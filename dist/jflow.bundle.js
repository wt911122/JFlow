!function(Q,U){"object"==typeof exports&&"object"==typeof module?module.exports=U():"function"==typeof define&&define.amd?define([],U):"object"==typeof exports?exports["@joskii/jflow"]=U():Q["@joskii/jflow"]=U()}(self,(function(){return(()=>{"use strict";var __webpack_modules__={406:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "BaseLink": () => (/* reexport */ base_link),\n  "BezierLink": () => (/* reexport */ bezier_link),\n  "Capsule": () => (/* reexport */ capsule),\n  "CapsuleGroup": () => (/* reexport */ CapsuleGroup),\n  "CapsuleVertical": () => (/* reexport */ capsule_vertical),\n  "CapsuleVerticalGroup": () => (/* reexport */ CapsuleVerticalGroup),\n  "Diamond": () => (/* reexport */ diamond),\n  "DiamondGroup": () => (/* reexport */ DiamondGroup),\n  "DiamondVerticalGroup": () => (/* reexport */ DiamondVerticalGroup),\n  "Group": () => (/* reexport */ Group),\n  "GroupFactory": () => (/* reexport */ groupFactory),\n  "Icon": () => (/* reexport */ instance_image),\n  "Instance": () => (/* reexport */ instance_instance),\n  "JFLOW_MODE": () => (/* reexport */ JFLOW_MODE),\n  "JFlowEvent": () => (/* reexport */ events),\n  "LinearLayout": () => (/* reexport */ linear_layout),\n  "Link": () => (/* reexport */ instance_link),\n  "Node": () => (/* reexport */ node),\n  "NodePlaceholder": () => (/* reexport */ NodePlaceholder),\n  "Point": () => (/* reexport */ point),\n  "PointGroup": () => (/* reexport */ PointGroup),\n  "PolyLink": () => (/* reexport */ poly_link),\n  "Rectangle": () => (/* reexport */ rectangle),\n  "Rhombus": () => (/* reexport */ rhombus),\n  "RhombusGroup": () => (/* reexport */ RhombusGroup),\n  "ScrollGroup": () => (/* reexport */ scroll_group),\n  "ShadowDom": () => (/* reexport */ shadowDom),\n  "Text": () => (/* reexport */ elements_text),\n  "TextElement": () => (/* reexport */ TextElement),\n  "TextGroup": () => (/* reexport */ text_group),\n  "addReflowWork": () => (/* reexport */ dirty_work_addReflowWork),\n  "commonEventAdapter": () => (/* reexport */ commonAdapter),\n  "default": () => (/* binding */ src)\n});\n\n;// CONCATENATED MODULE: ./package.json\nconst package_namespaceObject = {"i8":"1.0.6"};\n;// CONCATENATED MODULE: ./src/core/utils/canvas.js\n/**\n * @typedef {Object} CanvasMeta\n * @property {Element} canvas - canvas 元素\n * @property {number} width - 画布宽度\n * @property {number} height - 画布高度\n * @property {number} raw_width - 画布元素宽度\n * @property {number} raw_height - 画布元素高度\n * @property {number} left - 画布距离左端距离\n * @property {number} top - 画布距离顶端距离\n * @property {Context2d} ctx - Context2d\n * @property {number} scale - 当前的像素设备比\n */\n/**\n * 创建一个 canvas 元素\n * @param  {Element} wrapper - dom元素\n * @return {CanvasMeta}\n */\nfunction createCanvas(wrapper) {\n  var canvas = document.createElement(\'canvas\');\n  var ctx = canvas.getContext(\'2d\');\n  var _wrapper$getBoundingC = wrapper.getBoundingClientRect(),\n    width = _wrapper$getBoundingC.width,\n    height = _wrapper$getBoundingC.height,\n    left = _wrapper$getBoundingC.left,\n    top = _wrapper$getBoundingC.top;\n  canvas.style.width = width + "px";\n  canvas.style.height = height + "px";\n  canvas.style.userSelect = \'none\';\n  var scale = window.devicePixelRatio;\n  canvas.width = Math.floor(width * scale);\n  canvas.height = Math.floor(height * scale);\n  if (wrapper) {\n    wrapper.style.position = \'relative\';\n    wrapper.style.overflow = \'hidden\';\n    wrapper.append(canvas);\n  }\n  return {\n    canvas: canvas,\n    width: width,\n    height: height,\n    raw_width: canvas.width,\n    raw_height: canvas.height,\n    left: left,\n    top: top,\n    ctx: ctx,\n    scale: scale\n  };\n}\nfunction canvas_resizeCanvas(canvas, wrapper) {\n  var _wrapper$getBoundingC2 = wrapper.getBoundingClientRect(),\n    width = _wrapper$getBoundingC2.width,\n    height = _wrapper$getBoundingC2.height,\n    left = _wrapper$getBoundingC2.left,\n    top = _wrapper$getBoundingC2.top;\n  canvas.style.width = width + "px";\n  canvas.style.height = height + "px";\n  var scale = window.devicePixelRatio;\n  canvas.width = Math.floor(width * scale);\n  canvas.height = Math.floor(height * scale);\n  return {\n    width: width,\n    height: height,\n    raw_width: canvas.width,\n    raw_height: canvas.height\n  };\n}\nvar caheCanvas = document.createElement(\'canvas\');\ncaheCanvas.width = 1;\ncaheCanvas.height = 1;\nvar caheCanvasctx = caheCanvas.getContext(\'2d\');\nvar scale = window.devicePixelRatio;\ncaheCanvasctx.scale(scale, scale);\n\n/**\n * 在离线canvas上绘制元素\n * @param  {render} render - 绘图函数\n */\nfunction requestCacheCanvas(render) {\n  caheCanvasctx.clearRect(0, 0, 5, 5);\n  caheCanvasctx.save();\n  render(caheCanvasctx);\n  caheCanvasctx.restore();\n  caheCanvasctx.clearRect(0, 0, 5, 5);\n}\nfunction listenOnDevicePixelRatio(callback, destroyHandler) {\n  var target = matchMedia("(resolution: ".concat(window.devicePixelRatio, "dppx)"));\n  function onChange() {\n    console.log("devicePixelRatio changed: " + window.devicePixelRatio);\n    callback(window.devicePixelRatio);\n    listenOnDevicePixelRatio(callback, destroyHandler);\n  }\n  destroyHandler(function () {\n    console.log(\'remove devicePixelRatio event handler\');\n    target.removeEventListener("change", onChange, {\n      once: true\n    });\n  });\n  target.addEventListener("change", onChange, {\n    once: true\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/bezier-js/src/utils.js\n\n\n// math-inlining.\nconst { abs, cos, sin, acos, atan2, sqrt, pow } = Math;\n\n// cube root function yielding real roots\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n}\n\n// trig constants\nconst pi = Math.PI,\n  tau = 2 * pi,\n  quart = pi / 2,\n  // float precision significant decimal\n  epsilon = 0.000001,\n  // extremas used in bbox calculation and similar algorithms\n  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n  // a zero coordinate, which is surprisingly useful\n  ZERO = { x: 0, y: 0, z: 0 };\n\n// Bezier utility functions\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [\n    -0.0640568928626056260850430826247450385909,\n    0.0640568928626056260850430826247450385909,\n    -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404,\n    -0.3150426796961633743867932913198102407864,\n    0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524,\n    0.4337935076260451384870842319133497124524,\n    -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107,\n    -0.6480936519369755692524957869107476266696,\n    0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232,\n    0.7401241915785543642438281030999784255232,\n    -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761,\n    -0.8864155270044010342131543419821967550873,\n    0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548,\n    0.9382745520027327585236490017087214496548,\n    -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411,\n    -0.9951872199970213601799974097007368118745,\n    0.9951872199970213601799974097007368118745,\n  ],\n\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [\n    0.1279381953467521569740561652246953718517,\n    0.1279381953467521569740561652246953718517,\n    0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264,\n    0.121670472927803391204463153476262425607,\n    0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622,\n    0.1155056680537256013533444839067835598622,\n    0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946,\n    0.0976186521041138882698806644642471544279,\n    0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185,\n    0.086190161531953275917185202983742667185,\n    0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193,\n    0.0592985849154367807463677585001085845412,\n    0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593,\n    0.0442774388174198061686027482113382288593,\n    0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491,\n    0.0123412297999871995468056670700372915759,\n    0.0123412297999871995468056670700372915759,\n  ],\n\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== "undefined") {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points;\n\n    // constant?\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    }\n\n    // linear?\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n      return ret;\n    }\n\n    // quadratic/cubic curve?\n    if (order < 4) {\n      let mt2 = mt * mt,\n        t2 = t * t,\n        a,\n        b,\n        c,\n        d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n      return ret;\n    }\n\n    // higher order curves: use de Casteljau\'s computation\n    const dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,\n        };\n        if (typeof dCpts[i].z !== "undefined") {\n          dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n      r = ratios,\n      p = points;\n\n    let f1 = r[0],\n      f2 = r[1],\n      f3 = r[2],\n      f4 = r[3],\n      d;\n\n    // spec for linear\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to quadratic\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to cubic\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d\n          ? false\n          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t,\n      };\n    }\n  },\n\n  derive: function (points, _3d) {\n    const dpoints = [];\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y),\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n        list.push(dpt);\n      }\n      dpoints.push(list);\n      p = list;\n    }\n    return dpoints;\n  },\n\n  between: function (v, m, M) {\n    return (\n      (m <= v && v <= M) ||\n      utils.approximately(v, m) ||\n      utils.approximately(v, M)\n    );\n  },\n\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n\n  length: function (derivativeFn) {\n    const z = 0.5,\n      len = utils.Tvalues.length;\n\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n    return z * sum;\n  },\n\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n      d2 = te - ts,\n      v2 = v - ds,\n      r = v2 / d1;\n    return ts + d2 * r;\n  },\n\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y),\n    };\n    if (v1.z !== undefined && v2.z !== undefined) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n\n  pointToString: function (p) {\n    let s = p.x + "/" + p.y;\n    if (typeof p.z !== "undefined") {\n      s += "/" + p.z;\n    }\n    return s;\n  },\n\n  pointsToString: function (points) {\n    return "[" + points.map(utils.pointToString).join(", ") + "]";\n  },\n\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n      dy1 = v1.y - o.y,\n      dx2 = v2.x - o.x,\n      dy2 = v2.y - o.y,\n      cross = dx1 * dy2 - dy1 * dx2,\n      dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = "" + v;\n    const pos = s.indexOf(".");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n      dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n      mpos,\n      d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return { mdist: mdist, mpos: mpos };\n  },\n\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === "undefined") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const bottom = pow(t, n) + pow(1 - t, n),\n      top = bottom - 1;\n    return abs(top / bottom);\n  },\n\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === "undefined") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const top = pow(1 - t, n),\n      bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx =\n        (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d == 0) {\n      return false;\n    }\n    return { x: nx / d, y: ny / d };\n  },\n\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      x3 = p3.x,\n      y3 = p3.y,\n      x4 = p4.x,\n      y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n\n  makeline: function (p1, p2) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      dx = (x2 - x1) / 3,\n      dy = (y2 - y1) / 3;\n    return new Bezier(\n      x1,\n      y1,\n      x1 + dx,\n      y1 + dy,\n      x1 + 2 * dx,\n      y1 + 2 * dy,\n      x2,\n      y2\n    );\n  },\n\n  findbbox: function (sections) {\n    let mx = nMax,\n      my = nMax,\n      MX = nMin,\n      MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },\n    };\n  },\n\n  shapeintersections: function (\n    s1,\n    bbox1,\n    s2,\n    bbox2,\n    curveIntersectionThreshold\n  ) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end]),\n    };\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(\n        shape,\n        shape.bbox,\n        s2,\n        s2.bbox,\n        curveIntersectionThreshold\n      );\n    };\n    return shape;\n  },\n\n  getminmax: function (curve, d, list) {\n    if (!list) return { min: 0, max: 0 };\n    let min = nMax,\n      max = nMin,\n      t,\n      c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n      if (c[d] < min) {\n        min = c[d];\n      }\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n    return { min: min, mid: (min + max) / 2, max: max, size: max - min };\n  },\n\n  align: function (points, line) {\n    const tx = line.p1.x,\n      ty = line.p1.y,\n      a = -atan2(line.p2.y - ty, line.p2.x - tx),\n      d = function (v) {\n        return {\n          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a),\n        };\n      };\n    return points.map(d);\n  },\n\n  roots: function (points, line) {\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\n\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n        b = aligned[1].y,\n        c = aligned[2].y,\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n      return [];\n    }\n\n    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n    const pa = aligned[0].y,\n      pb = aligned[1].y,\n      pc = aligned[2].y,\n      pd = aligned[3].y;\n\n    let d = -pa + 3 * pb - 3 * pc + pd,\n      a = 3 * pa - 6 * pb + 3 * pc,\n      b = -3 * pa + 3 * pb,\n      c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        }\n        // linear solution:\n        return [-c / b].filter(reduce);\n      }\n      // quadratic solution:\n      const q = sqrt(b * b - 4 * a * c),\n        a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    }\n\n    // at this point, we know we need a cubic solution:\n\n    a /= d;\n    b /= d;\n    c /= d;\n\n    const p = (3 * b - a * a) / 3,\n      p3 = p / 3,\n      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n      q2 = q / 2,\n      discriminant = q2 * q2 + p3 * p3 * p3;\n\n    let u1, v1, x1, x2, x3;\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n        mp33 = mp3 * mp3 * mp3,\n        r = sqrt(mp33),\n        t = -q / (2 * r),\n        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n        phi = acos(cosphi),\n        crtr = crt(r),\n        t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n        b = p[1],\n        c = p[2],\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    }\n\n    // linear roots are even easier\n    if (p.length === 2) {\n      const a = p[0],\n        b = p[1];\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n      return [];\n    }\n\n    return [];\n  },\n\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n      dnm,\n      adk,\n      dk,\n      k = 0,\n      r = 0;\n\n    //\n    // We\'re using the following formula for curvature:\n    //\n    //              x\'y" - y\'x"\n    //   k(t) = ------------------\n    //           (x\'² + y\'²)^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y\'z" - y"z\')² + (z\'x" - z"x\')² + (x\'y" - x"y\')²)\n    //   k(t) = -------------------------------------------------------\n    //                     (x\'² + y\'² + z\'²)^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(\n        pow(d.y * dd.z - dd.y * d.z, 2) +\n          pow(d.z * dd.x - dd.z * d.x, 2) +\n          pow(d.x * dd.y - dd.x * d.y, 2)\n      );\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return { k: 0, r: 0 };\n    }\n\n    k = num / dnm;\n    r = dnm / num;\n\n    // We\'re also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we\'re just going to\n    // ballpark it based on an epsilon.\n    if (!kOnly) {\n      // compute k\'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return { k: k, r: r, dk: dk, adk: adk };\n  },\n\n  inflections: function (points) {\n    if (points.length < 4) return [];\n\n    // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),\n      a = p[2].x * p[1].y,\n      b = p[3].x * p[1].y,\n      c = p[1].x * p[2].y,\n      d = p[3].x * p[2].y,\n      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n      v2 = 18 * (3 * a - b - 3 * c),\n      v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n      return [];\n    }\n\n    const trm = v2 * v2 - 4 * v1 * v3,\n      sq = Math.sqrt(trm),\n      d2 = 2 * v1;\n\n    if (utils.approximately(d2, 0)) return [];\n\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n\n  bboxoverlap: function (b1, b2) {\n    const dims = ["x", "y"],\n      len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n    return true;\n  },\n\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n      c2b = c2.bbox(),\n      r = 100000,\n      threshold = curveIntersectionThreshold || 0.5;\n\n    if (\n      c1b.x.size + c1b.y.size < threshold &&\n      c2b.x.size + c2b.y.size < threshold\n    ) {\n      return [\n        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +\n          "/" +\n          (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,\n      ];\n    }\n\n    let cc1 = c1.split(0.5),\n      cc2 = c2.split(0.5),\n      pairs = [\n        { left: cc1.left, right: cc2.left },\n        { left: cc1.left, right: cc2.right },\n        { left: cc1.right, right: cc2.right },\n        { left: cc1.right, right: cc2.left },\n      ];\n\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n\n    let results = [];\n\n    if (pairs.length === 0) return results;\n\n    pairs.forEach(function (pair) {\n      results = results.concat(\n        utils.pairiteration(pair.left, pair.right, threshold)\n      );\n    });\n\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n\n    return results;\n  },\n\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n      dy1 = p2.y - p1.y,\n      dx2 = p3.x - p2.x,\n      dy2 = p3.y - p2.y,\n      dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n      dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n      dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n      dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n      // chord midpoints\n      mx1 = (p1.x + p2.x) / 2,\n      my1 = (p1.y + p2.y) / 2,\n      mx2 = (p2.x + p3.x) / 2,\n      my2 = (p2.y + p3.y) / 2,\n      // midpoint offsets\n      mx1n = mx1 + dx1p,\n      my1n = my1 + dy1p,\n      mx2n = mx2 + dx2p,\n      my2n = my2 + dy2p,\n      // intersection of these lines:\n      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n      r = utils.dist(arc, p1);\n\n    // arc start/end values, over mid point:\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n      m = atan2(p2.y - arc.y, p2.x - arc.x),\n      e = atan2(p3.y - arc.y, p3.x - arc.x),\n      _;\n\n    // determine arc direction (cw/ccw correction)\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    }\n    // assign and done.\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n\n  numberSort: function (a, b) {\n    return a - b;\n  },\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/bezier-js/src/poly-bezier.js\n\n\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return (\n      "[" +\n      this.curves\n        .map(function (curve) {\n          return utils.pointsToString(curve.points);\n        })\n        .join(", ") +\n      "]"\n    );\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves\n      .map(function (v) {\n        return v.length();\n      })\n      .reduce(function (a, b) {\n        return a + b;\n      });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/bezier-js/src/bezier.js\n/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\n\n\n\n// math-inlining.\nconst { abs: bezier_abs, min, max, cos: bezier_cos, sin: bezier_sin, acos: bezier_acos, sqrt: bezier_sqrt } = Math;\nconst bezier_pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst bezier_ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === "object") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        ["x", "y", "z"].forEach(function (d) {\n          if (typeof point[d] !== "undefined") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            "Only new Bezier(point[]) is accepted for 4th and higher order curves"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            "Only new Bezier(point[]) is accepted for 4th and higher order curves"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== "undefined"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = ["x", "y"]);\n    if (_3d) dims.push("z");\n    this.dimlen = dims.length;\n\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    this._linear = !aligned.some((p) => bezier_abs(p.y) > 0.0001);\n\n    this._lut = [];\n\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === "undefined") {\n      t = 0.5;\n    }\n    // shortcuts, although they\'re really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === "undefined") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === "undefined") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = ["M", x, y, this.order === 2 ? "Q" : "C"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(" ");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error("incorrect number of ratio values");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return "" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join("");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps) {\n      return this._lut;\n    }\n    this._lut = [];\n    // We want a range from 0 to 1 inclusive, so\n    // we decrement and then use <= rather than <:\n    steps--;\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = bezier_sqrt(d.x * d.x + d.y * d.y);\n    return { x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = bezier_sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = bezier_sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = bezier_sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use "de Casteljau" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we\'re done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== "undefined") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return bezier_abs(bezier_acos(s)) < bezier_pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (bezier_abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === "function") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for degenerate (=linear) curves.\n    const clockwise = this.clockwise;\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const points = this.points;\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error("cannot scale this curve. Try reducing it first.");\n    }\n    // move all points by distance \'d\' wrt the origin \'o\'\n\n    // move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by "however much necessary to\n    // ensure the correct tangent to endpoint".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = bezier_sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = typeof d2 === "undefined" ? d1 : d2;\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== "undefined" && typeof d4 !== "undefined";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the "return" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves),\n      slen = segments.length;\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // "simple" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return bezier_abs(d1 - ref) + bezier_abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the "good `t` closest to no-longer-good"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move \'e\' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we\'re done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc\'s end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * bezier_cos(arc.e),\n                y: arc.y + arc.r * bezier_sin(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move \'e\' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log("L835: [F] arc found", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\n\n\n;// CONCATENATED MODULE: ./src/core/utils/constance.js\n/**\n * 方向\n * @readonly\n * @enum {number}\n */\nvar DIRECTION = {\n  /** RIGHT */\n  RIGHT: 0,\n  /** BOTTOM */\n  BOTTOM: 1,\n  /** LEFT */\n  LEFT: 2,\n  /** TOP */\n  TOP: 3,\n  /** SELF */\n  SELF: 100\n};\nfunction nextDirection(direction, clockwise) {\n  var nextDir = (direction + (clockwise ? 1 : -1)) % 4;\n  return nextDir;\n}\nfunction oppositeDirection(direction) {\n  return (direction + 2) % 4;\n}\nvar APPROXIMATE = 6;\nvar JFLOW_MODE = {\n  DEFAULT: \'DEFAULT\',\n  LINKING: \'LINKING\'\n};\nvar LINE_DIR = {\n  FROM: \'from\',\n  TO: \'to\'\n};\n;// CONCATENATED MODULE: ./src/core/utils/functions.js\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n\n\n/**\n * 根据点计算最小外接矩形\n * @param {number[][]} points - 点集合\n * @return {Object} demension 宽高，坐标\n */\nfunction bounding_box(points) {\n  if (points.length === 0) {\n    return {\n      width: 1,\n      height: 1,\n      x: 0,\n      y: 0\n    };\n  }\n  var min_x = Infinity;\n  var min_y = Infinity;\n  var max_x = -Infinity;\n  var max_y = -Infinity;\n  for (var idx in points) {\n    var item = points[idx];\n    if (item[0] < min_x) {\n      min_x = item[0];\n    }\n    if (item[0] > max_x) {\n      max_x = item[0];\n    }\n    if (item[1] < min_y) {\n      min_y = item[1];\n    }\n    if (item[1] > max_y) {\n      max_y = item[1];\n    }\n  }\n  return {\n    // points: [(min_x,min_y),(max_x,min_y),(max_x,max_y),(min_x,max_y)],\n    width: Math.max(max_x - min_x, 10),\n    height: Math.max(max_y - min_y, 10),\n    x: min_x,\n    y: min_y\n  };\n}\nfunction sqr(x) {\n  return x * x;\n}\nfunction dist2(v, w) {\n  return sqr(v[0] - w[0]) + sqr(v[1] - w[1]);\n}\n\n// p - point\n// v - start point of segment\n// w - end point of segment\nfunction distToSegmentSquared(p, v, w) {\n  var l2 = dist2(v, w);\n  if (l2 === 0) return dist2(p, v);\n  var t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\n  t = Math.max(0, Math.min(1, t));\n  return dist2(p, [v[0] + t * (w[0] - v[0]), v[1] + t * (w[1] - v[1])]);\n}\nfunction minIntersectionBetweenNodes(dmsfrom, dmsto) {\n  var meta = {\n    fromDir: null,\n    fromP: null,\n    toDir: null,\n    toP: null,\n    distMin: Infinity\n  };\n  Object.keys(dmsfrom).forEach(function (df) {\n    if (+df === DIRECTION.SELF) {\n      return;\n    }\n    var pf = dmsfrom[df];\n    Object.keys(dmsto).forEach(function (dt) {\n      if (+dt === DIRECTION.SELF) {\n        return;\n      }\n      var pt = dmsto[dt];\n      var dist = dist2(pf, pt);\n      if (dist < meta.distMin) {\n        Object.assign(meta, {\n          distMin: dist,\n          fromDir: +df,\n          fromP: pf,\n          toDir: +dt,\n          toP: pt\n        });\n      }\n    });\n  });\n  return meta;\n}\n\n// export function bezierPoints(p1, p2, start_dir = DIRECTION.TOP, end_dir = DIRECTION.TOP, anticlock = false) {\n//     const isSameDirection = start_dir === end_dir;\n//     const isVerticalStart = [DIRECTION.TOP, DIRECTION.BOTTOM].includes(start_dir);   \n//     const isVerticalEnd = [DIRECTION.TOP, DIRECTION.BOTTOM].includes(end_dir);\n//     const arrowspan = [DIRECTION.TOP, DIRECTION.LEFT].includes(end_dir) ? -5 : 5;\n//     const endX = isVerticalEnd ? p2[0] : p2[0] + arrowspan;\n//     const endY = isVerticalEnd ? p2[1] + arrowspan : p2[1];\n//     if(isSameDirection) {\n//         let span = Math.abs(isVerticalStart ? (endY - p1[1]) : (endX - p1[0]))\n//         span = Math.min(span, 50);\n//         const symb = [DIRECTION.RIGHT, DIRECTION.BOTTOM].includes(end_dir)\n//         span = symb ? span : - span;\n//         const cp1 = isVerticalStart ? [p1[0], p1[1] + span] : [p1[0] + span, p1[1]];\n//         const cp2 = isVerticalEnd ? [endX, endY + span] : [endX + span, endY];\n//         return [ \n//             ...cp1,\n//             ...cp2,\n//             endX, endY ];\n//     }\n//     let spanStart = (anticlock ? -5 : 1) * (isVerticalStart ? (endY - p1[1]) / 2 : (endX - p1[0]) / 2)\n//     let spanEnd = (anticlock ? -4 : 1) * (isVerticalEnd ? (p1[1] - endY) / 2 : (p1[0] - endX) / 2)\n//     let u1 = spanStart / Math.abs(spanStart);\n//     spanStart = u1 * Math.min(Math.abs(spanStart), 50);\n//     let u2 = spanEnd / Math.abs(spanEnd);\n//     spanEnd = u2 * Math.min(Math.abs(spanEnd), 50);\n//     const cp1 = isVerticalStart ? [p1[0], p1[1] + spanStart] : [p1[0] + spanStart, p1[1]];\n//     const cp2 = isVerticalEnd ? [endX, endY + spanEnd] : [endX + spanEnd, endY];\n//     return [ \n//         ...cp1,\n//         ...cp2,\n//         endX, endY ];\n// }\nfunction _resolveControlPoint(p, dir, spanx, spany) {\n  if (dir === DIRECTION.TOP) {\n    return [p[0], p[1] - spany];\n  }\n  if (dir === DIRECTION.BOTTOM) {\n    return [p[0], p[1] + spany];\n  }\n  if (dir === DIRECTION.LEFT) {\n    return [p[0] - spanx, p[1]];\n  }\n  if (dir === DIRECTION.RIGHT) {\n    return [p[0] + spanx, p[1]];\n  }\n}\nfunction bezierPoints(p1, p2) {\n  var start_dir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DIRECTION.TOP;\n  var end_dir = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DIRECTION.TOP;\n  var minSpanX = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  var minSpanY = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  var spanx = Math.max(Math.abs((p1[0] - p2[0]) / 2), minSpanX);\n  var spany = Math.max(Math.abs((p1[1] - p2[1]) / 2), minSpanY);\n  var cp1 = _resolveControlPoint(p1, start_dir, spanx, spany);\n  var cp2 = _resolveControlPoint(p2, end_dir, spanx, spany);\n  var arrowspan = [DIRECTION.TOP, DIRECTION.LEFT].includes(end_dir) ? -5 : 5;\n  var isVerticalEnd = [DIRECTION.TOP, DIRECTION.BOTTOM].includes(end_dir);\n  var endX = isVerticalEnd ? p2[0] : p2[0] + arrowspan;\n  var endY = isVerticalEnd ? p2[1] + arrowspan : p2[1];\n  return [].concat(_toConsumableArray(cp1), _toConsumableArray(cp2), [endX, endY]);\n}\nfunction bezierPoint(t, P) {\n  var q = 1 - t;\n  var x = q * q * q * P[0] + 3 * q * q * t * P[2] + 3 * q * t * t * P[4] + t * t * t * P[6];\n  var y = q * q * q * P[1] + 3 * q * q * t * P[3] + 3 * q * t * t * P[5] + t * t * t * P[7];\n  var u = q * q * (P[2] - P[0]) + 2 * t * q * (P[4] - P[2]) + t * t * (P[6] - P[4]);\n  var v = q * q * (P[3] - P[1]) + 2 * t * q * (P[5] - P[3]) + t * t * (P[7] - P[5]);\n  var angle = Math.atan2(v, u);\n  // console.log(angle * 180)\n  // if(angle < 0) {\n  //     angle = Math.PI + angle;\n  // }\n  return [x, y, angle];\n}\n\n// export function bezierPoints(p1, p2, start_vec, end_vec) {\n\n// }\n\nfunction distToBezierSegmentSquared(p, points) {\n  var b = _construct(Bezier, _toConsumableArray(points));\n  var point = b.project({\n    x: p[0],\n    y: p[1]\n  });\n  var d = dist2(p, [point.x, point.y]);\n  return d;\n}\nfunction getBezierAngle(t, sx, sy, cp1x, cp1y, cp2x, cp2y, ex, ey) {\n  var dx = Math.pow(1 - t, 2) * (cp1x - sx) + 2 * t * (1 - t) * (cp2x - cp1x) + t * t * (ex - cp2x);\n  var dy = Math.pow(1 - t, 2) * (cp1y - sy) + 2 * t * (1 - t) * (cp2y - cp1y) + t * t * (ey - cp2y);\n  return -Math.atan2(dx, dy) + 0.5 * Math.PI;\n}\nfunction getInstanceHeight(instance) {\n  var rect = instance.getBoundingRect();\n  // let min_y = Infinity;\n  // let max_y = -Infinity;\n  // let min_x = Infinity;\n  // let max_x = -Infinity;\n  // rect.forEach(point => {\n  //     max_y = Math.max(max_y, point[1]);\n  //     min_y = Math.min(min_y, point[1]);\n  //     max_x = Math.max(max_x, point[0]);\n  //     min_x = Math.min(min_x, point[0]);\n  // });\n  return {\n    height: rect[3] - rect[1],\n    width: rect[2] - rect[0]\n  };\n}\nfunction polylinePoints(points, p1, p2) {\n  var start_dir = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DIRECTION.TOP;\n  var end_dir = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DIRECTION.TOP;\n  var minSpanX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 10;\n  var minSpanY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 10;\n  var isSelf = arguments.length > 7 ? arguments[7] : undefined;\n  var dirSpan = Math.abs(start_dir - end_dir);\n  // const spanx = Math.max(Math.abs((p1[0] - p2[0])/2), minSpanX);\n  // const spany = Math.max(Math.abs((p1[1] - p2[1])/2), minSpanY);\n  var isVerticalStart = start_dir === DIRECTION.TOP || start_dir === DIRECTION.BOTTOM;\n  points.length = 0;\n  switch (dirSpan) {\n    case 0:\n      // 都按向右好了\n      if (start_dir === DIRECTION.TOP) {\n        var y = Math.min(p1[1], p2[1]);\n        var yp = y - minSpanY;\n        points.push([p1[0], yp]);\n        points.push([p2[0], yp]);\n      }\n      if (start_dir === DIRECTION.BOTTOM) {\n        var _y = Math.max(p1[1], p2[1]);\n        var _yp = _y + minSpanY;\n        points.push([p1[0], _yp]);\n        points.push([p2[0], _yp]);\n      }\n      if (start_dir === DIRECTION.LEFT) {\n        var x = Math.min(p1[0], p2[0]);\n        var xp = x - minSpanX;\n        points.push([xp, p1[1]]);\n        points.push([xp, p2[1]]);\n      }\n      if (start_dir === DIRECTION.RIGHT) {\n        var _x = Math.max(p1[0], p2[0]);\n        var _xp = _x + minSpanX;\n        points.push([_xp, p1[1]]);\n        points.push([_xp, p2[1]]);\n      }\n      break;\n    case 1:\n    case 3:\n      if (isSelf) {\n        if (!isVerticalStart) {\n          points.push([p1[0] + minSpanX, p1[1]]);\n          points.push([p1[0] + minSpanX, p2[1] + minSpanY]);\n          points.push([p2[0], p2[1] + minSpanY]);\n        } else {\n          points.push([p1[0], p1[1] + minSpanY]);\n          points.push([p2[0] + minSpanX, p1[1] + minSpanY]);\n          points.push([p2[0] + minSpanX, p2[1]]);\n        }\n      } else {\n        var point = isVerticalStart ? [p1[0], p2[1]] : [p2[0], p1[1]];\n        points.push(point);\n      }\n      break;\n    case 2:\n      var pmiddle = [(p1[0] - p2[0]) / 2 + p2[0], (p1[1] - p2[1]) / 2 + p2[1]];\n      if (isVerticalStart) {\n        points.push([p1[0], pmiddle[1]]);\n        points.push([p2[0], pmiddle[1]]);\n      } else {\n        points.push([pmiddle[0], p1[1]]);\n        points.push([pmiddle[0], p2[1]]);\n      }\n      break;\n    default:\n      break;\n  }\n  points.unshift(p1);\n  points.push(p2);\n}\nfunction minusVec(p1, p2) {\n  return [p1[0] - p2[0], p1[1] - p2[1]];\n}\nfunction absVec(vec) {\n  return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);\n}\nfunction scaleVec(vec, scale) {\n  return [vec[0] * scale, vec[1] * scale];\n}\nfunction makeRadiusFromVector(pbefore, p, pnext, radius) {\n  var vec1 = minusVec(p, pbefore);\n  var vec2 = minusVec(p, pnext);\n  var absVec1 = absVec(vec1);\n  var absVec2 = absVec(vec2);\n  if (!absVec1 || !absVec2) {\n    return {\n      p1: null,\n      p2: null\n    };\n  }\n  var r1 = scaleVec(vec1, radius / absVec1);\n  var r2 = scaleVec(vec2, radius / absVec2);\n  return {\n    p1: minusVec(p, r1),\n    p2: minusVec(p, r2)\n  };\n}\n// 矩形重叠计算\nfunction doOverlap(rec1, rec2) {\n  if (rec1[0] == rec1[2] || rec1[1] == rec1[3] || rec2[0] == rec2[2] || rec2[1] == rec2[3]) {\n    // the line cannot have positive overlap\n    return false;\n  }\n  return !(rec1[2] <= rec2[0] ||\n  // left\n  rec1[3] <= rec2[1] ||\n  // bottom\n  rec1[0] >= rec2[2] ||\n  // right\n  rec1[1] >= rec2[3]); // top\n}\n\nfunction isPolyLineIntersectionRectange(polyline, rect) {\n  var p = polyline[0];\n  var l = polyline.length;\n  var i = 1;\n  var _rect = _slicedToArray(rect, 4),\n    l0 = _rect[0],\n    l1 = _rect[1],\n    r0 = _rect[2],\n    r1 = _rect[3];\n  while (i < l) {\n    var cp = polyline[i];\n    if (p[0] === cp[0]) {\n      // vertical\n      if (p[0] < r0 && p[0] > l0 && !(p[1] > r1 && cp[1] > r1 || p[1] < l1 && cp[1] < l1)) {\n        return true;\n      }\n    } else {\n      // horizontal\n      if (p[1] < r1 && p[1] > l1 && !(p[0] > r0 && cp[0] > r0 || p[0] < l0 && cp[0] < l0)) {\n        return true;\n      }\n    }\n    p = cp;\n    i++;\n  }\n  return false;\n}\nfunction debounce(func) {\n  var _this = this;\n  var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;\n  var timer;\n  return function () {\n    clearTimeout(timer);\n    timer = setTimeout(function () {\n      func.call(_this);\n    }, timeout);\n  };\n}\nfunction compareBoundingbox(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\nfunction copyBoundingbox(a, b) {\n  a[0] = b[0];\n  a[1] = b[1];\n  a[2] = b[2];\n  a[3] = b[3];\n}\n;// CONCATENATED MODULE: ./src/core/instance/instance.js\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) instance_setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = instance_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return instance_construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return instance_setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction instance_construct(Parent, args, Class) { if (instance_isNativeReflectConstruct()) { instance_construct = Reflect.construct.bind(); } else { instance_construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) instance_setPrototypeOf(instance, Class.prototype); return instance; }; } return instance_construct.apply(null, arguments); }\nfunction instance_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }\nfunction instance_setPrototypeOf(o, p) { instance_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return instance_setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n// import { setUniqueId, getUniqueId } from \'../utils/functions\';\n// import { nextDirection } from \'../utils/constance\';\n// const margin = 5;\nvar ishitKey = Symbol(\'ishit\');\nvar isInViewBox = Symbol(\'isInViewBox\');\n/**\n * @typedef Instance~Configs\n * @type {object}\n * @property {number} borderWidth      - 边的宽度 默认是 2\n * @property {string} borderColor      - 边框颜色 默认 black\n * @property {string} color            - 填充颜色 默认 white\n * @property {string} shadowColor      - 阴影颜色\n * @property {string} shadowBlur       - 阴影扩散范围\n * @property {string} shadowOffsetX    - 阴影偏移 X\n * @property {string} shadowOffsetX    - 阴影偏移 Y\n */\n\n/** \n * 图中的最小单元\n * @constructor Instance\n * @extends EventTarget\n * @param {Instance~Configs} configs - 最小单元的一些通用属性配置\n */\nvar Instance = /*#__PURE__*/function (_EventTarget) {\n  _inherits(Instance, _EventTarget);\n  var _super = _createSuper(Instance);\n  function Instance() {\n    var _this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, Instance);\n    _this = _super.call(this);\n    Object.assign(_assertThisInitialized(_this), configs);\n    // this.anchor = configs.anchor || [0, 0];\n    // this.belongs = undefined;\n    /** @member {boolean}      - 元素可见 默认 true */\n    _this.visible = true;\n    // this._jflow = undefined;\n    _this._belongs = undefined;\n    _this[ishitKey] = false;\n\n    /** @member {number}      - 边的宽度 默认是 0 */\n    _this.borderWidth = configs.borderWidth || 0;\n    /** @member {string}     - 边框颜色 默认 transparent */\n    _this.borderColor = configs.borderColor || \'transparent\';\n    /** @member {string}     - 填充颜色 默认 transparent */\n    _this.backgroundColor = configs.backgroundColor || \'transparent\';\n    /** @member {string}     - 阴影颜色 空就不显示阴影 */\n    _this.shadowColor = configs.shadowColor;\n    /** @member {string}     - 阴影扩散范围 默认 5 */\n    _this.shadowBlur = configs.shadowBlur || 5;\n    /** @member {string}     - 阴影偏移 X */\n    _this.shadowOffsetX = configs.shadowOffsetX || 0;\n    /** @member {string}     - 阴影偏移 Y */\n    _this.shadowOffsetY = configs.shadowOffsetY || 0;\n    /** @member {number}     - 透明度 */\n    _this.opacity = configs.opacity || 1;\n    _this._boundingrect = [0, 0, 0, 0];\n    return _this;\n  }\n  /**\n   * @member {boolean} - 当前单元选中状态\n   */\n  _createClass(Instance, [{\n    key: "_isTargeting",\n    get: function get() {\n      return this === (this._jflow._target.instance || this._jflow._target.link);\n    }\n    /**\n     * @member {boolean} - 当前单元移动状态\n     */\n  }, {\n    key: "_isMoving",\n    get: function get() {\n      return this === this._jflow._getMovingTarget() && this._jflow._target.status.movingState; // 移动了之后才能被当做移动状态\n    }\n    /**\n     * @member {boolean}  - 当前单元碰撞检测状态\n     */\n  }, {\n    key: "_isHit",\n    get: function get() {\n      return this[ishitKey];\n    }\n    /**\n     * @member {JFlow}  - canvas上 jflow 实体\n     */,\n    set: function set(ishit) {\n      if (this[ishitKey] !== ishit) {\n        /**\n         * 鼠标移入事件\n         *\n         * @event Instance#mouseenter\n         * @type {object}\n         * @property {Instance} instance      - 移入的对象 \n         */\n        /**\n         * 鼠标移出事件\n         *\n         * @event Instance#mouseleave\n         * @type {object}\n         * @property {Instance} instance      - 移入的对象 \n         */\n        this.dispatchEvent(new CustomEvent(ishit ? \'mouseenter\' : \'mouseleave\', {\n          detail: {\n            instance: this,\n            jflow: this._jflow\n          }\n        }));\n      }\n      this[ishitKey] = ishit; // validation could be checked here such as only allowing non numerical values\n    }\n  }, {\n    key: "_jflow",\n    get: function get() {\n      if (this._jflowRoot) {\n        return this._jflowRoot;\n      }\n      if (!this._belongs) {\n        return undefined;\n      }\n      return this._belongs.uniqueName === \'jflow\' ? this._belongs : this._belongs._jflow;\n    }\n  }, {\n    key: "isInViewBox",\n    get: function get() {\n      return this[isInViewBox];\n    }\n  }, {\n    key: "_isInViewBox",\n    set: function set(val) {\n      var oldval = this[isInViewBox];\n      if (val !== oldval) {\n        if (val) {\n          this.onEnterViewbox();\n        } else {\n          this.onLeaveViewbox();\n        }\n      }\n      this[isInViewBox] = val;\n    }\n\n    /**\n     * 当节点离开可视区域的回调\n     */\n  }, {\n    key: "onEnterViewbox",\n    value: function onEnterViewbox() {\n      return;\n    }\n\n    /**\n     * 当节点离开可视区域的回调\n     */\n  }, {\n    key: "onLeaveViewbox",\n    value: function onLeaveViewbox() {\n      return;\n    }\n\n    /**\n     * 改变当前配置\n     * @param {Configs} configs - The string containing two comma-separated numbers.\n     */\n  }, {\n    key: "setConfig",\n    value: function setConfig(configs) {\n      var _this2 = this;\n      Object.keys(configs).forEach(function (k) {\n        if (configs[k] !== undefined && configs[k] !== null) {\n          _this2[k] = configs[k];\n        }\n      });\n    }\n    /**\n     * 绘制单元\n     * @param {Context2d} ctx \n     */\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      throw \'require render implement\';\n    }\n    /**\n     * 判断当前单元是否被命中\n     * @param {number[]} point \n     * @return {Boolean}\n     */\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      throw \'require isHit implement\';\n    }\n    /**\n     * 计算当前的最大外接矩形的\n     * @return {number[]} [leftx, lefty, rightx, righty]\n     */\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      throw \'require getBoundingRect implement\';\n    }\n  }, {\n    key: "calculateIntersection",\n    value: function calculateIntersection() {\n      throw \'require calculateIntersection implement\';\n    }\n    /**\n     * 计算当前连线接入点的位置\n     * @return {Object} intersection 交叉点\n     * @return {number} intersection[DIRECTION.TOP] 上\n     * @return {number} intersection[DIRECTION.BOTTOM] 下\n     * @return {number} intersection[DIRECTION.LEFT] 上\n     * @return {number} intersection[DIRECTION.RIGHT] 右\n     */\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      throw \'require getIntersectionsInFourDimension implement\';\n    }\n\n    /**\n     * 获取当前所在层级的坐标\n     * @return {Number[]} 坐标\n     */\n  }, {\n    key: "getCenter",\n    value: function getCenter() {\n      return this.anchor;\n    }\n    /**\n     * 获取宽高\n     * @return {Object} demension 宽高\n     * @return {number} demension.width 宽\n     * @return {number} demension.height 高\n     */\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      var rect = instance.getBoundingRect();\n      var min_y = Infinity;\n      var max_y = -Infinity;\n      var min_x = Infinity;\n      var max_x = -Infinity;\n      rect.forEach(function (point) {\n        max_y = Math.max(max_y, point[1]);\n        min_y = Math.min(min_y, point[1]);\n        max_x = Math.max(max_x, point[0]);\n        min_x = Math.min(min_x, point[0]);\n      });\n      return {\n        height: max_y - min_y,\n        width: max_x - min_x\n      };\n    }\n    /**\n     * 冒泡事件\n     * @param {JFlowEvent} customEvent 自定义事件\n     */\n  }, {\n    key: "bubbleEvent",\n    value: function bubbleEvent(customEvent) {\n      customEvent.detail.currentTarget = this;\n      this.dispatchEvent(customEvent);\n      if (customEvent.detail.bubbles) {\n        if (this._belongs.bubbleEvent) {\n          this._belongs.bubbleEvent(customEvent);\n        } else {\n          this._belongs.dispatchEvent(customEvent);\n        }\n      }\n    }\n    /**\n     * 反算回页面的像素坐标\n     * @param {Number[]} point\n     * @return {Number[]} 世界坐标\n     */\n  }, {\n    key: "calculateToRealWorld",\n    value: function calculateToRealWorld(point) {\n      if (this._belongs && this._belongs.calculateToRealWorld) {\n        return this._belongs.calculateToRealWorld(point);\n      } else {\n        return point;\n      }\n    }\n  }, {\n    key: "calculateToRealWorldWithPointer",\n    value: function calculateToRealWorldWithPointer(outpoint, inpoint) {\n      if (this._belongs && this._belongs.calculateToRealWorldWithPointer) {\n        this._belongs.calculateToRealWorldWithPointer(outpoint, inpoint);\n      }\n    }\n  }, {\n    key: "calculateToRealWorldWithScalar",\n    value: function calculateToRealWorldWithScalar(length) {\n      return this._jflow.scale * length;\n    }\n\n    /**\n     * 从当前布局中删除虚拟布局节点\n     */\n    // removeFromLayoutSource() {\n    //     if(this._layoutNode) {\n    //         this._layoutNode.remove();\n    //     }\n    // }\n  }, {\n    key: "recalculateUp",\n    value: function recalculateUp() {\n      if (this._belongs) {\n        this._belongs.recalculateUp();\n      }\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      // this._belongs = undefined;\n      // this.removeEventListener();\n    }\n  }]);\n  return Instance;\n}( /*#__PURE__*/_wrapNativeSuper(EventTarget));\n/* harmony default export */ const instance_instance = (Instance);\n;// CONCATENATED MODULE: ./src/core/dirty-work/dirty-work.js\nfunction dirty_work_slicedToArray(arr, i) { return dirty_work_arrayWithHoles(arr) || dirty_work_iterableToArrayLimit(arr, i) || dirty_work_unsupportedIterableToArray(arr, i) || dirty_work_nonIterableRest(); }\nfunction dirty_work_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction dirty_work_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return dirty_work_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dirty_work_arrayLikeToArray(o, minLen); }\nfunction dirty_work_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction dirty_work_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction dirty_work_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar queue = [];\nvar clearQueue = [];\nvar queueSet = new WeakSet();\nvar checkWork = function checkWork(target) {\n  return queueSet.has(target);\n};\nvar getStackPath = function getStackPath(node) {\n  var t = node;\n  var exp = 1;\n  var p = \'\';\n  while (t && t._belongs) {\n    var idx = t._belongs._stack.findIndex(function (n) {\n      return n === t;\n    });\n    p = idx + (p && \'.\' + p);\n    t = t._belongs;\n  }\n  return p;\n};\nvar sortByPath = function sortByPath() {\n  var map = new WeakMap();\n  queue.sort(function (a, b) {\n    var apath = map.get(a);\n    if (apath === undefined) {\n      apath = getStackPath(a);\n      map.set(a, apath);\n    }\n    var bpath = map.get(b);\n    if (bpath === undefined) {\n      bpath = getStackPath(b);\n      map.set(b, bpath);\n    }\n    var _a = apath.split(\'.\');\n    var _b = bpath.split(\'.\');\n    if (_a.length < _b.length) {\n      return 1;\n    }\n    if (_a.length > _b.length) {\n      return -1;\n    }\n    for (var i = 0; i < _a.length; i++) {\n      var _p = +_a[i];\n      var _q = +_b[i];\n      if (_p < _q) {\n        return 1;\n      }\n      if (_p > _q) {\n        return -1;\n      }\n    }\n    return 0;\n  });\n};\nvar addClearSourceWork = function addClearSourceWork(jflow, source) {\n  clearQueue.push([jflow, source]);\n};\n\n// work is sync function!!\nvar dirty_work_addReflowWork = function addReflowWork(target, parent) {\n  if (target.doRecalculate) {\n    if (!queueSet.has(target)) {\n      queue.push(target);\n      queueSet.add(target);\n    }\n  }\n  if (parent && parent.doRecalculate && !queueSet.has(parent)) {\n    queue.push(parent);\n    queueSet.add(parent);\n  }\n\n  // if(target.doRecalculate) {\n  //     if(!checkWork(target)) {\n  //         queue.push(target);\n  //         queueSet.add(target);\n  //     }\n  // }  \n  // if(parent) {\n  //     if(checkWork(parent)) {\n  //         const idx = queue.findIndex(p => p === parent);\n  //         queue.splice(idx, 1);\n  //         queue.push(parent);\n  //     } else {\n  //         queue.push(parent);\n  //         queueSet.add(parent);\n  //     }\n\n  // }\n  flush();\n};\nvar inFlush = false;\nvar flush = function flush() {\n  if (inFlush) {\n    return;\n  }\n  inFlush = true;\n  requestAnimationFrame(function () {\n    var roots = new Set();\n    sortByPath();\n    while (queue.length) {\n      var target = queue.shift();\n      if (target.doRecalculate) {\n        target.doRecalculate();\n        roots.add(target._jflow);\n      }\n      // console.log(target.width, target.height)\n    }\n\n    while (clearQueue.length) {\n      var _clearQueue$shift = clearQueue.shift(),\n        _clearQueue$shift2 = dirty_work_slicedToArray(_clearQueue$shift, 2),\n        jflow = _clearQueue$shift2[0],\n        source = _clearQueue$shift2[1];\n      if (!jflow.getRenderNodeBySource(source)) {\n        jflow.clearSource(source);\n      }\n    }\n    // console.log(\'-----dirty---flush-----\')\n    queueSet = new WeakSet();\n    inFlush = false;\n    Array.from(roots).forEach(function (jflow) {\n      jflow._render();\n    });\n  });\n};\n;// CONCATENATED MODULE: ./src/core/instance/node.js\nfunction node_typeof(obj) { "@babel/helpers - typeof"; return node_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, node_typeof(obj); }\nfunction node_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction node_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, node_toPropertyKey(descriptor.key), descriptor); } }\nfunction node_createClass(Constructor, protoProps, staticProps) { if (protoProps) node_defineProperties(Constructor.prototype, protoProps); if (staticProps) node_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction node_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) node_setPrototypeOf(subClass, superClass); }\nfunction node_setPrototypeOf(o, p) { node_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return node_setPrototypeOf(o, p); }\nfunction node_createSuper(Derived) { var hasNativeReflectConstruct = node_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = node_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = node_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return node_possibleConstructorReturn(this, result); }; }\nfunction node_possibleConstructorReturn(self, call) { if (call && (node_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return node_assertThisInitialized(self); }\nfunction node_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction node_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction node_getPrototypeOf(o) { node_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return node_getPrototypeOf(o); }\nfunction _defineProperty(obj, key, value) { key = node_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction node_toPropertyKey(arg) { var key = node_toPrimitive(arg, "string"); return node_typeof(key) === "symbol" ? key : String(key); }\nfunction node_toPrimitive(input, hint) { if (node_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (node_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n\n\n/**\n * 绝对定位 配置， 绝对定位不受布局影响，相对于当前组来定位\n * @typedef {object} Node~AbsolutePosition \n * @property {number} top       - 上距离\n * @property {number} bottom    - 下距离\n * @property {number} right     - 右距离\n * @property {number} left      - 左距离\n */\n/**\n * Node 配置\n * @typedef {Instance~Configs} Node~Configs \n * @property {number[]} anchor - 坐标\n * @property {Node~AbsolutePosition} absolutePosition - 绝对定位位置\n */\n/**\n * 节点基类\n * @constructor Node\n * @extends Instance\n * @param {Node~Configs} configs - 节点配置\n */\nvar Node = /*#__PURE__*/function (_Instance) {\n  node_inherits(Node, _Instance);\n  var _super = node_createSuper(Node);\n  function Node() {\n    var _this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    node_classCallCheck(this, Node);\n    _this = _super.call(this, configs);\n    _defineProperty(node_assertThisInitialized(_this), "INSTANCE_TYPE", \'NODE\');\n    _this._rawConfigs = configs;\n    // for layout\n    /** @member {number[]} */\n    _this.anchor = configs.anchor || [0, 0];\n    /** @member {Node~AbsolutePosition} */\n    _this.absolutePosition = configs.absolutePosition;\n    return _this;\n  }\n  node_createClass(Node, [{\n    key: "nextSibling",\n    get: function get() {\n      var _this2 = this;\n      if (!this._belongs) {\n        return null;\n      }\n      var stack = this._belongs._stack;\n      var idx = stack.findIndex(function (s) {\n        return s === _this2;\n      });\n      if (idx !== -1) {\n        return stack[idx + 1];\n      }\n      return null;\n    }\n  }, {\n    key: "setConfig",\n    value: function setConfig(configs) {\n      var _this3 = this;\n      Object.keys(configs).forEach(function (k) {\n        if (configs[k] !== undefined && configs[k] !== null) {\n          _this3[k] = configs[k];\n          _this3._rawConfigs[k] = configs[k];\n        }\n      });\n    }\n  }, {\n    key: "setAnchorX",\n    value: function setAnchorX(x) {\n      this.anchor[0] = x;\n    }\n  }, {\n    key: "setAnchorY",\n    value: function setAnchorY(y) {\n      this.anchor[1] = y;\n    }\n  }, {\n    key: "setAnchor",\n    value: function setAnchor(x, y) {\n      this.anchor[0] = x;\n      this.anchor[1] = y;\n    }\n  }, {\n    key: "beforeRender",\n    value: function beforeRender() {\n      return doOverlap(this._belongs._getViewBox(), this.getBoundingRect());\n    }\n  }, {\n    key: "addReflowWork",\n    value: function addReflowWork() {\n      dirty_work_addReflowWork(this, this._belongs);\n    }\n\n    /**\n     * 克隆当前节点.\n     * @return {Node} 当前节点的副本\n     */\n  }, {\n    key: "clone",\n    value: function clone() {\n      var C = this.constructor;\n      var t = new C(this._rawConfigs);\n      t.visible = this.visible;\n      return t;\n    }\n  }]);\n  return Node;\n}(instance_instance);\n/* harmony default export */ const node = (Node);\n;// CONCATENATED MODULE: ./src/core/instance/ghostNode.js\nfunction ghostNode_typeof(obj) { "@babel/helpers - typeof"; return ghostNode_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, ghostNode_typeof(obj); }\nfunction ghostNode_defineProperty(obj, key, value) { key = ghostNode_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction ghostNode_slicedToArray(arr, i) { return ghostNode_arrayWithHoles(arr) || ghostNode_iterableToArrayLimit(arr, i) || ghostNode_unsupportedIterableToArray(arr, i) || ghostNode_nonIterableRest(); }\nfunction ghostNode_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction ghostNode_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return ghostNode_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ghostNode_arrayLikeToArray(o, minLen); }\nfunction ghostNode_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ghostNode_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction ghostNode_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction ghostNode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction ghostNode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, ghostNode_toPropertyKey(descriptor.key), descriptor); } }\nfunction ghostNode_createClass(Constructor, protoProps, staticProps) { if (protoProps) ghostNode_defineProperties(Constructor.prototype, protoProps); if (staticProps) ghostNode_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction ghostNode_toPropertyKey(arg) { var key = ghostNode_toPrimitive(arg, "string"); return ghostNode_typeof(key) === "symbol" ? key : String(key); }\nfunction ghostNode_toPrimitive(input, hint) { if (ghostNode_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (ghostNode_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction ghostNode_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) ghostNode_setPrototypeOf(subClass, superClass); }\nfunction ghostNode_setPrototypeOf(o, p) { ghostNode_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return ghostNode_setPrototypeOf(o, p); }\nfunction ghostNode_createSuper(Derived) { var hasNativeReflectConstruct = ghostNode_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = ghostNode_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = ghostNode_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return ghostNode_possibleConstructorReturn(this, result); }; }\nfunction ghostNode_possibleConstructorReturn(self, call) { if (call && (ghostNode_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return ghostNode_assertThisInitialized(self); }\nfunction ghostNode_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction ghostNode_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction ghostNode_getPrototypeOf(o) { ghostNode_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return ghostNode_getPrototypeOf(o); }\n\n\nvar GhostNode = /*#__PURE__*/function (_Node) {\n  ghostNode_inherits(GhostNode, _Node);\n  var _super = ghostNode_createSuper(GhostNode);\n  function GhostNode(configs) {\n    ghostNode_classCallCheck(this, GhostNode);\n    return _super.call(this, configs);\n  }\n  ghostNode_createClass(GhostNode, [{\n    key: "render",\n    value: function render(ctx) {}\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      return false;\n    }\n  }, {\n    key: "calculateIntersection",\n    value: function calculateIntersection(point) {\n      return this.anchor;\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var _this$anchor = ghostNode_slicedToArray(this.anchor, 2),\n        x2 = _this$anchor[0],\n        y2 = _this$anchor[1];\n      return [x2, y2, x2, y2];\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        width: 0,\n        height: 0\n      };\n    }\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      var _ref;\n      var _this$anchor2 = ghostNode_slicedToArray(this.anchor, 2),\n        x2 = _this$anchor2[0],\n        y2 = _this$anchor2[1];\n      return _ref = {}, ghostNode_defineProperty(_ref, DIRECTION.RIGHT, [x2 + 1, y2]), ghostNode_defineProperty(_ref, DIRECTION.LEFT, [x2 - 1, y2]), ghostNode_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + 1]), ghostNode_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - 1]), _ref;\n    }\n  }]);\n  return GhostNode;\n}(node);\n/* harmony default export */ const ghostNode = (GhostNode);\n;// CONCATENATED MODULE: ./src/core/instance/nodeWeakMap.js\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { nodeWeakMap_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction nodeWeakMap_defineProperty(obj, key, value) { key = nodeWeakMap_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction nodeWeakMap_typeof(obj) { "@babel/helpers - typeof"; return nodeWeakMap_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, nodeWeakMap_typeof(obj); }\nfunction nodeWeakMap_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction nodeWeakMap_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, nodeWeakMap_toPropertyKey(descriptor.key), descriptor); } }\nfunction nodeWeakMap_createClass(Constructor, protoProps, staticProps) { if (protoProps) nodeWeakMap_defineProperties(Constructor.prototype, protoProps); if (staticProps) nodeWeakMap_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction nodeWeakMap_toPropertyKey(arg) { var key = nodeWeakMap_toPrimitive(arg, "string"); return nodeWeakMap_typeof(key) === "symbol" ? key : String(key); }\nfunction nodeWeakMap_toPrimitive(input, hint) { if (nodeWeakMap_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (nodeWeakMap_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction getMapObject() {\n  return {\n    layoutNode: undefined,\n    jflowNode: undefined,\n    jflowlinks: [],\n    jflowFromLinks: new Set(),\n    jflowToLinks: new Set()\n  };\n}\nvar NodeWeakMap = /*#__PURE__*/function () {\n  function NodeWeakMap() {\n    nodeWeakMap_classCallCheck(this, NodeWeakMap);\n    this._map = new Map();\n  }\n  nodeWeakMap_createClass(NodeWeakMap, [{\n    key: "get",\n    value: function get(source) {\n      return this._map.get(source);\n    }\n  }, {\n    key: "set",\n    value: function set(source) {\n      var obj = getMapObject();\n      this._map.set(source, obj);\n      return obj;\n    }\n  }, {\n    key: "has",\n    value: function has(source) {\n      return this._map.has(source);\n    }\n  }, {\n    key: "delete",\n    value: function _delete(source) {\n      this._map["delete"](source);\n    }\n  }, {\n    key: "clear",\n    value: function clear() {\n      this._map.clear();\n    }\n  }]);\n  return NodeWeakMap;\n}();\nvar NodeWeakMapMixin = {\n  initNodeWeakMap: function initNodeWeakMap() {\n    this.source_Layout_Render_NodeMap = new NodeWeakMap();\n  },\n  getRenderNodeBySource: function getRenderNodeBySource(source) {\n    var mapping = this.source_Layout_Render_NodeMap.get(source);\n    if (mapping) {\n      return mapping.jflowNode;\n    }\n    return undefined;\n  },\n  removeRenderNodeBySource: function removeRenderNodeBySource(source) {\n    var map = this.source_Layout_Render_NodeMap;\n    var obj = map.get(source);\n    if (obj) {\n      obj.jflowNode = undefined;\n    }\n    if (obj.jflowFromLinks.size === 0 && obj.jflowToLinks.size === 0) {\n      this.source_Layout_Render_NodeMap["delete"](source);\n    }\n  },\n  getLayoutNodeBySource: function getLayoutNodeBySource(source) {\n    var mapping = this.source_Layout_Render_NodeMap.get(source);\n    if (mapping) {\n      return mapping.layoutNode;\n    }\n    return undefined;\n  },\n  getSourceRenderMeta: function getSourceRenderMeta(source) {\n    var map = this.source_Layout_Render_NodeMap;\n    var _meta = map.get(source);\n    return _objectSpread(_objectSpread({}, _meta), {}, {\n      jflowFromLinks: Array.from(_meta.jflowFromLinks),\n      jflowToLinks: Array.from(_meta.jflowToLinks)\n    });\n  },\n  _getMap: function _getMap(source) {\n    if (!source) {\n      return null;\n    }\n    var map = this.source_Layout_Render_NodeMap;\n    var obj;\n    if (map.has(source)) {\n      obj = map.get(source);\n    } else {\n      obj = map.set(source);\n    }\n    return obj;\n  },\n  setLayoutNodeBySource: function setLayoutNodeBySource(source, layoutNode) {\n    var obj = this._getMap(source);\n    obj.layoutNode = layoutNode;\n  },\n  setRenderNodeBySource: function setRenderNodeBySource(source, instance) {\n    var obj = this._getMap(source);\n    obj.jflowNode = instance;\n    if (obj.jflowFromLinks.size > 0) {\n      obj.jflowFromLinks.forEach(function (link) {\n        link.from = instance;\n      });\n    }\n    if (obj.jflowToLinks.size > 0) {\n      obj.jflowToLinks.forEach(function (link) {\n        link.to = instance;\n      });\n    }\n  },\n  addLinkNodeBySource: function addLinkNodeBySource(sourceFrom, sourceTo, link) {\n    var obj = this._getMap(sourceFrom);\n    obj.jflowFromLinks.add(link);\n    obj = this._getMap(sourceTo);\n    obj.jflowToLinks.add(link);\n  },\n  removeLinkNodeBySource: function removeLinkNodeBySource(sourceFrom, sourceTo, link) {\n    var map = this.source_Layout_Render_NodeMap;\n    var obj = map.get(sourceFrom);\n    if (obj) {\n      obj.jflowFromLinks["delete"](link);\n      if (obj.jflowFromLinks.size === 0 && obj.jflowToLinks.size === 0 && !obj.jflowNode) {\n        this.source_Layout_Render_NodeMap["delete"](sourceFrom);\n      }\n    }\n    obj = map.get(sourceTo);\n    if (obj) {\n      obj.jflowToLinks["delete"](link);\n      if (obj.jflowFromLinks.size === 0 && obj.jflowToLinks.size === 0 && !obj.jflowNode) {\n        this.source_Layout_Render_NodeMap["delete"](sourceTo);\n      }\n    }\n  },\n  changeLinkNodeBySource: function changeLinkNodeBySource(prevSource, nextSource, link, dir) {\n    var obj = this._getMap(prevSource);\n    if (obj) {\n      if (dir === \'from\') {\n        obj.jflowFromLinks["delete"](link);\n      }\n      if (dir === \'to\') {\n        obj.jflowToLinks["delete"](link);\n      }\n    }\n    obj = this._getMap(nextSource);\n    if (obj) {\n      if (dir === \'from\') {\n        obj.jflowFromLinks.add(link);\n        if (obj.jflowNode) {\n          link.from = obj.jflowNode;\n        }\n      }\n      if (dir === \'to\') {\n        obj.jflowToLinks.add(link);\n        if (obj.jflowNode) {\n          link.to = obj.jflowNode;\n        }\n      }\n    }\n  },\n  changeNodeBySource: function changeNodeBySource(prevSource, nextSource, instance) {\n    if (prevSource && nextSource) {\n      var oldobj = this._getMap(prevSource);\n      var newobj = this._getMap(nextSource);\n      newobj.jflowNode = instance;\n      oldobj.jflowFromLinks.forEach(function (link) {\n        newobj.jflowFromLinks.add(link);\n      });\n      oldobj.jflowToLinks.forEach(function (link) {\n        newobj.jflowFromLinks.add(link);\n      });\n      newobj.jflowFromLinks.forEach(function (link) {\n        link.from = instance;\n      });\n      newobj.jflowToLinks.forEach(function (link) {\n        link.to = instance;\n      });\n      this.source_Layout_Render_NodeMap["delete"](prevSource);\n    }\n  }\n};\n/* harmony default export */ const nodeWeakMap = ((/* unused pure expression or super */ null && (NodeWeakMap)));\n;// CONCATENATED MODULE: ./src/core/instance/stack.js\nfunction stack_typeof(obj) { "@babel/helpers - typeof"; return stack_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, stack_typeof(obj); }\nfunction stack_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction stack_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, stack_toPropertyKey(descriptor.key), descriptor); } }\nfunction stack_createClass(Constructor, protoProps, staticProps) { if (protoProps) stack_defineProperties(Constructor.prototype, protoProps); if (staticProps) stack_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction stack_toPropertyKey(arg) { var key = stack_toPrimitive(arg, "string"); return stack_typeof(key) === "symbol" ? key : String(key); }\nfunction stack_toPrimitive(input, hint) { if (stack_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (stack_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = stack_getPrototypeOf(object); if (object === null) break; } return object; }\nfunction stack_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) stack_setPrototypeOf(subClass, superClass); }\nfunction stack_createSuper(Derived) { var hasNativeReflectConstruct = stack_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = stack_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = stack_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return stack_possibleConstructorReturn(this, result); }; }\nfunction stack_possibleConstructorReturn(self, call) { if (call && (stack_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return stack_assertThisInitialized(self); }\nfunction stack_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction stack_wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; stack_wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !stack_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return stack_construct(Class, arguments, stack_getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return stack_setPrototypeOf(Wrapper, Class); }; return stack_wrapNativeSuper(Class); }\nfunction stack_construct(Parent, args, Class) { if (stack_isNativeReflectConstruct()) { stack_construct = Reflect.construct.bind(); } else { stack_construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) stack_setPrototypeOf(instance, Class.prototype); return instance; }; } return stack_construct.apply(null, arguments); }\nfunction stack_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction stack_isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }\nfunction stack_setPrototypeOf(o, p) { stack_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return stack_setPrototypeOf(o, p); }\nfunction stack_getPrototypeOf(o) { stack_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return stack_getPrototypeOf(o); }\n// import { NodePlaceholder } from \'./node-placeholder\';\n/**\n * 绘图栈\n * @extends Array\n */\nvar InstanceStack = /*#__PURE__*/function (_Array) {\n  stack_inherits(InstanceStack, _Array);\n  var _super = stack_createSuper(InstanceStack);\n  function InstanceStack() {\n    var _this;\n    stack_classCallCheck(this, InstanceStack);\n    _this = _super.call(this);\n    _this._currentHit = null;\n    return _this;\n  }\n  stack_createClass(InstanceStack, [{\n    key: "forEach",\n    value: function forEach(cb) {\n      return _get(stack_getPrototypeOf(InstanceStack.prototype), "forEach", this).call(this, function (i, idx) {\n        if (i.type === \'NODE_PLACEHOLDER\') {\n          return;\n        }\n        cb(i, idx);\n      });\n    }\n  }, {\n    key: "filter",\n    value: function filter(cb) {\n      return Array.from(_get(stack_getPrototypeOf(InstanceStack.prototype), "filter", this).call(this, function (i, idx) {\n        if (i.type === \'NODE_PLACEHOLDER\') {\n          return false;\n        }\n        return cb(i, idx);\n      }));\n    }\n  }, {\n    key: "slice",\n    value: function slice() {\n      return Array.from(_get(stack_getPrototypeOf(InstanceStack.prototype), "filter", this).call(this, function (i, idx) {\n        return i.type !== \'NODE_PLACEHOLDER\';\n      }));\n    }\n  }, {\n    key: "superfilter",\n    value: function superfilter(cb) {\n      return _get(stack_getPrototypeOf(InstanceStack.prototype), "filter", this).call(this, function (i, idx) {\n        return cb(i, idx);\n      });\n    }\n    /**\n     * 绘制当前栈\n     * @param {Context2d} ctx - canvas context2d\n     */\n  }, {\n    key: "render",\n    value: function render(ctx, condition) {\n      var movingTarget;\n      this.forEach(function (instance) {\n        if (instance._isMoving) {\n          movingTarget = instance;\n          return;\n        }\n        if (instance.visible && (!condition || condition(instance))) {\n          if (instance.beforeRender) {\n            if (!instance.beforeRender(ctx)) {\n              return;\n            }\n          }\n          ctx.save();\n          instance.render(ctx);\n          ctx.restore();\n        }\n      });\n      if (movingTarget) {\n        ctx.save();\n        // if(movingTarget.reflow && !movingTarget._reflowed) {\n        //     movingTarget.reflow();\n        //     movingTarget._reflowed = true;\n        // }\n        movingTarget.render(ctx);\n        ctx.restore();\n      }\n    }\n  }, {\n    key: "resetHitStatus",\n    value: function resetHitStatus() {\n      this._currentHit = null;\n      this.forEach(function (i) {\n        if (i._stack) {\n          i._stack.resetHitStatus();\n        }\n        i._isHit = false;\n      });\n    }\n\n    /**\n     * 碰撞对象过滤条件\n     * @name InstanceStack~InstanceFilter\n     * @function\n     * @param {Instance} instance - 当前对象\n    */\n    /**\n     * 碰撞检测\n     * @param {number[]} point - 碰撞点\n     * @param {InstanceStack~InstanceFilter} condition - 碰撞对象过滤条件\n     * @return {Instance}\n     */\n  }, {\n    key: "checkHit",\n    value: function checkHit(point, condition, currentConstraint) {\n      var i = this.length - 1;\n      while (i >= 0) {\n        var instance = this[i];\n        if (instance.type === \'NODE_PLACEHOLDER\') {\n          i--;\n          continue;\n        }\n        if (instance.visible && !instance.ignoreHit) {\n          if (condition && condition(instance)) {\n            i--;\n            continue;\n          }\n          if (currentConstraint && !currentConstraint(instance)) {\n            i--;\n            continue;\n          }\n          var ishit = instance.isHit(point, condition);\n          if (ishit) {\n            if (this._currentHit !== instance) {\n              if (this._currentHit) {\n                this._currentHit._isHit = false;\n              }\n              instance._isHit = true;\n              this._currentHit = instance;\n            }\n            if (typeof ishit !== \'boolean\') {\n              return ishit;\n            }\n            return instance;\n          } else {\n            instance._isHit = false;\n          }\n        }\n        i--;\n      }\n      if (this._currentHit) {\n        this._currentHit._isHit = false;\n      }\n      this._currentHit = null;\n      return null;\n    }\n    /**\n     * 获取当前层栈的最小外接矩形\n     * @return {number[][]} - 外接矩形坐标\n     */\n  }, {\n    key: "getBoundingRectPoints",\n    value: function getBoundingRectPoints() {\n      var points = [];\n      this.forEach(function (instance) {\n        if (instance.visible && !instance.absolutePosition) {\n          var rect = instance.getBoundingRect();\n          points.push([rect[0], rect[1]]);\n          points.push([rect[2], rect[3]]);\n        }\n      });\n      return points;\n    }\n\n    /**\n     * 获取当前层栈的锚点矩形\n     * @return {number[][]} - 锚点矩形坐标\n     */\n  }, {\n    key: "getAnchorRectPoints",\n    value: function getAnchorRectPoints() {\n      var points = [];\n      this.forEach(function (instance) {\n        if (instance.visible && !instance.absolutePosition) {\n          points.push(instance.anchor);\n        }\n      });\n      return points;\n    }\n  }]);\n  return InstanceStack;\n}( /*#__PURE__*/stack_wrapNativeSuper(Array));\n/* harmony default export */ const stack = (InstanceStack);\n;// CONCATENATED MODULE: ./src/core/instance/stackMixin.js\n\n\n\n// import { setUniqueId, getUniqueId } from \'../utils/functions\';\n/**\n * 对象栈 mixin 用于方便控制节点栈和连线栈\n *\n * @mixin\n */\nvar StackMixin = {\n  /** @property {Node[]}          - 对象数组 */\n  instances: [],\n  /** @property {BaseLink[]}      - 连线数组 */\n  links: [],\n  /** @property {InstanceStack}       - 对象栈 */\n  _stack: null,\n  /** @property {InstanceStack}       - 连线栈 */\n  _linkStack: null,\n  /**\n   * 初始化对象栈\n   * @param {JflowConfigs} configs - 配置\n   */\n  initStack: function initStack() {\n    var _this = this;\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      data = _ref.data;\n    this._stack = new stack();\n    this._linkStack = new stack();\n    if (!data) return;\n    this.instances = data.instances;\n    this.links = data.links;\n    this.instances.forEach(function (i) {\n      _this._stack.push(i);\n      i._belongs = _this;\n    });\n    this.links.forEach(function (link) {\n      _this._linkStack.push(link);\n      link._belongs = _this;\n    });\n  },\n  /**\n   * 加入节点对象\n   * @param {Node} instance - 节点对象\n   */\n  addToStack: function addToStack(instance) {\n    // console.log(\'-----addToStack----\', instance)\n    instance._belongs = this;\n    this._stack.push(instance);\n    dirty_work_addReflowWork(instance, this);\n    // this.recalculate()\n  },\n  insertToStackBefore: function insertToStackBefore(instance, anchorNode) {\n    // console.log(\'-----insertToStackBefore----\')\n    if (instance._belongs) {\n      instance._belongs.removeFromStack(instance);\n    }\n    instance._belongs = this;\n    var idx = this._stack.findIndex(function (s) {\n      return s === anchorNode;\n    });\n    if (idx !== -1) {\n      this._stack.splice(idx, 0, instance);\n      dirty_work_addReflowWork(instance, this);\n    } else {\n      this.addToStack(instance);\n    }\n  },\n  /**\n   * 替换对象\n   * @param {Instance} target - 被替换的对象\n   * @param {Instance} instance - 替换对象\n   */\n  replaceFromStack: function replaceFromStack(target, instance) {\n    var index = this._stack.findIndex(function (i) {\n      return i === target;\n    });\n    this._stack.splice(index, 1, instance);\n    target._belongs = null;\n    instance._belongs = this;\n    // this.recalculate()\n  },\n  /**\n   * 加入连线对象\n   * @param {BaseLink} instance - 连线对象\n   */\n  addToLinkStack: function addToLinkStack(link) {\n    if (this._linkStack.find(function (l) {\n      return l === link;\n    })) {\n      return;\n    }\n    link._belongs = this;\n    this._linkStack.push(link);\n  },\n  /**\n   * 删除节点对象\n   * @param {Node} target - 节点对象\n   */\n  removeFromStack: function removeFromStack(target) {\n    // console.log(\'-----removeFromStack----\')\n    // this.removeLinkOnInstance(target);\n    var index = this._stack.findIndex(function (i) {\n      return i === target;\n    });\n    if (index !== -1) {\n      this._stack.splice(index, 1);\n      dirty_work_addReflowWork(this);\n    }\n    // this.recalculate()\n  },\n  /**\n   * 删除连线对象\n   * @param {Node} target - 连线对象\n   */\n  removeFromLinkStack: function removeFromLinkStack(target) {\n    var index = this._linkStack.findIndex(function (i) {\n      return i === target;\n    });\n    if (index !== -1) {\n      this._linkStack.splice(index, 1);\n    }\n  },\n  emptyLink: function emptyLink() {\n    this._linkStack = new stack();\n  },\n  /**\n   * 重置当前栈中对象的位置\n   */\n  resetChildrenPosition: function resetChildrenPosition() {\n    this._stack.forEach(function (i) {\n      i.anchor = [0, 0];\n    });\n  },\n  addInstanceToLink: function addInstanceToLink(targetLink, instance) {\n    this.addToStack(instance);\n    var from = targetLink.from,\n      to = targetLink.to;\n    var index = this._linkStack.findIndex(function (l) {\n      return l === targetLink;\n    });\n    var _constuctor = targetLink.__proto__.constructor;\n    var l1 = new _constuctor({\n      from: from,\n      to: instance\n    });\n    l1._belongs = this;\n    var l2 = new _constuctor({\n      from: instance,\n      to: to\n    });\n    l2._belongs = this;\n    this._linkStack.splice(index, 1, l1, l2);\n  },\n  /**\n   * 循环当前栈中节点\n   * @property {stackIteratorCallback} 循环访问栈中每个节点\n   */\n  interateNodeStack: function interateNodeStack(callback) {\n    this._stack.forEach(function (instance) {\n      callback(instance);\n    });\n  }\n  /**\n  * 循环访问栈中每个节点\n  * @callback stackIteratorCallback\n  * @param {Node} instance 栈中节点\n  */\n};\n/* harmony default export */ const stackMixin = (StackMixin);\n;// CONCATENATED MODULE: ./src/core/instance/layoutMixin.js\n/**\n * Layout mixin 配置\n * @typedef {Object} LayoutMixin~LayoutConfigs\n * @property {Layout} layout             - 布局对象 \n */\n/**\n * 布局 mixin 用于注册和方便控制布局\n *\n * @mixin\n */\nvar LayoutMixin = {\n  /** @property {Layout}      - 布局对象 */\n  _layout: null,\n  /**\n   * 初始化布局\n   * @param {LayoutMixin~LayoutConfigs} configs - 配置\n   */\n  initLayout: function initLayout() {\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._layout = configs.layout;\n  },\n  /**\n   * 从当前层出发，向上层递归重排\n   */\n  recalculateUp: function recalculateUp() {\n    var _this$_belongs;\n    // console.log(\'----recalculateUp----\')\n    var dirty = true;\n    if (this.getBoundingDimension) {\n      var _this$getBoundingDime = this.getBoundingDimension(),\n        wold = _this$getBoundingDime.width,\n        hold = _this$getBoundingDime.height;\n      if (this.resetChildrenPosition) {\n        this.resetChildrenPosition();\n      }\n      if (this._getBoundingGroupRect) {\n        this._getBoundingGroupRect();\n      }\n      this.reflow();\n      if (this._getBoundingGroupRect) {\n        this._getBoundingGroupRect();\n      }\n      var _this$getBoundingDime2 = this.getBoundingDimension(),\n        wnow = _this$getBoundingDime2.width,\n        hnow = _this$getBoundingDime2.height;\n      dirty = wold !== wnow || hold !== hnow;\n    } else {\n      this.reflow();\n    }\n    if (this._belongs && dirty) {\n      this._belongs.recalculateUp();\n    }\n    if (!dirty || ((_this$_belongs = this._belongs) === null || _this$_belongs === void 0 ? void 0 : _this$_belongs.uniqueName) === \'jflow\') {\n      this.recalculateDown();\n    }\n  },\n  recalculateDown: function recalculateDown() {\n    if (this._layout && this._layout.reflowAfter) {\n      this._layout.reflowAfter(this);\n    }\n    this._stack.forEach(function (instance) {\n      if (instance.recalculateDown) {\n        instance.recalculateDown();\n      }\n    });\n  },\n  /**\n   * 重新计算布局，相当于浏览器里面重排，并重算当前布局下的最小外接矩形\n   */\n  recalculate: function recalculate() {\n    // console.log(\'----recalculate----\')\n    this.reflow();\n    if (this._getBoundingGroupRect) {\n      this._getBoundingGroupRect();\n    }\n  },\n  /**\n   * 布局静态检查\n   * @param {Instance} instance - 检查单元\n   * @return {Boolean} - 检查结果 \n   */\n  staticCheck: function staticCheck(instance) {\n    if (this._layout) {\n      return this._layout.staticCheck(instance, this);\n    }\n    return false;\n  },\n  /**\n   * 重新计算布局，相当于浏览器里面重排\n   */\n  reflow: function reflow() {\n    if (this._layout) {\n      this._layout.reflow(this);\n    }\n  }\n};\n/* harmony default export */ const layoutMixin = (LayoutMixin);\n;// CONCATENATED MODULE: ./src/core/instance/messageMixin.js\n/**\n * 消息 mixin 用于给Jflow传递消息\n *\n * @mixin\n */\nvar MessageMixin = {\n  _message: null,\n  /**\n   * 发送消息\n   * @param {Object} msg - 消息体\n   */\n  sendMessage: function sendMessage(msg) {\n    this._message = msg;\n  },\n  /**\n   * 接收消息\n   * @return {Object} msg - 消息体\n   */\n  consumeMessage: function consumeMessage() {\n    var msg = this._message;\n    this._message = null;\n    return msg;\n  },\n  readMessage: function readMessage() {\n    return this._message;\n  }\n};\n/* harmony default export */ const messageMixin = (MessageMixin);\n;// CONCATENATED MODULE: ./src/core/anime/animeMixin.js\n/* harmony default export */ const animeMixin = ({\n  initAnime: function initAnime() {\n    this.anime_queue = [];\n    this.__animeClock__ = undefined;\n    // this.animeclock = undefined;\n    // this.frameRendered = false;\n  },\n  // setAnimeClock(time) {\n  //     if(time !== this.animeclock) {\n  //         this.frameRendered = false;\n  //         this.animeclock = time;\n  //     }\n  // },\n  // hasAnimeAndFrameRendered() {\n  //     return this.anime_queue.length && this.frameRendered;\n  // },\n  // setFrameRendered() {\n  //     if(this.anime_queue.length) {\n  //         this.frameRendered = true;\n  //     }\n  // },\n  requestJFlowAnime: function requestJFlowAnime(frameCallBack) {\n    var meta = this.enqueueAnime(frameCallBack);\n    this._runAnime();\n    return meta;\n  },\n  enqueueAnime: function enqueueAnime(callback) {\n    var _this = this;\n    var animeMeta = {\n      start: undefined,\n      callback: callback,\n      cancel: function cancel() {\n        _this._cancelAnime(animeMeta);\n        _this._render();\n      }\n    };\n    this.anime_queue.push(animeMeta);\n    return animeMeta;\n  },\n  _cancelAnime: function _cancelAnime(meta) {\n    var idx = this.anime_queue.findIndex(function (m) {\n      return m === meta;\n    });\n    ~idx && this.anime_queue.splice(idx, 1);\n  },\n  runAnime: function runAnime() {\n    this._runAnime();\n    // requestAnimationFrame(this._runAnime.bind(this));\n  },\n  _runAnime: function _runAnime() {\n    var _this2 = this;\n    if (this.anime_queue.length) {\n      requestAnimationFrame(function () {\n        _this2.scheduleRender();\n        _this2._runAnime();\n      });\n      // requestAnimationFrame(this._runAnime.bind(this))\n    }\n  },\n  runAnimeFrame: function runAnimeFrame() {\n    this.anime_queue.forEach(function (meta) {\n      var timestamp = Date.now();\n      if (!meta.start) {\n        meta.start = timestamp;\n      }\n      var elapsed = timestamp - meta.start;\n      meta.callback(elapsed);\n    });\n  }\n});\n;// CONCATENATED MODULE: ./src/core/miniMap/minimap-mixin.js\nfunction minimap_mixin_slicedToArray(arr, i) { return minimap_mixin_arrayWithHoles(arr) || minimap_mixin_iterableToArrayLimit(arr, i) || minimap_mixin_unsupportedIterableToArray(arr, i) || minimap_mixin_nonIterableRest(); }\nfunction minimap_mixin_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction minimap_mixin_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return minimap_mixin_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return minimap_mixin_arrayLikeToArray(o, minLen); }\nfunction minimap_mixin_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction minimap_mixin_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction minimap_mixin_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/* harmony default export */ const minimap_mixin = ({\n  // 传入一个别的 context2d 来绘制\n  captureMap: function captureMap(wrapper, _ref) {\n    var _this = this;\n    var _ref$padding = _ref.padding,\n      padding = _ref$padding === void 0 ? 0 : _ref$padding,\n      _ref$placement = _ref.placement,\n      placement = _ref$placement === void 0 ? \'normal\' : _ref$placement;\n    this._getBoundingGroupRect();\n    var _this$bounding_box = this.bounding_box,\n      p_width = _this$bounding_box.width,\n      p_height = _this$bounding_box.height,\n      p_x = _this$bounding_box.x,\n      p_y = _this$bounding_box.y;\n    var miniMap = this.miniMap;\n    if (!miniMap) {\n      this.miniMap = createCanvas(wrapper);\n      var _this$miniMap = this.miniMap,\n        _width = _this$miniMap.width,\n        _height = _this$miniMap.height,\n        _raw_width = _this$miniMap.raw_width,\n        _raw_height = _this$miniMap.raw_height;\n      this.addEventListener(\'zoompan\', function () {\n        _this._renderMap && _this._renderMap();\n      });\n      var pressDown = false;\n      this.miniMap.canvas.addEventListener(\'pointerdown\', function (event) {\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY,\n          deltaX = event.deltaX,\n          deltaY = event.deltaY;\n        pressDown = true;\n        _this._onMoveMap && _this._onMoveMap(offsetX, offsetY);\n      });\n      this.miniMap.canvas.addEventListener(\'pointermove\', function (event) {\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY,\n          deltaX = event.deltaX,\n          deltaY = event.deltaY;\n        if (pressDown) {\n          _this._onMoveMap && _this._onMoveMap(offsetX, offsetY);\n        }\n        if (offsetY < 5 || offsetX < 5 || offsetX > _width - 5 || offsetY > _height - 5) {\n          pressDown = false;\n        }\n      });\n      this.miniMap.canvas.addEventListener(\'pointerup\', function () {\n        pressDown = false;\n      });\n      var caheCanvas = document.createElement(\'canvas\');\n      caheCanvas.width = _raw_width;\n      caheCanvas.height = _raw_height;\n      this.cacheMinimapCtx = caheCanvas.getContext(\'2d\');\n    }\n    var _this$miniMap2 = this.miniMap,\n      width = _this$miniMap2.width,\n      height = _this$miniMap2.height,\n      raw_width = _this$miniMap2.raw_width,\n      raw_height = _this$miniMap2.raw_height,\n      left = _this$miniMap2.left,\n      top = _this$miniMap2.top,\n      scale = _this$miniMap2.scale,\n      ctx = _this$miniMap2.ctx;\n    var pad2 = padding * 2;\n    var pad = padding;\n    var r1 = (width - pad2) / p_width;\n    var r2 = (height - pad2) / p_height;\n    var r = Math.min(r1, r2);\n    var m_x = 0;\n    var m_y = 0;\n    if (placement === \'center\') {\n      m_y = (height - p_height * r) / 2 - p_y * r;\n      m_x = (width - p_width * r) / 2 - p_x * r;\n    } else {\n      if (r1 < r2) {\n        m_y = (height - p_height * r) / 2 - p_y * r;\n        m_x = pad;\n      } else {\n        m_x = (width - p_width * r) / 2 - p_x * r;\n        m_y = pad;\n      }\n    }\n    var cachectx = this.cacheMinimapCtx;\n    cachectx.setTransform();\n    cachectx.clearRect(0, 0, raw_width, raw_height);\n    cachectx.scale(scale, scale);\n    cachectx.transform(r, 0, 0, r, m_x, m_y);\n    // ctx.fillStyle = \'red\';\n    // ctx.arc( 30, 30, 100, 0, 2*Math.PI);\n    // ctx.fill()\n    // debugger\n    var br = [0, 0, 0, 0];\n    if (this.NodeRenderTop) {\n      this._linkStack.render(cachectx, function (link) {\n        link.isInViewBox(br);\n        return true;\n      });\n      // this._linkStack.render(cachectx);\n      this._stack.render(cachectx);\n    } else {\n      this._stack.render(cachectx);\n      this._linkStack.render(cachectx, function (link) {\n        link.isInViewBox(br);\n        return true;\n      });\n    }\n    var _cacheMapImageData = cachectx.getImageData(0, 0, raw_width, raw_height);\n    this._renderMap = function () {\n      ctx.save();\n      ctx.setTransform();\n      ctx.clearRect(0, 0, raw_width, raw_height);\n      // if(!i) {\n      ctx.scale(scale, scale);\n      ctx.putImageData(_cacheMapImageData, 0, 0);\n      ctx.transform(r, 0, 0, r, m_x, m_y);\n      var _this$_getViewBox = _this._getViewBox(),\n        _this$_getViewBox2 = minimap_mixin_slicedToArray(_this$_getViewBox, 4),\n        x = _this$_getViewBox2[0],\n        y = _this$_getViewBox2[1],\n        t = _this$_getViewBox2[2],\n        d = _this$_getViewBox2[3];\n      ctx.beginPath();\n      ctx.rect(x, y, t - x, d - y);\n      ctx.setTransform();\n      ctx.rect(0, 0, raw_width, raw_height);\n      ctx.clip("evenodd");\n      ctx.fillStyle = \'rgba(0,0,0,0.4)\';\n      ctx.fillRect(0, 0, raw_width, raw_height);\n      ctx.restore();\n      // }\n    };\n\n    this._renderMap();\n    this._onMoveMap = function (offsetX, offsetY) {\n      var _this$_getViewBox3 = _this._getViewBox(),\n        _this$_getViewBox4 = minimap_mixin_slicedToArray(_this$_getViewBox3, 4),\n        x = _this$_getViewBox4[0],\n        y = _this$_getViewBox4[1],\n        t = _this$_getViewBox4[2],\n        d = _this$_getViewBox4[3];\n      // const w = t-x;\n      var a = (t - x) / 2 + x;\n      var b = (d - y) / 2 + y;\n      var p = [a * r + m_x, b * r + m_y];\n      _this._recalculatePosition((p[0] - offsetX) / r * _this.scale, (p[1] - offsetY) / r * _this.scale);\n      _this._render();\n      _this._renderMap();\n    };\n    // this._render(ctx);\n  }\n});\n;// CONCATENATED MODULE: ./src/core/events/index.js\nfunction events_typeof(obj) { "@babel/helpers - typeof"; return events_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, events_typeof(obj); }\nfunction events_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction events_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? events_ownKeys(Object(source), !0).forEach(function (key) { events_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : events_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction events_defineProperty(obj, key, value) { key = events_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction events_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, events_toPropertyKey(descriptor.key), descriptor); } }\nfunction events_createClass(Constructor, protoProps, staticProps) { if (protoProps) events_defineProperties(Constructor.prototype, protoProps); if (staticProps) events_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction events_toPropertyKey(arg) { var key = events_toPrimitive(arg, "string"); return events_typeof(key) === "symbol" ? key : String(key); }\nfunction events_toPrimitive(input, hint) { if (events_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (events_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction events_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction events_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) events_setPrototypeOf(subClass, superClass); }\nfunction events_createSuper(Derived) { var hasNativeReflectConstruct = events_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = events_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = events_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return events_possibleConstructorReturn(this, result); }; }\nfunction events_possibleConstructorReturn(self, call) { if (call && (events_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return events_assertThisInitialized(self); }\nfunction events_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction events_wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; events_wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !events_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return events_construct(Class, arguments, events_getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return events_setPrototypeOf(Wrapper, Class); }; return events_wrapNativeSuper(Class); }\nfunction events_construct(Parent, args, Class) { if (events_isNativeReflectConstruct()) { events_construct = Reflect.construct.bind(); } else { events_construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) events_setPrototypeOf(instance, Class.prototype); return instance; }; } return events_construct.apply(null, arguments); }\nfunction events_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction events_isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }\nfunction events_setPrototypeOf(o, p) { events_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return events_setPrototypeOf(o, p); }\nfunction events_getPrototypeOf(o) { events_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return events_getPrototypeOf(o); }\n/**\n * JFlow 抛出事件\n * @extends CustomEvent\n * @property {Event}  originEvent      - 原始事件\n * @property {Instance} target         - 事件触发对象\n * @property {JFlow} jflow             - JFlow 对象\n * @property {boolean} bubbles         - 冒泡标识\n */\nvar JFlowEvent = /*#__PURE__*/function (_CustomEvent) {\n  events_inherits(JFlowEvent, _CustomEvent);\n  var _super = events_createSuper(JFlowEvent);\n  function JFlowEvent(event) {\n    var configs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    events_classCallCheck(this, JFlowEvent);\n    var detail = events_objectSpread(events_objectSpread({}, configs), {}, {\n      originEvent: configs.event,\n      target: configs.target,\n      jflow: configs.jflow,\n      bubbles: configs.bubbles || false\n    });\n    return _super.call(this, event, {\n      detail: detail\n    });\n  }\n  return events_createClass(JFlowEvent);\n}( /*#__PURE__*/events_wrapNativeSuper(CustomEvent));\n/* harmony default export */ const events = (JFlowEvent);\n;// CONCATENATED MODULE: ./src/core/scrollbar/scrollbarMixin.js\nfunction scrollbarMixin_typeof(obj) { "@babel/helpers - typeof"; return scrollbarMixin_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, scrollbarMixin_typeof(obj); }\nfunction scrollbarMixin_slicedToArray(arr, i) { return scrollbarMixin_arrayWithHoles(arr) || scrollbarMixin_iterableToArrayLimit(arr, i) || scrollbarMixin_unsupportedIterableToArray(arr, i) || scrollbarMixin_nonIterableRest(); }\nfunction scrollbarMixin_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction scrollbarMixin_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return scrollbarMixin_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return scrollbarMixin_arrayLikeToArray(o, minLen); }\nfunction scrollbarMixin_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction scrollbarMixin_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction scrollbarMixin_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction scrollbarMixin_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction scrollbarMixin_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, scrollbarMixin_toPropertyKey(descriptor.key), descriptor); } }\nfunction scrollbarMixin_createClass(Constructor, protoProps, staticProps) { if (protoProps) scrollbarMixin_defineProperties(Constructor.prototype, protoProps); if (staticProps) scrollbarMixin_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction scrollbarMixin_toPropertyKey(arg) { var key = scrollbarMixin_toPrimitive(arg, "string"); return scrollbarMixin_typeof(key) === "symbol" ? key : String(key); }\nfunction scrollbarMixin_toPrimitive(input, hint) { if (scrollbarMixin_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (scrollbarMixin_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\nvar ScrollBar = /*#__PURE__*/function () {\n  function ScrollBar(dir) {\n    var configs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    scrollbarMixin_classCallCheck(this, ScrollBar);\n    this.anchor = [0, 0];\n    this.width = configs.barWidth || 4;\n    this.height = configs.barWidth || 4;\n    this.barMarginX = 0;\n    this.barMarginY = 0;\n    this.dir = dir;\n    this.plainColor = configs.plainColor || \'rgba(0, 0, 0, 0.15)\';\n    this.focusColor = configs.focusColor || \'rgba(0, 0, 0, 0.25)\';\n    this.isFocus = false;\n  }\n  scrollbarMixin_createClass(ScrollBar, [{\n    key: "render",\n    value: function render(ctx) {\n      var _this$anchor = scrollbarMixin_slicedToArray(this.anchor, 2),\n        x = _this$anchor[0],\n        y = _this$anchor[1];\n      ctx.save();\n      ctx.beginPath();\n      if (this.dir === \'x\') {\n        var radius = this.height / 2;\n        var cy = y + radius;\n        var by = y + this.height;\n        var rc = x + this.width - this.barMarginX * 2 - radius;\n        var lc = x + this.barMarginX + radius;\n        ctx.moveTo(lc, by);\n        ctx.arc(lc, cy, radius, Math.PI / 2, Math.PI / 2 * 3);\n        ctx.lineTo(rc, y);\n        ctx.arc(rc, cy, radius, -Math.PI / 2, Math.PI / 2);\n        ctx.closePath();\n      } else {\n        var _radius = this.width / 2;\n        var tc = y + this.barMarginY + _radius;\n        var bc = y + this.height - this.barMarginY * 2 - _radius;\n        var cx = x + _radius;\n        var rx = x + this.width;\n        ctx.moveTo(x, tc);\n        ctx.arc(cx, tc, _radius, -Math.PI, 0);\n        ctx.lineTo(rx, bc);\n        ctx.arc(cx, bc, _radius, 0, Math.PI);\n        ctx.closePath();\n      }\n      //   ctx.rect(\n      // x + this.barMarginX,\n      // y + this.barMarginY,\n      // this.width - this.barMarginX*2,\n      // this.height - this.barMarginY*2);\n\n      ctx.fillStyle = this.isFocus ? this.focusColor : this.plainColor;\n      ctx.fill();\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      var anchor = this.anchor;\n      var w = this.width;\n      var h = this.height;\n      return point[0] > anchor[0] - 5 && point[0] < anchor[0] + w + 5 && point[1] > anchor[1] - 5 && point[1] < anchor[1] + h + 5;\n    }\n  }]);\n  return ScrollBar;\n}();\n/* harmony default export */ const scrollbarMixin = ({\n  initScrollBar: function initScrollBar() {\n    var _this = this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var barColor = configs.barColor,\n      barFocusColor = configs.barFocusColor,\n      barMarginX = configs.barMarginX,\n      barMarginY = configs.barMarginY,\n      barWidth = configs.barWidth;\n    this._scrollbarEnable = true;\n    this._scrollbarX = new ScrollBar(\'x\', {\n      plainColor: barColor,\n      focusColor: barFocusColor,\n      barWidth: barWidth\n    });\n    this._scrollbarX.barMarginX = barMarginX || 5;\n    this._scrollbarY = new ScrollBar(\'y\', {\n      plainColor: barColor,\n      focusColor: barFocusColor,\n      barWidth: barWidth\n    });\n    this._scrollbarY.barMarginY = barMarginY || 5;\n    this._scrollBarStatus = {\n      dragging: false,\n      target: null,\n      xscale: undefined,\n      yscale: undefined,\n      barInitX: 0,\n      barInitY: 0\n    };\n    this.stopZoompanWatch = false;\n    this.addEventListener(\'zoompan\', function () {\n      if (!_this.stopZoompanWatch) {\n        _this.scrollBarOnPanAndZoom();\n      }\n    });\n    this.scrollBarOnPanAndZoom();\n    this.canvas.addEventListener(\'pointerdown\', function (e) {\n      var offsetX = e.offsetX,\n        offsetY = e.offsetY,\n        clientX = e.clientX,\n        clientY = e.clientY;\n      _this.onScrollbarPressStart(offsetX, offsetY, clientX, clientY);\n    });\n  },\n  checkScrollDragging: function checkScrollDragging() {\n    return this._scrollBarStatus && this._scrollBarStatus.dragging;\n  },\n  onScrollbarPressStart: function onScrollbarPressStart(offsetX, offsetY, clientX, clientY) {\n    var _this2 = this;\n    this.stopZoompanWatch = true;\n    var xhit = this._scrollbarX.isHit([offsetX, offsetY]);\n    if (xhit) {\n      Object.assign(this._scrollBarStatus, {\n        dragging: true,\n        target: this._scrollbarX,\n        barStartX: this._scrollbarX.anchor[0],\n        barInitX: clientX\n      });\n    }\n    var yhit = this._scrollbarY.isHit([offsetX, offsetY]);\n    if (yhit) {\n      Object.assign(this._scrollBarStatus, {\n        dragging: true,\n        target: this._scrollbarY,\n        barStartY: this._scrollbarY.anchor[1],\n        barInitY: clientY\n      });\n    }\n    var f = function (e) {\n      var offsetX = e.offsetX,\n        offsetY = e.offsetY,\n        clientX = e.clientX,\n        clientY = e.clientY;\n      _this2.onDraggingScrollbar(offsetX, offsetY, clientX, clientY);\n    }.bind(this);\n    document.addEventListener(\'pointermove\', f);\n    var t = function (e) {\n      Object.assign(_this2._scrollBarStatus, {\n        dragging: false,\n        target: null,\n        x: undefined,\n        y: undefined\n      });\n      document.removeEventListener(\'pointermove\', f);\n      document.removeEventListener(\'pointerup\', t);\n      _this2.canvas.removeEventListener(\'pointerup\', t);\n      _this2.stopZoompanWatch = false;\n    }.bind(this);\n    this.canvas.addEventListener(\'pointerup\', t, {\n      once: true\n    });\n    document.addEventListener(\'pointerup\', t, {\n      once: true\n    });\n  },\n  onDraggingScrollbar: function onDraggingScrollbar(offsetX, offsetY, clientX, clientY) {\n    if (this._scrollbarEnable && this._scrollBarStatus.dragging) {\n      var _this$_scrollBarStatu = this._scrollBarStatus,\n        target = _this$_scrollBarStatu.target,\n        barInitX = _this$_scrollBarStatu.barInitX,\n        barStartX = _this$_scrollBarStatu.barStartX,\n        barInitY = _this$_scrollBarStatu.barInitY,\n        barStartY = _this$_scrollBarStatu.barStartY,\n        xscale = _this$_scrollBarStatu.xscale,\n        yscale = _this$_scrollBarStatu.yscale,\n        scollbarHeight = _this$_scrollBarStatu.scollbarHeight,\n        scollbarWidth = _this$_scrollBarStatu.scollbarWidth,\n        realR = _this$_scrollBarStatu.realR,\n        realL = _this$_scrollBarStatu.realL,\n        realT = _this$_scrollBarStatu.realT,\n        realB = _this$_scrollBarStatu.realB;\n      var _this$canvasMeta = this.canvasMeta,\n        actual_width = _this$canvasMeta.actual_width,\n        actual_height = _this$canvasMeta.actual_height;\n      var _this$bounding_box = this.bounding_box,\n        p_x = _this$bounding_box.x,\n        p_y = _this$bounding_box.y;\n      // console.log(target.dir, realT, realB)\n      var deltaX = 0,\n        deltaY = 0;\n      if (target.dir === \'x\') {\n        deltaX = clientX - barInitX;\n        var xnew = barStartX + deltaX;\n        var q = target.anchor[0] = Math.max(Math.min(xnew, actual_width - scollbarWidth), 0);\n        var ratioInX = q / actual_width;\n        // const y = (realB - (realB - realT) * ratioInY) * this.scale\n        var ratioX = (realR - realL) * ratioInX + realL;\n        var x = (p_x - ratioX) * this.scale;\n        Object.assign(this.position, {\n          offsetX: x - p_x * this.scale,\n          x: x\n        });\n      }\n      if (target.dir === \'y\') {\n        deltaY = clientY - barInitY;\n        var ynew = barStartY + deltaY;\n        var _q = target.anchor[1] = Math.max(Math.min(ynew, actual_height - scollbarHeight), 0);\n        ;\n        var ratioInY = _q / actual_height;\n        // const y = (realB - (realB - realT) * ratioInY) * this.scale\n        var ratioY = (realB - realT) * ratioInY + realT;\n        var y = (p_y - ratioY) * this.scale;\n        Object.assign(this.position, {\n          offsetY: y - p_y * this.scale,\n          y: y\n        });\n      }\n      this.dispatchEvent(new events(\'zoompan\', {\n        deltaX: deltaX,\n        deltaY: deltaY\n      }));\n      this.scheduleRender();\n      return true;\n    }\n    return false;\n  },\n  checkScrollBarHover: function checkScrollBarHover(offsetX, offsetY) {\n    if (this._scrollbarEnable) {\n      var xhit = this._scrollbarX.isHit([offsetX, offsetY]);\n      if (xhit) {\n        // this._scrollBarStatus.hoverTarget = this._scrollbarX;\n        if (!this._scrollbarX.isFocus) {\n          this._scrollbarX.isFocus = true;\n          this.scheduleRender();\n        }\n        this.canvas.style.cursor = \'default\';\n        return true;\n      }\n      var yhit = this._scrollbarY.isHit([offsetX, offsetY]);\n      if (yhit) {\n        // this._scrollBarStatus.hoverTarget = this._scrollbarY;\n        if (!this._scrollbarY.isFocus) {\n          this._scrollbarY.isFocus = true;\n          this.scheduleRender();\n        }\n        this.canvas.style.cursor = \'default\';\n        return true;\n      }\n    }\n    return false;\n  },\n  resetScrollBarHover: function resetScrollBarHover() {\n    if (this._scrollbarEnable) {\n      if (this._scrollbarY.isFocus || this._scrollbarX.isFocus) {\n        this._scrollbarY.isFocus = false;\n        this._scrollbarX.isFocus = false;\n        this.scheduleRender();\n      }\n    }\n  },\n  _getScrollViewBoundingbox: function _getScrollViewBoundingbox() {\n    var padding = 120;\n    var _this$bounding_box2 = this.bounding_box,\n      p_width = _this$bounding_box2.width,\n      p_height = _this$bounding_box2.height,\n      p_x = _this$bounding_box2.x,\n      p_y = _this$bounding_box2.y;\n    var p = padding;\n    var p2 = padding * 2;\n    return {\n      width: p_width + p2,\n      height: p_height + p2,\n      x: p_x - p,\n      y: p_y - p\n    };\n  },\n  scrollBarOnPanAndZoom: function scrollBarOnPanAndZoom() {\n    if (!this._scrollbarEnable || this._scrollBarStatus.dragging) {\n      return;\n    }\n    var _this$_getScrollViewB = this._getScrollViewBoundingbox(),\n      p_width = _this$_getScrollViewB.width,\n      p_height = _this$_getScrollViewB.height,\n      p_x = _this$_getScrollViewB.x,\n      p_y = _this$_getScrollViewB.y;\n    var _this$_getViewBox = this._getViewBox(),\n      _this$_getViewBox2 = scrollbarMixin_slicedToArray(_this$_getViewBox, 4),\n      x = _this$_getViewBox2[0],\n      y = _this$_getViewBox2[1],\n      r = _this$_getViewBox2[2],\n      b = _this$_getViewBox2[3];\n    var realR = Math.max(r, p_x + p_width);\n    var realL = Math.min(x, p_x);\n    var realT = Math.min(y, p_y);\n    var realB = Math.max(b, p_y + p_height);\n    var vw = r - x;\n    var vh = b - y;\n    var _this$canvasMeta2 = this.canvasMeta,\n      actual_width = _this$canvasMeta2.actual_width,\n      actual_height = _this$canvasMeta2.actual_height;\n    var xscale = vw / (realR - realL);\n    if (xscale < 1) {\n      var scollbarWidth = actual_width * xscale;\n      var anchorX = (x - realL) * xscale * this.scale;\n      this._scrollbarX.anchor = [anchorX, actual_height - 10];\n      this._scrollbarX.width = scollbarWidth;\n      this._scrollBarStatus.scollbarWidth = scollbarWidth;\n    }\n    var yscale = vh / (realB - realT);\n    if (yscale < 1) {\n      var scollbarHeight = actual_height * yscale;\n      var anchorY = (y - realT) * yscale * this.scale;\n      this._scrollbarY.anchor = [actual_width - 10, anchorY];\n      this._scrollbarY.height = scollbarHeight;\n      this._scrollBarStatus.scollbarHeight = scollbarHeight;\n    }\n    Object.assign(this._scrollBarStatus, {\n      yscale: yscale,\n      xscale: xscale,\n      realR: realR,\n      realL: realL,\n      realT: realT,\n      realB: realB\n    });\n  },\n  resetScollBarStatus: function resetScollBarStatus() {\n    if (this._scrollbarEnable) {\n      Object.assign(this._scrollBarStatus, {\n        dragging: false,\n        target: null,\n        x: undefined,\n        y: undefined\n      });\n    }\n  },\n  renderScrollBar: function renderScrollBar(ctx) {\n    if (this._scrollbarEnable) {\n      ctx.setTransform();\n      ctx.scale(this.dpr, this.dpr);\n      var _this$_scrollBarStatu2 = this._scrollBarStatus,\n        xscale = _this$_scrollBarStatu2.xscale,\n        yscale = _this$_scrollBarStatu2.yscale;\n      if (xscale < 1) {\n        this._scrollbarX.render(ctx);\n      }\n      if (yscale < 1) {\n        this._scrollbarY.render(ctx);\n      }\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/core/flow/schedule.js\n/* harmony default export */ const schedule = ({\n  toggleRender: function toggleRender(val) {\n    this.__renderstop__ = !val;\n  },\n  initSchedule: function initSchedule() {\n    this.__clock__ = undefined;\n  },\n  scheduleRender: function scheduleRender(callback) {\n    var _this = this;\n    requestAnimationFrame(function (timestamp) {\n      var isFirstTime = _this.__clock__ !== timestamp;\n      if (!_this.__renderstop__ && isFirstTime) {\n        _this.__render();\n      }\n      if (callback) {\n        callback(timestamp);\n      }\n      _this.__clock__ = timestamp;\n    });\n  }\n});\n;// CONCATENATED MODULE: ./src/core/events/adapter.js\nfunction adapter_typeof(obj) { "@babel/helpers - typeof"; return adapter_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, adapter_typeof(obj); }\nfunction adapter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction adapter_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, adapter_toPropertyKey(descriptor.key), descriptor); } }\nfunction adapter_createClass(Constructor, protoProps, staticProps) { if (protoProps) adapter_defineProperties(Constructor.prototype, protoProps); if (staticProps) adapter_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction adapter_toPropertyKey(arg) { var key = adapter_toPrimitive(arg, "string"); return adapter_typeof(key) === "symbol" ? key : String(key); }\nfunction adapter_toPrimitive(input, hint) { if (adapter_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (adapter_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n/**\n * 事件处理函数\n * @name EventAdapter~Handler\n * @function\n * @param {Event} event - 原生事件\n * @param {JFlow} jflow - 当前jflow 对象\n */\n\n/**\n * EventAdapter 对象 plugin 配置\n * @typedef {Object} EventAdapter~pluginDef\n * @property {Object} canvas - canvas 相关的事件\n * @property {EventAdapter~Handler} canvas.eventName - 注册 canvas 上的事件处理\n * @property {Object} document - document 相关的事件\n * @property {EventAdapter~Handler} document.eventName - 注册 document 上的事件处理\n */\n\nfunction getDefaultPlugin() {\n  var _mouseStatus = {\n    // x: undefined,\n    // y: undefined,\n    // enableClick: false,\n    pointerDown: false,\n    dirty: false\n  };\n  return {\n    canvas: {\n      wheel: function wheel(event, jflow) {\n        event.preventDefault();\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY,\n          deltaX = event.deltaX,\n          deltaY = event.deltaY;\n        if (event.ctrlKey) {\n          deltaY = -deltaY;\n          jflow.zoomHandler(offsetX, offsetY, deltaX, deltaY, event);\n        } else {\n          jflow.panHandler(-deltaX, -deltaY, event);\n        }\n      },\n      pointerdown: function pointerdown(event, jflow) {\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY,\n          deltaY = event.deltaY,\n          button = event.button;\n        if (button !== 0) return;\n        _mouseStatus.pointerDown = true;\n        jflow.pressStartHandler(offsetX, offsetY, event);\n      },\n      pointermove: function pointermove(event, jflow) {\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY;\n        if (_mouseStatus.pointerDown) {\n          _mouseStatus.dirty = true;\n        }\n        jflow.pressMoveHandler(offsetX, offsetY, event);\n      },\n      pointerup: function pointerup(event, jflow) {\n        event.preventDefault();\n        // event.stopPropagation(); ALWAYS ENABLE PROPAGATION \n        var offsetX = event.offsetX,\n          offsetY = event.offsetY,\n          button = event.button;\n        if (button !== 0) return;\n        if (_mouseStatus.pointerDown && _mouseStatus.dirty) {\n          _mouseStatus.pointerDown = false;\n          _mouseStatus.dirty = false;\n          jflow.pressUpHanlder(false, event);\n        }\n      },\n      contextmenu: function contextmenu(event, jflow) {\n        event.preventDefault();\n        event.stopPropagation();\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY;\n        jflow.contextMenuHanlder(offsetX, offsetY, event);\n      },\n      dblclick: function dblclick(event, jflow) {\n        event.preventDefault();\n        event.stopPropagation();\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY;\n        jflow.dblclickHandler(offsetX, offsetY, event);\n      },\n      click: function click(event, jflow) {\n        event.preventDefault();\n        event.stopPropagation();\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY;\n        if (!_mouseStatus.dirty) {\n          _mouseStatus.pointerDown = false;\n          _mouseStatus.dirty = false;\n          jflow.clickHanlder(offsetX, offsetY, event);\n        }\n      }\n    },\n    document: {\n      pointerup: function pointerup(event, jflow) {\n        jflow.pressUpHanlder(true, event);\n      }\n    }\n  };\n}\n\n/** \n * EventAdapter 对象\n * EventAdapter 通过 plugin 的形式实现多种交互方式的映射\n * @constructor EventAdapter\n */\nvar EventAdapter = /*#__PURE__*/function () {\n  function EventAdapter() {\n    var plugin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    adapter_classCallCheck(this, EventAdapter);\n    this.plugin = getDefaultPlugin();\n    this.use(plugin);\n    this.canvasHandlers = [];\n    this.documentHandlers = [];\n  }\n  adapter_createClass(EventAdapter, [{\n    key: "use",\n    value: function use() {\n      var plugin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var ca = plugin.canvas,\n        docObj = plugin.document;\n      if (ca) {\n        for (var eventName in ca) {\n          if (ca.hasOwnProperty(eventName)) {\n            this.plugin.canvas[eventName] = ca[eventName];\n          }\n        }\n      }\n      if (docObj) {\n        for (var _eventName in docObj) {\n          if (docObj.hasOwnProperty(_eventName)) {\n            this.plugin.document[_eventName] = docObj[_eventName];\n          }\n        }\n      }\n    }\n  }, {\n    key: "apply",\n    value: function apply(jflow) {\n      var _this = this;\n      var _this$plugin = this.plugin,\n        ca = _this$plugin.canvas,\n        docObj = _this$plugin.document;\n      var canvas = jflow.canvas;\n      var _loop = function _loop() {\n        var handler = ca[eventName];\n        function handlerWrapperd(e) {\n          handler(e, jflow);\n        }\n        canvas.addEventListener(eventName, handlerWrapperd);\n        _this.canvasHandlers.push({\n          eventName: eventName,\n          handlerWrapperd: handlerWrapperd\n        });\n      };\n      for (var eventName in ca) {\n        _loop();\n      }\n      var _loop2 = function _loop2() {\n        var handler;\n        var options = {};\n        if (typeof docObj[_eventName2] === \'function\') {\n          handler = docObj[_eventName2];\n        } else {\n          handler = docObj[_eventName2].handler;\n          Object.assign(options, docObj[_eventName2].options);\n        }\n        function handlerWrapperd(e) {\n          handler(e, jflow);\n        }\n        document.addEventListener(_eventName2, handlerWrapperd, options);\n        _this.documentHandlers.push({\n          eventName: _eventName2,\n          handlerWrapperd: handlerWrapperd,\n          options: options\n        });\n      };\n      for (var _eventName2 in docObj) {\n        _loop2();\n      }\n    }\n  }, {\n    key: "unload",\n    value: function unload(jflow) {\n      var canvas = jflow.canvas;\n      this.canvasHandlers.forEach(function (_ref) {\n        var eventName = _ref.eventName,\n          handlerWrapperd = _ref.handlerWrapperd;\n        canvas.removeEventListener(eventName, handlerWrapperd);\n      });\n      this.documentHandlers.forEach(function (_ref2) {\n        var eventName = _ref2.eventName,\n          handlerWrapperd = _ref2.handlerWrapperd,\n          options = _ref2.options;\n        console.log(\'unload\', eventName);\n        document.removeEventListener(eventName, handlerWrapperd, options);\n      });\n    }\n  }]);\n  return EventAdapter;\n}();\n/* harmony default export */ const adapter = (EventAdapter);\n;// CONCATENATED MODULE: ./src/core/instance/groupFactory.js\nfunction groupFactory_typeof(obj) { "@babel/helpers - typeof"; return groupFactory_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, groupFactory_typeof(obj); }\nfunction groupFactory_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, groupFactory_toPropertyKey(descriptor.key), descriptor); } }\nfunction groupFactory_createClass(Constructor, protoProps, staticProps) { if (protoProps) groupFactory_defineProperties(Constructor.prototype, protoProps); if (staticProps) groupFactory_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction groupFactory_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction groupFactory_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) groupFactory_setPrototypeOf(subClass, superClass); }\nfunction groupFactory_setPrototypeOf(o, p) { groupFactory_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return groupFactory_setPrototypeOf(o, p); }\nfunction groupFactory_createSuper(Derived) { var hasNativeReflectConstruct = groupFactory_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = groupFactory_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = groupFactory_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return groupFactory_possibleConstructorReturn(this, result); }; }\nfunction groupFactory_possibleConstructorReturn(self, call) { if (call && (groupFactory_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return groupFactory_assertThisInitialized(self); }\nfunction groupFactory_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction groupFactory_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction groupFactory_getPrototypeOf(o) { groupFactory_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return groupFactory_getPrototypeOf(o); }\nfunction groupFactory_slicedToArray(arr, i) { return groupFactory_arrayWithHoles(arr) || groupFactory_iterableToArrayLimit(arr, i) || groupFactory_unsupportedIterableToArray(arr, i) || groupFactory_nonIterableRest(); }\nfunction groupFactory_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction groupFactory_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return groupFactory_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return groupFactory_arrayLikeToArray(o, minLen); }\nfunction groupFactory_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction groupFactory_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction groupFactory_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction groupFactory_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction groupFactory_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? groupFactory_ownKeys(Object(source), !0).forEach(function (key) { groupFactory_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : groupFactory_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction groupFactory_defineProperty(obj, key, value) { key = groupFactory_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction groupFactory_toPropertyKey(arg) { var key = groupFactory_toPrimitive(arg, "string"); return groupFactory_typeof(key) === "symbol" ? key : String(key); }\nfunction groupFactory_toPrimitive(input, hint) { if (groupFactory_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (groupFactory_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n\n\n\nvar GroupMixin = groupFactory_objectSpread(groupFactory_objectSpread(groupFactory_objectSpread({}, stackMixin), layoutMixin), {}, {\n  _setPadding: function _setPadding(configs) {\n    this.padding = {\n      top: configs.paddingTop || configs.padding || 0,\n      right: configs.paddingRight || configs.padding || 0,\n      bottom: configs.paddingBottom || configs.padding || 0,\n      left: configs.paddingLeft || configs.padding || 0\n    };\n  },\n  _setMargin: function _setMargin(configs) {\n    this.margin = {\n      top: configs.marginTop || configs.margin || 0,\n      right: configs.marginRight || configs.margin || 0,\n      bottom: configs.marginBottom || configs.margin || 0,\n      left: configs.marginLeft || configs.margin || 0\n    };\n  },\n  _getCenter: function _getCenter() {\n    var anchor = this.anchor;\n    var padding = this.padding;\n    var margin = this.margin;\n    var mx = (margin.left - margin.right) / 2;\n    var my = (margin.top - margin.bottom) / 2;\n    var centerX = (padding.left - padding.right) / 2 + mx;\n    var centerY = (padding.top - padding.bottom) / 2 + my;\n    this._shape.anchor = [anchor[0] + mx, anchor[1] + my];\n    this._center[0] = anchor[0] + centerX;\n    this._center[1] = anchor[1] + centerY;\n    return this._center;\n  },\n  setAnchorX: function setAnchorX(x) {\n    this.anchor[0] = x;\n    this._getCenter();\n  },\n  setAnchorY: function setAnchorY(y) {\n    this.anchor[1] = y;\n    this._getCenter();\n  },\n  setAnchor: function setAnchor(x, y) {\n    this.anchor[0] = x;\n    this.anchor[1] = y;\n    this._getCenter();\n  },\n  _calculatePointBack: function _calculatePointBack(point) {\n    var _point = groupFactory_slicedToArray(point, 2),\n      gx = _point[0],\n      gy = _point[1];\n    var _this$_getCenter = this._getCenter(),\n      _this$_getCenter2 = groupFactory_slicedToArray(_this$_getCenter, 2),\n      cx = _this$_getCenter2[0],\n      cy = _this$_getCenter2[1];\n    var p = [gx - cx, gy - cy];\n    return p;\n  },\n  _calculatePointBackWithPoint: function _calculatePointBackWithPoint(a, b, arr, idx1, idx2) {\n    var anchor = this.anchor;\n    var padding = this.padding;\n    var margin = this.margin;\n    arr[idx1] = a - (anchor[0] + (padding.left - padding.right) / 2 + (margin.left - margin.right) / 2);\n    arr[idx2] = b - (anchor[1] + (padding.top - padding.bottom) / 2 + (margin.top - margin.bottom) / 2);\n  },\n  /**\n   * 反算回 canvas 顶层坐标\n   * @param {Number[]} point\n   * @return {Number[]} 世界坐标\n   */\n  calculateToCoordination: function calculateToCoordination(point) {\n    var _point2 = groupFactory_slicedToArray(point, 2),\n      gx = _point2[0],\n      gy = _point2[1];\n    var _this$_getCenter3 = this._getCenter(),\n      _this$_getCenter4 = groupFactory_slicedToArray(_this$_getCenter3, 2),\n      cx = _this$_getCenter4[0],\n      cy = _this$_getCenter4[1];\n    // const p = [cx + anchor[0] - spanH, cy + anchor[1] - spanV];\n    var p = [gx + cx, gy + cy];\n    if (this._belongs && this._belongs.calculateToCoordination) {\n      return this._belongs.calculateToCoordination(p);\n    } else {\n      return p;\n    }\n  },\n  /**\n   * 反算回页面的像素坐标，重载 {@link Instance#calculateToRealWorld}\n   * @param {Number[]} point\n   * @return {Number[]} 世界坐标\n   */\n  calculateToRealWorld: function calculateToRealWorld(point) {\n    var _point3 = groupFactory_slicedToArray(point, 2),\n      gx = _point3[0],\n      gy = _point3[1];\n    var _this$_getCenter5 = this._getCenter(),\n      _this$_getCenter6 = groupFactory_slicedToArray(_this$_getCenter5, 2),\n      cx = _this$_getCenter6[0],\n      cy = _this$_getCenter6[1];\n    var p = [gx + cx, gy + cy];\n    if (this._belongs && this._belongs.calculateToRealWorld) {\n      return this._belongs.calculateToRealWorld(p);\n    }\n  },\n  calculateToRealWorldWithPointer: function calculateToRealWorldWithPointer(outpoint, inpoint) {\n    outpoint[0] = inpoint[0] + this._center[0];\n    outpoint[1] = inpoint[1] + this._center[1];\n    if (this._belongs && this._belongs.calculateToRealWorldWithPointer) {\n      return this._belongs.calculateToRealWorldWithPointer(outpoint, outpoint);\n    }\n  },\n  clone: function clone() {\n    var C = this.constructor;\n    var configs = Object.assign({}, this._rawConfigs, {\n      layout: this._layout && this._layout.clone()\n    });\n    var t = new C(configs);\n    this.interateNodeStack(function (instance) {\n      t.addToStack(instance.clone());\n    });\n    t.recalculate();\n    t.visible = this.visible;\n    return t;\n  },\n  getBoundingDimension: function getBoundingDimension() {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  },\n  getBoundingRect: function getBoundingRect() {\n    var anchor = this.anchor;\n    var w = this.width / 2;\n    var h = this.height / 2;\n    var ltx = anchor[0] - w;\n    var lty = anchor[1] - h;\n    var rbx = anchor[0] + w;\n    var rby = anchor[1] + h;\n    var br = this._boundingrect;\n    br[0] = ltx;\n    br[1] = lty;\n    br[2] = rbx;\n    br[3] = rby;\n    return br;\n  },\n  getIntersectionsInFourDimension: function getIntersectionsInFourDimension() {\n    var _ref;\n    var p2 = this.anchor;\n    if (this._belongs && this._belongs.calculateToCoordination) {\n      p2 = this._belongs.calculateToCoordination(p2);\n    }\n    var _p = p2,\n      _p2 = groupFactory_slicedToArray(_p, 2),\n      x2 = _p2[0],\n      y2 = _p2[1];\n    var w = this.width / 2;\n    var h = this.height / 2;\n    return _ref = {}, groupFactory_defineProperty(_ref, DIRECTION.RIGHT, [x2 + w, y2]), groupFactory_defineProperty(_ref, DIRECTION.LEFT, [x2 - w, y2]), groupFactory_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + h]), groupFactory_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - h]), groupFactory_defineProperty(_ref, DIRECTION.SELF, [x2 + w * 0.618, y2 + h * 0.618]), _ref;\n  },\n  calculateIntersection: function calculateIntersection(point) {\n    var _point4 = groupFactory_slicedToArray(point, 2),\n      x1 = _point4[0],\n      y1 = _point4[1];\n    var _this$anchor = groupFactory_slicedToArray(this.anchor, 2),\n      x2 = _this$anchor[0],\n      y2 = _this$anchor[1];\n    var w = this.width / 2;\n    var h = this.height / 2;\n    var vecx = x2 - x1;\n    var vecy = y2 - y1;\n    var theta1 = h / w;\n    var theta2 = Math.abs(vecy / vecx);\n    var dirx = x1 > x2;\n    var diry = y1 > y2;\n    var x, y;\n    if (theta2 < theta1) {\n      x = x2 + (dirx ? w : -w);\n      y = w * (diry ? theta2 : -theta2) + y2;\n    } else {\n      y = y2 + (diry ? h : -h);\n      x = h / (dirx ? theta2 : -theta2) + x2;\n    }\n    return [x, y];\n  },\n  onEnterViewbox: function onEnterViewbox() {\n    this.interateNodeStack(function (instance) {\n      instance.onEnterViewbox();\n    });\n  },\n  onLeaveViewbox: function onLeaveViewbox() {\n    this.interateNodeStack(function (instance) {\n      instance.onLeaveViewbox();\n    });\n  },\n  destroy: function destroy() {\n    this._shape.destroy();\n    this.interateNodeStack(function (instance) {\n      instance.destroy();\n    });\n  },\n  doRecalculate: function doRecalculate() {\n    if (this.__mounted__) {\n      this.recalculateUp();\n    } else {\n      this.recalculate();\n      this.__mounted__ = true;\n    }\n  }\n});\nfunction defaultShift(width, height) {\n  return [width, height];\n}\n\n/**\n * 根据paddingbox宽高来计算shapeshiftbox的宽高\n * @function shapeShift\n * @param {number} width            - paddingBox宽\n * @param {number} height           - paddingBox高\n * @return {number[]}\n */\n\n/**\n * 组工厂函数，用于通过JFlow 绘图节点来创建不同的组\n * @global \n * @function GroupFactory\n * @param {Node} jflowNodeConstructor - 绘图节点构造器\n * @param {object} options            - 配置项\n * @param {shapeShift} options.shapeShift - shift层适配方法\n * @return {Group} - 绘图节点构造器\n */\nfunction GroupFactory(jflowNodeConstructor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var shapeShift = typeof options.shapeShift === \'function\' ? options.shapeShift : defaultShift;\n\n  /**\n   * Group 配置\n   * @typedef {Object} GroupTemplate~GroupConfigs\n   * @property {number} width             - 设定宽度\n   * @property {number} minWidth          - 最小宽度\n   * @property {number} height            - 设定高度\n   * @property {number} padding          - 内边距\n   * @property {number} paddingTop          - 内上边距\n   * @property {number} paddingRight         - 内右边距\n   * @property {number} paddingBottom        - 内下边距\n   * @property {number} paddingLeft          - 内左边距\n   * @property {number} margin            - 外边距\n   * @property {number} marginTop          - 外上边距\n   * @property {number} marginRight         - 外右边距\n   * @property {number} marginBottom        - 外下边距\n   * @property {number} marginLeft          - 外左边距\n   * @property {boolean} lock            - 布局锁定状态 默认 true\n   */\n  var t = /*#__PURE__*/function (_Node) {\n    groupFactory_inherits(t, _Node);\n    var _super = groupFactory_createSuper(t);\n    /**\n    * @constructs GroupTemplate\n    * @param {GroupTemplate~GroupConfigs} configs - 组配置\n    * @mixes LayoutMixin\n    * @mixes StackMixin \n    */\n    function t(configs) {\n      var _configs$lock, _configs$transparent;\n      var _this;\n      groupFactory_classCallCheck(this, t);\n      _this = _super.call(this, configs);\n      _this.initStack(configs);\n      _this.initLayout(configs);\n      /** @member {Node}      - 壳绘图单元 */\n      _this._shape = new jflowNodeConstructor(configs);\n      _this._shape.anchor = [0, 0];\n      _this._shape._belongs = groupFactory_assertThisInitialized(_this);\n      _this._center = [0, 0];\n      _this._setPadding(configs);\n      _this._setMargin(configs);\n      /** @member {Number}      - 设定宽度 */\n      _this.definedWidth = configs.width;\n      /** @member {Number}      - 最小宽度 */\n      _this.minWidth = configs.minWidth;\n      /** @member {Number}      - 设定的高度 */\n      _this.definedHeight = configs.height;\n      /** @member {Boolean}      - 组内元素是否锁定， 默认true */\n      _this.lock = (_configs$lock = configs.lock) !== null && _configs$lock !== void 0 ? _configs$lock : true;\n      _this.display = configs.display || \'default\';\n      /** @member {Boolean}      - 组本身是否进入形状判定范围 */\n      _this.transparent = (_configs$transparent = configs.transparent) !== null && _configs$transparent !== void 0 ? _configs$transparent : false;\n      _this._getBoundingGroupRect();\n      _this.reflow();\n      _this._getBoundingGroupRect();\n      _this._cacheViewBox = [];\n      return _this;\n    }\n    return groupFactory_createClass(t);\n  }(node);\n  Object.assign(t.prototype, GroupMixin);\n  Object.assign(t.prototype, {\n    reflow: function reflow() {\n      GroupMixin.reflow.call(this);\n      var margin = this.margin;\n      var _shapeShift = shapeShift(this.width - margin.left - margin.right, this.height - margin.top - margin.bottom, this._shape),\n        _shapeShift2 = groupFactory_slicedToArray(_shapeShift, 2),\n        shapeWidth = _shapeShift2[0],\n        shapeHeight = _shapeShift2[1];\n      this._shape.width = shapeWidth;\n      this._shape.height = shapeHeight;\n    },\n    setConfig: function setConfig(configs) {\n      this._shape.setConfig(configs);\n      this._setPadding(configs);\n      this._setMargin(configs);\n      if (\'opacity\' in configs) {\n        this.opacity = configs.opacity;\n      }\n      if (configs.layout && this._layout !== configs.layout) {\n        this._layout = configs.layout;\n      }\n    },\n    _getBoundingGroupRect: function _getBoundingGroupRect() {\n      var points = this._stack.getBoundingRectPoints();\n      // content box \n      var bbox = bounding_box(points);\n\n      // padding box \n      var padding = this.padding;\n      var minWidth = this.minWidth; // - padding.left - padding.right;\n      var definedWidth = this.definedWidth; // - padding.left - padding.right;\n      var w = bbox.width + padding.left + padding.right;\n      var h = bbox.height + padding.top + padding.bottom;\n      var paddingWidth = minWidth ? Math.max(minWidth, w) : definedWidth || w;\n      var paddingHeight = this.definedHeight || h;\n      this._paddingWidth = paddingWidth;\n      this._paddingHeight = paddingHeight;\n\n      // shapeBox\n      var _shapeShift3 = shapeShift(paddingWidth, paddingHeight, this._shape),\n        _shapeShift4 = groupFactory_slicedToArray(_shapeShift3, 2),\n        shapeWidth = _shapeShift4[0],\n        shapeHeight = _shapeShift4[1];\n      this._shape.width = shapeWidth;\n      this._shape.height = shapeHeight;\n      // marginBox\n      var margin = this.margin;\n      this.width = shapeWidth + margin.left + margin.right;\n      this.height = shapeHeight + margin.top + margin.bottom;\n    },\n    _getViewBox: function _getViewBox() {\n      var belongs_vbox = this._belongs.getCacheViewBox();\n      var cacheViewBox = this._cacheViewBox;\n      this._calculatePointBackWithPoint(belongs_vbox[0], belongs_vbox[1], cacheViewBox, 0, 1);\n      this._calculatePointBackWithPoint(belongs_vbox[2], belongs_vbox[3], cacheViewBox, 2, 3);\n      return this._cacheViewBox;\n    },\n    getCacheViewBox: function getCacheViewBox() {\n      return this._cacheViewBox;\n    },\n    render: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      } else if (this.opacity !== 1) {\n        ctx.globalAlpha = this.opacity;\n      }\n      var _this$_getCenter7 = this._getCenter(),\n        _this$_getCenter8 = groupFactory_slicedToArray(_this$_getCenter7, 2),\n        cx = _this$_getCenter8[0],\n        cy = _this$_getCenter8[1];\n      this._shape.render(ctx);\n      ctx.translate(cx, cy);\n      this._stack.render(ctx);\n      // this._linkStack.render(ctx);    \n      ctx.translate(-cx, -cy);\n      ctx.restore();\n\n      // ctx.save();\n      // ctx.beginPath();\n      // ctx.arc(cx, cy, 5, 0, Math.PI*2);\n      // ctx.fillStyle = \'rgb(0,0,0)\'\n      // ctx.fill();\n      // ctx.restore();\n    },\n    isHit: function isHit(point, condition) {\n      var p = this._calculatePointBack(point);\n      this._currentp = p; // 暂存，为了后续计算别的位置\n      var target = this._stack.checkHit(p, condition);\n      if (target) return target;\n      if (!this.transparent) {\n        return this._shape.isHit(point);\n      }\n      return false;\n    }\n  });\n  return t;\n}\n/* harmony default export */ const groupFactory = (GroupFactory);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/point.js\nfunction point_typeof(obj) { "@babel/helpers - typeof"; return point_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, point_typeof(obj); }\nfunction point_defineProperty(obj, key, value) { key = point_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction point_slicedToArray(arr, i) { return point_arrayWithHoles(arr) || point_iterableToArrayLimit(arr, i) || point_unsupportedIterableToArray(arr, i) || point_nonIterableRest(); }\nfunction point_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction point_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return point_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return point_arrayLikeToArray(o, minLen); }\nfunction point_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction point_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction point_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction point_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction point_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, point_toPropertyKey(descriptor.key), descriptor); } }\nfunction point_createClass(Constructor, protoProps, staticProps) { if (protoProps) point_defineProperties(Constructor.prototype, protoProps); if (staticProps) point_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction point_toPropertyKey(arg) { var key = point_toPrimitive(arg, "string"); return point_typeof(key) === "symbol" ? key : String(key); }\nfunction point_toPrimitive(input, hint) { if (point_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (point_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction point_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) point_setPrototypeOf(subClass, superClass); }\nfunction point_setPrototypeOf(o, p) { point_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return point_setPrototypeOf(o, p); }\nfunction point_createSuper(Derived) { var hasNativeReflectConstruct = point_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = point_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = point_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return point_possibleConstructorReturn(this, result); }; }\nfunction point_possibleConstructorReturn(self, call) { if (call && (point_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return point_assertThisInitialized(self); }\nfunction point_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction point_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction point_getPrototypeOf(o) { point_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return point_getPrototypeOf(o); }\n\n\n/**\n * 圆形单元 配置\n * @typedef {Node~Configs} Point~PointConfigs\n * @property {number} radius  - 半径\n */\n/**\n * 圆形节点\n * @constructor Point\n * @extends Node\n * @param {Point~PointConfigs} configs - 配置\n */\nvar Point = /*#__PURE__*/function (_Node) {\n  point_inherits(Point, _Node);\n  var _super = point_createSuper(Point);\n  function Point(configs) {\n    var _this;\n    point_classCallCheck(this, Point);\n    _this = _super.call(this, configs);\n    _this.type = \'Point\';\n    /** @member {Number}      - 半径 */\n    _this.radius = configs.radius || 10;\n    _this._doCache();\n    return _this;\n  }\n  point_createClass(Point, [{\n    key: "setConfig",\n    value: function setConfig(configs) {\n      var _this2 = this;\n      Object.keys(configs).forEach(function (k) {\n        if (configs[k] !== undefined && configs[k] !== null) {\n          _this2[k] = configs[k];\n          _this2._rawConfigs[k] = configs[k];\n        }\n      });\n      this._doCache();\n    }\n  }, {\n    key: "_doCache",\n    value: function _doCache() {\n      this.width = this.radius * 2;\n      this.height = this.radius * 2;\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      ctx.beginPath();\n      ctx.arc(this.anchor[0], this.anchor[1], this.radius, 0, 2 * Math.PI);\n      ctx.fillStyle = this.backgroundColor;\n      ctx.fill();\n      if (this.borderWidth) {\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeStyle = this.borderColor;\n        ctx.stroke();\n      }\n      // if(this._isTargeting) {\n      //     this.renderFocus(ctx);\n      // }\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      var anchor = this.anchor;\n      return Math.pow(point[0] - anchor[0], 2) + Math.pow(point[1] - anchor[1], 2) < this.radius * this.radius;\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var r = this.radius;\n      var ltx = anchor[0] - r;\n      var lty = anchor[1] - r;\n      var rbx = anchor[0] + r;\n      var rby = anchor[1] + r;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }, {\n    key: "calculateIntersection",\n    value: function calculateIntersection(point) {\n      var _point = point_slicedToArray(point, 2),\n        x1 = _point[0],\n        y1 = _point[1];\n      var _this$anchor = point_slicedToArray(this.anchor, 2),\n        x2 = _this$anchor[0],\n        y2 = _this$anchor[1];\n      var vecx = x2 - x1;\n      var vecy = y2 - y1;\n      var dist = Math.sqrt(vecx * vecx + vecy * vecy);\n      var ratio = this.radius / dist;\n      return [x2 - ratio * vecx, y2 - ratio * vecy];\n    }\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      var _ref;\n      var _this$anchor2 = point_slicedToArray(this.anchor, 2),\n        x2 = _this$anchor2[0],\n        y2 = _this$anchor2[1];\n      var r = this.radius;\n      return _ref = {}, point_defineProperty(_ref, DIRECTION.RIGHT, [x2 + r, y2]), point_defineProperty(_ref, DIRECTION.LEFT, [x2 - r, y2]), point_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + r]), point_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - r]), _ref;\n    }\n  }, {\n    key: "calculateIntersectionInFourDimension",\n    value: function calculateIntersectionInFourDimension(point, end) {\n      var _allIntersections;\n      var _point2 = point_slicedToArray(point, 2),\n        x1 = _point2[0],\n        y1 = _point2[1];\n      var _this$anchor3 = point_slicedToArray(this.anchor, 2),\n        x2 = _this$anchor3[0],\n        y2 = _this$anchor3[1];\n      var r = this.radius;\n      var vecx = x2 - x1;\n      var vecy = y2 - y1;\n      var allIntersections = (_allIntersections = {}, point_defineProperty(_allIntersections, DIRECTION.RIGHT, [x2 + r, y2]), point_defineProperty(_allIntersections, DIRECTION.LEFT, [x2 - r, y2]), point_defineProperty(_allIntersections, DIRECTION.BOTTOM, [x2, y2 + r]), point_defineProperty(_allIntersections, DIRECTION.TOP, [x2, y2 - r]), _allIntersections);\n      // console.log(Math.abs(vecx) > Math.abs(vecy), vecx, r)\n      // if() {\n      //     return {\n      //         p: [x2 + (vecx<0?r:-r), y2],\n      //         dir: vecx<0 ? DIRECTION.RIGHT : DIRECTION.LEFT,\n      //     }\n      // } else {\n      //     return {\n      //         p: [x2, y2+(vecy<0?r:-r)],\n      //         dir: vecy<0 ? DIRECTION.BOTTOM : DIRECTION.TOP,\n      //     }\n      // }\n      var interDir = Math.abs(vecy) > Math.abs(vecx) ? vecy < 0 ? DIRECTION.BOTTOM : DIRECTION.TOP : vecx < 0 ? DIRECTION.RIGHT : DIRECTION.LEFT;\n\n      // interDir = this.checkLinked(interDir, end);\n      return {\n        p: allIntersections[interDir],\n        dir: interDir\n      };\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        width: this.width,\n        height: this.height\n      };\n    }\n  }]);\n  return Point;\n}(node);\n/* harmony default export */ const point = (Point);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/rectangle.js\nfunction rectangle_typeof(obj) { "@babel/helpers - typeof"; return rectangle_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, rectangle_typeof(obj); }\nfunction rectangle_defineProperty(obj, key, value) { key = rectangle_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction rectangle_slicedToArray(arr, i) { return rectangle_arrayWithHoles(arr) || rectangle_iterableToArrayLimit(arr, i) || rectangle_unsupportedIterableToArray(arr, i) || rectangle_nonIterableRest(); }\nfunction rectangle_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction rectangle_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return rectangle_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return rectangle_arrayLikeToArray(o, minLen); }\nfunction rectangle_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction rectangle_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction rectangle_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction rectangle_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction rectangle_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, rectangle_toPropertyKey(descriptor.key), descriptor); } }\nfunction rectangle_createClass(Constructor, protoProps, staticProps) { if (protoProps) rectangle_defineProperties(Constructor.prototype, protoProps); if (staticProps) rectangle_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction rectangle_toPropertyKey(arg) { var key = rectangle_toPrimitive(arg, "string"); return rectangle_typeof(key) === "symbol" ? key : String(key); }\nfunction rectangle_toPrimitive(input, hint) { if (rectangle_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (rectangle_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction rectangle_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) rectangle_setPrototypeOf(subClass, superClass); }\nfunction rectangle_setPrototypeOf(o, p) { rectangle_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rectangle_setPrototypeOf(o, p); }\nfunction rectangle_createSuper(Derived) { var hasNativeReflectConstruct = rectangle_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rectangle_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rectangle_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rectangle_possibleConstructorReturn(this, result); }; }\nfunction rectangle_possibleConstructorReturn(self, call) { if (call && (rectangle_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return rectangle_assertThisInitialized(self); }\nfunction rectangle_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction rectangle_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction rectangle_getPrototypeOf(o) { rectangle_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rectangle_getPrototypeOf(o); }\n\n\n/**\n * @typedef Rectangle~border\n * @type {object}\n * @property {number} borderColor      - 边框宽度, 默认 0\n * @property {number} borderWidth      - 边框颜色, 默认 transparent\n */\n/**\n * @typedef Rectangle~borders\n * @type {object}\n * @property {Rectangle~border} top      - 上边框\n * @property {Rectangle~border} right      - 右边框\n * @property {Rectangle~border} bottom      - 下边框\n * @property {Rectangle~border} left      - 左边框\n */\n\n/**\n * 矩形单元 配置\n * @typedef {Node~Configs} Rectangle~RectangleConfigs\n * @property {number} width - 宽\n * @property {number} height - 高\n * @property {number} borderRadius - 圆角矩形半径\n * @property {string} borderColor - 边框颜色, 默认 transparent\n * @property {string} borderWidth - 边框宽度, 默认 0\n * @property {Rectangle~borders} border      - 边框设置\n */\n/**\n * 矩形单元\n * @constructor Rectangle\n * @extends Node\n * @param {Rectangle~RectangleConfigs} configs\n */\nvar Rectangle = /*#__PURE__*/function (_Node) {\n  rectangle_inherits(Rectangle, _Node);\n  var _super = rectangle_createSuper(Rectangle);\n  function Rectangle() {\n    var _this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    rectangle_classCallCheck(this, Rectangle);\n    _this = _super.call(this, configs);\n    _this.type = \'Rectangle\';\n    /** @member {Number}      - 宽 */\n    _this.width = configs.width || 10;\n    /** @member {Number}      - 高 */\n    _this.height = configs.height || 10;\n    /** @member {Number}      - 圆角矩形半径 */\n    _this.borderRadius = configs.borderRadius || 0;\n    _this._setBorder(configs);\n    return _this;\n  }\n  rectangle_createClass(Rectangle, [{\n    key: "_setBorder",\n    value: function _setBorder(configs) {\n      var _configs$border, _configs$border2, _configs$border3, _configs$border4, _configs$border5, _configs$border6, _configs$border7, _configs$border8, _configs$border9, _configs$border10, _configs$border11, _configs$border12;\n      /** @member {Rectangle~borders}      - 边框设置，优先级高于 borderWidth，borderColor */\n      this.border = {\n        top: {\n          color: ((_configs$border = configs.border) === null || _configs$border === void 0 || (_configs$border = _configs$border.top) === null || _configs$border === void 0 ? void 0 : _configs$border.borderColor) || configs.borderColor || \'transparent\',\n          width: ((_configs$border2 = configs.border) === null || _configs$border2 === void 0 || (_configs$border2 = _configs$border2.top) === null || _configs$border2 === void 0 ? void 0 : _configs$border2.borderWidth) || configs.borderWidth || 0,\n          enable: (_configs$border3 = configs.border) === null || _configs$border3 === void 0 || (_configs$border3 = _configs$border3.top) === null || _configs$border3 === void 0 ? void 0 : _configs$border3.borderWidth\n        },\n        right: {\n          color: ((_configs$border4 = configs.border) === null || _configs$border4 === void 0 || (_configs$border4 = _configs$border4.right) === null || _configs$border4 === void 0 ? void 0 : _configs$border4.borderColor) || configs.borderColor || \'transparent\',\n          width: ((_configs$border5 = configs.border) === null || _configs$border5 === void 0 || (_configs$border5 = _configs$border5.right) === null || _configs$border5 === void 0 ? void 0 : _configs$border5.borderWidth) || configs.borderWidth || 0,\n          enable: (_configs$border6 = configs.border) === null || _configs$border6 === void 0 || (_configs$border6 = _configs$border6.right) === null || _configs$border6 === void 0 ? void 0 : _configs$border6.borderWidth\n        },\n        bottom: {\n          color: ((_configs$border7 = configs.border) === null || _configs$border7 === void 0 || (_configs$border7 = _configs$border7.bottom) === null || _configs$border7 === void 0 ? void 0 : _configs$border7.borderColor) || configs.borderColor || \'transparent\',\n          width: ((_configs$border8 = configs.border) === null || _configs$border8 === void 0 || (_configs$border8 = _configs$border8.bottom) === null || _configs$border8 === void 0 ? void 0 : _configs$border8.borderWidth) || configs.borderWidth || 0,\n          enable: (_configs$border9 = configs.border) === null || _configs$border9 === void 0 || (_configs$border9 = _configs$border9.bottom) === null || _configs$border9 === void 0 ? void 0 : _configs$border9.borderWidth\n        },\n        left: {\n          color: ((_configs$border10 = configs.border) === null || _configs$border10 === void 0 || (_configs$border10 = _configs$border10.left) === null || _configs$border10 === void 0 ? void 0 : _configs$border10.borderColor) || configs.borderColor || \'transparent\',\n          width: ((_configs$border11 = configs.border) === null || _configs$border11 === void 0 || (_configs$border11 = _configs$border11.left) === null || _configs$border11 === void 0 ? void 0 : _configs$border11.borderWidth) || configs.borderWidth || 0,\n          enable: (_configs$border12 = configs.border) === null || _configs$border12 === void 0 || (_configs$border12 = _configs$border12.left) === null || _configs$border12 === void 0 ? void 0 : _configs$border12.borderWidth\n        }\n      };\n      this.borderColor = configs.borderColor || \'transparent\';\n      this.borderWidth = configs.borderWidth || 0;\n    }\n  }, {\n    key: "setConfig",\n    value: function setConfig(configs) {\n      var _this2 = this;\n      Object.keys(configs).forEach(function (k) {\n        if (configs[k] !== undefined && configs[k] !== null) {\n          _this2[k] = configs[k];\n          _this2._rawConfigs[k] = configs[k];\n        }\n      });\n      this._setBorder(configs);\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      var radius = this.borderRadius,\n        anchor = this.anchor,\n        width = this.width,\n        height = this.height;\n      var x = this.anchor[0] - this.width / 2;\n      var y = this.anchor[1] - this.height / 2;\n      var xt = this.anchor[0] + this.width / 2;\n      var yt = this.anchor[1] + this.height / 2;\n      if (this.borderRadius) {\n        ctx.beginPath();\n        ctx.moveTo(x + radius, y);\n        ctx.lineTo(x + width - radius, y);\n        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n        ctx.lineTo(x + width, y + height - radius);\n        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n        ctx.lineTo(x + radius, y + height);\n        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n        ctx.lineTo(x, y + radius);\n        ctx.quadraticCurveTo(x, y, x + radius, y);\n        ctx.closePath();\n      } else {\n        ctx.beginPath();\n        ctx.rect(this.anchor[0] - this.width / 2, this.anchor[1] - this.height / 2, this.width, this.height);\n      }\n      if (this.borderWidth) {\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeStyle = this.borderColor;\n      }\n      if (this.shadowColor && this.shadowColor !== \'transparent\') {\n        ctx.shadowColor = this.shadowColor;\n        var scale = this._jflow.scale;\n        ctx.shadowBlur = this.shadowBlur * scale;\n        ctx.shadowOffsetX = this.shadowOffsetX * scale;\n        ctx.shadowOffsetY = this.shadowOffsetY * scale;\n        var switchPath = new Path2D();\n        if (this.borderRadius) {\n          switchPath.moveTo(x + radius, y);\n          switchPath.lineTo(x + width - radius, y);\n          switchPath.quadraticCurveTo(x + width, y, x + width, y + radius);\n          switchPath.lineTo(x + width, y + height - radius);\n          switchPath.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n          switchPath.lineTo(x + radius, y + height);\n          switchPath.quadraticCurveTo(x, y + height, x, y + height - radius);\n          switchPath.lineTo(x, y + radius);\n          switchPath.quadraticCurveTo(x, y, x + radius, y);\n          switchPath.closePath();\n        } else {\n          switchPath.rect(this.anchor[0] - this.width / 2, this.anchor[1] - this.height / 2, this.width, this.height);\n        }\n        switchPath.rect(x - 10, y - 10, this.width + 20, this.height + 20);\n        ctx.save();\n        ctx.clip(switchPath, "evenodd");\n        ctx.stroke();\n        ctx.restore();\n      }\n      ctx.fillStyle = this.backgroundColor;\n      ctx.fill();\n      if (this.borderRadius && this.borderWidth) {\n        ctx.shadowColor = \'transparent\';\n        ctx.stroke();\n      }\n      if (this.borderRadius) {\n        if (this.border.top.enable) {\n          var ty = y - this.border.top.width / 2;\n          // console.log(this.border.top.width)\n          ctx.beginPath();\n          var topPath = new Path2D();\n          topPath.moveTo(x, ty + radius);\n          topPath.quadraticCurveTo(x, ty, x + radius, ty);\n          topPath.lineTo(x + width - radius, ty);\n          topPath.quadraticCurveTo(x + width, ty, x + width, ty + radius);\n          topPath.closePath();\n          ctx.clip(topPath);\n          ctx.save();\n          ctx.shadowColor = \'transparent\';\n          ctx.fillStyle = this.border.top.color;\n          ctx.rect(x, ty, this.width, this.border.top.width);\n          ctx.fill();\n          ctx.restore();\n\n          // ctx.stroke();\n          // ctx.save();\n          // ctx.beginPath();\n          // ctx.moveTo(x, ty + radius);\n          // ctx.quadraticCurveTo(x, ty, x + radius, ty);\n          // ctx.lineTo(x + width - radius, ty);\n          // ctx.quadraticCurveTo(x + width, ty, x + width, ty + radius);\n          // ctx.closePath();\n\n          // // ctx.fill();\n          // ctx.clip();\n\n          // ctx.beginPath();\n          // ctx.rect(x, ty, this.width, this.border.top.width);\n          // ctx.fillStyle = this.border.top.color;\n          // ctx.shadowColor = \'transparent\';\n          // ctx.fill();\n          // ctx.restore();\n        }\n      } else {\n        if (this.border.top.width) {\n          ctx.beginPath();\n          ctx.moveTo(x, y);\n          ctx.lineTo(xt, y);\n          ctx.strokeStyle = this.border.top.color;\n          ctx.lineWidth = this.border.top.width;\n          ctx.stroke();\n        }\n        if (this.border.right.width) {\n          ctx.beginPath();\n          ctx.moveTo(xt, y);\n          ctx.lineTo(xt, yt);\n          ctx.strokeStyle = this.border.right.color;\n          ctx.lineWidth = this.border.right.width;\n          ctx.stroke();\n        }\n        if (this.border.bottom.width) {\n          ctx.beginPath();\n          ctx.moveTo(xt, yt);\n          ctx.lineTo(x, yt);\n          ctx.strokeStyle = this.border.bottom.color;\n          ctx.lineWidth = this.border.bottom.width;\n          ctx.stroke();\n        }\n        if (this.border.left.width) {\n          ctx.beginPath();\n          ctx.moveTo(x, yt);\n          ctx.lineTo(x, y);\n          ctx.strokeStyle = this.border.left.color;\n          ctx.lineWidth = this.border.left.width;\n          ctx.stroke();\n        }\n      }\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      return point[0] > anchor[0] - w && point[0] < anchor[0] + w && point[1] > anchor[1] - h && point[1] < anchor[1] + h;\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var ltx = anchor[0] - w;\n      var lty = anchor[1] - h;\n      var rbx = anchor[0] + w;\n      var rby = anchor[1] + h;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        height: this.height,\n        width: this.width\n      };\n    }\n  }, {\n    key: "calculateIntersection",\n    value: function calculateIntersection(point) {\n      var _point = rectangle_slicedToArray(point, 2),\n        x1 = _point[0],\n        y1 = _point[1];\n      var _this$anchor = rectangle_slicedToArray(this.anchor, 2),\n        x2 = _this$anchor[0],\n        y2 = _this$anchor[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var vecx = x2 - x1;\n      var vecy = y2 - y1;\n      var theta1 = h / w;\n      var theta2 = Math.abs(vecy / vecx);\n      var dirx = x1 > x2;\n      var diry = y1 > y2;\n      var x, y;\n      if (theta2 < theta1) {\n        x = x2 + (dirx ? w : -w);\n        y = w * (diry ? theta2 : -theta2) + y2;\n      } else {\n        y = y2 + (diry ? h : -h);\n        x = h / (dirx ? theta2 : -theta2) + x2;\n      }\n      return [x, y];\n    }\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      var _ref;\n      var p2 = this.anchor;\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        p2 = this._belongs.calculateToCoordination(p2);\n      }\n      var _p = p2,\n        _p2 = rectangle_slicedToArray(_p, 2),\n        x2 = _p2[0],\n        y2 = _p2[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      return _ref = {}, rectangle_defineProperty(_ref, DIRECTION.RIGHT, [x2 + w, y2]), rectangle_defineProperty(_ref, DIRECTION.LEFT, [x2 - w, y2]), rectangle_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + h]), rectangle_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - h]), _ref;\n    }\n  }, {\n    key: "calculateIntersectionInFourDimension",\n    value: function calculateIntersectionInFourDimension(point, end) {\n      var _allIntersections;\n      var _point2 = rectangle_slicedToArray(point, 2),\n        x1 = _point2[0],\n        y1 = _point2[1];\n      var p2 = this.anchor;\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        p2 = this._belongs.calculateToCoordination(p2);\n      }\n      var _p3 = p2,\n        _p4 = rectangle_slicedToArray(_p3, 2),\n        x2 = _p4[0],\n        y2 = _p4[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var allIntersections = (_allIntersections = {}, rectangle_defineProperty(_allIntersections, DIRECTION.RIGHT, [x2 + w, y2]), rectangle_defineProperty(_allIntersections, DIRECTION.LEFT, [x2 - w, y2]), rectangle_defineProperty(_allIntersections, DIRECTION.BOTTOM, [x2, y2 + h]), rectangle_defineProperty(_allIntersections, DIRECTION.TOP, [x2, y2 - h]), _allIntersections);\n      var vecx = x2 - x1;\n      var vecy = y2 - y1;\n      var theta1 = h / w;\n      var theta2 = Math.abs(vecy / vecx);\n      var dirx = x1 > x2;\n      var diry = y1 > y2;\n      var interDir = theta2 > theta1 ? diry ? DIRECTION.BOTTOM : DIRECTION.TOP : dirx ? DIRECTION.RIGHT : DIRECTION.LEFT;\n\n      // if(this._belongs && this._belongs.calculateToCoordination) {\n      //     console.log(JSON.stringify(this._intersections));\n      //     console.log(interDir)\n      // }\n      // interDir = this.checkLinked(interDir, end);\n      // if(this._belongs && this._belongs.calculateToCoordination) {\n      //     console.log(interDir)\n      // }\n\n      // if(!interDir) {\n      //     debugger\n      // }\n      // let endDir = interDir;\n      // if(end === \'to\') {\n      //     endDir = oppositeDirection(endDir)\n      // }\n      return {\n        p: allIntersections[interDir],\n        dir: interDir\n      };\n    }\n  }]);\n  return Rectangle;\n}(node);\n/* harmony default export */ const rectangle = (Rectangle);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/capsule.js\nfunction capsule_typeof(obj) { "@babel/helpers - typeof"; return capsule_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, capsule_typeof(obj); }\nfunction capsule_defineProperty(obj, key, value) { key = capsule_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction capsule_slicedToArray(arr, i) { return capsule_arrayWithHoles(arr) || capsule_iterableToArrayLimit(arr, i) || capsule_unsupportedIterableToArray(arr, i) || capsule_nonIterableRest(); }\nfunction capsule_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction capsule_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return capsule_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return capsule_arrayLikeToArray(o, minLen); }\nfunction capsule_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction capsule_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction capsule_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction capsule_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction capsule_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, capsule_toPropertyKey(descriptor.key), descriptor); } }\nfunction capsule_createClass(Constructor, protoProps, staticProps) { if (protoProps) capsule_defineProperties(Constructor.prototype, protoProps); if (staticProps) capsule_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction capsule_toPropertyKey(arg) { var key = capsule_toPrimitive(arg, "string"); return capsule_typeof(key) === "symbol" ? key : String(key); }\nfunction capsule_toPrimitive(input, hint) { if (capsule_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (capsule_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction capsule_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) capsule_setPrototypeOf(subClass, superClass); }\nfunction capsule_setPrototypeOf(o, p) { capsule_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return capsule_setPrototypeOf(o, p); }\nfunction capsule_createSuper(Derived) { var hasNativeReflectConstruct = capsule_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = capsule_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = capsule_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return capsule_possibleConstructorReturn(this, result); }; }\nfunction capsule_possibleConstructorReturn(self, call) { if (call && (capsule_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return capsule_assertThisInitialized(self); }\nfunction capsule_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction capsule_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction capsule_getPrototypeOf(o) { capsule_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return capsule_getPrototypeOf(o); }\n\n\n/**\n * 胶囊单元 配置\n * @typedef {Node~Configs} Capsule~CapsuleConfigs\n * @property {number} width  - 内部矩形宽\n * @property {number} height - 内部矩形高\n */\n/**\n * 胶囊单元\n * @constructor Capsule\n * @extends Node\n * @param {Capsule~CapsuleConfigs} configs - 配置\n */\nvar Capsule = /*#__PURE__*/function (_Node) {\n  capsule_inherits(Capsule, _Node);\n  var _super = capsule_createSuper(Capsule);\n  function Capsule() {\n    var _this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    capsule_classCallCheck(this, Capsule);\n    _this = _super.call(this, configs);\n    _this.type = \'Capsule\';\n    /** @member {Number}      - 内部矩形宽 */\n    _this.width = configs.width || 20;\n    /** @member {Number}      - 内部矩形高 */\n    _this.height = configs.height || 10;\n    return _this;\n  }\n  capsule_createClass(Capsule, [{\n    key: "render",\n    value: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      ctx.beginPath();\n      var _this$anchor = capsule_slicedToArray(this.anchor, 2),\n        x = _this$anchor[0],\n        y = _this$anchor[1];\n      var hw = this.width / 2;\n      var hh = this.height / 2;\n      var leftCenter = x - hw + hh;\n      var rightCenter = x + hw - hh;\n      var top = y - hh;\n      var bottom = y + hh;\n      ctx.moveTo(leftCenter, top);\n      ctx.lineTo(rightCenter, top);\n      ctx.arc(rightCenter, y, hh, -Math.PI / 2, Math.PI / 2);\n      ctx.lineTo(leftCenter, bottom);\n      ctx.arc(leftCenter, y, hh, Math.PI / 2, Math.PI / 2 * 3);\n      ctx.fillStyle = this.backgroundColor;\n      if (this.shadowColor) {\n        ctx.shadowColor = this.shadowColor;\n        ctx.shadowBlur = this.shadowBlur;\n        ctx.shadowOffsetX = this.shadowOffsetX;\n        ctx.shadowOffsetY = this.shadowOffsetY;\n      }\n      ctx.fill();\n      if (this.borderWidth) {\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeStyle = this.borderColor;\n        ctx.stroke();\n      }\n      // ctx.fillStyle = \'rgba(0,0,0,0.3)\';\n      // ctx.fillRect(x-hw, y-hh, this.width, this.height)\n\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      var anchor = this.anchor;\n      var hw = this.width / 2;\n      var hh = this.height / 2;\n      var ww = Math.abs(hw - hh);\n      var leftCenter = anchor[0] - hw + hh;\n      var rightCenter = anchor[0] + hw - hh;\n      var rr = hh * hh;\n      return point[0] > anchor[0] - ww && point[0] < anchor[0] + ww && point[1] > anchor[1] - hh && point[1] < anchor[1] + hh || Math.pow(point[0] - leftCenter, 2) + Math.pow(point[1] - anchor[1], 2) < rr || Math.pow(point[0] - rightCenter, 2) + Math.pow(point[1] - anchor[1], 2) < rr;\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var ltx = anchor[0] - w;\n      var lty = anchor[1] - h;\n      var rbx = anchor[0] + w;\n      var rby = anchor[1] + h;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        height: this.height,\n        width: this.width\n      };\n    }\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      var _ref;\n      var p2 = this.anchor;\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        p2 = this._belongs.calculateToCoordination(p2);\n      }\n      var _p = p2,\n        _p2 = capsule_slicedToArray(_p, 2),\n        x2 = _p2[0],\n        y2 = _p2[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      return _ref = {}, capsule_defineProperty(_ref, DIRECTION.RIGHT, [x2 + w, y2]), capsule_defineProperty(_ref, DIRECTION.LEFT, [x2 - w, y2]), capsule_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + h]), capsule_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - h]), _ref;\n    }\n  }]);\n  return Capsule;\n}(node);\n/* harmony default export */ const capsule = (Capsule);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/capsule-vertical.js\nfunction capsule_vertical_typeof(obj) { "@babel/helpers - typeof"; return capsule_vertical_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, capsule_vertical_typeof(obj); }\nfunction capsule_vertical_slicedToArray(arr, i) { return capsule_vertical_arrayWithHoles(arr) || capsule_vertical_iterableToArrayLimit(arr, i) || capsule_vertical_unsupportedIterableToArray(arr, i) || capsule_vertical_nonIterableRest(); }\nfunction capsule_vertical_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction capsule_vertical_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return capsule_vertical_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return capsule_vertical_arrayLikeToArray(o, minLen); }\nfunction capsule_vertical_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction capsule_vertical_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction capsule_vertical_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction capsule_vertical_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction capsule_vertical_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, capsule_vertical_toPropertyKey(descriptor.key), descriptor); } }\nfunction capsule_vertical_createClass(Constructor, protoProps, staticProps) { if (protoProps) capsule_vertical_defineProperties(Constructor.prototype, protoProps); if (staticProps) capsule_vertical_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction capsule_vertical_toPropertyKey(arg) { var key = capsule_vertical_toPrimitive(arg, "string"); return capsule_vertical_typeof(key) === "symbol" ? key : String(key); }\nfunction capsule_vertical_toPrimitive(input, hint) { if (capsule_vertical_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (capsule_vertical_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction capsule_vertical_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) capsule_vertical_setPrototypeOf(subClass, superClass); }\nfunction capsule_vertical_setPrototypeOf(o, p) { capsule_vertical_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return capsule_vertical_setPrototypeOf(o, p); }\nfunction capsule_vertical_createSuper(Derived) { var hasNativeReflectConstruct = capsule_vertical_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = capsule_vertical_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = capsule_vertical_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return capsule_vertical_possibleConstructorReturn(this, result); }; }\nfunction capsule_vertical_possibleConstructorReturn(self, call) { if (call && (capsule_vertical_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return capsule_vertical_assertThisInitialized(self); }\nfunction capsule_vertical_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction capsule_vertical_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction capsule_vertical_getPrototypeOf(o) { capsule_vertical_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return capsule_vertical_getPrototypeOf(o); }\n\n/**\n * 垂直胶囊单元\n * @constructor CapsuleVertical\n * @extends Capsule\n * @param {Capsule~CapsuleConfigs} configs - 配置\n */\nvar CapsuleVertical = /*#__PURE__*/function (_Capsule) {\n  capsule_vertical_inherits(CapsuleVertical, _Capsule);\n  var _super = capsule_vertical_createSuper(CapsuleVertical);\n  function CapsuleVertical() {\n    capsule_vertical_classCallCheck(this, CapsuleVertical);\n    return _super.apply(this, arguments);\n  }\n  capsule_vertical_createClass(CapsuleVertical, [{\n    key: "render",\n    value: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      ctx.beginPath();\n      var _this$anchor = capsule_vertical_slicedToArray(this.anchor, 2),\n        x = _this$anchor[0],\n        y = _this$anchor[1];\n      var hw = this.width / 2;\n      var hh = this.height / 2;\n      var topCenter = y - hh + hw;\n      var bottomCenter = y + hh - hw;\n      var left = x - hw;\n      var right = x + hw;\n      ctx.moveTo(left, topCenter);\n      ctx.arc(x, topCenter, hw, -Math.PI, 0);\n      ctx.lineTo(right, bottomCenter);\n      ctx.arc(x, bottomCenter, hw, 0, Math.PI);\n      ctx.closePath();\n      ctx.fillStyle = this.backgroundColor;\n      if (this.shadowColor) {\n        ctx.shadowColor = this.shadowColor;\n        ctx.shadowBlur = this.shadowBlur;\n        ctx.shadowOffsetX = this.shadowOffsetX;\n        ctx.shadowOffsetY = this.shadowOffsetY;\n      }\n      ctx.fill();\n      if (this.borderWidth) {\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeStyle = this.borderColor;\n        ctx.stroke();\n      }\n      // ctx.fillStyle = \'rgba(0,0,0,0.3)\';\n      // ctx.fillRect(x-hw, y-hh, this.width, this.height)\n\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point, condition) {\n      var _this$anchor2 = capsule_vertical_slicedToArray(this.anchor, 2),\n        x = _this$anchor2[0],\n        y = _this$anchor2[1];\n      var hw = this.width / 2;\n      var hh = this.height / 2;\n      var yy = Math.abs(hh - hw);\n      var topCenter = y - hh + hw;\n      var bottomCenter = y + hh - hw;\n      var rr = hw * hw;\n      return point[0] > x - hw && point[0] < x + hw && point[1] > y - yy && point[1] < y + yy || Math.pow(point[0] - x, 2) + Math.pow(point[1] - topCenter, 2) < rr || Math.pow(point[0] - x, 2) + Math.pow(point[1] - bottomCenter, 2) < rr;\n    }\n  }]);\n  return CapsuleVertical;\n}(capsule);\n/* harmony default export */ const capsule_vertical = (CapsuleVertical);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/rhombus.js\nfunction rhombus_typeof(obj) { "@babel/helpers - typeof"; return rhombus_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, rhombus_typeof(obj); }\nfunction rhombus_defineProperty(obj, key, value) { key = rhombus_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction rhombus_slicedToArray(arr, i) { return rhombus_arrayWithHoles(arr) || rhombus_iterableToArrayLimit(arr, i) || rhombus_unsupportedIterableToArray(arr, i) || rhombus_nonIterableRest(); }\nfunction rhombus_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction rhombus_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return rhombus_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return rhombus_arrayLikeToArray(o, minLen); }\nfunction rhombus_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction rhombus_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction rhombus_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction rhombus_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction rhombus_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, rhombus_toPropertyKey(descriptor.key), descriptor); } }\nfunction rhombus_createClass(Constructor, protoProps, staticProps) { if (protoProps) rhombus_defineProperties(Constructor.prototype, protoProps); if (staticProps) rhombus_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction rhombus_toPropertyKey(arg) { var key = rhombus_toPrimitive(arg, "string"); return rhombus_typeof(key) === "symbol" ? key : String(key); }\nfunction rhombus_toPrimitive(input, hint) { if (rhombus_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (rhombus_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction rhombus_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) rhombus_setPrototypeOf(subClass, superClass); }\nfunction rhombus_setPrototypeOf(o, p) { rhombus_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rhombus_setPrototypeOf(o, p); }\nfunction rhombus_createSuper(Derived) { var hasNativeReflectConstruct = rhombus_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rhombus_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rhombus_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rhombus_possibleConstructorReturn(this, result); }; }\nfunction rhombus_possibleConstructorReturn(self, call) { if (call && (rhombus_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return rhombus_assertThisInitialized(self); }\nfunction rhombus_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction rhombus_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction rhombus_getPrototypeOf(o) { rhombus_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rhombus_getPrototypeOf(o); }\n\n\n/**\n * 菱形单元 配置\n * @typedef {Node~Configs} Rhombus~RhombusConfigs\n * @property {number} diagonalsV  - 内十字高度\n * @property {number} diagonalsH  - 内十字宽度\n */\n/**\n * 菱形单元\n * @constructor Rhombus\n * @param {Rhombus~RhombusConfigs} configs - 配置\n * @extends Node\n */\nvar Rhombus = /*#__PURE__*/function (_Node) {\n  rhombus_inherits(Rhombus, _Node);\n  var _super = rhombus_createSuper(Rhombus);\n  function Rhombus() {\n    var _this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    rhombus_classCallCheck(this, Rhombus);\n    _this = _super.call(this, configs);\n    _this.type = \'Rhombus\';\n    /** @member {Number}      - 内十字高度 */\n    _this.height = configs.diagonalsV || 10;\n    /** @member {Number}      - 内十字宽度 */\n    _this.width = configs.diagonalsH || 20;\n    return _this;\n  }\n  rhombus_createClass(Rhombus, [{\n    key: "render",\n    value: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var center = this.anchor;\n      ctx.translate(center[0], center[1]);\n      ctx.beginPath();\n      ctx.moveTo(0, -h);\n      ctx.lineTo(w, 0);\n      ctx.lineTo(0, h);\n      ctx.lineTo(-w, 0);\n      ctx.closePath();\n      if (this.borderWidth) {\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeStyle = this.borderColor;\n      }\n      if (this.shadowColor) {\n        ctx.shadowColor = this.shadowColor;\n        var scale = this._jflow.scale;\n        ctx.shadowBlur = this.shadowBlur * scale;\n        ctx.shadowOffsetX = this.shadowOffsetX * scale;\n        ctx.shadowOffsetY = this.shadowOffsetY * scale;\n        var switchPath = new Path2D();\n        switchPath.moveTo(0, -h);\n        switchPath.lineTo(w, 0);\n        switchPath.lineTo(0, h);\n        switchPath.lineTo(-w, 0);\n        switchPath.closePath();\n        switchPath.rect(-w - 10, -h - 10, this.width + 20, this.height + 20);\n        // switchPath.moveTo(x, y-h);\n        // switchPath.lineTo(x + w, y);\n        // switchPath.lineTo(x, y + h);\n        // switchPath.lineTo(x-w, y);\n        // switchPath.closePath();\n        // switchPath.rect(x - w - 10, y - h - 10, this.width+ 20, this.height+ 20);\n        ctx.save();\n        ctx.clip(switchPath, "evenodd");\n        ctx.stroke();\n        ctx.restore();\n      }\n      ctx.fillStyle = this.backgroundColor;\n      ctx.fill();\n      if (this.borderWidth) {\n        ctx.shadowColor = \'transparent\';\n        ctx.stroke();\n      }\n      ctx.translate(-center[0], -center[1]);\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      var v = this.height / 2;\n      var h = this.width / 2;\n      var anchor = this.anchor;\n      var x = Math.abs(point[0] - anchor[0]);\n      var y = Math.abs(point[1] - anchor[1]);\n      return x / h + y / v <= 1;\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var ltx = anchor[0] - w;\n      var lty = anchor[1] - h;\n      var rbx = anchor[0] + w;\n      var rby = anchor[1] + h;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        height: this.height,\n        width: this.width\n      };\n    }\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      var _ref;\n      var p2 = this.anchor;\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        p2 = this._belongs.calculateToCoordination(p2);\n      }\n      var _p = p2,\n        _p2 = rhombus_slicedToArray(_p, 2),\n        x2 = _p2[0],\n        y2 = _p2[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      return _ref = {}, rhombus_defineProperty(_ref, DIRECTION.RIGHT, [x2 + w, y2]), rhombus_defineProperty(_ref, DIRECTION.LEFT, [x2 - w, y2]), rhombus_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + h]), rhombus_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - h]), rhombus_defineProperty(_ref, DIRECTION.SELF, [x2 + w * 0.618, y2 + h * 0.618]), _ref;\n    }\n  }]);\n  return Rhombus;\n}(node);\n/* harmony default export */ const rhombus = (Rhombus);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/diamond.js\nfunction diamond_typeof(obj) { "@babel/helpers - typeof"; return diamond_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, diamond_typeof(obj); }\nfunction diamond_defineProperty(obj, key, value) { key = diamond_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction diamond_slicedToArray(arr, i) { return diamond_arrayWithHoles(arr) || diamond_iterableToArrayLimit(arr, i) || diamond_unsupportedIterableToArray(arr, i) || diamond_nonIterableRest(); }\nfunction diamond_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction diamond_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return diamond_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return diamond_arrayLikeToArray(o, minLen); }\nfunction diamond_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction diamond_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction diamond_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction diamond_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction diamond_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, diamond_toPropertyKey(descriptor.key), descriptor); } }\nfunction diamond_createClass(Constructor, protoProps, staticProps) { if (protoProps) diamond_defineProperties(Constructor.prototype, protoProps); if (staticProps) diamond_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction diamond_toPropertyKey(arg) { var key = diamond_toPrimitive(arg, "string"); return diamond_typeof(key) === "symbol" ? key : String(key); }\nfunction diamond_toPrimitive(input, hint) { if (diamond_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (diamond_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction diamond_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) diamond_setPrototypeOf(subClass, superClass); }\nfunction diamond_setPrototypeOf(o, p) { diamond_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return diamond_setPrototypeOf(o, p); }\nfunction diamond_createSuper(Derived) { var hasNativeReflectConstruct = diamond_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = diamond_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = diamond_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return diamond_possibleConstructorReturn(this, result); }; }\nfunction diamond_possibleConstructorReturn(self, call) { if (call && (diamond_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return diamond_assertThisInitialized(self); }\nfunction diamond_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction diamond_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction diamond_getPrototypeOf(o) { diamond_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return diamond_getPrototypeOf(o); }\n\n\n// import { makeBezierPoints } from \'../../utils/functions\';\n/**\n * 钻石形单元 配置\n * @typedef {Node~Configs} Diamond~DiamondConfigs\n * @property {number} width  - 内部矩形宽\n * @property {number} height - 内部矩形高\n * @property {number} side   - 两侧三角形的宽\n */\n/**\n * 钻石形单元\n * @constructor Diamond\n * @param {Diamond~DiamondConfigs} configs - 配置\n * @extends Node\n */\nvar Diamond = /*#__PURE__*/function (_Node) {\n  diamond_inherits(Diamond, _Node);\n  var _super = diamond_createSuper(Diamond);\n  function Diamond() {\n    var _this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    diamond_classCallCheck(this, Diamond);\n    _this = _super.call(this, configs);\n    _this.type = \'Diamond\';\n    /** @member {Number}      - 内部矩形宽 */\n    _this.width = configs.width || 20;\n    /** @member {Number}      - 内部矩形高 */\n    _this.height = configs.height || 10;\n    /** @member {Number}      - 两侧三角形的宽 */\n    _this.side = configs.side || 6;\n    _this._doCache();\n    return _this;\n  }\n  diamond_createClass(Diamond, [{\n    key: "setConfig",\n    value: function setConfig(configs) {\n      var _this2 = this;\n      Object.keys(configs).forEach(function (k) {\n        if (configs[k] !== undefined && configs[k] !== null) {\n          _this2[k] = configs[k];\n          _this2._rawConfigs[k] = configs[k];\n        }\n      });\n      this._doCache();\n    }\n  }, {\n    key: "_doCache",\n    value: function _doCache() {\n      this.sinSIDE = Math.sin(Math.PI / 3) * this.side;\n      this.cosSIDE = Math.cos(Math.PI / 3) * this.side;\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      var _this$anchor = diamond_slicedToArray(this.anchor, 2),\n        x = _this$anchor[0],\n        y = _this$anchor[1];\n      var hw = this.width / 2;\n      var hh = this.height / 2;\n      var xx = hh / 1.732;\n      var leftCenter = x - hw + xx;\n      var rightCenter = x + hw - xx;\n      var right = x + hw;\n      var left = x - hw;\n      var top = y - hh;\n      var bottom = y + hh;\n      this._cachePoints = [[rightCenter, top], [right, y], [rightCenter, bottom], [leftCenter, bottom], [left, y], [leftCenter, top]];\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      ctx.beginPath();\n      var side = this.side,\n        sinSIDE = this.sinSIDE,\n        cosSIDE = this.cosSIDE;\n      ctx.moveTo(x, top);\n      ctx.lineTo(rightCenter - side, top);\n      ctx.quadraticCurveTo(rightCenter, top, rightCenter + cosSIDE, top + sinSIDE);\n      ctx.lineTo(right - cosSIDE, y - sinSIDE);\n      ctx.quadraticCurveTo(right, y, right - cosSIDE, y + sinSIDE);\n      ctx.lineTo(rightCenter + cosSIDE, bottom - sinSIDE);\n      ctx.quadraticCurveTo(rightCenter, bottom, rightCenter - side, bottom);\n      ctx.lineTo(leftCenter + side, bottom);\n      ctx.quadraticCurveTo(leftCenter, bottom, leftCenter - cosSIDE, bottom - sinSIDE);\n      ctx.lineTo(left + cosSIDE, y + sinSIDE);\n      ctx.quadraticCurveTo(left, y, left + cosSIDE, y - sinSIDE);\n      ctx.lineTo(leftCenter - cosSIDE, top + sinSIDE);\n      ctx.quadraticCurveTo(leftCenter, top, leftCenter + side, top);\n      ctx.closePath();\n      ctx.fillStyle = this.backgroundColor;\n      if (this.shadowColor) {\n        ctx.shadowColor = this.shadowColor;\n        ctx.shadowBlur = this.shadowBlur;\n        ctx.shadowOffsetX = this.shadowOffsetX;\n        ctx.shadowOffsetY = this.shadowOffsetY;\n      }\n      ctx.fill();\n      if (this.borderWidth) {\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeStyle = this.borderColor;\n        ctx.stroke();\n      }\n\n      // if(this._isTargeting) {\n      //     this.renderFocus(ctx);\n      // }\n      // ctx.fillStyle = \'rgba(0,0,0,0.3)\';\n      // ctx.fillRect(x-hw, y-hh, this.width, this.height)\n\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      if (!this._cachePoints) return false;\n      var polygon = this._cachePoints;\n      var odd = false;\n      // For each edge (In this case for each point of the polygon and the previous one)\n      for (var i = 0, j = polygon.length - 1; i < polygon.length; i++) {\n        // If a line from the point into infinity crosses this edge\n        if (polygon[i][1] > point[1] !== polygon[j][1] > point[1] // One point needs to be above, one below our y coordinate\n        // ...and the edge doesn\'t cross our Y corrdinate before our x coordinate (but between our x coordinate and infinity)\n        && point[0] < (polygon[j][0] - polygon[i][0]) * (point[1] - polygon[i][1]) / (polygon[j][1] - polygon[i][1]) + polygon[i][0]) {\n          // Invert odd\n          odd = !odd;\n        }\n        j = i;\n      }\n      return odd;\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var ltx = anchor[0] - w;\n      var lty = anchor[1] - h;\n      var rbx = anchor[0] + w;\n      var rby = anchor[1] + h;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        height: this.height,\n        width: this.width\n      };\n    }\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      var _ref;\n      var p2 = this.anchor;\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        p2 = this._belongs.calculateToCoordination(p2);\n      }\n      var _p = p2,\n        _p2 = diamond_slicedToArray(_p, 2),\n        x2 = _p2[0],\n        y2 = _p2[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      return _ref = {}, diamond_defineProperty(_ref, DIRECTION.RIGHT, [x2 + w, y2]), diamond_defineProperty(_ref, DIRECTION.LEFT, [x2 - w, y2]), diamond_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + h]), diamond_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - h]), _ref;\n    }\n  }]);\n  return Diamond;\n}(node);\n/* harmony default export */ const diamond = (Diamond);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/diamond-vertical.js\nfunction diamond_vertical_typeof(obj) { "@babel/helpers - typeof"; return diamond_vertical_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, diamond_vertical_typeof(obj); }\nfunction diamond_vertical_slicedToArray(arr, i) { return diamond_vertical_arrayWithHoles(arr) || diamond_vertical_iterableToArrayLimit(arr, i) || diamond_vertical_unsupportedIterableToArray(arr, i) || diamond_vertical_nonIterableRest(); }\nfunction diamond_vertical_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction diamond_vertical_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return diamond_vertical_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return diamond_vertical_arrayLikeToArray(o, minLen); }\nfunction diamond_vertical_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction diamond_vertical_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction diamond_vertical_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction diamond_vertical_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction diamond_vertical_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, diamond_vertical_toPropertyKey(descriptor.key), descriptor); } }\nfunction diamond_vertical_createClass(Constructor, protoProps, staticProps) { if (protoProps) diamond_vertical_defineProperties(Constructor.prototype, protoProps); if (staticProps) diamond_vertical_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction diamond_vertical_toPropertyKey(arg) { var key = diamond_vertical_toPrimitive(arg, "string"); return diamond_vertical_typeof(key) === "symbol" ? key : String(key); }\nfunction diamond_vertical_toPrimitive(input, hint) { if (diamond_vertical_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (diamond_vertical_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction diamond_vertical_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) diamond_vertical_setPrototypeOf(subClass, superClass); }\nfunction diamond_vertical_setPrototypeOf(o, p) { diamond_vertical_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return diamond_vertical_setPrototypeOf(o, p); }\nfunction diamond_vertical_createSuper(Derived) { var hasNativeReflectConstruct = diamond_vertical_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = diamond_vertical_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = diamond_vertical_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return diamond_vertical_possibleConstructorReturn(this, result); }; }\nfunction diamond_vertical_possibleConstructorReturn(self, call) { if (call && (diamond_vertical_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return diamond_vertical_assertThisInitialized(self); }\nfunction diamond_vertical_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction diamond_vertical_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction diamond_vertical_getPrototypeOf(o) { diamond_vertical_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return diamond_vertical_getPrototypeOf(o); }\n\nvar backsqrt3 = 1 / Math.sqrt(3);\n\n/**\n * 垂直钻石形单元\n * @constructor DiamondVertical\n * @param {Diamond~DiamondConfigs} configs - 配置\n * @extends Diamond\n */\nvar DiamondVertical = /*#__PURE__*/function (_Diamond) {\n  diamond_vertical_inherits(DiamondVertical, _Diamond);\n  var _super = diamond_vertical_createSuper(DiamondVertical);\n  function DiamondVertical(configs) {\n    diamond_vertical_classCallCheck(this, DiamondVertical);\n    return _super.call(this, configs);\n  }\n  diamond_vertical_createClass(DiamondVertical, [{\n    key: "render",\n    value: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      ctx.beginPath();\n      var _this$anchor = diamond_vertical_slicedToArray(this.anchor, 2),\n        x = _this$anchor[0],\n        y = _this$anchor[1];\n      var hw = this.width / 2;\n      var hh = this.height / 2;\n      var yy = hw / 1.732;\n      var top = y - hh;\n      var bottom = y + hh;\n      var topmiddle = y - hh + yy;\n      var bottommiddle = y + hh - yy;\n      var xleft = x - hw;\n      var xright = x + hw;\n      ctx.moveTo(x, top);\n      ctx.lineTo(xright, topmiddle);\n      ctx.lineTo(xright, bottommiddle);\n      ctx.lineTo(x, bottom);\n      ctx.lineTo(xleft, bottommiddle);\n      ctx.lineTo(xleft, topmiddle);\n      ctx.closePath();\n      ctx.fillStyle = this.backgroundColor;\n      if (this.shadowColor) {\n        ctx.shadowColor = this.shadowColor;\n        ctx.shadowBlur = this.shadowBlur;\n        ctx.shadowOffsetX = this.shadowOffsetX;\n        ctx.shadowOffsetY = this.shadowOffsetY;\n      }\n      ctx.fill();\n      if (this.borderWidth) {\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeStyle = this.borderColor;\n        ctx.stroke();\n      }\n      ctx.restore();\n      this._cachePoints = [[x, top], [xright, topmiddle], [xright, bottommiddle], [x, bottom], [xleft, bottommiddle], [xleft, topmiddle]];\n    }\n  }]);\n  return DiamondVertical;\n}(diamond);\n/* harmony default export */ const diamond_vertical = (DiamondVertical);\n;// CONCATENATED MODULE: ./src/core/instance/groups/scroll-group.js\nfunction scroll_group_typeof(obj) { "@babel/helpers - typeof"; return scroll_group_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, scroll_group_typeof(obj); }\nfunction scroll_group_defineProperty(obj, key, value) { key = scroll_group_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction scroll_group_slicedToArray(arr, i) { return scroll_group_arrayWithHoles(arr) || scroll_group_iterableToArrayLimit(arr, i) || scroll_group_unsupportedIterableToArray(arr, i) || scroll_group_nonIterableRest(); }\nfunction scroll_group_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction scroll_group_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return scroll_group_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return scroll_group_arrayLikeToArray(o, minLen); }\nfunction scroll_group_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction scroll_group_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction scroll_group_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction scroll_group_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction scroll_group_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, scroll_group_toPropertyKey(descriptor.key), descriptor); } }\nfunction scroll_group_createClass(Constructor, protoProps, staticProps) { if (protoProps) scroll_group_defineProperties(Constructor.prototype, protoProps); if (staticProps) scroll_group_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction scroll_group_toPropertyKey(arg) { var key = scroll_group_toPrimitive(arg, "string"); return scroll_group_typeof(key) === "symbol" ? key : String(key); }\nfunction scroll_group_toPrimitive(input, hint) { if (scroll_group_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (scroll_group_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction scroll_group_get() { if (typeof Reflect !== "undefined" && Reflect.get) { scroll_group_get = Reflect.get.bind(); } else { scroll_group_get = function _get(target, property, receiver) { var base = scroll_group_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return scroll_group_get.apply(this, arguments); }\nfunction scroll_group_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = scroll_group_getPrototypeOf(object); if (object === null) break; } return object; }\nfunction scroll_group_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) scroll_group_setPrototypeOf(subClass, superClass); }\nfunction scroll_group_setPrototypeOf(o, p) { scroll_group_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return scroll_group_setPrototypeOf(o, p); }\nfunction scroll_group_createSuper(Derived) { var hasNativeReflectConstruct = scroll_group_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = scroll_group_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = scroll_group_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return scroll_group_possibleConstructorReturn(this, result); }; }\nfunction scroll_group_possibleConstructorReturn(self, call) { if (call && (scroll_group_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return scroll_group_assertThisInitialized(self); }\nfunction scroll_group_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction scroll_group_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction scroll_group_getPrototypeOf(o) { scroll_group_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return scroll_group_getPrototypeOf(o); }\n\n\n\n\n\n\n\nvar scroll_group_ishitKey = Symbol(\'ishit\');\nvar InnerScrollBar = /*#__PURE__*/function (_ScrollBar) {\n  scroll_group_inherits(InnerScrollBar, _ScrollBar);\n  var _super = scroll_group_createSuper(InnerScrollBar);\n  function InnerScrollBar(dir) {\n    var _this;\n    var configs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    scroll_group_classCallCheck(this, InnerScrollBar);\n    _this = _super.call(this, dir, configs);\n    _this.visible = false;\n    return _this;\n  }\n  scroll_group_createClass(InnerScrollBar, [{\n    key: "render",\n    value: function render(ctx) {\n      if (this.visible) {\n        scroll_group_get(scroll_group_getPrototypeOf(InnerScrollBar.prototype), "render", this).call(this, ctx);\n      }\n    }\n  }, {\n    key: "setHit",\n    value: function setHit(ishit) {\n      if (this[scroll_group_ishitKey] !== ishit) {\n        this.isFocus = ishit;\n        this.onHit();\n      }\n      this[scroll_group_ishitKey] = ishit;\n    }\n  }]);\n  return InnerScrollBar;\n}(ScrollBar);\nvar ScrollGroup = /*#__PURE__*/function (_Node) {\n  scroll_group_inherits(ScrollGroup, _Node);\n  var _super2 = scroll_group_createSuper(ScrollGroup);\n  function ScrollGroup(configs) {\n    var _configs$lock;\n    var _this2;\n    scroll_group_classCallCheck(this, ScrollGroup);\n    _this2 = _super2.call(this, configs);\n    _this2.type = \'ScrollGroup\';\n    _this2.initStack(configs);\n    _this2.initLayout(configs);\n    _this2.initScrollBar(configs);\n    _this2._shape = new rectangle(configs);\n    _this2._shape.anchor = [0, 0];\n    _this2._shape._belongs = scroll_group_assertThisInitialized(_this2);\n    _this2.maxWidth = configs.maxWidth || Infinity;\n    _this2.definedWidth = configs.definedWidth;\n    _this2.maxHeight = configs.maxHeight || Infinity;\n    _this2.definedHeight = configs.definedHeight;\n    _this2.lock = (_configs$lock = configs.lock) !== null && _configs$lock !== void 0 ? _configs$lock : true;\n    _this2._offset = [0, 0];\n    _this2._getBoundingGroupRect();\n    _this2.reflow();\n    _this2._getBoundingGroupRect();\n    _this2._resetOffset();\n    _this2._cacheViewBox = [];\n    return _this2;\n  }\n  scroll_group_createClass(ScrollGroup, [{\n    key: "initScrollBar",\n    value: function initScrollBar(configs) {\n      var _this3 = this;\n      var barColor = configs.barColor,\n        barFocusColor = configs.barFocusColor,\n        barMarginX = configs.barMarginX,\n        barMarginY = configs.barMarginY,\n        barWidth = configs.barWidth;\n      this._scrollbarX = new InnerScrollBar(\'x\', {\n        plainColor: barColor,\n        focusColor: barFocusColor,\n        barWidth: barWidth\n      });\n      this._scrollbarY = new InnerScrollBar(\'y\', {\n        plainColor: barColor,\n        focusColor: barFocusColor,\n        barWidth: barWidth\n      });\n      this._scrollbarX.barMarginX = barMarginX || 1;\n      this._scrollbarY.barMarginY = barMarginY || 1;\n      var _f = function _f() {\n        _this3._jflow.scheduleRender();\n      };\n      this._scrollbarX.onHit = _f;\n      this._scrollbarY.onHit = _f;\n      this._scrollBarStatus = {\n        dragging: false,\n        target: null,\n        barInitX: 0,\n        barInitY: 0,\n        barStartX: 0,\n        barStartY: 0,\n        hitScrollX: false,\n        hitScrollY: false\n      };\n      // // const jflowInstance = this._jflow;\n      // this.addEventListener(\'instancemousemove\', e => {\n      //     if(this._scrollBarStatus.hitScrollX) {\n      //         if(!this._scrollbarX.isFocus) {\n      //             this._scrollbarX.isFocus = true;\n      //             e.detail.jflow.scheduleRender();\n      //         }\n      //         return;\n      //     }\n      //     if(this._scrollbarX.isFocus) {\n      //         this._scrollbarX.isFocus = false;\n      //         e.detail.jflow.scheduleRender();\n      //     }\n\n      // })\n      this.addEventListener(\'instancePressStart\', function (e) {\n        if (_this3._scrollBarStatus.hitScrollX) {\n          e.detail.preventDefault();\n          e.detail.bubbles = false;\n          var clientX = e.detail.event.clientX;\n          Object.assign(_this3._scrollBarStatus, {\n            dragging: true,\n            target: _this3._scrollbarX,\n            barStartX: _this3._scrollbarX.anchor[0],\n            barInitX: clientX\n          });\n          _this3.onScrollbarPressStart();\n        }\n        if (_this3._scrollBarStatus.hitScrollY) {\n          e.detail.preventDefault();\n          e.detail.bubbles = false;\n          var clientY = e.detail.event.clientY;\n          Object.assign(_this3._scrollBarStatus, {\n            dragging: true,\n            target: _this3._scrollbarY,\n            barStartY: _this3._scrollbarY.anchor[1],\n            barInitY: clientY\n          });\n          _this3.onScrollbarPressStart();\n        }\n      });\n    }\n  }, {\n    key: "onScrollbarPressStart",\n    value: function onScrollbarPressStart() {\n      var _this4 = this;\n      var jflowInstance = this._jflow;\n      var canvas = jflowInstance.canvas;\n      var f = function (e) {\n        var clientX = e.clientX,\n          clientY = e.clientY;\n        _this4.onDraggingScrollbar(clientX, clientY);\n      }.bind(this);\n      document.addEventListener(\'pointermove\', f);\n      var t = function (e) {\n        Object.assign(_this4._scrollBarStatus, {\n          dragging: false,\n          target: null,\n          barInitX: 0,\n          barInitY: 0,\n          barStartX: 0,\n          barStartY: 0,\n          hitScrollX: false,\n          hitScrollY: false\n        });\n        document.removeEventListener(\'pointermove\', f);\n        document.removeEventListener(\'pointerup\', t);\n        canvas.removeEventListener(\'pointerup\', t);\n      }.bind(this);\n      canvas.addEventListener(\'pointerup\', t, {\n        once: true\n      });\n      document.addEventListener(\'pointerup\', t, {\n        once: true\n      });\n    }\n  }, {\n    key: "onDraggingScrollbar",\n    value: function onDraggingScrollbar(clientX, clientY) {\n      if (this._scrollbarX.visible && this._scrollBarStatus.dragging) {\n        var JFLOW = this._jflow;\n        var scale = JFLOW.scale;\n        var _this$_scrollBarStatu = this._scrollBarStatus,\n          target = _this$_scrollBarStatu.target,\n          barInitX = _this$_scrollBarStatu.barInitX,\n          barStartX = _this$_scrollBarStatu.barStartX,\n          barInitY = _this$_scrollBarStatu.barInitY,\n          barStartY = _this$_scrollBarStatu.barStartY;\n        if (target.dir === \'x\') {\n          var _scrollWidth = this._scrollbarX.width;\n          var _outerWidth = this._outerWidth;\n          var deltaX = clientX - barInitX;\n          var xnew = barStartX + deltaX / scale;\n          var q = target.anchor[0] = Math.max(Math.min(xnew, _outerWidth - _scrollWidth), 0);\n          var ratioInX = q / (_outerWidth - _scrollWidth);\n          var s = (this._innerWidth - _outerWidth) / 2;\n          this._offset[0] = s - (this._innerWidth - _outerWidth) * ratioInX;\n          JFLOW.scheduleRender();\n        }\n        if (target.dir === \'y\') {\n          var _scrollHeight = this._scrollbarY.height;\n          var _outerHeight = this._outerHeight;\n          var deltaY = clientY - barInitY;\n          var ynew = barStartY + deltaY / scale;\n          var _q = target.anchor[1] = Math.max(Math.min(ynew, _outerHeight - _scrollHeight), 0);\n          var ratio = _q / (_outerHeight - _scrollHeight);\n          var _s = (this._innerHeight - _outerHeight) / 2;\n          this._offset[1] = _s - (this._innerHeight - _outerHeight) * ratio;\n          JFLOW.scheduleRender();\n        }\n      }\n    }\n  }, {\n    key: "setConfig",\n    value: function setConfig(configs) {\n      this._shape.setConfig(configs);\n    }\n  }, {\n    key: "_getBoundingGroupRect",\n    value: function _getBoundingGroupRect() {\n      var points = this._stack.getBoundingRectPoints();\n      // content box \n      var bbox = bounding_box(points);\n      var w = bbox.width;\n      var h = bbox.height;\n      var outerWidth = this.definedWidth || Math.min(w, this.maxWidth);\n      var outerHeight = this.definedHeight || Math.min(h, this.maxHeight);\n      this._innerWidth = w;\n      this._outerWidth = outerWidth;\n      this._innerHeight = h;\n      this._outerHeight = outerHeight;\n      this._shape.width = outerWidth;\n      this._shape.height = outerHeight;\n      this.width = outerWidth;\n      this.height = outerHeight;\n    }\n  }, {\n    key: "_calculatePointBack",\n    value: function _calculatePointBack(point) {\n      var _point = scroll_group_slicedToArray(point, 2),\n        gx = _point[0],\n        gy = _point[1];\n      var _this$_offset = scroll_group_slicedToArray(this._offset, 2),\n        tx = _this$_offset[0],\n        ty = _this$_offset[1];\n      var _this$anchor = scroll_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor[0],\n        cy = _this$anchor[1];\n      var p = [gx - cx - tx, gy - cy - ty];\n      return p;\n    }\n  }, {\n    key: "_calculatePointBackWithPoint",\n    value: function _calculatePointBackWithPoint(a, b, arr, idx1, idx2) {\n      var anchor = this.anchor;\n      var offset = this._offset;\n      arr[idx1] = a - anchor[0] - offset[0];\n      arr[idx2] = b - anchor[1] - offset[1];\n    }\n  }, {\n    key: "calculateToCoordination",\n    value: function calculateToCoordination(point) {\n      var _point2 = scroll_group_slicedToArray(point, 2),\n        gx = _point2[0],\n        gy = _point2[1];\n      var _this$anchor2 = scroll_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor2[0],\n        cy = _this$anchor2[1];\n      var _this$_offset2 = scroll_group_slicedToArray(this._offset, 2),\n        tx = _this$_offset2[0],\n        ty = _this$_offset2[1];\n      var p = [gx + cx - tx, gy + cy - ty];\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        return this._belongs.calculateToCoordination(p);\n      } else {\n        return p;\n      }\n    }\n  }, {\n    key: "calculateToRealWorld",\n    value: function calculateToRealWorld(point) {\n      var _point3 = scroll_group_slicedToArray(point, 2),\n        gx = _point3[0],\n        gy = _point3[1];\n      var _this$anchor3 = scroll_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor3[0],\n        cy = _this$anchor3[1];\n      var _this$_offset3 = scroll_group_slicedToArray(this._offset, 2),\n        tx = _this$_offset3[0],\n        ty = _this$_offset3[1];\n      var p = [gx + cx - tx, gy + cy - ty];\n      if (this._belongs && this._belongs.calculateToRealWorld) {\n        return this._belongs.calculateToRealWorld(p);\n      }\n    }\n  }, {\n    key: "calculateToRealWorldWithPointer",\n    value: function calculateToRealWorldWithPointer(outpoint, inpoint) {\n      outpoint[0] = inpoint[0] + this.anchor[0] - this.offset[0];\n      outpoint[1] = inpoint[1] + this.anchor[1] - this.offset[1];\n      if (this._belongs && this._belongs.calculateToRealWorldWithPointer) {\n        return this._belongs.calculateToRealWorldWithPointer(outpoint, outpoint);\n      }\n    }\n  }, {\n    key: "_getViewBox",\n    value: function _getViewBox() {\n      var belongs_vbox = this._belongs.getCacheViewBox();\n      var cacheViewBox = this._cacheViewBox;\n      this._calculatePointBackWithPoint(belongs_vbox[0], belongs_vbox[1], cacheViewBox, 0, 1);\n      this._calculatePointBackWithPoint(belongs_vbox[2], belongs_vbox[3], cacheViewBox, 2, 3);\n      return this._cacheViewBox;\n    }\n  }, {\n    key: "getCacheViewBox",\n    value: function getCacheViewBox() {\n      return this._cacheViewBox;\n    }\n  }, {\n    key: "_resetOffset",\n    value: function _resetOffset() {\n      this._offset = [Math.max((this._innerWidth - this._outerWidth) / 2, 0), Math.max((this._innerHeight - this._outerHeight) / 2, 0)];\n      if (this._innerWidth > this._outerWidth) {\n        this._scrollbarX.visible = true;\n        this._scrollbarX.width = this._outerWidth * this._outerWidth / this._innerWidth;\n        this._scrollbarX.anchor = [0, this._outerHeight - 4];\n      } else {\n        this._scrollbarX.visible = false;\n      }\n      if (this._innerHeight > this._outerHeight) {\n        this._scrollbarY.visible = true;\n        this._scrollbarY.height = this._outerHeight * this._outerHeight / this._innerHeight;\n        this._scrollbarY.anchor = [this._outerWidth - 4, 0];\n      } else {\n        this._scrollbarY.visible = false;\n      }\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      } else if (this.opacity !== 1) {\n        ctx.globalAlpha = this.opacity;\n      }\n      var _this$anchor4 = scroll_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor4[0],\n        cy = _this$anchor4[1];\n      var w = this.width;\n      var h = this.height;\n      var w2 = w / 2;\n      var h2 = h / 2;\n      // if((this.width * this.height) * this._jflow.scale < 144) {\n      //     ctx.restore();\n      //     return;\n      // }\n      var _this$_offset4 = scroll_group_slicedToArray(this._offset, 2),\n        tx = _this$_offset4[0],\n        ty = _this$_offset4[1];\n      ctx.translate(cx, cy);\n      this._shape.render(ctx);\n      ctx.translate(-w2, -h2);\n      if (this._scrollbarX.visible) {\n        this._scrollbarX.render(ctx);\n      }\n      if (this._scrollbarY.visible) {\n        this._scrollbarY.render(ctx);\n      }\n      ctx.translate(w2, h2);\n      ctx.save();\n      ctx.beginPath();\n      ctx.rect(-w2, -h2, w, h);\n      ctx.clip();\n      ctx.translate(tx, ty);\n      this._stack.render(ctx);\n      this._linkStack.render(ctx);\n      ctx.translate(-cx - tx, -cy - ty);\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point, condition) {\n      var _point4 = scroll_group_slicedToArray(point, 2),\n        gx = _point4[0],\n        gy = _point4[1];\n      var _this$anchor5 = scroll_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor5[0],\n        cy = _this$anchor5[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var sp = [gx - cx + w, gy - cy + h];\n      this._scrollBarStatus.hitScrollX = false;\n      this._scrollBarStatus.hitScrollY = false;\n      if (this._scrollbarX.visible) {\n        var xhit = this._scrollbarX.isHit(sp);\n        if (xhit) {\n          this._scrollBarStatus.hitScrollX = true;\n          this._scrollbarX.setHit(true);\n          return true;\n        }\n      }\n      this._scrollbarX.setHit(false);\n      if (this._scrollbarY.visible) {\n        var yhit = this._scrollbarY.isHit(sp);\n        if (yhit) {\n          this._scrollBarStatus.hitScrollY = true;\n          this._scrollbarY.setHit(true);\n          return true;\n        }\n      }\n      this._scrollbarY.setHit(false);\n\n      // const br = this._getViewBox();\n      var isInBound = this._shape.isHit([gx - cx, gy - cy]);\n      if (isInBound) {\n        var _this$_offset5 = scroll_group_slicedToArray(this._offset, 2),\n          tx = _this$_offset5[0],\n          ty = _this$_offset5[1];\n        var p = [gx - cx - tx, gy - cy - ty];\n        this._currentp = p; // 暂存，为了后续计算别的位置\n        var target = this._stack.checkHit(p, condition);\n        if (target) return target;\n      } else {\n        this._stack.resetHitStatus();\n      }\n      return false;\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        width: this.width,\n        height: this.height\n      };\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var ltx = anchor[0] - w;\n      var lty = anchor[1] - h;\n      var rbx = anchor[0] + w;\n      var rby = anchor[1] + h;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      var _ref;\n      var p2 = this.anchor;\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        p2 = this._belongs.calculateToCoordination(p2);\n      }\n      var _p = p2,\n        _p2 = scroll_group_slicedToArray(_p, 2),\n        x2 = _p2[0],\n        y2 = _p2[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      return _ref = {}, scroll_group_defineProperty(_ref, DIRECTION.RIGHT, [x2 + w, y2]), scroll_group_defineProperty(_ref, DIRECTION.LEFT, [x2 - w, y2]), scroll_group_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + h]), scroll_group_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - h]), scroll_group_defineProperty(_ref, DIRECTION.SELF, [x2 + w * 0.618, y2 + h * 0.618]), _ref;\n    }\n  }, {\n    key: "onEnterViewbox",\n    value: function onEnterViewbox() {\n      this.interateNodeStack(function (instance) {\n        instance.onEnterViewbox();\n      });\n    }\n  }, {\n    key: "onLeaveViewbox",\n    value: function onLeaveViewbox() {\n      this.interateNodeStack(function (instance) {\n        instance.onLeaveViewbox();\n      });\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      this._shape.destroy();\n      this.interateNodeStack(function (instance) {\n        instance.destroy();\n      });\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      var C = this.constructor;\n      var configs = Object.assign({}, this._rawConfigs, {\n        layout: this._layout && this._layout.clone()\n      });\n      var t = new C(configs);\n      this.interateNodeStack(function (instance) {\n        t.addToStack(instance.clone());\n      });\n      t.recalculate();\n      t.visible = this.visible;\n      return t;\n    }\n  }]);\n  return ScrollGroup;\n}(node);\nObject.assign(ScrollGroup.prototype, stackMixin);\nObject.assign(ScrollGroup.prototype, layoutMixin);\nObject.assign(ScrollGroup.prototype, {\n  recalculateUp: function recalculateUp() {\n    var dirty = true;\n    if (this.getBoundingDimension) {\n      // const { width: wold, height: hold } = this.getBoundingDimension();\n      var wold = this._innerWidth;\n      var hold = this._innerHeight;\n      if (this.resetChildrenPosition) {\n        this.resetChildrenPosition();\n      }\n      if (this._getBoundingGroupRect) {\n        this._getBoundingGroupRect();\n      }\n      this.reflow();\n      if (this._getBoundingGroupRect) {\n        this._getBoundingGroupRect();\n      }\n      var wnow = this._innerWidth;\n      var hnow = this._innerHeight;\n      // const { width: wnow, height: hnow } = this.getBoundingDimension();\n      dirty = wold !== wnow || hold !== hnow;\n    } else {\n      this.reflow();\n    }\n    if (this._belongs && dirty) {\n      this._resetOffset();\n      this._belongs.recalculateUp();\n    }\n  },\n  recalculate: function recalculate() {\n    var _this$getBoundingDime = this.getBoundingDimension(),\n      wold = _this$getBoundingDime.width,\n      hold = _this$getBoundingDime.height;\n    this.reflow();\n    if (this._getBoundingGroupRect) {\n      this._getBoundingGroupRect();\n    }\n    var _this$getBoundingDime2 = this.getBoundingDimension(),\n      wnow = _this$getBoundingDime2.width,\n      hnow = _this$getBoundingDime2.height;\n    if (wold !== wnow || hold !== hnow) {\n      this._resetOffset();\n    }\n  }\n});\n/* harmony default export */ const scroll_group = (ScrollGroup);\n;// CONCATENATED MODULE: ./src/core/events/commonAdapter.js\n/* harmony default export */ const commonAdapter = ({\n  canvas: {\n    wheel: function wheel(event, jflow) {\n      event.preventDefault();\n      var offsetX = event.offsetX,\n        offsetY = event.offsetY,\n        deltaX = event.deltaX,\n        deltaY = event.deltaY;\n      if (event.ctrlKey) {\n        deltaY = -deltaY;\n      }\n      jflow.zoomHandler(offsetX, offsetY, deltaX, deltaY, event);\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/core/instance/base-link.js\nfunction base_link_typeof(obj) { "@babel/helpers - typeof"; return base_link_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, base_link_typeof(obj); }\nfunction base_link_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction base_link_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, base_link_toPropertyKey(descriptor.key), descriptor); } }\nfunction base_link_createClass(Constructor, protoProps, staticProps) { if (protoProps) base_link_defineProperties(Constructor.prototype, protoProps); if (staticProps) base_link_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction base_link_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) base_link_setPrototypeOf(subClass, superClass); }\nfunction base_link_setPrototypeOf(o, p) { base_link_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return base_link_setPrototypeOf(o, p); }\nfunction base_link_createSuper(Derived) { var hasNativeReflectConstruct = base_link_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = base_link_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = base_link_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return base_link_possibleConstructorReturn(this, result); }; }\nfunction base_link_possibleConstructorReturn(self, call) { if (call && (base_link_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return base_link_assertThisInitialized(self); }\nfunction base_link_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction base_link_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction base_link_getPrototypeOf(o) { base_link_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return base_link_getPrototypeOf(o); }\nfunction base_link_defineProperty(obj, key, value) { key = base_link_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction base_link_toPropertyKey(arg) { var key = base_link_toPrimitive(arg, "string"); return base_link_typeof(key) === "symbol" ? key : String(key); }\nfunction base_link_toPrimitive(input, hint) { if (base_link_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (base_link_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n/**\n * @typedef {Instance~Configs} BaseLink~Configs\n * @property {Instance} from   - 起始单元\n * @property {Instance} to     - 终止单元\n * @property {String} fromDir  - 起始方向 \n * @property {String} toDir    - 终止方向 \n * @property {String} key      - 连线唯一键值\n * @property {String} backgroundColor    - 线条颜色 \n */\n/**\n * 连线基类\n * @constructor BaseLink\n * @extends Instance\n * @param {BaseLink~Configs} configs - 配置\n */\nvar BaseLink = /*#__PURE__*/function (_Instance) {\n  base_link_inherits(BaseLink, _Instance);\n  var _super = base_link_createSuper(BaseLink);\n  function BaseLink() {\n    var _this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    base_link_classCallCheck(this, BaseLink);\n    _this = _super.call(this);\n    /** @member {Instance}      - 起始单元 */\n    base_link_defineProperty(base_link_assertThisInitialized(_this), "INSTANCE_TYPE", \'LINK\');\n    _this.from = configs.from;\n    /** @member {Instance}      - 终止单元 */\n    _this.to = configs.to;\n    /** @member {DIRECTION}      - 起始方向 */\n    _this.fromDir = configs.fromDir;\n    /** @member {DIRECTION}      - 终止方向 */\n    _this.toDir = configs.toDir;\n    /** @member {number[][]}     - 连线控制点缓存 */\n    _this._cachePoints = null;\n    /** @member {string}     - 连线颜色，默认为 #000 */\n    _this.backgroundColor = configs.backgroundColor || \'#000\';\n    _this.isSelf = !!configs.isSelf;\n    return _this;\n  }\n\n  /**\n   * 是否出现在当前视窗内\n   * @param {number[]} viewbox\n   */\n  base_link_createClass(BaseLink, [{\n    key: "nextSibling",\n    get: function get() {\n      var _this2 = this;\n      if (!this._belongs) {\n        return null;\n      }\n      var stack = this._belongs._linkStack;\n      var idx = stack.findIndex(function (s) {\n        return s === _this2;\n      });\n      if (idx !== -1) {\n        return stack[idx + 1];\n      }\n      return null;\n    }\n  }, {\n    key: "isInViewBox",\n    value: function isInViewBox(viewbox) {\n      return true;\n    }\n  }, {\n    key: "bringToTop",\n    value: function bringToTop() {\n      var _this3 = this;\n      var linkStack = this._jflow._linkStack;\n      var index = linkStack.findIndex(function (l) {\n        return l === _this3;\n      });\n      linkStack.splice(index, 1);\n      linkStack.push(this);\n      this._jflow._render();\n    }\n  }]);\n  return BaseLink;\n}(instance_instance);\n/* harmony default export */ const base_link = (BaseLink);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/shadow-cache.js\nfunction shadow_cache_typeof(obj) { "@babel/helpers - typeof"; return shadow_cache_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, shadow_cache_typeof(obj); }\nfunction shadow_cache_slicedToArray(arr, i) { return shadow_cache_arrayWithHoles(arr) || shadow_cache_iterableToArrayLimit(arr, i) || shadow_cache_unsupportedIterableToArray(arr, i) || shadow_cache_nonIterableRest(); }\nfunction shadow_cache_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction shadow_cache_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return shadow_cache_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return shadow_cache_arrayLikeToArray(o, minLen); }\nfunction shadow_cache_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction shadow_cache_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction shadow_cache_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction shadow_cache_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction shadow_cache_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, shadow_cache_toPropertyKey(descriptor.key), descriptor); } }\nfunction shadow_cache_createClass(Constructor, protoProps, staticProps) { if (protoProps) shadow_cache_defineProperties(Constructor.prototype, protoProps); if (staticProps) shadow_cache_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction shadow_cache_toPropertyKey(arg) { var key = shadow_cache_toPrimitive(arg, "string"); return shadow_cache_typeof(key) === "symbol" ? key : String(key); }\nfunction shadow_cache_toPrimitive(input, hint) { if (shadow_cache_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (shadow_cache_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction shadow_cache_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) shadow_cache_setPrototypeOf(subClass, superClass); }\nfunction shadow_cache_setPrototypeOf(o, p) { shadow_cache_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return shadow_cache_setPrototypeOf(o, p); }\nfunction shadow_cache_createSuper(Derived) { var hasNativeReflectConstruct = shadow_cache_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = shadow_cache_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = shadow_cache_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return shadow_cache_possibleConstructorReturn(this, result); }; }\nfunction shadow_cache_possibleConstructorReturn(self, call) { if (call && (shadow_cache_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return shadow_cache_assertThisInitialized(self); }\nfunction shadow_cache_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction shadow_cache_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction shadow_cache_getPrototypeOf(o) { shadow_cache_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return shadow_cache_getPrototypeOf(o); }\n\nvar ShadowCache = /*#__PURE__*/function (_Node) {\n  shadow_cache_inherits(ShadowCache, _Node);\n  var _super = shadow_cache_createSuper(ShadowCache);\n  function ShadowCache(configs) {\n    var _this;\n    shadow_cache_classCallCheck(this, ShadowCache);\n    _this = _super.call(this, configs);\n    // this.imageData = configs.imageData;\n    _this.width = configs.width;\n    _this.height = configs.height;\n    _this.imageBuffer = document.createElement(\'canvas\');\n    _this.imageBuffer.width = _this.width + 2;\n    _this.imageBuffer.height = _this.height + 2;\n    configs.cache(_this.imageBuffer.getContext(\'2d\'));\n    return _this;\n  }\n  shadow_cache_createClass(ShadowCache, [{\n    key: "render",\n    value: function render(ctx) {\n      var _this$anchor = shadow_cache_slicedToArray(this.anchor, 2),\n        cx = _this$anchor[0],\n        cy = _this$anchor[1];\n      ctx.save();\n      ctx.translate(cx, cy);\n      ctx.beginPath();\n      ctx.drawImage(this.imageBuffer, -this.width / 2, -this.height / 2);\n      ctx.translate(-cx, -cy);\n      ctx.restore();\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        height: this.height,\n        width: this.width\n      };\n    }\n  }, {\n    key: "recalculate",\n    value: function recalculate() {}\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var ltx = anchor[0] - w;\n      var lty = anchor[1] - h;\n      var rbx = anchor[0] + w;\n      var rby = anchor[1] + h;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }]);\n  return ShadowCache;\n}(node);\n/* harmony default export */ const shadow_cache = (ShadowCache);\n;// CONCATENATED MODULE: ./src/core/instance/elements/text.js\nfunction text_typeof(obj) { "@babel/helpers - typeof"; return text_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, text_typeof(obj); }\nfunction text_slicedToArray(arr, i) { return text_arrayWithHoles(arr) || text_iterableToArrayLimit(arr, i) || text_unsupportedIterableToArray(arr, i) || text_nonIterableRest(); }\nfunction text_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction text_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return text_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return text_arrayLikeToArray(o, minLen); }\nfunction text_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction text_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction text_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction text_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction text_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, text_toPropertyKey(descriptor.key), descriptor); } }\nfunction text_createClass(Constructor, protoProps, staticProps) { if (protoProps) text_defineProperties(Constructor.prototype, protoProps); if (staticProps) text_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction text_toPropertyKey(arg) { var key = text_toPrimitive(arg, "string"); return text_typeof(key) === "symbol" ? key : String(key); }\nfunction text_toPrimitive(input, hint) { if (text_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (text_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction text_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) text_setPrototypeOf(subClass, superClass); }\nfunction text_setPrototypeOf(o, p) { text_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return text_setPrototypeOf(o, p); }\nfunction text_createSuper(Derived) { var hasNativeReflectConstruct = text_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = text_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = text_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return text_possibleConstructorReturn(this, result); }; }\nfunction text_possibleConstructorReturn(self, call) { if (call && (text_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return text_assertThisInitialized(self); }\nfunction text_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction text_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction text_getPrototypeOf(o) { text_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return text_getPrototypeOf(o); }\n\n\n\n\nvar TEXT_ALIGN = {\n  CENTER: \'center\',\n  LEFT: \'left\',\n  RIGHT: \'right\'\n};\nvar SPACE_REG = /\\s/g;\nvar Text = /*#__PURE__*/function (_Rectangle) {\n  text_inherits(Text, _Rectangle);\n  var _super = text_createSuper(Text);\n  function Text(configs) {\n    var _this;\n    text_classCallCheck(this, Text);\n    _this = _super.call(this, configs);\n    _this.type = \'Text\';\n    _this.content = configs.content || \'\';\n    _this.fontFamily = configs.fontFamily || \'-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Tahoma,Arial,Noto Sans,PingFang SC,Microsoft YaHei,Hiragino Sans GB,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji\';\n    _this.fontSize = configs.fontSize || \'14px\';\n    _this.fontWeight = configs.fontWeight || \'\';\n    _this.textColor = configs.textColor || \'white\';\n    _this.placeholderColor = configs.placeholderColor || configs.textColor || \'white\';\n    _this.textAlign = configs.textAlign || TEXT_ALIGN.CENTER;\n    _this.textBaseline = configs.textBaseline || \'middle\';\n    _this.lineHeight = configs.lineHeight;\n    _this.indent = configs.indent || 0;\n    _this.backgroundColor = configs.backgroundColor;\n    _this.editable = configs.editable;\n    _this.definedWidth = configs.definedWidth;\n    _this.minWidth = configs.minWidth || 0;\n    _this.maxWidth = configs.maxWidth;\n    _this.ellipsis = configs.ellipsis;\n    _this.placeholder = configs.placeholder || \'\';\n    _this.emptyWhenInput = configs.emptyWhenInput || false;\n    _this.editting = false;\n    _this.disabled = configs.disabled;\n    _this.cursorColor = configs.cursorColor || \'#60CFC4\';\n    _this.textRangeColor = configs.textRangeColor || \'#4E75EC1A\';\n    _this.spacePlaceholder = configs.spacePlaceholder;\n    _this.spacePlaceholderColor = configs.spacePlaceholderColor;\n    _this.spaceRecords = [];\n    _this._spacedContentSegmnent = [];\n    _this._status = {\n      editing: false,\n      cursorshow: true,\n      cursoranime: null,\n      lastElapsed: 0,\n      refreshElapsed: false,\n      cursorDragging: false,\n      shiftOn: false,\n      oldVal: \'\',\n      inputElement: null\n    };\n    _this._cursorOffset = 0;\n    _this._textRange = {\n      enable: false,\n      rangefrom: null,\n      // offsetfrom\n      rangeTo: null,\n      // offsetto\n      initialRange: null // offset\n    };\n\n    if (_this.editable) {\n      _this._makeFunctional();\n    }\n    _this.preCalculateText();\n    _this.shadowCache();\n    return _this;\n  }\n  text_createClass(Text, [{\n    key: "replaceSpaceHolder",\n    value: function replaceSpaceHolder(content) {\n      var useCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (useCache) {\n        return content.replace(/\\s/g, this.spacePlaceholder);\n      }\n      var r = this.spaceRecords;\n      var p = this.spacePlaceholder;\n      r.length = 0;\n      var lastOffset;\n      var c = content.replace(/\\s/g, function (_, offset) {\n        if (lastOffset === undefined) {\n          lastOffset = offset;\n          r.push(offset);\n        }\n        if (offset - lastOffset > 1) {\n          r.push(lastOffset);\n          r.push(offset);\n        }\n        lastOffset = offset;\n        return p;\n      });\n      if (lastOffset !== undefined) {\n        r.push(lastOffset);\n      }\n      return c;\n    }\n  }, {\n    key: "currentContent",\n    get: function get() {\n      return this.content || this.placeholder || \'\';\n    }\n  }, {\n    key: "isEmpty",\n    get: function get() {\n      return !this.content;\n    }\n  }, {\n    key: "preCalculateText",\n    value: function preCalculateText() {\n      var _this2 = this;\n      requestCacheCanvas(function (ctx) {\n        ctx.beginPath();\n        ctx.font = "".concat(_this2.fontWeight, " ").concat(_this2.fontSize, " ").concat(_this2.fontFamily);\n        ctx.textAlign = _this2.textAlign;\n        ctx.textBaseline = _this2.textBaseline;\n        var t_h = parseInt(_this2.fontSize);\n        var content = _this2.currentContent;\n        if (_this2.spacePlaceholder) {\n          content = _this2.replaceSpaceHolder(content);\n        }\n        var _ctx$measureText = ctx.measureText(content),\n          fontBoundingBoxAscent = _ctx$measureText.fontBoundingBoxAscent,\n          fontBoundingBoxDescent = _ctx$measureText.fontBoundingBoxDescent,\n          width = _ctx$measureText.width;\n        _this2._textWidth = _this2.indent + width;\n        if (_this2.definedWidth) {\n          if (_this2.ellipsis && _this2._textWidth > _this2.definedWidth) {\n            var offset = _this2._calculateOffset(_this2.definedWidth - 12);\n            _this2.ellipsisContent = content.substring(0, offset) + \'...\';\n          } else {\n            _this2.ellipsisContent = content;\n          }\n          _this2.width = _this2.definedWidth;\n        } else if (_this2.maxWidth && _this2.ellipsis) {\n          if (_this2._textWidth > _this2.maxWidth) {\n            var ratio = _this2.maxWidth / _this2._textWidth;\n            var l = Math.floor(content.length * ratio - 3);\n            _this2.ellipsisContent = content.substring(0, l) + \'...\';\n          } else {\n            _this2.ellipsisContent = content;\n          }\n          _this2.width = Math.min(_this2.maxWidth, _this2._textWidth);\n        } else {\n          _this2.width = Math.max(_this2.minWidth, _this2._textWidth);\n        }\n        if (_this2.spacePlaceholder) {\n          var _ctx$measureText2 = ctx.measureText(_this2.spacePlaceholder),\n            s_width = _ctx$measureText2.width;\n          var r2 = _this2._spacedContentSegmnent;\n          var textColor = _this2.textColor;\n          var lastOffset = 0;\n          r2.length = 0;\n          if (_this2.spaceRecords.length) {\n            var r = _this2.spaceRecords;\n            var pcolor = _this2.spacePlaceholderColor;\n            var _l = r.length;\n            var i = 0;\n            while (i < _l) {\n              var f = r[i++];\n              var t = r[i++];\n              var q = content.substring(lastOffset, f);\n              r2.push([q, ctx.measureText(q).width, textColor]);\n              r2.push([content.substring(f, t + 1), (t - f + 1) * s_width, pcolor]);\n              lastOffset = t + 1;\n            }\n          }\n          if (lastOffset < content.length) {\n            var _q = content.substring(lastOffset);\n            r2.push([_q, ctx.measureText(_q).width, textColor]);\n          }\n        }\n        var height = Math.abs(fontBoundingBoxAscent) + Math.abs(fontBoundingBoxDescent) || t_h;\n        _this2._textHeight = height;\n        if (_this2.lineHeight) {\n          _this2.height = _this2.lineHeight;\n        } else {\n          _this2.height = height;\n        }\n      });\n    }\n  }, {\n    key: "shadowCache",\n    value: function shadowCache() {\n      var _this3 = this;\n      var scale = window.devicePixelRatio;\n      var w = this.width * scale;\n      var h = this.height * scale;\n      var i = this.indent * scale;\n      var size = parseInt(this.fontSize) * scale;\n      this._shadowCache = new shadow_cache({\n        width: w,\n        height: h,\n        cache: function cache(ctx) {\n          // const [cx, cy] = this.anchor;\n          // ctx.scale(4, 4)\n          ctx.translate(w / 2, h / 2);\n          var font = "".concat(_this3.fontWeight, " ").concat(size, "px ").concat(_this3.fontFamily);\n          ctx.font = font;\n          ctx.textAlign = _this3.textAlign;\n          ctx.textBaseline = _this3.textBaseline;\n          ctx.fillStyle = _this3.isEmpty ? _this3.placeholderColor : _this3.textColor;\n          var content = _this3.currentContent;\n          if (_this3.spacePlaceholder) {\n            if (_this3.textAlign === TEXT_ALIGN.LEFT) {\n              var hw = w / 2;\n              var _w = -hw + i / 2;\n              _this3._spacedContentSegmnent.forEach(function (seg) {\n                ctx.fillStyle = seg[2];\n                ctx.fillText(seg[0], _w, 0);\n                _w += seg[1] * scale;\n              });\n            }\n          } else {\n            if (_this3.ellipsisContent) {\n              content = _this3.ellipsisContent;\n            }\n            if (content) {\n              if (_this3.textAlign === TEXT_ALIGN.LEFT) {\n                var _hw = w / 2;\n                ctx.fillText(content, -_hw + i / 2, 0);\n              } else if (_this3.textAlign === TEXT_ALIGN.RIGHT) {\n                var _hw2 = w / 2;\n                ctx.fillText(content, _hw2, 0);\n              } else {\n                ctx.fillText(content, i / 2, 0);\n              }\n            }\n          }\n        }\n      });\n    }\n  }, {\n    key: "setConfig",\n    value: function setConfig(configs) {\n      var _this4 = this;\n      Object.keys(configs).forEach(function (k) {\n        if (configs[k] !== undefined && configs[k] !== null) {\n          _this4[k] = configs[k];\n          _this4._rawConfigs[k] = configs[k];\n        }\n      });\n      this.preCalculateText();\n      this.shadowCache();\n    }\n  }, {\n    key: "click",\n    value: function click() {\n      var _this5 = this;\n      if (!this._status.editing) {\n        var flag = true;\n        this.dispatchEvent(new events(\'edit\', {\n          target: this,\n          preventDefault: function preventDefault() {\n            flag = false;\n          }\n        }));\n        if (!flag) {\n          return;\n        }\n        var point = this._belongs._currentp;\n        var jflow = this._jflow;\n        if (point) {\n          this._cursorOffset = this._positionToCursorOffset(point);\n        } else {\n          this._cursorOffset = 0;\n        }\n        var inputElement = createInputElement(this._controlCallback.bind(this), this._defaultCallback.bind(this));\n        var wrapper = jflow.DOMwrapper;\n        wrapper.append(inputElement);\n        inputElement.focus({\n          preventScroll: true\n        });\n        jflow.setFocusInstance(this);\n        Object.assign(this._status, {\n          editing: true,\n          oldVal: this.content,\n          inputElement: inputElement,\n          cursoranime: jflow.requestJFlowAnime(function (elapsed) {\n            var lastElapsed = _this5._status.lastElapsed;\n            if (_this5._status.refreshElapsed) {\n              _this5._status.lastElapsed = elapsed;\n              _this5._status.refreshElapsed = false;\n            }\n            if (elapsed - lastElapsed > 500) {\n              _this5._status.cursorshow = !_this5._status.cursorshow;\n              _this5._status.lastElapsed = elapsed;\n            }\n          })\n        });\n        if (this.emptyWhenInput) {\n          this.content = \'\';\n        }\n        this.syncShadowInputPosition();\n      }\n    }\n  }, {\n    key: "_makeFunctional",\n    value: function _makeFunctional() {\n      var _this6 = this;\n      var blurHandler = function blurHandler(event) {\n        _this6._status.editing = false;\n        if (_this6._status.inputElement) {\n          _this6._status.inputElement.remove();\n        }\n        if (_this6._belongs) {\n          _this6._jflow.scheduleRender();\n        }\n      };\n      this.addEventListener(\'dblclick\', function (event) {\n        if (event.currentTarget !== _this6) {\n          return;\n        }\n        if (_this6._status.editing) {\n          _this6._selectFullRange();\n        }\n      });\n      this.addEventListener(\'click\', function (event) {\n        if (event.currentTarget !== _this6) {\n          return;\n        }\n        // event.detail.bubbles = false;\n        if (_this6._status.editing) {\n          var point = _this6._belongs._currentp;\n          var offset = _this6._positionToCursorOffset(point);\n          if (_this6._status.shiftOn) {\n            var initialRange = _this6._textRange.initialRange;\n            Object.assign(_this6._textRange, {\n              rangefrom: Math.min(offset, initialRange),\n              rangeTo: Math.max(offset, initialRange),\n              enable: true\n            });\n            _this6._cursorOffset = _this6._textRange.rangeTo;\n            _this6._status.inputElement.focus({\n              preventScroll: true\n            });\n            // this._refreshCursor();  \n          } else {\n            _this6._cursorOffset = offset;\n            _this6._status.inputElement.focus({\n              preventScroll: true\n            });\n            _this6._refreshCursor();\n            _this6.syncShadowInputPosition();\n          }\n        }\n        _this6.click();\n      });\n      this.addEventListener(\'blur\', function (event) {\n        var _this6$_status$cursor;\n        blurHandler(event);\n        _this6.dispatchEvent(new events(\'change\', {\n          target: _this6,\n          oldVal: _this6._status.oldVal,\n          val: _this6.content\n        }));\n        _this6._textRange.enable = false;\n        (_this6$_status$cursor = _this6._status.cursoranime) === null || _this6$_status$cursor === void 0 ? void 0 : _this6$_status$cursor.cancel();\n        Object.assign(_this6._status, {\n          editing: false,\n          cursorshow: true,\n          cursoranime: null,\n          lastElapsed: 0,\n          refreshElapsed: false,\n          cursorDragging: false,\n          shiftOn: false,\n          oldVal: \'\',\n          inputElement: null\n        });\n      });\n      this.addEventListener(\'instancePressStart\', function (event) {\n        if (_this6._status.editing && !_this6._status.shiftOn) {\n          event.detail.bubbles = false;\n          event.detail.preventDefault();\n          var point = _this6._belongs._currentp;\n          var c = _this6._positionToCursorOffset(point);\n          _this6._textRange.initialRange = c;\n          var jflow = event.detail.jflow;\n          var moved = false;\n          var t = function (e) {\n            moved = true;\n            var offsetX = e.offsetX,\n              offsetY = e.offsetY;\n            var p = jflow._calculatePointBack([offsetX, offsetY]);\n            jflow._stack.checkHit(p);\n            var point = _this6._belongs._currentp;\n            var c = _this6._positionToCursorOffset(point);\n            var initialRange = _this6._textRange.initialRange;\n            _this6._status.editing = false;\n            Object.assign(_this6._textRange, {\n              rangefrom: Math.min(c, initialRange),\n              rangeTo: Math.max(c, initialRange),\n              enable: true\n            });\n          }.bind(_this6);\n          document.addEventListener(\'pointermove\', t);\n          document.addEventListener(\'pointerup\', function (e) {\n            document.removeEventListener(\'pointermove\', t);\n            if (!moved) {\n              _this6._textRange.initialRange = null;\n              return;\n            }\n            var rangeTo = _this6._textRange.rangeTo;\n            _this6._cursorOffset = rangeTo;\n            _this6._status.editing = true;\n            _this6._status.inputElement.focus({\n              preventScroll: true\n            });\n            _this6._textRange.initialRange = null;\n          }, {\n            once: true\n          });\n        }\n      });\n    }\n  }, {\n    key: "_positionToCursorOffset",\n    value: function _positionToCursorOffset(point) {\n      var _point = text_slicedToArray(point, 1),\n        x = _point[0];\n      var w = this.width / 2;\n      var _this$anchor = text_slicedToArray(this.anchor, 1),\n        ox = _this$anchor[0];\n      var offsetX = x - (ox - w);\n      var cursorOffset = 0;\n      if (offsetX >= this._textWidth) {\n        cursorOffset = this.content.length;\n      } else {\n        cursorOffset = this._calculateOffset(offsetX);\n      }\n      return cursorOffset;\n    }\n  }, {\n    key: "_calculateOffset",\n    value: function _calculateOffset(offx) {\n      var _this7 = this;\n      var content = this.content;\n      if (this.spacePlaceholder) {\n        content = this.replaceSpaceHolder(content, true);\n      }\n      var maxL = content.length - 1;\n      var contentWidth = this._textWidth;\n      if (contentWidth === 0) {\n        return 0;\n      }\n      var allwidth = contentWidth;\n      var idx = Math.floor(offx / allwidth * maxL);\n      requestCacheCanvas(function (ctx) {\n        ctx.font = "".concat(_this7.fontSize, " ").concat(_this7.fontFamily);\n        var g1, g2;\n        var lastidx;\n        var c = content.substring(0, idx);\n        var c1 = content.substring(idx - 1, idx);\n        var c2 = content.substring(idx, idx + 1);\n        var w = ctx.measureText(c).width;\n        var w1 = ctx.measureText(c1).width;\n        var w2 = ctx.measureText(c2).width;\n        g1 = w - w1 / 2;\n        g2 = w + w2 / 2;\n        do {\n          if (g1 <= offx && g2 >= offx) {\n            break;\n          }\n          if (g1 > offx) {\n            // 左侧少了\n            var spanw = g2 - offx;\n            lastidx = idx;\n            if (spanw < 100) {\n              idx -= 1;\n            } else {\n              idx -= Math.floor(spanw / g2 * lastidx);\n            }\n            c = content.substring(idx, lastidx);\n            w -= ctx.measureText(c).width;\n          } else if (g2 < offx) {\n            // 右侧少了\n            var _spanw = offx - g1;\n            lastidx = idx;\n            if (_spanw < 100) {\n              idx += 1;\n            } else {\n              idx += Math.floor(_spanw / (allwidth - g1) * (maxL - lastidx));\n            }\n            c = content.substring(lastidx, idx);\n            w += ctx.measureText(c).width;\n          }\n          c1 = content.substring(idx - 1, idx);\n          c2 = content.substring(idx, idx + 1);\n          w1 = ctx.measureText(c1).width;\n          w2 = ctx.measureText(c2).width;\n          g1 = w - w1 / 2;\n          g2 = w + w2 / 2;\n        } while (idx >= 0 && idx <= maxL);\n      });\n      return idx;\n    }\n  }, {\n    key: "_refreshCursor",\n    value: function _refreshCursor() {\n      if (this._status.editing) {\n        Object.assign(this._status, {\n          cursorshow: true,\n          refreshElapsed: true\n        });\n      }\n      if (this._textRange.enable) {\n        this._textRange.enable = false;\n      }\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      if (!ctx.disableCache && !this._status.editing && this._jflow.scale * parseInt(this.fontSize) < 8) {\n        var _this$anchor2 = text_slicedToArray(this.anchor, 2),\n          cx = _this$anchor2[0],\n          cy = _this$anchor2[1];\n        // this._shadowCache.render(ctx);\n        ctx.save();\n        ctx.translate(cx, cy);\n        ctx.beginPath();\n        ctx.drawImage(this._shadowCache.imageBuffer, -this.width / 2, -this.height / 2, this.width, this.height);\n        ctx.translate(-cx, -cy);\n        ctx.restore();\n        return;\n      }\n      var font = "".concat(this.fontWeight, " ").concat(this.fontSize, " ").concat(this.fontFamily);\n      if (ctx.font !== font) {\n        ctx.font = font;\n      }\n      if (ctx.textAlign !== this.textAlign) {\n        ctx.textAlign = this.textAlign;\n      }\n      if (ctx.textBaseline !== this.textBaseline) {\n        ctx.textBaseline = this.textBaseline;\n      }\n      ctx.fillStyle = this.isEmpty ? this.placeholderColor : this.textColor;\n      var content = this.currentContent;\n      if (this.spacePlaceholder) {\n        if (this.textAlign === TEXT_ALIGN.LEFT) {\n          var _hw3 = this.width / 2;\n          var w = this.anchor[0] - _hw3 + this.indent / 2;\n          var _y = this.anchor[1];\n          this._spacedContentSegmnent.forEach(function (seg) {\n            ctx.fillStyle = seg[2];\n            ctx.fillText(seg[0], w, _y);\n            w += seg[1];\n          });\n        }\n      } else {\n        if (this.ellipsisContent) {\n          content = this.ellipsisContent;\n        }\n        if (content) {\n          if (this.textAlign === TEXT_ALIGN.LEFT) {\n            var _hw4 = this.width / 2;\n            ctx.fillText(content, this.anchor[0] - _hw4 + this.indent / 2, this.anchor[1]);\n          } else if (this.textAlign === TEXT_ALIGN.RIGHT) {\n            var _hw5 = this.width / 2;\n            ctx.fillText(content, this.anchor[0] + _hw5, this.anchor[1]);\n          } else {\n            ctx.fillText(content, this.anchor[0] + this.indent / 2, this.anchor[1]);\n          }\n        }\n      }\n      var hw = this.width / 2;\n      var textheight = this._textHeight;\n      var _this$anchor3 = text_slicedToArray(this.anchor, 2),\n        x = _this$anchor3[0],\n        y = _this$anchor3[1];\n      var lx = x - hw;\n      var ly = y - textheight / 2;\n      if (this._status.cursorshow && this._status.editing) {\n        var offset = this._cursorOffset;\n        var c = content.substring(0, offset);\n        if (this.spacePlaceholder) {\n          c = this.replaceSpaceHolder(c, true);\n        }\n        var cw = lx + ctx.measureText(c).width;\n        var c_len = this._textHeight / 2;\n        ctx.beginPath();\n        ctx.moveTo(cw, y - c_len);\n        ctx.lineTo(cw, y + c_len);\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = this.cursorColor;\n        ctx.stroke();\n      }\n      if (this._textRange.enable) {\n        var _this$_textRange = this._textRange,\n          rangefrom = _this$_textRange.rangefrom,\n          rangeTo = _this$_textRange.rangeTo;\n        var _c = this.content.substring(0, rangefrom);\n        var range = this.content.substring(rangefrom, rangeTo);\n        var _x2 = lx + ctx.measureText(_c).width;\n        var _w2 = ctx.measureText(range).width;\n        ctx.beginPath();\n        ctx.rect(_x2, ly, _w2, textheight);\n        ctx.fillStyle = this.textRangeColor;\n        ctx.fill();\n      }\n    }\n  }, {\n    key: "_inputControl",\n    value: function _inputControl(op, data) {\n      if (this._textRange.enable) {\n        this._clearTextRange();\n        if (op === \'Backspace\') {\n          this.dispatchEvent(new events(\'input\', {\n            target: this,\n            oldVal: this._status.oldVal,\n            val: this.content\n          }));\n          this.refresh();\n          this.syncShadowInputPosition();\n          return;\n        }\n      }\n      var offset = this._cursorOffset;\n      var content = this.content;\n      var preContent = content.substring(0, offset);\n      var afterContent;\n      if (this.cacheIdx) {\n        afterContent = content.substring(this.cacheIdx[1]);\n      } else {\n        afterContent = content.substring(offset);\n      }\n      var stopInputEvent = false;\n      switch (op) {\n        case "Input":\n          preContent += data;\n          this._cursorOffset += data.length;\n          this.content = preContent + afterContent;\n          break;\n        case "compositionstart":\n          this.cacheIdx = [preContent.length, preContent.length];\n          break;\n        case "compositionupdate":\n          preContent = preContent.substring(0, this.cacheIdx[0]);\n          preContent += data;\n          this.content = preContent + afterContent;\n          this._cursorOffset = this.cacheIdx[0] + data.length;\n          this.cacheIdx[1] = this.cacheIdx[0] + data.length;\n          break;\n        case "compositionend":\n          preContent = preContent.substring(0, this.cacheIdx[0]);\n          this._cursorOffset = this.cacheIdx[0] + data.length;\n          this.cacheIdx = null;\n          preContent += data;\n          this.content = preContent + afterContent;\n          break;\n        case "Enter":\n          if (this.cacheIdx) {\n            return;\n          }\n          var defaultAct = true;\n          this.dispatchEvent(new events(\'enterkeypressed\', {\n            target: this,\n            handler: function handler(val) {\n              defaultAct = val;\n            },\n            stopInput: function stopInput() {\n              stopInputEvent = true;\n            }\n          }));\n          if (defaultAct) {\n            this._jflow.blur();\n          }\n          break;\n        case "Backspace":\n          if (this.cacheIdx) {\n            return;\n          }\n          preContent = preContent.substring(0, preContent.length - 1);\n          this._cursorOffset = Math.max(0, this._cursorOffset - 1);\n          this.content = preContent + afterContent;\n          break;\n      }\n      if (!stopInputEvent) {\n        this.dispatchEvent(new events(\'input\', {\n          target: this,\n          oldVal: this._status.oldVal,\n          val: this.content\n        }));\n      }\n      this.refresh();\n      this.syncShadowInputPosition();\n    }\n  }, {\n    key: "refresh",\n    value: function refresh() {\n      this.preCalculateText();\n      this._belongs.recalculateUp();\n      this._jflow.scheduleRender();\n    }\n  }, {\n    key: "syncShadowInputPosition",\n    value: function syncShadowInputPosition() {\n      var _this8 = this;\n      if (this._status.editing) {\n        var hw = this.width / 2;\n        var hh = this.height / 2;\n        var lx = this.anchor[0] - hw;\n        var offset = this._cursorOffset;\n        requestCacheCanvas(function (ctx) {\n          ctx.beginPath();\n          ctx.font = "".concat(_this8.fontSize, " ").concat(_this8.fontFamily);\n          var c = _this8.content.substring(0, offset);\n          lx += ctx.measureText(c).width;\n        });\n        var point = this.calculateToRealWorld([lx, hh]);\n        var canvasMeta = this._jflow.canvasMeta;\n        var px = Math.min(canvasMeta.actual_width - 120, point[0]);\n        this._status.inputElement.style.transform = "translate(".concat(px, "px, ").concat(point[1], "px)");\n      }\n    }\n  }, {\n    key: "_controlCallback",\n    value: function _controlCallback(op, data, e) {\n      if (this._status.editing) {\n        Object.assign(this._status, {\n          cursorshow: true,\n          refreshElapsed: true\n        });\n      }\n      switch (op) {\n        case "Input":\n        case "compositionstart":\n        case "compositionupdate":\n        case "compositionend":\n        case "Enter":\n        case "Backspace":\n          this._inputControl(op, data);\n          break;\n        case "ArrowLeft":\n          if (this._textRange.enable) {\n            this._textRange.enable = false;\n          }\n          this._onArrowLeft();\n          break;\n        case "ArrowRight":\n          if (this._textRange.enable) {\n            this._textRange.enable = false;\n          }\n          this._onArrowRight();\n          break;\n        case "Shift":\n          this._onShiftToggle(data);\n          break;\n        case "CtrlA":\n          this._selectFullRange();\n          break;\n        case "COPY":\n          this._copy(e);\n          break;\n        case "CUT":\n          this._cut(e);\n          break;\n        case "PASTE":\n          this._paste(e);\n          break;\n      }\n    }\n  }, {\n    key: "_onArrowLeft",\n    value: function _onArrowLeft() {\n      this._cursorOffset = Math.max(0, this._cursorOffset - 1);\n      this._jflow.scheduleRender();\n      this.syncShadowInputPosition();\n    }\n  }, {\n    key: "_onArrowRight",\n    value: function _onArrowRight() {\n      this._cursorOffset = Math.min(this.content.length, this._cursorOffset + 1);\n      this._jflow.scheduleRender();\n      this.syncShadowInputPosition();\n    }\n  }, {\n    key: "_onShiftToggle",\n    value: function _onShiftToggle(val) {\n      this._status.shiftOn = val;\n      if (val) {\n        this._textRange.initialRange = this._cursorOffset;\n      } else {\n        this._textRange.initialRange = null;\n      }\n    }\n  }, {\n    key: "_selectFullRange",\n    value: function _selectFullRange() {\n      this._textRange = {\n        enable: true,\n        rangefrom: 0,\n        rangeTo: this.content.length\n      };\n      this._cursorOffset = this.content.length;\n    }\n  }, {\n    key: "_clearTextRange",\n    value: function _clearTextRange() {\n      if (this._textRange.enable) {\n        var _this$_textRange2 = this._textRange,\n          rangefrom = _this$_textRange2.rangefrom,\n          rangeTo = _this$_textRange2.rangeTo;\n        var content = this.content;\n        var preContent = content.substring(0, rangefrom);\n        var afterContent = content.substring(rangeTo);\n        this.content = preContent + afterContent;\n        this._cursorOffset = preContent.length;\n        this._textRange.enable = false;\n      }\n    }\n  }, {\n    key: "_getSelection",\n    value: function _getSelection() {\n      if (this._textRange.enable) {\n        var _this$_textRange3 = this._textRange,\n          rangefrom = _this$_textRange3.rangefrom,\n          rangeTo = _this$_textRange3.rangeTo;\n        var content = this.content;\n        return content.substring(rangefrom, rangeTo);\n      }\n      return null;\n    }\n  }, {\n    key: "_copy",\n    value: function _copy(event) {\n      var selection = this._getSelection();\n      if (selection) {\n        event.clipboardData.setData("text/plain", selection);\n      }\n    }\n  }, {\n    key: "_cut",\n    value: function _cut(event) {\n      var selection = this._getSelection();\n      if (selection) {\n        event.clipboardData.setData("text/plain", selection);\n        this._clearTextRange();\n        this.refresh();\n      }\n    }\n  }, {\n    key: "_paste",\n    value: function _paste(event) {\n      var pasteContent = (event.clipboardData || window.clipboardData).getData("text");\n      var flag = false;\n      this.dispatchEvent(new events(\'paste\', {\n        target: this,\n        content: pasteContent,\n        preventDefault: function preventDefault() {\n          flag = true;\n        },\n        resolvePasteContent: function resolvePasteContent(callback) {\n          pasteContent = callback(pasteContent);\n        }\n      }));\n      if (flag) {\n        return;\n      }\n      this._clearTextRange();\n      var offset = this._cursorOffset;\n      var content = this.content;\n      var preContent = content.substring(0, offset);\n      var afterContent = content.substring(offset);\n      this.content = preContent + pasteContent + afterContent;\n      this._cursorOffset = (preContent + pasteContent).length;\n      this.refresh();\n    }\n  }, {\n    key: "_defaultCallback",\n    value: function _defaultCallback(op, e) {\n      switch (op) {\n        case \'KeyDown\':\n          this.dispatchEvent(new events(\'keydown\', {\n            target: this,\n            key: e.key,\n            code: e.code,\n            rawEvent: e\n          }));\n          break;\n        case \'KeyUp\':\n          this.dispatchEvent(new events(\'keyup\', {\n            target: this,\n            key: e.key,\n            code: e.code,\n            rawEvent: e\n          }));\n          break;\n      }\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      if (this._jflow._focus.instance === this) {\n        this._jflow.blur();\n      }\n    }\n  }]);\n  return Text;\n}(rectangle);\n/* harmony default export */ const elements_text = (Text);\nfunction createInputElement(controlCallback, defaultCallback) {\n  var input = document.createElement(\'input\');\n  input.setAttribute(\'style\', "\\n        width: 100px;\\n        position: absolute;\\n        left: 0;\\n        top: 0;\\n        border:none;\\n        opacity: 0;\\n        z-index: -1;\\n        contain: strict;");\n  input.setAttribute(\'tabindex\', -1);\n  input.setAttribute(\'spellcheck\', false);\n  input.setAttribute(\'autocorrect\', \'off\');\n\n  // let content = configs.content;\n  // let startidx = 0;\n\n  // function renderContent() {\n  //     configs.callback(content)\n  // }\n  var stopInput = false;\n  var status = {\n    ctrlOn: false\n  };\n  input.addEventListener(\'beforeinput\', function (e) {\n    e.preventDefault();\n    if (e.data) {\n      // content += e.data;\n      // renderContent();\n      if (!stopInput) {\n        controlCallback(\'Input\', e.data);\n      }\n    }\n  });\n  input.addEventListener(\'compositionstart\', function (e) {\n    // cache composition start offset\n    // startidx = content.length;\n    controlCallback(\'compositionstart\');\n    stopInput = true;\n  });\n  input.addEventListener(\'compositionupdate\', function (e) {\n    // update content\n    // content = content.substring(0, startidx);\n    // content += e.data;\n    // renderContent();\n    controlCallback(\'compositionupdate\', e.data);\n  });\n  input.addEventListener(\'compositionend\', function (e) {\n    // replace text at start offset\n    // content = content.substring(0, startidx);\n    // startidx = 0;\n    // content += e.data;\n    // renderContent();\n    controlCallback(\'compositionend\', e.data);\n    input.value = \'\';\n    stopInput = false;\n  });\n  input.addEventListener(\'keyup\', function (event) {\n    switch (event.key) {\n      case "Shift":\n        controlCallback("Shift", false);\n        break;\n      case "Meta":\n      case "Control":\n        status.ctrlOn = false;\n        break;\n    }\n  });\n  input.addEventListener(\'keydown\', function (event) {\n    switch (event.code) {\n      case "Enter":\n        // content = content + \'\\n\';\n        // renderContent();\n        controlCallback(\'Enter\');\n        break;\n      case "Backspace":\n        // content = content.substring(0, content.length - 1);\n        // renderContent();\n        controlCallback(\'Backspace\');\n        break;\n      case "ArrowLeft":\n        controlCallback("ArrowLeft");\n        break;\n      case "ArrowRight":\n        controlCallback("ArrowRight");\n        break;\n      case "ArrowDown":\n        controlCallback("ArrowDown");\n        break;\n      case "ArrowUp":\n        controlCallback("ArrowUp");\n        break;\n    }\n    switch (event.key) {\n      case "Shift":\n        controlCallback("Shift", true);\n        break;\n      case "Meta":\n      case "Control":\n        status.ctrlOn = true;\n        break;\n      case \'a\':\n        if (status.ctrlOn) {\n          controlCallback(\'CtrlA\');\n        }\n        break;\n    }\n  });\n  input.addEventListener(\'keyup\', function (event) {\n    defaultCallback(\'KeyUp\', event);\n  });\n  input.addEventListener(\'keydown\', function (event) {\n    defaultCallback(\'KeyDown\', event);\n  });\n  input.addEventListener(\'copy\', function (event) {\n    event.preventDefault();\n    event.stopPropagation();\n    controlCallback(\'COPY\', null, event);\n  });\n  input.addEventListener(\'cut\', function (event) {\n    event.preventDefault();\n    event.stopPropagation();\n    controlCallback(\'CUT\', null, event);\n  });\n  input.addEventListener(\'paste\', function (event) {\n    event.preventDefault();\n    event.stopPropagation();\n    controlCallback(\'PASTE\', null, event);\n  });\n  return input;\n}\n;// CONCATENATED MODULE: ./src/core/instance/image.js\nfunction image_typeof(obj) { "@babel/helpers - typeof"; return image_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, image_typeof(obj); }\nfunction image_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction image_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, image_toPropertyKey(descriptor.key), descriptor); } }\nfunction image_createClass(Constructor, protoProps, staticProps) { if (protoProps) image_defineProperties(Constructor.prototype, protoProps); if (staticProps) image_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction image_toPropertyKey(arg) { var key = image_toPrimitive(arg, "string"); return image_typeof(key) === "symbol" ? key : String(key); }\nfunction image_toPrimitive(input, hint) { if (image_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (image_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction image_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) image_setPrototypeOf(subClass, superClass); }\nfunction image_setPrototypeOf(o, p) { image_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return image_setPrototypeOf(o, p); }\nfunction image_createSuper(Derived) { var hasNativeReflectConstruct = image_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = image_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = image_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return image_possibleConstructorReturn(this, result); }; }\nfunction image_possibleConstructorReturn(self, call) { if (call && (image_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return image_assertThisInitialized(self); }\nfunction image_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction image_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction image_getPrototypeOf(o) { image_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return image_getPrototypeOf(o); }\n\n\n\n\n\n\n/**\n * @typedef {Object} Icon~ImageBounding\n * @property {number} width   - 图片宽度\n * @property {number} height   - 图片高度 \n */\n/**\n * 图片单元 配置\n * @typedef {Rectangle~RectangleConfigs} Icon~IconConfigs\n * @property {number} image   - 图片地址\n * @property {number} imageWidth   - 图片宽度\n * @property {number} imageHeight   - 图片高度\n */\n\n/**\n * 图片单元\n * @description 图片单元可以绘制图片，图片加载后会自动重新绘制\n * @constructor Icon\n * @extends Rectangle\n * @param {Icon~IconConfigs} configs - 配置\n */\nvar Icon = /*#__PURE__*/function (_Rectangle) {\n  image_inherits(Icon, _Rectangle);\n  var _super = image_createSuper(Icon);\n  function Icon(configs) {\n    var _this;\n    image_classCallCheck(this, Icon);\n    _this = _super.call(this, configs);\n    /** @member {CanvasImageSource}      - 图片 */\n    _this.image = configs.image;\n    _this.image.onload = function () {\n      _this._jflow._render();\n      // requestAnimationFrame(() => {\n\n      // })\n    };\n    /** @member {Icon~ImageBounding}      - 图片维度 */\n    _this.imageBounding = {\n      width: configs.imageWidth || configs.width,\n      height: configs.imageHeight || configs.height\n    };\n    return _this;\n  }\n  image_createClass(Icon, [{\n    key: "setConfig",\n    value: function setConfig(configs) {\n      var _this2 = this;\n      Object.keys(configs).forEach(function (k) {\n        if (configs[k] !== undefined && configs[k] !== null) {\n          _this2[k] = configs[k];\n          _this2._rawConfigs[k] = configs[k];\n        }\n      });\n      if (configs.image && !configs.image.complete) {\n        this.image.onload = function () {\n          _this2._jflow._render();\n          // requestAnimationFrame(() => {\n          //     this._jflow._render();\n          // })\n        };\n      }\n\n      this.imageBounding = {\n        width: configs.imageWidth || configs.width || this.imageBounding.width,\n        height: configs.imageHeight || configs.height || this.imageBounding.height\n      };\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      rectangle.prototype.render.call(this, ctx);\n      var x = this.anchor[0] - this.width / 2;\n      var y = this.anchor[1] - this.height / 2;\n      if (this.opacity < 1) {\n        ctx.globalAlpha = this.opacity;\n      }\n      if (this.image.complete) {\n        ctx.drawImage(this.image, x, y, this.imageBounding.width, this.imageBounding.height);\n      }\n      ctx.restore();\n    }\n  }]);\n  return Icon;\n}(rectangle);\n/* harmony default export */ const instance_image = (Icon);\n;// CONCATENATED MODULE: ./src/core/instance/shadowDom.js\nfunction shadowDom_typeof(obj) { "@babel/helpers - typeof"; return shadowDom_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, shadowDom_typeof(obj); }\nfunction shadowDom_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction shadowDom_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, shadowDom_toPropertyKey(descriptor.key), descriptor); } }\nfunction shadowDom_createClass(Constructor, protoProps, staticProps) { if (protoProps) shadowDom_defineProperties(Constructor.prototype, protoProps); if (staticProps) shadowDom_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction shadowDom_toPropertyKey(arg) { var key = shadowDom_toPrimitive(arg, "string"); return shadowDom_typeof(key) === "symbol" ? key : String(key); }\nfunction shadowDom_toPrimitive(input, hint) { if (shadowDom_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (shadowDom_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction shadowDom_get() { if (typeof Reflect !== "undefined" && Reflect.get) { shadowDom_get = Reflect.get.bind(); } else { shadowDom_get = function _get(target, property, receiver) { var base = shadowDom_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return shadowDom_get.apply(this, arguments); }\nfunction shadowDom_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = shadowDom_getPrototypeOf(object); if (object === null) break; } return object; }\nfunction shadowDom_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) shadowDom_setPrototypeOf(subClass, superClass); }\nfunction shadowDom_setPrototypeOf(o, p) { shadowDom_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return shadowDom_setPrototypeOf(o, p); }\nfunction shadowDom_createSuper(Derived) { var hasNativeReflectConstruct = shadowDom_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = shadowDom_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = shadowDom_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return shadowDom_possibleConstructorReturn(this, result); }; }\nfunction shadowDom_possibleConstructorReturn(self, call) { if (call && (shadowDom_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return shadowDom_assertThisInitialized(self); }\nfunction shadowDom_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction shadowDom_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction shadowDom_getPrototypeOf(o) { shadowDom_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return shadowDom_getPrototypeOf(o); }\n\n/**\n * @funtion domFactory\n * @param {Element} container - DOM容器\n */\n/**\n * DOM元素容器 配置\n * @typedef {Rectangle~Configs} ShadowDom~RectangleConfigs\n * @property {domFactory} createDocument - 宽\n */\n/**\n * DOM元素容器 内容可贴 DOM 元素，支持缩放平移\n * @constructor ShadowDom\n * @extends Rectangle\n * @param {ShadowDom~RectangleConfigs} configs\n */\nvar ShadowDom = /*#__PURE__*/function (_Rectangle) {\n  shadowDom_inherits(ShadowDom, _Rectangle);\n  var _super = shadowDom_createSuper(ShadowDom);\n  function ShadowDom(configs) {\n    var _this;\n    shadowDom_classCallCheck(this, ShadowDom);\n    _this = _super.call(this, configs);\n    _this.domFactory = configs.createDocument;\n    _this._dom = null;\n    return _this;\n  }\n  shadowDom_createClass(ShadowDom, [{\n    key: "getRealWorldPosition",\n    value: function getRealWorldPosition() {\n      var b = this.getBoundingRect();\n      return this.calculateToRealWorld(b.slice(0, 2));\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      var _this2 = this;\n      if (!this._dom && this.domFactory) {\n        requestAnimationFrame(function () {\n          if (!_this2._dom) {\n            var container = document.createElement(\'div\');\n            var pos = _this2.getRealWorldPosition();\n            var scale = _this2._jflow.scale;\n            container.setAttribute(\'style\', "\\n                        position: absolute;\\n                        width: ".concat(_this2.width, "px;\\n                        height: ").concat(_this2.height, "px;\\n                        transform-origin: left top;\\n                        top: 0;\\n                        left: 0;\\n                        transform: translate(").concat(pos[0], "px, ").concat(pos[1], "px) scale(").concat(scale, ");"));\n            _this2._dom = container;\n            _this2._jflow.DOMwrapper.appendChild(container);\n            _this2.domFactory(container);\n          }\n        });\n      } else {\n        var pos = this.getRealWorldPosition();\n        var scale = this._jflow.scale;\n        this._dom.style.transform = "translate(".concat(pos[0], "px, ").concat(pos[1], "px) scale(").concat(scale, ")");\n      }\n      shadowDom_get(shadowDom_getPrototypeOf(ShadowDom.prototype), "render", this).call(this, ctx);\n    }\n  }, {\n    key: "onEnterViewbox",\n    value: function onEnterViewbox() {\n      if (this._dom) {\n        this._dom.style.display = \'block\';\n      }\n    }\n  }, {\n    key: "onLeaveViewbox",\n    value: function onLeaveViewbox() {\n      if (this._dom) {\n        this._dom.style.display = \'none\';\n      }\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      if (this._dom) {\n        this._jflow.DOMwrapper.removeChild(this._dom);\n      }\n      shadowDom_get(shadowDom_getPrototypeOf(ShadowDom.prototype), "destroy", this).call(this);\n    }\n  }]);\n  return ShadowDom;\n}(rectangle);\n/* harmony default export */ const shadowDom = (ShadowDom);\n;// CONCATENATED MODULE: ./src/core/instance/link.js\nfunction link_typeof(obj) { "@babel/helpers - typeof"; return link_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, link_typeof(obj); }\nfunction link_slicedToArray(arr, i) { return link_arrayWithHoles(arr) || link_iterableToArrayLimit(arr, i) || link_unsupportedIterableToArray(arr, i) || link_nonIterableRest(); }\nfunction link_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction link_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return link_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return link_arrayLikeToArray(o, minLen); }\nfunction link_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction link_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction link_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction link_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction link_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, link_toPropertyKey(descriptor.key), descriptor); } }\nfunction link_createClass(Constructor, protoProps, staticProps) { if (protoProps) link_defineProperties(Constructor.prototype, protoProps); if (staticProps) link_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction link_toPropertyKey(arg) { var key = link_toPrimitive(arg, "string"); return link_typeof(key) === "symbol" ? key : String(key); }\nfunction link_toPrimitive(input, hint) { if (link_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (link_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction link_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) link_setPrototypeOf(subClass, superClass); }\nfunction link_setPrototypeOf(o, p) { link_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return link_setPrototypeOf(o, p); }\nfunction link_createSuper(Derived) { var hasNativeReflectConstruct = link_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = link_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = link_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return link_possibleConstructorReturn(this, result); }; }\nfunction link_possibleConstructorReturn(self, call) { if (call && (link_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return link_assertThisInitialized(self); }\nfunction link_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction link_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction link_getPrototypeOf(o) { link_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return link_getPrototypeOf(o); }\n\n\n\n/**\n * @typedef {BaseLink~Configs} Link~Configs\n * @property {Number} approximate   - 点击响应范围\n * @property {Number[]} lineDash    - 虚线数组\n * @property {Boolean} doubleLink   - 双向箭头\n * @property {String} fontFamily    - 连线上的文字字体\n * @property {Number} fontSize      - 连线上的文字大小\n * @property {String} content       - 连线上的文字\n */\n/**\n * 直线\n * @constructor Link\n * @extends BaseLink\n * @param {Link~Configs} configs - 配置\n */\nvar Link = /*#__PURE__*/function (_BaseLink) {\n  link_inherits(Link, _BaseLink);\n  var _super = link_createSuper(Link);\n  function Link(configs) {\n    var _this;\n    link_classCallCheck(this, Link);\n    _this = _super.call(this, configs);\n    _this.fontFamily = configs.fontFamily = \'-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Tahoma,Arial,Noto Sans,PingFang SC,Microsoft YaHei,Hiragino Sans GB,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji\';\n    _this.fontSize = configs.fontSize || \'12px\';\n    _this.content = configs.content || \'\';\n    _this.lineDash = configs.lineDash;\n    _this.approximate = configs.approximate || APPROXIMATE;\n    _this._cacheAngle = undefined;\n    _this._cachePoints = [];\n    _this._cacheBoundingbox = {\n      from: [],\n      to: []\n    };\n    return _this;\n  }\n  link_createClass(Link, [{\n    key: "_calculateAnchorPoints",\n    value: function _calculateAnchorPoints() {\n      var p0 = this.from.calculateIntersection(this.to.getCenter());\n      var p1 = this.to.calculateIntersection(this.from.getCenter());\n      this._cachePoints[0] = p0;\n      this._cachePoints[1] = p1;\n      var dx = p1[0] - p0[0];\n      var dy = p1[1] - p0[1];\n      var angle = Math.atan2(dy, dx);\n      this._cacheAngle = angle;\n    }\n  }, {\n    key: "isInViewBox",\n    value: function isInViewBox(br) {\n      var frombox = this.from.getBoundingRect();\n      var tobox = this.to.getBoundingRect();\n      var _box = this._cacheBoundingbox;\n      if (!compareBoundingbox(_box.from, frombox) || compareBoundingbox(_box.to, tobox)) {\n        copyBoundingbox(_box.from, frombox);\n        copyBoundingbox(_box.to, tobox);\n        this._calculateAnchorPoints();\n      }\n      return true;\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      var _this$_cachePoints = link_slicedToArray(this._cachePoints, 2),\n        p0 = _this$_cachePoints[0],\n        p1 = _this$_cachePoints[1];\n      var angle = this._cacheAngle;\n      var dx = p1[0] - p0[0];\n      var dy = p1[1] - p0[1];\n      ctx.fillStyle = ctx.strokeStyle = this.backgroundColor;\n      ctx.beginPath();\n      if (this.content) {\n        ctx.textAlign = \'center\';\n        ctx.font = "".concat(this.fontSize, " ").concat(this.fontFamily);\n        ctx.textBaseline = \'middle\';\n        var _ctx$measureText = ctx.measureText(this.content),\n          actualBoundingBoxLeft = _ctx$measureText.actualBoundingBoxLeft,\n          actualBoundingBoxRight = _ctx$measureText.actualBoundingBoxRight,\n          fontBoundingBoxAscent = _ctx$measureText.fontBoundingBoxAscent,\n          fontBoundingBoxDescent = _ctx$measureText.fontBoundingBoxDescent;\n        var x = dx / 2 + p0[0];\n        var y = dy / 2 + p0[1];\n        ctx.fillText(this.content, x, y);\n        var width = Math.abs(actualBoundingBoxLeft) + Math.abs(actualBoundingBoxRight) + 20;\n        var height = (Math.abs(fontBoundingBoxAscent) + Math.abs(fontBoundingBoxDescent)) * 1.5;\n        ctx.beginPath();\n        var region = new Path2D();\n        region.rect(x - width / 2, y - height / 2, width, height);\n        var rx = Math.min(p1[0], p0[0]) - 10;\n        var ry = Math.min(p1[1], p0[1]) - 10;\n        var rw = Math.abs(dx) + 20;\n        var rh = Math.abs(dy) + 20;\n        region.rect(rx, ry, rw, rh);\n        ctx.clip(region, "evenodd");\n      }\n      ctx.moveTo(p0[0], p0[1]);\n      ctx.lineTo(p1[0], p1[1]);\n      if (this.lineDash) {\n        ctx.save();\n        ctx.setLineDash(this.lineDash);\n      }\n      ctx.stroke();\n      if (this.lineDash) {\n        ctx.restore();\n      }\n      ctx.translate(p1[0], p1[1]);\n      ctx.rotate(angle);\n      ctx.moveTo(0, 0);\n      ctx.lineTo(-5, -4);\n      ctx.lineTo(-5, 4);\n      ctx.lineTo(0, 0);\n      ctx.fill();\n      ctx.rotate(-angle);\n      ctx.translate(-p1[0], -p1[1]);\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      if (!this._cachePoints) return false;\n      var _this$_cachePoints2 = link_slicedToArray(this._cachePoints, 2),\n        start = _this$_cachePoints2[0],\n        end = _this$_cachePoints2[1];\n      var dist = distToSegmentSquared(point, start, end);\n      return dist < this.approximate;\n    }\n  }]);\n  return Link;\n}(base_link);\n/* harmony default export */ const instance_link = (Link);\n;// CONCATENATED MODULE: ./src/core/instance/poly-link.js\nfunction poly_link_typeof(obj) { "@babel/helpers - typeof"; return poly_link_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, poly_link_typeof(obj); }\nfunction poly_link_defineProperty(obj, key, value) { key = poly_link_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction poly_link_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction poly_link_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, poly_link_toPropertyKey(descriptor.key), descriptor); } }\nfunction poly_link_createClass(Constructor, protoProps, staticProps) { if (protoProps) poly_link_defineProperties(Constructor.prototype, protoProps); if (staticProps) poly_link_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction poly_link_toPropertyKey(arg) { var key = poly_link_toPrimitive(arg, "string"); return poly_link_typeof(key) === "symbol" ? key : String(key); }\nfunction poly_link_toPrimitive(input, hint) { if (poly_link_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (poly_link_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction poly_link_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) poly_link_setPrototypeOf(subClass, superClass); }\nfunction poly_link_setPrototypeOf(o, p) { poly_link_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return poly_link_setPrototypeOf(o, p); }\nfunction poly_link_createSuper(Derived) { var hasNativeReflectConstruct = poly_link_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = poly_link_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = poly_link_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return poly_link_possibleConstructorReturn(this, result); }; }\nfunction poly_link_possibleConstructorReturn(self, call) { if (call && (poly_link_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return poly_link_assertThisInitialized(self); }\nfunction poly_link_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction poly_link_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction poly_link_getPrototypeOf(o) { poly_link_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return poly_link_getPrototypeOf(o); }\n\n\n\n// import { dist2, bezierPoint } from \'../utils/functions\';\nvar PIINRATIO = Math.PI / 180;\n/**\n * @typedef {BaseLink~Configs} PolyLink~Configs\n * @property {Number} approximate   - 点击响应范围\n * @property {Number} radius        - 拐角弧度\n * @property {Number} minSpanX      - 起点终点在 x 方向最小的跨度\n * @property {Number} minSpanY      - 起点终点在 y 方向最小的跨度\n * @property {number[]} lineDash    - 虚线数组\n * @property {Boolean} doubleLink   - 双向箭头\n * @property {String} fontFamily    - 连线上的文字字体\n * @property {Number} fontSize      - 连线上的文字大小\n * @property {String} content       - 连线上的文字\n * @property {String} isSelf        - 是否为自连接\n */\n/**\n * 方形折线\n * @constructor PolyLink\n * @extends BaseLink\n * @param {PolyLink~Configs} configs - 配置\n */\nvar PolyLink = /*#__PURE__*/function (_BaseLink) {\n  poly_link_inherits(PolyLink, _BaseLink);\n  var _super = poly_link_createSuper(PolyLink);\n  /**\n  * 创建方形折线\n  * @param {PolyLink~Configs} configs - 配置\n  **/\n  function PolyLink(configs) {\n    var _this;\n    poly_link_classCallCheck(this, PolyLink);\n    _this = _super.call(this, configs);\n    /** @member {Number}   - 点击响应范围 */\n    _this.approximate = configs.approximate || APPROXIMATE;\n    /** @member {Number}   - 拐角弧度 */\n    _this.radius = configs.radius || 0;\n    /** @member {Number}   - 起点终点在 x 方向最小的跨度 */\n    _this.minSpanX = configs.minSpanX || 10;\n    /** @member {Number}   - 起点终点在 y 方向最小的跨度 */\n    _this.minSpanY = configs.minSpanY || 10;\n    /** @member {Number}    - 虚线数组 */\n    _this.lineDash = configs.lineDash;\n    /** @member {Number}    - 双向箭头 */\n    _this.doubleLink = configs.doubleLink;\n    /** @member {Number}    - 连线上的文字字体 */\n    _this.fontFamily = configs.fontFamily = \'-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Tahoma,Arial,Noto Sans,PingFang SC,Microsoft YaHei,Hiragino Sans GB,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji\';\n    /** @member {Number}    - 连线上的文字大小 */\n    _this.fontSize = configs.fontSize || \'12px\';\n    /** @member {Number}    - 连线上的文字 */\n    _this.content = configs.content || \'\';\n    /** @member {Number}    - 是否为自连接 */\n    _this.isSelf = !!configs.isSelf;\n    _this.noArrow = !!configs.noArrow;\n    _this._cacheAngle = [];\n    _this._cachePoints = [];\n    _this._cacheBoundingbox = {\n      from: [],\n      to: []\n    };\n    return _this;\n  }\n  poly_link_createClass(PolyLink, [{\n    key: "_calculateAnchorPoints",\n    value: function _calculateAnchorPoints() {\n      var dmsfrom = this.from.getIntersectionsInFourDimension();\n      var dmsto = this.to.getIntersectionsInFourDimension();\n      var _cacheAngle = this._cacheAngle;\n      if (this.isSelf) {\n        polylinePoints(this._cachePoints, dmsfrom[this.fromDir], dmsto[DIRECTION.SELF], this.fromDir, this.toDir, this.minSpanX, this.minSpanY, true);\n        _cacheAngle[0] = this.fromDir;\n        _cacheAngle[1] = this.toDir;\n      } else if (this.fromDir !== undefined && this.toDir !== undefined) {\n        polylinePoints(this._cachePoints, dmsfrom[this.fromDir], dmsto[this.toDir], this.fromDir, this.toDir, this.minSpanX, this.minSpanY);\n        _cacheAngle[0] = this.fromDir;\n        _cacheAngle[1] = this.toDir;\n      } else {\n        var meta = minIntersectionBetweenNodes(dmsfrom, dmsto);\n        polylinePoints(this._cachePoints, meta.fromP, meta.toP, meta.fromDir, meta.toDir, this.minSpanX, this.minSpanY);\n        _cacheAngle[0] = meta.fromDir;\n        _cacheAngle[1] = meta.toDir;\n      }\n    }\n  }, {\n    key: "isInViewBox",\n    value: function isInViewBox(br) {\n      if (this._static) {\n        return true;\n      }\n      this._calculateAnchorPoints();\n      return isPolyLineIntersectionRectange(this._cachePoints, br);\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      var _this2 = this;\n      // this._calculateAnchorPoints();\n      var radius = this.radius;\n      var points = this._cachePoints;\n      var p = points[0];\n      var pEnd = points[points.length - 1];\n      var angleEnd = (this._cacheAngle[1] + 2) % 4 * 90 * PIINRATIO;\n      ctx.fillStyle = ctx.strokeStyle = this.backgroundColor;\n      if (this.doubleLink) {\n        var beginAngle = (this._cacheAngle[0] + 2) % 4 * 90 * PIINRATIO;\n        ctx.beginPath();\n        ctx.translate(p[0], p[1]);\n        ctx.rotate(beginAngle);\n        ctx.moveTo(5, 0);\n        ctx.lineTo(0, -4);\n        ctx.lineTo(0, 4);\n        ctx.lineTo(5, 0);\n        ctx.fill();\n        ctx.rotate(-beginAngle);\n        ctx.translate(-p[0], -p[1]);\n      }\n      ctx.beginPath();\n      ctx.moveTo(p[0], p[1]);\n      points.slice(1, points.length - 1).forEach(function (p, idx) {\n        if (_this2.radius) {\n          var pLast = points[idx];\n          var pNext = points[idx + 2];\n          var _makeRadiusFromVector = makeRadiusFromVector(pLast, p, pNext, radius),\n            p1 = _makeRadiusFromVector.p1,\n            p2 = _makeRadiusFromVector.p2;\n          if (p1 && p2) {\n            ctx.lineTo(p1[0], p1[1]);\n            ctx.quadraticCurveTo(p[0], p[1], p2[0], p2[1]);\n          } else {\n            ctx.lineTo(p[0], p[1]);\n          }\n        } else {\n          ctx.lineTo(p[0], p[1]);\n        }\n      });\n      ctx.lineTo(pEnd[0], pEnd[1]);\n      if (this.lineDash) {\n        ctx.save();\n        ctx.setLineDash(this.lineDash);\n      }\n      ctx.stroke();\n      if (this.lineDash) {\n        ctx.restore();\n      }\n      if (!this.noArrow) {\n        ctx.beginPath();\n        ctx.translate(pEnd[0], pEnd[1]);\n        ctx.rotate(angleEnd);\n        ctx.moveTo(0, 0);\n        ctx.lineTo(-5, -4);\n        ctx.lineTo(-5, 4);\n        ctx.lineTo(0, 0);\n        ctx.fill();\n        ctx.rotate(-angleEnd);\n        ctx.translate(-pEnd[0], -pEnd[1]);\n      }\n      if (this.content) {\n        ctx.beginPath();\n        ctx.font = "".concat(this.fontSize, " ").concat(this.fontFamily);\n        switch (this.fromDir) {\n          case DIRECTION.BOTTOM:\n            ctx.textAlign = \'left\';\n            ctx.fillText(this.content, p[0] + 2, p[1] + 10);\n            break;\n          case DIRECTION.RIGHT:\n            ctx.textAlign = \'left\';\n            ctx.fillText(this.content, p[0] + 10, p[1] - 2);\n            break;\n          default:\n            break;\n        }\n      }\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      if (this._static) {\n        return false;\n      }\n      if (!this._cachePoints) {\n        return false;\n      }\n      var points = this._cachePoints;\n      var lastP = points[0];\n      var remainPoints = points.slice(1);\n      do {\n        var currentP = remainPoints.shift();\n        if (currentP) {\n          var dist = distToSegmentSquared(point, lastP, currentP);\n          if (dist < this.approximate) {\n            return true;\n          }\n        }\n        lastP = currentP;\n      } while (lastP);\n      return false;\n    }\n  }, {\n    key: "cloneStatic",\n    value: function cloneStatic() {\n      var _Object$assign;\n      var t = new PolyLink({});\n      Object.assign(t, (_Object$assign = {\n        radius: this.radius,\n        _cachePoints: this._cachePoints,\n        _cacheAngle: this._cacheAngle,\n        backgroundColor: this.backgroundColor,\n        doubleLink: this.doubleLink\n      }, poly_link_defineProperty(_Object$assign, "radius", this.radius), poly_link_defineProperty(_Object$assign, "lineDash", this.lineDash), poly_link_defineProperty(_Object$assign, "noArrow", this.noArrow), poly_link_defineProperty(_Object$assign, "content", this.content), poly_link_defineProperty(_Object$assign, "fontSize", this.fontSize), poly_link_defineProperty(_Object$assign, "fontFamily", this.fontFamily), poly_link_defineProperty(_Object$assign, "fromDir", this.fromDir), poly_link_defineProperty(_Object$assign, "_static", true), _Object$assign));\n      return t;\n    }\n  }]);\n  return PolyLink;\n}(base_link);\n/* harmony default export */ const poly_link = (PolyLink);\n;// CONCATENATED MODULE: ./src/core/instance/bezier-link.js\nfunction bezier_link_typeof(obj) { "@babel/helpers - typeof"; return bezier_link_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, bezier_link_typeof(obj); }\nfunction bezier_link_slicedToArray(arr, i) { return bezier_link_arrayWithHoles(arr) || bezier_link_iterableToArrayLimit(arr, i) || bezier_link_unsupportedIterableToArray(arr, i) || bezier_link_nonIterableRest(); }\nfunction bezier_link_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction bezier_link_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction bezier_link_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction bezier_link_toConsumableArray(arr) { return bezier_link_arrayWithoutHoles(arr) || bezier_link_iterableToArray(arr) || bezier_link_unsupportedIterableToArray(arr) || bezier_link_nonIterableSpread(); }\nfunction bezier_link_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction bezier_link_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return bezier_link_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return bezier_link_arrayLikeToArray(o, minLen); }\nfunction bezier_link_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\nfunction bezier_link_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return bezier_link_arrayLikeToArray(arr); }\nfunction bezier_link_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction bezier_link_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction bezier_link_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, bezier_link_toPropertyKey(descriptor.key), descriptor); } }\nfunction bezier_link_createClass(Constructor, protoProps, staticProps) { if (protoProps) bezier_link_defineProperties(Constructor.prototype, protoProps); if (staticProps) bezier_link_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction bezier_link_toPropertyKey(arg) { var key = bezier_link_toPrimitive(arg, "string"); return bezier_link_typeof(key) === "symbol" ? key : String(key); }\nfunction bezier_link_toPrimitive(input, hint) { if (bezier_link_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (bezier_link_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction bezier_link_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) bezier_link_setPrototypeOf(subClass, superClass); }\nfunction bezier_link_setPrototypeOf(o, p) { bezier_link_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return bezier_link_setPrototypeOf(o, p); }\nfunction bezier_link_createSuper(Derived) { var hasNativeReflectConstruct = bezier_link_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = bezier_link_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = bezier_link_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return bezier_link_possibleConstructorReturn(this, result); }; }\nfunction bezier_link_possibleConstructorReturn(self, call) { if (call && (bezier_link_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return bezier_link_assertThisInitialized(self); }\nfunction bezier_link_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction bezier_link_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction bezier_link_getPrototypeOf(o) { bezier_link_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return bezier_link_getPrototypeOf(o); }\n\n\n\n\nvar bezier_link_PIINRATIO = Math.PI / 180;\n/**\n * @typedef {BaseLink~Configs} BezierLink~Configs\n * @property {Number} approximate   - 点击响应范围\n * @property {Number} minSpanX      - 起点终点在 x 方向最小的跨度\n * @property {Number} minSpanY      - 起点终点在 y 方向最小的跨度\n * @property {Number[]} lineDash    - 虚线数组\n * @property {Boolean} doubleLink   - 双向箭头\n * @property {String} fontFamily    - 连线上的文字字体\n * @property {Number} fontSize      - 连线上的文字大小\n * @property {String} content       - 连线上的文字\n * @property {Boolean} isSelf        - 是否为自连接\n */\n/**\n * 贝塞尔曲线\n * @constructor BezierLink\n * @extends BaseLink\n * @param {BezierLink~Configs} configs - 配置\n */\nvar BezierLink = /*#__PURE__*/function (_BaseLink) {\n  bezier_link_inherits(BezierLink, _BaseLink);\n  var _super = bezier_link_createSuper(BezierLink);\n  /**\n  * 创建贝塞尔曲线.\n  * @param {BezierLink~Configs} configs - 配置\n  **/\n  function BezierLink(configs) {\n    var _this;\n    bezier_link_classCallCheck(this, BezierLink);\n    _this = _super.call(this, configs);\n    /** @member {Number}      - 点击响应范围 */\n    _this.approximate = configs.approximate || APPROXIMATE;\n    /** @member {Number}      - 起点终点在 x 方向最小的跨度 */\n    _this.minSpanX = configs.minSpanX || 0;\n    /** @member {Number}      - 起点终点在 y 方向最小的跨度 */\n    _this.minSpanY = configs.minSpanY || 0;\n    /** @member {Number[]}      - 虚线数组 */\n    _this.lineDash = configs.lineDash;\n    _this.lineWidth = configs.lineWidth || 1;\n    /** @member {Boolean}      - 双向箭头 */\n    _this.doubleLink = configs.doubleLink;\n    /** @member {String}      - 连线上的文字字体 */\n    _this.fontFamily = configs.fontFamily = \'-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Tahoma,Arial,Noto Sans,PingFang SC,Microsoft YaHei,Hiragino Sans GB,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji\';\n    /** @member {Number}      - 连线上的文字大小 */\n    _this.fontSize = configs.fontSize || \'12px\';\n    /** @member {String}      - 连线上的文字 */\n    _this.content = configs.content || \'\';\n    /** @member {Boolean}      - 是否为自连接 */\n    _this.isSelf = !!configs.isSelf;\n    return _this;\n  }\n\n  // getColor() {\n  //     if(this._isTargeting) {\n  //         return this.hoverStyle;\n  //     }\n  //     return this.defaultStyle;\n  // }\n\n  // _calculateAnchorPoints() {\n  //     let start;\n  //     let end;\n  //     if(this.fromDir !== undefined) {\n  //         start = {\n  //             dir: this.fromDir,\n  //             p: this.from.getIntersectionsInFourDimension()[this.fromDir],\n  //         }\n  //     } else {\n  //         start = this.from.calculateIntersectionInFourDimension(this.to.getCenter(), \'from\');\n  //     }\n  //     if(this.toDir !== undefined) {\n  //         end = {\n  //             dir: this.toDir,\n  //             p: this.to.getIntersectionsInFourDimension()[this.toDir],\n  //         }\n  //     } else {\n  //         end = this.to.calculateIntersectionInFourDimension(this.from.getCenter(), \'to\');\n  //     }\n\n  //     // const start = this.from.calculateIntersectionInFourDimension(this.to.getCenter(), \'from\');\n  //     // const end = this.to.calculateIntersectionInFourDimension(this.from.getCenter(), \'to\');\n  //     const p1 = start.p;\n  //     const p2 = end.p;\n  //     const points = bezierPoints(p1, p2, start.dir, end.dir, this.anticlock);\n\n  //     this._cachePoints = [...p1, ...points]\n  // }\n  bezier_link_createClass(BezierLink, [{\n    key: "_calculateAnchorPoints",\n    value: function _calculateAnchorPoints() {\n      var dmsfrom = this.from.getIntersectionsInFourDimension();\n      var dmsto = this.to.getIntersectionsInFourDimension();\n      if (this.isSelf) {\n        var points = bezierPoints(dmsfrom[this.fromDir], dmsto[DIRECTION.SELF], this.fromDir, DIRECTION.BOTTOM, this.minSpanX, this.minSpanY);\n        this._cachePoints = [].concat(bezier_link_toConsumableArray(dmsfrom[this.fromDir]), bezier_link_toConsumableArray(points));\n        this._cacheAngle = [this.fromDir, DIRECTION.BOTTOM];\n      } else if (this.fromDir !== undefined && this.toDir !== undefined) {\n        var _points = bezierPoints(dmsfrom[this.fromDir], dmsto[this.toDir], this.fromDir, this.toDir, this.minSpanX, this.minSpanY);\n        this._cachePoints = [].concat(bezier_link_toConsumableArray(dmsfrom[this.fromDir]), bezier_link_toConsumableArray(_points));\n        this._cacheAngle = [this.fromDir, this.toDir];\n      } else {\n        var meta = minIntersectionBetweenNodes(dmsfrom, dmsto);\n        var _points2 = bezierPoints(meta.fromP, meta.toP, meta.fromDir, meta.toDir);\n        this._cachePoints = [].concat(bezier_link_toConsumableArray(meta.fromP), bezier_link_toConsumableArray(_points2));\n        this._cacheAngle = [meta.fromDir, meta.toDir];\n      }\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      this._calculateAnchorPoints();\n      var points = this._cachePoints;\n      var angle = getBezierAngle.apply(null, [1].concat(bezier_link_toConsumableArray(points)));\n      ctx.fillStyle = ctx.strokeStyle = this.backgroundColor;\n      ctx.lineWidth = this.lineWidth;\n      if (this.doubleLink) {\n        var beginAngle = (this._cacheAngle[0] + 2) % 4 * 90 * bezier_link_PIINRATIO;\n        ctx.beginPath();\n        ctx.translate(points[0], points[1]);\n        ctx.rotate(beginAngle);\n        ctx.moveTo(5, 0);\n        ctx.lineTo(0, -4);\n        ctx.lineTo(0, 4);\n        ctx.lineTo(5, 0);\n        ctx.fill();\n        ctx.rotate(-beginAngle);\n        ctx.translate(-points[0], -points[1]);\n      }\n      ctx.beginPath();\n      ctx.moveTo(points[0], points[1]);\n      ctx.bezierCurveTo.apply(ctx, bezier_link_toConsumableArray(points.slice(2)));\n      if (this.lineDash) {\n        ctx.save();\n        ctx.setLineDash(this.lineDash);\n      }\n      ctx.stroke();\n      if (this.lineDash) {\n        ctx.restore();\n      }\n      ctx.beginPath();\n      ctx.translate(points[6], points[7]);\n      ctx.rotate(angle);\n      ctx.moveTo(5, 0);\n      ctx.lineTo(0, -4);\n      ctx.lineTo(0, 4);\n      ctx.lineTo(5, 0);\n      ctx.fill();\n      ctx.rotate(-angle);\n      ctx.translate(-points[6], -points[7]);\n      if (this.content) {\n        ctx.beginPath();\n        var hasFlip = points[0] > points[6];\n        var _bezierPoint = bezierPoint(0.5, points),\n          _bezierPoint2 = bezier_link_slicedToArray(_bezierPoint, 3),\n          x = _bezierPoint2[0],\n          y = _bezierPoint2[1],\n          _angle = _bezierPoint2[2];\n        ctx.translate(x, y);\n        ctx.rotate(_angle);\n        if (hasFlip) {\n          ctx.rotate(Math.PI);\n        }\n        ctx.font = "".concat(this.fontSize, " ").concat(this.fontFamily);\n        ctx.textAlign = \'center\';\n        ctx.fillText(this.content, 0, -(parseInt(this.fontSize) || 12) / 4);\n        if (hasFlip) {\n          ctx.rotate(Math.PI);\n        }\n        ctx.rotate(-_angle);\n        ctx.translate(-x, -y);\n      }\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      if (!this._cachePoints) return false;\n      var points = this._cachePoints;\n      var dist = distToBezierSegmentSquared(point, points);\n      return dist < this.approximate;\n    }\n  }]);\n  return BezierLink;\n}(base_link);\n/* harmony default export */ const bezier_link = (BezierLink);\n;// CONCATENATED MODULE: ./src/core/layout/linear-layout.js\nfunction linear_layout_typeof(obj) { "@babel/helpers - typeof"; return linear_layout_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, linear_layout_typeof(obj); }\nfunction linear_layout_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction linear_layout_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, linear_layout_toPropertyKey(descriptor.key), descriptor); } }\nfunction linear_layout_createClass(Constructor, protoProps, staticProps) { if (protoProps) linear_layout_defineProperties(Constructor.prototype, protoProps); if (staticProps) linear_layout_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction linear_layout_toPropertyKey(arg) { var key = linear_layout_toPrimitive(arg, "string"); return linear_layout_typeof(key) === "symbol" ? key : String(key); }\nfunction linear_layout_toPrimitive(input, hint) { if (linear_layout_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (linear_layout_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n/**\n * 线性布局配置\n * @typedef {Object} LinearLayout~Configs\n * @property {string} direction     - 排列方向 默认 vertical\n * @property {number} gap           - 边距, 默认是 5\n * @property {string} alignment     - 垂直排列方向对齐方式 默认 center\n * @property {string} justify       - 排列方向对齐方式 默认 center\n */\n/**\n    线性布局\n\n    排列方向\n    direction:\n        + vertical 从上至下排布\n        + horizontal 从左至右排布\n    \n    不重叠，中线对齐\n    只针对当前的 group\n\n    对齐方式\n    alignment: \n        + start 主轴左侧对齐\n        + center 主轴对齐\n        + end   主轴右侧对齐\n    justify: \n        + start 开始时对齐\n        + center 居中对齐\n        + end   末尾对齐\n        + space-between 平均分配空间对齐\n\n * @constructor LinearLayout\n * @implements {Layout}\n * @param {LinearLayout~Configs} configs - 配置\n */\nvar LinearLayout = /*#__PURE__*/function () {\n  function LinearLayout() {\n    var _configs$gap;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    linear_layout_classCallCheck(this, LinearLayout);\n    /** @member {string}  - 排列方向 默认 vertical */\n    this.direction = configs.direction || \'vertical\';\n    /** @member {number}  - 边距, 默认是 5 */\n    this.gap = (_configs$gap = configs.gap) !== null && _configs$gap !== void 0 ? _configs$gap : 5;\n    /** @member {string}  - 垂直排列方向对齐方式 默认 center */\n    this.alignment = configs.alignment || \'center\';\n    /** @member {string}  - 排列方向对齐方式 默认 center */\n    this.justify = configs.justify || \'center\';\n    // this.widthSetByParent =  configs.width === \'100%\'\n    this._rawConfigs = configs;\n  }\n  linear_layout_createClass(LinearLayout, [{\n    key: "reflow",\n    value: function reflow(group) {\n      var _this = this;\n      var stack = group._stack.filter(function (instance) {\n        return instance.visible && !instance.absolutePosition;\n      });\n      var absoluteStack = group._stack.filter(function (instance) {\n        return instance.visible && instance.absolutePosition;\n      });\n      var groupWidth = group.width - group.padding.left - group.padding.right;\n      if (this.direction === \'vertical\') {\n        var reduceHeight = 0;\n        var lastInstanceHeight = 0;\n        var maxWidth = 0;\n        var allHeight = 0;\n        var childAll = stack.concat(absoluteStack);\n        childAll.forEach(function (instance, idx) {\n          if (instance.display === \'block\') {\n            instance.width = 0;\n            // instance.definedWidth = maxWidth;\n            instance.resetChildrenPosition();\n            instance.reflow();\n            instance._getBoundingGroupRect();\n          }\n        });\n        stack.forEach(function (instance, idx) {\n          var _instance$getBounding = instance.getBoundingDimension(),\n            width = _instance$getBounding.width,\n            height = _instance$getBounding.height;\n          // console.log(height, instance.type);\n          var gap = idx > 0 ? _this.gap : 0;\n          if (instance.display !== \'outstretch\') {\n            maxWidth = Math.max(width, maxWidth);\n          }\n          allHeight += height + gap;\n          reduceHeight += height / 2 + gap + lastInstanceHeight;\n          lastInstanceHeight = height / 2;\n          instance.anchor = [0, reduceHeight];\n        });\n        childAll.forEach(function (instance, idx) {\n          if (instance.display === \'block\') {\n            // instance.definedWidth = maxWidth;\n            instance.resetChildrenPosition();\n            instance.width = maxWidth;\n            instance.reflow();\n            // instance._getBoundingGroupRect();\n          } else if (instance.display === \'outstretch\') {\n            var w = group._belongs.width - group._belongs.padding.left - group._belongs.padding.right;\n            instance.resetChildrenPosition();\n            instance.width = Math.max(w, maxWidth);\n            instance.reflow();\n          }\n        });\n        maxWidth = Math.max(groupWidth, maxWidth);\n        allHeight = allHeight / 2;\n        if (this.alignment === \'start\') {\n          stack.forEach(function (instance, idx) {\n            var _instance$getBounding2 = instance.getBoundingDimension(),\n              width = _instance$getBounding2.width;\n            instance.anchor[0] = -(maxWidth - width) / 2;\n            instance.anchor[1] -= allHeight;\n            // console.log(maxWidth, width, instance.anchor[0])\n          });\n        }\n\n        if (this.alignment === \'end\') {\n          stack.forEach(function (instance, idx) {\n            var _instance$getBounding3 = instance.getBoundingDimension(),\n              width = _instance$getBounding3.width;\n            instance.anchor[0] = (maxWidth - width) / 2;\n            instance.anchor[1] -= allHeight;\n          });\n        }\n        if (this.alignment === \'center\') {\n          stack.forEach(function (instance, idx) {\n            var _instance$getBounding4 = instance.getBoundingDimension(),\n              width = _instance$getBounding4.width;\n            instance.anchor[1] -= allHeight;\n          });\n        }\n      }\n      if (this.direction === \'horizontal\') {\n        var reduceWidth = 0;\n        var lastInstanceWidth = 0;\n        var maxHeight = 0;\n        var allWidth = 0;\n        var allPureWidth = 0;\n        stack.forEach(function (instance, idx) {\n          var _instance$getBounding5 = instance.getBoundingDimension(),\n            width = _instance$getBounding5.width,\n            height = _instance$getBounding5.height;\n          var gap = idx > 0 ? _this.gap : 0;\n          maxHeight = Math.max(height, maxHeight);\n          allWidth += width + gap;\n          allPureWidth += width;\n          reduceWidth += width / 2 + gap + lastInstanceWidth;\n          lastInstanceWidth = width / 2;\n          instance.anchor = [reduceWidth, 0];\n        });\n        if (this.justify === \'start\') {\n          var withdraw = groupWidth / 2;\n          stack.forEach(function (instance, idx) {\n            instance.anchor[0] -= withdraw;\n          });\n        }\n        if (this.justify === \'end\') {\n          var _withdraw = groupWidth / 2 - allWidth;\n          stack.forEach(function (instance, idx) {\n            instance.anchor[0] += _withdraw;\n          });\n        }\n        if (this.justify === \'center\') {\n          var _withdraw2 = allWidth / 2;\n          stack.forEach(function (instance, idx) {\n            instance.anchor[0] -= _withdraw2;\n          });\n        }\n        if (this.justify === \'space-between\' && stack.length > 1) {\n          var width = Math.max(groupWidth, allWidth);\n          var gapAverage = (width - allWidth) / (stack.length - 1);\n          var _withdraw3 = width / 2;\n          stack.forEach(function (instance, idx) {\n            instance.anchor[0] += gapAverage * idx - _withdraw3;\n          });\n        }\n        if (this.alignment === \'start\') {\n          stack.forEach(function (instance, idx) {\n            var _instance$getBounding6 = instance.getBoundingDimension(),\n              height = _instance$getBounding6.height;\n            instance.anchor[1] = -(maxHeight - height) / 2;\n          });\n        }\n        if (this.alignment === \'end\') {\n          stack.forEach(function (instance, idx) {\n            var _instance$getBounding7 = instance.getBoundingDimension(),\n              height = _instance$getBounding7.height;\n            instance.anchor[1] = (maxHeight - height) / 2;\n          });\n        }\n      }\n      if (absoluteStack.length) {\n        if (group.display === \'block\') {\n          group.getBoundingDimension();\n        } else {\n          group._getBoundingGroupRect();\n        }\n        var WIDTH = group.width / 2;\n        var HEIGHT = group.height / 2;\n        var shifty = (group.padding.top - group.padding.bottom) / 2;\n        var shiftx = (group.padding.left - group.padding.right) / 2;\n        absoluteStack.forEach(function (instance) {\n          instance.anchor = _this._resolveAbsoluteAnchor(instance.absolutePosition, instance, WIDTH, HEIGHT, shiftx, shifty);\n        });\n      }\n    }\n  }, {\n    key: "_resolveAbsoluteAnchor",\n    value: function _resolveAbsoluteAnchor(config, instance, w, h, shiftx, shifty) {\n      var top = config.top,\n        right = config.right,\n        bottom = config.bottom,\n        left = config.left,\n        centerX = config.centerX,\n        centerY = config.centerY;\n      var _instance$getBounding8 = instance.getBoundingDimension(),\n        width = _instance$getBounding8.width,\n        height = _instance$getBounding8.height;\n      var hw = width / 2;\n      var hh = height / 2;\n      var y = 0;\n      var x = 0;\n      if (typeof top === \'number\') {\n        y = top + hh - h - shifty;\n      }\n      if (typeof right === \'number\') {\n        x = w - right - hw - shiftx;\n      }\n      if (typeof bottom === \'number\') {\n        y = h - bottom - hh - shifty;\n      }\n      if (typeof left === \'number\') {\n        x = left + hw - w - shiftx;\n      }\n      if (typeof centerX === \'number\') {\n        x = centerX;\n      }\n      if (typeof centerY === \'number\') {\n        y = centerY;\n      }\n      return [x, y];\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new LinearLayout(this._rawConfigs);\n    }\n  }]);\n  return LinearLayout;\n}();\n/* harmony default export */ const linear_layout = (LinearLayout);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/base/constants.js\nvar EDITOR_EVENTS = {\n  INPUT: \'input\',\n  CONTROL_CMD: \'control\'\n};\nvar KEYBOARD_INPUT = {\n  INPUT: \'input\',\n  COMPOSITION_START: \'compositionstart\',\n  COMPOSITION_UPDATE: \'compositionupdate\',\n  COMPOSITION_END: \'compositionend\',\n  ENTER: \'enter\',\n  DELETE: \'delete\',\n  BACKSPACE: \'backspace\'\n};\nvar KEYBOARD_COMMANDS = {\n  ARROW_LEFT: \'arrowLeft\',\n  ARROW_RIGHT: \'arrowRight\',\n  ARROW_UP: \'arrowUp\',\n  ARROW_DOWN: \'arrowDown\',\n  UNDO: \'undo\',\n  REDO: \'redo\',\n  SHIFT_DOWN: \'shift_down\',\n  SHIFT_UP: \'shift_up\',\n  CTRLA: \'ctrla\',\n  COPY: \'copy\',\n  CUT: \'cut\',\n  PASTE: \'paste\'\n};\nvar MOUSE_COMMANDS = {\n  START_EDIT: \'startedit\',\n  EDIT_CLICK: \'editclick\',\n  SHIFT_ON_CLICK: \'shiftonclick\',\n  DOUBLE_CLICK: \'doubleclick\'\n};\nvar OPERRATION = {\n  PLAININPUT: \'plaininput\',\n  SPACEINPUT: \'spaceinput\',\n  RETURNINPUT: \'returninput\',\n  CARETMOVEMENT: \'caretmovement\',\n  DELETE_IN_LINE: \'deleteinline\',\n  DELETE_IN_EDITAREA: \'deleteineditarea\',\n  ENSURE_DELETE: \'ensuredelete\',\n  SELECTION_DELETE: \'selectiondelete\',\n  SELECTION_INPUT: \'selectioninput\',\n  COMPOSITE_INSERT: \'compositeinsert\'\n};\n;// CONCATENATED MODULE: ./src/core/instance/text-group/base/shadow-input.js\nfunction shadow_input_typeof(obj) { "@babel/helpers - typeof"; return shadow_input_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, shadow_input_typeof(obj); }\nfunction shadow_input_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction shadow_input_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, shadow_input_toPropertyKey(descriptor.key), descriptor); } }\nfunction shadow_input_createClass(Constructor, protoProps, staticProps) { if (protoProps) shadow_input_defineProperties(Constructor.prototype, protoProps); if (staticProps) shadow_input_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction shadow_input_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) shadow_input_setPrototypeOf(subClass, superClass); }\nfunction shadow_input_createSuper(Derived) { var hasNativeReflectConstruct = shadow_input_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = shadow_input_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = shadow_input_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return shadow_input_possibleConstructorReturn(this, result); }; }\nfunction shadow_input_possibleConstructorReturn(self, call) { if (call && (shadow_input_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return shadow_input_assertThisInitialized(self); }\nfunction shadow_input_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction shadow_input_wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; shadow_input_wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !shadow_input_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return shadow_input_construct(Class, arguments, shadow_input_getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return shadow_input_setPrototypeOf(Wrapper, Class); }; return shadow_input_wrapNativeSuper(Class); }\nfunction shadow_input_construct(Parent, args, Class) { if (shadow_input_isNativeReflectConstruct()) { shadow_input_construct = Reflect.construct.bind(); } else { shadow_input_construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) shadow_input_setPrototypeOf(instance, Class.prototype); return instance; }; } return shadow_input_construct.apply(null, arguments); }\nfunction shadow_input_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction shadow_input_isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }\nfunction shadow_input_setPrototypeOf(o, p) { shadow_input_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return shadow_input_setPrototypeOf(o, p); }\nfunction shadow_input_getPrototypeOf(o) { shadow_input_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return shadow_input_getPrototypeOf(o); }\nfunction shadow_input_defineProperty(obj, key, value) { key = shadow_input_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction shadow_input_toPropertyKey(arg) { var key = shadow_input_toPrimitive(arg, "string"); return shadow_input_typeof(key) === "symbol" ? key : String(key); }\nfunction shadow_input_toPrimitive(input, hint) { if (shadow_input_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (shadow_input_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\nvar ShadowInput = /*#__PURE__*/function (_EventTarget) {\n  shadow_input_inherits(ShadowInput, _EventTarget);\n  var _super = shadow_input_createSuper(ShadowInput);\n  function ShadowInput(wrapper) {\n    var _this;\n    shadow_input_classCallCheck(this, ShadowInput);\n    _this = _super.call(this);\n    shadow_input_defineProperty(shadow_input_assertThisInitialized(_this), "_inputElement", null);\n    _this._inputElement = shadow_input_createInputElement(_this.controlCallback.bind(shadow_input_assertThisInitialized(_this)));\n    wrapper.append(_this._inputElement);\n    _this._inputElement.focus();\n    return _this;\n  }\n  shadow_input_createClass(ShadowInput, [{\n    key: "controlCallback",\n    value: function controlCallback(kind, data) {\n      switch (kind) {\n        case KEYBOARD_INPUT.INPUT:\n        case KEYBOARD_INPUT.COMPOSITION_START:\n        case KEYBOARD_INPUT.COMPOSITION_UPDATE:\n        case KEYBOARD_INPUT.COMPOSITION_END:\n        case KEYBOARD_INPUT.ENTER:\n        case KEYBOARD_INPUT.BACKSPACE:\n        case KEYBOARD_INPUT.DELETE:\n          this.dispatchEvent(new CustomEvent(EDITOR_EVENTS.INPUT, {\n            detail: {\n              kind: kind,\n              data: data\n            }\n          }));\n          break;\n        case KEYBOARD_COMMANDS.ARROW_LEFT:\n        case KEYBOARD_COMMANDS.ARROW_RIGHT:\n        case KEYBOARD_COMMANDS.ARROW_UP:\n        case KEYBOARD_COMMANDS.ARROW_DOWN:\n        case KEYBOARD_COMMANDS.CTRLA:\n        case KEYBOARD_COMMANDS.SHIFT_DOWN:\n        case KEYBOARD_COMMANDS.SHIFT_UP:\n        case KEYBOARD_COMMANDS.UNDO:\n        case KEYBOARD_COMMANDS.REDO:\n        case KEYBOARD_COMMANDS.COPY:\n        case KEYBOARD_COMMANDS.CUT:\n        case KEYBOARD_COMMANDS.PASTE:\n          this.dispatchEvent(new CustomEvent(EDITOR_EVENTS.CONTROL_CMD, {\n            detail: {\n              kind: kind,\n              data: data\n            }\n          }));\n          break;\n      }\n    }\n  }, {\n    key: "focus",\n    value: function focus() {\n      this._inputElement.focus({\n        preventScroll: true\n      });\n    }\n  }, {\n    key: "syncPosition",\n    value: function syncPosition(x, y) {\n      this._inputElement.style.transform = "translate(".concat(x, "px, ").concat(y, "px)");\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      if (this.removeLisenter) {\n        this.removeLisenter();\n      }\n      this._inputElement.remove();\n    }\n  }]);\n  return ShadowInput;\n}( /*#__PURE__*/shadow_input_wrapNativeSuper(EventTarget));\n/* harmony default export */ const shadow_input = (ShadowInput);\nfunction shadow_input_createInputElement(controlCallback) {\n  var input = document.createElement(\'input\');\n  input.setAttribute(\'style\', "\\n        width: 100px;\\n        position: absolute;\\n        left: 0;\\n        top: 0;\\n        border:none;\\n        opacity: 0;\\n        z-index: -1;\\n        contain: strict;");\n  input.setAttribute(\'tabindex\', -1);\n  input.setAttribute(\'spellcheck\', false);\n  input.setAttribute(\'autocorrect\', \'off\');\n  var stopInput = false;\n  var status = {\n    ctrlOn: false,\n    shiftOn: false\n  };\n  input.addEventListener(\'beforeinput\', function (e) {\n    e.preventDefault();\n    if (e.data) {\n      // content += e.data;\n      // renderContent();\n      if (!stopInput) {\n        controlCallback(KEYBOARD_INPUT.INPUT, e.data);\n      }\n    }\n  });\n  input.addEventListener(\'paste\', function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    var pasteContent = (e.clipboardData || window.clipboardData).getData("text");\n    controlCallback(KEYBOARD_COMMANDS.PASTE, pasteContent);\n  });\n  input.addEventListener(\'copy\', function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    controlCallback(KEYBOARD_COMMANDS.COPY, e);\n  });\n  input.addEventListener(\'cut\', function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    controlCallback(KEYBOARD_COMMANDS.CUT, e);\n  });\n  input.addEventListener(\'compositionstart\', function (e) {\n    controlCallback(KEYBOARD_INPUT.COMPOSITION_START);\n    stopInput = true;\n  });\n  input.addEventListener(\'compositionupdate\', function (e) {\n    controlCallback(KEYBOARD_INPUT.COMPOSITION_UPDATE, e.data);\n  });\n  input.addEventListener(\'compositionend\', function (e) {\n    controlCallback(KEYBOARD_INPUT.COMPOSITION_END, e.data);\n    input.value = \'\';\n    stopInput = false;\n  });\n  input.addEventListener(\'keyup\', function (event) {\n    if (stopInput) {\n      return;\n    }\n    switch (event.key) {\n      case "Shift":\n        controlCallback(KEYBOARD_COMMANDS.SHIFT_UP);\n        status.shiftOn = false;\n        break;\n      case "Meta":\n      case "Control":\n        status.ctrlOn = false;\n        break;\n    }\n  });\n  input.addEventListener(\'keydown\', function (event) {\n    if (stopInput) {\n      return;\n    }\n    switch (event.code) {\n      case "Enter":\n        controlCallback(KEYBOARD_INPUT.ENTER);\n        break;\n      case "Backspace":\n        controlCallback(KEYBOARD_INPUT.BACKSPACE);\n        break;\n      case "Delete":\n        controlCallback(KEYBOARD_INPUT.DELETE);\n        break;\n      case "ArrowLeft":\n        controlCallback(KEYBOARD_COMMANDS.ARROW_LEFT);\n        break;\n      case "ArrowRight":\n        controlCallback(KEYBOARD_COMMANDS.ARROW_RIGHT);\n        break;\n      case "ArrowDown":\n        controlCallback(KEYBOARD_COMMANDS.ARROW_DOWN);\n        break;\n      case "ArrowUp":\n        controlCallback(KEYBOARD_COMMANDS.ARROW_UP);\n        break;\n    }\n    switch (event.key) {\n      case "Shift":\n        controlCallback(KEYBOARD_COMMANDS.SHIFT_DOWN);\n        status.shiftOn = true;\n        break;\n      case "Meta":\n      case "Control":\n        status.ctrlOn = true;\n        break;\n      case \'a\':\n        if (status.ctrlOn) {\n          controlCallback(KEYBOARD_COMMANDS.CTRLA);\n        }\n        break;\n      // case \'c\':\n      //     if(status.ctrlOn) {\n      //         controlCallback(KEYBOARD_COMMANDS.CTRLC);\n      //     }\n      //     break; \n      // case \'v\':\n      //     if(status.ctrlOn) {\n      //         controlCallback(KEYBOARD_COMMANDS.CTRLV);\n      //     }\n      //     break;   \n      // case \'x\':\n      //     if(status.ctrlOn) {\n      //         controlCallback(KEYBOARD_COMMANDS.CTRLX);\n      //     }\n      //     break;\n      case \'y\':\n        if (status.ctrlOn) {\n          event.preventDefault();\n          controlCallback(KEYBOARD_COMMANDS.REDO);\n        }\n        break;\n      case \'z\':\n        if (status.ctrlOn && status.shiftOn) {\n          controlCallback(KEYBOARD_COMMANDS.REDO);\n        } else if (status.ctrlOn) {\n          controlCallback(KEYBOARD_COMMANDS.UNDO);\n        }\n        break;\n    }\n  });\n  return input;\n}\n;// CONCATENATED MODULE: ./src/core/instance/text-group/base/caret.js\nfunction caret_typeof(obj) { "@babel/helpers - typeof"; return caret_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, caret_typeof(obj); }\nfunction caret_toConsumableArray(arr) { return caret_arrayWithoutHoles(arr) || caret_iterableToArray(arr) || caret_unsupportedIterableToArray(arr) || caret_nonIterableSpread(); }\nfunction caret_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction caret_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return caret_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return caret_arrayLikeToArray(o, minLen); }\nfunction caret_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\nfunction caret_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return caret_arrayLikeToArray(arr); }\nfunction caret_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction caret_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction caret_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, caret_toPropertyKey(descriptor.key), descriptor); } }\nfunction caret_createClass(Constructor, protoProps, staticProps) { if (protoProps) caret_defineProperties(Constructor.prototype, protoProps); if (staticProps) caret_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction caret_defineProperty(obj, key, value) { key = caret_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction caret_toPropertyKey(arg) { var key = caret_toPrimitive(arg, "string"); return caret_typeof(key) === "symbol" ? key : String(key); }\nfunction caret_toPrimitive(input, hint) { if (caret_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (caret_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nvar Caret = /*#__PURE__*/function () {\n  function Caret() {\n    caret_classCallCheck(this, Caret);\n    caret_defineProperty(this, "_row", 0);\n    caret_defineProperty(this, "_column", [0, 0]);\n    caret_defineProperty(this, "_status", {\n      show: true,\n      anime: null,\n      lastElapsed: 0,\n      refreshElapsed: false\n    });\n  }\n  caret_createClass(Caret, [{\n    key: "setRow",\n    value: function setRow(row) {\n      this._row = row;\n    }\n  }, {\n    key: "setColumn",\n    value: function setColumn(columnoridx, column) {\n      if (column !== undefined) {\n        this._column[columnoridx] = column;\n      } else {\n        this._column = columnoridx;\n      }\n    }\n  }, {\n    key: "getRow",\n    value: function getRow() {\n      return this._row;\n    }\n  }, {\n    key: "getColumn",\n    value: function getColumn(idx) {\n      if (idx !== undefined) {\n        return this._column[idx];\n      }\n      return this._column;\n    }\n  }, {\n    key: "animate",\n    value: function animate(jflow) {\n      var _this = this;\n      this._status.anime = jflow.requestJFlowAnime(function (elapsed) {\n        var lastElapsed = _this._status.lastElapsed;\n        if (_this._status.refreshElapsed) {\n          _this._status.lastElapsed = elapsed;\n          _this._status.refreshElapsed = false;\n        }\n        if (elapsed - lastElapsed > 500) {\n          _this._status.show = !_this._status.show;\n          _this._status.lastElapsed = elapsed;\n        }\n      });\n    }\n  }, {\n    key: "cancelAnimate",\n    value: function cancelAnimate() {\n      this._status.anime.cancel();\n      Object.assign(this._status, {\n        show: true,\n        anime: null,\n        lastElapsed: 0\n      });\n    }\n  }, {\n    key: "isShow",\n    value: function isShow() {\n      return this._status.show;\n    }\n  }, {\n    key: "refresh",\n    value: function refresh() {\n      Object.assign(this._status, {\n        show: true,\n        refreshElapsed: true\n      });\n    }\n  }, {\n    key: "toRange",\n    value: function toRange() {\n      return [this._row].concat(caret_toConsumableArray(this._column));\n    }\n  }, {\n    key: "fromRange",\n    value: function fromRange(range) {\n      this._row = range[0];\n      this._column = range.slice(1);\n    }\n  }]);\n  return Caret;\n}();\n/* harmony default export */ const caret = (Caret);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/utils.js\n\nfunction calculateOffsetByWidth(offx, textmeta, fontSize, fontFamily, spaceHolder) {\n  var content = textmeta.getRenderSource(spaceHolder);\n  var maxL = content.length - 1;\n  if (textmeta.width === 0) {\n    return 0;\n  }\n  var allwidth = textmeta.width;\n  var idx = Math.floor(offx / allwidth * maxL);\n  requestCacheCanvas(function (ctx) {\n    ctx.font = "".concat(fontSize, " ").concat(fontFamily);\n    var g1, g2;\n    var lastidx;\n    var c = content.substring(0, idx);\n    var c1 = content.substring(idx - 1, idx);\n    var c2 = content.substring(idx, idx + 1);\n    var w = ctx.measureText(c).width;\n    var w1 = ctx.measureText(c1).width;\n    var w2 = ctx.measureText(c2).width;\n    g1 = w - w1 / 2;\n    g2 = w + w2 / 2;\n    do {\n      if (g1 <= offx && g2 >= offx) {\n        break;\n      }\n      if (g1 > offx) {\n        // 左侧少了\n        var spanw = g2 - offx;\n        lastidx = idx;\n        if (spanw < 100) {\n          idx -= 1;\n        } else {\n          idx -= Math.floor(spanw / g2 * lastidx);\n        }\n        c = content.substring(idx, lastidx);\n        w -= ctx.measureText(c).width;\n      } else if (g2 < offx) {\n        // 右侧少了\n        var _spanw = offx - g1;\n        lastidx = idx;\n        if (_spanw < 100) {\n          idx += 1;\n        } else {\n          idx += Math.floor(_spanw / (allwidth - g1) * (maxL - lastidx));\n        }\n        c = content.substring(lastidx, idx);\n        w += ctx.measureText(c).width;\n      }\n      c1 = content.substring(idx - 1, idx);\n      c2 = content.substring(idx, idx + 1);\n      w1 = ctx.measureText(c1).width;\n      w2 = ctx.measureText(c2).width;\n      g1 = w - w1 / 2;\n      g2 = w + w2 / 2;\n    } while (idx >= 0 && idx <= maxL);\n  });\n  return idx;\n}\n;// CONCATENATED MODULE: ./src/core/instance/text-group/storage/index.js\nfunction storage_typeof(obj) { "@babel/helpers - typeof"; return storage_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, storage_typeof(obj); }\nfunction storage_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction storage_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, storage_toPropertyKey(descriptor.key), descriptor); } }\nfunction storage_createClass(Constructor, protoProps, staticProps) { if (protoProps) storage_defineProperties(Constructor.prototype, protoProps); if (staticProps) storage_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction storage_defineProperty(obj, key, value) { key = storage_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction storage_toPropertyKey(arg) { var key = storage_toPrimitive(arg, "string"); return storage_typeof(key) === "symbol" ? key : String(key); }\nfunction storage_toPrimitive(input, hint) { if (storage_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (storage_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\nvar Area = /*#__PURE__*/function () {\n  function Area() {\n    storage_classCallCheck(this, Area);\n    storage_defineProperty(this, "_lines", []);\n  }\n  storage_createClass(Area, [{\n    key: "get",\n    value: function get(idx) {\n      return this._lines[idx];\n    }\n  }, {\n    key: "getLineAbove",\n    value: function getLineAbove(offsetY) {\n      var row = 0;\n      var lines = this._lines;\n      while (row < lines.length) {\n        if (lines[row].reduceHeight > offsetY) {\n          break;\n        }\n        row++;\n      }\n      return Math.min(row, lines.length - 1);\n    }\n  }, {\n    key: "truncate",\n    value: function truncate(configs) {\n      var l = Line.create(configs);\n      this._lines = [l];\n      return l;\n    }\n  }, {\n    key: "push",\n    value: function push(line) {\n      this._lines.push(line);\n    }\n  }, {\n    key: "forEach",\n    value: function forEach(callback) {\n      this._lines.forEach(callback);\n    }\n  }, {\n    key: "length",\n    value: function length() {\n      return this._lines.length;\n    }\n  }]);\n  return Area;\n}();\nvar Line = /*#__PURE__*/function () {\n  function Line() {\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    storage_classCallCheck(this, Line);\n    storage_defineProperty(this, "width", 0);\n    storage_defineProperty(this, "anchorY", 0);\n    storage_defineProperty(this, "height", 0);\n    storage_defineProperty(this, "reduceHeight", 0);\n    storage_defineProperty(this, "_elements", []);\n    storage_defineProperty(this, "_elements", []);\n    Object.assign(this, configs);\n  }\n  storage_createClass(Line, [{\n    key: "get",\n    value: function get(idx) {\n      return this._elements[idx];\n    }\n  }, {\n    key: "length",\n    value: function length() {\n      return this._elements.length;\n    }\n  }, {\n    key: "insert",\n    value: function insert(idx, elem) {\n      this._elements.splice(idx, 0, elem);\n    }\n  }, {\n    key: "push",\n    value: function push(elem) {\n      this._elements.push(elem);\n    }\n  }, {\n    key: "tail",\n    value: function tail() {\n      return this._elements[this._elements.length - 1];\n    }\n  }, {\n    key: "copy",\n    value: function copy() {\n      return this._elements.slice();\n    }\n  }, {\n    key: "getColumnNearest",\n    value: function getColumnNearest(offsetX, elementSpace, fontSize, fontFamily, editor) {\n      var elements = this._elements;\n      if (offsetX >= this.width) {\n        var c = elements.length - 1;\n        var elem = elements[c];\n        var q = 0;\n        if (elem.type === \'text\') {\n          q = elem.source.length;\n        }\n        return [c, q];\n      } else {\n        var elem_idx = 0;\n        var last_c = 0;\n        var _c = 0;\n        var lastel = null;\n        while (elem_idx < elements.length - 1) {\n          last_c = _c;\n          var el = elements[elem_idx];\n          if (el.type !== \'text\') {\n            var doubleMargin = lastel && lastel.type === \'text\';\n            var margin = doubleMargin ? elementSpace * 2 : elementSpace;\n            _c += el.width + margin;\n          } else {\n            _c += el.width;\n          }\n          if (_c > offsetX) {\n            lastel = el;\n            break;\n          }\n          lastel = el;\n          elem_idx++;\n        }\n        if (_c <= offsetX) {\n          last_c = _c;\n        }\n        var textmeta = elements[elem_idx];\n        if (textmeta.type === \'text\') {\n          var offx = offsetX - last_c;\n          var idx = calculateOffsetByWidth(offx, textmeta, fontSize, fontFamily, editor.spaceHolder);\n          return [elem_idx, idx];\n        } else {\n          var _offx = offsetX - last_c;\n          if (_offx > lastel.width / 2) {\n            return [elem_idx + 1, 0];\n          } else {\n            return [elem_idx, 0];\n          }\n        }\n      }\n    }\n  }, {\n    key: "forEach",\n    value: function forEach(callback) {\n      this._elements.forEach(callback);\n    }\n  }], [{\n    key: "create",\n    value: function create(configs) {\n      var l = new Line(configs);\n      return l;\n    }\n  }]);\n  return Line;\n}();\nvar FlattenTextElements = /*#__PURE__*/function () {\n  function FlattenTextElements() {\n    storage_classCallCheck(this, FlattenTextElements);\n    storage_defineProperty(this, "_textElements", []);\n    storage_defineProperty(this, "_records", []);\n    storage_defineProperty(this, "_caretRecord", null);\n  }\n  storage_createClass(FlattenTextElements, [{\n    key: "insertBefore",\n    value: function insertBefore(anchor, elem) {\n      var idx = this.findIndex(anchor);\n      this.inersetAt(idx, elem);\n    }\n  }, {\n    key: "insertAfter",\n    value: function insertAfter(anchor, elem, needWrap) {\n      var idx = this.findIndex(anchor);\n      // const next = this.get(idx+1);\n      if (needWrap) {\n        elem.setNeedWrap(true);\n      }\n      this.inersetAt(idx + 1, elem);\n    }\n  }, {\n    key: "findIndex",\n    value: function findIndex(elem) {\n      return this._textElements.findIndex(function (el) {\n        return el === elem;\n      });\n    }\n  }, {\n    key: "get",\n    value: function get(idx) {\n      return this._textElements[idx];\n    }\n  }, {\n    key: "from",\n    value: function from(elements) {\n      this._textElements = elements;\n    }\n  }, {\n    key: "inersetAt",\n    value: function inersetAt(idx, elem) {\n      this.splice(idx, 0, elem);\n    }\n  }, {\n    key: "push",\n    value: function push(elem) {\n      this.splice(this.length(), 0, elem);\n    }\n  }, {\n    key: "remove",\n    value: function remove(idx) {\n      this.splice(idx, 1);\n    }\n  }, {\n    key: "splice",\n    value: function splice() {\n      var _this$_textElements;\n      var removed = (_this$_textElements = this._textElements).splice.apply(_this$_textElements, arguments);\n      this._records.push({\n        op: \'splice\',\n        args: arguments,\n        removed: removed\n      });\n    }\n  }, {\n    key: "slice",\n    value: function slice() {\n      var _this$_textElements2;\n      return (_this$_textElements2 = this._textElements).slice.apply(_this$_textElements2, arguments);\n    }\n  }, {\n    key: "copy",\n    value: function copy() {\n      return this._textElements.slice();\n    }\n  }, {\n    key: "isEmpty",\n    value: function isEmpty() {\n      return this._textElements.length === 1 && this._textElements[0].source === \'\';\n    }\n  }, {\n    key: "forEach",\n    value: function forEach(callback) {\n      this._textElements.forEach(callback);\n    }\n  }, {\n    key: "tail",\n    value: function tail() {\n      return this._textElements[this._textElements.length - 1];\n    }\n  }, {\n    key: "filter",\n    value: function filter(callback) {\n      return this._textElements.filter(callback);\n    }\n  }, {\n    key: "length",\n    value: function length() {\n      return this._textElements.length;\n    }\n  }, {\n    key: "startRecord",\n    value: function startRecord() {\n      this._caretRecord = {\n        before: null,\n        after: null\n      };\n      this._records = [];\n      return this._records;\n    }\n  }, {\n    key: "getRecord",\n    value: function getRecord() {\n      return this._records;\n    }\n  }, {\n    key: "recordBeforeCaret",\n    value: function recordBeforeCaret(caret) {\n      this._caretRecord.before = caret.toRange();\n    }\n  }, {\n    key: "recordAfterCaret",\n    value: function recordAfterCaret(caret) {\n      this._caretRecord.after = caret.toRange();\n    }\n  }, {\n    key: "getCaretRecord",\n    value: function getCaretRecord() {\n      return this._caretRecord;\n    }\n  }, {\n    key: "collectRecords",\n    value: function collectRecords() {\n      return this._records;\n    }\n  }], [{\n    key: "create",\n    value: function create(elements) {\n      var _e = new FlattenTextElements();\n      _e.from(elements);\n      return _e;\n    }\n  }]);\n  return FlattenTextElements;\n}();\nvar TextElement = /*#__PURE__*/function () {\n  function TextElement(type, source) {\n    storage_classCallCheck(this, TextElement);\n    storage_defineProperty(this, "needWrap", false);\n    storage_defineProperty(this, "width", 0);\n    storage_defineProperty(this, "reduceWidth", 0);\n    storage_defineProperty(this, "height", 0);\n    storage_defineProperty(this, "anchorX", 0);\n    storage_defineProperty(this, "anchorY", 0);\n    storage_defineProperty(this, "dirty", true);\n    storage_defineProperty(this, "isTail", false);\n    storage_defineProperty(this, "_spaceRecords", []);\n    storage_defineProperty(this, "_spacedContentSegmnent", []);\n    storage_defineProperty(this, "_returnSymbol", {\n      symbol: \'↲\',\n      width: 0\n    });\n    this.type = type;\n    this.source = source;\n  }\n  storage_createClass(TextElement, [{\n    key: "getRenderSource",\n    value: function getRenderSource(spaceHolder) {\n      var content = this.source;\n      if (spaceHolder.enable) {\n        return content.replace(/\\s/g, spaceHolder.spacePlaceholder);\n      }\n      return content;\n    }\n  }, {\n    key: "setSourceWithRecord",\n    value: function setSourceWithRecord(source, spaceHolder, records) {\n      var lastSource = this.source;\n      this.setSource(source, spaceHolder);\n      if (records) {\n        records.push({\n          op: \'setSource\',\n          args: [this, source, lastSource]\n        });\n      }\n    }\n  }, {\n    key: "setSource",\n    value: function setSource(source, spaceHolder) {\n      this.source = source;\n      this.dirty = true;\n      if (spaceHolder.enable) {\n        var r = this._spaceRecords;\n        var p = spaceHolder.spacePlaceholder;\n        r.length = 0;\n        var lastOffset;\n        source.replace(/\\s/g, function (_, offset) {\n          if (lastOffset === undefined) {\n            lastOffset = offset;\n            r.push(offset);\n          }\n          if (offset - lastOffset > 1) {\n            r.push(lastOffset);\n            r.push(offset);\n          }\n          lastOffset = offset;\n          return p;\n        });\n        if (lastOffset !== undefined) {\n          r.push(lastOffset);\n        }\n      }\n    }\n  }, {\n    key: "setNeedWrap",\n    value: function setNeedWrap(needWrap, records) {\n      var lastWrap = this.needWrap;\n      this.needWrap = needWrap;\n      if (lastWrap !== needWrap && records) {\n        records.push({\n          op: \'setNeedWrap\',\n          args: [this, needWrap, lastWrap]\n        });\n      }\n    }\n  }, {\n    key: "shift",\n    value: function shift(offset, step) {\n      if (this.type === \'text\') {\n        var content = this.source;\n        var l = content.length;\n        var nextOffset = offset + step;\n        if (nextOffset < 0) {\n          return \'prev\';\n        }\n        if (nextOffset > l) {\n          //- ((isTail || this.needWrap) ? 0 : 1)) {\n          return \'next\';\n        }\n        return \'self\';\n      } else {\n        if (step > 0) {\n          return \'next\';\n        }\n        if (step < 0) {\n          return \'prev\';\n        }\n      }\n    }\n  }, {\n    key: "tailOffset",\n    value: function tailOffset() {\n      if (this.type === \'text\') {\n        if (this.needWrap || this.isTail) {\n          return this.source.length;\n        } else {\n          return Math.max(0, this.source.length - 1);\n        }\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: "headOffset",\n    value: function headOffset() {\n      return 0;\n    }\n  }, {\n    key: "preCalculateText",\n    value: function preCalculateText(ctx, spaceHolder) {\n      var content = this.getRenderSource(spaceHolder);\n      this.width = ctx.measureText(content).width;\n      this.dirty = false;\n      if (spaceHolder.enable) {\n        var s_width = ctx.measureText(spaceHolder.spacePlaceholder).width;\n        this._returnSymbol.width = ctx.measureText(this._returnSymbol.symbol).width;\n        var r2 = this._spacedContentSegmnent;\n        var lastOffset = 0;\n        r2.length = 0;\n        if (this._spaceRecords.length) {\n          var r = this._spaceRecords;\n          var l = r.length;\n          var i = 0;\n          while (i < l) {\n            var f = r[i++];\n            var t = r[i++];\n            var q = content.substring(lastOffset, f);\n            r2.push([q, ctx.measureText(q).width, \'text\']);\n            r2.push([content.substring(f, t + 1), (t - f + 1) * s_width, \'placeholder\']);\n            lastOffset = t + 1;\n          }\n        }\n        if (lastOffset < content.length) {\n          var _q = content.substring(lastOffset);\n          r2.push([_q, ctx.measureText(_q).width, \'text\']);\n        }\n        if (this.needWrap) {\n          this.width += this._returnSymbol.width;\n        }\n      }\n    }\n  }, {\n    key: "render",\n    value: function render(ctx, spaceHolder, textColor) {\n      var _this = this;\n      if (spaceHolder.enable) {\n        var hw = this.width / 2;\n        var _w = -hw + this.anchorX;\n        var spacePlaceholderColor = spaceHolder.spacePlaceholderColor;\n        this._spacedContentSegmnent.forEach(function (seg) {\n          ctx.fillStyle = seg[2] === \'text\' ? textColor : spacePlaceholderColor;\n          var t = seg[1] / 2;\n          _w += t;\n          ctx.fillText(seg[0], _w, _this.anchorY);\n          _w += t;\n        });\n        if (this.needWrap) {\n          ctx.save();\n          ctx.font = spaceHolder.returnFont;\n          ctx.fillStyle = spacePlaceholderColor;\n          ctx.fillText(this._returnSymbol.symbol, _w + this._returnSymbol.width / 2, this.anchorY);\n          ctx.restore();\n        }\n        return;\n      }\n      ctx.fillText(this.source, this.anchorX, this.anchorY);\n    }\n  }]);\n  return TextElement;\n}();\n;// CONCATENATED MODULE: ./src/core/instance/text-group/base/range.js\nfunction range_typeof(obj) { "@babel/helpers - typeof"; return range_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, range_typeof(obj); }\nfunction range_slicedToArray(arr, i) { return range_arrayWithHoles(arr) || range_iterableToArrayLimit(arr, i) || range_unsupportedIterableToArray(arr, i) || range_nonIterableRest(); }\nfunction range_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction range_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return range_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return range_arrayLikeToArray(o, minLen); }\nfunction range_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction range_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction range_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction range_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction range_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, range_toPropertyKey(descriptor.key), descriptor); } }\nfunction range_createClass(Constructor, protoProps, staticProps) { if (protoProps) range_defineProperties(Constructor.prototype, protoProps); if (staticProps) range_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction range_defineProperty(obj, key, value) { key = range_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction range_toPropertyKey(arg) { var key = range_toPrimitive(arg, "string"); return range_typeof(key) === "symbol" ? key : String(key); }\nfunction range_toPrimitive(input, hint) { if (range_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (range_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\nvar Range = /*#__PURE__*/function () {\n  function Range() {\n    range_classCallCheck(this, Range);\n    range_defineProperty(this, "_enable", false);\n    range_defineProperty(this, "_rangeFrom", null);\n    // [row, elem_idx, offset]\n    range_defineProperty(this, "_rangeTo", null);\n    // [row, elem_idx, offset]\n    range_defineProperty(this, "_initialRange", null);\n  }\n  range_createClass(Range, [{\n    key: "setInitialRange",\n    value: function setInitialRange(initialRange) {\n      this._initialRange = initialRange;\n    }\n  }, {\n    key: "getRangeFrom",\n    value: function getRangeFrom() {\n      return this._rangeFrom;\n    }\n  }, {\n    key: "getRangeTo",\n    value: function getRangeTo() {\n      return this._rangeTo;\n    }\n  }, {\n    key: "isEnable",\n    value: function isEnable() {\n      return this._enable;\n    }\n  }, {\n    key: "enable",\n    value: function enable() {\n      this._enable = true;\n    }\n  }, {\n    key: "disable",\n    value: function disable() {\n      this._enable = false;\n    }\n  }, {\n    key: "handleCaret",\n    value: function handleCaret(caret) {\n      var _this$_rangeTo = range_slicedToArray(this._rangeTo, 3),\n        a = _this$_rangeTo[0],\n        b = _this$_rangeTo[1],\n        c = _this$_rangeTo[2];\n      caret.setRow(a);\n      caret.setColumn([b, c]);\n    }\n  }, {\n    key: "setRange",\n    value: function setRange(another) {\n      var a = this._initialRange;\n      if (this._compareRange(a, another)) {\n        this._rangeFrom = a;\n        this._rangeTo = another;\n      } else {\n        this._rangeFrom = another;\n        this._rangeTo = a;\n      }\n    }\n  }, {\n    key: "_compareRange",\n    value: function _compareRange(r1, r2) {\n      if (r1[0] > r2[0]) {\n        return false;\n      }\n      if (r1[0] === r2[0] && r1[1] > r2[1]) {\n        return false;\n      }\n      if (r1[0] === r2[0] && r1[1] === r2[1] && r1[2] > r2[2]) {\n        return false;\n      }\n      return true;\n    }\n\n    // TODO \n  }, {\n    key: "getRangeCopy",\n    value: function getRangeCopy(editor) {\n      if (this._enable) {\n        var area = editor._area;\n        var caret = editor._caret;\n        var rangeFrom = this._rangeFrom;\n        var rangeTo = this._rangeTo;\n        var elemFrom = area.get(rangeFrom[0]).get(rangeFrom[1]);\n        var elemTo = area.get(rangeTo[0]).get(rangeTo[1]);\n        if (elemFrom === elemTo) {\n          var c = elemFrom.source;\n          return c.substring(rangeFrom[2], rangeTo[2]);\n        }\n        var flattenTxtElem = editor._flattenTxtElem;\n        var preContent = \'\';\n        var afterContent = \'\';\n        var fromIdx = flattenTxtElem.findIndex(elemFrom);\n        var toIdx = flattenTxtElem.findIndex(elemTo);\n        var elems = flattenTxtElem.slice(fromIdx, toIdx + 1);\n        var elements = elems.slice(1, elems.length - 1).filter(function (el) {\n          return el.type === \'text\';\n        });\n        preContent = elemFrom.source.substring(rangeFrom[2]);\n        afterContent = elemTo.source.substring(0, rangeTo[2]);\n        var content = preContent;\n        if (elemFrom.needWrap) {\n          content += \'\\n\';\n        }\n        elements.forEach(function (el) {\n          content += el.source;\n          if (el.needWrap) {\n            content += \'\\n\';\n          }\n        });\n        return content + afterContent;\n      }\n    }\n  }, {\n    key: "delete",\n    value: function _delete(editor, records) {\n      if (this._enable) {\n        var area = editor._area;\n        var caret = editor._caret;\n        var rangeFrom = this._rangeFrom;\n        var rangeTo = this._rangeTo;\n        var elemFrom = area.get(rangeFrom[0]).get(rangeFrom[1]);\n        var elemTo = area.get(rangeTo[0]).get(rangeTo[1]);\n        var _rangeFrom = range_slicedToArray(rangeFrom, 3),\n          row = _rangeFrom[0],\n          elem_idx = _rangeFrom[1],\n          offset = _rangeFrom[2];\n        records.push({\n          op: \'range\',\n          args: [rangeFrom.slice(), rangeTo.slice()]\n        });\n        if (elemFrom === elemTo) {\n          var c = elemFrom.source;\n          elemFrom.setSourceWithRecord(c.substring(0, rangeFrom[2]) + c.substring(rangeTo[2]), editor.spaceHolder, records);\n        } else {\n          var flattenTxtElem = editor._flattenTxtElem;\n          var preContent = \'\';\n          var afterContent = \'\';\n          var preElement;\n          var afterElement;\n          var fromIdx = flattenTxtElem.findIndex(elemFrom);\n          var toIdx = flattenTxtElem.findIndex(elemTo);\n          var endTextNeedWrap = false;\n          if (elemFrom.type === \'text\') {\n            preContent = elemFrom.source.substring(0, rangeFrom[2]);\n          } else {\n            preElement = flattenTxtElem.get(fromIdx - 1);\n          }\n          if (elemTo.type === \'text\') {\n            afterContent = elemTo.source.substring(rangeTo[2]);\n            endTextNeedWrap = elemTo.needWrap;\n          } else {\n            afterElement = flattenTxtElem.get(toIdx - 1);\n          }\n          if (preElement) {\n            flattenTxtElem.splice(fromIdx, toIdx - fromIdx + 1);\n            if (preElement.type === \'text\') {\n              if (preElement.needWrap) {\n                row -= 1;\n              } else {\n                elem_idx -= 1;\n              }\n              offset = preElement.source.length;\n              preElement.setSourceWithRecord(preElement.source + afterContent, editor.spaceHolder, records);\n              preElement.setNeedWrap(endTextNeedWrap, records);\n            } else {\n              var t = new TextElement(\'text\', preContent + afterContent);\n              t.setNeedWrap(endTextNeedWrap, records);\n              flattenTxtElem.splice(fromIdx, 0, t);\n            }\n          } else {\n            flattenTxtElem.splice(fromIdx, toIdx - fromIdx);\n            if (afterElement) {\n              var _t = new TextElement(\'text\', preContent);\n              flattenTxtElem.splice(fromIdx, 0, _t);\n            } else {\n              elemTo.setSourceWithRecord(preContent + afterContent, editor.spaceHolder, records);\n            }\n          }\n          if (flattenTxtElem.length() === 0) {\n            // elem_idx = 0;\n            flattenTxtElem.push(new TextElement(\'text\', \'\'));\n          }\n        }\n        this.disable();\n        caret.setRow(row);\n        caret.setColumn([elem_idx, offset]);\n      }\n    }\n  }]);\n  return Range;\n}();\n/* harmony default export */ const range = (Range);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/undoredo.js\nfunction undoredo_toConsumableArray(arr) { return undoredo_arrayWithoutHoles(arr) || undoredo_iterableToArray(arr) || undoredo_unsupportedIterableToArray(arr) || undoredo_nonIterableSpread(); }\nfunction undoredo_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction undoredo_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return undoredo_arrayLikeToArray(arr); }\nfunction _toArray(arr) { return undoredo_arrayWithHoles(arr) || undoredo_iterableToArray(arr) || undoredo_unsupportedIterableToArray(arr) || undoredo_nonIterableRest(); }\nfunction undoredo_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\nfunction undoredo_slicedToArray(arr, i) { return undoredo_arrayWithHoles(arr) || undoredo_iterableToArrayLimit(arr, i) || undoredo_unsupportedIterableToArray(arr, i) || undoredo_nonIterableRest(); }\nfunction undoredo_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction undoredo_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return undoredo_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return undoredo_arrayLikeToArray(o, minLen); }\nfunction undoredo_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction undoredo_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction undoredo_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction undoredo_typeof(obj) { "@babel/helpers - typeof"; return undoredo_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, undoredo_typeof(obj); }\nfunction undoredo_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction undoredo_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, undoredo_toPropertyKey(descriptor.key), descriptor); } }\nfunction undoredo_createClass(Constructor, protoProps, staticProps) { if (protoProps) undoredo_defineProperties(Constructor.prototype, protoProps); if (staticProps) undoredo_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction undoredo_defineProperty(obj, key, value) { key = undoredo_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction undoredo_toPropertyKey(arg) { var key = undoredo_toPrimitive(arg, "string"); return undoredo_typeof(key) === "symbol" ? key : String(key); }\nfunction undoredo_toPrimitive(input, hint) { if (undoredo_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (undoredo_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction isSetSourceBatch(x) {\n  return x.length === 1 && x[0].op === \'setSource\';\n}\nvar UndoRedo = /*#__PURE__*/function () {\n  function UndoRedo() {\n    undoredo_classCallCheck(this, UndoRedo);\n    undoredo_defineProperty(this, "_undo", []);\n    undoredo_defineProperty(this, "_redo", []);\n    undoredo_defineProperty(this, "_editor", null);\n  }\n  undoredo_createClass(UndoRedo, [{\n    key: "write",\n    value: function write(x, caretRecord) {\n      if (x.length === 0) {\n        return;\n      }\n      if (isSetSourceBatch(x)) {\n        var t = x[0];\n        var lastUndo = this.getLastUndo();\n        if (lastUndo && isSetSourceBatch(lastUndo._batch)) {\n          var q = lastUndo._batch[0];\n          if (q.args[0] === t.args[0]) {\n            q.args[1] = t.args[1];\n            lastUndo._caretMetaTo = caretRecord.after;\n            return;\n          }\n        }\n      }\n      var r = new BatchAction(x);\n      r._caretMetaFrom = caretRecord.before;\n      r._caretMetaTo = caretRecord.after;\n      this._undo.push(r);\n      if (this._undo.length > UndoRedo._length) {\n        this._undo.splice(0, 1);\n      }\n      if (this._redo.length) {\n        this._redo = [];\n      }\n    }\n  }, {\n    key: "getLastUndo",\n    value: function getLastUndo() {\n      return this._undo[this._undo.length - 1];\n    }\n  }, {\n    key: "undo",\n    value: function undo() {\n      var x = this._undo.pop();\n      if (x) {\n        x.undo(this._editor);\n        this._redo.push(x);\n      }\n      return x;\n    }\n  }, {\n    key: "redo",\n    value: function redo() {\n      var x = this._redo.pop();\n      while (x && x.SKIP_REDO) {\n        x = this._redo.pop();\n      }\n      if (x) {\n        x.redo(this._editor);\n        this._undo.push(x);\n      }\n      return x;\n    }\n  }]);\n  return UndoRedo;\n}();\nundoredo_defineProperty(UndoRedo, "_length", 50);\n\nvar BatchAction = /*#__PURE__*/function () {\n  function BatchAction(batch) {\n    undoredo_classCallCheck(this, BatchAction);\n    undoredo_defineProperty(this, "_batch", []);\n    undoredo_defineProperty(this, "_caretMetaFrom", null);\n    undoredo_defineProperty(this, "_caretMetaTo", null);\n    this._batch = batch;\n  }\n  undoredo_createClass(BatchAction, [{\n    key: "updateCaretMetaTo",\n    value: function updateCaretMetaTo(meta) {\n      this._caretMetaTo = meta;\n    }\n  }, {\n    key: "undo",\n    value: function undo(editor) {\n      this._batch.slice().reverse().forEach(function (action) {\n        switch (action.op) {\n          case \'range\':\n            var _action$args = undoredo_slicedToArray(action.args, 2),\n              rangeFrom = _action$args[0],\n              rangeTo = _action$args[1];\n            var range = editor._range;\n            range.setInitialRange(rangeFrom);\n            range.setRange(rangeTo);\n            range.enable();\n            break;\n          case \'setSource\':\n            var _action$args2 = undoredo_slicedToArray(action.args, 3),\n              elem = _action$args2[0],\n              s = _action$args2[1],\n              ls = _action$args2[2];\n            elem.setSource(ls, editor.spaceHolder);\n            break;\n          case \'setNeedWrap\':\n            var _action$args3 = undoredo_slicedToArray(action.args, 3),\n              o = _action$args3[0],\n              p = _action$args3[1],\n              q = _action$args3[2];\n            o.needWrap = q;\n            o.dirty = true;\n            break;\n          case \'splice\':\n            var flattenTxtElem = editor._flattenTxtElem;\n            var _action$args4 = _toArray(action.args),\n              a = _action$args4[0],\n              b = _action$args4[1],\n              c = _action$args4.slice(2);\n            var removed = action.removed;\n            var i = 0;\n            if (c) {\n              i = c.length;\n            }\n            flattenTxtElem.splice.apply(flattenTxtElem, [a, i].concat(undoredo_toConsumableArray(removed)));\n            break;\n        }\n      });\n      editor._caret.fromRange(this._caretMetaFrom);\n    }\n  }, {\n    key: "redo",\n    value: function redo(editor) {\n      this._batch.forEach(function (action) {\n        switch (action.op) {\n          case \'setSource\':\n            var _action$args5 = undoredo_slicedToArray(action.args, 3),\n              elem = _action$args5[0],\n              s = _action$args5[1],\n              ls = _action$args5[2];\n            elem.setSource(s, editor.spaceHolder);\n            break;\n          case \'setNeedWrap\':\n            var _action$args6 = undoredo_slicedToArray(action.args, 3),\n              o = _action$args6[0],\n              p = _action$args6[1],\n              q = _action$args6[2];\n            o.needWrap = p;\n            o.dirty = true;\n            break;\n          case \'splice\':\n            var flattenTxtElem = editor._flattenTxtElem;\n            flattenTxtElem.splice.apply(flattenTxtElem, undoredo_toConsumableArray(action.args));\n            break;\n        }\n      });\n      editor._caret.fromRange(this._caretMetaTo);\n    }\n  }]);\n  return BatchAction;\n}();\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/base.js\nfunction base_typeof(obj) { "@babel/helpers - typeof"; return base_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, base_typeof(obj); }\nfunction base_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction base_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, base_toPropertyKey(descriptor.key), descriptor); } }\nfunction base_createClass(Constructor, protoProps, staticProps) { if (protoProps) base_defineProperties(Constructor.prototype, protoProps); if (staticProps) base_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction base_toPropertyKey(arg) { var key = base_toPrimitive(arg, "string"); return base_typeof(key) === "symbol" ? key : String(key); }\nfunction base_toPrimitive(input, hint) { if (base_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (base_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nvar Command = /*#__PURE__*/function () {\n  function Command(editor) {\n    base_classCallCheck(this, Command);\n    this._editor = editor;\n  }\n  base_createClass(Command, [{\n    key: "exec",\n    value: function exec() {}\n  }], [{\n    key: "create",\n    value: function create(editor) {\n      return new this(editor);\n    }\n  }]);\n  return Command;\n}();\n/* harmony default export */ const base = (Command);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/movement.js\nfunction movement_typeof(obj) { "@babel/helpers - typeof"; return movement_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, movement_typeof(obj); }\nfunction movement_slicedToArray(arr, i) { return movement_arrayWithHoles(arr) || movement_iterableToArrayLimit(arr, i) || movement_unsupportedIterableToArray(arr, i) || movement_nonIterableRest(); }\nfunction movement_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction movement_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return movement_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return movement_arrayLikeToArray(o, minLen); }\nfunction movement_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction movement_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction movement_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction movement_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction movement_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, movement_toPropertyKey(descriptor.key), descriptor); } }\nfunction movement_createClass(Constructor, protoProps, staticProps) { if (protoProps) movement_defineProperties(Constructor.prototype, protoProps); if (staticProps) movement_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction movement_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) movement_setPrototypeOf(subClass, superClass); }\nfunction movement_setPrototypeOf(o, p) { movement_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return movement_setPrototypeOf(o, p); }\nfunction movement_createSuper(Derived) { var hasNativeReflectConstruct = movement_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = movement_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = movement_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return movement_possibleConstructorReturn(this, result); }; }\nfunction movement_possibleConstructorReturn(self, call) { if (call && (movement_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return movement_assertThisInitialized(self); }\nfunction movement_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction movement_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction movement_getPrototypeOf(o) { movement_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return movement_getPrototypeOf(o); }\nfunction movement_defineProperty(obj, key, value) { key = movement_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction movement_toPropertyKey(arg) { var key = movement_toPrimitive(arg, "string"); return movement_typeof(key) === "symbol" ? key : String(key); }\nfunction movement_toPrimitive(input, hint) { if (movement_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (movement_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\nvar ArrowLeftCommand = /*#__PURE__*/function (_Command) {\n  movement_inherits(ArrowLeftCommand, _Command);\n  var _super = movement_createSuper(ArrowLeftCommand);\n  function ArrowLeftCommand() {\n    movement_classCallCheck(this, ArrowLeftCommand);\n    return _super.apply(this, arguments);\n  }\n  movement_createClass(ArrowLeftCommand, [{\n    key: "exec",\n    value: function exec() {\n      var editor = this._editor;\n      editor._range.disable();\n      var flattenTxtElem = editor._flattenTxtElem;\n      var caret = editor._caret;\n      var row = caret.getRow();\n      var column = caret.getColumn();\n      var _column = movement_slicedToArray(column, 2),\n        elemidx = _column[0],\n        offset = _column[1];\n      var line = editor._area.get(row);\n      var element = line.get(elemidx);\n      var idx = flattenTxtElem.findIndex(element);\n      var result = element.shift(offset, -1);\n      switch (result) {\n        case \'prev\':\n          if (elemidx > 0) {\n            var el = line.get(elemidx - 1);\n            caret.setColumn([elemidx - 1, el.tailOffset()]);\n          } else if (idx > 0) {\n            var preRow = row - 1;\n            var preElemidx = editor._area.get(preRow).length() - 1;\n            var _offset = flattenTxtElem.get(idx - 1).tailOffset();\n            caret.setRow(preRow);\n            caret.setColumn([preElemidx, _offset]);\n          }\n          break;\n        case \'self\':\n          caret.setColumn(1, offset - 1);\n          break;\n      }\n      caret.refresh();\n      editor.syncShadowInputPosition();\n      editor._jflow._render();\n    }\n  }]);\n  return ArrowLeftCommand;\n}(base);\nmovement_defineProperty(ArrowLeftCommand, "_name", KEYBOARD_COMMANDS.ARROW_LEFT);\nvar ArrowRightCommand = /*#__PURE__*/function (_Command2) {\n  movement_inherits(ArrowRightCommand, _Command2);\n  var _super2 = movement_createSuper(ArrowRightCommand);\n  function ArrowRightCommand() {\n    movement_classCallCheck(this, ArrowRightCommand);\n    return _super2.apply(this, arguments);\n  }\n  movement_createClass(ArrowRightCommand, [{\n    key: "exec",\n    value: function exec() {\n      var editor = this._editor;\n      editor._range.disable();\n      var flattenTxtElem = editor._flattenTxtElem;\n      var caret = editor._caret;\n      var row = caret.getRow();\n      var column = caret.getColumn();\n      var _column2 = movement_slicedToArray(column, 2),\n        elemidx = _column2[0],\n        offset = _column2[1];\n      var line = editor._area.get(row);\n      var element = line.get(elemidx);\n      var idx = flattenTxtElem.findIndex(element);\n      var result = element.shift(offset, 1, idx === flattenTxtElem.length() - 1);\n      switch (result) {\n        case \'next\':\n          if (elemidx < line.length() - 1) {\n            var el = line.get(elemidx + 1);\n            if (element.type === \'text\' && el.type !== \'text\') {\n              caret.setColumn([elemidx + 2, el.headOffset()]);\n            } else {\n              caret.setColumn([elemidx + 1, el.headOffset()]);\n            }\n          } else if (idx < flattenTxtElem.length() - 1) {\n            var afterRow = row + 1;\n            var _offset2 = flattenTxtElem.get(idx + 1).headOffset();\n            caret.setRow(afterRow);\n            caret.setColumn([0, _offset2]);\n          }\n          break;\n        case \'self\':\n          caret.setColumn(1, offset + 1);\n          break;\n      }\n      caret.refresh();\n      editor.syncShadowInputPosition();\n      editor._jflow._render();\n    }\n  }]);\n  return ArrowRightCommand;\n}(base);\nmovement_defineProperty(ArrowRightCommand, "_name", KEYBOARD_COMMANDS.ARROW_RIGHT);\nvar ArrowUpCommand = /*#__PURE__*/function (_Command3) {\n  movement_inherits(ArrowUpCommand, _Command3);\n  var _super3 = movement_createSuper(ArrowUpCommand);\n  function ArrowUpCommand() {\n    movement_classCallCheck(this, ArrowUpCommand);\n    return _super3.apply(this, arguments);\n  }\n  movement_createClass(ArrowUpCommand, [{\n    key: "exec",\n    value: function exec() {\n      this._editor._range.disable();\n      var nextRow = this._editor._caret.getRow() - 1;\n      if (nextRow > -1) {\n        this._handler(nextRow);\n      }\n    }\n  }]);\n  return ArrowUpCommand;\n}(base);\nmovement_defineProperty(ArrowUpCommand, "_name", KEYBOARD_COMMANDS.ARROW_UP);\nvar ArrowDownCommand = /*#__PURE__*/function (_Command4) {\n  movement_inherits(ArrowDownCommand, _Command4);\n  var _super4 = movement_createSuper(ArrowDownCommand);\n  function ArrowDownCommand() {\n    movement_classCallCheck(this, ArrowDownCommand);\n    return _super4.apply(this, arguments);\n  }\n  movement_createClass(ArrowDownCommand, [{\n    key: "exec",\n    value: function exec() {\n      this._editor._range.disable();\n      var nextRow = this._editor._caret.getRow() + 1;\n      if (nextRow < this._editor._area.length()) {\n        this._handler(nextRow);\n      }\n    }\n  }]);\n  return ArrowDownCommand;\n}(base);\nmovement_defineProperty(ArrowDownCommand, "_name", KEYBOARD_COMMANDS.ARROW_DOWN);\nvar _mixin = {\n  _handler: function _handler(nextRow) {\n    var editor = this._editor;\n    var caret = editor._caret;\n    var row = caret.getRow();\n    var column = caret.getColumn();\n    var _column3 = movement_slicedToArray(column, 2),\n      elemidx = _column3[0],\n      offset = _column3[1];\n    var area = editor._area;\n    var line = area.get(row);\n    var currElem = line.get(elemidx);\n    var currElemReduceWidth = currElem.reduceWidth;\n    if (offset > 0) {\n      currElemReduceWidth += editor.measureTextWidth(currElem.getRenderSource(editor.spaceHolder).substring(0, offset));\n    }\n    var nextLine = area.get(nextRow);\n    var nextColumn = nextLine.getColumnNearest(currElemReduceWidth, editor.elementSpace, editor.fontSize, editor.fontFamily, editor);\n    caret.setRow(nextRow);\n    caret.setColumn(nextColumn);\n    caret.refresh();\n    editor.syncShadowInputPosition();\n    editor._jflow._render();\n  }\n};\nObject.assign(ArrowUpCommand.prototype, _mixin);\nObject.assign(ArrowDownCommand.prototype, _mixin);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/input.js\nfunction input_typeof(obj) { "@babel/helpers - typeof"; return input_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, input_typeof(obj); }\nfunction input_slicedToArray(arr, i) { return input_arrayWithHoles(arr) || input_iterableToArrayLimit(arr, i) || input_unsupportedIterableToArray(arr, i) || input_nonIterableRest(); }\nfunction input_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction input_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return input_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return input_arrayLikeToArray(o, minLen); }\nfunction input_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction input_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction input_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction input_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction input_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, input_toPropertyKey(descriptor.key), descriptor); } }\nfunction input_createClass(Constructor, protoProps, staticProps) { if (protoProps) input_defineProperties(Constructor.prototype, protoProps); if (staticProps) input_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction input_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) input_setPrototypeOf(subClass, superClass); }\nfunction input_setPrototypeOf(o, p) { input_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return input_setPrototypeOf(o, p); }\nfunction input_createSuper(Derived) { var hasNativeReflectConstruct = input_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = input_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = input_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return input_possibleConstructorReturn(this, result); }; }\nfunction input_possibleConstructorReturn(self, call) { if (call && (input_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return input_assertThisInitialized(self); }\nfunction input_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction input_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction input_getPrototypeOf(o) { input_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return input_getPrototypeOf(o); }\nfunction input_defineProperty(obj, key, value) { key = input_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction input_toPropertyKey(arg) { var key = input_toPrimitive(arg, "string"); return input_typeof(key) === "symbol" ? key : String(key); }\nfunction input_toPrimitive(input, hint) { if (input_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (input_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n\nfunction _blandAdjacentElement(editor, elem1, elem2, defaultOffset, records) {\n  if (!elem1) {\n    return [defaultOffset, false];\n  }\n  if (elem1.type === \'text\' && elem2.type === \'text\') {\n    var offset = elem1.source.length;\n    elem1.setSourceWithRecord(elem1.source + elem2.source, editor.spaceHolder, records);\n    elem1.setNeedWrap(elem2.needWrap, records);\n    return [offset, true];\n  }\n  return [defaultOffset, false];\n}\nvar Input = /*#__PURE__*/function (_Command) {\n  input_inherits(Input, _Command);\n  var _super = input_createSuper(Input);\n  function Input() {\n    var _this;\n    input_classCallCheck(this, Input);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    input_defineProperty(input_assertThisInitialized(_this), "cacheIdx", null);\n    return _this;\n  }\n  input_createClass(Input, [{\n    key: "exec",\n    value: function exec(kind, data) {\n      var editor = this._editor;\n      var range = editor._range;\n      var caret = editor._caret;\n      var flattenTxtElem = editor._flattenTxtElem;\n      var undoredo = editor._undoredo;\n      var records = flattenTxtElem.startRecord();\n      flattenTxtElem.recordBeforeCaret(caret);\n      // let _afterRangeDelete = false;\n      if (range.isEnable()) {\n        range["delete"](editor, records);\n        if (kind === KEYBOARD_INPUT.BACKSPACE || kind === KEYBOARD_INPUT.DELETE) {\n          flattenTxtElem.collectRecords();\n          flattenTxtElem.recordAfterCaret(caret);\n          this._editor.refresh();\n          undoredo.write(records, flattenTxtElem.getCaretRecord());\n          return;\n        } else {\n          this._editor.refresh();\n          // _afterRangeDelete = true;\n        }\n      }\n\n      var row = caret.getRow();\n      var _caret$getColumn = caret.getColumn(),\n        _caret$getColumn2 = input_slicedToArray(_caret$getColumn, 2),\n        elem_idx = _caret$getColumn2[0],\n        offset = _caret$getColumn2[1];\n      var area = editor._area;\n      var line = area.get(row);\n      var element = line.get(elem_idx);\n      var preElem = line.get(elem_idx - 1);\n      var content = \'\';\n      if (element.type === \'text\') {\n        content = element.source;\n      } else if ((preElem === null || preElem === void 0 ? void 0 : preElem.type) === \'text\') {\n        content = preElem.source;\n        element = preElem;\n        offset = content.length;\n        elem_idx -= 1;\n        caret.setColumn([elem_idx, content.length]);\n      } else {\n        var newElement = new TextElement(\'text\', \'\');\n        flattenTxtElem.insertBefore(element, newElement);\n        element = newElement;\n      }\n      var preContent = content.substring(0, offset);\n      var afterContent;\n      if (this.cacheIdx) {\n        afterContent = content.substring(this.cacheIdx[1]);\n      } else {\n        afterContent = content.substring(offset);\n      }\n      switch (kind) {\n        case KEYBOARD_INPUT.INPUT:\n          // if(_afterRangeDelete) {\n          //     element = flattenTxtElem.get(0);\n          //     afterContent = \'\';\n          //     preContent = \'\';\n          // }\n          if (/\\r?[\\n\\t]/.test(data)) {\n            var rows = data.split(/\\r?[\\n\\t]/) || \'\';\n            // source = source.replace(/\\t/, \'\');\n            var idx = flattenTxtElem.findIndex(element);\n            var _lastNeedWrap = element.needWrap;\n            element.setSourceWithRecord(preContent + rows.shift(), editor.spaceHolder, records);\n            element.setNeedWrap(true, records);\n            var temp = [];\n            var tn;\n            var _row = row;\n            var col;\n            while (rows.length) {\n              tn = new TextElement(\'text\', rows.shift());\n              tn.needWrap = true;\n              temp.push(tn);\n              _row++;\n            }\n            col = tn.source.length;\n            tn.source += afterContent;\n            tn.needWrap = _lastNeedWrap;\n            temp.forEach(function (t, i) {\n              flattenTxtElem.inersetAt(idx + 1 + i, t);\n            });\n            caret.setRow(_row);\n            caret.setColumn([0, col]);\n          } else {\n            preContent += data;\n            caret.setColumn(1, caret.getColumn(1) + data.length);\n            element.setSourceWithRecord(preContent + afterContent, editor.spaceHolder, records);\n          }\n          break;\n        case KEYBOARD_INPUT.COMPOSITION_START:\n          this.cacheIdx = [preContent.length, preContent.length];\n          break;\n        case KEYBOARD_INPUT.COMPOSITION_UPDATE:\n          preContent = preContent.substring(0, this.cacheIdx[0]);\n          preContent += data;\n          element.setSourceWithRecord(preContent + afterContent, editor.spaceHolder, records);\n          var _t = this.cacheIdx[0] + data.length;\n          caret.setColumn(1, _t);\n          this.cacheIdx[1] = _t;\n          break;\n        case KEYBOARD_INPUT.COMPOSITION_END:\n          preContent = preContent.substring(0, this.cacheIdx[0]);\n          caret.setColumn(1, this.cacheIdx[0] + data.length);\n          this.cacheIdx = null;\n          preContent += data;\n          element.setSourceWithRecord(preContent + afterContent, editor.spaceHolder, records);\n          break;\n        case KEYBOARD_INPUT.ENTER:\n          var lastNeedWrap = element.needWrap;\n          element.setSourceWithRecord(preContent, editor.spaceHolder, records);\n          element.setNeedWrap(true, records);\n          var t = new TextElement(\'text\', afterContent);\n          flattenTxtElem.insertAfter(element, t, lastNeedWrap);\n          caret.setRow(row + 1);\n          caret.setColumn([0, 0]);\n          break;\n        case KEYBOARD_INPUT.BACKSPACE:\n          var result = element.shift(offset, -1);\n          switch (result) {\n            case \'prev\':\n              var _idx = flattenTxtElem.findIndex(element);\n              if (elem_idx > 0) {\n                // 行内\n                flattenTxtElem.splice(_idx - 1, 1);\n                _idx -= 1;\n                // element.setSource(afterContent, records);\n                // element.dirty = true;\n                var _blandAdjacentElement2 = _blandAdjacentElement(editor, flattenTxtElem.get(_idx - 1), element, 0, records),\n                  _blandAdjacentElement3 = input_slicedToArray(_blandAdjacentElement2, 2),\n                  _offset = _blandAdjacentElement3[0],\n                  deleteop = _blandAdjacentElement3[1];\n                if (deleteop) {\n                  flattenTxtElem.remove(_idx);\n                }\n                caret.setColumn([elem_idx - (_offset > 0 || deleteop ? 2 : 1), _offset]);\n              } else if (_idx > 0) {\n                // 换行了\n                var preRow = row - 1;\n                var preElemidx = area.get(preRow).length() - 1;\n                var _blandAdjacentElement4 = _blandAdjacentElement(editor, flattenTxtElem.get(_idx - 1), element, 0, records),\n                  _blandAdjacentElement5 = input_slicedToArray(_blandAdjacentElement4, 2),\n                  _offset2 = _blandAdjacentElement5[0],\n                  _deleteop = _blandAdjacentElement5[1];\n                if (_deleteop) {\n                  flattenTxtElem.remove(_idx);\n                }\n                caret.setRow(preRow);\n                caret.setColumn([preElemidx, _offset2]);\n              }\n              break;\n            case \'self\':\n              preContent = preContent.substring(0, preContent.length - 1);\n              caret.setColumn(1, caret.getColumn(1) - 1);\n              element.setSourceWithRecord(preContent + afterContent, editor.spaceHolder, records);\n              break;\n          }\n          break;\n        case KEYBOARD_INPUT.DELETE:\n          var shiftresult = element.shift(offset, 1);\n          switch (shiftresult) {\n            case \'next\':\n              var _idx2 = flattenTxtElem.findIndex(element);\n              if (elem_idx < line.length() - 1) {\n                // 行内\n                flattenTxtElem.splice(_idx2 + 1, 1);\n                var nextElem = flattenTxtElem.get(_idx2 + 1);\n                var _blandAdjacentElement6 = _blandAdjacentElement(element, nextElem, element.source.length, records),\n                  _blandAdjacentElement7 = input_slicedToArray(_blandAdjacentElement6, 2),\n                  _offset3 = _blandAdjacentElement7[0],\n                  _deleteop2 = _blandAdjacentElement7[1];\n                if (_deleteop2) {\n                  flattenTxtElem.remove(_idx2 + 1);\n                }\n                caret.setColumn([elem_idx, _offset3]);\n              } else if (_idx2 < flattenTxtElem.length() - 1) {\n                // 换行了\n                var _nextElem = flattenTxtElem.get(_idx2 + 1);\n                var _blandAdjacentElement8 = _blandAdjacentElement(element, _nextElem, element.source.length, records),\n                  _blandAdjacentElement9 = input_slicedToArray(_blandAdjacentElement8, 2),\n                  _offset4 = _blandAdjacentElement9[0],\n                  _deleteop3 = _blandAdjacentElement9[1];\n                if (_deleteop3) {\n                  flattenTxtElem.remove(_idx2 + 1);\n                }\n                caret.setColumn([elem_idx, _offset4]);\n              }\n              break;\n            case \'self\':\n              afterContent = afterContent.substring(1);\n              element.setSourceWithRecord(preContent + afterContent, editor.spaceHolder, records);\n              break;\n          }\n          break;\n      }\n      flattenTxtElem.collectRecords();\n      flattenTxtElem.recordAfterCaret(caret);\n      undoredo.write(records, flattenTxtElem.getCaretRecord());\n      this._editor.refresh();\n    }\n  }]);\n  return Input;\n}(base);\ninput_defineProperty(Input, "_name", EDITOR_EVENTS.INPUT);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/mouse.js\nfunction mouse_typeof(obj) { "@babel/helpers - typeof"; return mouse_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, mouse_typeof(obj); }\nfunction mouse_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction mouse_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, mouse_toPropertyKey(descriptor.key), descriptor); } }\nfunction mouse_createClass(Constructor, protoProps, staticProps) { if (protoProps) mouse_defineProperties(Constructor.prototype, protoProps); if (staticProps) mouse_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction mouse_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) mouse_setPrototypeOf(subClass, superClass); }\nfunction mouse_setPrototypeOf(o, p) { mouse_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return mouse_setPrototypeOf(o, p); }\nfunction mouse_createSuper(Derived) { var hasNativeReflectConstruct = mouse_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = mouse_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = mouse_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return mouse_possibleConstructorReturn(this, result); }; }\nfunction mouse_possibleConstructorReturn(self, call) { if (call && (mouse_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return mouse_assertThisInitialized(self); }\nfunction mouse_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction mouse_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction mouse_getPrototypeOf(o) { mouse_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return mouse_getPrototypeOf(o); }\nfunction mouse_defineProperty(obj, key, value) { key = mouse_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction mouse_toPropertyKey(arg) { var key = mouse_toPrimitive(arg, "string"); return mouse_typeof(key) === "symbol" ? key : String(key); }\nfunction mouse_toPrimitive(input, hint) { if (mouse_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (mouse_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n\nvar StartEditCommand = /*#__PURE__*/function (_Command) {\n  mouse_inherits(StartEditCommand, _Command);\n  var _super = mouse_createSuper(StartEditCommand);\n  function StartEditCommand() {\n    mouse_classCallCheck(this, StartEditCommand);\n    return _super.apply(this, arguments);\n  }\n  mouse_createClass(StartEditCommand, [{\n    key: "exec",\n    value: function exec() {\n      var editor = this._editor;\n      if (!this._startEdit()) {\n        return;\n      }\n      var jflow = editor._jflow;\n      editor.moveCaretByHitPoint();\n      editor.createShadowInput();\n      editor._caret.animate(jflow);\n      editor.syncShadowInputPosition();\n    }\n  }, {\n    key: "_startEdit",\n    value: function _startEdit() {\n      var flag = true;\n      var editor = this._editor;\n      editor.dispatchEvent(new events(\'edit\', {\n        target: editor,\n        preventDefault: function preventDefault() {\n          flag = false;\n        }\n      }));\n      return flag;\n    }\n  }]);\n  return StartEditCommand;\n}(base);\nmouse_defineProperty(StartEditCommand, "_name", MOUSE_COMMANDS.START_EDIT);\nvar EditClickCommand = /*#__PURE__*/function (_Command2) {\n  mouse_inherits(EditClickCommand, _Command2);\n  var _super2 = mouse_createSuper(EditClickCommand);\n  function EditClickCommand() {\n    mouse_classCallCheck(this, EditClickCommand);\n    return _super2.apply(this, arguments);\n  }\n  mouse_createClass(EditClickCommand, [{\n    key: "exec",\n    value: function exec() {\n      var editor = this._editor;\n      editor.moveCaretByHitPoint();\n      editor._caret.refresh();\n      editor.syncShadowInputPosition();\n      editor._range.disable();\n    }\n  }]);\n  return EditClickCommand;\n}(base);\nmouse_defineProperty(EditClickCommand, "_name", MOUSE_COMMANDS.EDIT_CLICK);\nvar DoubleClickCommand = /*#__PURE__*/function (_Command3) {\n  mouse_inherits(DoubleClickCommand, _Command3);\n  var _super3 = mouse_createSuper(DoubleClickCommand);\n  function DoubleClickCommand() {\n    mouse_classCallCheck(this, DoubleClickCommand);\n    return _super3.apply(this, arguments);\n  }\n  mouse_createClass(DoubleClickCommand, [{\n    key: "exec",\n    value: function exec() {\n      var editor = this._editor;\n      editor.moveCaretByHitPoint();\n      var caret = editor._caret;\n      var range = editor._range;\n      var area = editor._area;\n      var row = caret.getRow();\n      var line = area.get(row);\n      var elem_idx = line.length() - 1;\n      range.setInitialRange([row, 0, 0]);\n      range.setRange([row, elem_idx, line.tail().tailOffset()]);\n      range.handleCaret(caret);\n      range.enable();\n      editor.syncShadowInputPosition();\n    }\n  }]);\n  return DoubleClickCommand;\n}(base);\nmouse_defineProperty(DoubleClickCommand, "_name", MOUSE_COMMANDS.DOUBLE_CLICK);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/shift.js\nfunction shift_typeof(obj) { "@babel/helpers - typeof"; return shift_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, shift_typeof(obj); }\nfunction shift_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction shift_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, shift_toPropertyKey(descriptor.key), descriptor); } }\nfunction shift_createClass(Constructor, protoProps, staticProps) { if (protoProps) shift_defineProperties(Constructor.prototype, protoProps); if (staticProps) shift_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction shift_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) shift_setPrototypeOf(subClass, superClass); }\nfunction shift_setPrototypeOf(o, p) { shift_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return shift_setPrototypeOf(o, p); }\nfunction shift_createSuper(Derived) { var hasNativeReflectConstruct = shift_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = shift_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = shift_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return shift_possibleConstructorReturn(this, result); }; }\nfunction shift_possibleConstructorReturn(self, call) { if (call && (shift_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return shift_assertThisInitialized(self); }\nfunction shift_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction shift_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction shift_getPrototypeOf(o) { shift_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return shift_getPrototypeOf(o); }\nfunction shift_defineProperty(obj, key, value) { key = shift_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction shift_toPropertyKey(arg) { var key = shift_toPrimitive(arg, "string"); return shift_typeof(key) === "symbol" ? key : String(key); }\nfunction shift_toPrimitive(input, hint) { if (shift_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (shift_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\nvar ShiftUpCommand = /*#__PURE__*/function (_Command) {\n  shift_inherits(ShiftUpCommand, _Command);\n  var _super = shift_createSuper(ShiftUpCommand);\n  function ShiftUpCommand() {\n    shift_classCallCheck(this, ShiftUpCommand);\n    return _super.apply(this, arguments);\n  }\n  shift_createClass(ShiftUpCommand, [{\n    key: "exec",\n    value: function exec() {\n      var range = this._editor._range;\n      range.setInitialRange(null);\n      this._editor.toggleShift(false);\n    }\n  }]);\n  return ShiftUpCommand;\n}(base);\nshift_defineProperty(ShiftUpCommand, "_name", KEYBOARD_COMMANDS.SHIFT_UP);\nvar ShiftDownCommand = /*#__PURE__*/function (_Command2) {\n  shift_inherits(ShiftDownCommand, _Command2);\n  var _super2 = shift_createSuper(ShiftDownCommand);\n  function ShiftDownCommand() {\n    shift_classCallCheck(this, ShiftDownCommand);\n    return _super2.apply(this, arguments);\n  }\n  shift_createClass(ShiftDownCommand, [{\n    key: "exec",\n    value: function exec() {\n      var range = this._editor._range;\n      var caret = this._editor._caret;\n      range.setInitialRange(caret.toRange());\n      this._editor.toggleShift(true);\n    }\n  }]);\n  return ShiftDownCommand;\n}(base);\nshift_defineProperty(ShiftDownCommand, "_name", KEYBOARD_COMMANDS.SHIFT_DOWN);\nvar ShiftOnClickCommand = /*#__PURE__*/function (_Command3) {\n  shift_inherits(ShiftOnClickCommand, _Command3);\n  var _super3 = shift_createSuper(ShiftOnClickCommand);\n  function ShiftOnClickCommand() {\n    shift_classCallCheck(this, ShiftOnClickCommand);\n    return _super3.apply(this, arguments);\n  }\n  shift_createClass(ShiftOnClickCommand, [{\n    key: "exec",\n    value: function exec() {\n      var editor = this._editor;\n      editor.moveCaretByHitPoint();\n      var caret = this._editor._caret;\n      var range = this._editor._range;\n      range.setRange(caret.toRange());\n      range.enable();\n      range.handleCaret(caret);\n      caret.refresh();\n      editor.syncShadowInputPosition();\n    }\n  }]);\n  return ShiftOnClickCommand;\n}(base);\nshift_defineProperty(ShiftOnClickCommand, "_name", MOUSE_COMMANDS.SHIFT_ON_CLICK);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/ctrl.js\nfunction ctrl_typeof(obj) { "@babel/helpers - typeof"; return ctrl_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, ctrl_typeof(obj); }\nfunction ctrl_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction ctrl_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, ctrl_toPropertyKey(descriptor.key), descriptor); } }\nfunction ctrl_createClass(Constructor, protoProps, staticProps) { if (protoProps) ctrl_defineProperties(Constructor.prototype, protoProps); if (staticProps) ctrl_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction ctrl_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) ctrl_setPrototypeOf(subClass, superClass); }\nfunction ctrl_setPrototypeOf(o, p) { ctrl_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return ctrl_setPrototypeOf(o, p); }\nfunction ctrl_createSuper(Derived) { var hasNativeReflectConstruct = ctrl_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = ctrl_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = ctrl_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return ctrl_possibleConstructorReturn(this, result); }; }\nfunction ctrl_possibleConstructorReturn(self, call) { if (call && (ctrl_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return ctrl_assertThisInitialized(self); }\nfunction ctrl_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction ctrl_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction ctrl_getPrototypeOf(o) { ctrl_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return ctrl_getPrototypeOf(o); }\nfunction ctrl_defineProperty(obj, key, value) { key = ctrl_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction ctrl_toPropertyKey(arg) { var key = ctrl_toPrimitive(arg, "string"); return ctrl_typeof(key) === "symbol" ? key : String(key); }\nfunction ctrl_toPrimitive(input, hint) { if (ctrl_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (ctrl_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\nvar CtrlACommand = /*#__PURE__*/function (_Command) {\n  ctrl_inherits(CtrlACommand, _Command);\n  var _super = ctrl_createSuper(CtrlACommand);\n  function CtrlACommand() {\n    ctrl_classCallCheck(this, CtrlACommand);\n    return _super.apply(this, arguments);\n  }\n  ctrl_createClass(CtrlACommand, [{\n    key: "exec",\n    value: function exec() {\n      var editor = this._editor;\n      var caret = editor._caret;\n      var range = editor._range;\n      var area = editor._area;\n      var row = area.length() - 1;\n      var line = area.get(row);\n      var elem_idx = line.length() - 1;\n      range.setInitialRange([0, 0, 0]);\n      range.setRange([row, elem_idx, line.tail().tailOffset()]);\n      range.handleCaret(caret);\n      range.enable();\n      editor.syncShadowInputPosition();\n    }\n  }]);\n  return CtrlACommand;\n}(base);\nctrl_defineProperty(CtrlACommand, "_name", KEYBOARD_COMMANDS.CTRLA);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/undoredo.js\nfunction command_undoredo_typeof(obj) { "@babel/helpers - typeof"; return command_undoredo_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, command_undoredo_typeof(obj); }\nfunction command_undoredo_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction command_undoredo_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, command_undoredo_toPropertyKey(descriptor.key), descriptor); } }\nfunction command_undoredo_createClass(Constructor, protoProps, staticProps) { if (protoProps) command_undoredo_defineProperties(Constructor.prototype, protoProps); if (staticProps) command_undoredo_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction undoredo_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) undoredo_setPrototypeOf(subClass, superClass); }\nfunction undoredo_setPrototypeOf(o, p) { undoredo_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return undoredo_setPrototypeOf(o, p); }\nfunction undoredo_createSuper(Derived) { var hasNativeReflectConstruct = undoredo_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = undoredo_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = undoredo_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return undoredo_possibleConstructorReturn(this, result); }; }\nfunction undoredo_possibleConstructorReturn(self, call) { if (call && (command_undoredo_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return undoredo_assertThisInitialized(self); }\nfunction undoredo_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction undoredo_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction undoredo_getPrototypeOf(o) { undoredo_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return undoredo_getPrototypeOf(o); }\nfunction command_undoredo_defineProperty(obj, key, value) { key = command_undoredo_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction command_undoredo_toPropertyKey(arg) { var key = command_undoredo_toPrimitive(arg, "string"); return command_undoredo_typeof(key) === "symbol" ? key : String(key); }\nfunction command_undoredo_toPrimitive(input, hint) { if (command_undoredo_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (command_undoredo_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\nvar UndoCommand = /*#__PURE__*/function (_Command) {\n  undoredo_inherits(UndoCommand, _Command);\n  var _super = undoredo_createSuper(UndoCommand);\n  function UndoCommand() {\n    command_undoredo_classCallCheck(this, UndoCommand);\n    return _super.apply(this, arguments);\n  }\n  command_undoredo_createClass(UndoCommand, [{\n    key: "exec",\n    value: function exec() {\n      this._editor._range.disable();\n      this._editor._undoredo.undo();\n      this._editor.refresh();\n    }\n  }]);\n  return UndoCommand;\n}(base);\ncommand_undoredo_defineProperty(UndoCommand, "_name", KEYBOARD_COMMANDS.UNDO);\nvar RedoCommand = /*#__PURE__*/function (_Command2) {\n  undoredo_inherits(RedoCommand, _Command2);\n  var _super2 = undoredo_createSuper(RedoCommand);\n  function RedoCommand() {\n    command_undoredo_classCallCheck(this, RedoCommand);\n    return _super2.apply(this, arguments);\n  }\n  command_undoredo_createClass(RedoCommand, [{\n    key: "exec",\n    value: function exec() {\n      this._editor._range.disable();\n      this._editor._undoredo.redo();\n      this._editor.refresh();\n    }\n  }]);\n  return RedoCommand;\n}(base);\ncommand_undoredo_defineProperty(RedoCommand, "_name", KEYBOARD_COMMANDS.REDO);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/clipboard.js\nfunction clipboard_typeof(obj) { "@babel/helpers - typeof"; return clipboard_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, clipboard_typeof(obj); }\nfunction clipboard_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction clipboard_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, clipboard_toPropertyKey(descriptor.key), descriptor); } }\nfunction clipboard_createClass(Constructor, protoProps, staticProps) { if (protoProps) clipboard_defineProperties(Constructor.prototype, protoProps); if (staticProps) clipboard_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction clipboard_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) clipboard_setPrototypeOf(subClass, superClass); }\nfunction clipboard_setPrototypeOf(o, p) { clipboard_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return clipboard_setPrototypeOf(o, p); }\nfunction clipboard_createSuper(Derived) { var hasNativeReflectConstruct = clipboard_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = clipboard_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = clipboard_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return clipboard_possibleConstructorReturn(this, result); }; }\nfunction clipboard_possibleConstructorReturn(self, call) { if (call && (clipboard_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return clipboard_assertThisInitialized(self); }\nfunction clipboard_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction clipboard_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction clipboard_getPrototypeOf(o) { clipboard_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return clipboard_getPrototypeOf(o); }\nfunction clipboard_defineProperty(obj, key, value) { key = clipboard_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction clipboard_toPropertyKey(arg) { var key = clipboard_toPrimitive(arg, "string"); return clipboard_typeof(key) === "symbol" ? key : String(key); }\nfunction clipboard_toPrimitive(input, hint) { if (clipboard_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (clipboard_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n\nvar CopyCommand = /*#__PURE__*/function (_Command) {\n  clipboard_inherits(CopyCommand, _Command);\n  var _super = clipboard_createSuper(CopyCommand);\n  function CopyCommand() {\n    clipboard_classCallCheck(this, CopyCommand);\n    return _super.apply(this, arguments);\n  }\n  clipboard_createClass(CopyCommand, [{\n    key: "exec",\n    value: function exec(event) {\n      var editor = this._editor;\n      var range = editor._range;\n      var content = range.getRangeCopy(editor);\n      if (content) {\n        event.clipboardData.setData("text/plain", content);\n      }\n    }\n  }]);\n  return CopyCommand;\n}(base);\nclipboard_defineProperty(CopyCommand, "_name", KEYBOARD_COMMANDS.COPY);\nvar CutCommand = /*#__PURE__*/function (_Command2) {\n  clipboard_inherits(CutCommand, _Command2);\n  var _super2 = clipboard_createSuper(CutCommand);\n  function CutCommand() {\n    clipboard_classCallCheck(this, CutCommand);\n    return _super2.apply(this, arguments);\n  }\n  clipboard_createClass(CutCommand, [{\n    key: "exec",\n    value: function exec(event) {\n      var editor = this._editor;\n      var range = editor._range;\n      var content = range.getRangeCopy(editor);\n      if (content) {\n        event.clipboardData.setData("text/plain", content);\n      }\n      if (range.isEnable()) {\n        var cmd = editor.commands.get(EDITOR_EVENTS.INPUT);\n        cmd.exec(KEYBOARD_INPUT.BACKSPACE);\n      }\n    }\n  }]);\n  return CutCommand;\n}(base);\nclipboard_defineProperty(CutCommand, "_name", KEYBOARD_COMMANDS.CUT);\nvar PasteCommand = /*#__PURE__*/function (_Command3) {\n  clipboard_inherits(PasteCommand, _Command3);\n  var _super3 = clipboard_createSuper(PasteCommand);\n  function PasteCommand() {\n    clipboard_classCallCheck(this, PasteCommand);\n    return _super3.apply(this, arguments);\n  }\n  clipboard_createClass(PasteCommand, [{\n    key: "exec",\n    value: function exec(pasteContent) {\n      var editor = this._editor;\n      if (pasteContent) {\n        var _preventDefault = false;\n        editor.dispatchEvent(new events(\'paste\', {\n          content: pasteContent,\n          preventDefault: function preventDefault() {\n            _preventDefault = true;\n          }\n        }));\n        if (!_preventDefault) {\n          var cmd = editor.commands.get(EDITOR_EVENTS.INPUT);\n          cmd.exec(KEYBOARD_INPUT.INPUT, pasteContent);\n        }\n      }\n    }\n  }]);\n  return PasteCommand;\n}(base);\nclipboard_defineProperty(PasteCommand, "_name", KEYBOARD_COMMANDS.PASTE);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/index.js\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./src/core/instance/text-group/text-group.js\nfunction text_group_typeof(obj) { "@babel/helpers - typeof"; return text_group_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, text_group_typeof(obj); }\nfunction text_group_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction text_group_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? text_group_ownKeys(Object(source), !0).forEach(function (key) { text_group_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : text_group_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction text_group_defineProperty(obj, key, value) { key = text_group_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction text_group_slicedToArray(arr, i) { return text_group_arrayWithHoles(arr) || text_group_iterableToArrayLimit(arr, i) || text_group_unsupportedIterableToArray(arr, i) || text_group_nonIterableRest(); }\nfunction text_group_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction text_group_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction text_group_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction text_group_toConsumableArray(arr) { return text_group_arrayWithoutHoles(arr) || text_group_iterableToArray(arr) || text_group_unsupportedIterableToArray(arr) || text_group_nonIterableSpread(); }\nfunction text_group_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction text_group_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return text_group_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return text_group_arrayLikeToArray(o, minLen); }\nfunction text_group_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\nfunction text_group_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return text_group_arrayLikeToArray(arr); }\nfunction text_group_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction text_group_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction text_group_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, text_group_toPropertyKey(descriptor.key), descriptor); } }\nfunction text_group_createClass(Constructor, protoProps, staticProps) { if (protoProps) text_group_defineProperties(Constructor.prototype, protoProps); if (staticProps) text_group_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction text_group_toPropertyKey(arg) { var key = text_group_toPrimitive(arg, "string"); return text_group_typeof(key) === "symbol" ? key : String(key); }\nfunction text_group_toPrimitive(input, hint) { if (text_group_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (text_group_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction text_group_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) text_group_setPrototypeOf(subClass, superClass); }\nfunction text_group_setPrototypeOf(o, p) { text_group_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return text_group_setPrototypeOf(o, p); }\nfunction text_group_createSuper(Derived) { var hasNativeReflectConstruct = text_group_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = text_group_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = text_group_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return text_group_possibleConstructorReturn(this, result); }; }\nfunction text_group_possibleConstructorReturn(self, call) { if (call && (text_group_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return text_group_assertThisInitialized(self); }\nfunction text_group_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction text_group_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction text_group_getPrototypeOf(o) { text_group_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return text_group_getPrototypeOf(o); }\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar TextGroup = /*#__PURE__*/function (_Node) {\n  text_group_inherits(TextGroup, _Node);\n  var _super = text_group_createSuper(TextGroup);\n  function TextGroup(configs) {\n    var _this;\n    text_group_classCallCheck(this, TextGroup);\n    _this = _super.call(this, configs);\n    _this.type = \'TextGroup\';\n    _this.initStack(configs);\n    _this.initLayout(configs);\n    _this._undoredo = new UndoRedo();\n    _this._undoredo._editor = text_group_assertThisInitialized(_this);\n    _this._caret = new caret();\n    _this._range = new range();\n    _this._shadowInput = undefined;\n    _this.textColor = configs.textColor || \'transparent\';\n    _this.fontFamily = configs.fontFamily || \'-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Tahoma,Arial,Noto Sans,PingFang SC,Microsoft YaHei,Hiragino Sans GB,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji\';\n    _this.fontSize = configs.fontSize || \'28px\';\n    _this.fontWeight = configs.fontWeight || \'\';\n    _this.elementSpace = configs.elementSpace || 5;\n    _this.lineSpace = configs.lineSpace || 5;\n    _this.placeholder = configs.placeholder || \'请输入\';\n    _this.placeholderColor = configs.placeholderColor || \'#eee\';\n    _this.cursorColor = configs.cursorColor || \'#60CFC4\';\n    _this.textRangeColor = configs.textRangeColor || \'#4E75EC1A\';\n    _this.minWidth = configs.minWidth || 0;\n    _this.spaceHolder = {\n      enable: false\n    };\n    if (configs.spacePlaceholder) {\n      Object.assign(_this.spaceHolder, {\n        enable: true,\n        spacePlaceholder: configs.spacePlaceholder,\n        spacePlaceholderColor: configs.spacePlaceholderColor,\n        returnFont: configs.returnFont\n      });\n    }\n    _this.resolver = function () {\n      var elements = configs.resolver();\n      if (elements.length === 0 || elements[elements.length - 1].type !== \'text\') {\n        elements.push(new TextElement(\'text\', \'\'));\n      }\n      elements.forEach(function (el) {\n        if (el.type === \'text\') {\n          el.setSource(el.source, _this.spaceHolder);\n        }\n      });\n      return elements;\n    };\n\n    // this._lines = [];\n    _this._area = new Area();\n    _this._flattenTxtElem = FlattenTextElements.create(_this.resolver());\n    _this._status = {\n      editing: false,\n      dragover: false\n    };\n    _this.commands = new Map();\n    _this.registCommand(StartEditCommand);\n    _this.registCommand(EditClickCommand);\n    _this.registCommand(ShiftUpCommand);\n    _this.registCommand(ShiftDownCommand);\n    _this.registCommand(ShiftOnClickCommand);\n    _this.registCommand(Input);\n    _this.registCommand(ArrowLeftCommand);\n    _this.registCommand(ArrowRightCommand);\n    _this.registCommand(ArrowUpCommand);\n    _this.registCommand(ArrowDownCommand);\n    _this.registCommand(CtrlACommand);\n    _this.registCommand(DoubleClickCommand);\n    // this.registCommand(ReturnCommand);\n    // this.registCommand(DeleteCommand);\n    _this.registCommand(UndoCommand);\n    _this.registCommand(RedoCommand);\n    _this.registCommand(CopyCommand);\n    _this.registCommand(CutCommand);\n    _this.registCommand(PasteCommand);\n    _this._makeFunctional();\n    _this._cacheViewBox = [];\n    return _this;\n  }\n  text_group_createClass(TextGroup, [{\n    key: "currentLineHeight",\n    get: function get() {\n      return this.lineHeight || parseInt(this.fontSize);\n    }\n  }, {\n    key: "registCommand",\n    value: function registCommand(cmd) {\n      if (!this.commands.has(cmd._name)) {\n        this.commands.set(cmd._name, cmd.create(this));\n      }\n    }\n  }, {\n    key: "_makeFunctional",\n    value: function _makeFunctional() {\n      var _this2 = this;\n      this.addEventListener(\'dblclick\', function (event) {\n        if (event.currentTarget !== _this2) {\n          return;\n        }\n        event.detail.bubbles = false;\n        if (_this2._status.editing) {\n          _this2.execCommand(MOUSE_COMMANDS.DOUBLE_CLICK);\n        }\n      });\n      this.addEventListener(\'click\', function (event) {\n        if (event.currentTarget !== _this2) {\n          return;\n        }\n        event.detail.bubbles = false;\n        var commnd;\n        if (_this2._status.editing) {\n          if (_this2._status.shiftOn) {\n            commnd = MOUSE_COMMANDS.SHIFT_ON_CLICK;\n          } else {\n            commnd = MOUSE_COMMANDS.EDIT_CLICK;\n          }\n        } else {\n          commnd = MOUSE_COMMANDS.START_EDIT;\n        }\n        _this2.execCommand(commnd);\n      });\n      this.addEventListener(\'blur\', function (event) {\n        _this2._status.editing = false;\n        if (_this2._shadowInput) {\n          // this._shadowInput.releaseEventListenr();\n          _this2._shadowInput.destroy();\n          _this2._shadowInput = undefined;\n        }\n        if (_this2._belongs) {\n          _this2._jflow._render();\n        }\n        _this2.dispatchEvent(new events(\'change\', {\n          target: _this2,\n          textElements: _this2._flattenTxtElem.copy()\n        }));\n        _this2._range.disable();\n        _this2._caret.cancelAnimate();\n      });\n      this.addEventListener(\'instancePressStart\', function (event) {\n        if (_this2._status.editing && !_this2._status.shiftOn) {\n          event.detail.bubbles = false;\n          event.detail.preventDefault();\n          // event.detail.jflow.setMovingTargets(null);\n          var point = _this2._currentp;\n          var c = _this2._positionToCursorOffset(point);\n          // this._cursor = c;\n          var range = _this2._range;\n          range.setInitialRange([c.row].concat(text_group_toConsumableArray(c.column)));\n          var jflow = event.detail.jflow;\n          var moved = false;\n          var t = function (e) {\n            _this2._status.editing = false;\n            moved = true;\n            var offsetX = e.offsetX,\n              offsetY = e.offsetY;\n            var p = jflow._calculatePointBack([offsetX, offsetY]);\n            jflow._stack.checkHit(p);\n            var point = _this2._currentp;\n            var c = _this2._positionToCursorOffset(point);\n            // this._cursor = c;\n            range.setRange([c.row].concat(text_group_toConsumableArray(c.column)));\n            range.enable();\n          }.bind(_this2);\n          document.addEventListener(\'pointermove\', t);\n          document.addEventListener(\'pointerup\', function (e) {\n            document.removeEventListener(\'pointermove\', t);\n            range.setInitialRange(null);\n            if (!moved) {\n              return;\n            }\n            range.handleCaret(_this2._caret);\n            _this2._status.editing = true;\n            _this2._shadowInput.focus();\n          }, {\n            once: true\n          });\n        }\n      });\n      this.addEventListener(\'dragenter\', function () {\n        _this2.moveCaretByHitPoint();\n        _this2._status.dragover = true;\n      });\n      this.addEventListener(\'dragover\', function () {\n        _this2.moveCaretByHitPoint();\n      });\n      this.addEventListener(\'dragleave\', function () {\n        _this2._status.dragover = false;\n      });\n      var onDrop = function (event) {\n        if (!_this2._status.dragover) {\n          return;\n        }\n        event.detail.bubbles = false;\n        _this2._status.dragover = false;\n        var caret = _this2._caret;\n        var row = caret.getRow();\n        var column = caret.getColumn();\n        var line = _this2._area.get(row);\n        var _column = text_group_slicedToArray(column, 2),\n          elemidx = _column[0],\n          offset = _column[1];\n        var element = line.get(elemidx);\n        var preElem = line.get(elemidx - 1);\n        var flattenTxtElem = _this2._flattenTxtElem;\n        var idx = flattenTxtElem.findIndex(element);\n        if (element.type !== \'text\' && (preElem === null || preElem === void 0 ? void 0 : preElem.type) === \'text\') {\n          offset = preElem.source.length;\n          idx = flattenTxtElem.findIndex(preElem);\n        }\n        var lastLength = flattenTxtElem.length();\n        _this2.dispatchEvent(new events(\'insert\', text_group_objectSpread(text_group_objectSpread({}, event.detail), {}, {\n          type: event.type,\n          textElements: flattenTxtElem.copy(),\n          idx: idx,\n          offset: offset\n        })));\n        // after insert\n        flattenTxtElem = _this2._flattenTxtElem;\n        if (_this2._status.editing) {\n          if (flattenTxtElem.length() > lastLength) {\n            caret.setColumn([elemidx + flattenTxtElem.length() - lastLength, 0]);\n          }\n          _this2._shadowInput.focus();\n        }\n        if (_this2._status.editing) {\n          _this2._caret.refresh();\n        }\n        _this2.syncShadowInputPosition();\n        _this2._range.disable();\n      }.bind(this);\n      this.addEventListener(\'pressEnd\', onDrop);\n      this.addEventListener(\'drop\', onDrop);\n    }\n  }, {\n    key: "toggleShift",\n    value: function toggleShift(val) {\n      this._status.shiftOn = val;\n    }\n  }, {\n    key: "execCommand",\n    value: function execCommand(kind, data) {\n      var cmd = this.commands.get(kind);\n      cmd.exec(data);\n    }\n  }, {\n    key: "createShadowInput",\n    value: function createShadowInput() {\n      var _this3 = this;\n      var jflow = this._jflow;\n      var shadowInput = new shadow_input(jflow.DOMwrapper);\n      var _a = function _a(e) {\n        var kind = e.detail.kind;\n        var data = e.detail.data;\n        _this3.execCommand(kind, data);\n      };\n      var _b = function _b(e) {\n        var kind = e.detail.kind;\n        var data = e.detail.data;\n        var cmd = _this3.commands.get(EDITOR_EVENTS.INPUT);\n        cmd.exec(kind, data);\n      };\n      shadowInput.addEventListener(EDITOR_EVENTS.CONTROL_CMD, _a);\n      shadowInput.addEventListener(EDITOR_EVENTS.INPUT, _b);\n      shadowInput.removeLisenter = function () {\n        shadowInput.removeEventListener(EDITOR_EVENTS.CONTROL_CMD, _a);\n        shadowInput.removeEventListener(EDITOR_EVENTS.INPUT, _b);\n        shadowInput.removeLisenter = null;\n      };\n      this._shadowInput = shadowInput;\n      this._status.editing = true;\n      jflow.setFocusInstance(this);\n    }\n  }, {\n    key: "moveCaretByHitPoint",\n    value: function moveCaretByHitPoint() {\n      var point = this._currentp;\n      var caret = this._caret;\n      var _this$_positionToCurs = this._positionToCursorOffset(point),\n        row = _this$_positionToCurs.row,\n        column = _this$_positionToCurs.column;\n      caret.setRow(row);\n      caret.setColumn(column);\n    }\n  }, {\n    key: "refresh",\n    value: function refresh() {\n      this.recalculateUp();\n      this.syncShadowInputPosition();\n      this._jflow._render();\n    }\n  }, {\n    key: "refreshTextElements",\n    value: function refreshTextElements() {\n      this._flattenTxtElem = FlattenTextElements.create(this.resolver());\n    }\n  }, {\n    key: "_positionToCursorOffset",\n    value: function _positionToCursorOffset(point) {\n      var _point = text_group_slicedToArray(point, 2),\n        x = _point[0],\n        y = _point[1];\n      // const [x0, y0] = this.anchor;\n      var area = this._area;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var offsetX = x + w;\n      var offsetY = y + h;\n      var row = area.getLineAbove(offsetY);\n      var currLine = area.get(row);\n      var column = currLine.getColumnNearest(offsetX, this.elementSpace, this.fontSize, this.fontFamily, this);\n      return {\n        row: row,\n        column: column\n      };\n    }\n  }, {\n    key: "_caretToPosition",\n    value: function _caretToPosition() {\n      var _this4 = this;\n      var row = this._caret.getRow();\n      var column = this._caret.getColumn();\n      var line = this._area.get(row);\n      var _column2 = text_group_slicedToArray(column, 2),\n        elemidx = _column2[0],\n        offset = _column2[1];\n      var meta = line.get(elemidx);\n      var idx = this._flattenTxtElem.findIndex(meta);\n      var preElem = this._flattenTxtElem.get(idx - 1);\n      var cw;\n      var c_len = this.currentLineHeight / 2;\n      if (meta.type === \'text\') {\n        var c = meta.getRenderSource(this.spaceHolder).substring(0, offset);\n        requestCacheCanvas(function (ctx) {\n          ctx.beginPath();\n          ctx.font = "".concat(_this4.fontSize, " ").concat(_this4.fontFamily);\n          cw = meta.anchorX - meta.width / 2 + ctx.measureText(c).width;\n        });\n      } else {\n        cw = meta.anchorX - meta.width / 2;\n        c_len = Math.max(c_len, meta.height / 2);\n      }\n      if (offset === 0 && preElem && preElem.type !== \'text\') {\n        c_len = Math.max(c_len, preElem.height / 2);\n      }\n      return [cw, c_len, line.anchorY, preElem, meta];\n    }\n  }, {\n    key: "syncShadowInputPosition",\n    value: function syncShadowInputPosition() {\n      if (this._status.editing) {\n        var _this$_caretToPositio = this._caretToPosition(),\n          _this$_caretToPositio2 = text_group_slicedToArray(_this$_caretToPositio, 3),\n          cw = _this$_caretToPositio2[0],\n          c_len = _this$_caretToPositio2[1],\n          anchorY = _this$_caretToPositio2[2];\n        var point = this.calculateToRealWorld([cw, anchorY + c_len]);\n        var canvasMeta = this._jflow.canvasMeta;\n        var px = Math.min(canvasMeta.actual_width - 120, point[0]);\n        // return [px, point[1]];\n        this._shadowInput.syncPosition(px, point[1]);\n        this._shadowInput.focus();\n      }\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      var _this5 = this;\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      } else if (this.opacity !== 1) {\n        ctx.globalAlpha = this.opacity;\n      }\n      var _this$anchor = text_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor[0],\n        cy = _this$anchor[1];\n      var jflow = this._jflow;\n      var area = this._area;\n      ctx.translate(cx, cy);\n      // ctx.beginPath();\n      // ctx.rect(-width/2, -height/2, width, height);\n      // ctx.stroke();\n      var flattenTxtElem = this._flattenTxtElem;\n      if (flattenTxtElem.isEmpty()) {\n        ctx.beginPath();\n        ctx.font = "".concat(this.fontWeight, " ").concat(this.fontSize, " ").concat(this.fontFamily);\n        ctx.textAlign = \'center\';\n        ctx.textBaseline = \'middle\';\n        ctx.fillStyle = this.placeholderColor;\n        ctx.fillText(this.placeholder, 0, 0);\n        this._randerCursor(ctx);\n        ctx.translate(-cx, -cy);\n        ctx.restore();\n        return;\n      }\n      ctx.beginPath();\n      ctx.font = "".concat(this.fontWeight, " ").concat(this.fontSize, " ").concat(this.fontFamily);\n      ctx.textAlign = \'center\';\n      ctx.textBaseline = \'middle\';\n      ctx.fillStyle = this.textColor;\n      area.forEach(function (line) {\n        line.forEach(function (el) {\n          if (el.type === \'text\') {\n            el.render(ctx, _this5.spaceHolder, _this5.textColor);\n            // ctx.fillText(el.source, el.anchorX, el.anchorY)\n          }\n        });\n      });\n\n      flattenTxtElem.forEach(function (elem) {\n        if (elem.type !== \'text\') {\n          var instance = jflow.getRenderNodeBySource(elem.source);\n          if (instance && instance.visible) {\n            ctx.save();\n            instance.render(ctx);\n            ctx.restore();\n          }\n        }\n      });\n      this._randerCursor(ctx);\n      this._renderRange(ctx);\n      ctx.translate(-cx, -cy);\n      ctx.restore();\n    }\n  }, {\n    key: "_randerCursor",\n    value: function _randerCursor(ctx) {\n      if (this._caret.isShow() && (this._status.editing || this._status.dragover)) {\n        var _this$_caretToPositio3 = this._caretToPosition(),\n          _this$_caretToPositio4 = text_group_slicedToArray(_this$_caretToPositio3, 3),\n          cw = _this$_caretToPositio4[0],\n          c_len = _this$_caretToPositio4[1],\n          anchorY = _this$_caretToPositio4[2];\n        ctx.beginPath();\n        ctx.moveTo(cw, anchorY - c_len);\n        ctx.lineTo(cw, anchorY + c_len);\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = this.cursorColor;\n        ctx.stroke();\n      }\n    }\n  }, {\n    key: "_renderRange",\n    value: function _renderRange(ctx) {\n      var range = this._range;\n      if (range.isEnable()) {\n        var area = this._area;\n        var textRangeColor = this.textRangeColor;\n        var blockheight = this.height;\n        var blockwidth = this.width;\n        var lineSpace = this.lineSpace;\n        var _range$getRangeFrom = range.getRangeFrom(),\n          _range$getRangeFrom2 = text_group_slicedToArray(_range$getRangeFrom, 3),\n          r_f = _range$getRangeFrom2[0],\n          idx_f = _range$getRangeFrom2[1],\n          offset_f = _range$getRangeFrom2[2];\n        var _range$getRangeTo = range.getRangeTo(),\n          _range$getRangeTo2 = text_group_slicedToArray(_range$getRangeTo, 3),\n          r_t = _range$getRangeTo2[0],\n          idx_t = _range$getRangeTo2[1],\n          offset_t = _range$getRangeTo2[2];\n        if (r_f === r_t) {\n          if (idx_f === idx_t && offset_f == offset_t) {\n            return;\n          }\n          var line = area.get(r_f);\n          var space = r_f === area.length() - 1 ? 0 : lineSpace;\n          var lty = line.reduceHeight - space - line.height - blockheight / 2;\n          var height = line.height;\n          var x1 = this._measureElementOffsetX(line.get(idx_f), offset_f, ctx);\n          var x2 = this._measureElementOffsetX(line.get(idx_t), offset_t, ctx);\n          ctx.beginPath();\n          ctx.rect(x1, lty, x2 - x1, height);\n          ctx.fillStyle = textRangeColor;\n          ctx.fill();\n        } else {\n          var _r = r_f;\n          var beginning = true;\n          while (_r <= r_t) {\n            var _line = area.get(_r);\n            var _space = _r === area.length() - 1 ? 0 : lineSpace;\n            var _lty = _line.reduceHeight - _space - _line.height - blockheight / 2;\n            var _height = _line.height;\n            if (beginning) {\n              var elem = _line.get(idx_f);\n              var x = this._measureElementOffsetX(elem, offset_f, ctx);\n              var lastElem = _line.tail();\n              var t = lastElem.anchorX + lastElem.width / 2;\n              ctx.beginPath();\n              ctx.rect(x, _lty, t - x, _height);\n              ctx.fillStyle = textRangeColor;\n              ctx.fill();\n            } else if (_r === r_t) {\n              var _elem = _line.get(idx_t);\n              var _x2 = this._measureElementOffsetX(_elem, offset_t, ctx);\n              ctx.beginPath();\n              ctx.rect(-blockwidth / 2, _lty, _elem.reduceWidth + (_x2 - _elem.anchorX + _elem.width / 2), _height);\n              ctx.fillStyle = textRangeColor;\n              ctx.fill();\n            } else {\n              ctx.beginPath();\n              ctx.rect(-blockwidth / 2, _lty, _line.width, _height);\n              ctx.fillStyle = textRangeColor;\n              ctx.fill();\n            }\n            beginning = false;\n            _r++;\n          }\n        }\n      }\n    }\n  }, {\n    key: "_measureElementOffsetX",\n    value: function _measureElementOffsetX(element, offset, ctx) {\n      if (element.type !== \'text\' || offset === 0) {\n        return element.anchorX - element.width / 2;\n      }\n      return element.anchorX - element.width / 2 + ctx.measureText(element.getRenderSource(this.spaceHolder).substring(0, offset)).width;\n    }\n  }, {\n    key: "measureTextWidth",\n    value: function measureTextWidth(content) {\n      var _this6 = this;\n      var t;\n      requestCacheCanvas(function (ctx) {\n        ctx.font = "".concat(_this6.fontSize, " ").concat(_this6.fontFamily);\n        t = ctx.measureText(content).width;\n      });\n      return t;\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        width: this.width,\n        height: this.height\n      };\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var ltx = anchor[0] - w;\n      var lty = anchor[1] - h;\n      var rbx = anchor[0] + w;\n      var rby = anchor[1] + h;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }, {\n    key: "_getViewBox",\n    value: function _getViewBox() {\n      var belongs_vbox = this._belongs.getCacheViewBox();\n      var cacheViewBox = this._cacheViewBox;\n      this._calculatePointBackWithPoint(belongs_vbox[0], belongs_vbox[1], cacheViewBox, 0, 1);\n      this._calculatePointBackWithPoint(belongs_vbox[2], belongs_vbox[3], cacheViewBox, 2, 3);\n      return this._cacheViewBox;\n    }\n  }, {\n    key: "getCacheViewBox",\n    value: function getCacheViewBox() {\n      return this._cacheViewBox;\n    }\n  }, {\n    key: "calculateToCoordination",\n    value: function calculateToCoordination(point) {\n      var _point2 = text_group_slicedToArray(point, 2),\n        gx = _point2[0],\n        gy = _point2[1];\n      var _this$anchor2 = text_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor2[0],\n        cy = _this$anchor2[1];\n      // const p = [cx + anchor[0] - spanH, cy + anchor[1] - spanV];\n      var p = [gx + cx, gy + cy];\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        return this._belongs.calculateToCoordination(p);\n      } else {\n        return p;\n      }\n    }\n  }, {\n    key: "calculateToRealWorld",\n    value: function calculateToRealWorld(point) {\n      var _point3 = text_group_slicedToArray(point, 2),\n        gx = _point3[0],\n        gy = _point3[1];\n      var _this$anchor3 = text_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor3[0],\n        cy = _this$anchor3[1];\n      var p = [gx + cx, gy + cy];\n      if (this._belongs && this._belongs.calculateToRealWorld) {\n        return this._belongs.calculateToRealWorld(p);\n      }\n    }\n  }, {\n    key: "calculateToRealWorldWithPointer",\n    value: function calculateToRealWorldWithPointer(outpoint, inpoint) {\n      outpoint[0] = inpoint[0] + this.anchor[0];\n      outpoint[1] = inpoint[1] + this.anchor[1];\n      if (this._belongs && this._belongs.calculateToRealWorldWithPointer) {\n        return this._belongs.calculateToRealWorldWithPointer(outpoint, outpoint);\n      }\n    }\n  }, {\n    key: "_calculatePointBack",\n    value: function _calculatePointBack(point) {\n      var _point4 = text_group_slicedToArray(point, 2),\n        gx = _point4[0],\n        gy = _point4[1];\n      var _this$anchor4 = text_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor4[0],\n        cy = _this$anchor4[1];\n      var p = [gx - cx, gy - cy];\n      return p;\n    }\n  }, {\n    key: "_calculatePointBackWithPoint",\n    value: function _calculatePointBackWithPoint(a, b, arr, idx1, idx2) {\n      arr[idx1] = a - this.anchor[0];\n      arr[idx2] = b - this.anchor[1];\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point, condition) {\n      var p = this._calculatePointBack(point);\n      var jflow = this._jflow;\n      this._currentp = p; // 暂存，为了后续计算别的位置\n      var validInstance = [];\n      var flattenTxtElem = this._flattenTxtElem;\n      flattenTxtElem.forEach(function (elem) {\n        if (elem.type !== \'text\') {\n          var instance = jflow.getRenderNodeBySource(elem.source);\n          if (instance.visible) {\n            validInstance.push(instance);\n          }\n        }\n      });\n      var target = this._stack.checkHit(p, condition, function (i) {\n        return validInstance.includes(i);\n      });\n      if (target) return target;\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      return point[0] > anchor[0] - w && point[0] < anchor[0] + w && point[1] > anchor[1] - h && point[1] < anchor[1] + h;\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      var _this7 = this;\n      var t = new shadow_cache({\n        width: this.width,\n        height: this.height,\n        cache: function cache(ctx) {\n          var _this7$anchor = text_group_slicedToArray(_this7.anchor, 2),\n            cx = _this7$anchor[0],\n            cy = _this7$anchor[1];\n          ctx.translate(-cx + _this7.width / 2, -cy + _this7.height / 2);\n          _this7.render(ctx);\n        }\n      });\n      return t;\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      if (this._jflow._focus.instance === this) {\n        this._jflow.blur();\n      }\n    }\n  }]);\n  return TextGroup;\n}(node);\nObject.assign(TextGroup.prototype, stackMixin);\nObject.assign(TextGroup.prototype, layoutMixin);\nObject.assign(TextGroup.prototype, {\n  // 屏蔽这两个方法，只根据reflow重算\n  _getBoundingGroupRect: function _getBoundingGroupRect() {},\n  resetChildrenPosition: function resetChildrenPosition() {},\n  reflow: function reflow() {\n    var _this8 = this;\n    var lineHeight = this.currentLineHeight;\n    var flattenTxtElem = this._flattenTxtElem;\n    var area = this._area;\n    if (flattenTxtElem.isEmpty()) {\n      var width = 0;\n      var t = flattenTxtElem.get(0);\n      requestCacheCanvas(function (ctx) {\n        ctx.font = "".concat(_this8.fontSize, " ").concat(_this8.fontFamily);\n        width = ctx.measureText(_this8.placeholder).width;\n      });\n      var _line2 = area.truncate({\n        height: lineHeight,\n        reduceHeight: lineHeight\n      });\n      _line2.insert(0, t);\n      Object.assign(t, {\n        anchorX: -width / 2,\n        height: lineHeight,\n        isTail: true\n      });\n      this.width = width;\n      this.height = lineHeight;\n      return;\n    }\n    var jflow = this._jflow;\n    var spaceHolder = this.spaceHolder;\n    requestCacheCanvas(function (ctx) {\n      ctx.font = "".concat(_this8.fontSize, " ").concat(_this8.fontFamily);\n      flattenTxtElem.forEach(function (element) {\n        if (element.type === \'text\' && element.dirty) {\n          element.preCalculateText(ctx, spaceHolder);\n        }\n      });\n    });\n    var nextArea = new Area();\n    nextArea.truncate({\n      height: lineHeight\n    });\n    var line = nextArea.get(0);\n    var allHeight = 0;\n    var allWidth = 0;\n    var lastElem = null;\n    var lineSpace = this.lineSpace;\n    var elementSpace = this.elementSpace;\n    flattenTxtElem.forEach(function (element) {\n      line.push(element);\n      element.reduceWidth = line.width;\n      if (element.type === \'text\') {\n        element.height = lineHeight;\n        line.width += element.width;\n        if (element.needWrap) {\n          allHeight += line.height + lineSpace;\n          line.reduceHeight = allHeight;\n          allWidth = Math.max(line.width, allWidth);\n          line = Line.create({\n            height: lineHeight\n          });\n          nextArea.push(line);\n        }\n      } else {\n        var node = jflow.getRenderNodeBySource(element.source);\n        element.height = node.height;\n        line.height = Math.max(line.height, node.height);\n        var margin = !lastElem || lastElem.type === \'text\' ? elementSpace * 2 : elementSpace;\n        line.width += node.width + margin;\n      }\n      lastElem = element;\n    });\n    flattenTxtElem.tail().isTail = true;\n    allHeight += line.height;\n    line.reduceHeight = allHeight;\n    allWidth = Math.max(this.minWidth, Math.max(line.width, allWidth));\n    var hh = allHeight / 2;\n    var hw = allWidth / 2;\n    var ty = -hh;\n    var lastReduceY = 0;\n    nextArea.forEach(function (l) {\n      var height = l.height,\n        reduceHeight = l.reduceHeight;\n      var anchorY = ty + lastReduceY + height / 2;\n      l.anchorY = anchorY;\n      var reduceX = -hw;\n      var lastel = null;\n      l.forEach(function (el) {\n        if (el.type === \'text\') {\n          el.anchorY = anchorY;\n          el.anchorX = reduceX + el.width / 2;\n          reduceX += el.width;\n        } else {\n          var renderNode = jflow.getRenderNodeBySource(el.source);\n          var doubleMargin = !lastel || lastel.type === \'text\';\n          var margin = doubleMargin ? elementSpace * 2 : elementSpace;\n          el.width = renderNode.width;\n          el.anchorY = anchorY;\n          el.anchorX = reduceX + el.width / 2 + (doubleMargin ? margin / 2 : 0);\n          renderNode.anchor = [el.anchorX, el.anchorY];\n          reduceX += el.width + margin;\n        }\n        lastel = el;\n      });\n      lastReduceY = reduceHeight;\n    });\n    this._area = nextArea;\n    this.width = allWidth;\n    this.height = allHeight;\n  },\n  doRecalculate: function doRecalculate() {\n    if (this.__mounted__) {\n      this.recalculateUp();\n    } else {\n      this.recalculate();\n      this.__mounted__ = true;\n    }\n  }\n});\n/* harmony default export */ const text_group = (TextGroup);\n;// CONCATENATED MODULE: ./src/core/instance/node-placeholder.js\nfunction node_placeholder_typeof(obj) { "@babel/helpers - typeof"; return node_placeholder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, node_placeholder_typeof(obj); }\nfunction node_placeholder_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, node_placeholder_toPropertyKey(descriptor.key), descriptor); } }\nfunction node_placeholder_createClass(Constructor, protoProps, staticProps) { if (protoProps) node_placeholder_defineProperties(Constructor.prototype, protoProps); if (staticProps) node_placeholder_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction node_placeholder_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction node_placeholder_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) node_placeholder_setPrototypeOf(subClass, superClass); }\nfunction node_placeholder_setPrototypeOf(o, p) { node_placeholder_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return node_placeholder_setPrototypeOf(o, p); }\nfunction node_placeholder_createSuper(Derived) { var hasNativeReflectConstruct = node_placeholder_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = node_placeholder_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = node_placeholder_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return node_placeholder_possibleConstructorReturn(this, result); }; }\nfunction node_placeholder_possibleConstructorReturn(self, call) { if (call && (node_placeholder_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return node_placeholder_assertThisInitialized(self); }\nfunction node_placeholder_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction node_placeholder_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction node_placeholder_getPrototypeOf(o) { node_placeholder_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return node_placeholder_getPrototypeOf(o); }\nfunction node_placeholder_defineProperty(obj, key, value) { key = node_placeholder_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction node_placeholder_toPropertyKey(arg) { var key = node_placeholder_toPrimitive(arg, "string"); return node_placeholder_typeof(key) === "symbol" ? key : String(key); }\nfunction node_placeholder_toPrimitive(input, hint) { if (node_placeholder_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (node_placeholder_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n// export const PLACEHOLDER_SYMBOL = Symbol(\'PLACEHOLDER_SYMBOL\');\n\nvar NodePlaceholder = /*#__PURE__*/function (_Node) {\n  node_placeholder_inherits(NodePlaceholder, _Node);\n  var _super = node_placeholder_createSuper(NodePlaceholder);\n  function NodePlaceholder() {\n    var _this;\n    node_placeholder_classCallCheck(this, NodePlaceholder);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    node_placeholder_defineProperty(node_placeholder_assertThisInitialized(_this), "type", \'NODE_PLACEHOLDER\');\n    return _this;\n  }\n  return node_placeholder_createClass(NodePlaceholder);\n}(node);\n;// CONCATENATED MODULE: ./src/core/flow/index.js\nfunction flow_typeof(obj) { "@babel/helpers - typeof"; return flow_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, flow_typeof(obj); }\nfunction flow_slicedToArray(arr, i) { return flow_arrayWithHoles(arr) || flow_iterableToArrayLimit(arr, i) || flow_unsupportedIterableToArray(arr, i) || flow_nonIterableRest(); }\nfunction flow_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction flow_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return flow_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return flow_arrayLikeToArray(o, minLen); }\nfunction flow_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction flow_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction flow_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction flow_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction flow_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, flow_toPropertyKey(descriptor.key), descriptor); } }\nfunction flow_createClass(Constructor, protoProps, staticProps) { if (protoProps) flow_defineProperties(Constructor.prototype, protoProps); if (staticProps) flow_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction flow_toPropertyKey(arg) { var key = flow_toPrimitive(arg, "string"); return flow_typeof(key) === "symbol" ? key : String(key); }\nfunction flow_toPrimitive(input, hint) { if (flow_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (flow_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction flow_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) flow_setPrototypeOf(subClass, superClass); }\nfunction flow_createSuper(Derived) { var hasNativeReflectConstruct = flow_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = flow_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = flow_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return flow_possibleConstructorReturn(this, result); }; }\nfunction flow_possibleConstructorReturn(self, call) { if (call && (flow_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return flow_assertThisInitialized(self); }\nfunction flow_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction flow_wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; flow_wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !flow_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return flow_construct(Class, arguments, flow_getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return flow_setPrototypeOf(Wrapper, Class); }; return flow_wrapNativeSuper(Class); }\nfunction flow_construct(Parent, args, Class) { if (flow_isNativeReflectConstruct()) { flow_construct = Reflect.construct.bind(); } else { flow_construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) flow_setPrototypeOf(instance, Class.prototype); return instance; }; } return flow_construct.apply(null, arguments); }\nfunction flow_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction flow_isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }\nfunction flow_setPrototypeOf(o, p) { flow_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return flow_setPrototypeOf(o, p); }\nfunction flow_getPrototypeOf(o) { flow_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return flow_getPrototypeOf(o); }\n\n\n\n\n\n\n\n\n\n\n\n\n// import { setUniqueId, getUniqueId } from \'../utils/functions\';\n\n\n\n\n\n\n\n\n\n\n// import { createInputTextStyle } from \'../instance/text\';\n// createInputTextStyle();\n/**\n * @funtion setInitialPosition\n * @param {Number} RealboxX - 内容映射到canvas上的 X\n * @param {Number} RealboxY - 内容映射到canvas上的 Y \n * @param {Number} RealboxW - 内容映射到canvas上的宽度\n * @param {Number} RealboxH - 内容映射到canvas上的高度 \n * @param {Number} CanvasWidth  - 视窗宽度\n * @param {Number} CanvasHeight  - 视窗高度\n * @return {Object} - 初始位置 { x, y }\n */\n\n/**\n * @funtion linkGen\n * @param {Node} from - 出发绘图节点\n * @param {Node} to - 临时节点，当前鼠标指的地方\n * @return {BaseeLink} - 连线对象\n */\n\n/** \n * @class Group\n * @classdesc 矩形组单元 由 {@link GroupFactory} 通过 {@link Rectangle} 生成\n * @groupfrom Rectangle\n * @augments GroupTemplate\n * @augments Rectangle\n * @param {(Rectangle~RectangleConfigs|GroupTemplate~GroupConfigs)} configs - 配置\n */\nvar Group = groupFactory(rectangle);\n/** \n * @class CapsuleGroup\n * @classdesc 胶囊组单元 由 {@link GroupFactory} 通过 {@link Capsule} 生成\n * @groupfrom Capsule\n * @augments GroupTemplate\n * @augments Capsule\n * @param {(Capsule~CapsuleConfigs|GroupTemplate~GroupConfigs)} configs - 配置\n */\nvar CapsuleGroup = groupFactory(capsule);\n/** \n * @class RhombusGroup\n * @classdesc 菱形组单元 由 {@link GroupFactory} 通过 {@link Rhombus} 生成\n * @augments GroupTemplate\n * @augments Rhombus\n * @groupfrom Rhombus\n * @param {(Rhombus~RhombusConfigs|GroupTemplate~GroupConfigs)} configs - 配置\n */\nvar RhombusGroup = groupFactory(rhombus);\n/** \n * @class DiamondGroup\n * @classdesc 钻石形组单元 由 {@link GroupFactory} 通过 {@link Diamond} 生成\n * @groupfrom Diamond\n * @augments GroupTemplate\n * @augments Diamond\n * @param {(Diamond~DiamondConfigs|GroupTemplate~GroupConfigs)} configs - 配置\n */\nvar DiamondGroup = groupFactory(diamond, {\n  shapeShift: function shapeShift(width, height) {\n    return [width + height * 0.28865, height];\n  }\n});\n/** \n * @class DiamondVerticalGroup\n * @classdesc 垂直钻石形组单元 由 {@link GroupFactory} 通过 {@link DiamondVertical} 生成\n * @groupfrom DiamondVertical\n * @augments GroupTemplate\n * @augments DiamondVertical\n * @param {(Diamond~DiamondConfigs|GroupTemplate~GroupConfigs)} configs - 配置\n */\nvar DiamondVerticalGroup = groupFactory(diamond_vertical, {\n  shapeShift: function shapeShift(width, height) {\n    return [width, height + width * 0.5773];\n  }\n});\n/** \n * @class CapsuleVerticalGroup\n * @classdesc 垂直钻石形组单元 由 {@link GroupFactory} 通过 {@link CapsuleVertical} 生成\n * @groupfrom CapsuleVertical\n * @augments GroupTemplate\n * @augments CapsuleVertical\n * @param {(Capsule~CapsuleConfigs|GroupTemplate~GroupConfigs)} configs - 配置\n */\nvar CapsuleVerticalGroup = groupFactory(capsule_vertical);\nvar PointGroup = groupFactory(point, {\n  shapeShift: function shapeShift(width, height, p) {\n    var r = Math.ceil(Math.sqrt(width * width + height * height) / 2);\n    p.radius = r;\n    var w = r * 2;\n    return [w, w];\n  }\n});\n\n/**\n * @typedef JFlow~JFlowConfigs\n * @type {object}\n * @property {Boolean} allowDrop      - 是否允许 dragdrop\n * @property {Number} maxZoom         - 最大缩放\n * @property {Number} minZoom         - 最小缩放\n * @property {number} initialZoom     - 初始缩放比\n * @property {EventAdapter~pluginDef} eventAdapter\n */\n\n/**\n * @typedef {JFlow~JFlowConfigs | LayoutMixin~LayoutConfigs} JFlow~JFlowLayoutConfigs\n */\n/** \n * JFlow 对象\n * JFlow 是 canvas 上面封装的一个顶层对象，具有处理事件和绘制的功能\n * @constructor JFlow\n * @param {JFlow~JFlowLayoutConfigs} configs - 配置项\n * @mixes LayoutMixin\n * @mixes StackMixin\n * @mixes MessageMixin\n */\nvar JFlow = /*#__PURE__*/function (_EventTarget) {\n  flow_inherits(JFlow, _EventTarget);\n  var _super = flow_createSuper(JFlow);\n  function JFlow(configs) {\n    var _this;\n    flow_classCallCheck(this, JFlow);\n    _this = _super.call(this);\n    _this.uniqueName = \'jflow\';\n    /**\n     * @member {EventAdapter} eventAdapter    - eventAdapter 对象\n     **/\n    _this.eventAdapter = new adapter(configs.eventAdapter);\n    _this.initNodeWeakMap();\n    _this.initAnime();\n    _this.initStack(configs);\n    _this.initLayout(configs);\n    /** @member {Context2d}     - Context2d 对象 */\n    _this.ctx = null;\n    /** @member {Element}       - canvas 元素 */\n    _this.canvas = null;\n    /** @member {number}       - 设备DPR */\n    _this.dpr = 1;\n    /** @member {number}       - 内边距 */\n    _this.padding = 20;\n    _this.position = null;\n    /** @member {number}     - 缩放 */\n    _this.scale = null;\n    /** @member {number}     - 初始缩放 */\n    _this.initialZoom = configs.initialZoom;\n    /** @member {setInitialPosition} - 初始位置计算 */\n    _this.initialPosition = configs.setInitialPosition;\n    /** @member {number}     - 最大缩放 */\n    _this.maxZoom = configs.maxZoom || 3;\n    /** @member {number}     - 最小缩放 */\n    _this.minZoom = configs.minZoom || .5;\n    _this.NodeRenderTop = !!configs.NodeRenderTop;\n    _this.worldMargin = configs.worldMargin;\n    _this.draggingbehavior = Object.assign({\n      panInBorder: {\n        enable: true,\n        padding: 20,\n        deltamovement: 8,\n        allowMovingTargetInPan: true\n      }\n    }, configs.draggingbehavior || {});\n    _this.scrollBarBehavior = Object.assign({\n      enable: true\n    }, configs.scrollBarBehavior || {});\n    // this.initScale = 1;\n    // this.initPosition = null\n    _this.offeset = null;\n    _this._lastState = {\n      x: null,\n      y: null,\n      dragging: false,\n      processing: false\n    };\n    _this._lastDragState = {\n      target: null,\n      targetLink: null,\n      processing: false\n    };\n    _this._target = {\n      instance: null,\n      link: null,\n      moving: null,\n      isInstanceDirty: false,\n      isLinkDirty: false,\n      // isMovingDirty: false, \n      cache: {\n        stack: null,\n        belongs: null,\n        point: null\n      },\n      meta: {\n        x: undefined,\n        y: undefined,\n        initialX: undefined,\n        initialY: undefined\n      },\n      status: {\n        dragovering: false,\n        dragging: false,\n        processing: false,\n        movingState: false\n      }\n    };\n    _this._focus = {\n      instance: null\n    };\n    _this._dragOverTarget = null;\n    // this.lock = configs.lock;\n\n    _this.allowDrop = configs.allowDrop;\n    // 临时绘制的对象\n    _this._tempNode = null;\n    _this._tempLink = null;\n    _this.mode = JFLOW_MODE.DEFAULT;\n    _this._allowMovingTarget = true;\n    _this.canvasMeta = {};\n    _this._cacheViewBox = [];\n    _this.__mounted__ = false;\n\n    // this._allowZoom = true;\n    return _this;\n  }\n\n  // allowZoom() {\n  //     this._allowZoom = true;\n  // }\n\n  // abandonZoom() {\n  //     this._allowZoom = false;\n  // }\n  /**\n   * 设置当前拖动的 JFlow 对象\n   * @param {Object[]} targets - 具有 anchor 属性的对象\n   */\n  flow_createClass(JFlow, [{\n    key: "setMovingTargets",\n    value: function setMovingTargets(targets) {\n      Object.assign(this._target, {\n        moving: targets\n      });\n    }\n\n    /**\n     * 设置当前拖动的 JFlow 对象\n     * @param {Instance} instance - JFlow 对象\n     */\n  }, {\n    key: "setTempDraggingInstance",\n    value: function setTempDraggingInstance(instance) {\n      instance._belongs = this;\n      this._tempNode = instance;\n      Object.assign(this._target, {\n        moving: [this._tempNode],\n        dragging: true\n      });\n    }\n\n    /**\n     * 取消当前拖动的 JFlow 对象\n     * @return {number[]} point - JFlow 坐标\n     */\n  }, {\n    key: "removeTempDraggingInstance",\n    value: function removeTempDraggingInstance() {\n      if (this._tempNode) {\n        // this.removeFromStack(this._tempNode);\n        var anchor = this._tempNode.anchor;\n        this._tempNode = null;\n        return anchor;\n      }\n    }\n    /**\n     * 关闭默认对象拖动效果\n     */\n  }, {\n    key: "preventDefaultDragging",\n    value: function preventDefaultDragging() {\n      this._allowMovingTarget = false;\n    }\n    /**\n     * 开启默认对象拖动效果\n     */\n  }, {\n    key: "allowDefaultDragging",\n    value: function allowDefaultDragging() {\n      this._allowMovingTarget = true;\n    }\n    /**\n     * 在 Document 元素上初始化实例\n     * @param {Element} dom \n     */\n  }, {\n    key: "$mount",\n    value: function $mount(dom) {\n      var _this2 = this;\n      var _createCanvas = createCanvas(dom),\n        canvas = _createCanvas.canvas,\n        ctx = _createCanvas.ctx,\n        dpr = _createCanvas.scale,\n        c_width = _createCanvas.width,\n        c_height = _createCanvas.height,\n        raw_width = _createCanvas.raw_width,\n        raw_height = _createCanvas.raw_height,\n        left = _createCanvas.left,\n        top = _createCanvas.top;\n      this.reflow();\n      this.ctx = ctx; //new CanvasContext2d(ctx, dpr);\n      this.DOMwrapper = dom;\n      this.canvas = canvas;\n      this.canvas.setAttribute(\'data-jflow\', true);\n      this.canvas.$jflow = this;\n      this.canvasMeta = {\n        width: raw_width,\n        height: raw_height,\n        actual_width: c_width,\n        actual_height: c_height\n      };\n      this.dpr = dpr;\n      this._getBoundingGroupRect();\n      var padding = this.padding;\n      var _this$bounding_box = this.bounding_box,\n        p_width = _this$bounding_box.width,\n        p_height = _this$bounding_box.height,\n        p_x = _this$bounding_box.x,\n        p_y = _this$bounding_box.y;\n      var contentBox = {\n        x: padding,\n        y: padding,\n        width: c_width - padding * 2,\n        height: c_height - padding * 2\n      };\n      var position = {\n        x: 0,\n        y: 0,\n        offsetX: 0,\n        offsetY: 0\n      };\n      var w_ratio = contentBox.width / p_width;\n      var h_ratio = contentBox.height / p_height;\n      var align = w_ratio <= h_ratio ? \'x\' : \'y\';\n      var scaleRatio;\n      if (this.initialZoom) {\n        scaleRatio = this.initialZoom;\n      } else {\n        scaleRatio = Math.min(w_ratio, h_ratio);\n      }\n      this.scale = scaleRatio;\n      if (scaleRatio > this.maxZoom) {\n        this.maxZoom = scaleRatio;\n      }\n      if (scaleRatio < this.minZoom) {\n        this.minZoom = scaleRatio;\n      }\n      var realboxX = p_x * scaleRatio;\n      var realboxY = p_y * scaleRatio;\n      var realboxW = contentBox.width;\n      var realboxH = contentBox.height;\n      if (this.initialPosition) {\n        var _this$initialPosition = this.initialPosition(realboxX, realboxY, realboxW, realboxH, contentBox.x, contentBox.y, c_width, c_height, p_x, p_y, p_width, p_height),\n          x = _this$initialPosition.x,\n          y = _this$initialPosition.y;\n        position.x = x;\n        position.y = y;\n      } else {\n        position.x = align === \'x\' ? contentBox.x : (realboxW - p_width * scaleRatio) / 2 + padding;\n        position.y = align === \'y\' ? contentBox.y : (realboxH - p_height * scaleRatio) / 2 + padding;\n      }\n      position.offsetX = position.x - realboxX;\n      position.offsetY = position.y - realboxY;\n      this.position = position;\n      this._readyToRender = true;\n      if (this.scrollBarBehavior.enable) {\n        this.initScrollBar(this.scrollBarBehavior);\n      }\n      // this.initSchedule();\n      // this.scheduleRender(() => {\n      //     this._createEventHandler();\n      // });\n      this.__render();\n      this._createEventHandler();\n      listenOnDevicePixelRatio(function (dpr) {\n        _this2.dpr = dpr;\n        // this.ctx.setDPR(dpr)\n        _this2.resizeCanvas();\n        _this2.scheduleRender();\n      }, function (handler) {\n        _this2.destroyDprListener = handler;\n      });\n      this.__mounted__ = true;\n    }\n\n    /**\n     * 设置Jflow进入连线模式\n     * @param {Object} source - 当前连线的出发原始数据\n     * @param {linkGen} linkGen - 生成连线单元的方法\n     */\n  }, {\n    key: "setLinkingMode",\n    value: function setLinkingMode(source, linkGen, isTail) {\n      var renderNode = this.getRenderNodeBySource(source);\n      this._tempNode = new ghostNode();\n      if (isTail) {\n        this._tempLink = linkGen({\n          from: this._tempNode,\n          to: renderNode\n        });\n      } else {\n        this._tempLink = linkGen({\n          from: renderNode,\n          to: this._tempNode\n        });\n      }\n      this.sendMessage({\n        instance: source\n      });\n      this.mode = JFLOW_MODE.LINKING;\n    }\n  }, {\n    key: "isInLinkingMode",\n    value: function isInLinkingMode() {\n      return this.mode === JFLOW_MODE.LINKING;\n    }\n\n    /**\n     * 连线模式下，设置当前临时连线的属性\n     * @param {BaseLink~Configs} configs - 当前连线的出发原始数据\n     */\n  }, {\n    key: "setLinkingLink",\n    value: function setLinkingLink(configs) {\n      if (this.mode === JFLOW_MODE.LINKING) {\n        this._tempLink.setConfig(configs);\n      }\n    }\n    /**\n     * 连线模式下，重连回临时鼠标节点\n     */\n  }, {\n    key: "resetLinkingLink",\n    value: function resetLinkingLink() {\n      if (this.mode === JFLOW_MODE.LINKING) {\n        this._tempLink.setConfig({\n          to: this._tempNode\n        });\n      }\n    }\n  }, {\n    key: "clearTemp",\n    value: function clearTemp() {\n      if (this._tempNode) {\n        this._tempNode.destroy();\n        this._tempNode = null;\n      }\n      if (this._tempLink) {\n        this._tempLink.destroy();\n        this._tempLink = null;\n      }\n      this._render();\n    }\n  }, {\n    key: "preventClearTemp",\n    value: function preventClearTemp() {\n      this._preventClearTemp = true;\n    }\n\n    /**\n     * 外层容器大小变化后，调用此方法可以改变当前canvas的状态\n     */\n  }, {\n    key: "resizeCanvas",\n    value: function resizeCanvas() {\n      if (this.canvas && this.DOMwrapper) {\n        var _resizeCanvas2 = canvas_resizeCanvas(this.canvas, this.DOMwrapper),\n          c_width = _resizeCanvas2.width,\n          c_height = _resizeCanvas2.height,\n          raw_width = _resizeCanvas2.raw_width,\n          raw_height = _resizeCanvas2.raw_height;\n        this.canvasMeta = {\n          width: raw_width,\n          height: raw_height,\n          actual_width: c_width,\n          actual_height: c_height\n        };\n      }\n    }\n  }, {\n    key: "setFocusInstance",\n    value: function setFocusInstance(node) {\n      this._focus.instance = node;\n    }\n\n    /**\n     * 移动画布到以目标绘图节点为中心的位置上\n     * @param {Node} node - 绘图节点\n     */\n  }, {\n    key: "focusOn",\n    value: function focusOn(node) {\n      var center = this._calculatePointBack([this.canvasMeta.actual_width / 2, this.canvasMeta.actual_height / 2]);\n      var offset = node.anchor;\n      if (node._belongs.calculateToCoordination) {\n        offset = node._belongs.calculateToCoordination(offset);\n      }\n      var deltaX = (center[0] - offset[0]) * this.scale;\n      var deltaY = (center[1] - offset[1]) * this.scale;\n      this._recalculatePosition(deltaX, deltaY);\n      this._render();\n    }\n  }, {\n    key: "_getBoundingGroupRect",\n    value: function _getBoundingGroupRect() {\n      var points = this._stack.getBoundingRectPoints();\n      if (this.bounding_box) {\n        this.bounding_box = bounding_box(points);\n        var _this$bounding_box2 = this.bounding_box,\n          nowx = _this$bounding_box2.x,\n          nowy = _this$bounding_box2.y;\n        var scale = this.scale;\n        this.position.x = this.position.offsetX + nowx * scale;\n        this.position.y = this.position.offsetY + nowy * scale;\n      } else {\n        this.bounding_box = bounding_box(points);\n      }\n    }\n  }, {\n    key: "_createEventHandler",\n    value: function _createEventHandler() {\n      var _this3 = this;\n      var canvas = this.canvas;\n      var destroyListener;\n      this.eventAdapter.apply(this);\n      var destroyPlainEventListener = function destroyPlainEventListener() {\n        _this3.eventAdapter.unload(_this3);\n        _this3.destroyDprListener();\n      };\n      destroyListener = destroyPlainEventListener;\n      if (this.allowDrop) {\n        var dragoverHandler = this._onDragover.bind(this);\n        var dropHandler = this._onDrop.bind(this);\n        var dragleaveHanlder = this._onDragLeave.bind(this);\n        canvas.addEventListener(\'dragstart\', function (e) {\n          e.preventDefault();\n        });\n        canvas.addEventListener(\'dragover\', dragoverHandler);\n        canvas.addEventListener(\'drop\', dropHandler);\n        canvas.addEventListener(\'dragleave\', dragleaveHanlder);\n        destroyListener = function destroyListener() {\n          destroyPlainEventListener();\n          canvas.removeEventListener(\'dragover\', dragoverHandler);\n          canvas.removeEventListener(\'drop\', dropHandler);\n          canvas.removeEventListener(\'dragleave\', dragleaveHanlder);\n        };\n      }\n      this.destroy = destroyListener;\n    }\n  }, {\n    key: "_targetLockOn",\n    value: function _targetLockOn(offsetPoint, event) {\n      var _this4 = this;\n      var point = this._calculatePointBack(offsetPoint);\n      var topLayerPoint = point;\n      this._currentp = point;\n      var stack = this._stack;\n      var br = this._getViewBox();\n      var target = stack.checkHit(point,\n      // 应用于所有\n      function (instance) {\n        return _this4._target.status.dragging && instance === _this4._getMovingTarget();\n      },\n      // 仅对于本层过滤\n      function (instance) {\n        return doOverlap(br, instance.getBoundingRect());\n      });\n      var linkStack = this._linkStack;\n      var belongs = this;\n      /*\n      if(target) {\n          linkStack = target._belongs._linkStack;\n          point = target._belongs._currentp;\n          stack = target._belongs._stack;\n          belongs = target._belongs\n      }*/\n      // 暂时设定只有顶层有连线\n      var targetLink;\n      if (!target || target._belongs === this) {\n        targetLink = linkStack.checkHit(point, function (link) {\n          if (!_this4._target.status.dragging) {\n            return false;\n          }\n          var movingtarget = _this4._getMovingTarget();\n          return link.from === movingtarget || link.to === movingtarget;\n        });\n      }\n      if (!targetLink) {\n        targetLink = linkStack.checkHit(point, function (link) {\n          return !link.ON_TOP;\n        });\n      }\n      Object.assign(this._target, {\n        instance: target,\n        link: targetLink,\n        isInstanceDirty: target === this._target.instance,\n        isLinkDirty: targetLink === this._target.link\n      });\n      Object.assign(this._target.cache, {\n        stack: stack,\n        belongs: belongs,\n        point: point,\n        topLayerPoint: topLayerPoint\n      });\n      Object.assign(this._target.meta, {\n        x: offsetPoint[0],\n        y: offsetPoint[1]\n      });\n      if (event === \'pressStart\' && !this._target.status.dragging && !this._target.status.dragovering) {\n        var movingtarget = target;\n        while (movingtarget && movingtarget._belongs.lock && movingtarget !== this) {\n          movingtarget = movingtarget._belongs;\n        }\n        this.setMovingTargets(movingtarget && [movingtarget]);\n        if (movingtarget) {\n          /**\n           * \n           * 开始拖拽时，拖拽对象设置之前\n           * @event Node#afterResolveMovingTarget\n           * @type {object}\n           * @property {Event} event           - 原始事件 \n           * @property {JFlow} jflow           - 当前JFlow对象 \n           * @property {Node} target           - 目标节点\n           */\n          target.bubbleEvent(new events(\'afterResolveMovingTarget\', {\n            event: event,\n            target: movingtarget,\n            jflow: this,\n            bubbles: true\n          }));\n        }\n      }\n      if ([\'pressStart\', \'click\', \'dblclick\', \'contextclick\'].includes(event)) {\n        if (this._focus.instance && this._focus.instance !== target) {\n          this._focus.instance.dispatchEvent(new events(\'blur\', {\n            relatedTarget: target\n          }));\n          this._focus.instance = null;\n        }\n      }\n      return this._target;\n    }\n  }, {\n    key: "blur",\n    value: function blur() {\n      if (this._focus.instance) {\n        this._focus.instance.dispatchEvent(new events(\'blur\', {\n          relatedTarget: null\n        }));\n        this._focus.instance = null;\n      }\n    }\n  }, {\n    key: "_getMovingTarget",\n    value: function _getMovingTarget() {\n      return this._target.moving && this._target.moving[0];\n    }\n  }, {\n    key: "_processDragOver",\n    value: function _processDragOver(instance, event) {\n      if (this._dragOverTarget !== instance) {\n        var _this$readMessage;\n        var target = (_this$readMessage = this.readMessage()) === null || _this$readMessage === void 0 ? void 0 : _this$readMessage.instance;\n        this._dragCurrentData = target;\n        var point = this._target.cache.point;\n        // console.log(\'_processDragOver\', this._dragOverTarget)\n        if (this._dragOverTarget) {\n          var oldIns = this._dragOverTarget;\n          /**\n          * dragleave 退出事件\n          * @event Instance#dragleave\n          * @type {object}\n          * @property {Event} event           - 原始事件 \n          * @property {Object} instance       - dragleave的对象 \n          * @property {target} target         - drag 携带的对象（特指从外面拖进canvas的对象） \n          */\n          oldIns.dispatchEvent(new events(\'dragleave\', {\n            event: event,\n            instance: oldIns,\n            target: target,\n            jflow: this,\n            point: point\n          }));\n        }\n        if (instance) {\n          /**\n          * dragenter 进入事件\n          * @event Instance#dragenter\n          * @type {object}\n          * @property {Event} event           - 原始事件 \n          * @property {Object} instance       - dragenter的对象 \n          * @property {target} target         - drag 携带的对象（特指从外面拖进canvas的对象） \n          */\n          instance.dispatchEvent(new events(\'dragenter\', {\n            event: event,\n            instance: instance,\n            target: target,\n            jflow: this,\n            point: point\n          }));\n        }\n        this._dragOverTarget = instance;\n      } else if (this._dragOverTarget) {\n        /**\n        * dragover 进入事件\n        * @event Instance#dragover\n        * @type {object}\n        * @property {Event} event           - 原始事件 \n        * @property {Object} instance       - dragover的对象 \n        * @property {target} target         - drag 携带的对象（特指从外面拖进canvas的对象） \n        */\n        this._dragOverTarget.dispatchEvent(new events(\'dragover\', {\n          event: event,\n          instance: instance,\n          jflow: this,\n          target: this._dragCurrentData\n        }));\n      }\n      this._processPanInBorder();\n    }\n  }, {\n    key: "_processPanInBorder",\n    value: function _processPanInBorder() {\n      var _this$draggingbehavio,\n        _this5 = this;\n      if ((_this$draggingbehavio = this.draggingbehavior) !== null && _this$draggingbehavio !== void 0 && (_this$draggingbehavio = _this$draggingbehavio.panInBorder) !== null && _this$draggingbehavio !== void 0 && _this$draggingbehavio.enable) {\n        if (!this.draggingbehavior.panInBorder.timer) {\n          this.draggingbehavior.panInBorder.timer = Date.now();\n        }\n        if (Date.now() - this.draggingbehavior.panInBorder.timer > 500) {\n          var _this$_cacheViewBox = flow_slicedToArray(this._cacheViewBox, 4),\n            x = _this$_cacheViewBox[0],\n            y = _this$_cacheViewBox[1],\n            w = _this$_cacheViewBox[2],\n            h = _this$_cacheViewBox[3];\n          var _this$_currentp = flow_slicedToArray(this._currentp, 2),\n            px = _this$_currentp[0],\n            py = _this$_currentp[1];\n          var _this$draggingbehavio2 = this.draggingbehavior.panInBorder,\n            padding = _this$draggingbehavio2.padding,\n            deltamovement = _this$draggingbehavio2.deltamovement;\n          var deltaX = 0;\n          var deltaY = 0;\n          if (px < x + padding) {\n            deltaX = deltamovement;\n          }\n          if (px > w - padding) {\n            deltaX = -deltamovement;\n          }\n          if (py < y + padding) {\n            deltaY = deltamovement;\n          }\n          if (py > h - padding) {\n            deltaY = -deltamovement;\n          }\n          if (this.__processOverAnime) {\n            this.__processOverAnime.cancel();\n          }\n          if (deltaX || deltaY) {\n            this.__processOverAnime = this.requestJFlowAnime(function () {\n              _this5.panHandler(deltaX, deltaY);\n            });\n          } else {\n            this.draggingbehavior.panInBorder.timer = null;\n          }\n        }\n      }\n    }\n  }, {\n    key: "_onDragover",\n    value: function _onDragover(event) {\n      var _this6 = this;\n      event.preventDefault();\n      event.stopPropagation();\n      if (this._lastDragState.processing) return;\n      this._lastDragState.processing = true;\n      var offsetX = event.offsetX,\n        offsetY = event.offsetY;\n      Object.assign(this._target.status, {\n        dragovering: true\n      });\n      this._targetLockOn([offsetX, offsetY]);\n      var instance = this._target.instance || this._target.link;\n      this._processDragOver(instance, event);\n      if (this._target.isLinkDirty || this._target.isInstanceDirty) {\n        Promise.resolve().then(function () {\n          // this._render();    \n          _this6._target.isLinkDirty = false;\n          _this6._target.isInstanceDirty = false;\n          _this6._lastDragState.processing = false;\n        });\n      } else {\n        this._lastDragState.processing = false;\n      }\n    }\n  }, {\n    key: "_cancelPanInBorder",\n    value: function _cancelPanInBorder() {\n      var _this$draggingbehavio3;\n      if (this.__processOverAnime) {\n        this.__processOverAnime.cancel();\n      }\n      if ((_this$draggingbehavio3 = this.draggingbehavior) !== null && _this$draggingbehavio3 !== void 0 && _this$draggingbehavio3.panInBorder) {\n        this.draggingbehavior.panInBorder.timer = null;\n      }\n    }\n  }, {\n    key: "_onDragLeave",\n    value: function _onDragLeave() {\n      this._cancelPanInBorder();\n    }\n  }, {\n    key: "_onDrop",\n    value: function _onDrop(event) {\n      var _this7 = this;\n      this._cancelPanInBorder();\n      var payload = this.consumeMessage();\n      var instance = payload === null || payload === void 0 ? void 0 : payload.instance;\n      if (this._dragOverTarget) {\n        var oldIns = this._dragOverTarget;\n        oldIns.dispatchEvent(new events(\'dragoverend\', {\n          event: event,\n          instance: oldIns\n        }));\n        this._dragOverTarget = null;\n      }\n      var _this$_target = this._target,\n        link = _this$_target.link,\n        target = _this$_target.instance;\n      var _this$_target$cache = this._target.cache,\n        point = _this$_target$cache.point,\n        belongs = _this$_target$cache.belongs;\n      if (link) {\n        /**\n         * 丢在线上事件\n         *\n         * @event BaseLink#drop\n         * @type {object}\n         * @property {Event} event           - 原始事件 \n         * @property {Object} instance       - 拖动的对象 \n         * @property {BaseLink} link         - 目标连线 \n         * @property {JFlow} jflow           - 当前JFlow对象 \n         * @property {Group|JFlow} belongs   - 连线所在的绘图栈的对象\n         * @property {number[]} point        - 已经计算到绘图栈对应坐标系下的坐标\n         */\n        // instance.anchor = point;\n        link.dispatchEvent(new events(\'drop\', {\n          event: event,\n          instance: instance,\n          link: link,\n          jflow: this,\n          belongs: belongs,\n          point: point\n        }));\n      } else if (target) {\n        /**\n         * 丢在节点上事件\n         *\n         * @event Node#drop\n         * @type {object}\n         * @property {Event} event           - 原始事件 \n         * @property {Object} instance       - 拖动的对象 \n         * @property {JFlow} jflow           - 当前JFlow对象 \n         * @property {Node} target           - 目标节点\n         * @property {number[]} point        - 已经计算到绘图栈对应坐标系下的坐标\n         */\n        target.bubbleEvent(new events(\'drop\', {\n          event: event,\n          instance: instance,\n          jflow: this,\n          target: target,\n          point: point,\n          bubbles: true\n        }));\n      } else {\n        /**\n        * 丢在主图上事件\n        *\n        * @event JFlow#drop\n        * @type {object}\n        * @property {Event} event           - 原始事件 \n        * @property {Object} instance       - 拖动的对象 \n        * @property {JFlow} jflow           - 当前JFlow对象 \n        * @property {number[]} point        - 已经计算到绘图栈对应坐标系下的坐标\n        */\n        this.dispatchEvent(new events(\'drop\', {\n          event: event,\n          instance: instance,\n          jflow: this,\n          target: target,\n          point: point\n        }));\n      }\n      requestAnimationFrame(function () {\n        _this7.cancelDrop();\n      });\n    }\n  }, {\n    key: "cancelDrop",\n    value: function cancelDrop() {\n      this._target.instance = null;\n      this._target.link = null;\n      Object.assign(this._target.status, {\n        dragovering: false\n      });\n    }\n\n    /**\n     * 缩放操作处理函数\n     * @param {Number} offsetX - 事件对象与canvas的内填充边（padding edge）在 X 轴方向上的偏移量。\n     * @param {Number} offsetY - 事件对象与canvas的内填充边（padding edge）在 Y 轴方向上的偏移量。 \n     * @param {Number} deltaX  - 水平滚动量\n     * @param {Number} deltaY  - 垂直滚动量\n     * @param {Number} event - 原生事件\n     */\n  }, {\n    key: "zoomHandler",\n    value: function zoomHandler(offsetX, offsetY, deltaX, deltaY, event) {\n      var _this8 = this;\n      // if(!this._allowZoom) return;\n      if (this._zooming) return;\n      this._zooming = true;\n      var _this$bounding_box3 = this.bounding_box,\n        p_width = _this$bounding_box3.width,\n        p_height = _this$bounding_box3.height,\n        x = _this$bounding_box3.x,\n        y = _this$bounding_box3.y;\n      var _this$canvasMeta = this.canvasMeta,\n        cw = _this$canvasMeta.actual_width,\n        ch = _this$canvasMeta.actual_height;\n      var minZoom = this.minZoom;\n      if (this.worldMargin) {\n        var m = this.worldMargin;\n        var maxWidth = p_width + m * 2;\n        var maxHeight = p_height + m * 2;\n        minZoom = Math.max(minZoom, Math.max(cw / maxWidth, ch / maxHeight));\n      }\n      var newScale = this.scale;\n      var amount = deltaY > 0 ? 1.05 : 1 / 1.05;\n      newScale *= amount;\n      newScale = Math.min(this.maxZoom, Math.max(minZoom, newScale));\n      // console.log(newScale);\n      // if (this.maxZoom && newScale > this.maxZoom){\n      //     // could just return but then won\'t stop exactly at maxZoom\n      //     newScale = this.maxZoom;\n      // }\n\n      // if(this.minZoom && newScale < this.minZoom) {\n      //     newScale = this.minZoom;\n      // }\n\n      var deltaScale = newScale - this.scale;\n      var currentWidth = p_width * this.scale;\n      var currentHeight = p_height * this.scale;\n      var deltaWidth = p_width * deltaScale;\n      var deltaHeight = p_height * deltaScale;\n      var tX = offsetX - this.position.x;\n      var tY = offsetY - this.position.y;\n      var pX = -tX / currentWidth;\n      var pY = -tY / currentHeight;\n      this.scale = newScale;\n      this._recalculatePosition(pX * deltaWidth, pY * deltaHeight);\n\n      // this.position.x += pX * deltaWidth;\n      // this.position.y += pY * deltaHeight;\n      // this.position.offsetX = this.position.x - x * newScale;\n      // this.position.offsetY = this.position.y - y * newScale;\n      this.dispatchEvent(new events(\'zoompan\', {\n        deltaX: 0,\n        deltaY: 0\n      }));\n      // this.setAnimeClock()\n      this.scheduleRender(function () {\n        _this8._zooming = false;\n      });\n      // requestAnimationFrame((timestamp) => {\n      //     this.setAnimeClock(timestamp);\n      //     this._render();\n      //     this._zooming = false;\n      // })\n    }\n    /**\n     * 平移画布操作处理函数\n     * @param {Number} deltaX  - 水平滚动量\n     * @param {Number} deltaY  - 垂直滚动量\n     * @param {Number} event - 原生事件\n     */\n  }, {\n    key: "panHandler",\n    value: function panHandler(deltaX, deltaY, event) {\n      var _this9 = this;\n      if (this._panning) return;\n      this._panning = true;\n      var dragging = this._target.status.dragging;\n      if (dragging) {\n        var movingtarget = this._target.moving;\n        if (movingtarget) {\n          if (this.draggingbehavior.panInBorder.allowMovingTargetInPan) {\n            movingtarget.forEach(function (t) {\n              t.anchor[0] += -deltaX / _this9.scale;\n              t.anchor[1] += -deltaY / _this9.scale;\n            });\n          }\n        }\n      }\n      this._recalculatePosition(deltaX, deltaY);\n      /**\n       * 缩放平移事件\n       *\n       * @event JFlow#zoompan\n      */\n      this.dispatchEvent(new events(\'zoompan\', {\n        deltaX: deltaX,\n        deltaY: deltaY\n      }));\n      this.scheduleRender(function () {\n        _this9._panning = false;\n      });\n      // requestAnimationFrame((timestamp) => {\n      //     this.setAnimeClock(timestamp);\n      //     this._render();\n      //     this._panning = false;\n      // })\n    }\n    /**\n     * 开始按压处理函数\n     * @param {Number} offsetX - 事件对象与canvas的内填充边（padding edge）在 X 轴方向上的偏移量。\n     * @param {Number} offsetY - 事件对象与canvas的内填充边（padding edge）在 Y 轴方向上的偏移量。 \n     * @param {Number} event - 原生事件\n     */\n  }, {\n    key: "pressStartHandler",\n    value: function pressStartHandler(offsetX, offsetY, event) {\n      var _this10 = this;\n      if (this.checkScrollDragging()) {\n        return;\n      }\n      Object.assign(this._target.meta, {\n        initialX: offsetX,\n        initialY: offsetY\n      });\n      var _this$_targetLockOn = this._targetLockOn([offsetX, offsetY], \'pressStart\'),\n        link = _this$_targetLockOn.link,\n        instance = _this$_targetLockOn.instance;\n      // 后续只支持 click 动作\n      if (this.mode === JFLOW_MODE.LINKING) return;\n      Object.assign(this._target.status, {\n        dragging: true,\n        processing: false\n      });\n      if (this._target.moving) {\n        var moving = this._getMovingTarget();\n        /**\n         * 开始拖动组的事件（特指lock的顶层组）\n         *\n         * @event Node#pressStart\n         * @type {object}\n         * @property {Event} event           - 原始事件 \n         * @property {Node} instance       - 拖动的对象 \n         * @property {JFlow} jflow           - 当前JFlow对象 \n         */\n        moving.dispatchEvent(new events(\'pressStart\', {\n          event: event,\n          instance: moving,\n          jflow: this\n        }));\n      }\n      var t = this._resolveLockOnTarget(link, instance);\n      if (t) {\n        /**\n         * 开始拖动对象事件（就是目标对象的拖动事件，事件支持冒泡）\n         *\n         * @event Node#instancePressStart\n         * @type {object}\n         * @property {Event} event           - 原始事件 \n         * @property {Node} instance     - 拖动的对象 \n         * @property {JFlow} jflow           - 当前JFlow对象 \n         * @property {Boolean} bubbles       - 冒泡\n         */\n        // const t = this._target.instance;\n        t.bubbleEvent(new events(\'instancePressStart\', {\n          event: event,\n          target: t,\n          jflow: this,\n          bubbles: true,\n          preventDefault: function preventDefault() {\n            _this10._preventPressSequeence = true;\n            _this10._clearTarget();\n            document.addEventListener(\'pointerup\', function (e) {\n              e.preventDefault();\n              e.stopPropagation();\n              _this10._preventPressSequeence = false;\n            }, {\n              once: true\n            });\n          }\n        }));\n      }\n      if (!this._preventPressSequeence) {\n        this.dispatchEvent(new events(\'jflowPressStart\', {\n          event: event,\n          jflow: this\n        }));\n      }\n    }\n    /**\n     * 按压中处理函数\n     * @param {Number} offsetX - 事件对象与canvas的内填充边（padding edge）在 X 轴方向上的偏移量。\n     * @param {Number} offsetY - 事件对象与canvas的内填充边（padding edge）在 Y 轴方向上的偏移量。 \n     * @param {Number} event - 原生事件\n     */\n  }, {\n    key: "pressMoveHandler",\n    value: function pressMoveHandler(offsetX, offsetY, event) {\n      var _this11 = this;\n      if (this._preventPressSequeence) {\n        return;\n      }\n      if (this.checkScrollDragging()) {\n        return;\n      }\n      var _this$_target$status = this._target.status,\n        dragging = _this$_target$status.dragging,\n        processing = _this$_target$status.processing;\n      var _this$_target$meta = this._target.meta,\n        x = _this$_target$meta.x,\n        y = _this$_target$meta.y;\n      // this.canvas.style.cursor = \'default\';\n      if (!dragging) {\n        if (this.checkScrollBarHover(offsetX, offsetY)) {\n          return;\n        } else {\n          this.resetScrollBarHover();\n        }\n      }\n      if (!dragging && !processing) {\n        var _this$_targetLockOn2 = this._targetLockOn([offsetX, offsetY]),\n          _link = _this$_targetLockOn2.link,\n          _instance = _this$_targetLockOn2.instance;\n        var t = this._resolveLockOnTarget(_link, _instance);\n        if (t) {\n          /**\n          * instance mousemove 原生事件，仅在无拖拽时触发\n          *\n          * @event Node#instancemousemove\n          * @type {object}\n          * @property {Event} event           - 原始事件\n          * @property {Node} instance           - 原始事件\n          * @property {JFlow} jflow           - 当前JFlow对象 \n          */\n          // instance.dispatchEvent(new JFlowEvent(\'instancemousemove\', {\n          //     event,\n          //     instance,\n          //     jflow: this,\n          // }))\n          t.bubbleEvent(new events(\'instancemousemove\', {\n            event: event,\n            instance: t,\n            jflow: this,\n            bubbles: true\n          }));\n        } else {\n          this.dispatchEvent(new events(\'instancemousemove\', {\n            event: event,\n            instance: null,\n            jflow: this\n          }));\n        }\n        if (this.mode === JFLOW_MODE.LINKING) {\n          // if(instance) {\n          //     instance.bubbleEvent(new JFlowEvent(\'linking\', {\n          //         event,\n          //         target: instance,\n          //         jflow: this,\n          //         bubbles: true,\n          //         callback: (p) => {\n          //             this._currentp = p;\n          //         }\n          //     }))\n          // }\n\n          this._tempNode.anchor = this._currentp;\n          this.scheduleRender(function () {\n            _this11._target.isLinkDirty = false;\n            _this11._target.isInstanceDirty = false;\n            _this11._target.status.processing = false;\n          });\n          this._processPanInBorder();\n          // requestAnimationFrame((timestamp) => {\n          //     this.setAnimeClock(timestamp);\n          //     this._render();\n          //     this._target.isLinkDirty = false; \n          //     this._target.isInstanceDirty = false;\n          //     this._target.status.processing = false;\n          // })\n          return;\n        }\n      }\n\n      /**\n       * canvas mousemove 原生事件\n       *\n       * @event JFlow#canvasmousemove\n       * @type {object}\n       * @property {Event} event           - 原始事件\n       * @property {JFlow} jflow           - 当前JFlow对象 \n       */\n      this.dispatchEvent(new events(\'canvasmousemove\', {\n        event: event,\n        jflow: this\n      }));\n      if (!dragging) return;\n      // this.canvas.style.cursor = \'grabbing\';\n      if (processing) return;\n      var movingtarget = this._target.moving; // this._tempNode ? [this._tempNode] : this._target.moving;\n      this._target.status.movingState = true;\n      this._target.status.processing = true;\n      var deltaX = offsetX - x;\n      var deltaY = offsetY - y;\n      if (movingtarget) {\n        if (this._allowMovingTarget) {\n          movingtarget.forEach(function (t) {\n            t.anchor[0] += deltaX / _this11.scale;\n            t.anchor[1] += deltaY / _this11.scale;\n          });\n        }\n      } else {\n        this._recalculatePosition(deltaX, deltaY);\n        this.dispatchEvent(new events(\'zoompan\', {\n          deltaX: deltaX,\n          deltaY: deltaY\n        }));\n      }\n      var _this$_targetLockOn3 = this._targetLockOn([offsetX, offsetY]),\n        instance = _this$_targetLockOn3.instance,\n        link = _this$_targetLockOn3.link;\n      this._processDragOver(instance || link, event);\n      this.scheduleRender(function () {\n        _this11._target.isLinkDirty = false;\n        _this11._target.isInstanceDirty = false;\n        _this11._target.status.processing = false;\n      });\n      // requestAnimationFrame((timestamp) => {\n      //     this._render();\n      //     this._target.isLinkDirty = false; \n      //     this._target.isInstanceDirty = false;\n      //     this._target.status.processing = false;\n      // })\n    }\n    /**\n     * 按压结束处理函数\n     * @param {Boolean} isDocument - 是否为 document 触发\n     * @param {Number} event - 原生事件\n     */\n  }, {\n    key: "pressUpHanlder",\n    value: function pressUpHanlder(isDocument, event) {\n      if (this._preventPressSequeence) {\n        return;\n      }\n      if (this.__processOverAnime) {\n        this.__processOverAnime.cancel();\n      }\n      this._dragOverTarget = null;\n      this._cancelPanInBorder();\n      // this.resetScollBarStatus();\n      var meta = this._target.meta;\n      if (this.mode === JFLOW_MODE.LINKING) {\n        var t = this._target.instance;\n        var payload = this.consumeMessage();\n        // console.log(payload)\n        var _preventDefault = false;\n        var preventDefault = function preventDefault() {\n          _preventDefault = true;\n        };\n        if (t) {\n          /**\n           * canvas mousemove 原生事件\n           *\n           * @event Node#link\n           * @type {object}\n           * @property {Event} event           - 原始事件\n           * @property {Node} target           - 原始事件\n           * @property {object} payload        - 传入的消息\n           * @property {JFlow} jflow           - 当前JFlow对象       - 当前JFlow对象 \n           */\n          t.bubbleEvent(new events(\'link\', {\n            event: event,\n            target: t,\n            jflow: this,\n            payload: payload,\n            bubbles: true,\n            link: this._tempLink,\n            preventDefault: preventDefault\n          }));\n        } else {\n          var offsetX = event.offsetX,\n            offsetY = event.offsetY;\n          this.dispatchEvent(new events(\'link\', {\n            event: event,\n            jflow: this,\n            payload: payload,\n            anchor: this._calculatePointBack([offsetX, offsetY]),\n            link: this._tempLink,\n            preventDefault: preventDefault\n          }));\n        }\n        if (_preventDefault) {\n          return;\n        }\n        this._clearTarget();\n        if (!this._preventClearTemp) {\n          if (this._tempNode) {\n            this._tempNode.destroy();\n            this._tempNode = null;\n          }\n          if (this._tempLink) {\n            this._tempLink.destroy();\n            this._tempLink = null;\n          }\n        }\n        this._preventClearTemp = false;\n        this.mode = JFLOW_MODE.DEFAULT;\n        this._render();\n        return;\n      }\n      if (this._target.moving) {\n        var checkresult = false;\n        if (this._layout["static"]) {\n          checkresult = this.staticCheck(this._getMovingTarget());\n        }\n        if (!checkresult && this._target.link) {\n          var _this$_target$cache2 = this._target.cache,\n            point = _this$_target$cache2.point,\n            belongs = _this$_target$cache2.belongs;\n          var link = this._target.link;\n          var instance = this._getMovingTarget();\n          /**\n           * 拖动到线上事件\n           *\n           * @event BaseLink#drop\n           * @type {object}\n           * @property {Event} event           - 原始事件 \n           * @property {Object} instance     - 拖动的对象 \n           * @property {BaseLink} link         - 目标连线 \n           * @property {JFlow} jflow           - 当前JFlow对象 \n           * @property {Group|JFlow} belongs   - 连线所在的绘图栈的对象\n           */\n          link.dispatchEvent(new events(\'drop\', {\n            event: event,\n            instance: instance,\n            link: link,\n            jflow: this,\n            belongs: belongs\n          }));\n          this._target.link = null;\n          this._target.instance = null;\n        } else if (this._target.moving) {\n          if (this._target.instance) {\n            /**\n             * 拖动后放置到 Instance 上的事件，由被拖动到的对象触发\n             *\n             * @event Node#pressEnd\n             * @type {object}\n             * @property {Event} event           - 原始事件 \n             * @property {Node} instance         - 拖动的对象 \n             * @property {JFlow} jflow           - 当前JFlow对象 \n             * @property {Instance} target       - 拖动到的对象\n             * @property {boolean} bubbles       - 冒泡\n             */\n            //  console.log(\'pressEnd\', this._target.instance)\n            this._target.instance.bubbleEvent(new events(\'pressEnd\', {\n              event: event,\n              instance: this._getMovingTarget(),\n              jflow: this,\n              target: this._target.instance,\n              bubbles: true\n            }));\n          } else {\n            /**\n             * 拖动后放置到主图上的事件\n             *\n             * @event JFlow#pressEnd\n             * @type {object}\n             * @property {Event} event           - 原始事件 \n             * @property {Instance} instance       - 拖动的对象 \n             * @property {JFlow} jflow           - 当前JFlow对象 \n             */\n            this.dispatchEvent(new events(\'pressEnd\', {\n              event: event,\n              instance: this._getMovingTarget(),\n              jflow: this\n            }));\n          }\n        }\n        this._target.moving = null;\n        this.removeTempDraggingInstance();\n        // this._target.isMovingDirty = false;\n        this._render();\n      }\n      this._clearTarget();\n    }\n    /**\n    * 菜单弹出处理函数\n    * @param {Number} offsetX - 事件对象与canvas的内填充边（padding edge）在 X 轴方向上的偏移量。\n    * @param {Number} offsetY - 事件对象与canvas的内填充边（padding edge）在 Y 轴方向上的偏移量。 \n    * @param {Number} event - 原生事件\n    */\n  }, {\n    key: "clickHanlder",\n    value: function clickHanlder(offsetX, offsetY, event) {\n      var _this$_targetLockOn4 = this._targetLockOn([offsetX, offsetY], \'click\'),\n        link = _this$_targetLockOn4.link,\n        instance = _this$_targetLockOn4.instance,\n        meta = _this$_targetLockOn4.meta;\n      if (Math.abs(meta.initialX - meta.x) < 1 && Math.abs(meta.initialY - meta.y) < 1) {\n        if (event.target !== this.canvas) {\n          this._clearTarget();\n          Object.assign(this._target.meta, {\n            initialX: undefined,\n            initialY: undefined\n          });\n          return;\n        }\n        var topLayerPoint = this._target.cache.topLayerPoint;\n        var t = this._resolveLockOnTarget(link, instance);\n        if (t) {\n          var target = t;\n          /**\n           * 点击事件（冒泡）\n           *\n           * @event Instance#contextclick\n           * @type {object}\n           * @property {Event} event           - 原始事件 \n           * @property {Instance} target       - 右键对象 \n           * @property {JFlow} jflow           - 当前JFlow对象\n           * @property {number[]} topLayerPoint  - jflow坐标系上的位置\n           * @property {Boolean} bubbles       - 冒泡\n           */\n          target.bubbleEvent(new events(\'click\', {\n            event: event,\n            jflow: this,\n            target: target,\n            topLayerPoint: topLayerPoint,\n            bubbles: true\n          }));\n        } else {\n          /**\n           * 点击事件\n           *\n           * @event JFlow#contextclick\n           * @type {object}\n           * @property {Event} event           - 原始事件 \n           * @property {JFlow} jflow           - 当前JFlow对象\n           * @property {number[]} topLayerPoint  - jflow坐标系上的位置\n           */\n          this.dispatchEvent(new events(\'click\', {\n            event: event,\n            jflow: this,\n            topLayerPoint: topLayerPoint\n          }));\n        }\n        this._clearTarget();\n        Object.assign(this._target.meta, {\n          initialX: undefined,\n          initialY: undefined\n        });\n      }\n    }\n    /**\n     * 菜单弹出处理函数\n     * @param {Number} offsetX - 事件对象与canvas的内填充边（padding edge）在 X 轴方向上的偏移量。\n     * @param {Number} offsetY - 事件对象与canvas的内填充边（padding edge）在 Y 轴方向上的偏移量。 \n     * @param {Number} event - 原生事件\n     */\n  }, {\n    key: "contextMenuHanlder",\n    value: function contextMenuHanlder(offsetX, offsetY, event) {\n      var _this$_targetLockOn5 = this._targetLockOn([offsetX, offsetY], \'contextclick\'),\n        link = _this$_targetLockOn5.link,\n        instance = _this$_targetLockOn5.instance;\n      var topLayerPoint = this._target.cache.topLayerPoint;\n      var t = this._resolveLockOnTarget(link, instance);\n      if (t) {\n        var target = t;\n        /**\n         * 右键事件（冒泡）\n         *\n         * @event Instance#contextclick\n         * @type {object}\n         * @property {Event} event           - 原始事件 \n         * @property {Instance} target       - 右键对象 \n         * @property {JFlow} jflow           - 当前JFlow对象\n         * @property {number[]} topLayerPoint  - jflow坐标系上的位置\n         * @property {Boolean} bubbles       - 冒泡\n         */\n        target.bubbleEvent(new events(\'contextclick\', {\n          event: event,\n          jflow: this,\n          target: target,\n          topLayerPoint: topLayerPoint,\n          bubbles: true\n        }));\n      } else {\n        /**\n         * 右键事件\n         *\n         * @event JFlow#contextclick\n         * @type {object}\n         * @property {Event} event           - 原始事件 \n         * @property {JFlow} jflow           - 当前JFlow对象\n         * @property {number[]} topLayerPoint  - jflow坐标系上的位置\n         */\n        this.dispatchEvent(new events(\'contextclick\', {\n          event: event,\n          jflow: this,\n          topLayerPoint: topLayerPoint\n        }));\n      }\n    }\n  }, {\n    key: "dblclickHandler",\n    value: function dblclickHandler(offsetX, offsetY, event) {\n      var _this$_targetLockOn6 = this._targetLockOn([offsetX, offsetY], \'dblclick\'),\n        link = _this$_targetLockOn6.link,\n        instance = _this$_targetLockOn6.instance;\n      var topLayerPoint = this._target.cache.topLayerPoint;\n      var t = this._resolveLockOnTarget(link, instance);\n      if (t) {\n        var target = t;\n        /**\n         * 右键事件\n         *\n         * @event Instance#dblclick\n         * @type {object}\n         * @property {Event} event           - 原始事件 \n         * @property {Instance} target       - 右键对象 \n         * @property {JFlow} jflow           - 当前JFlow对象\n         * @property {number[]} topLayerPoint  - jflow坐标系上的位置\n         * @property {Boolean} bubbles       - 冒泡\n         */\n        target.bubbleEvent(new events(\'dblclick\', {\n          event: event,\n          jflow: this,\n          target: target,\n          topLayerPoint: topLayerPoint,\n          bubbles: true\n        }));\n      } else {\n        this.dispatchEvent(new events(\'dblclick\', {\n          event: event,\n          jflow: this,\n          topLayerPoint: topLayerPoint\n        }));\n      }\n    }\n\n    /*_onZoom(event) {\n        event.preventDefault();\n        let { offsetX, offsetY, deltaX, deltaY } = event\n        if(event.ctrlKey) { \n            deltaY = -deltaY;\n            this.zoomHandler(offsetX, offsetY, deltaX, deltaY);\n        } else {\n            this.panHandler(-deltaX, -deltaY);\n        }\n    }\n     _onPressStart(event) { \n        const { offsetX, offsetY, deltaY, button } = event\n        if(button !== 0) return;\n        this.pressStartHandler(offsetX, offsetY);\n    }\n     _onPressMove(event) {\n        const { offsetX, offsetY } = event\n        this.pressMoveHandler(offsetX, offsetY);\n    }\n     _onPressUp(event, isDocument) {\n        event.preventDefault();\n        event.stopPropagation();\n        const { button } = event\n        if(button !== 0) return;\n        this.pressUpHanlder(isDocument)\n    }\n     _onPressUpDocument(event) {\n        this._onPressUp(event, true);\n    }\n     _onContextMenu(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        const { offsetX, offsetY } = event;\n        this.contextMenuHanlder(offsetX, offsetY);\n    }*/\n  }, {\n    key: "_resolveLockOnTarget",\n    value: function _resolveLockOnTarget(link, instance) {\n      return link !== null && link !== void 0 && link.ON_TOP ? link : instance || link;\n    }\n  }, {\n    key: "_clearTarget",\n    value: function _clearTarget() {\n      Object.assign(this._target.meta, {\n        x: undefined,\n        y: undefined\n        // initialX: undefined,\n        // initialY: undefined, \n      });\n\n      Object.assign(this._target.status, {\n        dragging: false,\n        processing: false,\n        movingState: false\n      });\n      Object.assign(this._target, {\n        instance: null,\n        link: null,\n        moving: null\n      });\n    }\n  }, {\n    key: "_recalculatePosition",\n    value: function _recalculatePosition(deltaX, deltaY, scale) {\n      var _this$bounding_box4 = this.bounding_box,\n        x = _this$bounding_box4.x,\n        y = _this$bounding_box4.y,\n        width = _this$bounding_box4.width,\n        height = _this$bounding_box4.height;\n      var _this$canvasMeta2 = this.canvasMeta,\n        cw = _this$canvasMeta2.actual_width,\n        ch = _this$canvasMeta2.actual_height;\n      if (scale === undefined) {\n        scale = this.scale;\n      }\n      if (this.worldMargin) {\n        // console.log(scale)\n        var m = this.worldMargin;\n        var bx1 = (x + width + m) * scale - cw;\n        var bx2 = (x - m) * scale;\n        // console.log(bx1, bx2)\n        var sx = x * scale;\n        var px = this.position.x + deltaX;\n        var cx = px - sx;\n        this.position.offsetX = Math.min(Math.max(-bx1, cx), -bx2);\n        // console.log(this.position.offsetX)\n        // this.position.offsetX = Math.max(Math.min(-bx2, cx), -bx1);\n        this.position.x = this.position.offsetX + sx;\n        // console.log(this.position.x, deltaX)\n        // console.log(this.position.offsetX)\n\n        var by1 = (y + height + m) * scale - ch;\n        var by2 = (y - m) * scale;\n        // console.log(by1, by2)\n        var sy = y * scale;\n        var py = this.position.y + deltaY;\n        var cy = py - sy;\n        this.position.offsetY = Math.min(Math.max(-by1, cy), -by2);\n        // this.position.offsetY = Math.max(Math.min(-by2, cy), -by1);\n        this.position.y = this.position.offsetY + sy;\n      } else {\n        this.position.x += deltaX;\n        this.position.y += deltaY;\n        this.position.offsetX = this.position.x - x * scale;\n        this.position.offsetY = this.position.y - y * scale;\n      }\n    }\n  }, {\n    key: "calculateToRealWorld",\n    value: function calculateToRealWorld(p) {\n      var scale = this.scale;\n      var position = this.position;\n      return [p[0] * scale + position.offsetX, p[1] * scale + position.offsetY];\n    }\n  }, {\n    key: "_calculatePointBack",\n    value: function _calculatePointBack(p) {\n      var scale = this.scale;\n      var position = this.position;\n      return [(p[0] - position.offsetX) / scale, (p[1] - position.offsetY) / scale];\n    }\n  }, {\n    key: "_calculatePointBackWithPoint",\n    value: function _calculatePointBackWithPoint(a, b, arr, idx1, idx2) {\n      var scale = this.scale;\n      var position = this.position;\n      arr[idx1] = (a - position.offsetX) / scale;\n      arr[idx2] = (b - position.offsetY) / scale;\n    }\n  }, {\n    key: "_calculateDistance",\n    value: function _calculateDistance(l) {\n      return this.scale * l;\n    }\n  }, {\n    key: "_resetTransform",\n    value: function _resetTransform() {\n      var _this$canvasMeta3 = this.canvasMeta,\n        c_width = _this$canvasMeta3.width,\n        c_height = _this$canvasMeta3.height;\n      var position = this.position;\n      var scale = this.scale;\n      var ctx = this.ctx;\n      ctx.setTransform();\n      ctx.clearRect(0, 0, c_width, c_height);\n      ctx.scale(this.dpr, this.dpr);\n      ctx.transform(scale, 0, 0, scale, position.offsetX, position.offsetY);\n      // ctx._ctx.setTransform();\n      // ctx._ctx.clearRect(0, 0, c_width, c_height);\n      // ctx._ctx.scale(this.dpr, this.dpr);\n      // ctx.transform(scale, position.offsetX, position.offsetY);\n    }\n  }, {\n    key: "resetTransform",\n    value: function resetTransform(ctx) {\n      var position = this.position;\n      var scale = this.scale;\n      ctx.setTransform();\n      ctx.scale(this.dpr, this.dpr);\n      ctx.transform(scale, 0, 0, scale, position.offsetX, position.offsetY);\n    }\n  }, {\n    key: "_getViewBox",\n    value: function _getViewBox() {\n      // const cacheViewBox = [\n      //     ...this._calculatePointBack([0,0]),\n      //     ...this._calculatePointBack([this.canvasMeta.actual_width,this.canvasMeta.actual_height]),\n      // ];\n      var cacheViewBox = this._cacheViewBox;\n      this._calculatePointBackWithPoint(0, 0, cacheViewBox, 0, 1);\n      this._calculatePointBackWithPoint(this.canvasMeta.actual_width, this.canvasMeta.actual_height, cacheViewBox, 2, 3);\n      return cacheViewBox;\n    }\n  }, {\n    key: "setNodeToTopLayer",\n    value: function setNodeToTopLayer(node) {\n      var index = this._stack.findIndex(function (n) {\n        return n === node;\n      });\n      if (index !== -1) {\n        var _this$_stack$splice = this._stack.splice(index, 1),\n          _this$_stack$splice2 = flow_slicedToArray(_this$_stack$splice, 1),\n          renderNode = _this$_stack$splice2[0];\n        this._stack.push(renderNode);\n      }\n    }\n  }, {\n    key: "getCacheViewBox",\n    value: function getCacheViewBox() {\n      return this._cacheViewBox;\n    }\n  }, {\n    key: "_render",\n    value: function _render() {\n      this.scheduleRender();\n    }\n\n    /**\n    * 绘制画布\n    */\n  }, {\n    key: "__render",\n    value: function __render() {\n      if (!this._readyToRender) return;\n      // if(this.hasAnimeAndFrameRendered()) return;\n      this.runAnimeFrame();\n      this._resetTransform();\n      var ctx = this.ctx;\n      this.dispatchEvent(new events(\'beforeJflowRender\', {\n        ctx: ctx\n      }));\n      var br = this._getViewBox();\n      if (this.NodeRenderTop) {\n        this._linkStack.render(ctx, function (link) {\n          return !link.ON_TOP && link.isInViewBox(br);\n        });\n        this._stack.render(ctx, function (instance) {\n          var result = doOverlap(br, instance.getBoundingRect());\n          instance._isInViewBox = result;\n          return result;\n        });\n        this._linkStack.render(ctx, function (link) {\n          return link.ON_TOP && link.isInViewBox(br);\n        });\n      } else {\n        this._stack.render(ctx, function (instance) {\n          var result = doOverlap(br, instance.getBoundingRect());\n          // console.log(instance._layoutNode.type, result)\n          instance._isInViewBox = result;\n          return result;\n        });\n        this._linkStack.render(ctx, function (link) {\n          return link.isInViewBox(br);\n        });\n      }\n      // ctx.save();\n      // for(let i =0;i<2000;i++) {\n      //     ctx.beginPath();\n      //     ctx.fillStyle = `rgb(${parseInt(Math.random()*255)},${parseInt(Math.random()*255)},${parseInt(Math.random()*255)})`\n      //     ctx.fillRect(\n      //         Math.random()*250, \n      //         Math.random()*240, \n      //         Math.random()*200, \n      //         Math.random()*300)\n      // }\n\n      // ctx.restore();\n\n      if (this._tempNode) {\n        ctx.save();\n        this._tempNode.render(ctx);\n        ctx.restore();\n      }\n      if (this._tempLink) {\n        ctx.save();\n        this._tempLink.isInViewBox(br);\n        this._tempLink.render(ctx);\n        ctx.restore();\n      }\n      this.dispatchEvent(new events(\'afterJflowRender\', {\n        ctx: ctx\n      }));\n      this.renderScrollBar(ctx);\n      // this.setFrameRendered();\n    }\n  }]);\n  return JFlow;\n}( /*#__PURE__*/flow_wrapNativeSuper(EventTarget));\nObject.assign(JFlow.prototype, messageMixin);\nObject.assign(JFlow.prototype, stackMixin);\nObject.assign(JFlow.prototype, layoutMixin);\nObject.assign(JFlow.prototype, {\n  recalculateUp: function recalculateUp() {\n    if (this.__mounted__) {\n      this.reflow();\n    }\n  }\n});\nObject.assign(JFlow.prototype, NodeWeakMapMixin);\nObject.assign(JFlow.prototype, animeMixin);\nObject.assign(JFlow.prototype, minimap_mixin);\nObject.assign(JFlow.prototype, schedule);\nObject.assign(JFlow.prototype, scrollbarMixin);\n/* harmony default export */ const flow = (JFlow);\n\n\n\n\n\n\n\n\n// export { default as Group } from \'../instance/shapes/rectangle-group\';\n\n\n// export { default as CapsuleGroup } from \'../instance/shapes/capsule-group\';\n// export { default as CapsuleVerticalGroup } from \'../instance/shapes/capsule-vertical-group\';\n\n// export { default as DiamondGroup } from \'../instance/shapes/diamond-group\';\n// export { default as DiamondVerticalGroup } from \'../instance/shapes/diamond-vertical-group\';\n\n// export { default as RhombusGroup } from \'../instance/shapes/rhombus-group\';\n\n\n\n\n\n\n\n\n// export { default as TreeLayout } from \'../ler-layouta;yout/tree-layout\';\n// export { default as Lowcodelayout } from \'../layout/low-code-layout\';\n// export { default as ERLayout } from \'../layout/er-layout/er-layout\';\n// export { default as Orange } from \'../instance/nodeWrapper/orange/orange\'\n// export { default as TextEditor } from \'../instance/text-editor\';\n// export { default as TextGroup} from \'../instance/text-group\';\n\n\n// export { JFlowPath2D } from \'../utils/path-2d\';\n\n\n\n;// CONCATENATED MODULE: ./src/index.js\n\n\n/* harmony default export */ const src = (flow);\n\n// export { default as JFlowVuePlugin, JFlowLinkGroup } from \'./vue-plugin/JFlowPlugin.js\';\nflow.$jflow_version = package_namespaceObject.i8;\n// console.log(`jflow version@${packageJson.version}`)//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGFBQWE7QUFDYixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsV0FBVyxxREFBcUQ7QUFDaEUsV0FBVyxxREFBcUQ7QUFDaEU7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHFCQUFxQixNQUFNLFlBQVksUUFBUTs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FB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LENBQUMsR0FBRyxDQUFDLEdBQUNDLENBQUMsR0FBQ0EsQ0FBQyxHQUFDNUMsQ0FBQyxHQUFDMkMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBQ0MsQ0FBQyxHQUFDNUMsQ0FBQyxHQUFDQSxDQUFDLEdBQUMyQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUczQyxDQUFDLEdBQUNBLENBQUMsR0FBQ0EsQ0FBQyxHQUFDMkMsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUMvRCxJQUFNRSxDQUFDLEdBQUdELENBQUMsR0FBQ0EsQ0FBQyxJQUFFRCxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUNBLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBQzNDLENBQUMsR0FBQzRDLENBQUMsSUFBRUQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFDQSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRzNDLENBQUMsR0FBQ0EsQ0FBQyxJQUFFMkMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFDQSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDL0QsSUFBTWhELENBQUMsR0FBR2lELENBQUMsR0FBQ0EsQ0FBQyxJQUFFRCxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUNBLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBQzNDLENBQUMsR0FBQzRDLENBQUMsSUFBRUQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFDQSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRzNDLENBQUMsR0FBQ0EsQ0FBQyxJQUFFMkMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFDQSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDL0QsSUFBSUcsS0FBSyxHQUFHakgsSUFBSSxDQUFDa0gsS0FBSyxDQUFDcEQsQ0FBQyxFQUFFa0QsQ0FBQyxDQUFDO0VBQzVCO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsT0FBTyxDQUFDOUQsQ0FBQyxFQUFFQyxDQUFDLEVBQUU4RCxLQUFLLENBQUM7QUFDeEI7O0FBRUE7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QVcsRUFBRTtNQUNqQixJQUFJLENBQUNqUSxNQUFNLENBQUMsQ0FBQztJQUNqQjtFQUNKO0FBQ0osQ0FBQyxDQUFDO0FBRUZ6VSxNQUFNLENBQUNRLE1BQU0sQ0FBQzh3QyxLQUFLLENBQUM3L0IsU0FBUyxFQUFFOUIsZ0JBQWdCLENBQUM7QUFDaEQzUCxNQUFNLENBQUNRLE1BQU0sQ0FBQzh3QyxLQUFLLENBQUM3L0IsU0FBUyxFQUFFaS9CLFVBQVUsQ0FBQztBQUMxQzF3QyxNQUFNLENBQUNRLE1BQU0sQ0FBQzh3QyxLQUFLLENBQUM3L0IsU0FBUyxFQUFFay9CLGFBQVksQ0FBQztBQUM1QzN3QyxNQUFNLENBQUNRLE1BQU0sQ0FBQzh3QyxLQUFLLENBQUM3L0IsU0FBUyxFQUFFby9CLFFBQWEsQ0FBQztBQUM3Qzd3QyxNQUFNLENBQUNRLE1BQU0sQ0FBQzh3QyxLQUFLLENBQUM3L0IsU0FBUyxFQUFFbS9CLGNBQWMsQ0FBQztBQUU5QywyQ0FBZVUsS0FBSyxFQUFDO0FBQzJCO0FBQ0U7QUFDc0I7QUFDYjtBQUNSO0FBQ1M7QUFDQTtBQUNRO0FBQ3BFO0FBQ2dFO0FBQ2lCO0FBQ2pGO0FBQ0E7QUFDZ0U7QUFDaEU7QUFDQTtBQUNnRTtBQUNoRTtBQUM0RDtBQUNSO0FBQ1M7QUFDTTtBQUNoQjtBQUNTO0FBQ0k7QUFDQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDd0U7QUFDWDtBQUM3RDs7QUFFK0Q7OztBQ3R6RHJCO0FBQ0s7QUFDL0MsMENBQWVBLElBQUssRUFBQztBQUNPO0FBQzVCO0FBQ0FBLG1CQUFvQixHQUFHbUosMEJBQW1CO0FBQzFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL3V0aWxzL2NhbnZhcy5qcz9jZmExIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9ub2RlX21vZHVsZXMvYmV6aWVyLWpzL3NyYy91dGlscy5qcz8wMGZhIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9ub2RlX21vZHVsZXMvYmV6aWVyLWpzL3NyYy9wb2x5LWJlemllci5qcz9kODE4Iiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9ub2RlX21vZHVsZXMvYmV6aWVyLWpzL3NyYy9iZXppZXIuanM/MzVkMSIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvdXRpbHMvY29uc3RhbmNlLmpzP2UyN2QiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL3V0aWxzL2Z1bmN0aW9ucy5qcz9jZTVmIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS9pbnN0YW5jZS5qcz9hZDYwIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9kaXJ0eS13b3JrL2RpcnR5LXdvcmsuanM/NDEwNiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2Uvbm9kZS5qcz8yYmE5Iiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS9naG9zdE5vZGUuanM/NzA2MCIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2Uvbm9kZVdlYWtNYXAuanM/NDRiMSIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2Uvc3RhY2suanM/YjRiNSIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2Uvc3RhY2tNaXhpbi5qcz84MDE2Iiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS9sYXlvdXRNaXhpbi5qcz83ZmQ3Iiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS9tZXNzYWdlTWl4aW4uanM/ZDZiYyIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvYW5pbWUvYW5pbWVNaXhpbi5qcz83MDVjIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9taW5pTWFwL21pbmltYXAtbWl4aW4uanM/MGVlNiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvZXZlbnRzL2luZGV4LmpzP2YzY2YiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL3Njcm9sbGJhci9zY3JvbGxiYXJNaXhpbi5qcz9kNDVlIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9mbG93L3NjaGVkdWxlLmpzP2U3MWYiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2V2ZW50cy9hZGFwdGVyLmpzPzZiNDMiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL2dyb3VwRmFjdG9yeS5qcz8xN2Q2Iiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS9zaGFwZXMvcG9pbnQuanM/MTcxNiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2Uvc2hhcGVzL3JlY3RhbmdsZS5qcz9hYzVlIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS9zaGFwZXMvY2Fwc3VsZS5qcz9jZDcwIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS9zaGFwZXMvY2Fwc3VsZS12ZXJ0aWNhbC5qcz8zYTIwIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS9zaGFwZXMvcmhvbWJ1cy5qcz9jODRiIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS9zaGFwZXMvZGlhbW9uZC5qcz9jNTVmIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS9zaGFwZXMvZGlhbW9uZC12ZXJ0aWNhbC5qcz8zM2VmIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS9ncm91cHMvc2Nyb2xsLWdyb3VwLmpzPzM0YmUiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2V2ZW50cy9jb21tb25BZGFwdGVyLmpzP2Y4NTEiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL2Jhc2UtbGluay5qcz84ZjgyIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS9zaGFwZXMvc2hhZG93LWNhY2hlLmpzPzI3OGYiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL2VsZW1lbnRzL3RleHQuanM/N2M4MiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvaW1hZ2UuanM/NzhiNiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2Uvc2hhZG93RG9tLmpzP2FmYTkiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL2xpbmsuanM/MzFkMyIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvcG9seS1saW5rLmpzP2YxZDMiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL2Jlemllci1saW5rLmpzP2Q4ZWYiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2xheW91dC9saW5lYXItbGF5b3V0LmpzPzljOGEiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3RleHQtZ3JvdXAvYmFzZS9jb25zdGFudHMuanM/ZmNiOSIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvdGV4dC1ncm91cC9iYXNlL3NoYWRvdy1pbnB1dC5qcz84MDA2Iiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS90ZXh0LWdyb3VwL2Jhc2UvY2FyZXQuanM/MWM5YyIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvdGV4dC1ncm91cC91dGlscy5qcz8xYjU2Iiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS90ZXh0LWdyb3VwL3N0b3JhZ2UvaW5kZXguanM/NGE0YiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvdGV4dC1ncm91cC9iYXNlL3JhbmdlLmpzP2RkMWEiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3RleHQtZ3JvdXAvdW5kb3JlZG8uanM/ZjNkZCIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvdGV4dC1ncm91cC9jb21tYW5kL2Jhc2UuanM/YmJiYiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvdGV4dC1ncm91cC9jb21tYW5kL21vdmVtZW50LmpzPzVhNmYiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3RleHQtZ3JvdXAvY29tbWFuZC9pbnB1dC5qcz9mYTExIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS90ZXh0LWdyb3VwL2NvbW1hbmQvbW91c2UuanM/ODc4YiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvdGV4dC1ncm91cC9jb21tYW5kL3NoaWZ0LmpzPzMxMDYiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3RleHQtZ3JvdXAvY29tbWFuZC9jdHJsLmpzPzIwNmIiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3RleHQtZ3JvdXAvY29tbWFuZC91bmRvcmVkby5qcz85ZTkyIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS90ZXh0LWdyb3VwL2NvbW1hbmQvY2xpcGJvYXJkLmpzPzllNmIiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3RleHQtZ3JvdXAvY29tbWFuZC9pbmRleC5qcz83ODBlIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS90ZXh0LWdyb3VwL3RleHQtZ3JvdXAuanM/NGZjMSIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2Uvbm9kZS1wbGFjZWhvbGRlci5qcz84ODJhIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9mbG93L2luZGV4LmpzPzkzMDciLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9pbmRleC5qcz9iNjM1Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDYW52YXNNZXRhXG4gKiBAcHJvcGVydHkge0VsZW1lbnR9IGNhbnZhcyAtIGNhbnZhcyDlhYPntKBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aCAtIOeUu+W4g+WuveW6plxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAtIOeUu+W4g+mrmOW6plxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJhd193aWR0aCAtIOeUu+W4g+WFg+e0oOWuveW6plxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJhd19oZWlnaHQgLSDnlLvluIPlhYPntKDpq5jluqZcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZWZ0IC0g55S75biD6Led56a75bem56uv6Led56a7XG4gKiBAcHJvcGVydHkge251bWJlcn0gdG9wIC0g55S75biD6Led56a76aG256uv6Led56a7XG4gKiBAcHJvcGVydHkge0NvbnRleHQyZH0gY3R4IC0gQ29udGV4dDJkXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2NhbGUgLSDlvZPliY3nmoTlg4/ntKDorr7lpIfmr5RcbiAqL1xuLyoqXG4gKiDliJvlu7rkuIDkuKogY2FudmFzIOWFg+e0oFxuICogQHBhcmFtICB7RWxlbWVudH0gd3JhcHBlciAtIGRvbeWFg+e0oFxuICogQHJldHVybiB7Q2FudmFzTWV0YX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyh3cmFwcGVyKSB7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBsZWZ0LCB0b3AgfSA9IHdyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICBjYW52YXMuc3R5bGUudXNlclNlbGVjdCA9ICdub25lJztcbiAgICBjb25zdCBzY2FsZSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIGNhbnZhcy53aWR0aCA9IE1hdGguZmxvb3Iod2lkdGggKiBzY2FsZSk7XG4gICAgY2FudmFzLmhlaWdodCA9IE1hdGguZmxvb3IoaGVpZ2h0ICogc2NhbGUpO1xuXG4gICAgaWYod3JhcHBlcikge1xuICAgICAgICB3cmFwcGVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgd3JhcHBlci5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZChjYW52YXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjYW52YXMsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHJhd193aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgICByYXdfaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LFxuICAgICAgICBsZWZ0LFxuICAgICAgICB0b3AsXG4gICAgICAgIGN0eCxcbiAgICAgICAgc2NhbGUsXG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzaXplQ2FudmFzKGNhbnZhcywgd3JhcHBlcikge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgbGVmdCwgdG9wIH0gPSB3cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gICAgY29uc3Qgc2NhbGUgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICBjYW52YXMud2lkdGggPSBNYXRoLmZsb29yKHdpZHRoICogc2NhbGUpO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBNYXRoLmZsb29yKGhlaWdodCAqIHNjYWxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICByYXdfd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgICAgcmF3X2hlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICB9XG59XG5cbmNvbnN0IGNhaGVDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbmNhaGVDYW52YXMud2lkdGggPSAxO1xuY2FoZUNhbnZhcy5oZWlnaHQgPSAxO1xuY29uc3QgY2FoZUNhbnZhc2N0eCA9IGNhaGVDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbmNvbnN0IHNjYWxlID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG5jYWhlQ2FudmFzY3R4LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG5cbi8qKlxuICog5Zyo56a757q/Y2FudmFz5LiK57uY5Yi25YWD57SgXG4gKiBAcGFyYW0gIHtyZW5kZXJ9IHJlbmRlciAtIOe7mOWbvuWHveaVsFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVxdWVzdENhY2hlQ2FudmFzKHJlbmRlcikge1xuICAgIGNhaGVDYW52YXNjdHguY2xlYXJSZWN0KDAsMCw1LDUpO1xuICAgIGNhaGVDYW52YXNjdHguc2F2ZSgpO1xuICAgIHJlbmRlcihjYWhlQ2FudmFzY3R4KTtcbiAgICBjYWhlQ2FudmFzY3R4LnJlc3RvcmUoKTtcbiAgICBjYWhlQ2FudmFzY3R4LmNsZWFyUmVjdCgwLDAsNSw1KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpc3Rlbk9uRGV2aWNlUGl4ZWxSYXRpbyhjYWxsYmFjaywgZGVzdHJveUhhbmRsZXIpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBtYXRjaE1lZGlhKFxuICAgICAgICBgKHJlc29sdXRpb246ICR7d2luZG93LmRldmljZVBpeGVsUmF0aW99ZHBweClgXG4gICAgKTtcbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiZGV2aWNlUGl4ZWxSYXRpbyBjaGFuZ2VkOiBcIiArIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAgIGNhbGxiYWNrKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAgIGxpc3Rlbk9uRGV2aWNlUGl4ZWxSYXRpbyhjYWxsYmFjaywgZGVzdHJveUhhbmRsZXIpO1xuICAgIH1cbiAgICBkZXN0cm95SGFuZGxlcigoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdyZW1vdmUgZGV2aWNlUGl4ZWxSYXRpbyBldmVudCBoYW5kbGVyJylcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgb25DaGFuZ2UsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9KVxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIG9uQ2hhbmdlLCB7IG9uY2U6IHRydWUgfSk7XG59IiwiaW1wb3J0IHsgQmV6aWVyIH0gZnJvbSBcIi4vYmV6aWVyLmpzXCI7XG5cbi8vIG1hdGgtaW5saW5pbmcuXG5jb25zdCB7IGFicywgY29zLCBzaW4sIGFjb3MsIGF0YW4yLCBzcXJ0LCBwb3cgfSA9IE1hdGg7XG5cbi8vIGN1YmUgcm9vdCBmdW5jdGlvbiB5aWVsZGluZyByZWFsIHJvb3RzXG5mdW5jdGlvbiBjcnQodikge1xuICByZXR1cm4gdiA8IDAgPyAtcG93KC12LCAxIC8gMykgOiBwb3codiwgMSAvIDMpO1xufVxuXG4vLyB0cmlnIGNvbnN0YW50c1xuY29uc3QgcGkgPSBNYXRoLlBJLFxuICB0YXUgPSAyICogcGksXG4gIHF1YXJ0ID0gcGkgLyAyLFxuICAvLyBmbG9hdCBwcmVjaXNpb24gc2lnbmlmaWNhbnQgZGVjaW1hbFxuICBlcHNpbG9uID0gMC4wMDAwMDEsXG4gIC8vIGV4dHJlbWFzIHVzZWQgaW4gYmJveCBjYWxjdWxhdGlvbiBhbmQgc2ltaWxhciBhbGdvcml0aG1zXG4gIG5NYXggPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxLFxuICBuTWluID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgfHwgLTkwMDcxOTkyNTQ3NDA5OTEsXG4gIC8vIGEgemVybyBjb29yZGluYXRlLCB3aGljaCBpcyBzdXJwcmlzaW5nbHkgdXNlZnVsXG4gIFpFUk8gPSB7IHg6IDAsIHk6IDAsIHo6IDAgfTtcblxuLy8gQmV6aWVyIHV0aWxpdHkgZnVuY3Rpb25zXG5jb25zdCB1dGlscyA9IHtcbiAgLy8gTGVnZW5kcmUtR2F1c3MgYWJzY2lzc2FlIHdpdGggbj0yNCAoeF9pIHZhbHVlcywgZGVmaW5lZCBhdCBpPW4gYXMgdGhlIHJvb3RzIG9mIHRoZSBudGggb3JkZXIgTGVnZW5kcmUgcG9seW5vbWlhbCBQbih4KSlcbiAgVHZhbHVlczogW1xuICAgIC0wLjA2NDA1Njg5Mjg2MjYwNTYyNjA4NTA0MzA4MjYyNDc0NTAzODU5MDksXG4gICAgMC4wNjQwNTY4OTI4NjI2MDU2MjYwODUwNDMwODI2MjQ3NDUwMzg1OTA5LFxuICAgIC0wLjE5MTExODg2NzQ3MzYxNjMwOTE1ODYzOTgyMDc1NzA2OTYzMTg0MDQsXG4gICAgMC4xOTExMTg4Njc0NzM2MTYzMDkxNTg2Mzk4MjA3NTcwNjk2MzE4NDA0LFxuICAgIC0wLjMxNTA0MjY3OTY5NjE2MzM3NDM4Njc5MzI5MTMxOTgxMDI0MDc4NjQsXG4gICAgMC4zMTUwNDI2Nzk2OTYxNjMzNzQzODY3OTMyOTEzMTk4MTAyNDA3ODY0LFxuICAgIC0wLjQzMzc5MzUwNzYyNjA0NTEzODQ4NzA4NDIzMTkxMzM0OTcxMjQ1MjQsXG4gICAgMC40MzM3OTM1MDc2MjYwNDUxMzg0ODcwODQyMzE5MTMzNDk3MTI0NTI0LFxuICAgIC0wLjU0NTQyMTQ3MTM4ODgzOTUzNTY1ODM3NTYxNzIxODM3MjM3MDAxMDcsXG4gICAgMC41NDU0MjE0NzEzODg4Mzk1MzU2NTgzNzU2MTcyMTgzNzIzNzAwMTA3LFxuICAgIC0wLjY0ODA5MzY1MTkzNjk3NTU2OTI1MjQ5NTc4NjkxMDc0NzYyNjY2OTYsXG4gICAgMC42NDgwOTM2NTE5MzY5NzU1NjkyNTI0OTU3ODY5MTA3NDc2MjY2Njk2LFxuICAgIC0wLjc0MDEyNDE5MTU3ODU1NDM2NDI0MzgyODEwMzA5OTk3ODQyNTUyMzIsXG4gICAgMC43NDAxMjQxOTE1Nzg1NTQzNjQyNDM4MjgxMDMwOTk5Nzg0MjU1MjMyLFxuICAgIC0wLjgyMDAwMTk4NTk3MzkwMjkyMTk1Mzk0OTg3MjY2OTc0NTIwODA3NjEsXG4gICAgMC44MjAwMDE5ODU5NzM5MDI5MjE5NTM5NDk4NzI2Njk3NDUyMDgwNzYxLFxuICAgIC0wLjg4NjQxNTUyNzAwNDQwMTAzNDIxMzE1NDM0MTk4MjE5Njc1NTA4NzMsXG4gICAgMC44ODY0MTU1MjcwMDQ0MDEwMzQyMTMxNTQzNDE5ODIxOTY3NTUwODczLFxuICAgIC0wLjkzODI3NDU1MjAwMjczMjc1ODUyMzY0OTAwMTcwODcyMTQ0OTY1NDgsXG4gICAgMC45MzgyNzQ1NTIwMDI3MzI3NTg1MjM2NDkwMDE3MDg3MjE0NDk2NTQ4LFxuICAgIC0wLjk3NDcyODU1NTk3MTMwOTQ5ODE5ODM5MTk5MzAwODE2OTA2MTc0MTEsXG4gICAgMC45NzQ3Mjg1NTU5NzEzMDk0OTgxOTgzOTE5OTMwMDgxNjkwNjE3NDExLFxuICAgIC0wLjk5NTE4NzIxOTk5NzAyMTM2MDE3OTk5NzQwOTcwMDczNjgxMTg3NDUsXG4gICAgMC45OTUxODcyMTk5OTcwMjEzNjAxNzk5OTc0MDk3MDA3MzY4MTE4NzQ1LFxuICBdLFxuXG4gIC8vIExlZ2VuZHJlLUdhdXNzIHdlaWdodHMgd2l0aCBuPTI0ICh3X2kgdmFsdWVzLCBkZWZpbmVkIGJ5IGEgZnVuY3Rpb24gbGlua2VkIHRvIGluIHRoZSBCZXppZXIgcHJpbWVyIGFydGljbGUpXG4gIEN2YWx1ZXM6IFtcbiAgICAwLjEyNzkzODE5NTM0Njc1MjE1Njk3NDA1NjE2NTIyNDY5NTM3MTg1MTcsXG4gICAgMC4xMjc5MzgxOTUzNDY3NTIxNTY5NzQwNTYxNjUyMjQ2OTUzNzE4NTE3LFxuICAgIDAuMTI1ODM3NDU2MzQ2ODI4Mjk2MTIxMzc1MzgyNTExMTgzNjg4NzI2NCxcbiAgICAwLjEyNTgzNzQ1NjM0NjgyODI5NjEyMTM3NTM4MjUxMTE4MzY4ODcyNjQsXG4gICAgMC4xMjE2NzA0NzI5Mjc4MDMzOTEyMDQ0NjMxNTM0NzYyNjI0MjU2MDcsXG4gICAgMC4xMjE2NzA0NzI5Mjc4MDMzOTEyMDQ0NjMxNTM0NzYyNjI0MjU2MDcsXG4gICAgMC4xMTU1MDU2NjgwNTM3MjU2MDEzNTMzNDQ0ODM5MDY3ODM1NTk4NjIyLFxuICAgIDAuMTE1NTA1NjY4MDUzNzI1NjAxMzUzMzQ0NDgzOTA2NzgzNTU5ODYyMixcbiAgICAwLjEwNzQ0NDI3MDExNTk2NTYzNDc4MjU3NzM0MjQ0NjYwNjIyMjc5NDYsXG4gICAgMC4xMDc0NDQyNzAxMTU5NjU2MzQ3ODI1NzczNDI0NDY2MDYyMjI3OTQ2LFxuICAgIDAuMDk3NjE4NjUyMTA0MTEzODg4MjY5ODgwNjY0NDY0MjQ3MTU0NDI3OSxcbiAgICAwLjA5NzYxODY1MjEwNDExMzg4ODI2OTg4MDY2NDQ2NDI0NzE1NDQyNzksXG4gICAgMC4wODYxOTAxNjE1MzE5NTMyNzU5MTcxODUyMDI5ODM3NDI2NjcxODUsXG4gICAgMC4wODYxOTAxNjE1MzE5NTMyNzU5MTcxODUyMDI5ODM3NDI2NjcxODUsXG4gICAgMC4wNzMzNDY0ODE0MTEwODAzMDU3MzQwMzM2MTUyNTMxMTY1MTgxMTkzLFxuICAgIDAuMDczMzQ2NDgxNDExMDgwMzA1NzM0MDMzNjE1MjUzMTE2NTE4MTE5MyxcbiAgICAwLjA1OTI5ODU4NDkxNTQzNjc4MDc0NjM2Nzc1ODUwMDEwODU4NDU0MTIsXG4gICAgMC4wNTkyOTg1ODQ5MTU0MzY3ODA3NDYzNjc3NTg1MDAxMDg1ODQ1NDEyLFxuICAgIDAuMDQ0Mjc3NDM4ODE3NDE5ODA2MTY4NjAyNzQ4MjExMzM4MjI4ODU5MyxcbiAgICAwLjA0NDI3NzQzODgxNzQxOTgwNjE2ODYwMjc0ODIxMTMzODIyODg1OTMsXG4gICAgMC4wMjg1MzEzODg2Mjg5MzM2NjMxODEzMDc4MTU5NTE4NzgyODY0NDkxLFxuICAgIDAuMDI4NTMxMzg4NjI4OTMzNjYzMTgxMzA3ODE1OTUxODc4Mjg2NDQ5MSxcbiAgICAwLjAxMjM0MTIyOTc5OTk4NzE5OTU0NjgwNTY2NzA3MDAzNzI5MTU3NTksXG4gICAgMC4wMTIzNDEyMjk3OTk5ODcxOTk1NDY4MDU2NjcwNzAwMzcyOTE1NzU5LFxuICBdLFxuXG4gIGFyY2ZuOiBmdW5jdGlvbiAodCwgZGVyaXZhdGl2ZUZuKSB7XG4gICAgY29uc3QgZCA9IGRlcml2YXRpdmVGbih0KTtcbiAgICBsZXQgbCA9IGQueCAqIGQueCArIGQueSAqIGQueTtcbiAgICBpZiAodHlwZW9mIGQueiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgbCArPSBkLnogKiBkLno7XG4gICAgfVxuICAgIHJldHVybiBzcXJ0KGwpO1xuICB9LFxuXG4gIGNvbXB1dGU6IGZ1bmN0aW9uICh0LCBwb2ludHMsIF8zZCkge1xuICAgIC8vIHNob3J0Y3V0c1xuICAgIGlmICh0ID09PSAwKSB7XG4gICAgICBwb2ludHNbMF0udCA9IDA7XG4gICAgICByZXR1cm4gcG9pbnRzWzBdO1xuICAgIH1cblxuICAgIGNvbnN0IG9yZGVyID0gcG9pbnRzLmxlbmd0aCAtIDE7XG5cbiAgICBpZiAodCA9PT0gMSkge1xuICAgICAgcG9pbnRzW29yZGVyXS50ID0gMTtcbiAgICAgIHJldHVybiBwb2ludHNbb3JkZXJdO1xuICAgIH1cblxuICAgIGNvbnN0IG10ID0gMSAtIHQ7XG4gICAgbGV0IHAgPSBwb2ludHM7XG5cbiAgICAvLyBjb25zdGFudD9cbiAgICBpZiAob3JkZXIgPT09IDApIHtcbiAgICAgIHBvaW50c1swXS50ID0gdDtcbiAgICAgIHJldHVybiBwb2ludHNbMF07XG4gICAgfVxuXG4gICAgLy8gbGluZWFyP1xuICAgIGlmIChvcmRlciA9PT0gMSkge1xuICAgICAgY29uc3QgcmV0ID0ge1xuICAgICAgICB4OiBtdCAqIHBbMF0ueCArIHQgKiBwWzFdLngsXG4gICAgICAgIHk6IG10ICogcFswXS55ICsgdCAqIHBbMV0ueSxcbiAgICAgICAgdDogdCxcbiAgICAgIH07XG4gICAgICBpZiAoXzNkKSB7XG4gICAgICAgIHJldC56ID0gbXQgKiBwWzBdLnogKyB0ICogcFsxXS56O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvLyBxdWFkcmF0aWMvY3ViaWMgY3VydmU/XG4gICAgaWYgKG9yZGVyIDwgNCkge1xuICAgICAgbGV0IG10MiA9IG10ICogbXQsXG4gICAgICAgIHQyID0gdCAqIHQsXG4gICAgICAgIGEsXG4gICAgICAgIGIsXG4gICAgICAgIGMsXG4gICAgICAgIGQgPSAwO1xuICAgICAgaWYgKG9yZGVyID09PSAyKSB7XG4gICAgICAgIHAgPSBbcFswXSwgcFsxXSwgcFsyXSwgWkVST107XG4gICAgICAgIGEgPSBtdDI7XG4gICAgICAgIGIgPSBtdCAqIHQgKiAyO1xuICAgICAgICBjID0gdDI7XG4gICAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAzKSB7XG4gICAgICAgIGEgPSBtdDIgKiBtdDtcbiAgICAgICAgYiA9IG10MiAqIHQgKiAzO1xuICAgICAgICBjID0gbXQgKiB0MiAqIDM7XG4gICAgICAgIGQgPSB0ICogdDI7XG4gICAgICB9XG4gICAgICBjb25zdCByZXQgPSB7XG4gICAgICAgIHg6IGEgKiBwWzBdLnggKyBiICogcFsxXS54ICsgYyAqIHBbMl0ueCArIGQgKiBwWzNdLngsXG4gICAgICAgIHk6IGEgKiBwWzBdLnkgKyBiICogcFsxXS55ICsgYyAqIHBbMl0ueSArIGQgKiBwWzNdLnksXG4gICAgICAgIHQ6IHQsXG4gICAgICB9O1xuICAgICAgaWYgKF8zZCkge1xuICAgICAgICByZXQueiA9IGEgKiBwWzBdLnogKyBiICogcFsxXS56ICsgYyAqIHBbMl0ueiArIGQgKiBwWzNdLno7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8vIGhpZ2hlciBvcmRlciBjdXJ2ZXM6IHVzZSBkZSBDYXN0ZWxqYXUncyBjb21wdXRhdGlvblxuICAgIGNvbnN0IGRDcHRzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwb2ludHMpKTtcbiAgICB3aGlsZSAoZENwdHMubGVuZ3RoID4gMSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkQ3B0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgZENwdHNbaV0gPSB7XG4gICAgICAgICAgeDogZENwdHNbaV0ueCArIChkQ3B0c1tpICsgMV0ueCAtIGRDcHRzW2ldLngpICogdCxcbiAgICAgICAgICB5OiBkQ3B0c1tpXS55ICsgKGRDcHRzW2kgKyAxXS55IC0gZENwdHNbaV0ueSkgKiB0LFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIGRDcHRzW2ldLnogIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBkQ3B0c1tpXSA9IGRDcHRzW2ldLnogKyAoZENwdHNbaSArIDFdLnogLSBkQ3B0c1tpXS56KSAqIHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRDcHRzLnNwbGljZShkQ3B0cy5sZW5ndGggLSAxLCAxKTtcbiAgICB9XG4gICAgZENwdHNbMF0udCA9IHQ7XG4gICAgcmV0dXJuIGRDcHRzWzBdO1xuICB9LFxuXG4gIGNvbXB1dGVXaXRoUmF0aW9zOiBmdW5jdGlvbiAodCwgcG9pbnRzLCByYXRpb3MsIF8zZCkge1xuICAgIGNvbnN0IG10ID0gMSAtIHQsXG4gICAgICByID0gcmF0aW9zLFxuICAgICAgcCA9IHBvaW50cztcblxuICAgIGxldCBmMSA9IHJbMF0sXG4gICAgICBmMiA9IHJbMV0sXG4gICAgICBmMyA9IHJbMl0sXG4gICAgICBmNCA9IHJbM10sXG4gICAgICBkO1xuXG4gICAgLy8gc3BlYyBmb3IgbGluZWFyXG4gICAgZjEgKj0gbXQ7XG4gICAgZjIgKj0gdDtcblxuICAgIGlmIChwLmxlbmd0aCA9PT0gMikge1xuICAgICAgZCA9IGYxICsgZjI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAoZjEgKiBwWzBdLnggKyBmMiAqIHBbMV0ueCkgLyBkLFxuICAgICAgICB5OiAoZjEgKiBwWzBdLnkgKyBmMiAqIHBbMV0ueSkgLyBkLFxuICAgICAgICB6OiAhXzNkID8gZmFsc2UgOiAoZjEgKiBwWzBdLnogKyBmMiAqIHBbMV0ueikgLyBkLFxuICAgICAgICB0OiB0LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB1cGdyYWRlIHRvIHF1YWRyYXRpY1xuICAgIGYxICo9IG10O1xuICAgIGYyICo9IDIgKiBtdDtcbiAgICBmMyAqPSB0ICogdDtcblxuICAgIGlmIChwLmxlbmd0aCA9PT0gMykge1xuICAgICAgZCA9IGYxICsgZjIgKyBmMztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IChmMSAqIHBbMF0ueCArIGYyICogcFsxXS54ICsgZjMgKiBwWzJdLngpIC8gZCxcbiAgICAgICAgeTogKGYxICogcFswXS55ICsgZjIgKiBwWzFdLnkgKyBmMyAqIHBbMl0ueSkgLyBkLFxuICAgICAgICB6OiAhXzNkID8gZmFsc2UgOiAoZjEgKiBwWzBdLnogKyBmMiAqIHBbMV0ueiArIGYzICogcFsyXS56KSAvIGQsXG4gICAgICAgIHQ6IHQsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHVwZ3JhZGUgdG8gY3ViaWNcbiAgICBmMSAqPSBtdDtcbiAgICBmMiAqPSAxLjUgKiBtdDtcbiAgICBmMyAqPSAzICogbXQ7XG4gICAgZjQgKj0gdCAqIHQgKiB0O1xuXG4gICAgaWYgKHAubGVuZ3RoID09PSA0KSB7XG4gICAgICBkID0gZjEgKyBmMiArIGYzICsgZjQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAoZjEgKiBwWzBdLnggKyBmMiAqIHBbMV0ueCArIGYzICogcFsyXS54ICsgZjQgKiBwWzNdLngpIC8gZCxcbiAgICAgICAgeTogKGYxICogcFswXS55ICsgZjIgKiBwWzFdLnkgKyBmMyAqIHBbMl0ueSArIGY0ICogcFszXS55KSAvIGQsXG4gICAgICAgIHo6ICFfM2RcbiAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgOiAoZjEgKiBwWzBdLnogKyBmMiAqIHBbMV0ueiArIGYzICogcFsyXS56ICsgZjQgKiBwWzNdLnopIC8gZCxcbiAgICAgICAgdDogdCxcbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIGRlcml2ZTogZnVuY3Rpb24gKHBvaW50cywgXzNkKSB7XG4gICAgY29uc3QgZHBvaW50cyA9IFtdO1xuICAgIGZvciAobGV0IHAgPSBwb2ludHMsIGQgPSBwLmxlbmd0aCwgYyA9IGQgLSAxOyBkID4gMTsgZC0tLCBjLS0pIHtcbiAgICAgIGNvbnN0IGxpc3QgPSBbXTtcbiAgICAgIGZvciAobGV0IGogPSAwLCBkcHQ7IGogPCBjOyBqKyspIHtcbiAgICAgICAgZHB0ID0ge1xuICAgICAgICAgIHg6IGMgKiAocFtqICsgMV0ueCAtIHBbal0ueCksXG4gICAgICAgICAgeTogYyAqIChwW2ogKyAxXS55IC0gcFtqXS55KSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKF8zZCkge1xuICAgICAgICAgIGRwdC56ID0gYyAqIChwW2ogKyAxXS56IC0gcFtqXS56KTtcbiAgICAgICAgfVxuICAgICAgICBsaXN0LnB1c2goZHB0KTtcbiAgICAgIH1cbiAgICAgIGRwb2ludHMucHVzaChsaXN0KTtcbiAgICAgIHAgPSBsaXN0O1xuICAgIH1cbiAgICByZXR1cm4gZHBvaW50cztcbiAgfSxcblxuICBiZXR3ZWVuOiBmdW5jdGlvbiAodiwgbSwgTSkge1xuICAgIHJldHVybiAoXG4gICAgICAobSA8PSB2ICYmIHYgPD0gTSkgfHxcbiAgICAgIHV0aWxzLmFwcHJveGltYXRlbHkodiwgbSkgfHxcbiAgICAgIHV0aWxzLmFwcHJveGltYXRlbHkodiwgTSlcbiAgICApO1xuICB9LFxuXG4gIGFwcHJveGltYXRlbHk6IGZ1bmN0aW9uIChhLCBiLCBwcmVjaXNpb24pIHtcbiAgICByZXR1cm4gYWJzKGEgLSBiKSA8PSAocHJlY2lzaW9uIHx8IGVwc2lsb24pO1xuICB9LFxuXG4gIGxlbmd0aDogZnVuY3Rpb24gKGRlcml2YXRpdmVGbikge1xuICAgIGNvbnN0IHogPSAwLjUsXG4gICAgICBsZW4gPSB1dGlscy5UdmFsdWVzLmxlbmd0aDtcblxuICAgIGxldCBzdW0gPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIHQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgdCA9IHogKiB1dGlscy5UdmFsdWVzW2ldICsgejtcbiAgICAgIHN1bSArPSB1dGlscy5DdmFsdWVzW2ldICogdXRpbHMuYXJjZm4odCwgZGVyaXZhdGl2ZUZuKTtcbiAgICB9XG4gICAgcmV0dXJuIHogKiBzdW07XG4gIH0sXG5cbiAgbWFwOiBmdW5jdGlvbiAodiwgZHMsIGRlLCB0cywgdGUpIHtcbiAgICBjb25zdCBkMSA9IGRlIC0gZHMsXG4gICAgICBkMiA9IHRlIC0gdHMsXG4gICAgICB2MiA9IHYgLSBkcyxcbiAgICAgIHIgPSB2MiAvIGQxO1xuICAgIHJldHVybiB0cyArIGQyICogcjtcbiAgfSxcblxuICBsZXJwOiBmdW5jdGlvbiAociwgdjEsIHYyKSB7XG4gICAgY29uc3QgcmV0ID0ge1xuICAgICAgeDogdjEueCArIHIgKiAodjIueCAtIHYxLngpLFxuICAgICAgeTogdjEueSArIHIgKiAodjIueSAtIHYxLnkpLFxuICAgIH07XG4gICAgaWYgKHYxLnogIT09IHVuZGVmaW5lZCAmJiB2Mi56ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldC56ID0gdjEueiArIHIgKiAodjIueiAtIHYxLnopO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIHBvaW50VG9TdHJpbmc6IGZ1bmN0aW9uIChwKSB7XG4gICAgbGV0IHMgPSBwLnggKyBcIi9cIiArIHAueTtcbiAgICBpZiAodHlwZW9mIHAueiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcyArPSBcIi9cIiArIHAuejtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH0sXG5cbiAgcG9pbnRzVG9TdHJpbmc6IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICByZXR1cm4gXCJbXCIgKyBwb2ludHMubWFwKHV0aWxzLnBvaW50VG9TdHJpbmcpLmpvaW4oXCIsIFwiKSArIFwiXVwiO1xuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgfSxcblxuICBhbmdsZTogZnVuY3Rpb24gKG8sIHYxLCB2Mikge1xuICAgIGNvbnN0IGR4MSA9IHYxLnggLSBvLngsXG4gICAgICBkeTEgPSB2MS55IC0gby55LFxuICAgICAgZHgyID0gdjIueCAtIG8ueCxcbiAgICAgIGR5MiA9IHYyLnkgLSBvLnksXG4gICAgICBjcm9zcyA9IGR4MSAqIGR5MiAtIGR5MSAqIGR4MixcbiAgICAgIGRvdCA9IGR4MSAqIGR4MiArIGR5MSAqIGR5MjtcbiAgICByZXR1cm4gYXRhbjIoY3Jvc3MsIGRvdCk7XG4gIH0sXG5cbiAgLy8gcm91bmQgYXMgc3RyaW5nLCB0byBhdm9pZCByb3VuZGluZyBlcnJvcnNcbiAgcm91bmQ6IGZ1bmN0aW9uICh2LCBkKSB7XG4gICAgY29uc3QgcyA9IFwiXCIgKyB2O1xuICAgIGNvbnN0IHBvcyA9IHMuaW5kZXhPZihcIi5cIik7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQocy5zdWJzdHJpbmcoMCwgcG9zICsgMSArIGQpKTtcbiAgfSxcblxuICBkaXN0OiBmdW5jdGlvbiAocDEsIHAyKSB7XG4gICAgY29uc3QgZHggPSBwMS54IC0gcDIueCxcbiAgICAgIGR5ID0gcDEueSAtIHAyLnk7XG4gICAgcmV0dXJuIHNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICB9LFxuXG4gIGNsb3Nlc3Q6IGZ1bmN0aW9uIChMVVQsIHBvaW50KSB7XG4gICAgbGV0IG1kaXN0ID0gcG93KDIsIDYzKSxcbiAgICAgIG1wb3MsXG4gICAgICBkO1xuICAgIExVVC5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpZHgpIHtcbiAgICAgIGQgPSB1dGlscy5kaXN0KHBvaW50LCBwKTtcbiAgICAgIGlmIChkIDwgbWRpc3QpIHtcbiAgICAgICAgbWRpc3QgPSBkO1xuICAgICAgICBtcG9zID0gaWR4O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7IG1kaXN0OiBtZGlzdCwgbXBvczogbXBvcyB9O1xuICB9LFxuXG4gIGFiY3JhdGlvOiBmdW5jdGlvbiAodCwgbikge1xuICAgIC8vIHNlZSByYXRpbyh0KSBub3RlIG9uIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby8jYWJjXG4gICAgaWYgKG4gIT09IDIgJiYgbiAhPT0gMykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHQgPSAwLjU7XG4gICAgfSBlbHNlIGlmICh0ID09PSAwIHx8IHQgPT09IDEpIHtcbiAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgICBjb25zdCBib3R0b20gPSBwb3codCwgbikgKyBwb3coMSAtIHQsIG4pLFxuICAgICAgdG9wID0gYm90dG9tIC0gMTtcbiAgICByZXR1cm4gYWJzKHRvcCAvIGJvdHRvbSk7XG4gIH0sXG5cbiAgcHJvamVjdGlvbnJhdGlvOiBmdW5jdGlvbiAodCwgbikge1xuICAgIC8vIHNlZSB1KHQpIG5vdGUgb24gaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvLyNhYmNcbiAgICBpZiAobiAhPT0gMiAmJiBuICE9PSAzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdCA9IDAuNTtcbiAgICB9IGVsc2UgaWYgKHQgPT09IDAgfHwgdCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICAgIGNvbnN0IHRvcCA9IHBvdygxIC0gdCwgbiksXG4gICAgICBib3R0b20gPSBwb3codCwgbikgKyB0b3A7XG4gICAgcmV0dXJuIHRvcCAvIGJvdHRvbTtcbiAgfSxcblxuICBsbGk4OiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0KSB7XG4gICAgY29uc3QgbnggPVxuICAgICAgICAoeDEgKiB5MiAtIHkxICogeDIpICogKHgzIC0geDQpIC0gKHgxIC0geDIpICogKHgzICogeTQgLSB5MyAqIHg0KSxcbiAgICAgIG55ID0gKHgxICogeTIgLSB5MSAqIHgyKSAqICh5MyAtIHk0KSAtICh5MSAtIHkyKSAqICh4MyAqIHk0IC0geTMgKiB4NCksXG4gICAgICBkID0gKHgxIC0geDIpICogKHkzIC0geTQpIC0gKHkxIC0geTIpICogKHgzIC0geDQpO1xuICAgIGlmIChkID09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgeDogbnggLyBkLCB5OiBueSAvIGQgfTtcbiAgfSxcblxuICBsbGk0OiBmdW5jdGlvbiAocDEsIHAyLCBwMywgcDQpIHtcbiAgICBjb25zdCB4MSA9IHAxLngsXG4gICAgICB5MSA9IHAxLnksXG4gICAgICB4MiA9IHAyLngsXG4gICAgICB5MiA9IHAyLnksXG4gICAgICB4MyA9IHAzLngsXG4gICAgICB5MyA9IHAzLnksXG4gICAgICB4NCA9IHA0LngsXG4gICAgICB5NCA9IHA0Lnk7XG4gICAgcmV0dXJuIHV0aWxzLmxsaTgoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0KTtcbiAgfSxcblxuICBsbGk6IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICByZXR1cm4gdXRpbHMubGxpNCh2MSwgdjEuYywgdjIsIHYyLmMpO1xuICB9LFxuXG4gIG1ha2VsaW5lOiBmdW5jdGlvbiAocDEsIHAyKSB7XG4gICAgY29uc3QgeDEgPSBwMS54LFxuICAgICAgeTEgPSBwMS55LFxuICAgICAgeDIgPSBwMi54LFxuICAgICAgeTIgPSBwMi55LFxuICAgICAgZHggPSAoeDIgLSB4MSkgLyAzLFxuICAgICAgZHkgPSAoeTIgLSB5MSkgLyAzO1xuICAgIHJldHVybiBuZXcgQmV6aWVyKFxuICAgICAgeDEsXG4gICAgICB5MSxcbiAgICAgIHgxICsgZHgsXG4gICAgICB5MSArIGR5LFxuICAgICAgeDEgKyAyICogZHgsXG4gICAgICB5MSArIDIgKiBkeSxcbiAgICAgIHgyLFxuICAgICAgeTJcbiAgICApO1xuICB9LFxuXG4gIGZpbmRiYm94OiBmdW5jdGlvbiAoc2VjdGlvbnMpIHtcbiAgICBsZXQgbXggPSBuTWF4LFxuICAgICAgbXkgPSBuTWF4LFxuICAgICAgTVggPSBuTWluLFxuICAgICAgTVkgPSBuTWluO1xuICAgIHNlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgIGNvbnN0IGJib3ggPSBzLmJib3goKTtcbiAgICAgIGlmIChteCA+IGJib3gueC5taW4pIG14ID0gYmJveC54Lm1pbjtcbiAgICAgIGlmIChteSA+IGJib3gueS5taW4pIG15ID0gYmJveC55Lm1pbjtcbiAgICAgIGlmIChNWCA8IGJib3gueC5tYXgpIE1YID0gYmJveC54Lm1heDtcbiAgICAgIGlmIChNWSA8IGJib3gueS5tYXgpIE1ZID0gYmJveC55Lm1heDtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeyBtaW46IG14LCBtaWQ6IChteCArIE1YKSAvIDIsIG1heDogTVgsIHNpemU6IE1YIC0gbXggfSxcbiAgICAgIHk6IHsgbWluOiBteSwgbWlkOiAobXkgKyBNWSkgLyAyLCBtYXg6IE1ZLCBzaXplOiBNWSAtIG15IH0sXG4gICAgfTtcbiAgfSxcblxuICBzaGFwZWludGVyc2VjdGlvbnM6IGZ1bmN0aW9uIChcbiAgICBzMSxcbiAgICBiYm94MSxcbiAgICBzMixcbiAgICBiYm94MixcbiAgICBjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZFxuICApIHtcbiAgICBpZiAoIXV0aWxzLmJib3hvdmVybGFwKGJib3gxLCBiYm94MikpIHJldHVybiBbXTtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25zID0gW107XG4gICAgY29uc3QgYTEgPSBbczEuc3RhcnRjYXAsIHMxLmZvcndhcmQsIHMxLmJhY2ssIHMxLmVuZGNhcF07XG4gICAgY29uc3QgYTIgPSBbczIuc3RhcnRjYXAsIHMyLmZvcndhcmQsIHMyLmJhY2ssIHMyLmVuZGNhcF07XG4gICAgYTEuZm9yRWFjaChmdW5jdGlvbiAobDEpIHtcbiAgICAgIGlmIChsMS52aXJ0dWFsKSByZXR1cm47XG4gICAgICBhMi5mb3JFYWNoKGZ1bmN0aW9uIChsMikge1xuICAgICAgICBpZiAobDIudmlydHVhbCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBpc3MgPSBsMS5pbnRlcnNlY3RzKGwyLCBjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZCk7XG4gICAgICAgIGlmIChpc3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlzcy5jMSA9IGwxO1xuICAgICAgICAgIGlzcy5jMiA9IGwyO1xuICAgICAgICAgIGlzcy5zMSA9IHMxO1xuICAgICAgICAgIGlzcy5zMiA9IHMyO1xuICAgICAgICAgIGludGVyc2VjdGlvbnMucHVzaChpc3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgfSxcblxuICBtYWtlc2hhcGU6IGZ1bmN0aW9uIChmb3J3YXJkLCBiYWNrLCBjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZCkge1xuICAgIGNvbnN0IGJwbCA9IGJhY2sucG9pbnRzLmxlbmd0aDtcbiAgICBjb25zdCBmcGwgPSBmb3J3YXJkLnBvaW50cy5sZW5ndGg7XG4gICAgY29uc3Qgc3RhcnQgPSB1dGlscy5tYWtlbGluZShiYWNrLnBvaW50c1ticGwgLSAxXSwgZm9yd2FyZC5wb2ludHNbMF0pO1xuICAgIGNvbnN0IGVuZCA9IHV0aWxzLm1ha2VsaW5lKGZvcndhcmQucG9pbnRzW2ZwbCAtIDFdLCBiYWNrLnBvaW50c1swXSk7XG4gICAgY29uc3Qgc2hhcGUgPSB7XG4gICAgICBzdGFydGNhcDogc3RhcnQsXG4gICAgICBmb3J3YXJkOiBmb3J3YXJkLFxuICAgICAgYmFjazogYmFjayxcbiAgICAgIGVuZGNhcDogZW5kLFxuICAgICAgYmJveDogdXRpbHMuZmluZGJib3goW3N0YXJ0LCBmb3J3YXJkLCBiYWNrLCBlbmRdKSxcbiAgICB9O1xuICAgIHNoYXBlLmludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiAoczIpIHtcbiAgICAgIHJldHVybiB1dGlscy5zaGFwZWludGVyc2VjdGlvbnMoXG4gICAgICAgIHNoYXBlLFxuICAgICAgICBzaGFwZS5iYm94LFxuICAgICAgICBzMixcbiAgICAgICAgczIuYmJveCxcbiAgICAgICAgY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGRcbiAgICAgICk7XG4gICAgfTtcbiAgICByZXR1cm4gc2hhcGU7XG4gIH0sXG5cbiAgZ2V0bWlubWF4OiBmdW5jdGlvbiAoY3VydmUsIGQsIGxpc3QpIHtcbiAgICBpZiAoIWxpc3QpIHJldHVybiB7IG1pbjogMCwgbWF4OiAwIH07XG4gICAgbGV0IG1pbiA9IG5NYXgsXG4gICAgICBtYXggPSBuTWluLFxuICAgICAgdCxcbiAgICAgIGM7XG4gICAgaWYgKGxpc3QuaW5kZXhPZigwKSA9PT0gLTEpIHtcbiAgICAgIGxpc3QgPSBbMF0uY29uY2F0KGxpc3QpO1xuICAgIH1cbiAgICBpZiAobGlzdC5pbmRleE9mKDEpID09PSAtMSkge1xuICAgICAgbGlzdC5wdXNoKDEpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdCA9IGxpc3RbaV07XG4gICAgICBjID0gY3VydmUuZ2V0KHQpO1xuICAgICAgaWYgKGNbZF0gPCBtaW4pIHtcbiAgICAgICAgbWluID0gY1tkXTtcbiAgICAgIH1cbiAgICAgIGlmIChjW2RdID4gbWF4KSB7XG4gICAgICAgIG1heCA9IGNbZF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG1pbjogbWluLCBtaWQ6IChtaW4gKyBtYXgpIC8gMiwgbWF4OiBtYXgsIHNpemU6IG1heCAtIG1pbiB9O1xuICB9LFxuXG4gIGFsaWduOiBmdW5jdGlvbiAocG9pbnRzLCBsaW5lKSB7XG4gICAgY29uc3QgdHggPSBsaW5lLnAxLngsXG4gICAgICB0eSA9IGxpbmUucDEueSxcbiAgICAgIGEgPSAtYXRhbjIobGluZS5wMi55IC0gdHksIGxpbmUucDIueCAtIHR4KSxcbiAgICAgIGQgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6ICh2LnggLSB0eCkgKiBjb3MoYSkgLSAodi55IC0gdHkpICogc2luKGEpLFxuICAgICAgICAgIHk6ICh2LnggLSB0eCkgKiBzaW4oYSkgKyAodi55IC0gdHkpICogY29zKGEpLFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICByZXR1cm4gcG9pbnRzLm1hcChkKTtcbiAgfSxcblxuICByb290czogZnVuY3Rpb24gKHBvaW50cywgbGluZSkge1xuICAgIGxpbmUgPSBsaW5lIHx8IHsgcDE6IHsgeDogMCwgeTogMCB9LCBwMjogeyB4OiAxLCB5OiAwIH0gfTtcblxuICAgIGNvbnN0IG9yZGVyID0gcG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgYWxpZ25lZCA9IHV0aWxzLmFsaWduKHBvaW50cywgbGluZSk7XG4gICAgY29uc3QgcmVkdWNlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiAwIDw9IHQgJiYgdCA8PSAxO1xuICAgIH07XG5cbiAgICBpZiAob3JkZXIgPT09IDIpIHtcbiAgICAgIGNvbnN0IGEgPSBhbGlnbmVkWzBdLnksXG4gICAgICAgIGIgPSBhbGlnbmVkWzFdLnksXG4gICAgICAgIGMgPSBhbGlnbmVkWzJdLnksXG4gICAgICAgIGQgPSBhIC0gMiAqIGIgKyBjO1xuICAgICAgaWYgKGQgIT09IDApIHtcbiAgICAgICAgY29uc3QgbTEgPSAtc3FydChiICogYiAtIGEgKiBjKSxcbiAgICAgICAgICBtMiA9IC1hICsgYixcbiAgICAgICAgICB2MSA9IC0obTEgKyBtMikgLyBkLFxuICAgICAgICAgIHYyID0gLSgtbTEgKyBtMikgLyBkO1xuICAgICAgICByZXR1cm4gW3YxLCB2Ml0uZmlsdGVyKHJlZHVjZSk7XG4gICAgICB9IGVsc2UgaWYgKGIgIT09IGMgJiYgZCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gWygyICogYiAtIGMpIC8gKDIgKiBiIC0gMiAqIGMpXS5maWx0ZXIocmVkdWNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvLyBzZWUgaHR0cDovL3d3dy50cmFuczRtaW5kLmNvbS9wZXJzb25hbF9kZXZlbG9wbWVudC9tYXRoZW1hdGljcy9wb2x5bm9taWFscy9jdWJpY0FsZ2VicmEuaHRtXG4gICAgY29uc3QgcGEgPSBhbGlnbmVkWzBdLnksXG4gICAgICBwYiA9IGFsaWduZWRbMV0ueSxcbiAgICAgIHBjID0gYWxpZ25lZFsyXS55LFxuICAgICAgcGQgPSBhbGlnbmVkWzNdLnk7XG5cbiAgICBsZXQgZCA9IC1wYSArIDMgKiBwYiAtIDMgKiBwYyArIHBkLFxuICAgICAgYSA9IDMgKiBwYSAtIDYgKiBwYiArIDMgKiBwYyxcbiAgICAgIGIgPSAtMyAqIHBhICsgMyAqIHBiLFxuICAgICAgYyA9IHBhO1xuXG4gICAgaWYgKHV0aWxzLmFwcHJveGltYXRlbHkoZCwgMCkpIHtcbiAgICAgIC8vIHRoaXMgaXMgbm90IGEgY3ViaWMgY3VydmUuXG4gICAgICBpZiAodXRpbHMuYXBwcm94aW1hdGVseShhLCAwKSkge1xuICAgICAgICAvLyBpbiBmYWN0LCB0aGlzIGlzIG5vdCBhIHF1YWRyYXRpYyBjdXJ2ZSBlaXRoZXIuXG4gICAgICAgIGlmICh1dGlscy5hcHByb3hpbWF0ZWx5KGIsIDApKSB7XG4gICAgICAgICAgLy8gaW4gZmFjdCBpbiBmYWN0LCB0aGVyZSBhcmUgbm8gc29sdXRpb25zLlxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsaW5lYXIgc29sdXRpb246XG4gICAgICAgIHJldHVybiBbLWMgLyBiXS5maWx0ZXIocmVkdWNlKTtcbiAgICAgIH1cbiAgICAgIC8vIHF1YWRyYXRpYyBzb2x1dGlvbjpcbiAgICAgIGNvbnN0IHEgPSBzcXJ0KGIgKiBiIC0gNCAqIGEgKiBjKSxcbiAgICAgICAgYTIgPSAyICogYTtcbiAgICAgIHJldHVybiBbKHEgLSBiKSAvIGEyLCAoLWIgLSBxKSAvIGEyXS5maWx0ZXIocmVkdWNlKTtcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCB3ZSBrbm93IHdlIG5lZWQgYSBjdWJpYyBzb2x1dGlvbjpcblxuICAgIGEgLz0gZDtcbiAgICBiIC89IGQ7XG4gICAgYyAvPSBkO1xuXG4gICAgY29uc3QgcCA9ICgzICogYiAtIGEgKiBhKSAvIDMsXG4gICAgICBwMyA9IHAgLyAzLFxuICAgICAgcSA9ICgyICogYSAqIGEgKiBhIC0gOSAqIGEgKiBiICsgMjcgKiBjKSAvIDI3LFxuICAgICAgcTIgPSBxIC8gMixcbiAgICAgIGRpc2NyaW1pbmFudCA9IHEyICogcTIgKyBwMyAqIHAzICogcDM7XG5cbiAgICBsZXQgdTEsIHYxLCB4MSwgeDIsIHgzO1xuICAgIGlmIChkaXNjcmltaW5hbnQgPCAwKSB7XG4gICAgICBjb25zdCBtcDMgPSAtcCAvIDMsXG4gICAgICAgIG1wMzMgPSBtcDMgKiBtcDMgKiBtcDMsXG4gICAgICAgIHIgPSBzcXJ0KG1wMzMpLFxuICAgICAgICB0ID0gLXEgLyAoMiAqIHIpLFxuICAgICAgICBjb3NwaGkgPSB0IDwgLTEgPyAtMSA6IHQgPiAxID8gMSA6IHQsXG4gICAgICAgIHBoaSA9IGFjb3MoY29zcGhpKSxcbiAgICAgICAgY3J0ciA9IGNydChyKSxcbiAgICAgICAgdDEgPSAyICogY3J0cjtcbiAgICAgIHgxID0gdDEgKiBjb3MocGhpIC8gMykgLSBhIC8gMztcbiAgICAgIHgyID0gdDEgKiBjb3MoKHBoaSArIHRhdSkgLyAzKSAtIGEgLyAzO1xuICAgICAgeDMgPSB0MSAqIGNvcygocGhpICsgMiAqIHRhdSkgLyAzKSAtIGEgLyAzO1xuICAgICAgcmV0dXJuIFt4MSwgeDIsIHgzXS5maWx0ZXIocmVkdWNlKTtcbiAgICB9IGVsc2UgaWYgKGRpc2NyaW1pbmFudCA9PT0gMCkge1xuICAgICAgdTEgPSBxMiA8IDAgPyBjcnQoLXEyKSA6IC1jcnQocTIpO1xuICAgICAgeDEgPSAyICogdTEgLSBhIC8gMztcbiAgICAgIHgyID0gLXUxIC0gYSAvIDM7XG4gICAgICByZXR1cm4gW3gxLCB4Ml0uZmlsdGVyKHJlZHVjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNkID0gc3FydChkaXNjcmltaW5hbnQpO1xuICAgICAgdTEgPSBjcnQoLXEyICsgc2QpO1xuICAgICAgdjEgPSBjcnQocTIgKyBzZCk7XG4gICAgICByZXR1cm4gW3UxIC0gdjEgLSBhIC8gM10uZmlsdGVyKHJlZHVjZSk7XG4gICAgfVxuICB9LFxuXG4gIGRyb290czogZnVuY3Rpb24gKHApIHtcbiAgICAvLyBxdWFkcmF0aWMgcm9vdHMgYXJlIGVhc3lcbiAgICBpZiAocC5sZW5ndGggPT09IDMpIHtcbiAgICAgIGNvbnN0IGEgPSBwWzBdLFxuICAgICAgICBiID0gcFsxXSxcbiAgICAgICAgYyA9IHBbMl0sXG4gICAgICAgIGQgPSBhIC0gMiAqIGIgKyBjO1xuICAgICAgaWYgKGQgIT09IDApIHtcbiAgICAgICAgY29uc3QgbTEgPSAtc3FydChiICogYiAtIGEgKiBjKSxcbiAgICAgICAgICBtMiA9IC1hICsgYixcbiAgICAgICAgICB2MSA9IC0obTEgKyBtMikgLyBkLFxuICAgICAgICAgIHYyID0gLSgtbTEgKyBtMikgLyBkO1xuICAgICAgICByZXR1cm4gW3YxLCB2Ml07XG4gICAgICB9IGVsc2UgaWYgKGIgIT09IGMgJiYgZCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gWygyICogYiAtIGMpIC8gKDIgKiAoYiAtIGMpKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gbGluZWFyIHJvb3RzIGFyZSBldmVuIGVhc2llclxuICAgIGlmIChwLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3QgYSA9IHBbMF0sXG4gICAgICAgIGIgPSBwWzFdO1xuICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgcmV0dXJuIFthIC8gKGEgLSBiKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9LFxuXG4gIGN1cnZhdHVyZTogZnVuY3Rpb24gKHQsIGQxLCBkMiwgXzNkLCBrT25seSkge1xuICAgIGxldCBudW0sXG4gICAgICBkbm0sXG4gICAgICBhZGssXG4gICAgICBkayxcbiAgICAgIGsgPSAwLFxuICAgICAgciA9IDA7XG5cbiAgICAvL1xuICAgIC8vIFdlJ3JlIHVzaW5nIHRoZSBmb2xsb3dpbmcgZm9ybXVsYSBmb3IgY3VydmF0dXJlOlxuICAgIC8vXG4gICAgLy8gICAgICAgICAgICAgIHgneVwiIC0geSd4XCJcbiAgICAvLyAgIGsodCkgPSAtLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAgICAgICAgICAgKHgnwrIgKyB5J8KyKV4oMy8yKVxuICAgIC8vXG4gICAgLy8gZnJvbSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYWRpdXNfb2ZfY3VydmF0dXJlI0RlZmluaXRpb25cbiAgICAvL1xuICAgIC8vIFdpdGggaXQgY29ycmVzcG9uZGluZyAzRCBjb3VudGVycGFydDpcbiAgICAvL1xuICAgIC8vICAgICAgICAgIHNxcnQoICh5J3pcIiAtIHlcInonKcKyICsgKHoneFwiIC0gelwieCcpwrIgKyAoeCd5XCIgLSB4XCJ5JynCsilcbiAgICAvLyAgIGsodCkgPSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAoeCfCsiArIHknwrIgKyB6J8KyKV4oMy8yKVxuICAgIC8vXG5cbiAgICBjb25zdCBkID0gdXRpbHMuY29tcHV0ZSh0LCBkMSk7XG4gICAgY29uc3QgZGQgPSB1dGlscy5jb21wdXRlKHQsIGQyKTtcbiAgICBjb25zdCBxZHN1bSA9IGQueCAqIGQueCArIGQueSAqIGQueTtcblxuICAgIGlmIChfM2QpIHtcbiAgICAgIG51bSA9IHNxcnQoXG4gICAgICAgIHBvdyhkLnkgKiBkZC56IC0gZGQueSAqIGQueiwgMikgK1xuICAgICAgICAgIHBvdyhkLnogKiBkZC54IC0gZGQueiAqIGQueCwgMikgK1xuICAgICAgICAgIHBvdyhkLnggKiBkZC55IC0gZGQueCAqIGQueSwgMilcbiAgICAgICk7XG4gICAgICBkbm0gPSBwb3cocWRzdW0gKyBkLnogKiBkLnosIDMgLyAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtID0gZC54ICogZGQueSAtIGQueSAqIGRkLng7XG4gICAgICBkbm0gPSBwb3cocWRzdW0sIDMgLyAyKTtcbiAgICB9XG5cbiAgICBpZiAobnVtID09PSAwIHx8IGRubSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHsgazogMCwgcjogMCB9O1xuICAgIH1cblxuICAgIGsgPSBudW0gLyBkbm07XG4gICAgciA9IGRubSAvIG51bTtcblxuICAgIC8vIFdlJ3JlIGFsc28gY29tcHV0aW5nIHRoZSBkZXJpdmF0aXZlIG9mIGthcHBhLCBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgdmFsdWUgaW4ga25vd2luZyB0aGUgcmF0ZSBvZiBjaGFuZ2UgZm9yIHRoZVxuICAgIC8vIGN1cnZhdHVyZSBhbG9uZyB0aGUgY3VydmUuIEFuZCB3ZSdyZSBqdXN0IGdvaW5nIHRvXG4gICAgLy8gYmFsbHBhcmsgaXQgYmFzZWQgb24gYW4gZXBzaWxvbi5cbiAgICBpZiAoIWtPbmx5KSB7XG4gICAgICAvLyBjb21wdXRlIGsnKHQpIGJhc2VkIG9uIHRoZSBpbnRlcnZhbCBiZWZvcmUsIGFuZCBhZnRlciBpdCxcbiAgICAgIC8vIHRvIGF0IGxlYXN0IHRyeSB0byBub3QgaW50cm9kdWNlIGZvcndhcmQvYmFja3dhcmQgcGFzcyBiaWFzLlxuICAgICAgY29uc3QgcGsgPSB1dGlscy5jdXJ2YXR1cmUodCAtIDAuMDAxLCBkMSwgZDIsIF8zZCwgdHJ1ZSkuaztcbiAgICAgIGNvbnN0IG5rID0gdXRpbHMuY3VydmF0dXJlKHQgKyAwLjAwMSwgZDEsIGQyLCBfM2QsIHRydWUpLms7XG4gICAgICBkayA9IChuayAtIGsgKyAoayAtIHBrKSkgLyAyO1xuICAgICAgYWRrID0gKGFicyhuayAtIGspICsgYWJzKGsgLSBwaykpIC8gMjtcbiAgICB9XG5cbiAgICByZXR1cm4geyBrOiBrLCByOiByLCBkazogZGssIGFkazogYWRrIH07XG4gIH0sXG5cbiAgaW5mbGVjdGlvbnM6IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDQpIHJldHVybiBbXTtcblxuICAgIC8vIEZJWE1FOiBUT0RPOiBhZGQgaW4gaW5mbGVjdGlvbiBhYnN0cmFjdGlvbiBmb3IgcXVhcnRpYysgY3VydmVzP1xuXG4gICAgY29uc3QgcCA9IHV0aWxzLmFsaWduKHBvaW50cywgeyBwMTogcG9pbnRzWzBdLCBwMjogcG9pbnRzLnNsaWNlKC0xKVswXSB9KSxcbiAgICAgIGEgPSBwWzJdLnggKiBwWzFdLnksXG4gICAgICBiID0gcFszXS54ICogcFsxXS55LFxuICAgICAgYyA9IHBbMV0ueCAqIHBbMl0ueSxcbiAgICAgIGQgPSBwWzNdLnggKiBwWzJdLnksXG4gICAgICB2MSA9IDE4ICogKC0zICogYSArIDIgKiBiICsgMyAqIGMgLSBkKSxcbiAgICAgIHYyID0gMTggKiAoMyAqIGEgLSBiIC0gMyAqIGMpLFxuICAgICAgdjMgPSAxOCAqIChjIC0gYSk7XG5cbiAgICBpZiAodXRpbHMuYXBwcm94aW1hdGVseSh2MSwgMCkpIHtcbiAgICAgIGlmICghdXRpbHMuYXBwcm94aW1hdGVseSh2MiwgMCkpIHtcbiAgICAgICAgbGV0IHQgPSAtdjMgLyB2MjtcbiAgICAgICAgaWYgKDAgPD0gdCAmJiB0IDw9IDEpIHJldHVybiBbdF07XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgdHJtID0gdjIgKiB2MiAtIDQgKiB2MSAqIHYzLFxuICAgICAgc3EgPSBNYXRoLnNxcnQodHJtKSxcbiAgICAgIGQyID0gMiAqIHYxO1xuXG4gICAgaWYgKHV0aWxzLmFwcHJveGltYXRlbHkoZDIsIDApKSByZXR1cm4gW107XG5cbiAgICByZXR1cm4gWyhzcSAtIHYyKSAvIGQyLCAtKHYyICsgc3EpIC8gZDJdLmZpbHRlcihmdW5jdGlvbiAocikge1xuICAgICAgcmV0dXJuIDAgPD0gciAmJiByIDw9IDE7XG4gICAgfSk7XG4gIH0sXG5cbiAgYmJveG92ZXJsYXA6IGZ1bmN0aW9uIChiMSwgYjIpIHtcbiAgICBjb25zdCBkaW1zID0gW1wieFwiLCBcInlcIl0sXG4gICAgICBsZW4gPSBkaW1zLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwLCBkaW0sIGwsIHQsIGQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGltID0gZGltc1tpXTtcbiAgICAgIGwgPSBiMVtkaW1dLm1pZDtcbiAgICAgIHQgPSBiMltkaW1dLm1pZDtcbiAgICAgIGQgPSAoYjFbZGltXS5zaXplICsgYjJbZGltXS5zaXplKSAvIDI7XG4gICAgICBpZiAoYWJzKGwgLSB0KSA+PSBkKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIGV4cGFuZGJveDogZnVuY3Rpb24gKGJib3gsIF9iYm94KSB7XG4gICAgaWYgKF9iYm94LngubWluIDwgYmJveC54Lm1pbikge1xuICAgICAgYmJveC54Lm1pbiA9IF9iYm94LngubWluO1xuICAgIH1cbiAgICBpZiAoX2Jib3gueS5taW4gPCBiYm94LnkubWluKSB7XG4gICAgICBiYm94LnkubWluID0gX2Jib3gueS5taW47XG4gICAgfVxuICAgIGlmIChfYmJveC56ICYmIF9iYm94LnoubWluIDwgYmJveC56Lm1pbikge1xuICAgICAgYmJveC56Lm1pbiA9IF9iYm94LnoubWluO1xuICAgIH1cbiAgICBpZiAoX2Jib3gueC5tYXggPiBiYm94LngubWF4KSB7XG4gICAgICBiYm94LngubWF4ID0gX2Jib3gueC5tYXg7XG4gICAgfVxuICAgIGlmIChfYmJveC55Lm1heCA+IGJib3gueS5tYXgpIHtcbiAgICAgIGJib3gueS5tYXggPSBfYmJveC55Lm1heDtcbiAgICB9XG4gICAgaWYgKF9iYm94LnogJiYgX2Jib3guei5tYXggPiBiYm94LnoubWF4KSB7XG4gICAgICBiYm94LnoubWF4ID0gX2Jib3guei5tYXg7XG4gICAgfVxuICAgIGJib3gueC5taWQgPSAoYmJveC54Lm1pbiArIGJib3gueC5tYXgpIC8gMjtcbiAgICBiYm94LnkubWlkID0gKGJib3gueS5taW4gKyBiYm94LnkubWF4KSAvIDI7XG4gICAgaWYgKGJib3gueikge1xuICAgICAgYmJveC56Lm1pZCA9IChiYm94LnoubWluICsgYmJveC56Lm1heCkgLyAyO1xuICAgIH1cbiAgICBiYm94Lnguc2l6ZSA9IGJib3gueC5tYXggLSBiYm94LngubWluO1xuICAgIGJib3gueS5zaXplID0gYmJveC55Lm1heCAtIGJib3gueS5taW47XG4gICAgaWYgKGJib3gueikge1xuICAgICAgYmJveC56LnNpemUgPSBiYm94LnoubWF4IC0gYmJveC56Lm1pbjtcbiAgICB9XG4gIH0sXG5cbiAgcGFpcml0ZXJhdGlvbjogZnVuY3Rpb24gKGMxLCBjMiwgY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGQpIHtcbiAgICBjb25zdCBjMWIgPSBjMS5iYm94KCksXG4gICAgICBjMmIgPSBjMi5iYm94KCksXG4gICAgICByID0gMTAwMDAwLFxuICAgICAgdGhyZXNob2xkID0gY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGQgfHwgMC41O1xuXG4gICAgaWYgKFxuICAgICAgYzFiLnguc2l6ZSArIGMxYi55LnNpemUgPCB0aHJlc2hvbGQgJiZcbiAgICAgIGMyYi54LnNpemUgKyBjMmIueS5zaXplIDwgdGhyZXNob2xkXG4gICAgKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAoKChyICogKGMxLl90MSArIGMxLl90MikpIC8gMikgfCAwKSAvIHIgK1xuICAgICAgICAgIFwiL1wiICtcbiAgICAgICAgICAoKChyICogKGMyLl90MSArIGMyLl90MikpIC8gMikgfCAwKSAvIHIsXG4gICAgICBdO1xuICAgIH1cblxuICAgIGxldCBjYzEgPSBjMS5zcGxpdCgwLjUpLFxuICAgICAgY2MyID0gYzIuc3BsaXQoMC41KSxcbiAgICAgIHBhaXJzID0gW1xuICAgICAgICB7IGxlZnQ6IGNjMS5sZWZ0LCByaWdodDogY2MyLmxlZnQgfSxcbiAgICAgICAgeyBsZWZ0OiBjYzEubGVmdCwgcmlnaHQ6IGNjMi5yaWdodCB9LFxuICAgICAgICB7IGxlZnQ6IGNjMS5yaWdodCwgcmlnaHQ6IGNjMi5yaWdodCB9LFxuICAgICAgICB7IGxlZnQ6IGNjMS5yaWdodCwgcmlnaHQ6IGNjMi5sZWZ0IH0sXG4gICAgICBdO1xuXG4gICAgcGFpcnMgPSBwYWlycy5maWx0ZXIoZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgIHJldHVybiB1dGlscy5iYm94b3ZlcmxhcChwYWlyLmxlZnQuYmJveCgpLCBwYWlyLnJpZ2h0LmJib3goKSk7XG4gICAgfSk7XG5cbiAgICBsZXQgcmVzdWx0cyA9IFtdO1xuXG4gICAgaWYgKHBhaXJzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJlc3VsdHM7XG5cbiAgICBwYWlycy5mb3JFYWNoKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICByZXN1bHRzID0gcmVzdWx0cy5jb25jYXQoXG4gICAgICAgIHV0aWxzLnBhaXJpdGVyYXRpb24ocGFpci5sZWZ0LCBwYWlyLnJpZ2h0LCB0aHJlc2hvbGQpXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmVzdWx0cyA9IHJlc3VsdHMuZmlsdGVyKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0cy5pbmRleE9mKHYpID09PSBpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH0sXG5cbiAgZ2V0Y2NlbnRlcjogZnVuY3Rpb24gKHAxLCBwMiwgcDMpIHtcbiAgICBjb25zdCBkeDEgPSBwMi54IC0gcDEueCxcbiAgICAgIGR5MSA9IHAyLnkgLSBwMS55LFxuICAgICAgZHgyID0gcDMueCAtIHAyLngsXG4gICAgICBkeTIgPSBwMy55IC0gcDIueSxcbiAgICAgIGR4MXAgPSBkeDEgKiBjb3MocXVhcnQpIC0gZHkxICogc2luKHF1YXJ0KSxcbiAgICAgIGR5MXAgPSBkeDEgKiBzaW4ocXVhcnQpICsgZHkxICogY29zKHF1YXJ0KSxcbiAgICAgIGR4MnAgPSBkeDIgKiBjb3MocXVhcnQpIC0gZHkyICogc2luKHF1YXJ0KSxcbiAgICAgIGR5MnAgPSBkeDIgKiBzaW4ocXVhcnQpICsgZHkyICogY29zKHF1YXJ0KSxcbiAgICAgIC8vIGNob3JkIG1pZHBvaW50c1xuICAgICAgbXgxID0gKHAxLnggKyBwMi54KSAvIDIsXG4gICAgICBteTEgPSAocDEueSArIHAyLnkpIC8gMixcbiAgICAgIG14MiA9IChwMi54ICsgcDMueCkgLyAyLFxuICAgICAgbXkyID0gKHAyLnkgKyBwMy55KSAvIDIsXG4gICAgICAvLyBtaWRwb2ludCBvZmZzZXRzXG4gICAgICBteDFuID0gbXgxICsgZHgxcCxcbiAgICAgIG15MW4gPSBteTEgKyBkeTFwLFxuICAgICAgbXgybiA9IG14MiArIGR4MnAsXG4gICAgICBteTJuID0gbXkyICsgZHkycCxcbiAgICAgIC8vIGludGVyc2VjdGlvbiBvZiB0aGVzZSBsaW5lczpcbiAgICAgIGFyYyA9IHV0aWxzLmxsaTgobXgxLCBteTEsIG14MW4sIG15MW4sIG14MiwgbXkyLCBteDJuLCBteTJuKSxcbiAgICAgIHIgPSB1dGlscy5kaXN0KGFyYywgcDEpO1xuXG4gICAgLy8gYXJjIHN0YXJ0L2VuZCB2YWx1ZXMsIG92ZXIgbWlkIHBvaW50OlxuICAgIGxldCBzID0gYXRhbjIocDEueSAtIGFyYy55LCBwMS54IC0gYXJjLngpLFxuICAgICAgbSA9IGF0YW4yKHAyLnkgLSBhcmMueSwgcDIueCAtIGFyYy54KSxcbiAgICAgIGUgPSBhdGFuMihwMy55IC0gYXJjLnksIHAzLnggLSBhcmMueCksXG4gICAgICBfO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGFyYyBkaXJlY3Rpb24gKGN3L2NjdyBjb3JyZWN0aW9uKVxuICAgIGlmIChzIDwgZSkge1xuICAgICAgLy8gaWYgczxtPGUsIGFyYyhzLCBlKVxuICAgICAgLy8gaWYgbTxzPGUsIGFyYyhlLCBzICsgdGF1KVxuICAgICAgLy8gaWYgczxlPG0sIGFyYyhlLCBzICsgdGF1KVxuICAgICAgaWYgKHMgPiBtIHx8IG0gPiBlKSB7XG4gICAgICAgIHMgKz0gdGF1O1xuICAgICAgfVxuICAgICAgaWYgKHMgPiBlKSB7XG4gICAgICAgIF8gPSBlO1xuICAgICAgICBlID0gcztcbiAgICAgICAgcyA9IF87XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGU8bTxzLCBhcmMoZSwgcylcbiAgICAgIC8vIGlmIG08ZTxzLCBhcmMocywgZSArIHRhdSlcbiAgICAgIC8vIGlmIGU8czxtLCBhcmMocywgZSArIHRhdSlcbiAgICAgIGlmIChlIDwgbSAmJiBtIDwgcykge1xuICAgICAgICBfID0gZTtcbiAgICAgICAgZSA9IHM7XG4gICAgICAgIHMgPSBfO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZSArPSB0YXU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGFzc2lnbiBhbmQgZG9uZS5cbiAgICBhcmMucyA9IHM7XG4gICAgYXJjLmUgPSBlO1xuICAgIGFyYy5yID0gcjtcbiAgICByZXR1cm4gYXJjO1xuICB9LFxuXG4gIG51bWJlclNvcnQ6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xuICB9LFxufTtcblxuZXhwb3J0IHsgdXRpbHMgfTtcbiIsImltcG9ydCB7IHV0aWxzIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcblxuLyoqXG4gKiBQb2x5IEJlemllclxuICogQHBhcmFtIHtbdHlwZV19IGN1cnZlcyBbZGVzY3JpcHRpb25dXG4gKi9cbmNsYXNzIFBvbHlCZXppZXIge1xuICBjb25zdHJ1Y3RvcihjdXJ2ZXMpIHtcbiAgICB0aGlzLmN1cnZlcyA9IFtdO1xuICAgIHRoaXMuXzNkID0gZmFsc2U7XG4gICAgaWYgKCEhY3VydmVzKSB7XG4gICAgICB0aGlzLmN1cnZlcyA9IGN1cnZlcztcbiAgICAgIHRoaXMuXzNkID0gdGhpcy5jdXJ2ZXNbMF0uXzNkO1xuICAgIH1cbiAgfVxuXG4gIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAoXG4gICAgICBcIltcIiArXG4gICAgICB0aGlzLmN1cnZlc1xuICAgICAgICAubWFwKGZ1bmN0aW9uIChjdXJ2ZSkge1xuICAgICAgICAgIHJldHVybiB1dGlscy5wb2ludHNUb1N0cmluZyhjdXJ2ZS5wb2ludHMpO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbihcIiwgXCIpICtcbiAgICAgIFwiXVwiXG4gICAgKTtcbiAgfVxuXG4gIGFkZEN1cnZlKGN1cnZlKSB7XG4gICAgdGhpcy5jdXJ2ZXMucHVzaChjdXJ2ZSk7XG4gICAgdGhpcy5fM2QgPSB0aGlzLl8zZCB8fCBjdXJ2ZS5fM2Q7XG4gIH1cblxuICBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VydmVzXG4gICAgICAubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB2Lmxlbmd0aCgpO1xuICAgICAgfSlcbiAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgKyBiO1xuICAgICAgfSk7XG4gIH1cblxuICBjdXJ2ZShpZHgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZXNbaWR4XTtcbiAgfVxuXG4gIGJib3goKSB7XG4gICAgY29uc3QgYyA9IHRoaXMuY3VydmVzO1xuICAgIHZhciBiYm94ID0gY1swXS5iYm94KCk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XG4gICAgICB1dGlscy5leHBhbmRib3goYmJveCwgY1tpXS5iYm94KCkpO1xuICAgIH1cbiAgICByZXR1cm4gYmJveDtcbiAgfVxuXG4gIG9mZnNldChkKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gW107XG4gICAgdGhpcy5jdXJ2ZXMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgb2Zmc2V0LnB1c2goLi4udi5vZmZzZXQoZCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUG9seUJlemllcihvZmZzZXQpO1xuICB9XG59XG5cbmV4cG9ydCB7IFBvbHlCZXppZXIgfTtcbiIsIi8qKlxuICBBIGphdmFzY3JpcHQgQmV6aWVyIGN1cnZlIGxpYnJhcnkgYnkgUG9tYXguXG5cbiAgQmFzZWQgb24gaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvXG5cbiAgVGhpcyBjb2RlIGlzIE1JVCBsaWNlbnNlZC5cbioqL1xuXG5pbXBvcnQgeyB1dGlscyB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBQb2x5QmV6aWVyIH0gZnJvbSBcIi4vcG9seS1iZXppZXIuanNcIjtcblxuLy8gbWF0aC1pbmxpbmluZy5cbmNvbnN0IHsgYWJzLCBtaW4sIG1heCwgY29zLCBzaW4sIGFjb3MsIHNxcnQgfSA9IE1hdGg7XG5jb25zdCBwaSA9IE1hdGguUEk7XG4vLyBhIHplcm8gY29vcmRpbmF0ZSwgd2hpY2ggaXMgc3VycHJpc2luZ2x5IHVzZWZ1bFxuY29uc3QgWkVSTyA9IHsgeDogMCwgeTogMCwgejogMCB9O1xuXG4vKipcbiAqIEJlemllciBjdXJ2ZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiAuLi5kb2NzIHBlbmRpbmcuLi5cbiAqL1xuY2xhc3MgQmV6aWVyIHtcbiAgY29uc3RydWN0b3IoY29vcmRzKSB7XG4gICAgbGV0IGFyZ3MgPVxuICAgICAgY29vcmRzICYmIGNvb3Jkcy5mb3JFYWNoID8gY29vcmRzIDogQXJyYXkuZnJvbShhcmd1bWVudHMpLnNsaWNlKCk7XG4gICAgbGV0IGNvb3JkbGVuID0gZmFsc2U7XG5cbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvb3JkbGVuID0gYXJncy5sZW5ndGg7XG4gICAgICBjb25zdCBuZXdhcmdzID0gW107XG4gICAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIFtcInhcIiwgXCJ5XCIsIFwielwiXS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwb2ludFtkXSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbmV3YXJncy5wdXNoKHBvaW50W2RdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBhcmdzID0gbmV3YXJncztcbiAgICB9XG5cbiAgICBsZXQgaGlnaGVyID0gZmFsc2U7XG4gICAgY29uc3QgbGVuID0gYXJncy5sZW5ndGg7XG5cbiAgICBpZiAoY29vcmRsZW4pIHtcbiAgICAgIGlmIChjb29yZGxlbiA+IDQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIk9ubHkgbmV3IEJlemllcihwb2ludFtdKSBpcyBhY2NlcHRlZCBmb3IgNHRoIGFuZCBoaWdoZXIgb3JkZXIgY3VydmVzXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGhpZ2hlciA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsZW4gIT09IDYgJiYgbGVuICE9PSA4ICYmIGxlbiAhPT0gOSAmJiBsZW4gIT09IDEyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJPbmx5IG5ldyBCZXppZXIocG9pbnRbXSkgaXMgYWNjZXB0ZWQgZm9yIDR0aCBhbmQgaGlnaGVyIG9yZGVyIGN1cnZlc1wiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IF8zZCA9ICh0aGlzLl8zZCA9XG4gICAgICAoIWhpZ2hlciAmJiAobGVuID09PSA5IHx8IGxlbiA9PT0gMTIpKSB8fFxuICAgICAgKGNvb3JkcyAmJiBjb29yZHNbMF0gJiYgdHlwZW9mIGNvb3Jkc1swXS56ICE9PSBcInVuZGVmaW5lZFwiKSk7XG5cbiAgICBjb25zdCBwb2ludHMgPSAodGhpcy5wb2ludHMgPSBbXSk7XG4gICAgZm9yIChsZXQgaWR4ID0gMCwgc3RlcCA9IF8zZCA/IDMgOiAyOyBpZHggPCBsZW47IGlkeCArPSBzdGVwKSB7XG4gICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgIHg6IGFyZ3NbaWR4XSxcbiAgICAgICAgeTogYXJnc1tpZHggKyAxXSxcbiAgICAgIH07XG4gICAgICBpZiAoXzNkKSB7XG4gICAgICAgIHBvaW50LnogPSBhcmdzW2lkeCArIDJdO1xuICAgICAgfVxuICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgIH1cbiAgICBjb25zdCBvcmRlciA9ICh0aGlzLm9yZGVyID0gcG9pbnRzLmxlbmd0aCAtIDEpO1xuXG4gICAgY29uc3QgZGltcyA9ICh0aGlzLmRpbXMgPSBbXCJ4XCIsIFwieVwiXSk7XG4gICAgaWYgKF8zZCkgZGltcy5wdXNoKFwielwiKTtcbiAgICB0aGlzLmRpbWxlbiA9IGRpbXMubGVuZ3RoO1xuXG4gICAgY29uc3QgYWxpZ25lZCA9IHV0aWxzLmFsaWduKHBvaW50cywgeyBwMTogcG9pbnRzWzBdLCBwMjogcG9pbnRzW29yZGVyXSB9KTtcbiAgICB0aGlzLl9saW5lYXIgPSAhYWxpZ25lZC5zb21lKChwKSA9PiBhYnMocC55KSA+IDAuMDAwMSk7XG5cbiAgICB0aGlzLl9sdXQgPSBbXTtcblxuICAgIHRoaXMuX3QxID0gMDtcbiAgICB0aGlzLl90MiA9IDE7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIHN0YXRpYyBxdWFkcmF0aWNGcm9tUG9pbnRzKHAxLCBwMiwgcDMsIHQpIHtcbiAgICBpZiAodHlwZW9mIHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHQgPSAwLjU7XG4gICAgfVxuICAgIC8vIHNob3J0Y3V0cywgYWx0aG91Z2ggdGhleSdyZSByZWFsbHkgZHVtYlxuICAgIGlmICh0ID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IEJlemllcihwMiwgcDIsIHAzKTtcbiAgICB9XG4gICAgaWYgKHQgPT09IDEpIHtcbiAgICAgIHJldHVybiBuZXcgQmV6aWVyKHAxLCBwMiwgcDIpO1xuICAgIH1cbiAgICAvLyByZWFsIGZpdHRpbmcuXG4gICAgY29uc3QgYWJjID0gQmV6aWVyLmdldEFCQygyLCBwMSwgcDIsIHAzLCB0KTtcbiAgICByZXR1cm4gbmV3IEJlemllcihwMSwgYWJjLkEsIHAzKTtcbiAgfVxuXG4gIHN0YXRpYyBjdWJpY0Zyb21Qb2ludHMoUywgQiwgRSwgdCwgZDEpIHtcbiAgICBpZiAodHlwZW9mIHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHQgPSAwLjU7XG4gICAgfVxuICAgIGNvbnN0IGFiYyA9IEJlemllci5nZXRBQkMoMywgUywgQiwgRSwgdCk7XG4gICAgaWYgKHR5cGVvZiBkMSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgZDEgPSB1dGlscy5kaXN0KEIsIGFiYy5DKTtcbiAgICB9XG4gICAgY29uc3QgZDIgPSAoZDEgKiAoMSAtIHQpKSAvIHQ7XG5cbiAgICBjb25zdCBzZWxlbiA9IHV0aWxzLmRpc3QoUywgRSksXG4gICAgICBseCA9IChFLnggLSBTLngpIC8gc2VsZW4sXG4gICAgICBseSA9IChFLnkgLSBTLnkpIC8gc2VsZW4sXG4gICAgICBieDEgPSBkMSAqIGx4LFxuICAgICAgYnkxID0gZDEgKiBseSxcbiAgICAgIGJ4MiA9IGQyICogbHgsXG4gICAgICBieTIgPSBkMiAqIGx5O1xuICAgIC8vIGRlcml2YXRpb24gb2YgbmV3IGh1bGwgY29vcmRpbmF0ZXNcbiAgICBjb25zdCBlMSA9IHsgeDogQi54IC0gYngxLCB5OiBCLnkgLSBieTEgfSxcbiAgICAgIGUyID0geyB4OiBCLnggKyBieDIsIHk6IEIueSArIGJ5MiB9LFxuICAgICAgQSA9IGFiYy5BLFxuICAgICAgdjEgPSB7IHg6IEEueCArIChlMS54IC0gQS54KSAvICgxIC0gdCksIHk6IEEueSArIChlMS55IC0gQS55KSAvICgxIC0gdCkgfSxcbiAgICAgIHYyID0geyB4OiBBLnggKyAoZTIueCAtIEEueCkgLyB0LCB5OiBBLnkgKyAoZTIueSAtIEEueSkgLyB0IH0sXG4gICAgICBuYzEgPSB7IHg6IFMueCArICh2MS54IC0gUy54KSAvIHQsIHk6IFMueSArICh2MS55IC0gUy55KSAvIHQgfSxcbiAgICAgIG5jMiA9IHtcbiAgICAgICAgeDogRS54ICsgKHYyLnggLSBFLngpIC8gKDEgLSB0KSxcbiAgICAgICAgeTogRS55ICsgKHYyLnkgLSBFLnkpIC8gKDEgLSB0KSxcbiAgICAgIH07XG4gICAgLy8gLi4uZG9uZVxuICAgIHJldHVybiBuZXcgQmV6aWVyKFMsIG5jMSwgbmMyLCBFKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRVdGlscygpIHtcbiAgICByZXR1cm4gdXRpbHM7XG4gIH1cblxuICBnZXRVdGlscygpIHtcbiAgICByZXR1cm4gQmV6aWVyLmdldFV0aWxzKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IFBvbHlCZXppZXIoKSB7XG4gICAgcmV0dXJuIFBvbHlCZXppZXI7XG4gIH1cblxuICB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdXRpbHMucG9pbnRzVG9TdHJpbmcodGhpcy5wb2ludHMpO1xuICB9XG5cbiAgdG9TVkcoKSB7XG4gICAgaWYgKHRoaXMuXzNkKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgcCA9IHRoaXMucG9pbnRzLFxuICAgICAgeCA9IHBbMF0ueCxcbiAgICAgIHkgPSBwWzBdLnksXG4gICAgICBzID0gW1wiTVwiLCB4LCB5LCB0aGlzLm9yZGVyID09PSAyID8gXCJRXCIgOiBcIkNcIl07XG4gICAgZm9yIChsZXQgaSA9IDEsIGxhc3QgPSBwLmxlbmd0aDsgaSA8IGxhc3Q7IGkrKykge1xuICAgICAgcy5wdXNoKHBbaV0ueCk7XG4gICAgICBzLnB1c2gocFtpXS55KTtcbiAgICB9XG4gICAgcmV0dXJuIHMuam9pbihcIiBcIik7XG4gIH1cblxuICBzZXRSYXRpb3MocmF0aW9zKSB7XG4gICAgaWYgKHJhdGlvcy5sZW5ndGggIT09IHRoaXMucG9pbnRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5jb3JyZWN0IG51bWJlciBvZiByYXRpbyB2YWx1ZXNcIik7XG4gICAgfVxuICAgIHRoaXMucmF0aW9zID0gcmF0aW9zO1xuICAgIHRoaXMuX2x1dCA9IFtdOyAvLyAgaW52YWxpZGF0ZSBhbnkgcHJlY29tcHV0ZWQgTFVUXG4gIH1cblxuICB2ZXJpZnkoKSB7XG4gICAgY29uc3QgcHJpbnQgPSB0aGlzLmNvb3JkRGlnZXN0KCk7XG4gICAgaWYgKHByaW50ICE9PSB0aGlzLl9wcmludCkge1xuICAgICAgdGhpcy5fcHJpbnQgPSBwcmludDtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgY29vcmREaWdlc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRzXG4gICAgICAubWFwKGZ1bmN0aW9uIChjLCBwb3MpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyBwb3MgKyBjLnggKyBjLnkgKyAoYy56ID8gYy56IDogMCk7XG4gICAgICB9KVxuICAgICAgLmpvaW4oXCJcIik7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgLy8gaW52YWxpZGF0ZSBhbnkgcHJlY29tcHV0ZWQgTFVUXG4gICAgdGhpcy5fbHV0ID0gW107XG4gICAgdGhpcy5kcG9pbnRzID0gdXRpbHMuZGVyaXZlKHRoaXMucG9pbnRzLCB0aGlzLl8zZCk7XG4gICAgdGhpcy5jb21wdXRlZGlyZWN0aW9uKCk7XG4gIH1cblxuICBjb21wdXRlZGlyZWN0aW9uKCkge1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIGNvbnN0IGFuZ2xlID0gdXRpbHMuYW5nbGUocG9pbnRzWzBdLCBwb2ludHNbdGhpcy5vcmRlcl0sIHBvaW50c1sxXSk7XG4gICAgdGhpcy5jbG9ja3dpc2UgPSBhbmdsZSA+IDA7XG4gIH1cblxuICBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxlbmd0aCh0aGlzLmRlcml2YXRpdmUuYmluZCh0aGlzKSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0QUJDKG9yZGVyID0gMiwgUywgQiwgRSwgdCA9IDAuNSkge1xuICAgIGNvbnN0IHUgPSB1dGlscy5wcm9qZWN0aW9ucmF0aW8odCwgb3JkZXIpLFxuICAgICAgdW0gPSAxIC0gdSxcbiAgICAgIEMgPSB7XG4gICAgICAgIHg6IHUgKiBTLnggKyB1bSAqIEUueCxcbiAgICAgICAgeTogdSAqIFMueSArIHVtICogRS55LFxuICAgICAgfSxcbiAgICAgIHMgPSB1dGlscy5hYmNyYXRpbyh0LCBvcmRlciksXG4gICAgICBBID0ge1xuICAgICAgICB4OiBCLnggKyAoQi54IC0gQy54KSAvIHMsXG4gICAgICAgIHk6IEIueSArIChCLnkgLSBDLnkpIC8gcyxcbiAgICAgIH07XG4gICAgcmV0dXJuIHsgQSwgQiwgQywgUywgRSB9O1xuICB9XG5cbiAgZ2V0QUJDKHQsIEIpIHtcbiAgICBCID0gQiB8fCB0aGlzLmdldCh0KTtcbiAgICBsZXQgUyA9IHRoaXMucG9pbnRzWzBdO1xuICAgIGxldCBFID0gdGhpcy5wb2ludHNbdGhpcy5vcmRlcl07XG4gICAgcmV0dXJuIEJlemllci5nZXRBQkModGhpcy5vcmRlciwgUywgQiwgRSwgdCk7XG4gIH1cblxuICBnZXRMVVQoc3RlcHMpIHtcbiAgICB0aGlzLnZlcmlmeSgpO1xuICAgIHN0ZXBzID0gc3RlcHMgfHwgMTAwO1xuICAgIGlmICh0aGlzLl9sdXQubGVuZ3RoID09PSBzdGVwcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2x1dDtcbiAgICB9XG4gICAgdGhpcy5fbHV0ID0gW107XG4gICAgLy8gV2Ugd2FudCBhIHJhbmdlIGZyb20gMCB0byAxIGluY2x1c2l2ZSwgc29cbiAgICAvLyB3ZSBkZWNyZW1lbnQgYW5kIHRoZW4gdXNlIDw9IHJhdGhlciB0aGFuIDw6XG4gICAgc3RlcHMtLTtcbiAgICBmb3IgKGxldCBpID0gMCwgcCwgdDsgaSA8IHN0ZXBzOyBpKyspIHtcbiAgICAgIHQgPSBpIC8gKHN0ZXBzIC0gMSk7XG4gICAgICBwID0gdGhpcy5jb21wdXRlKHQpO1xuICAgICAgcC50ID0gdDtcbiAgICAgIHRoaXMuX2x1dC5wdXNoKHApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbHV0O1xuICB9XG5cbiAgb24ocG9pbnQsIGVycm9yKSB7XG4gICAgZXJyb3IgPSBlcnJvciB8fCA1O1xuICAgIGNvbnN0IGx1dCA9IHRoaXMuZ2V0TFVUKCksXG4gICAgICBoaXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGMsIHQgPSAwOyBpIDwgbHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjID0gbHV0W2ldO1xuICAgICAgaWYgKHV0aWxzLmRpc3QoYywgcG9pbnQpIDwgZXJyb3IpIHtcbiAgICAgICAgaGl0cy5wdXNoKGMpO1xuICAgICAgICB0ICs9IGkgLyBsdXQubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWhpdHMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuICh0IC89IGhpdHMubGVuZ3RoKTtcbiAgfVxuXG4gIHByb2plY3QocG9pbnQpIHtcbiAgICAvLyBzdGVwIDE6IGNvYXJzZSBjaGVja1xuICAgIGNvbnN0IExVVCA9IHRoaXMuZ2V0TFVUKCksXG4gICAgICBsID0gTFVULmxlbmd0aCAtIDEsXG4gICAgICBjbG9zZXN0ID0gdXRpbHMuY2xvc2VzdChMVVQsIHBvaW50KSxcbiAgICAgIG1wb3MgPSBjbG9zZXN0Lm1wb3MsXG4gICAgICB0MSA9IChtcG9zIC0gMSkgLyBsLFxuICAgICAgdDIgPSAobXBvcyArIDEpIC8gbCxcbiAgICAgIHN0ZXAgPSAwLjEgLyBsO1xuXG4gICAgLy8gc3RlcCAyOiBmaW5lIGNoZWNrXG4gICAgbGV0IG1kaXN0ID0gY2xvc2VzdC5tZGlzdCxcbiAgICAgIHQgPSB0MSxcbiAgICAgIGZ0ID0gdCxcbiAgICAgIHA7XG4gICAgbWRpc3QgKz0gMTtcbiAgICBmb3IgKGxldCBkOyB0IDwgdDIgKyBzdGVwOyB0ICs9IHN0ZXApIHtcbiAgICAgIHAgPSB0aGlzLmNvbXB1dGUodCk7XG4gICAgICBkID0gdXRpbHMuZGlzdChwb2ludCwgcCk7XG4gICAgICBpZiAoZCA8IG1kaXN0KSB7XG4gICAgICAgIG1kaXN0ID0gZDtcbiAgICAgICAgZnQgPSB0O1xuICAgICAgfVxuICAgIH1cbiAgICBmdCA9IGZ0IDwgMCA/IDAgOiBmdCA+IDEgPyAxIDogZnQ7XG4gICAgcCA9IHRoaXMuY29tcHV0ZShmdCk7XG4gICAgcC50ID0gZnQ7XG4gICAgcC5kID0gbWRpc3Q7XG4gICAgcmV0dXJuIHA7XG4gIH1cblxuICBnZXQodCkge1xuICAgIHJldHVybiB0aGlzLmNvbXB1dGUodCk7XG4gIH1cblxuICBwb2ludChpZHgpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludHNbaWR4XTtcbiAgfVxuXG4gIGNvbXB1dGUodCkge1xuICAgIGlmICh0aGlzLnJhdGlvcykge1xuICAgICAgcmV0dXJuIHV0aWxzLmNvbXB1dGVXaXRoUmF0aW9zKHQsIHRoaXMucG9pbnRzLCB0aGlzLnJhdGlvcywgdGhpcy5fM2QpO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMuY29tcHV0ZSh0LCB0aGlzLnBvaW50cywgdGhpcy5fM2QsIHRoaXMucmF0aW9zKTtcbiAgfVxuXG4gIHJhaXNlKCkge1xuICAgIGNvbnN0IHAgPSB0aGlzLnBvaW50cyxcbiAgICAgIG5wID0gW3BbMF1dLFxuICAgICAgayA9IHAubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAxLCBwaSwgcGltOyBpIDwgazsgaSsrKSB7XG4gICAgICBwaSA9IHBbaV07XG4gICAgICBwaW0gPSBwW2kgLSAxXTtcbiAgICAgIG5wW2ldID0ge1xuICAgICAgICB4OiAoKGsgLSBpKSAvIGspICogcGkueCArIChpIC8gaykgKiBwaW0ueCxcbiAgICAgICAgeTogKChrIC0gaSkgLyBrKSAqIHBpLnkgKyAoaSAvIGspICogcGltLnksXG4gICAgICB9O1xuICAgIH1cbiAgICBucFtrXSA9IHBbayAtIDFdO1xuICAgIHJldHVybiBuZXcgQmV6aWVyKG5wKTtcbiAgfVxuXG4gIGRlcml2YXRpdmUodCkge1xuICAgIHJldHVybiB1dGlscy5jb21wdXRlKHQsIHRoaXMuZHBvaW50c1swXSwgdGhpcy5fM2QpO1xuICB9XG5cbiAgZGRlcml2YXRpdmUodCkge1xuICAgIHJldHVybiB1dGlscy5jb21wdXRlKHQsIHRoaXMuZHBvaW50c1sxXSwgdGhpcy5fM2QpO1xuICB9XG5cbiAgYWxpZ24oKSB7XG4gICAgbGV0IHAgPSB0aGlzLnBvaW50cztcbiAgICByZXR1cm4gbmV3IEJlemllcih1dGlscy5hbGlnbihwLCB7IHAxOiBwWzBdLCBwMjogcFtwLmxlbmd0aCAtIDFdIH0pKTtcbiAgfVxuXG4gIGN1cnZhdHVyZSh0KSB7XG4gICAgcmV0dXJuIHV0aWxzLmN1cnZhdHVyZSh0LCB0aGlzLmRwb2ludHNbMF0sIHRoaXMuZHBvaW50c1sxXSwgdGhpcy5fM2QpO1xuICB9XG5cbiAgaW5mbGVjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmluZmxlY3Rpb25zKHRoaXMucG9pbnRzKTtcbiAgfVxuXG4gIG5vcm1hbCh0KSB7XG4gICAgcmV0dXJuIHRoaXMuXzNkID8gdGhpcy5fX25vcm1hbDModCkgOiB0aGlzLl9fbm9ybWFsMih0KTtcbiAgfVxuXG4gIF9fbm9ybWFsMih0KSB7XG4gICAgY29uc3QgZCA9IHRoaXMuZGVyaXZhdGl2ZSh0KTtcbiAgICBjb25zdCBxID0gc3FydChkLnggKiBkLnggKyBkLnkgKiBkLnkpO1xuICAgIHJldHVybiB7IHg6IC1kLnkgLyBxLCB5OiBkLnggLyBxIH07XG4gIH1cblxuICBfX25vcm1hbDModCkge1xuICAgIC8vIHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI1NDUzMTU5XG4gICAgY29uc3QgcjEgPSB0aGlzLmRlcml2YXRpdmUodCksXG4gICAgICByMiA9IHRoaXMuZGVyaXZhdGl2ZSh0ICsgMC4wMSksXG4gICAgICBxMSA9IHNxcnQocjEueCAqIHIxLnggKyByMS55ICogcjEueSArIHIxLnogKiByMS56KSxcbiAgICAgIHEyID0gc3FydChyMi54ICogcjIueCArIHIyLnkgKiByMi55ICsgcjIueiAqIHIyLnopO1xuICAgIHIxLnggLz0gcTE7XG4gICAgcjEueSAvPSBxMTtcbiAgICByMS56IC89IHExO1xuICAgIHIyLnggLz0gcTI7XG4gICAgcjIueSAvPSBxMjtcbiAgICByMi56IC89IHEyO1xuICAgIC8vIGNyb3NzIHByb2R1Y3RcbiAgICBjb25zdCBjID0ge1xuICAgICAgeDogcjIueSAqIHIxLnogLSByMi56ICogcjEueSxcbiAgICAgIHk6IHIyLnogKiByMS54IC0gcjIueCAqIHIxLnosXG4gICAgICB6OiByMi54ICogcjEueSAtIHIyLnkgKiByMS54LFxuICAgIH07XG4gICAgY29uc3QgbSA9IHNxcnQoYy54ICogYy54ICsgYy55ICogYy55ICsgYy56ICogYy56KTtcbiAgICBjLnggLz0gbTtcbiAgICBjLnkgLz0gbTtcbiAgICBjLnogLz0gbTtcbiAgICAvLyByb3RhdGlvbiBtYXRyaXhcbiAgICBjb25zdCBSID0gW1xuICAgICAgYy54ICogYy54LFxuICAgICAgYy54ICogYy55IC0gYy56LFxuICAgICAgYy54ICogYy56ICsgYy55LFxuICAgICAgYy54ICogYy55ICsgYy56LFxuICAgICAgYy55ICogYy55LFxuICAgICAgYy55ICogYy56IC0gYy54LFxuICAgICAgYy54ICogYy56IC0gYy55LFxuICAgICAgYy55ICogYy56ICsgYy54LFxuICAgICAgYy56ICogYy56LFxuICAgIF07XG4gICAgLy8gbm9ybWFsIHZlY3RvcjpcbiAgICBjb25zdCBuID0ge1xuICAgICAgeDogUlswXSAqIHIxLnggKyBSWzFdICogcjEueSArIFJbMl0gKiByMS56LFxuICAgICAgeTogUlszXSAqIHIxLnggKyBSWzRdICogcjEueSArIFJbNV0gKiByMS56LFxuICAgICAgejogUls2XSAqIHIxLnggKyBSWzddICogcjEueSArIFJbOF0gKiByMS56LFxuICAgIH07XG4gICAgcmV0dXJuIG47XG4gIH1cblxuICBodWxsKHQpIHtcbiAgICBsZXQgcCA9IHRoaXMucG9pbnRzLFxuICAgICAgX3AgPSBbXSxcbiAgICAgIHEgPSBbXSxcbiAgICAgIGlkeCA9IDA7XG4gICAgcVtpZHgrK10gPSBwWzBdO1xuICAgIHFbaWR4KytdID0gcFsxXTtcbiAgICBxW2lkeCsrXSA9IHBbMl07XG4gICAgaWYgKHRoaXMub3JkZXIgPT09IDMpIHtcbiAgICAgIHFbaWR4KytdID0gcFszXTtcbiAgICB9XG4gICAgLy8gd2UgbGVycCBiZXR3ZWVuIGFsbCBwb2ludHMgYXQgZWFjaCBpdGVyYXRpb24sIHVudGlsIHdlIGhhdmUgMSBwb2ludCBsZWZ0LlxuICAgIHdoaWxlIChwLmxlbmd0aCA+IDEpIHtcbiAgICAgIF9wID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMCwgcHQsIGwgPSBwLmxlbmd0aCAtIDE7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcHQgPSB1dGlscy5sZXJwKHQsIHBbaV0sIHBbaSArIDFdKTtcbiAgICAgICAgcVtpZHgrK10gPSBwdDtcbiAgICAgICAgX3AucHVzaChwdCk7XG4gICAgICB9XG4gICAgICBwID0gX3A7XG4gICAgfVxuICAgIHJldHVybiBxO1xuICB9XG5cbiAgc3BsaXQodDEsIHQyKSB7XG4gICAgLy8gc2hvcnRjdXRzXG4gICAgaWYgKHQxID09PSAwICYmICEhdDIpIHtcbiAgICAgIHJldHVybiB0aGlzLnNwbGl0KHQyKS5sZWZ0O1xuICAgIH1cbiAgICBpZiAodDIgPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLnNwbGl0KHQxKS5yaWdodDtcbiAgICB9XG5cbiAgICAvLyBubyBzaG9ydGN1dDogdXNlIFwiZGUgQ2FzdGVsamF1XCIgaXRlcmF0aW9uLlxuICAgIGNvbnN0IHEgPSB0aGlzLmh1bGwodDEpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIGxlZnQ6XG4gICAgICAgIHRoaXMub3JkZXIgPT09IDJcbiAgICAgICAgICA/IG5ldyBCZXppZXIoW3FbMF0sIHFbM10sIHFbNV1dKVxuICAgICAgICAgIDogbmV3IEJlemllcihbcVswXSwgcVs0XSwgcVs3XSwgcVs5XV0pLFxuICAgICAgcmlnaHQ6XG4gICAgICAgIHRoaXMub3JkZXIgPT09IDJcbiAgICAgICAgICA/IG5ldyBCZXppZXIoW3FbNV0sIHFbNF0sIHFbMl1dKVxuICAgICAgICAgIDogbmV3IEJlemllcihbcVs5XSwgcVs4XSwgcVs2XSwgcVszXV0pLFxuICAgICAgc3BhbjogcSxcbiAgICB9O1xuXG4gICAgLy8gbWFrZSBzdXJlIHdlIGJpbmQgX3QxL190MiBpbmZvcm1hdGlvbiFcbiAgICByZXN1bHQubGVmdC5fdDEgPSB1dGlscy5tYXAoMCwgMCwgMSwgdGhpcy5fdDEsIHRoaXMuX3QyKTtcbiAgICByZXN1bHQubGVmdC5fdDIgPSB1dGlscy5tYXAodDEsIDAsIDEsIHRoaXMuX3QxLCB0aGlzLl90Mik7XG4gICAgcmVzdWx0LnJpZ2h0Ll90MSA9IHV0aWxzLm1hcCh0MSwgMCwgMSwgdGhpcy5fdDEsIHRoaXMuX3QyKTtcbiAgICByZXN1bHQucmlnaHQuX3QyID0gdXRpbHMubWFwKDEsIDAsIDEsIHRoaXMuX3QxLCB0aGlzLl90Mik7XG5cbiAgICAvLyBpZiB3ZSBoYXZlIG5vIHQyLCB3ZSdyZSBkb25lXG4gICAgaWYgKCF0Mikge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGEgdDIsIHNwbGl0IGFnYWluOlxuICAgIHQyID0gdXRpbHMubWFwKHQyLCB0MSwgMSwgMCwgMSk7XG4gICAgcmV0dXJuIHJlc3VsdC5yaWdodC5zcGxpdCh0MikubGVmdDtcbiAgfVxuXG4gIGV4dHJlbWEoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgbGV0IHJvb3RzID0gW107XG5cbiAgICB0aGlzLmRpbXMuZm9yRWFjaChcbiAgICAgIGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgbGV0IG1mbiA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgcmV0dXJuIHZbZGltXTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHAgPSB0aGlzLmRwb2ludHNbMF0ubWFwKG1mbik7XG4gICAgICAgIHJlc3VsdFtkaW1dID0gdXRpbHMuZHJvb3RzKHApO1xuICAgICAgICBpZiAodGhpcy5vcmRlciA9PT0gMykge1xuICAgICAgICAgIHAgPSB0aGlzLmRwb2ludHNbMV0ubWFwKG1mbik7XG4gICAgICAgICAgcmVzdWx0W2RpbV0gPSByZXN1bHRbZGltXS5jb25jYXQodXRpbHMuZHJvb3RzKHApKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbZGltXSA9IHJlc3VsdFtkaW1dLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0ID49IDAgJiYgdCA8PSAxO1xuICAgICAgICB9KTtcbiAgICAgICAgcm9vdHMgPSByb290cy5jb25jYXQocmVzdWx0W2RpbV0uc29ydCh1dGlscy5udW1iZXJTb3J0KSk7XG4gICAgICB9LmJpbmQodGhpcylcbiAgICApO1xuXG4gICAgcmVzdWx0LnZhbHVlcyA9IHJvb3RzLnNvcnQodXRpbHMubnVtYmVyU29ydCkuZmlsdGVyKGZ1bmN0aW9uICh2LCBpZHgpIHtcbiAgICAgIHJldHVybiByb290cy5pbmRleE9mKHYpID09PSBpZHg7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgYmJveCgpIHtcbiAgICBjb25zdCBleHRyZW1hID0gdGhpcy5leHRyZW1hKCksXG4gICAgICByZXN1bHQgPSB7fTtcbiAgICB0aGlzLmRpbXMuZm9yRWFjaChcbiAgICAgIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJlc3VsdFtkXSA9IHV0aWxzLmdldG1pbm1heCh0aGlzLCBkLCBleHRyZW1hW2RdKTtcbiAgICAgIH0uYmluZCh0aGlzKVxuICAgICk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIG92ZXJsYXBzKGN1cnZlKSB7XG4gICAgY29uc3QgbGJib3ggPSB0aGlzLmJib3goKSxcbiAgICAgIHRiYm94ID0gY3VydmUuYmJveCgpO1xuICAgIHJldHVybiB1dGlscy5iYm94b3ZlcmxhcChsYmJveCwgdGJib3gpO1xuICB9XG5cbiAgb2Zmc2V0KHQsIGQpIHtcbiAgICBpZiAodHlwZW9mIGQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLmdldCh0KSxcbiAgICAgICAgbiA9IHRoaXMubm9ybWFsKHQpO1xuICAgICAgY29uc3QgcmV0ID0ge1xuICAgICAgICBjOiBjLFxuICAgICAgICBuOiBuLFxuICAgICAgICB4OiBjLnggKyBuLnggKiBkLFxuICAgICAgICB5OiBjLnkgKyBuLnkgKiBkLFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLl8zZCkge1xuICAgICAgICByZXQueiA9IGMueiArIG4ueiAqIGQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGluZWFyKSB7XG4gICAgICBjb25zdCBudiA9IHRoaXMubm9ybWFsKDApLFxuICAgICAgICBjb29yZHMgPSB0aGlzLnBvaW50cy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICBjb25zdCByZXQgPSB7XG4gICAgICAgICAgICB4OiBwLnggKyB0ICogbnYueCxcbiAgICAgICAgICAgIHk6IHAueSArIHQgKiBudi55LFxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHAueiAmJiBudi56KSB7XG4gICAgICAgICAgICByZXQueiA9IHAueiArIHQgKiBudi56O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9KTtcbiAgICAgIHJldHVybiBbbmV3IEJlemllcihjb29yZHMpXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVkdWNlKCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICBpZiAocy5fbGluZWFyKSB7XG4gICAgICAgIHJldHVybiBzLm9mZnNldCh0KVswXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzLnNjYWxlKHQpO1xuICAgIH0pO1xuICB9XG5cbiAgc2ltcGxlKCkge1xuICAgIGlmICh0aGlzLm9yZGVyID09PSAzKSB7XG4gICAgICBjb25zdCBhMSA9IHV0aWxzLmFuZ2xlKHRoaXMucG9pbnRzWzBdLCB0aGlzLnBvaW50c1szXSwgdGhpcy5wb2ludHNbMV0pO1xuICAgICAgY29uc3QgYTIgPSB1dGlscy5hbmdsZSh0aGlzLnBvaW50c1swXSwgdGhpcy5wb2ludHNbM10sIHRoaXMucG9pbnRzWzJdKTtcbiAgICAgIGlmICgoYTEgPiAwICYmIGEyIDwgMCkgfHwgKGExIDwgMCAmJiBhMiA+IDApKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG4xID0gdGhpcy5ub3JtYWwoMCk7XG4gICAgY29uc3QgbjIgPSB0aGlzLm5vcm1hbCgxKTtcbiAgICBsZXQgcyA9IG4xLnggKiBuMi54ICsgbjEueSAqIG4yLnk7XG4gICAgaWYgKHRoaXMuXzNkKSB7XG4gICAgICBzICs9IG4xLnogKiBuMi56O1xuICAgIH1cbiAgICByZXR1cm4gYWJzKGFjb3MocykpIDwgcGkgLyAzO1xuICB9XG5cbiAgcmVkdWNlKCkge1xuICAgIC8vIFRPRE86IGV4YW1pbmUgdGhlc2UgdmFyIHR5cGVzIGluIG1vcmUgZGV0YWlsLi4uXG4gICAgbGV0IGksXG4gICAgICB0MSA9IDAsXG4gICAgICB0MiA9IDAsXG4gICAgICBzdGVwID0gMC4wMSxcbiAgICAgIHNlZ21lbnQsXG4gICAgICBwYXNzMSA9IFtdLFxuICAgICAgcGFzczIgPSBbXTtcbiAgICAvLyBmaXJzdCBwYXNzOiBzcGxpdCBvbiBleHRyZW1hXG4gICAgbGV0IGV4dHJlbWEgPSB0aGlzLmV4dHJlbWEoKS52YWx1ZXM7XG4gICAgaWYgKGV4dHJlbWEuaW5kZXhPZigwKSA9PT0gLTEpIHtcbiAgICAgIGV4dHJlbWEgPSBbMF0uY29uY2F0KGV4dHJlbWEpO1xuICAgIH1cbiAgICBpZiAoZXh0cmVtYS5pbmRleE9mKDEpID09PSAtMSkge1xuICAgICAgZXh0cmVtYS5wdXNoKDEpO1xuICAgIH1cblxuICAgIGZvciAodDEgPSBleHRyZW1hWzBdLCBpID0gMTsgaSA8IGV4dHJlbWEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHQyID0gZXh0cmVtYVtpXTtcbiAgICAgIHNlZ21lbnQgPSB0aGlzLnNwbGl0KHQxLCB0Mik7XG4gICAgICBzZWdtZW50Ll90MSA9IHQxO1xuICAgICAgc2VnbWVudC5fdDIgPSB0MjtcbiAgICAgIHBhc3MxLnB1c2goc2VnbWVudCk7XG4gICAgICB0MSA9IHQyO1xuICAgIH1cblxuICAgIC8vIHNlY29uZCBwYXNzOiBmdXJ0aGVyIHJlZHVjZSB0aGVzZSBzZWdtZW50cyB0byBzaW1wbGUgc2VnbWVudHNcbiAgICBwYXNzMS5mb3JFYWNoKGZ1bmN0aW9uIChwMSkge1xuICAgICAgdDEgPSAwO1xuICAgICAgdDIgPSAwO1xuICAgICAgd2hpbGUgKHQyIDw9IDEpIHtcbiAgICAgICAgZm9yICh0MiA9IHQxICsgc3RlcDsgdDIgPD0gMSArIHN0ZXA7IHQyICs9IHN0ZXApIHtcbiAgICAgICAgICBzZWdtZW50ID0gcDEuc3BsaXQodDEsIHQyKTtcbiAgICAgICAgICBpZiAoIXNlZ21lbnQuc2ltcGxlKCkpIHtcbiAgICAgICAgICAgIHQyIC09IHN0ZXA7XG4gICAgICAgICAgICBpZiAoYWJzKHQxIC0gdDIpIDwgc3RlcCkge1xuICAgICAgICAgICAgICAvLyB3ZSBjYW4gbmV2ZXIgZm9ybSBhIHJlZHVjdGlvblxuICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWdtZW50ID0gcDEuc3BsaXQodDEsIHQyKTtcbiAgICAgICAgICAgIHNlZ21lbnQuX3QxID0gdXRpbHMubWFwKHQxLCAwLCAxLCBwMS5fdDEsIHAxLl90Mik7XG4gICAgICAgICAgICBzZWdtZW50Ll90MiA9IHV0aWxzLm1hcCh0MiwgMCwgMSwgcDEuX3QxLCBwMS5fdDIpO1xuICAgICAgICAgICAgcGFzczIucHVzaChzZWdtZW50KTtcbiAgICAgICAgICAgIHQxID0gdDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0MSA8IDEpIHtcbiAgICAgICAgc2VnbWVudCA9IHAxLnNwbGl0KHQxLCAxKTtcbiAgICAgICAgc2VnbWVudC5fdDEgPSB1dGlscy5tYXAodDEsIDAsIDEsIHAxLl90MSwgcDEuX3QyKTtcbiAgICAgICAgc2VnbWVudC5fdDIgPSBwMS5fdDI7XG4gICAgICAgIHBhc3MyLnB1c2goc2VnbWVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhc3MyO1xuICB9XG5cbiAgc2NhbGUoZCkge1xuICAgIGNvbnN0IG9yZGVyID0gdGhpcy5vcmRlcjtcbiAgICBsZXQgZGlzdGFuY2VGbiA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2YgZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBkaXN0YW5jZUZuID0gZDtcbiAgICB9XG4gICAgaWYgKGRpc3RhbmNlRm4gJiYgb3JkZXIgPT09IDIpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhaXNlKCkuc2NhbGUoZGlzdGFuY2VGbik7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogYWRkIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGRlZ2VuZXJhdGUgKD1saW5lYXIpIGN1cnZlcy5cbiAgICBjb25zdCBjbG9ja3dpc2UgPSB0aGlzLmNsb2Nrd2lzZTtcbiAgICBjb25zdCByMSA9IGRpc3RhbmNlRm4gPyBkaXN0YW5jZUZuKDApIDogZDtcbiAgICBjb25zdCByMiA9IGRpc3RhbmNlRm4gPyBkaXN0YW5jZUZuKDEpIDogZDtcbiAgICBjb25zdCB2ID0gW3RoaXMub2Zmc2V0KDAsIDEwKSwgdGhpcy5vZmZzZXQoMSwgMTApXTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCBucCA9IFtdO1xuICAgIGNvbnN0IG8gPSB1dGlscy5sbGk0KHZbMF0sIHZbMF0uYywgdlsxXSwgdlsxXS5jKTtcblxuICAgIGlmICghbykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHNjYWxlIHRoaXMgY3VydmUuIFRyeSByZWR1Y2luZyBpdCBmaXJzdC5cIik7XG4gICAgfVxuICAgIC8vIG1vdmUgYWxsIHBvaW50cyBieSBkaXN0YW5jZSAnZCcgd3J0IHRoZSBvcmlnaW4gJ28nXG5cbiAgICAvLyBtb3ZlIGVuZCBwb2ludHMgYnkgZml4ZWQgZGlzdGFuY2UgYWxvbmcgbm9ybWFsLlxuICAgIFswLCAxXS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICBjb25zdCBwID0gKG5wW3QgKiBvcmRlcl0gPSB1dGlscy5jb3B5KHBvaW50c1t0ICogb3JkZXJdKSk7XG4gICAgICBwLnggKz0gKHQgPyByMiA6IHIxKSAqIHZbdF0ubi54O1xuICAgICAgcC55ICs9ICh0ID8gcjIgOiByMSkgKiB2W3RdLm4ueTtcbiAgICB9KTtcblxuICAgIGlmICghZGlzdGFuY2VGbikge1xuICAgICAgLy8gbW92ZSBjb250cm9sIHBvaW50cyB0byBsaWUgb24gdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgb2Zmc2V0XG4gICAgICAvLyBkZXJpdmF0aXZlIHZlY3RvciwgYW5kIHRoZSBvcmlnaW4tdGhyb3VnaC1jb250cm9sIHZlY3RvclxuICAgICAgWzAsIDFdLmZvckVhY2goKHQpID0+IHtcbiAgICAgICAgaWYgKG9yZGVyID09PSAyICYmICEhdCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBwID0gbnBbdCAqIG9yZGVyXTtcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuZGVyaXZhdGl2ZSh0KTtcbiAgICAgICAgY29uc3QgcDIgPSB7IHg6IHAueCArIGQueCwgeTogcC55ICsgZC55IH07XG4gICAgICAgIG5wW3QgKyAxXSA9IHV0aWxzLmxsaTQocCwgcDIsIG8sIHBvaW50c1t0ICsgMV0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IEJlemllcihucCk7XG4gICAgfVxuXG4gICAgLy8gbW92ZSBjb250cm9sIHBvaW50cyBieSBcImhvd2V2ZXIgbXVjaCBuZWNlc3NhcnkgdG9cbiAgICAvLyBlbnN1cmUgdGhlIGNvcnJlY3QgdGFuZ2VudCB0byBlbmRwb2ludFwiLlxuICAgIFswLCAxXS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAob3JkZXIgPT09IDIgJiYgISF0KSByZXR1cm47XG4gICAgICB2YXIgcCA9IHBvaW50c1t0ICsgMV07XG4gICAgICB2YXIgb3YgPSB7XG4gICAgICAgIHg6IHAueCAtIG8ueCxcbiAgICAgICAgeTogcC55IC0gby55LFxuICAgICAgfTtcbiAgICAgIHZhciByYyA9IGRpc3RhbmNlRm4gPyBkaXN0YW5jZUZuKCh0ICsgMSkgLyBvcmRlcikgOiBkO1xuICAgICAgaWYgKGRpc3RhbmNlRm4gJiYgIWNsb2Nrd2lzZSkgcmMgPSAtcmM7XG4gICAgICB2YXIgbSA9IHNxcnQob3YueCAqIG92LnggKyBvdi55ICogb3YueSk7XG4gICAgICBvdi54IC89IG07XG4gICAgICBvdi55IC89IG07XG4gICAgICBucFt0ICsgMV0gPSB7XG4gICAgICAgIHg6IHAueCArIHJjICogb3YueCxcbiAgICAgICAgeTogcC55ICsgcmMgKiBvdi55LFxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IEJlemllcihucCk7XG4gIH1cblxuICBvdXRsaW5lKGQxLCBkMiwgZDMsIGQ0KSB7XG4gICAgZDIgPSB0eXBlb2YgZDIgPT09IFwidW5kZWZpbmVkXCIgPyBkMSA6IGQyO1xuICAgIGNvbnN0IHJlZHVjZWQgPSB0aGlzLnJlZHVjZSgpLFxuICAgICAgbGVuID0gcmVkdWNlZC5sZW5ndGgsXG4gICAgICBmY3VydmVzID0gW107XG5cbiAgICBsZXQgYmN1cnZlcyA9IFtdLFxuICAgICAgcCxcbiAgICAgIGFsZW4gPSAwLFxuICAgICAgdGxlbiA9IHRoaXMubGVuZ3RoKCk7XG5cbiAgICBjb25zdCBncmFkdWF0ZWQgPSB0eXBlb2YgZDMgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGQ0ICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gICAgZnVuY3Rpb24gbGluZWFyRGlzdGFuY2VGdW5jdGlvbihzLCBlLCB0bGVuLCBhbGVuLCBzbGVuKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgY29uc3QgZjEgPSBhbGVuIC8gdGxlbixcbiAgICAgICAgICBmMiA9IChhbGVuICsgc2xlbikgLyB0bGVuLFxuICAgICAgICAgIGQgPSBlIC0gcztcbiAgICAgICAgcmV0dXJuIHV0aWxzLm1hcCh2LCAwLCAxLCBzICsgZjEgKiBkLCBzICsgZjIgKiBkKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZm9ybSBjdXJ2ZSBvdWxpbmVzXG4gICAgcmVkdWNlZC5mb3JFYWNoKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgICBjb25zdCBzbGVuID0gc2VnbWVudC5sZW5ndGgoKTtcbiAgICAgIGlmIChncmFkdWF0ZWQpIHtcbiAgICAgICAgZmN1cnZlcy5wdXNoKFxuICAgICAgICAgIHNlZ21lbnQuc2NhbGUobGluZWFyRGlzdGFuY2VGdW5jdGlvbihkMSwgZDMsIHRsZW4sIGFsZW4sIHNsZW4pKVxuICAgICAgICApO1xuICAgICAgICBiY3VydmVzLnB1c2goXG4gICAgICAgICAgc2VnbWVudC5zY2FsZShsaW5lYXJEaXN0YW5jZUZ1bmN0aW9uKC1kMiwgLWQ0LCB0bGVuLCBhbGVuLCBzbGVuKSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZjdXJ2ZXMucHVzaChzZWdtZW50LnNjYWxlKGQxKSk7XG4gICAgICAgIGJjdXJ2ZXMucHVzaChzZWdtZW50LnNjYWxlKC1kMikpO1xuICAgICAgfVxuICAgICAgYWxlbiArPSBzbGVuO1xuICAgIH0pO1xuXG4gICAgLy8gcmV2ZXJzZSB0aGUgXCJyZXR1cm5cIiBvdXRsaW5lXG4gICAgYmN1cnZlcyA9IGJjdXJ2ZXNcbiAgICAgIC5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcCA9IHMucG9pbnRzO1xuICAgICAgICBpZiAocFszXSkge1xuICAgICAgICAgIHMucG9pbnRzID0gW3BbM10sIHBbMl0sIHBbMV0sIHBbMF1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMucG9pbnRzID0gW3BbMl0sIHBbMV0sIHBbMF1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfSlcbiAgICAgIC5yZXZlcnNlKCk7XG5cbiAgICAvLyBmb3JtIHRoZSBlbmRjYXBzIGFzIGxpbmVzXG4gICAgY29uc3QgZnMgPSBmY3VydmVzWzBdLnBvaW50c1swXSxcbiAgICAgIGZlID0gZmN1cnZlc1tsZW4gLSAxXS5wb2ludHNbZmN1cnZlc1tsZW4gLSAxXS5wb2ludHMubGVuZ3RoIC0gMV0sXG4gICAgICBicyA9IGJjdXJ2ZXNbbGVuIC0gMV0ucG9pbnRzW2JjdXJ2ZXNbbGVuIC0gMV0ucG9pbnRzLmxlbmd0aCAtIDFdLFxuICAgICAgYmUgPSBiY3VydmVzWzBdLnBvaW50c1swXSxcbiAgICAgIGxzID0gdXRpbHMubWFrZWxpbmUoYnMsIGZzKSxcbiAgICAgIGxlID0gdXRpbHMubWFrZWxpbmUoZmUsIGJlKSxcbiAgICAgIHNlZ21lbnRzID0gW2xzXS5jb25jYXQoZmN1cnZlcykuY29uY2F0KFtsZV0pLmNvbmNhdChiY3VydmVzKSxcbiAgICAgIHNsZW4gPSBzZWdtZW50cy5sZW5ndGg7XG5cbiAgICByZXR1cm4gbmV3IFBvbHlCZXppZXIoc2VnbWVudHMpO1xuICB9XG5cbiAgb3V0bGluZXNoYXBlcyhkMSwgZDIsIGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkKSB7XG4gICAgZDIgPSBkMiB8fCBkMTtcbiAgICBjb25zdCBvdXRsaW5lID0gdGhpcy5vdXRsaW5lKGQxLCBkMikuY3VydmVzO1xuICAgIGNvbnN0IHNoYXBlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAxLCBsZW4gPSBvdXRsaW5lLmxlbmd0aDsgaSA8IGxlbiAvIDI7IGkrKykge1xuICAgICAgY29uc3Qgc2hhcGUgPSB1dGlscy5tYWtlc2hhcGUoXG4gICAgICAgIG91dGxpbmVbaV0sXG4gICAgICAgIG91dGxpbmVbbGVuIC0gaV0sXG4gICAgICAgIGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkXG4gICAgICApO1xuICAgICAgc2hhcGUuc3RhcnRjYXAudmlydHVhbCA9IGkgPiAxO1xuICAgICAgc2hhcGUuZW5kY2FwLnZpcnR1YWwgPSBpIDwgbGVuIC8gMiAtIDE7XG4gICAgICBzaGFwZXMucHVzaChzaGFwZSk7XG4gICAgfVxuICAgIHJldHVybiBzaGFwZXM7XG4gIH1cblxuICBpbnRlcnNlY3RzKGN1cnZlLCBjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZCkge1xuICAgIGlmICghY3VydmUpIHJldHVybiB0aGlzLnNlbGZpbnRlcnNlY3RzKGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkKTtcbiAgICBpZiAoY3VydmUucDEgJiYgY3VydmUucDIpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpbmVJbnRlcnNlY3RzKGN1cnZlKTtcbiAgICB9XG4gICAgaWYgKGN1cnZlIGluc3RhbmNlb2YgQmV6aWVyKSB7XG4gICAgICBjdXJ2ZSA9IGN1cnZlLnJlZHVjZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jdXJ2ZWludGVyc2VjdHMoXG4gICAgICB0aGlzLnJlZHVjZSgpLFxuICAgICAgY3VydmUsXG4gICAgICBjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZFxuICAgICk7XG4gIH1cblxuICBsaW5lSW50ZXJzZWN0cyhsaW5lKSB7XG4gICAgY29uc3QgbXggPSBtaW4obGluZS5wMS54LCBsaW5lLnAyLngpLFxuICAgICAgbXkgPSBtaW4obGluZS5wMS55LCBsaW5lLnAyLnkpLFxuICAgICAgTVggPSBtYXgobGluZS5wMS54LCBsaW5lLnAyLngpLFxuICAgICAgTVkgPSBtYXgobGluZS5wMS55LCBsaW5lLnAyLnkpO1xuICAgIHJldHVybiB1dGlscy5yb290cyh0aGlzLnBvaW50cywgbGluZSkuZmlsdGVyKCh0KSA9PiB7XG4gICAgICB2YXIgcCA9IHRoaXMuZ2V0KHQpO1xuICAgICAgcmV0dXJuIHV0aWxzLmJldHdlZW4ocC54LCBteCwgTVgpICYmIHV0aWxzLmJldHdlZW4ocC55LCBteSwgTVkpO1xuICAgIH0pO1xuICB9XG5cbiAgc2VsZmludGVyc2VjdHMoY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGQpIHtcbiAgICAvLyBcInNpbXBsZVwiIGN1cnZlcyBjYW5ub3QgaW50ZXJzZWN0IHdpdGggdGhlaXIgZGlyZWN0XG4gICAgLy8gbmVpZ2hib3VyLCBzbyBmb3IgZWFjaCBzZWdtZW50IFggd2UgY2hlY2sgd2hldGhlclxuICAgIC8vIGl0IGludGVyc2VjdHMgWzA6eC0yXVt4KzI6bGFzdF0uXG5cbiAgICBjb25zdCByZWR1Y2VkID0gdGhpcy5yZWR1Y2UoKSxcbiAgICAgIGxlbiA9IHJlZHVjZWQubGVuZ3RoIC0gMixcbiAgICAgIHJlc3VsdHMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwLCByZXN1bHQsIGxlZnQsIHJpZ2h0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxlZnQgPSByZWR1Y2VkLnNsaWNlKGksIGkgKyAxKTtcbiAgICAgIHJpZ2h0ID0gcmVkdWNlZC5zbGljZShpICsgMik7XG4gICAgICByZXN1bHQgPSB0aGlzLmN1cnZlaW50ZXJzZWN0cyhsZWZ0LCByaWdodCwgY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGQpO1xuICAgICAgcmVzdWx0cy5wdXNoKC4uLnJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgY3VydmVpbnRlcnNlY3RzKGMxLCBjMiwgY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGQpIHtcbiAgICBjb25zdCBwYWlycyA9IFtdO1xuICAgIC8vIHN0ZXAgMTogcGFpciBvZmYgYW55IG92ZXJsYXBwaW5nIHNlZ21lbnRzXG4gICAgYzEuZm9yRWFjaChmdW5jdGlvbiAobCkge1xuICAgICAgYzIuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgICBpZiAobC5vdmVybGFwcyhyKSkge1xuICAgICAgICAgIHBhaXJzLnB1c2goeyBsZWZ0OiBsLCByaWdodDogciB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gc3RlcCAyOiBmb3IgZWFjaCBwYWlyaW5nLCBydW4gdGhyb3VnaCB0aGUgY29udmVyZ2VuY2UgYWxnb3JpdGhtLlxuICAgIGxldCBpbnRlcnNlY3Rpb25zID0gW107XG4gICAgcGFpcnMuZm9yRWFjaChmdW5jdGlvbiAocGFpcikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdXRpbHMucGFpcml0ZXJhdGlvbihcbiAgICAgICAgcGFpci5sZWZ0LFxuICAgICAgICBwYWlyLnJpZ2h0LFxuICAgICAgICBjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZFxuICAgICAgKTtcbiAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICBpbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0aW9ucy5jb25jYXQocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgfVxuXG4gIGFyY3MoZXJyb3JUaHJlc2hvbGQpIHtcbiAgICBlcnJvclRocmVzaG9sZCA9IGVycm9yVGhyZXNob2xkIHx8IDAuNTtcbiAgICByZXR1cm4gdGhpcy5faXRlcmF0ZShlcnJvclRocmVzaG9sZCwgW10pO1xuICB9XG5cbiAgX2Vycm9yKHBjLCBucDEsIHMsIGUpIHtcbiAgICBjb25zdCBxID0gKGUgLSBzKSAvIDQsXG4gICAgICBjMSA9IHRoaXMuZ2V0KHMgKyBxKSxcbiAgICAgIGMyID0gdGhpcy5nZXQoZSAtIHEpLFxuICAgICAgcmVmID0gdXRpbHMuZGlzdChwYywgbnAxKSxcbiAgICAgIGQxID0gdXRpbHMuZGlzdChwYywgYzEpLFxuICAgICAgZDIgPSB1dGlscy5kaXN0KHBjLCBjMik7XG4gICAgcmV0dXJuIGFicyhkMSAtIHJlZikgKyBhYnMoZDIgLSByZWYpO1xuICB9XG5cbiAgX2l0ZXJhdGUoZXJyb3JUaHJlc2hvbGQsIGNpcmNsZXMpIHtcbiAgICBsZXQgdF9zID0gMCxcbiAgICAgIHRfZSA9IDEsXG4gICAgICBzYWZldHk7XG4gICAgLy8gd2UgZG8gYSBiaW5hcnkgc2VhcmNoIHRvIGZpbmQgdGhlIFwiZ29vZCBgdGAgY2xvc2VzdCB0byBuby1sb25nZXItZ29vZFwiXG4gICAgZG8ge1xuICAgICAgc2FmZXR5ID0gMDtcblxuICAgICAgLy8gc3RlcCAxOiBzdGFydCB3aXRoIHRoZSBtYXhpbXVtIHBvc3NpYmxlIGFyY1xuICAgICAgdF9lID0gMTtcblxuICAgICAgLy8gcG9pbnRzOlxuICAgICAgbGV0IG5wMSA9IHRoaXMuZ2V0KHRfcyksXG4gICAgICAgIG5wMixcbiAgICAgICAgbnAzLFxuICAgICAgICBhcmMsXG4gICAgICAgIHByZXZfYXJjO1xuXG4gICAgICAvLyBib29sZWFuczpcbiAgICAgIGxldCBjdXJyX2dvb2QgPSBmYWxzZSxcbiAgICAgICAgcHJldl9nb29kID0gZmFsc2UsXG4gICAgICAgIGRvbmU7XG5cbiAgICAgIC8vIG51bWJlcnM6XG4gICAgICBsZXQgdF9tID0gdF9lLFxuICAgICAgICBwcmV2X2UgPSAxLFxuICAgICAgICBzdGVwID0gMDtcblxuICAgICAgLy8gc3RlcCAyOiBmaW5kIHRoZSBiZXN0IHBvc3NpYmxlIGFyY1xuICAgICAgZG8ge1xuICAgICAgICBwcmV2X2dvb2QgPSBjdXJyX2dvb2Q7XG4gICAgICAgIHByZXZfYXJjID0gYXJjO1xuICAgICAgICB0X20gPSAodF9zICsgdF9lKSAvIDI7XG4gICAgICAgIHN0ZXArKztcblxuICAgICAgICBucDIgPSB0aGlzLmdldCh0X20pO1xuICAgICAgICBucDMgPSB0aGlzLmdldCh0X2UpO1xuXG4gICAgICAgIGFyYyA9IHV0aWxzLmdldGNjZW50ZXIobnAxLCBucDIsIG5wMyk7XG5cbiAgICAgICAgLy9hbHNvIHNhdmUgdGhlIHQgdmFsdWVzXG4gICAgICAgIGFyYy5pbnRlcnZhbCA9IHtcbiAgICAgICAgICBzdGFydDogdF9zLFxuICAgICAgICAgIGVuZDogdF9lLFxuICAgICAgICB9O1xuXG4gICAgICAgIGxldCBlcnJvciA9IHRoaXMuX2Vycm9yKGFyYywgbnAxLCB0X3MsIHRfZSk7XG4gICAgICAgIGN1cnJfZ29vZCA9IGVycm9yIDw9IGVycm9yVGhyZXNob2xkO1xuXG4gICAgICAgIGRvbmUgPSBwcmV2X2dvb2QgJiYgIWN1cnJfZ29vZDtcbiAgICAgICAgaWYgKCFkb25lKSBwcmV2X2UgPSB0X2U7XG5cbiAgICAgICAgLy8gdGhpcyBhcmMgaXMgZmluZTogd2UgY2FuIG1vdmUgJ2UnIHVwIHRvIHNlZSBpZiB3ZSBjYW4gZmluZCBhIHdpZGVyIGFyY1xuICAgICAgICBpZiAoY3Vycl9nb29kKSB7XG4gICAgICAgICAgLy8gaWYgZSBpcyBhbHJlYWR5IGF0IG1heCwgdGhlbiB3ZSdyZSBkb25lIGZvciB0aGlzIGFyYy5cbiAgICAgICAgICBpZiAodF9lID49IDEpIHtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBjYXAgYXQgdD0xXG4gICAgICAgICAgICBhcmMuaW50ZXJ2YWwuZW5kID0gcHJldl9lID0gMTtcbiAgICAgICAgICAgIHByZXZfYXJjID0gYXJjO1xuICAgICAgICAgICAgLy8gaWYgd2UgY2FwcGVkIHRoZSBhcmMgc2VnbWVudCB0byB0PTEgd2UgYWxzbyBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0XG4gICAgICAgICAgICAvLyB0aGUgYXJjJ3MgZW5kIGFuZ2xlIGlzIGNvcnJlY3Qgd2l0aCByZXNwZWN0IHRvIHRoZSBiZXppZXIgZW5kIHBvaW50LlxuICAgICAgICAgICAgaWYgKHRfZSA+IDEpIHtcbiAgICAgICAgICAgICAgbGV0IGQgPSB7XG4gICAgICAgICAgICAgICAgeDogYXJjLnggKyBhcmMuciAqIGNvcyhhcmMuZSksXG4gICAgICAgICAgICAgICAgeTogYXJjLnkgKyBhcmMuciAqIHNpbihhcmMuZSksXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGFyYy5lICs9IHV0aWxzLmFuZ2xlKHsgeDogYXJjLngsIHk6IGFyYy55IH0sIGQsIHRoaXMuZ2V0KDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpZiBub3QsIG1vdmUgaXQgdXAgYnkgaGFsZiB0aGUgaXRlcmF0aW9uIGRpc3RhbmNlXG4gICAgICAgICAgdF9lID0gdF9lICsgKHRfZSAtIHRfcykgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoaXMgaXMgYSBiYWQgYXJjOiB3ZSBuZWVkIHRvIG1vdmUgJ2UnIGRvd24gdG8gZmluZCBhIGdvb2QgYXJjXG4gICAgICAgICAgdF9lID0gdF9tO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICghZG9uZSAmJiBzYWZldHkrKyA8IDEwMCk7XG5cbiAgICAgIGlmIChzYWZldHkgPj0gMTAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBjb25zb2xlLmxvZyhcIkw4MzU6IFtGXSBhcmMgZm91bmRcIiwgdF9zLCBwcmV2X2UsIHByZXZfYXJjLngsIHByZXZfYXJjLnksIHByZXZfYXJjLnMsIHByZXZfYXJjLmUpO1xuXG4gICAgICBwcmV2X2FyYyA9IHByZXZfYXJjID8gcHJldl9hcmMgOiBhcmM7XG4gICAgICBjaXJjbGVzLnB1c2gocHJldl9hcmMpO1xuICAgICAgdF9zID0gcHJldl9lO1xuICAgIH0gd2hpbGUgKHRfZSA8IDEpO1xuICAgIHJldHVybiBjaXJjbGVzO1xuICB9XG59XG5cbmV4cG9ydCB7IEJlemllciB9O1xuIiwiLyoqXG4gKiDmlrnlkJFcbiAqIEByZWFkb25seVxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IERJUkVDVElPTiA9IHtcbiAgICAvKiogUklHSFQgKi9cbiAgICBSSUdIVDogMCxcbiAgICAvKiogQk9UVE9NICovXG4gICAgQk9UVE9NOiAxLFxuICAgIC8qKiBMRUZUICovXG4gICAgTEVGVDogMixcbiAgICAvKiogVE9QICovXG4gICAgVE9QOiAzLFxuICAgIC8qKiBTRUxGICovXG4gICAgU0VMRjogMTAwLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gbmV4dERpcmVjdGlvbihkaXJlY3Rpb24sIGNsb2Nrd2lzZSkge1xuICAgIGNvbnN0IG5leHREaXIgPSAoZGlyZWN0aW9uICsgKGNsb2Nrd2lzZSA/IDEgOiAtMSkpICUgNDtcbiAgICByZXR1cm4gbmV4dERpcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9wcG9zaXRlRGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgIHJldHVybiAoZGlyZWN0aW9uICsgMikgJSA0XG59XG5cbmV4cG9ydCBjb25zdCBBUFBST1hJTUFURSA9IDY7XG5cbmV4cG9ydCBjb25zdCBKRkxPV19NT0RFID0ge1xuICAgIERFRkFVTFQ6ICdERUZBVUxUJyxcbiAgICBMSU5LSU5HOiAnTElOS0lORycsXG59XG5cbmV4cG9ydCBjb25zdCBMSU5FX0RJUiA9IHtcbiAgICBGUk9NOiAnZnJvbScsXG4gICAgVE86ICd0bycsXG59IiwiaW1wb3J0IHtcbiAgICBCZXppZXIsXG59IGZyb20gJ2Jlemllci1qcyc7XG5pbXBvcnQgeyBESVJFQ1RJT04gfSBmcm9tICcuL2NvbnN0YW5jZSc7XG5cbi8qKlxuICog5qC55o2u54K56K6h566X5pyA5bCP5aSW5o6l55+p5b2iXG4gKiBAcGFyYW0ge251bWJlcltdW119IHBvaW50cyAtIOeCuembhuWQiFxuICogQHJldHVybiB7T2JqZWN0fSBkZW1lbnNpb24g5a696auY77yM5Z2Q5qCHXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBib3VuZGluZ19ib3gocG9pbnRzKSB7XG4gICAgaWYocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgbWluX3ggPSBJbmZpbml0eTsgXG4gICAgbGV0IG1pbl95ID0gSW5maW5pdHk7IFxuICAgIGxldCBtYXhfeCA9IC1JbmZpbml0eTsgXG4gICAgbGV0IG1heF95ID0gLUluZmluaXR5OyBcbiAgICBmb3IobGV0IGlkeCBpbiBwb2ludHMpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHBvaW50c1tpZHhdO1xuICAgICAgICBpZihpdGVtWzBdIDwgbWluX3gpe1xuICAgICAgICAgICAgbWluX3ggPSBpdGVtWzBdXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbVswXSA+IG1heF94KSB7XG4gICAgICAgICAgICBtYXhfeCA9IGl0ZW1bMF1cbiAgICAgICAgfSBcblxuICAgICAgICBpZiAoaXRlbVsxXSA8IG1pbl95KSB7XG4gICAgICAgICAgICBtaW5feSA9IGl0ZW1bMV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVtWzFdID4gbWF4X3kpIHtcbiAgICAgICAgICAgIG1heF95ID0gaXRlbVsxXVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIC8vIHBvaW50czogWyhtaW5feCxtaW5feSksKG1heF94LG1pbl95KSwobWF4X3gsbWF4X3kpLChtaW5feCxtYXhfeSldLFxuICAgICAgICB3aWR0aDogTWF0aC5tYXgobWF4X3ggLSBtaW5feCwgMTApLFxuICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KG1heF95IC0gbWluX3ksIDEwKSxcbiAgICAgICAgeDogbWluX3gsXG4gICAgICAgIHk6IG1pbl95LFxuICAgIH1cbn1cblxuZnVuY3Rpb24gc3FyKHgpIHtcbiAgICByZXR1cm4geCAqIHg7XG59XG5leHBvcnQgZnVuY3Rpb24gZGlzdDIodiwgdykge1xuICAgIHJldHVybiBzcXIodlswXSAtIHdbMF0pICsgc3FyKHZbMV0gLSB3WzFdKTtcbn1cblxuLy8gcCAtIHBvaW50XG4vLyB2IC0gc3RhcnQgcG9pbnQgb2Ygc2VnbWVudFxuLy8gdyAtIGVuZCBwb2ludCBvZiBzZWdtZW50XG5leHBvcnQgZnVuY3Rpb24gZGlzdFRvU2VnbWVudFNxdWFyZWQocCwgdiwgdykge1xuICAgIGNvbnN0IGwyID0gZGlzdDIodiwgdyk7XG4gICAgaWYgKGwyID09PSAwKSByZXR1cm4gZGlzdDIocCwgdik7XG4gICAgbGV0IHQgPSAoKHBbMF0gLSB2WzBdKSAqICh3WzBdIC0gdlswXSkgKyAocFsxXSAtIHZbMV0pICogKHdbMV0gLSB2WzFdKSkgLyBsMjtcbiAgICB0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdCkpO1xuICAgIHJldHVybiBkaXN0MihwLCBbIHZbMF0gKyB0ICogKHdbMF0gLSB2WzBdKSwgdlsxXSArIHQgKiAod1sxXSAtIHZbMV0pIF0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWluSW50ZXJzZWN0aW9uQmV0d2Vlbk5vZGVzKGRtc2Zyb20sIGRtc3RvKSB7XG4gICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgZnJvbURpcjogbnVsbCxcbiAgICAgICAgZnJvbVA6IG51bGwsXG4gICAgICAgIHRvRGlyOiBudWxsLFxuICAgICAgICB0b1A6IG51bGwsXG4gICAgICAgIGRpc3RNaW46IEluZmluaXR5XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKGRtc2Zyb20pLmZvckVhY2goZGYgPT4ge1xuICAgICAgICBpZigoK2RmKSA9PT0gRElSRUNUSU9OLlNFTEYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGYgPSBkbXNmcm9tW2RmXTtcbiAgICAgICAgT2JqZWN0LmtleXMoZG1zdG8pLmZvckVhY2goZHQgPT4ge1xuICAgICAgICAgICAgaWYoKCtkdCkgPT09IERJUkVDVElPTi5TRUxGKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHB0ID0gZG1zdG9bZHRdO1xuICAgICAgICAgICAgY29uc3QgZGlzdCA9IGRpc3QyKHBmLCBwdCk7XG4gICAgICAgICAgICBpZihkaXN0IDwgbWV0YS5kaXN0TWluKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihtZXRhLCB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3RNaW46IGRpc3QsXG4gICAgICAgICAgICAgICAgICAgIGZyb21EaXI6ICtkZixcbiAgICAgICAgICAgICAgICAgICAgZnJvbVA6IHBmLFxuICAgICAgICAgICAgICAgICAgICB0b0RpcjogK2R0LFxuICAgICAgICAgICAgICAgICAgICB0b1A6IHB0LFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfSk7XG4gICAgcmV0dXJuIG1ldGE7XG59XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBiZXppZXJQb2ludHMocDEsIHAyLCBzdGFydF9kaXIgPSBESVJFQ1RJT04uVE9QLCBlbmRfZGlyID0gRElSRUNUSU9OLlRPUCwgYW50aWNsb2NrID0gZmFsc2UpIHtcbi8vICAgICBjb25zdCBpc1NhbWVEaXJlY3Rpb24gPSBzdGFydF9kaXIgPT09IGVuZF9kaXI7XG4vLyAgICAgY29uc3QgaXNWZXJ0aWNhbFN0YXJ0ID0gW0RJUkVDVElPTi5UT1AsIERJUkVDVElPTi5CT1RUT01dLmluY2x1ZGVzKHN0YXJ0X2Rpcik7ICAgXG4vLyAgICAgY29uc3QgaXNWZXJ0aWNhbEVuZCA9IFtESVJFQ1RJT04uVE9QLCBESVJFQ1RJT04uQk9UVE9NXS5pbmNsdWRlcyhlbmRfZGlyKTtcbi8vICAgICBjb25zdCBhcnJvd3NwYW4gPSBbRElSRUNUSU9OLlRPUCwgRElSRUNUSU9OLkxFRlRdLmluY2x1ZGVzKGVuZF9kaXIpID8gLTUgOiA1O1xuLy8gICAgIGNvbnN0IGVuZFggPSBpc1ZlcnRpY2FsRW5kID8gcDJbMF0gOiBwMlswXSArIGFycm93c3Bhbjtcbi8vICAgICBjb25zdCBlbmRZID0gaXNWZXJ0aWNhbEVuZCA/IHAyWzFdICsgYXJyb3dzcGFuIDogcDJbMV07XG4vLyAgICAgaWYoaXNTYW1lRGlyZWN0aW9uKSB7XG4vLyAgICAgICAgIGxldCBzcGFuID0gTWF0aC5hYnMoaXNWZXJ0aWNhbFN0YXJ0ID8gKGVuZFkgLSBwMVsxXSkgOiAoZW5kWCAtIHAxWzBdKSlcbi8vICAgICAgICAgc3BhbiA9IE1hdGgubWluKHNwYW4sIDUwKTtcbi8vICAgICAgICAgY29uc3Qgc3ltYiA9IFtESVJFQ1RJT04uUklHSFQsIERJUkVDVElPTi5CT1RUT01dLmluY2x1ZGVzKGVuZF9kaXIpXG4vLyAgICAgICAgIHNwYW4gPSBzeW1iID8gc3BhbiA6IC0gc3Bhbjtcbi8vICAgICAgICAgY29uc3QgY3AxID0gaXNWZXJ0aWNhbFN0YXJ0ID8gW3AxWzBdLCBwMVsxXSArIHNwYW5dIDogW3AxWzBdICsgc3BhbiwgcDFbMV1dO1xuLy8gICAgICAgICBjb25zdCBjcDIgPSBpc1ZlcnRpY2FsRW5kID8gW2VuZFgsIGVuZFkgKyBzcGFuXSA6IFtlbmRYICsgc3BhbiwgZW5kWV07XG4vLyAgICAgICAgIHJldHVybiBbIFxuLy8gICAgICAgICAgICAgLi4uY3AxLFxuLy8gICAgICAgICAgICAgLi4uY3AyLFxuLy8gICAgICAgICAgICAgZW5kWCwgZW5kWSBdO1xuLy8gICAgIH1cbi8vICAgICBsZXQgc3BhblN0YXJ0ID0gKGFudGljbG9jayA/IC01IDogMSkgKiAoaXNWZXJ0aWNhbFN0YXJ0ID8gKGVuZFkgLSBwMVsxXSkgLyAyIDogKGVuZFggLSBwMVswXSkgLyAyKVxuLy8gICAgIGxldCBzcGFuRW5kID0gKGFudGljbG9jayA/IC00IDogMSkgKiAoaXNWZXJ0aWNhbEVuZCA/IChwMVsxXSAtIGVuZFkpIC8gMiA6IChwMVswXSAtIGVuZFgpIC8gMilcbi8vICAgICBsZXQgdTEgPSBzcGFuU3RhcnQgLyBNYXRoLmFicyhzcGFuU3RhcnQpO1xuLy8gICAgIHNwYW5TdGFydCA9IHUxICogTWF0aC5taW4oTWF0aC5hYnMoc3BhblN0YXJ0KSwgNTApO1xuLy8gICAgIGxldCB1MiA9IHNwYW5FbmQgLyBNYXRoLmFicyhzcGFuRW5kKTtcbi8vICAgICBzcGFuRW5kID0gdTIgKiBNYXRoLm1pbihNYXRoLmFicyhzcGFuRW5kKSwgNTApO1xuLy8gICAgIGNvbnN0IGNwMSA9IGlzVmVydGljYWxTdGFydCA/IFtwMVswXSwgcDFbMV0gKyBzcGFuU3RhcnRdIDogW3AxWzBdICsgc3BhblN0YXJ0LCBwMVsxXV07XG4vLyAgICAgY29uc3QgY3AyID0gaXNWZXJ0aWNhbEVuZCA/IFtlbmRYLCBlbmRZICsgc3BhbkVuZF0gOiBbZW5kWCArIHNwYW5FbmQsIGVuZFldO1xuLy8gICAgIHJldHVybiBbIFxuLy8gICAgICAgICAuLi5jcDEsXG4vLyAgICAgICAgIC4uLmNwMixcbi8vICAgICAgICAgZW5kWCwgZW5kWSBdO1xuLy8gfVxuZnVuY3Rpb24gX3Jlc29sdmVDb250cm9sUG9pbnQocCwgZGlyLCBzcGFueCwgc3Bhbnkpe1xuICAgIGlmKGRpciA9PT0gRElSRUNUSU9OLlRPUCl7XG4gICAgICAgIHJldHVybiBbcFswXSwgcFsxXS1zcGFueV1cbiAgICB9XG4gICAgaWYoZGlyID09PSBESVJFQ1RJT04uQk9UVE9NKXtcbiAgICAgICAgcmV0dXJuIFtwWzBdLCBwWzFdK3NwYW55XVxuICAgIH1cbiAgICBpZihkaXIgPT09IERJUkVDVElPTi5MRUZUKXtcbiAgICAgICAgcmV0dXJuIFtwWzBdLXNwYW54LCBwWzFdXVxuICAgIH1cbiAgICBpZihkaXIgPT09IERJUkVDVElPTi5SSUdIVCl7XG4gICAgICAgIHJldHVybiBbcFswXStzcGFueCwgcFsxXV1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiZXppZXJQb2ludHMocDEsIHAyLCBzdGFydF9kaXIgPSBESVJFQ1RJT04uVE9QLCBlbmRfZGlyID0gRElSRUNUSU9OLlRPUCwgbWluU3BhblggPSAwLCBtaW5TcGFuWSA9IDApIHtcbiAgICBjb25zdCBzcGFueCA9IE1hdGgubWF4KE1hdGguYWJzKChwMVswXSAtIHAyWzBdKS8yKSwgbWluU3BhblgpO1xuICAgIGNvbnN0IHNwYW55ID0gTWF0aC5tYXgoTWF0aC5hYnMoKHAxWzFdIC0gcDJbMV0pLzIpLCBtaW5TcGFuWSk7XG4gICAgY29uc3QgY3AxID0gX3Jlc29sdmVDb250cm9sUG9pbnQocDEsIHN0YXJ0X2Rpciwgc3BhbngsIHNwYW55KTtcbiAgICBjb25zdCBjcDIgPSBfcmVzb2x2ZUNvbnRyb2xQb2ludChwMiwgZW5kX2Rpciwgc3BhbngsIHNwYW55KTtcbiAgICBjb25zdCBhcnJvd3NwYW4gPSBbRElSRUNUSU9OLlRPUCwgRElSRUNUSU9OLkxFRlRdLmluY2x1ZGVzKGVuZF9kaXIpID8gLTUgOiA1O1xuICAgIGNvbnN0IGlzVmVydGljYWxFbmQgPSBbRElSRUNUSU9OLlRPUCwgRElSRUNUSU9OLkJPVFRPTV0uaW5jbHVkZXMoZW5kX2Rpcik7XG4gICAgY29uc3QgZW5kWCA9IGlzVmVydGljYWxFbmQgPyBwMlswXSA6IHAyWzBdICsgYXJyb3dzcGFuO1xuICAgIGNvbnN0IGVuZFkgPSBpc1ZlcnRpY2FsRW5kID8gcDJbMV0gKyBhcnJvd3NwYW4gOiBwMlsxXTtcbiAgICByZXR1cm4gWyBcbiAgICAgICAgLi4uY3AxLFxuICAgICAgICAuLi5jcDIsXG4gICAgICAgIGVuZFgsIGVuZFldO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmV6aWVyUG9pbnQodCwgUCkge1xuICAgIGNvbnN0IHEgPSAxLXQ7XG4gICAgY29uc3QgeCA9IHEqcSpxKlBbMF0gKyAzKnEqcSp0KlBbMl0gKyAzKnEqdCp0KlBbNF0gKyB0KnQqdCpQWzZdO1xuICAgIGNvbnN0IHkgPSBxKnEqcSpQWzFdICsgMypxKnEqdCpQWzNdICsgMypxKnQqdCpQWzVdICsgdCp0KnQqUFs3XTtcbiAgICBjb25zdCB1ID0gcSpxKihQWzJdLVBbMF0pICsgMip0KnEqKFBbNF0tUFsyXSkgKyB0KnQqKFBbNl0tUFs0XSk7XG4gICAgY29uc3QgdiA9IHEqcSooUFszXS1QWzFdKSArIDIqdCpxKihQWzVdLVBbM10pICsgdCp0KihQWzddLVBbNV0pO1xuICAgIGxldCBhbmdsZSA9IE1hdGguYXRhbjIodiwgdSk7XG4gICAgLy8gY29uc29sZS5sb2coYW5nbGUgKiAxODApXG4gICAgLy8gaWYoYW5nbGUgPCAwKSB7XG4gICAgLy8gICAgIGFuZ2xlID0gTWF0aC5QSSArIGFuZ2xlO1xuICAgIC8vIH1cbiAgICByZXR1cm4gW3gsIHksIGFuZ2xlXTtcbn1cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIGJlemllclBvaW50cyhwMSwgcDIsIHN0YXJ0X3ZlYywgZW5kX3ZlYykge1xuXG4vLyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0VG9CZXppZXJTZWdtZW50U3F1YXJlZChwLCBwb2ludHMpIHtcbiAgICBjb25zdCBiID0gbmV3IEJlemllciguLi5wb2ludHMpO1xuXG4gICAgY29uc3QgcG9pbnQgPSBiLnByb2plY3QoeyB4OiBwWzBdLCB5OiBwWzFdIH0pO1xuICAgIGNvbnN0IGQgPSBkaXN0MihwLCBbIHBvaW50LngsIHBvaW50LnkgXSk7XG4gICAgcmV0dXJuIGQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRCZXppZXJBbmdsZSh0LCBzeCwgc3ksIGNwMXgsIGNwMXksIGNwMngsIGNwMnksIGV4LCBleSkge1xuICB2YXIgZHggPSBNYXRoLnBvdygxLXQsIDIpKihjcDF4LXN4KSArIDIqdCooMS10KSooY3AyeC1jcDF4KSArIHQgKiB0ICogKGV4IC0gY3AyeCk7XG4gIHZhciBkeSA9IE1hdGgucG93KDEtdCwgMikqKGNwMXktc3kpICsgMip0KigxLXQpKihjcDJ5LWNwMXkpICsgdCAqIHQgKiAoZXkgLSBjcDJ5KTtcbiAgcmV0dXJuIC1NYXRoLmF0YW4yKGR4LCBkeSkgKyAwLjUqTWF0aC5QSTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5zdGFuY2VIZWlnaHQoaW5zdGFuY2UpIHtcbiAgICBjb25zdCByZWN0ID0gaW5zdGFuY2UuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgLy8gbGV0IG1pbl95ID0gSW5maW5pdHk7XG4gICAgLy8gbGV0IG1heF95ID0gLUluZmluaXR5O1xuICAgIC8vIGxldCBtaW5feCA9IEluZmluaXR5O1xuICAgIC8vIGxldCBtYXhfeCA9IC1JbmZpbml0eTtcbiAgICAvLyByZWN0LmZvckVhY2gocG9pbnQgPT4ge1xuICAgIC8vICAgICBtYXhfeSA9IE1hdGgubWF4KG1heF95LCBwb2ludFsxXSk7XG4gICAgLy8gICAgIG1pbl95ID0gTWF0aC5taW4obWluX3ksIHBvaW50WzFdKTtcbiAgICAvLyAgICAgbWF4X3ggPSBNYXRoLm1heChtYXhfeCwgcG9pbnRbMF0pO1xuICAgIC8vICAgICBtaW5feCA9IE1hdGgubWluKG1pbl94LCBwb2ludFswXSk7XG4gICAgLy8gfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGVpZ2h0OiByZWN0WzNdIC0gcmVjdFsxXSxcbiAgICAgICAgd2lkdGg6IHJlY3RbMl0gLSByZWN0WzBdLFxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlsaW5lUG9pbnRzKHBvaW50cywgcDEsIHAyLCBzdGFydF9kaXIgPSBESVJFQ1RJT04uVE9QLCBlbmRfZGlyID0gRElSRUNUSU9OLlRPUCwgbWluU3BhblggPSAxMCwgbWluU3BhblkgPSAxMCwgaXNTZWxmKSB7XG4gICAgY29uc3QgZGlyU3BhbiA9IE1hdGguYWJzKHN0YXJ0X2RpciAtIGVuZF9kaXIpO1xuICAgIC8vIGNvbnN0IHNwYW54ID0gTWF0aC5tYXgoTWF0aC5hYnMoKHAxWzBdIC0gcDJbMF0pLzIpLCBtaW5TcGFuWCk7XG4gICAgLy8gY29uc3Qgc3BhbnkgPSBNYXRoLm1heChNYXRoLmFicygocDFbMV0gLSBwMlsxXSkvMiksIG1pblNwYW5ZKTtcbiAgICBjb25zdCBpc1ZlcnRpY2FsU3RhcnQgPSAoc3RhcnRfZGlyID09PSBESVJFQ1RJT04uVE9QIHx8IHN0YXJ0X2RpciA9PT0gRElSRUNUSU9OLkJPVFRPTSk7XG4gICAgcG9pbnRzLmxlbmd0aCA9IDA7XG4gICAgc3dpdGNoIChkaXJTcGFuKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIC8vIOmDveaMieWQkeWPs+WlveS6hlxuICAgICAgICAgICAgaWYoc3RhcnRfZGlyID09PSBESVJFQ1RJT04uVE9QKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IE1hdGgubWluKHAxWzFdLCBwMlsxXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeXAgPSB5IC0gbWluU3Bhblk7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goW3AxWzBdLCB5cF0pO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFtwMlswXSwgeXBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHN0YXJ0X2RpciA9PT0gRElSRUNUSU9OLkJPVFRPTSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLm1heChwMVsxXSwgcDJbMV0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHlwID0geSArIG1pblNwYW5ZO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFtwMVswXSwgeXBdKTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChbcDJbMF0sIHlwXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihzdGFydF9kaXIgPT09IERJUkVDVElPTi5MRUZUKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgubWluKHAxWzBdLCBwMlswXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeHAgPSB4IC0gbWluU3Bhblg7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goW3hwLCBwMVsxXV0pO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFt4cCwgcDJbMV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHN0YXJ0X2RpciA9PT0gRElSRUNUSU9OLlJJR0hUKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgubWF4KHAxWzBdLCBwMlswXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeHAgPSB4ICsgbWluU3Bhblg7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goW3hwLCBwMVsxXV0pO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFt4cCwgcDJbMV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMzogIFxuICAgICAgICAgICAgaWYoaXNTZWxmKSB7XG4gICAgICAgICAgICAgICAgaWYoIWlzVmVydGljYWxTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChbcDFbMF0gKyBtaW5TcGFuWCwgcDFbMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goW3AxWzBdICsgbWluU3BhblgsIHAyWzFdICsgbWluU3BhblldKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goW3AyWzBdLCBwMlsxXSArIG1pblNwYW5ZXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goW3AxWzBdLCBwMVsxXSArIG1pblNwYW5ZXSk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFtwMlswXSArIG1pblNwYW5YLCBwMVsxXSArIG1pblNwYW5ZXSk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFtwMlswXSArIG1pblNwYW5YLCBwMlsxXV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBpc1ZlcnRpY2FsU3RhcnQgPyBbcDFbMF0sIHAyWzFdXTogW3AyWzBdLCBwMVsxXV1cbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY29uc3QgcG1pZGRsZSA9IFtcbiAgICAgICAgICAgICAgICAocDFbMF0gLSBwMlswXSkvMiArIHAyWzBdLFxuICAgICAgICAgICAgICAgIChwMVsxXSAtIHAyWzFdKS8yICsgcDJbMV1cbiAgICAgICAgICAgIF07IFxuICAgICAgICAgICAgaWYoaXNWZXJ0aWNhbFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goW3AxWzBdLCBwbWlkZGxlWzFdXSlcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChbcDJbMF0sIHBtaWRkbGVbMV1dKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChbcG1pZGRsZVswXSwgcDFbMV1dKVxuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFtwbWlkZGxlWzBdLCBwMlsxXV0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwb2ludHMudW5zaGlmdChwMSk7XG4gICAgcG9pbnRzLnB1c2gocDIpO1xufVxuXG5mdW5jdGlvbiBtaW51c1ZlYyhwMSwgcDIpIHtcbiAgICByZXR1cm4gW3AxWzBdIC0gcDJbMF0sIHAxWzFdIC0gcDJbMV1dXG59XG5cbmZ1bmN0aW9uIGFic1ZlYyh2ZWMpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHZlY1swXSAqIHZlY1swXSArIHZlY1sxXSAqIHZlY1sxXSk7XG59XG5cbmZ1bmN0aW9uIHNjYWxlVmVjKHZlYywgc2NhbGUpIHtcbiAgICByZXR1cm4gW3ZlY1swXSAqIHNjYWxlLCB2ZWNbMV0gKiBzY2FsZV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUmFkaXVzRnJvbVZlY3RvcihwYmVmb3JlLCBwLCBwbmV4dCwgcmFkaXVzKSB7XG4gICAgY29uc3QgdmVjMSA9IG1pbnVzVmVjKHAsIHBiZWZvcmUpO1xuICAgIGNvbnN0IHZlYzIgPSBtaW51c1ZlYyhwLCBwbmV4dCk7XG4gICAgY29uc3QgYWJzVmVjMSA9IGFic1ZlYyh2ZWMxKTtcbiAgICBjb25zdCBhYnNWZWMyID0gYWJzVmVjKHZlYzIpO1xuICAgIGlmKCFhYnNWZWMxIHx8ICFhYnNWZWMyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwMTogbnVsbCxcbiAgICAgICAgICAgIHAyOiBudWxsLFxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHIxID0gc2NhbGVWZWModmVjMSwgcmFkaXVzL2Fic1ZlYzEpO1xuICAgIGNvbnN0IHIyID0gc2NhbGVWZWModmVjMiwgcmFkaXVzL2Fic1ZlYzIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHAxOiBtaW51c1ZlYyhwLCByMSksXG4gICAgICAgIHAyOiBtaW51c1ZlYyhwLCByMiksXG4gICAgfVxufVxuLy8g55+p5b2i6YeN5Y+g6K6h566XXG5leHBvcnQgZnVuY3Rpb24gZG9PdmVybGFwKHJlYzEsIHJlYzIpIHtcbiAgICBpZiAocmVjMVswXSA9PSByZWMxWzJdIHx8IHJlYzFbMV0gPT0gcmVjMVszXSB8fFxuICAgICAgICByZWMyWzBdID09IHJlYzJbMl0gfHwgcmVjMlsxXSA9PSByZWMyWzNdKSB7XG4gICAgICAgIC8vIHRoZSBsaW5lIGNhbm5vdCBoYXZlIHBvc2l0aXZlIG92ZXJsYXBcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAhKHJlYzFbMl0gPD0gcmVjMlswXSB8fCAgIC8vIGxlZnRcbiAgICAgICAgICAgICAgICByZWMxWzNdIDw9IHJlYzJbMV0gfHwgICAvLyBib3R0b21cbiAgICAgICAgICAgICAgICByZWMxWzBdID49IHJlYzJbMl0gfHwgICAvLyByaWdodFxuICAgICAgICAgICAgICAgIHJlYzFbMV0gPj0gcmVjMlszXSk7ICAgIC8vIHRvcFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQb2x5TGluZUludGVyc2VjdGlvblJlY3RhbmdlKHBvbHlsaW5lLCByZWN0KSB7XG4gICAgbGV0IHAgPSBwb2x5bGluZVswXTtcbiAgICBsZXQgbCA9IHBvbHlsaW5lLmxlbmd0aDtcbiAgICBsZXQgaSA9IDE7XG4gICAgY29uc3QgW2wwLCBsMSwgcjAsIHIxXSA9IHJlY3Q7XG4gICAgd2hpbGUgKGkgPCBsKSB7XG4gICAgICAgIGNvbnN0IGNwID0gcG9seWxpbmVbaV07XG4gICAgICAgIGlmKHBbMF0gPT09IGNwWzBdKSB7XG4gICAgICAgICAgICAvLyB2ZXJ0aWNhbFxuICAgICAgICAgICAgaWYocFswXSA8IHIwICYmIHBbMF0gPiBsMCBcbiAgICAgICAgICAgICAgICAmJiAhKChwWzFdID4gcjEgJiYgY3BbMV0gPiByMSkgfHwgKHBbMV0gPCBsMSAmJiBjcFsxXSA8IGwxKSkpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaG9yaXpvbnRhbFxuICAgICAgICAgICAgaWYocFsxXSA8IHIxICYmIHBbMV0gPiBsMVxuICAgICAgICAgICAgICAgICYmICEoKHBbMF0gPiByMCAmJiBjcFswXSA+IHIwKSB8fCAocFswXSA8IGwwICYmIGNwWzBdIDwgbDApKSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgIH1cbiAgICAgICAgcCA9IGNwO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHRpbWVvdXQgPSAzMDApe1xuICAgIGxldCB0aW1lcjtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7IGZ1bmMuY2FsbCh0aGlzKTsgfSwgdGltZW91dCk7XG4gICAgfTtcbiAgfVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZUJvdW5kaW5nYm94KGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb3B5Qm91bmRpbmdib3goYSwgYikge1xuICAgIGFbMF0gPSBiWzBdO1xuICAgIGFbMV0gPSBiWzFdO1xuICAgIGFbMl0gPSBiWzJdO1xuICAgIGFbM10gPSBiWzNdO1xufSIsIi8vIGltcG9ydCB7IHNldFVuaXF1ZUlkLCBnZXRVbmlxdWVJZCB9IGZyb20gJy4uL3V0aWxzL2Z1bmN0aW9ucyc7XG4vLyBpbXBvcnQgeyBuZXh0RGlyZWN0aW9uIH0gZnJvbSAnLi4vdXRpbHMvY29uc3RhbmNlJztcbi8vIGNvbnN0IG1hcmdpbiA9IDU7XG5jb25zdCBpc2hpdEtleSA9IFN5bWJvbCgnaXNoaXQnKTtcbmNvbnN0IGlzSW5WaWV3Qm94ID0gU3ltYm9sKCdpc0luVmlld0JveCcpO1xuLyoqXG4gKiBAdHlwZWRlZiBJbnN0YW5jZX5Db25maWdzXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJvcmRlcldpZHRoICAgICAgLSDovrnnmoTlrr3luqYg6buY6K6k5pivIDJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBib3JkZXJDb2xvciAgICAgIC0g6L655qGG6aKc6ImyIOm7mOiupCBibGFja1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbG9yICAgICAgICAgICAgLSDloavlhYXpopzoibIg6buY6K6kIHdoaXRlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc2hhZG93Q29sb3IgICAgICAtIOmYtOW9seminOiJslxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNoYWRvd0JsdXIgICAgICAgLSDpmLTlvbHmianmlaPojIPlm7RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzaGFkb3dPZmZzZXRYICAgIC0g6Zi05b2x5YGP56e7IFhcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzaGFkb3dPZmZzZXRYICAgIC0g6Zi05b2x5YGP56e7IFlcbiAqL1xuXG4vKiogXG4gKiDlm77kuK3nmoTmnIDlsI/ljZXlhYNcbiAqIEBjb25zdHJ1Y3RvciBJbnN0YW5jZVxuICogQGV4dGVuZHMgRXZlbnRUYXJnZXRcbiAqIEBwYXJhbSB7SW5zdGFuY2V+Q29uZmlnc30gY29uZmlncyAtIOacgOWwj+WNleWFg+eahOS4gOS6m+mAmueUqOWxnuaAp+mFjee9rlxuICovXG5jbGFzcyBJbnN0YW5jZSBleHRlbmRzIEV2ZW50VGFyZ2V0e1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3MgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNvbmZpZ3MpO1xuICAgICAgICAvLyB0aGlzLmFuY2hvciA9IGNvbmZpZ3MuYW5jaG9yIHx8IFswLCAwXTtcbiAgICAgICAgLy8gdGhpcy5iZWxvbmdzID0gdW5kZWZpbmVkO1xuICAgICAgICAvKiogQG1lbWJlciB7Ym9vbGVhbn0gICAgICAtIOWFg+e0oOWPr+ingSDpu5jorqQgdHJ1ZSAqL1xuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAvLyB0aGlzLl9qZmxvdyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fYmVsb25ncyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpc1tpc2hpdEtleV0gPSBmYWxzZTsgXG5cbiAgICAgICAgLyoqIEBtZW1iZXIge251bWJlcn0gICAgICAtIOi+ueeahOWuveW6piDpu5jorqTmmK8gMCAqL1xuICAgICAgICB0aGlzLmJvcmRlcldpZHRoID0gICAgICBjb25maWdzLmJvcmRlcldpZHRoIHx8IDA7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtzdHJpbmd9ICAgICAtIOi+ueahhuminOiJsiDpu5jorqQgdHJhbnNwYXJlbnQgKi9cbiAgICAgICAgdGhpcy5ib3JkZXJDb2xvciA9ICAgICAgY29uZmlncy5ib3JkZXJDb2xvciB8fCAndHJhbnNwYXJlbnQnO1xuICAgICAgICAvKiogQG1lbWJlciB7c3RyaW5nfSAgICAgLSDloavlhYXpopzoibIg6buY6K6kIHRyYW5zcGFyZW50ICovXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gIGNvbmZpZ3MuYmFja2dyb3VuZENvbG9yIHx8ICd0cmFuc3BhcmVudCc7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtzdHJpbmd9ICAgICAtIOmYtOW9seminOiJsiDnqbrlsLHkuI3mmL7npLrpmLTlvbEgKi9cbiAgICAgICAgdGhpcy5zaGFkb3dDb2xvciA9ICAgICAgY29uZmlncy5zaGFkb3dDb2xvcjtcbiAgICAgICAgLyoqIEBtZW1iZXIge3N0cmluZ30gICAgIC0g6Zi05b2x5omp5pWj6IyD5Zu0IOm7mOiupCA1ICovXG4gICAgICAgIHRoaXMuc2hhZG93Qmx1ciAgPSAgICAgIGNvbmZpZ3Muc2hhZG93Qmx1ciB8fCA1O1xuICAgICAgICAvKiogQG1lbWJlciB7c3RyaW5nfSAgICAgLSDpmLTlvbHlgY/np7sgWCAqL1xuICAgICAgICB0aGlzLnNoYWRvd09mZnNldFggPSAgICBjb25maWdzLnNoYWRvd09mZnNldFggfHwgMDtcbiAgICAgICAgLyoqIEBtZW1iZXIge3N0cmluZ30gICAgIC0g6Zi05b2x5YGP56e7IFkgKi9cbiAgICAgICAgdGhpcy5zaGFkb3dPZmZzZXRZID0gICAgY29uZmlncy5zaGFkb3dPZmZzZXRZIHx8IDA7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtudW1iZXJ9ICAgICAtIOmAj+aYjuW6piAqL1xuICAgICAgICB0aGlzLm9wYWNpdHkgID0gICAgICAgICBjb25maWdzLm9wYWNpdHkgfHwgMVxuXG4gICAgICAgIHRoaXMuX2JvdW5kaW5ncmVjdCA9IFswLDAsMCwwXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn0gLSDlvZPliY3ljZXlhYPpgInkuK3nirbmgIFcbiAgICAgKi9cbiAgICBnZXQgX2lzVGFyZ2V0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcyA9PT0gKHRoaXMuX2pmbG93Ll90YXJnZXQuaW5zdGFuY2UgfHwgdGhpcy5famZsb3cuX3RhcmdldC5saW5rKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn0gLSDlvZPliY3ljZXlhYPnp7vliqjnirbmgIFcbiAgICAgKi9cbiAgICBnZXQgX2lzTW92aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcyA9PT0gdGhpcy5famZsb3cuX2dldE1vdmluZ1RhcmdldCgpICYmIHRoaXMuX2pmbG93Ll90YXJnZXQuc3RhdHVzLm1vdmluZ1N0YXRlOyAvLyDnp7vliqjkuobkuYvlkI7miY3og73ooqvlvZPlgZrnp7vliqjnirbmgIFcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn0gIC0g5b2T5YmN5Y2V5YWD56Kw5pKe5qOA5rWL54q25oCBXG4gICAgICovXG4gICAgZ2V0IF9pc0hpdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbaXNoaXRLZXldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtKRmxvd30gIC0gY2FudmFz5LiKIGpmbG93IOWunuS9k1xuICAgICAqL1xuICAgIGdldCBfamZsb3coKSB7XG4gICAgICAgIGlmKHRoaXMuX2pmbG93Um9vdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pmbG93Um9vdDtcbiAgICAgICAgfVxuICAgICAgICBpZighdGhpcy5fYmVsb25ncykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9iZWxvbmdzLnVuaXF1ZU5hbWUgPT09ICdqZmxvdycgPyB0aGlzLl9iZWxvbmdzIDogdGhpcy5fYmVsb25ncy5famZsb3c7XG4gICAgfVxuXG4gICAgc2V0IF9pc0hpdChpc2hpdCkge1xuICAgICAgICBpZih0aGlzW2lzaGl0S2V5XSAhPT0gaXNoaXQpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog6byg5qCH56e75YWl5LqL5Lu2XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV2ZW50IEluc3RhbmNlI21vdXNlZW50ZXJcbiAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0luc3RhbmNlfSBpbnN0YW5jZSAgICAgIC0g56e75YWl55qE5a+56LGhIFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOm8oOagh+enu+WHuuS6i+S7tlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBldmVudCBJbnN0YW5jZSNtb3VzZWxlYXZlXG4gICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtJbnN0YW5jZX0gaW5zdGFuY2UgICAgICAtIOenu+WFpeeahOWvueixoSBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChpc2hpdCA/ICdtb3VzZWVudGVyJzogJ21vdXNlbGVhdmUnICwge1xuICAgICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZTogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgamZsb3c6IHRoaXMuX2pmbG93XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbaXNoaXRLZXldID0gaXNoaXQ7IC8vIHZhbGlkYXRpb24gY291bGQgYmUgY2hlY2tlZCBoZXJlIHN1Y2ggYXMgb25seSBhbGxvd2luZyBub24gbnVtZXJpY2FsIHZhbHVlc1xuICAgIH1cblxuICAgIGdldCBpc0luVmlld0JveCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbaXNJblZpZXdCb3hdO1xuICAgIH1cblxuICAgIHNldCBfaXNJblZpZXdCb3godmFsKSB7XG4gICAgICAgIGNvbnN0IG9sZHZhbCA9IHRoaXNbaXNJblZpZXdCb3hdO1xuICAgICAgICBpZih2YWwgIT09IG9sZHZhbCkge1xuICAgICAgICAgICAgaWYodmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVudGVyVmlld2JveCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTGVhdmVWaWV3Ym94KCk7XG4gICAgICAgICAgICB9IFxuICAgICAgICB9ICAgIFxuICAgICAgICB0aGlzW2lzSW5WaWV3Qm94XSA9IHZhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlvZPoioLngrnnprvlvIDlj6/op4bljLrln5/nmoTlm57osINcbiAgICAgKi9cbiAgICBvbkVudGVyVmlld2JveCgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOW9k+iKgueCueemu+W8gOWPr+inhuWMuuWfn+eahOWbnuiwg1xuICAgICAqL1xuICAgIG9uTGVhdmVWaWV3Ym94KCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5pS55Y+Y5b2T5YmN6YWN572uXG4gICAgICogQHBhcmFtIHtDb25maWdzfSBjb25maWdzIC0gVGhlIHN0cmluZyBjb250YWluaW5nIHR3byBjb21tYS1zZXBhcmF0ZWQgbnVtYmVycy5cbiAgICAgKi9cbiAgICBzZXRDb25maWcoY29uZmlncykge1xuICAgICAgICBPYmplY3Qua2V5cyhjb25maWdzKS5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAgICAgaWYoY29uZmlnc1trXSAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZ3Nba10gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tdID0gY29uZmlnc1trXVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cbiAgICAvKipcbiAgICAgKiDnu5jliLbljZXlhYNcbiAgICAgKiBAcGFyYW0ge0NvbnRleHQyZH0gY3R4IFxuICAgICAqL1xuICAgIHJlbmRlcihjdHgpIHtcbiAgICAgICAgdGhyb3cgJ3JlcXVpcmUgcmVuZGVyIGltcGxlbWVudCdcbiAgICB9XG4gICAgLyoqXG4gICAgICog5Yik5pat5b2T5YmN5Y2V5YWD5piv5ZCm6KKr5ZG95LitXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcG9pbnQgXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0hpdChwb2ludCkge1xuICAgICAgICB0aHJvdyAncmVxdWlyZSBpc0hpdCBpbXBsZW1lbnQnXG4gICAgfVxuICAgIC8qKlxuICAgICAqIOiuoeeul+W9k+WJjeeahOacgOWkp+WkluaOpeefqeW9oueahFxuICAgICAqIEByZXR1cm4ge251bWJlcltdfSBbbGVmdHgsIGxlZnR5LCByaWdodHgsIHJpZ2h0eV1cbiAgICAgKi9cbiAgICBnZXRCb3VuZGluZ1JlY3QoKSB7XG4gICAgICAgIHRocm93ICdyZXF1aXJlIGdldEJvdW5kaW5nUmVjdCBpbXBsZW1lbnQnXG4gICAgfVxuICAgIGNhbGN1bGF0ZUludGVyc2VjdGlvbigpIHtcbiAgICAgICAgdGhyb3cgJ3JlcXVpcmUgY2FsY3VsYXRlSW50ZXJzZWN0aW9uIGltcGxlbWVudCdcbiAgICB9XG4gICAgLyoqXG4gICAgICog6K6h566X5b2T5YmN6L+e57q/5o6l5YWl54K555qE5L2N572uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBpbnRlcnNlY3Rpb24g5Lqk5Y+J54K5XG4gICAgICogQHJldHVybiB7bnVtYmVyfSBpbnRlcnNlY3Rpb25bRElSRUNUSU9OLlRPUF0g5LiKXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBpbnRlcnNlY3Rpb25bRElSRUNUSU9OLkJPVFRPTV0g5LiLXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBpbnRlcnNlY3Rpb25bRElSRUNUSU9OLkxFRlRdIOS4ilxuICAgICAqIEByZXR1cm4ge251bWJlcn0gaW50ZXJzZWN0aW9uW0RJUkVDVElPTi5SSUdIVF0g5Y+zXG4gICAgICovXG4gICAgZ2V0SW50ZXJzZWN0aW9uc0luRm91ckRpbWVuc2lvbigpIHtcbiAgICAgICAgdGhyb3cgJ3JlcXVpcmUgZ2V0SW50ZXJzZWN0aW9uc0luRm91ckRpbWVuc2lvbiBpbXBsZW1lbnQnXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiDojrflj5blvZPliY3miYDlnKjlsYLnuqfnmoTlnZDmoIdcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJbXX0g5Z2Q5qCHXG4gICAgICovXG4gICAgZ2V0Q2VudGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmNob3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOiOt+WPluWuvemrmFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gZGVtZW5zaW9uIOWuvemrmFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gZGVtZW5zaW9uLndpZHRoIOWuvVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gZGVtZW5zaW9uLmhlaWdodCDpq5hcbiAgICAgKi9cbiAgICBnZXRCb3VuZGluZ0RpbWVuc2lvbigpIHtcbiAgICAgICAgY29uc3QgcmVjdCA9IGluc3RhbmNlLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICBsZXQgbWluX3kgPSBJbmZpbml0eTtcbiAgICAgICAgbGV0IG1heF95ID0gLUluZmluaXR5O1xuICAgICAgICBsZXQgbWluX3ggPSBJbmZpbml0eTtcbiAgICAgICAgbGV0IG1heF94ID0gLUluZmluaXR5O1xuICAgICAgICByZWN0LmZvckVhY2gocG9pbnQgPT4ge1xuICAgICAgICAgICAgbWF4X3kgPSBNYXRoLm1heChtYXhfeSwgcG9pbnRbMV0pO1xuICAgICAgICAgICAgbWluX3kgPSBNYXRoLm1pbihtaW5feSwgcG9pbnRbMV0pO1xuICAgICAgICAgICAgbWF4X3ggPSBNYXRoLm1heChtYXhfeCwgcG9pbnRbMF0pO1xuICAgICAgICAgICAgbWluX3ggPSBNYXRoLm1pbihtaW5feCwgcG9pbnRbMF0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlaWdodDogbWF4X3kgLSBtaW5feSxcbiAgICAgICAgICAgIHdpZHRoOiBtYXhfeCAtIG1pbl94LFxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOWGkuazoeS6i+S7tlxuICAgICAqIEBwYXJhbSB7SkZsb3dFdmVudH0gY3VzdG9tRXZlbnQg6Ieq5a6a5LmJ5LqL5Lu2XG4gICAgICovXG4gICAgYnViYmxlRXZlbnQoY3VzdG9tRXZlbnQpe1xuICAgICAgICBjdXN0b21FdmVudC5kZXRhaWwuY3VycmVudFRhcmdldCA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChjdXN0b21FdmVudCk7XG4gICAgICAgIGlmKGN1c3RvbUV2ZW50LmRldGFpbC5idWJibGVzKXtcbiAgICAgICAgICAgIGlmKHRoaXMuX2JlbG9uZ3MuYnViYmxlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWxvbmdzLmJ1YmJsZUV2ZW50KGN1c3RvbUV2ZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmVsb25ncy5kaXNwYXRjaEV2ZW50KGN1c3RvbUV2ZW50KTsgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiDlj43nrpflm57pobXpnaLnmoTlg4/ntKDlnZDmoIdcbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBwb2ludFxuICAgICAqIEByZXR1cm4ge051bWJlcltdfSDkuJbnlYzlnZDmoIdcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVUb1JlYWxXb3JsZChwb2ludCkge1xuICAgICAgICBpZih0aGlzLl9iZWxvbmdzICYmIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9SZWFsV29ybGQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvUmVhbFdvcmxkKHBvaW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhbGN1bGF0ZVRvUmVhbFdvcmxkV2l0aFBvaW50ZXIob3V0cG9pbnQsIGlucG9pbnQpIHtcbiAgICAgICAgaWYodGhpcy5fYmVsb25ncyAmJiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvUmVhbFdvcmxkV2l0aFBvaW50ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9SZWFsV29ybGRXaXRoUG9pbnRlcihvdXRwb2ludCwgaW5wb2ludCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxjdWxhdGVUb1JlYWxXb3JsZFdpdGhTY2FsYXIobGVuZ3RoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2pmbG93LnNjYWxlICogbGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOS7juW9k+WJjeW4g+WxgOS4reWIoOmZpOiZmuaLn+W4g+WxgOiKgueCuVxuICAgICAqL1xuICAgIC8vIHJlbW92ZUZyb21MYXlvdXRTb3VyY2UoKSB7XG4gICAgLy8gICAgIGlmKHRoaXMuX2xheW91dE5vZGUpIHtcbiAgICAvLyAgICAgICAgIHRoaXMuX2xheW91dE5vZGUucmVtb3ZlKCk7XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG5cbiAgICByZWNhbGN1bGF0ZVVwKCkge1xuICAgICAgICBpZih0aGlzLl9iZWxvbmdzKSB7XG4gICAgICAgICAgICB0aGlzLl9iZWxvbmdzLnJlY2FsY3VsYXRlVXAoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIHRoaXMuX2JlbG9uZ3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5zdGFuY2U7IiwiY29uc3QgcXVldWUgPSBbXTtcbmNvbnN0IGNsZWFyUXVldWUgPSBbXTtcbmxldCBxdWV1ZVNldCA9IG5ldyBXZWFrU2V0KCk7XG5cbmNvbnN0IGNoZWNrV29yayA9ICh0YXJnZXQpID0+IHtcbiAgICByZXR1cm4gcXVldWVTZXQuaGFzKHRhcmdldCk7XG59ICBcblxuY29uc3QgZ2V0U3RhY2tQYXRoID0gKG5vZGUpID0+IHtcbiAgICBsZXQgdCA9IG5vZGU7XG4gICAgbGV0IGV4cCA9IDE7XG4gICAgbGV0IHAgPSAnJztcbiAgICB3aGlsZSh0ICYmIHQuX2JlbG9uZ3MpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdC5fYmVsb25ncy5fc3RhY2suZmluZEluZGV4KG4gPT4gbiA9PT0gdCk7XG4gICAgICAgIHAgPSBpZHggKyAocCAmJiAoJy4nICsgcCkpXG4gICAgICAgIHQgPSB0Ll9iZWxvbmdzO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cblxuY29uc3Qgc29ydEJ5UGF0aCA9ICgpID0+IHtcbiAgICBjb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIHF1ZXVlLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgbGV0IGFwYXRoID0gbWFwLmdldChhKTtcbiAgICAgICAgaWYoYXBhdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXBhdGggPSBnZXRTdGFja1BhdGgoYSk7XG4gICAgICAgICAgICBtYXAuc2V0KGEsIGFwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYnBhdGggPSBtYXAuZ2V0KGIpO1xuICAgICAgICBpZihicGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBicGF0aCA9IGdldFN0YWNrUGF0aChiKTtcbiAgICAgICAgICAgIG1hcC5zZXQoYiwgYnBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF9hID0gYXBhdGguc3BsaXQoJy4nKVxuICAgICAgICBjb25zdCBfYiA9IGJwYXRoLnNwbGl0KCcuJylcbiAgICAgICAgaWYoX2EubGVuZ3RoIDwgX2IubGVuZ3RoKSB7IFxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gXG4gICAgICAgIGlmKF9hLmxlbmd0aCA+IF9iLmxlbmd0aCkgeyBcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBcbiAgICAgICAgZm9yKGxldCBpPTA7aTxfYS5sZW5ndGg7aSsrKSB7XG4gICAgICAgICAgICBjb25zdCBfcCA9ICtfYVtpXTtcbiAgICAgICAgICAgIGNvbnN0IF9xID0gK19iW2ldO1xuICAgICAgICAgICAgaWYoX3AgPCBfcSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoX3AgPiBfcSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9KVxufVxuXG5cbmV4cG9ydCBjb25zdCBhZGRDbGVhclNvdXJjZVdvcmsgPSAoamZsb3csIHNvdXJjZSkgPT4ge1xuICAgIGNsZWFyUXVldWUucHVzaChbamZsb3csIHNvdXJjZV0pO1xufVxuXG4vLyB3b3JrIGlzIHN5bmMgZnVuY3Rpb24hIVxuZXhwb3J0IGNvbnN0IGFkZFJlZmxvd1dvcmsgPSAodGFyZ2V0LCBwYXJlbnQpID0+IHtcbiAgICBcbiAgICBpZih0YXJnZXQuZG9SZWNhbGN1bGF0ZSkge1xuICAgICAgICBpZighcXVldWVTZXQuaGFzKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgIHF1ZXVlU2V0LmFkZCh0YXJnZXQpXG4gICAgICAgIH1cbiAgICB9IFxuICAgIGlmKHBhcmVudCAmJiBwYXJlbnQuZG9SZWNhbGN1bGF0ZSAmJiAhcXVldWVTZXQuaGFzKHBhcmVudCkpIHtcbiAgICAgICAgcXVldWUucHVzaChwYXJlbnQpO1xuICAgICAgICBxdWV1ZVNldC5hZGQocGFyZW50KVxuICAgIH1cbiAgIFxuICAgIC8vIGlmKHRhcmdldC5kb1JlY2FsY3VsYXRlKSB7XG4gICAgLy8gICAgIGlmKCFjaGVja1dvcmsodGFyZ2V0KSkge1xuICAgIC8vICAgICAgICAgcXVldWUucHVzaCh0YXJnZXQpO1xuICAgIC8vICAgICAgICAgcXVldWVTZXQuYWRkKHRhcmdldCk7XG4gICAgLy8gICAgIH1cbiAgICAvLyB9ICBcbiAgICAvLyBpZihwYXJlbnQpIHtcbiAgICAvLyAgICAgaWYoY2hlY2tXb3JrKHBhcmVudCkpIHtcbiAgICAvLyAgICAgICAgIGNvbnN0IGlkeCA9IHF1ZXVlLmZpbmRJbmRleChwID0+IHAgPT09IHBhcmVudCk7XG4gICAgLy8gICAgICAgICBxdWV1ZS5zcGxpY2UoaWR4LCAxKTtcbiAgICAvLyAgICAgICAgIHF1ZXVlLnB1c2gocGFyZW50KTtcbiAgICAvLyAgICAgfSBlbHNlIHtcbiAgICAvLyAgICAgICAgIHF1ZXVlLnB1c2gocGFyZW50KTtcbiAgICAvLyAgICAgICAgIHF1ZXVlU2V0LmFkZChwYXJlbnQpO1xuICAgIC8vICAgICB9XG5cbiAgICAvLyB9XG4gICAgZmx1c2goKTtcbn1cbmxldCBpbkZsdXNoID0gZmFsc2U7XG5jb25zdCBmbHVzaCA9ICgpID0+IHtcbiAgICBpZihpbkZsdXNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5GbHVzaCA9IHRydWU7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgY29uc3Qgcm9vdHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHNvcnRCeVBhdGgoKTtcbiAgICAgICAgd2hpbGUocXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgaWYodGFyZ2V0LmRvUmVjYWxjdWxhdGUpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuZG9SZWNhbGN1bGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJvb3RzLmFkZCh0YXJnZXQuX2pmbG93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRhcmdldC53aWR0aCwgdGFyZ2V0LmhlaWdodClcbiAgICAgICAgfVxuICAgICAgICB3aGlsZShjbGVhclF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgW2pmbG93LCBzb3VyY2VdID0gY2xlYXJRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgaWYoIWpmbG93LmdldFJlbmRlck5vZGVCeVNvdXJjZShzb3VyY2UpKXtcbiAgICAgICAgICAgICAgICBqZmxvdy5jbGVhclNvdXJjZShzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLWRpcnR5LS0tZmx1c2gtLS0tLScpXG4gICAgICAgIHF1ZXVlU2V0ID0gbmV3IFdlYWtTZXQoKTtcbiAgICAgICAgaW5GbHVzaCA9IGZhbHNlXG4gICAgICAgIEFycmF5LmZyb20ocm9vdHMpLmZvckVhY2goamZsb3cgPT4ge1xuICAgICAgICAgICAgamZsb3cuX3JlbmRlcigpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0iLCJpbXBvcnQgSW5zdGFuY2UgZnJvbSAnLi9pbnN0YW5jZSc7XG5pbXBvcnQgeyBkb092ZXJsYXAgfSBmcm9tICcuLi91dGlscy9mdW5jdGlvbnMnO1xuaW1wb3J0IHsgYWRkUmVmbG93V29yayB9IGZyb20gJy4uL2RpcnR5LXdvcmsvZGlydHktd29yaydcblxuLyoqXG4gKiDnu53lr7nlrprkvY0g6YWN572u77yMIOe7neWvueWumuS9jeS4jeWPl+W4g+WxgOW9seWTje+8jOebuOWvueS6juW9k+WJjee7hOadpeWumuS9jVxuICogQHR5cGVkZWYge29iamVjdH0gTm9kZX5BYnNvbHV0ZVBvc2l0aW9uIFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRvcCAgICAgICAtIOS4iui3neemu1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGJvdHRvbSAgICAtIOS4i+i3neemu1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHJpZ2h0ICAgICAtIOWPs+i3neemu1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGxlZnQgICAgICAtIOW3pui3neemu1xuICovXG4vKipcbiAqIE5vZGUg6YWN572uXG4gKiBAdHlwZWRlZiB7SW5zdGFuY2V+Q29uZmlnc30gTm9kZX5Db25maWdzIFxuICogQHByb3BlcnR5IHtudW1iZXJbXX0gYW5jaG9yIC0g5Z2Q5qCHXG4gKiBAcHJvcGVydHkge05vZGV+QWJzb2x1dGVQb3NpdGlvbn0gYWJzb2x1dGVQb3NpdGlvbiAtIOe7neWvueWumuS9jeS9jee9rlxuICovXG4vKipcbiAqIOiKgueCueWfuuexu1xuICogQGNvbnN0cnVjdG9yIE5vZGVcbiAqIEBleHRlbmRzIEluc3RhbmNlXG4gKiBAcGFyYW0ge05vZGV+Q29uZmlnc30gY29uZmlncyAtIOiKgueCuemFjee9rlxuICovXG5jbGFzcyBOb2RlIGV4dGVuZHMgSW5zdGFuY2Uge1xuICAgIElOU1RBTkNFX1RZUEUgPSAnTk9ERSdcbiAgICBnZXQgbmV4dFNpYmxpbmcoKSB7XG4gICAgICAgIGlmKCF0aGlzLl9iZWxvbmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFjayA9IHRoaXMuX2JlbG9uZ3MuX3N0YWNrXG4gICAgICAgIGNvbnN0IGlkeCA9IHN0YWNrLmZpbmRJbmRleChzID0+IHMgPT09IHRoaXMpO1xuICAgICAgICBpZihpZHggIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tbaWR4KzFdO1xuICAgICAgICB9IFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzID0ge30pIHtcbiAgICAgICAgc3VwZXIoY29uZmlncyk7XG4gICAgICAgIHRoaXMuX3Jhd0NvbmZpZ3MgPSBjb25maWdzO1xuICAgICAgICAvLyBmb3IgbGF5b3V0XG4gICAgICAgIC8qKiBAbWVtYmVyIHtudW1iZXJbXX0gKi9cbiAgICAgICAgdGhpcy5hbmNob3IgPSAgICAgICAgICAgY29uZmlncy5hbmNob3IgfHwgWzAsIDBdO1xuICAgICAgICAvKiogQG1lbWJlciB7Tm9kZX5BYnNvbHV0ZVBvc2l0aW9ufSAqL1xuICAgICAgICB0aGlzLmFic29sdXRlUG9zaXRpb24gPSBjb25maWdzLmFic29sdXRlUG9zaXRpb247XG4gICAgfVxuXG4gICAgc2V0Q29uZmlnKGNvbmZpZ3MpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoY29uZmlncykuZm9yRWFjaChrID0+IHtcbiAgICAgICAgICAgIGlmKGNvbmZpZ3Nba10gIT09IHVuZGVmaW5lZCAmJiBjb25maWdzW2tdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trXSA9IGNvbmZpZ3Nba11cbiAgICAgICAgICAgICAgICB0aGlzLl9yYXdDb25maWdzW2tdID0gY29uZmlnc1trXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldEFuY2hvclgoeCkge1xuICAgICAgICB0aGlzLmFuY2hvclswXSA9IHg7XG4gICAgfVxuICAgIHNldEFuY2hvclkoeSkge1xuICAgICAgICB0aGlzLmFuY2hvclsxXSA9IHk7XG4gICAgfVxuICAgIHNldEFuY2hvcih4LCB5KSB7XG4gICAgICAgIHRoaXMuYW5jaG9yWzBdID0geDtcbiAgICAgICAgdGhpcy5hbmNob3JbMV0gPSB5O1xuICAgIH1cblxuICAgIGJlZm9yZVJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIGRvT3ZlcmxhcCh0aGlzLl9iZWxvbmdzLl9nZXRWaWV3Qm94KCksIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkpXG4gICAgfVxuXG4gICAgYWRkUmVmbG93V29yaygpIHtcbiAgICAgICAgYWRkUmVmbG93V29yayh0aGlzLCB0aGlzLl9iZWxvbmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlhYvpmoblvZPliY3oioLngrkuXG4gICAgICogQHJldHVybiB7Tm9kZX0g5b2T5YmN6IqC54K555qE5Ymv5pysXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IEMgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICBjb25zdCB0ID0gbmV3IEModGhpcy5fcmF3Q29uZmlncyk7XG4gICAgICAgIHQudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOb2RlOyIsImltcG9ydCBOb2RlIGZyb20gJy4vbm9kZSc7XG5pbXBvcnQgeyBESVJFQ1RJT04gfSBmcm9tICcuLi91dGlscy9jb25zdGFuY2UnO1xuXG5jbGFzcyBHaG9zdE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3MpO1xuICAgIH1cblxuICAgIHJlbmRlcihjdHgpIHt9XG5cbiAgICBpc0hpdChwb2ludCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNhbGN1bGF0ZUludGVyc2VjdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmNob3I7XG4gICAgfVxuXG4gICAgZ2V0Qm91bmRpbmdSZWN0KCkge1xuICAgICAgICBjb25zdCBbeDIsIHkyXSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICByZXR1cm4gW3gyLCB5MiwgeDIsIHkyXVxuICAgIH1cblxuICAgIGdldEJvdW5kaW5nRGltZW5zaW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IDAsIGhlaWdodDogMFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0SW50ZXJzZWN0aW9uc0luRm91ckRpbWVuc2lvbigpIHtcbiAgICAgICAgY29uc3QgW3gyLCB5Ml0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtESVJFQ1RJT04uUklHSFRdOiAgW3gyKzEsIHkyXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uTEVGVF06ICAgW3gyLTEsIHkyXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uQk9UVE9NXTogW3gyLCB5MisxXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uVE9QXTogICAgW3gyLCB5Mi0xXSxcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgR2hvc3ROb2RlOyIsImZ1bmN0aW9uIGdldE1hcE9iamVjdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsYXlvdXROb2RlOiB1bmRlZmluZWQsXG4gICAgICAgIGpmbG93Tm9kZTogdW5kZWZpbmVkLFxuICAgICAgICBqZmxvd2xpbmtzOiBbXSxcbiAgICAgICAgamZsb3dGcm9tTGlua3M6IG5ldyBTZXQoKSxcbiAgICAgICAgamZsb3dUb0xpbmtzOiBuZXcgU2V0KCksXG4gICAgfVxufVxuY2xhc3MgTm9kZVdlYWtNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgZ2V0KHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmdldChzb3VyY2UpO1xuICAgIH1cblxuICAgIHNldChzb3VyY2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gZ2V0TWFwT2JqZWN0KCk7XG4gICAgICAgIHRoaXMuX21hcC5zZXQoc291cmNlLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGhhcyhzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoc291cmNlKTtcbiAgICB9XG5cbiAgICBkZWxldGUoc291cmNlKSB7XG4gICAgICAgIHRoaXMuX21hcC5kZWxldGUoc291cmNlKTtcbiAgICB9XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fbWFwLmNsZWFyKCk7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgTm9kZVdlYWtNYXBNaXhpbiA9IHtcbiAgICBpbml0Tm9kZVdlYWtNYXAoKSB7XG4gICAgICAgIHRoaXMuc291cmNlX0xheW91dF9SZW5kZXJfTm9kZU1hcCA9IG5ldyBOb2RlV2Vha01hcCgpO1xuICAgIH0sXG4gICAgZ2V0UmVuZGVyTm9kZUJ5U291cmNlKHNvdXJjZSkge1xuICAgICAgICBjb25zdCBtYXBwaW5nID0gdGhpcy5zb3VyY2VfTGF5b3V0X1JlbmRlcl9Ob2RlTWFwLmdldChzb3VyY2UpO1xuICAgICAgICBpZihtYXBwaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwcGluZy5qZmxvd05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LCBcbiAgICByZW1vdmVSZW5kZXJOb2RlQnlTb3VyY2Uoc291cmNlKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IHRoaXMuc291cmNlX0xheW91dF9SZW5kZXJfTm9kZU1hcDtcbiAgICAgICAgbGV0IG9iaiA9IG1hcC5nZXQoc291cmNlKTtcbiAgICAgICAgaWYob2JqKSB7XG4gICAgICAgICAgICBvYmouamZsb3dOb2RlID0gdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICAgICAgaWYob2JqLmpmbG93RnJvbUxpbmtzLnNpemUgPT09IDAgJiYgb2JqLmpmbG93VG9MaW5rcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZV9MYXlvdXRfUmVuZGVyX05vZGVNYXAuZGVsZXRlKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldExheW91dE5vZGVCeVNvdXJjZShzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgbWFwcGluZyA9IHRoaXMuc291cmNlX0xheW91dF9SZW5kZXJfTm9kZU1hcC5nZXQoc291cmNlKTtcbiAgICAgICAgaWYobWFwcGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG1hcHBpbmcubGF5b3V0Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgZ2V0U291cmNlUmVuZGVyTWV0YShzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgbWFwID0gdGhpcy5zb3VyY2VfTGF5b3V0X1JlbmRlcl9Ob2RlTWFwO1xuICAgICAgICBjb25zdCBfbWV0YSA9IG1hcC5nZXQoc291cmNlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLl9tZXRhLFxuICAgICAgICAgICAgamZsb3dGcm9tTGlua3M6IEFycmF5LmZyb20oX21ldGEuamZsb3dGcm9tTGlua3MpLFxuICAgICAgICAgICAgamZsb3dUb0xpbmtzOiBBcnJheS5mcm9tKF9tZXRhLmpmbG93VG9MaW5rcyksXG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9nZXRNYXAoc291cmNlKSB7XG4gICAgICAgIGlmKCFzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hcCA9IHRoaXMuc291cmNlX0xheW91dF9SZW5kZXJfTm9kZU1hcDtcbiAgICAgICAgbGV0IG9iajtcbiAgICAgICAgaWYobWFwLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgICAgICBvYmogPSBtYXAuZ2V0KHNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmogPSBtYXAuc2V0KHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9ialxuICAgIH0sXG4gICAgc2V0TGF5b3V0Tm9kZUJ5U291cmNlKHNvdXJjZSwgbGF5b3V0Tm9kZSkge1xuICAgICAgICBsZXQgb2JqID0gdGhpcy5fZ2V0TWFwKHNvdXJjZSk7XG4gICAgICAgIG9iai5sYXlvdXROb2RlID0gbGF5b3V0Tm9kZTtcbiAgICB9LFxuICAgIHNldFJlbmRlck5vZGVCeVNvdXJjZShzb3VyY2UsIGluc3RhbmNlKSB7XG4gICAgICAgIGxldCBvYmogPSB0aGlzLl9nZXRNYXAoc291cmNlKTtcbiAgICAgICAgb2JqLmpmbG93Tm9kZSA9IGluc3RhbmNlO1xuXG4gICAgICAgIGlmKG9iai5qZmxvd0Zyb21MaW5rcy5zaXplID4gMCkge1xuICAgICAgICAgICAgb2JqLmpmbG93RnJvbUxpbmtzLmZvckVhY2gobGluayA9PiB7XG4gICAgICAgICAgICAgICAgbGluay5mcm9tID0gaW5zdGFuY2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZihvYmouamZsb3dUb0xpbmtzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICBvYmouamZsb3dUb0xpbmtzLmZvckVhY2gobGluayA9PiB7XG4gICAgICAgICAgICAgICAgbGluay50bz0gaW5zdGFuY2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYWRkTGlua05vZGVCeVNvdXJjZShzb3VyY2VGcm9tLCBzb3VyY2VUbywgbGluaykge1xuICAgICAgICBsZXQgb2JqID0gdGhpcy5fZ2V0TWFwKHNvdXJjZUZyb20pO1xuICAgICAgICBvYmouamZsb3dGcm9tTGlua3MuYWRkKGxpbmspO1xuXG4gICAgICAgIG9iaiA9IHRoaXMuX2dldE1hcChzb3VyY2VUbyk7XG4gICAgICAgIG9iai5qZmxvd1RvTGlua3MuYWRkKGxpbmspO1xuICAgIH0sXG4gICAgcmVtb3ZlTGlua05vZGVCeVNvdXJjZShzb3VyY2VGcm9tLCBzb3VyY2VUbywgbGluaykge1xuICAgICAgICBjb25zdCBtYXAgPSB0aGlzLnNvdXJjZV9MYXlvdXRfUmVuZGVyX05vZGVNYXA7XG4gICAgICAgIGxldCBvYmogPSBtYXAuZ2V0KHNvdXJjZUZyb20pO1xuICAgICAgICBpZihvYmopIHtcbiAgICAgICAgICAgIG9iai5qZmxvd0Zyb21MaW5rcy5kZWxldGUobGluayk7XG4gICAgICAgICAgICBpZihvYmouamZsb3dGcm9tTGlua3Muc2l6ZSA9PT0gMCAmJiBvYmouamZsb3dUb0xpbmtzLnNpemUgPT09IDAgJiYgIW9iai5qZmxvd05vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZV9MYXlvdXRfUmVuZGVyX05vZGVNYXAuZGVsZXRlKHNvdXJjZUZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9iaiA9IG1hcC5nZXQoc291cmNlVG8pO1xuICAgICAgICBpZihvYmopIHtcbiAgICAgICAgICAgIG9iai5qZmxvd1RvTGlua3MuZGVsZXRlKGxpbmspO1xuICAgICAgICAgICAgaWYob2JqLmpmbG93RnJvbUxpbmtzLnNpemUgPT09IDAgJiYgb2JqLmpmbG93VG9MaW5rcy5zaXplID09PSAwICYmICFvYmouamZsb3dOb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VfTGF5b3V0X1JlbmRlcl9Ob2RlTWFwLmRlbGV0ZShzb3VyY2VUbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNoYW5nZUxpbmtOb2RlQnlTb3VyY2UocHJldlNvdXJjZSwgbmV4dFNvdXJjZSwgbGluaywgZGlyKSB7XG4gICAgICAgIGxldCBvYmogPSB0aGlzLl9nZXRNYXAocHJldlNvdXJjZSk7XG4gICAgICAgIGlmKG9iaikge1xuICAgICAgICAgICAgaWYoZGlyID09PSAnZnJvbScpIHtcbiAgICAgICAgICAgICAgICBvYmouamZsb3dGcm9tTGlua3MuZGVsZXRlKGxpbmspXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkaXIgPT09ICd0bycpIHtcbiAgICAgICAgICAgICAgICBvYmouamZsb3dUb0xpbmtzLmRlbGV0ZShsaW5rKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9iaiA9IHRoaXMuX2dldE1hcChuZXh0U291cmNlKTtcbiAgICAgICAgaWYob2JqKSB7XG4gICAgICAgICAgICBpZihkaXIgPT09ICdmcm9tJykge1xuICAgICAgICAgICAgICAgIG9iai5qZmxvd0Zyb21MaW5rcy5hZGQobGluayk7XG4gICAgICAgICAgICAgICAgaWYob2JqLmpmbG93Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5rLmZyb20gPSBvYmouamZsb3dOb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGRpciA9PT0gJ3RvJykge1xuICAgICAgICAgICAgICAgIG9iai5qZmxvd1RvTGlua3MuYWRkKGxpbmspO1xuICAgICAgICAgICAgICAgIGlmKG9iai5qZmxvd05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluay50byA9IG9iai5qZmxvd05vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjaGFuZ2VOb2RlQnlTb3VyY2UocHJldlNvdXJjZSwgbmV4dFNvdXJjZSwgaW5zdGFuY2UpIHtcbiAgICAgICAgaWYocHJldlNvdXJjZSAmJiBuZXh0U291cmNlKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRvYmogPSB0aGlzLl9nZXRNYXAocHJldlNvdXJjZSk7XG4gICAgICAgICAgICBjb25zdCBuZXdvYmogPSB0aGlzLl9nZXRNYXAobmV4dFNvdXJjZSk7XG4gICAgICAgICAgICBuZXdvYmouamZsb3dOb2RlID0gaW5zdGFuY2U7XG4gICAgICAgICAgICBvbGRvYmouamZsb3dGcm9tTGlua3MuZm9yRWFjaChsaW5rID0+IHtcbiAgICAgICAgICAgICAgICBuZXdvYmouamZsb3dGcm9tTGlua3MuYWRkKGxpbmspO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvbGRvYmouamZsb3dUb0xpbmtzLmZvckVhY2gobGluayA9PiB7XG4gICAgICAgICAgICAgICAgbmV3b2JqLmpmbG93RnJvbUxpbmtzLmFkZChsaW5rKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3b2JqLmpmbG93RnJvbUxpbmtzLmZvckVhY2gobGluayA9PiB7XG4gICAgICAgICAgICAgICAgbGluay5mcm9tID0gaW5zdGFuY2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5ld29iai5qZmxvd1RvTGlua3MuZm9yRWFjaChsaW5rID0+IHtcbiAgICAgICAgICAgICAgICBsaW5rLnRvID0gaW5zdGFuY2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlX0xheW91dF9SZW5kZXJfTm9kZU1hcC5kZWxldGUocHJldlNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5vZGVXZWFrTWFwO1xuXG4iLCIvLyBpbXBvcnQgeyBOb2RlUGxhY2Vob2xkZXIgfSBmcm9tICcuL25vZGUtcGxhY2Vob2xkZXInO1xuLyoqXG4gKiDnu5jlm77moIhcbiAqIEBleHRlbmRzIEFycmF5XG4gKi9cbmNsYXNzIEluc3RhbmNlU3RhY2sgZXh0ZW5kcyBBcnJheSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRIaXQgPSBudWxsO1xuICAgIH1cblxuICAgIGZvckVhY2goY2IpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmZvckVhY2goKGksIGlkeCkgPT4ge1xuICAgICAgICAgICAgaWYoaS50eXBlID09PSAnTk9ERV9QTEFDRUhPTERFUicpIHsgXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2IoaSwgaWR4KTtcbiAgICAgICAgfSlcbiAgICB9XG4gICAgZmlsdGVyKGNiKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHN1cGVyLmZpbHRlcigoaSwgaWR4KSA9PiB7XG4gICAgICAgICAgICBpZihpLnR5cGUgPT09ICdOT0RFX1BMQUNFSE9MREVSJykgeyBcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2IoaSwgaWR4KTtcbiAgICAgICAgfSkpXG4gICAgfVxuICAgIHNsaWNlKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShzdXBlci5maWx0ZXIoKGksIGlkeCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGkudHlwZSAhPT0gJ05PREVfUExBQ0VIT0xERVInXG4gICAgICAgIH0pKVxuICAgIH1cbiAgICBzdXBlcmZpbHRlcihjYikge1xuICAgICAgICByZXR1cm4gc3VwZXIuZmlsdGVyKChpLCBpZHgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjYihpLCBpZHgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog57uY5Yi25b2T5YmN5qCIXG4gICAgICogQHBhcmFtIHtDb250ZXh0MmR9IGN0eCAtIGNhbnZhcyBjb250ZXh0MmRcbiAgICAgKi9cbiAgICByZW5kZXIoY3R4LCBjb25kaXRpb24pIHtcbiAgICAgICAgbGV0IG1vdmluZ1RhcmdldDtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGluc3RhbmNlID0+IHtcbiAgICAgICAgICAgIGlmKGluc3RhbmNlLl9pc01vdmluZykge1xuICAgICAgICAgICAgICAgIG1vdmluZ1RhcmdldCA9IGluc3RhbmNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGluc3RhbmNlLnZpc2libGUgJiYgKCFjb25kaXRpb24gfHwgY29uZGl0aW9uKGluc3RhbmNlKSkpIHtcbiAgICAgICAgICAgICAgICBpZihpbnN0YW5jZS5iZWZvcmVSZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoIWluc3RhbmNlLmJlZm9yZVJlbmRlcihjdHgpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLnJlbmRlcihjdHgpO1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZihtb3ZpbmdUYXJnZXQpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAvLyBpZihtb3ZpbmdUYXJnZXQucmVmbG93ICYmICFtb3ZpbmdUYXJnZXQuX3JlZmxvd2VkKSB7XG4gICAgICAgICAgICAvLyAgICAgbW92aW5nVGFyZ2V0LnJlZmxvdygpO1xuICAgICAgICAgICAgLy8gICAgIG1vdmluZ1RhcmdldC5fcmVmbG93ZWQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgbW92aW5nVGFyZ2V0LnJlbmRlcihjdHgpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0SGl0U3RhdHVzKCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50SGl0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGkgPT4ge1xuICAgICAgICAgICAgaWYoaS5fc3RhY2spIHtcbiAgICAgICAgICAgICAgICBpLl9zdGFjay5yZXNldEhpdFN0YXR1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaS5faXNIaXQgPSBmYWxzZTtcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDnorDmkp7lr7nosaHov4fmu6TmnaHku7ZcbiAgICAgKiBAbmFtZSBJbnN0YW5jZVN0YWNrfkluc3RhbmNlRmlsdGVyXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtJbnN0YW5jZX0gaW5zdGFuY2UgLSDlvZPliY3lr7nosaFcbiAgICAqL1xuICAgIC8qKlxuICAgICAqIOeisOaSnuajgOa1i1xuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHBvaW50IC0g56Kw5pKe54K5XG4gICAgICogQHBhcmFtIHtJbnN0YW5jZVN0YWNrfkluc3RhbmNlRmlsdGVyfSBjb25kaXRpb24gLSDnorDmkp7lr7nosaHov4fmu6TmnaHku7ZcbiAgICAgKiBAcmV0dXJuIHtJbnN0YW5jZX1cbiAgICAgKi9cbiAgICBjaGVja0hpdChwb2ludCwgY29uZGl0aW9uLCBjdXJyZW50Q29uc3RyYWludCl7XG4gICAgICAgIGxldCBpID0gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZShpID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpc1tpXTtcbiAgICAgICAgICAgIGlmKGluc3RhbmNlLnR5cGUgPT09ICdOT0RFX1BMQUNFSE9MREVSJykgeyBcbiAgICAgICAgICAgICAgICBpLS1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGluc3RhbmNlLnZpc2libGUgJiYgIWluc3RhbmNlLmlnbm9yZUhpdCkge1xuICAgICAgICAgICAgICAgIGlmKGNvbmRpdGlvbiAmJiBjb25kaXRpb24oaW5zdGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGktLVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoY3VycmVudENvbnN0cmFpbnQgJiYgIWN1cnJlbnRDb25zdHJhaW50KGluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICBpLS1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNoaXQgPSBpbnN0YW5jZS5pc0hpdChwb2ludCwgY29uZGl0aW9uKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihpc2hpdCkge1xuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLl9jdXJyZW50SGl0ICE9PSBpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5fY3VycmVudEhpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRIaXQuX2lzSGl0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5faXNIaXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpdCA9IGluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBpc2hpdCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNoaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLl9pc0hpdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGktLVxuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuX2N1cnJlbnRIaXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRIaXQuX2lzSGl0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3VycmVudEhpdCA9IG51bGw7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDojrflj5blvZPliY3lsYLmoIjnmoTmnIDlsI/lpJbmjqXnn6nlvaJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJbXVtdfSAtIOWkluaOpeefqeW9ouWdkOagh1xuICAgICAqL1xuICAgIGdldEJvdW5kaW5nUmVjdFBvaW50cygpIHtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaChpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICBpZihpbnN0YW5jZS52aXNpYmxlICYmICFpbnN0YW5jZS5hYnNvbHV0ZVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IGluc3RhbmNlLmdldEJvdW5kaW5nUmVjdCgpXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goW3JlY3RbMF0sIHJlY3RbMV1dKTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChbcmVjdFsyXSwgcmVjdFszXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDojrflj5blvZPliY3lsYLmoIjnmoTplJrngrnnn6nlvaJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJbXVtdfSAtIOmUmueCueefqeW9ouWdkOagh1xuICAgICAqL1xuICAgIGdldEFuY2hvclJlY3RQb2ludHMoKSB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2goaW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgaWYoaW5zdGFuY2UudmlzaWJsZSAmJiAhaW5zdGFuY2UuYWJzb2x1dGVQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGluc3RhbmNlLmFuY2hvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5zdGFuY2VTdGFjaztcbiIsImltcG9ydCBJbnN0YW5jZVN0YWNrIGZyb20gJy4vc3RhY2snO1xuaW1wb3J0IHsgYWRkUmVmbG93V29yayB9IGZyb20gJy4uL2RpcnR5LXdvcmsvZGlydHktd29yayc7XG5cbi8vIGltcG9ydCB7IHNldFVuaXF1ZUlkLCBnZXRVbmlxdWVJZCB9IGZyb20gJy4uL3V0aWxzL2Z1bmN0aW9ucyc7XG4vKipcbiAqIOWvueixoeagiCBtaXhpbiDnlKjkuo7mlrnkvr/mjqfliLboioLngrnmoIjlkozov57nur/moIhcbiAqXG4gKiBAbWl4aW5cbiAqL1xuY29uc3QgU3RhY2tNaXhpbiA9IHtcbiAgICAvKiogQHByb3BlcnR5IHtOb2RlW119ICAgICAgICAgIC0g5a+56LGh5pWw57uEICovXG4gICAgaW5zdGFuY2VzOiBbXSxcbiAgICAvKiogQHByb3BlcnR5IHtCYXNlTGlua1tdfSAgICAgIC0g6L+e57q/5pWw57uEICovXG4gICAgbGlua3M6IFtdLFxuICAgIC8qKiBAcHJvcGVydHkge0luc3RhbmNlU3RhY2t9ICAgICAgIC0g5a+56LGh5qCIICovXG4gICAgX3N0YWNrOiBudWxsLFxuICAgIC8qKiBAcHJvcGVydHkge0luc3RhbmNlU3RhY2t9ICAgICAgIC0g6L+e57q/5qCIICovXG4gICAgX2xpbmtTdGFjazogbnVsbCxcbiAgICAvKipcbiAgICAgKiDliJ3lp4vljJblr7nosaHmoIhcbiAgICAgKiBAcGFyYW0ge0pmbG93Q29uZmlnc30gY29uZmlncyAtIOmFjee9rlxuICAgICAqL1xuICAgIGluaXRTdGFjayh7IGRhdGEgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMuX3N0YWNrID0gbmV3IEluc3RhbmNlU3RhY2soKTtcbiAgICAgICAgdGhpcy5fbGlua1N0YWNrID0gbmV3IEluc3RhbmNlU3RhY2soKTtcbiAgICAgICAgaWYoIWRhdGEpIHJldHVybjtcbiAgICAgICAgdGhpcy5pbnN0YW5jZXMgPSBkYXRhLmluc3RhbmNlcztcbiAgICAgICAgdGhpcy5saW5rcyA9IGRhdGEubGlua3M7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VzLmZvckVhY2goaSA9PiB7IFxuICAgICAgICAgICAgdGhpcy5fc3RhY2sucHVzaChpKTtcbiAgICAgICAgICAgIGkuX2JlbG9uZ3MgPSB0aGlzO1xuICAgICAgICB9KVxuICAgICAgICB0aGlzLmxpbmtzLmZvckVhY2goKGxpbmspID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmtTdGFjay5wdXNoKGxpbmspO1xuICAgICAgICAgICAgbGluay5fYmVsb25ncyA9IHRoaXM7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICog5Yqg5YWl6IqC54K55a+56LGhXG4gICAgICogQHBhcmFtIHtOb2RlfSBpbnN0YW5jZSAtIOiKgueCueWvueixoVxuICAgICAqL1xuICAgIGFkZFRvU3RhY2soaW5zdGFuY2UpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0tYWRkVG9TdGFjay0tLS0nLCBpbnN0YW5jZSlcbiAgICAgICAgaW5zdGFuY2UuX2JlbG9uZ3MgPSB0aGlzO1xuICAgICAgICB0aGlzLl9zdGFjay5wdXNoKGluc3RhbmNlKTtcbiAgICAgICAgYWRkUmVmbG93V29yayhpbnN0YW5jZSwgdGhpcyk7XG4gICAgICAgIC8vIHRoaXMucmVjYWxjdWxhdGUoKVxuICAgIH0sXG5cbiAgICBpbnNlcnRUb1N0YWNrQmVmb3JlKGluc3RhbmNlLCBhbmNob3JOb2RlKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLWluc2VydFRvU3RhY2tCZWZvcmUtLS0tJylcbiAgICAgICAgaWYoaW5zdGFuY2UuX2JlbG9uZ3MpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLl9iZWxvbmdzLnJlbW92ZUZyb21TdGFjayhpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UuX2JlbG9uZ3MgPSB0aGlzO1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9zdGFjay5maW5kSW5kZXgocyA9PiBzID09PSBhbmNob3JOb2RlKTtcbiAgICAgICAgaWYoaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhY2suc3BsaWNlKGlkeCwgMCwgaW5zdGFuY2UpXG4gICAgICAgICAgICBhZGRSZWZsb3dXb3JrKGluc3RhbmNlLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkVG9TdGFjayhpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIOabv+aNouWvueixoVxuICAgICAqIEBwYXJhbSB7SW5zdGFuY2V9IHRhcmdldCAtIOiiq+abv+aNoueahOWvueixoVxuICAgICAqIEBwYXJhbSB7SW5zdGFuY2V9IGluc3RhbmNlIC0g5pu/5o2i5a+56LGhXG4gICAgICovXG4gICAgcmVwbGFjZUZyb21TdGFjayh0YXJnZXQsIGluc3RhbmNlKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fc3RhY2suZmluZEluZGV4KGkgPT4gaSA9PT0gdGFyZ2V0KTtcbiAgICAgICAgdGhpcy5fc3RhY2suc3BsaWNlKGluZGV4LCAxLCBpbnN0YW5jZSk7XG4gICAgICAgIHRhcmdldC5fYmVsb25ncyA9IG51bGw7XG4gICAgICAgIGluc3RhbmNlLl9iZWxvbmdzID0gdGhpcztcbiAgICAgICAgLy8gdGhpcy5yZWNhbGN1bGF0ZSgpXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiDliqDlhaXov57nur/lr7nosaFcbiAgICAgKiBAcGFyYW0ge0Jhc2VMaW5rfSBpbnN0YW5jZSAtIOi/nue6v+WvueixoVxuICAgICAqL1xuICAgIGFkZFRvTGlua1N0YWNrKGxpbmspIHtcbiAgICAgICAgaWYodGhpcy5fbGlua1N0YWNrLmZpbmQobCA9PiBsID09PSBsaW5rKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxpbmsuX2JlbG9uZ3MgPSB0aGlzO1xuICAgICAgICB0aGlzLl9saW5rU3RhY2sucHVzaChsaW5rKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIOWIoOmZpOiKgueCueWvueixoVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0IC0g6IqC54K55a+56LGhXG4gICAgICovXG4gICAgcmVtb3ZlRnJvbVN0YWNrKHRhcmdldCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLS1yZW1vdmVGcm9tU3RhY2stLS0tJylcbiAgICAgICAgLy8gdGhpcy5yZW1vdmVMaW5rT25JbnN0YW5jZSh0YXJnZXQpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX3N0YWNrLmZpbmRJbmRleChpID0+IGkgPT09IHRhcmdldCk7XG4gICAgICAgIGlmKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhY2suc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGFkZFJlZmxvd1dvcmsodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcy5yZWNhbGN1bGF0ZSgpXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiDliKDpmaTov57nur/lr7nosaFcbiAgICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldCAtIOi/nue6v+WvueixoVxuICAgICAqL1xuICAgIHJlbW92ZUZyb21MaW5rU3RhY2sodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbGlua1N0YWNrLmZpbmRJbmRleChpID0+IGkgPT09IHRhcmdldCk7XG4gICAgICAgIGlmKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fbGlua1N0YWNrLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgXG4gICAgZW1wdHlMaW5rKCkge1xuICAgICAgICB0aGlzLl9saW5rU3RhY2sgPSBuZXcgSW5zdGFuY2VTdGFjaygpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICog6YeN572u5b2T5YmN5qCI5Lit5a+56LGh55qE5L2N572uXG4gICAgICovXG4gICAgcmVzZXRDaGlsZHJlblBvc2l0aW9uKCkge1xuICAgICAgICB0aGlzLl9zdGFjay5mb3JFYWNoKGkgPT4ge1xuICAgICAgICAgICAgaS5hbmNob3IgPSBbMCwwXVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgYWRkSW5zdGFuY2VUb0xpbmsodGFyZ2V0TGluaywgaW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5hZGRUb1N0YWNrKGluc3RhbmNlKTtcbiAgICAgICAgY29uc3QgeyBmcm9tLCB0byB9ID0gdGFyZ2V0TGluaztcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9saW5rU3RhY2suZmluZEluZGV4KGwgPT4gbCA9PT0gdGFyZ2V0TGluayk7XG4gICAgICAgIGNvbnN0IF9jb25zdHVjdG9yID0gdGFyZ2V0TGluay5fX3Byb3RvX18uY29uc3RydWN0b3I7XG4gICAgICAgIGNvbnN0IGwxID0gbmV3IF9jb25zdHVjdG9yKHtcbiAgICAgICAgICAgIGZyb20sIFxuICAgICAgICAgICAgdG86IGluc3RhbmNlLFxuICAgICAgICB9KTtcbiAgICAgICAgbDEuX2JlbG9uZ3MgPSB0aGlzO1xuICAgICAgICBjb25zdCBsMiA9IG5ldyBfY29uc3R1Y3Rvcih7XG4gICAgICAgICAgICBmcm9tOiBpbnN0YW5jZSwgXG4gICAgICAgICAgICB0byxcbiAgICAgICAgfSk7XG4gICAgICAgIGwyLl9iZWxvbmdzID0gdGhpcztcblxuICAgICAgICB0aGlzLl9saW5rU3RhY2suc3BsaWNlKGluZGV4LCAxLCBsMSwgbDIpO1xuICAgIH0sXG4gICAgXG4gICAgLyoqXG4gICAgICog5b6q546v5b2T5YmN5qCI5Lit6IqC54K5XG4gICAgICogQHByb3BlcnR5IHtzdGFja0l0ZXJhdG9yQ2FsbGJhY2t9IOW+queOr+iuv+mXruagiOS4reavj+S4quiKgueCuVxuICAgICAqL1xuICAgIGludGVyYXRlTm9kZVN0YWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX3N0YWNrLmZvckVhY2goaW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2soaW5zdGFuY2UpO1xuICAgICAgICB9KVxuICAgIH0gICBcbiAgICAvKipcbiAgICAqIOW+queOr+iuv+mXruagiOS4reavj+S4quiKgueCuVxuICAgICogQGNhbGxiYWNrIHN0YWNrSXRlcmF0b3JDYWxsYmFja1xuICAgICogQHBhcmFtIHtOb2RlfSBpbnN0YW5jZSDmoIjkuK3oioLngrlcbiAgICAqL1xufVxuXG5leHBvcnQgZGVmYXVsdCBTdGFja01peGluOyIsIi8qKlxuICogTGF5b3V0IG1peGluIOmFjee9rlxuICogQHR5cGVkZWYge09iamVjdH0gTGF5b3V0TWl4aW5+TGF5b3V0Q29uZmlnc1xuICogQHByb3BlcnR5IHtMYXlvdXR9IGxheW91dCAgICAgICAgICAgICAtIOW4g+WxgOWvueixoSBcbiAqL1xuLyoqXG4gKiDluIPlsYAgbWl4aW4g55So5LqO5rOo5YaM5ZKM5pa55L6/5o6n5Yi25biD5bGAXG4gKlxuICogQG1peGluXG4gKi9cbmNvbnN0IExheW91dE1peGluID0ge1xuICAgIC8qKiBAcHJvcGVydHkge0xheW91dH0gICAgICAtIOW4g+WxgOWvueixoSAqL1xuICAgIF9sYXlvdXQ6IG51bGwsXG4gICAgLyoqXG4gICAgICog5Yid5aeL5YyW5biD5bGAXG4gICAgICogQHBhcmFtIHtMYXlvdXRNaXhpbn5MYXlvdXRDb25maWdzfSBjb25maWdzIC0g6YWN572uXG4gICAgICovXG4gICAgaW5pdExheW91dChjb25maWdzID0ge30pIHtcbiAgICAgICAgdGhpcy5fbGF5b3V0ID0gY29uZmlncy5sYXlvdXQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiDku47lvZPliY3lsYLlh7rlj5HvvIzlkJHkuIrlsYLpgJLlvZLph43mjpJcbiAgICAgKi9cbiAgICByZWNhbGN1bGF0ZVVwKCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLXJlY2FsY3VsYXRlVXAtLS0tJylcbiAgICAgICAgbGV0IGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaWYodGhpcy5nZXRCb3VuZGluZ0RpbWVuc2lvbikge1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aDogd29sZCwgaGVpZ2h0OiBob2xkIH0gPSB0aGlzLmdldEJvdW5kaW5nRGltZW5zaW9uKCk7XG4gICAgICAgICAgICBpZih0aGlzLnJlc2V0Q2hpbGRyZW5Qb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRDaGlsZHJlblBvc2l0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLl9nZXRCb3VuZGluZ0dyb3VwUmVjdCl7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0Qm91bmRpbmdHcm91cFJlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVmbG93KCk7XG4gICAgICAgICAgICBpZih0aGlzLl9nZXRCb3VuZGluZ0dyb3VwUmVjdCl7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0Qm91bmRpbmdHcm91cFJlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGg6IHdub3csIGhlaWdodDogaG5vdyB9ID0gdGhpcy5nZXRCb3VuZGluZ0RpbWVuc2lvbigpO1xuICAgICAgICAgICAgZGlydHkgPSAod29sZCAhPT0gd25vdyB8fCBob2xkICE9PSBobm93KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWZsb3coKTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLl9iZWxvbmdzICYmIGRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLl9iZWxvbmdzLnJlY2FsY3VsYXRlVXAoKTtcbiAgICAgICAgfVxuICAgICAgICBpZighZGlydHkgfHwgdGhpcy5fYmVsb25ncz8udW5pcXVlTmFtZSA9PT0gJ2pmbG93Jykge1xuICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZURvd24oKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVjYWxjdWxhdGVEb3duKCkge1xuICAgICAgICBpZih0aGlzLl9sYXlvdXQgJiYgdGhpcy5fbGF5b3V0LnJlZmxvd0FmdGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXQucmVmbG93QWZ0ZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhY2suZm9yRWFjaChpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICBpZihpbnN0YW5jZS5yZWNhbGN1bGF0ZURvd24pIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5yZWNhbGN1bGF0ZURvd24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIOmHjeaWsOiuoeeul+W4g+WxgO+8jOebuOW9k+S6jua1j+iniOWZqOmHjOmdoumHjeaOku+8jOW5tumHjeeul+W9k+WJjeW4g+WxgOS4i+eahOacgOWwj+WkluaOpeefqeW9olxuICAgICAqL1xuICAgIHJlY2FsY3VsYXRlKCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLXJlY2FsY3VsYXRlLS0tLScpXG4gICAgICAgIHRoaXMucmVmbG93KCk7XG4gICAgICAgIGlmKHRoaXMuX2dldEJvdW5kaW5nR3JvdXBSZWN0KXtcbiAgICAgICAgICAgIHRoaXMuX2dldEJvdW5kaW5nR3JvdXBSZWN0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIOW4g+WxgOmdmeaAgeajgOafpVxuICAgICAqIEBwYXJhbSB7SW5zdGFuY2V9IGluc3RhbmNlIC0g5qOA5p+l5Y2V5YWDXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gLSDmo4Dmn6Xnu5PmnpwgXG4gICAgICovXG4gICAgc3RhdGljQ2hlY2soaW5zdGFuY2UpIHtcbiAgICAgICAgaWYodGhpcy5fbGF5b3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0LnN0YXRpY0NoZWNrKGluc3RhbmNlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiDph43mlrDorqHnrpfluIPlsYDvvIznm7jlvZPkuo7mtY/op4jlmajph4zpnaLph43mjpJcbiAgICAgKi9cbiAgICByZWZsb3coKSB7XG4gICAgICAgIGlmKHRoaXMuX2xheW91dCkge1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0LnJlZmxvdyh0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IExheW91dE1peGluOyIsIi8qKlxuICog5raI5oGvIG1peGluIOeUqOS6jue7mUpmbG935Lyg6YCS5raI5oGvXG4gKlxuICogQG1peGluXG4gKi9cbmNvbnN0IE1lc3NhZ2VNaXhpbiA9IHtcbiAgICBfbWVzc2FnZTogbnVsbCxcbiAgICAvKipcbiAgICAgKiDlj5HpgIHmtojmga9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbXNnIC0g5raI5oGv5L2TXG4gICAgICovXG4gICAgc2VuZE1lc3NhZ2UobXNnKSB7XG4gICAgICAgIHRoaXMuX21lc3NhZ2UgPSBtc2c7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiDmjqXmlLbmtojmga9cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG1zZyAtIOa2iOaBr+S9k1xuICAgICAqL1xuICAgIGNvbnN1bWVNZXNzYWdlKCkge1xuICAgICAgICBjb25zdCBtc2cgPSB0aGlzLl9tZXNzYWdlO1xuICAgICAgICB0aGlzLl9tZXNzYWdlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG1zZztcbiAgICB9LFxuICAgIHJlYWRNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVzc2FnZTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1lc3NhZ2VNaXhpbjsiLCJcbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBpbml0QW5pbWUoKSB7XG4gICAgICAgIHRoaXMuYW5pbWVfcXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5fX2FuaW1lQ2xvY2tfXyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gdGhpcy5hbmltZWNsb2NrID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyB0aGlzLmZyYW1lUmVuZGVyZWQgPSBmYWxzZTtcbiAgICB9LFxuICAgIC8vIHNldEFuaW1lQ2xvY2sodGltZSkge1xuICAgIC8vICAgICBpZih0aW1lICE9PSB0aGlzLmFuaW1lY2xvY2spIHtcbiAgICAvLyAgICAgICAgIHRoaXMuZnJhbWVSZW5kZXJlZCA9IGZhbHNlO1xuICAgIC8vICAgICAgICAgdGhpcy5hbmltZWNsb2NrID0gdGltZTtcbiAgICAvLyAgICAgfVxuICAgIC8vIH0sXG5cbiAgICAvLyBoYXNBbmltZUFuZEZyYW1lUmVuZGVyZWQoKSB7XG4gICAgLy8gICAgIHJldHVybiB0aGlzLmFuaW1lX3F1ZXVlLmxlbmd0aCAmJiB0aGlzLmZyYW1lUmVuZGVyZWQ7XG4gICAgLy8gfSxcblxuICAgIC8vIHNldEZyYW1lUmVuZGVyZWQoKSB7XG4gICAgLy8gICAgIGlmKHRoaXMuYW5pbWVfcXVldWUubGVuZ3RoKSB7XG4gICAgLy8gICAgICAgICB0aGlzLmZyYW1lUmVuZGVyZWQgPSB0cnVlO1xuICAgIC8vICAgICB9XG4gICAgLy8gfSxcblxuICAgIHJlcXVlc3RKRmxvd0FuaW1lKGZyYW1lQ2FsbEJhY2spIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuZW5xdWV1ZUFuaW1lKGZyYW1lQ2FsbEJhY2spO1xuICAgICAgICB0aGlzLl9ydW5BbmltZSgpO1xuICAgICAgICByZXR1cm4gbWV0YTtcbiAgICB9LFxuXG4gICAgZW5xdWV1ZUFuaW1lKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGFuaW1lTWV0YSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgIGNhbmNlbDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbEFuaW1lKGFuaW1lTWV0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmltZV9xdWV1ZS5wdXNoKGFuaW1lTWV0YSk7XG4gICAgICAgIHJldHVybiBhbmltZU1ldGE7XG4gICAgfSxcblxuICAgIF9jYW5jZWxBbmltZShtZXRhKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuYW5pbWVfcXVldWUuZmluZEluZGV4KG0gPT4gbSA9PT0gbWV0YSk7XG4gICAgICAgIH5pZHggJiYgdGhpcy5hbmltZV9xdWV1ZS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgXG4gICAgfSxcblxuICAgIHJ1bkFuaW1lKCkge1xuICAgICAgICB0aGlzLl9ydW5BbmltZSgpO1xuICAgICAgICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fcnVuQW5pbWUuYmluZCh0aGlzKSk7XG4gICAgfSxcbiAgICBfcnVuQW5pbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmFuaW1lX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcnVuQW5pbWUoKTtcbiAgICAgICAgICAgIH0pICBcbiAgICAgICAgICAgIC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9ydW5BbmltZS5iaW5kKHRoaXMpKVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJ1bkFuaW1lRnJhbWUoKSB7XG4gICAgICAgIHRoaXMuYW5pbWVfcXVldWUuZm9yRWFjaChtZXRhID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBpZighbWV0YS5zdGFydCkge1xuICAgICAgICAgICAgICAgIG1ldGEuc3RhcnQgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbGFwc2VkID0gdGltZXN0YW1wIC0gbWV0YS5zdGFydDtcbiAgICAgICAgICAgIG1ldGEuY2FsbGJhY2soZWxhcHNlZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBjcmVhdGVDYW52YXMgfSBmcm9tICcuLi91dGlscy9jYW52YXMnO1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIC8vIOS8oOWFpeS4gOS4quWIq+eahCBjb250ZXh0MmQg5p2l57uY5Yi2XG4gICAgY2FwdHVyZU1hcCh3cmFwcGVyLCB7XG4gICAgICAgIHBhZGRpbmcgPSAwLFxuICAgICAgICBwbGFjZW1lbnQgPSAnbm9ybWFsJyxcbiAgICB9KSB7XG5cbiAgICAgICAgdGhpcy5fZ2V0Qm91bmRpbmdHcm91cFJlY3QoKTtcbiAgICAgICAgY29uc3QgeyBcbiAgICAgICAgICAgIHdpZHRoOiBwX3dpZHRoLCBcbiAgICAgICAgICAgIGhlaWdodDogcF9oZWlnaHQsIFxuICAgICAgICAgICAgeDogcF94LCBcbiAgICAgICAgICAgIHk6IHBfeSBcbiAgICAgICAgfSA9IHRoaXMuYm91bmRpbmdfYm94O1xuICAgICAgICBsZXQgbWluaU1hcCA9IHRoaXMubWluaU1hcDtcbiAgICAgICAgaWYoIW1pbmlNYXApIHtcbiAgICAgICAgICAgIHRoaXMubWluaU1hcCA9IGNyZWF0ZUNhbnZhcyh3cmFwcGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHJhd193aWR0aCxcbiAgICAgICAgICAgICAgICByYXdfaGVpZ2h0LFxuICAgICAgICAgICAgfSA9IHRoaXMubWluaU1hcDtcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignem9vbXBhbicsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJNYXAgJiYgdGhpcy5fcmVuZGVyTWFwKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgbGV0IHByZXNzRG93biA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5taW5pTWFwLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB7IG9mZnNldFgsIG9mZnNldFksIGRlbHRhWCwgZGVsdGFZIH0gPSBldmVudFxuICAgICAgICAgICAgICAgIHByZXNzRG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25Nb3ZlTWFwICYmIHRoaXMuX29uTW92ZU1hcChvZmZzZXRYLCBvZmZzZXRZKSAgXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdGhpcy5taW5pTWFwLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB7IG9mZnNldFgsIG9mZnNldFksIGRlbHRhWCwgZGVsdGFZIH0gPSBldmVudFxuICAgICAgICAgICAgICAgIGlmKHByZXNzRG93bikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbk1vdmVNYXAgJiYgdGhpcy5fb25Nb3ZlTWFwKG9mZnNldFgsIG9mZnNldFkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKG9mZnNldFkgPCA1IHx8IG9mZnNldFggPCA1IHx8IG9mZnNldFggPiB3aWR0aC01IHx8IG9mZnNldFkgPiBoZWlnaHQtNSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVzc0Rvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdGhpcy5taW5pTWFwLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcHJlc3NEb3duID0gZmFsc2U7XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBjb25zdCBjYWhlQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBjYWhlQ2FudmFzLndpZHRoID0gcmF3X3dpZHRoO1xuICAgICAgICAgICAgY2FoZUNhbnZhcy5oZWlnaHQgPSByYXdfaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5jYWNoZU1pbmltYXBDdHggPSBjYWhlQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgcmF3X3dpZHRoLFxuICAgICAgICAgICAgcmF3X2hlaWdodCxcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBzY2FsZSxcbiAgICAgICAgICAgIGN0eFxuICAgICAgICB9ID0gdGhpcy5taW5pTWFwXG4gICAgICAgIGNvbnN0IHBhZDIgPSBwYWRkaW5nICogMjtcbiAgICAgICAgY29uc3QgcGFkID0gcGFkZGluZztcbiAgICAgICAgY29uc3QgcjEgPSAod2lkdGggLSBwYWQyKSAvIHBfd2lkdGg7XG4gICAgICAgIGNvbnN0IHIyID0gKGhlaWdodCAtIHBhZDIpIC8gcF9oZWlnaHQ7XG4gICAgICAgIGNvbnN0IHIgPSBNYXRoLm1pbihyMSwgcjIpO1xuICAgICAgICBcbiAgICAgICAgbGV0IG1feCA9IDA7XG4gICAgICAgIGxldCBtX3kgPSAwO1xuXG4gICAgICAgIGlmKHBsYWNlbWVudCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIG1feSA9IChoZWlnaHQgLSBwX2hlaWdodCAqIHIpIC8gMiAtIHBfeSAqIHI7XG4gICAgICAgICAgICBtX3ggPSAod2lkdGggLSBwX3dpZHRoICogcikgLyAyIC0gcF94ICogcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKHIxIDwgcjIpIHtcbiAgICAgICAgICAgICAgICBtX3kgPSAoaGVpZ2h0IC0gcF9oZWlnaHQgKiByKSAvIDIgLSBwX3kgKiByO1xuICAgICAgICAgICAgICAgIG1feCA9IHBhZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbV94ID0gKHdpZHRoIC0gcF93aWR0aCAqIHIpIC8gMiAtIHBfeCAqIHI7XG4gICAgICAgICAgICAgICAgbV95ID0gcGFkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhY2hlY3R4ID0gdGhpcy5jYWNoZU1pbmltYXBDdHg7XG4gICAgICAgIGNhY2hlY3R4LnNldFRyYW5zZm9ybSgpO1xuICAgICAgICBjYWNoZWN0eC5jbGVhclJlY3QoMCwgMCwgcmF3X3dpZHRoLCByYXdfaGVpZ2h0KTtcbiAgICAgICAgY2FjaGVjdHguc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICAgICAgY2FjaGVjdHgudHJhbnNmb3JtKHIsIDAsIDAsIHIsIG1feCwgbV95KTtcbiAgICAgICAgLy8gY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuICAgICAgICAvLyBjdHguYXJjKCAzMCwgMzAsIDEwMCwgMCwgMipNYXRoLlBJKTtcbiAgICAgICAgLy8gY3R4LmZpbGwoKVxuICAgICAgICAvLyBkZWJ1Z2dlclxuICAgICAgICBjb25zdCBiciA9IFswLDAsMCwwXVxuICAgICAgICBpZih0aGlzLk5vZGVSZW5kZXJUb3ApIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmtTdGFjay5yZW5kZXIoY2FjaGVjdHgsIChsaW5rKSA9PiB7IGxpbmsuaXNJblZpZXdCb3goYnIpOyByZXR1cm4gdHJ1ZTsgfSk7XG4gICAgICAgICAgICAvLyB0aGlzLl9saW5rU3RhY2sucmVuZGVyKGNhY2hlY3R4KTtcbiAgICAgICAgICAgIHRoaXMuX3N0YWNrLnJlbmRlcihjYWNoZWN0eCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFjay5yZW5kZXIoY2FjaGVjdHgpO1xuICAgICAgICAgICAgdGhpcy5fbGlua1N0YWNrLnJlbmRlcihjYWNoZWN0eCwgKGxpbmspID0+IHsgbGluay5pc0luVmlld0JveChicik7IHJldHVybiB0cnVlOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBfY2FjaGVNYXBJbWFnZURhdGEgPSBjYWNoZWN0eC5nZXRJbWFnZURhdGEoMCwgMCxyYXdfd2lkdGgsIHJhd19oZWlnaHQpO1xuICAgICAgICB0aGlzLl9yZW5kZXJNYXAgPSAoKSA9PiB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCByYXdfd2lkdGgsIHJhd19oZWlnaHQpO1xuICAgICAgICAgICAgLy8gaWYoIWkpIHtcbiAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgICAgICAgICAgY3R4LnB1dEltYWdlRGF0YShfY2FjaGVNYXBJbWFnZURhdGEsIDAsIDApO1xuICAgICAgICAgICAgY3R4LnRyYW5zZm9ybShyLCAwLCAwLCByLCBtX3gsIG1feSk7XG4gICAgICAgICAgICBjb25zdCBbeCwgeSwgdCwgZF0gPSB0aGlzLl9nZXRWaWV3Qm94KCk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgucmVjdCh4LCB5LCAgdC14LCBkLXkpO1xuICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgY3R4LnJlY3QoMCwgMCwgcmF3X3dpZHRoLCByYXdfaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5jbGlwKFwiZXZlbm9kZFwiKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDAuNCknO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHJhd193aWR0aCwgcmF3X2hlaWdodCk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbmRlck1hcCgpO1xuXG4gICAgICAgIHRoaXMuX29uTW92ZU1hcCA9IChvZmZzZXRYLCBvZmZzZXRZKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbeCwgeSwgdCwgZF0gPSB0aGlzLl9nZXRWaWV3Qm94KCk7XG4gICAgICAgICAgICAvLyBjb25zdCB3ID0gdC14O1xuICAgICAgICAgICAgY29uc3QgYSA9ICh0LXgpLzIgKyB4O1xuICAgICAgICAgICAgY29uc3QgYiA9IChkLXkpLzIgKyB5O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBwID0gW2EgKiByICsgbV94LCBiICogciArIG1feV1cbiAgICAgICAgICAgIHRoaXMuX3JlY2FsY3VsYXRlUG9zaXRpb24oKHBbMF0gLSBvZmZzZXRYKS8gciAqIHRoaXMuc2NhbGUsIChwWzFdIC0gb2Zmc2V0WSkvIHIgKiB0aGlzLnNjYWxlKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcy5fcmVuZGVyKGN0eCk7XG4gICAgfVxuXG5cbn0iLCIvKipcbiAqIEpGbG93IOaKm+WHuuS6i+S7tlxuICogQGV4dGVuZHMgQ3VzdG9tRXZlbnRcbiAqIEBwcm9wZXJ0eSB7RXZlbnR9ICBvcmlnaW5FdmVudCAgICAgIC0g5Y6f5aeL5LqL5Lu2XG4gKiBAcHJvcGVydHkge0luc3RhbmNlfSB0YXJnZXQgICAgICAgICAtIOS6i+S7tuinpuWPkeWvueixoVxuICogQHByb3BlcnR5IHtKRmxvd30gamZsb3cgICAgICAgICAgICAgLSBKRmxvdyDlr7nosaFcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYnViYmxlcyAgICAgICAgIC0g5YaS5rOh5qCH6K+GXG4gKi9cbmNsYXNzIEpGbG93RXZlbnQgZXh0ZW5kcyBDdXN0b21FdmVudHtcbiAgICBjb25zdHJ1Y3RvcihldmVudCwgY29uZmlncyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGRldGFpbCA9IHtcbiAgICAgICAgICAgIC4uLmNvbmZpZ3MsXG4gICAgICAgICAgICBvcmlnaW5FdmVudDogY29uZmlncy5ldmVudCxcbiAgICAgICAgICAgIHRhcmdldDogY29uZmlncy50YXJnZXQsXG4gICAgICAgICAgICBqZmxvdzogY29uZmlncy5qZmxvdyxcbiAgICAgICAgICAgIGJ1YmJsZXM6IGNvbmZpZ3MuYnViYmxlcyB8fCBmYWxzZSwgICAgXG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZXZlbnQsIHtcbiAgICAgICAgICAgIGRldGFpbFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEpGbG93RXZlbnQ7IiwiaW1wb3J0IEpGbG93RXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmV4cG9ydCBjbGFzcyBTY3JvbGxCYXIge1xuICAgIGNvbnN0cnVjdG9yKGRpciwgY29uZmlncyA9IHt9KSB7XG4gICAgICAgIHRoaXMuYW5jaG9yID0gWzAsMF07XG4gICAgICAgIHRoaXMud2lkdGggPSBjb25maWdzLmJhcldpZHRoIHx8IDQ7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gY29uZmlncy5iYXJXaWR0aCB8fCA0OyAgXG4gICAgICAgIHRoaXMuYmFyTWFyZ2luWCA9IDA7XG4gICAgICAgIHRoaXMuYmFyTWFyZ2luWSA9IDBcbiAgICAgICAgdGhpcy5kaXIgPSBkaXI7XG4gICAgICAgIHRoaXMucGxhaW5Db2xvciA9IGNvbmZpZ3MucGxhaW5Db2xvciB8fCAncmdiYSgwLCAwLCAwLCAwLjE1KSc7XG4gICAgICAgIHRoaXMuZm9jdXNDb2xvciA9IGNvbmZpZ3MuZm9jdXNDb2xvciB8fCAncmdiYSgwLCAwLCAwLCAwLjI1KSc7XG4gICAgICAgIHRoaXMuaXNGb2N1cyA9IGZhbHNlO1xuICAgIH1cbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIGNvbnN0IFt4LCB5XSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGlmKHRoaXMuZGlyID09PSAneCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIGNvbnN0IGN5ID0geSArIHJhZGl1cztcbiAgICAgICAgICAgIGNvbnN0IGJ5ID0geSArIHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgcmMgPSB4ICsgdGhpcy53aWR0aCAtIHRoaXMuYmFyTWFyZ2luWCoyIC0gcmFkaXVzO1xuICAgICAgICAgICAgY29uc3QgbGMgPSB4ICsgdGhpcy5iYXJNYXJnaW5YICsgcmFkaXVzXG4gICAgICAgICAgICBjdHgubW92ZVRvKGxjLCBieSk7XG4gICAgICAgICAgICBjdHguYXJjKGxjLCBjeSwgcmFkaXVzLCBNYXRoLlBJLzIsIE1hdGguUEkvMiozKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocmMsIHkpO1xuICAgICAgICAgICAgY3R4LmFyYyhyYywgY3ksIHJhZGl1cywgIC1NYXRoLlBJLzIsIE1hdGguUEkvMik7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gIFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmFkaXVzID0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgICAgICBjb25zdCB0YyA9IHkgKyB0aGlzLmJhck1hcmdpblkgKyByYWRpdXM7XG4gICAgICAgICAgICBjb25zdCBiYyA9IHkgKyB0aGlzLmhlaWdodCAtIHRoaXMuYmFyTWFyZ2luWSoyIC0gcmFkaXVzXG4gICAgICAgICAgICBjb25zdCBjeCA9IHggKyByYWRpdXM7XG4gICAgICAgICAgICBjb25zdCByeCA9IHggKyB0aGlzLndpZHRoO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCB0Yyk7XG4gICAgICAgICAgICBjdHguYXJjKGN4LCB0YywgcmFkaXVzLCAtTWF0aC5QSSwgMCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHJ4LCBiYyk7XG4gICAgICAgICAgICBjdHguYXJjKGN4LCBiYywgcmFkaXVzLCAwLCBNYXRoLlBJKTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gICBjdHgucmVjdChcbiAgICAgICAgICAgICAgICAvLyB4ICsgdGhpcy5iYXJNYXJnaW5YLFxuICAgICAgICAgICAgICAgIC8vIHkgKyB0aGlzLmJhck1hcmdpblksXG4gICAgICAgICAgICAgICAgLy8gdGhpcy53aWR0aCAtIHRoaXMuYmFyTWFyZ2luWCoyLFxuICAgICAgICAgICAgICAgIC8vIHRoaXMuaGVpZ2h0IC0gdGhpcy5iYXJNYXJnaW5ZKjIpO1xuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmlzRm9jdXMgPyB0aGlzLmZvY3VzQ29sb3IgOiB0aGlzLnBsYWluQ29sb3I7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGlzSGl0KHBvaW50KSB7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aDtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICByZXR1cm4gcG9pbnRbMF0gPiBhbmNob3JbMF0gLSA1XG4gICAgICAgICAgICAmJiBwb2ludFswXSA8IGFuY2hvclswXSArIHcgKyA1XG4gICAgICAgICAgICAmJiBwb2ludFsxXSA+IGFuY2hvclsxXSAtIDVcbiAgICAgICAgICAgICYmIHBvaW50WzFdIDwgYW5jaG9yWzFdICsgaCArIDU7XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGluaXRTY3JvbGxCYXIoY29uZmlncyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGJhckNvbG9yLFxuICAgICAgICAgICAgYmFyRm9jdXNDb2xvcixcbiAgICAgICAgICAgIGJhck1hcmdpblgsXG4gICAgICAgICAgICBiYXJNYXJnaW5ZLFxuICAgICAgICAgICAgYmFyV2lkdGgsXG4gICAgICAgIH0gPSBjb25maWdzO1xuICAgICAgICB0aGlzLl9zY3JvbGxiYXJFbmFibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zY3JvbGxiYXJYID0gbmV3IFNjcm9sbEJhcigneCcsIHtcbiAgICAgICAgICAgIHBsYWluQ29sb3I6IGJhckNvbG9yLFxuICAgICAgICAgICAgZm9jdXNDb2xvcjogYmFyRm9jdXNDb2xvcixcbiAgICAgICAgICAgIGJhcldpZHRoLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWC5iYXJNYXJnaW5YID0gYmFyTWFyZ2luWCB8fCA1O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWSA9IG5ldyBTY3JvbGxCYXIoJ3knLCB7XG4gICAgICAgICAgICBwbGFpbkNvbG9yOiBiYXJDb2xvcixcbiAgICAgICAgICAgIGZvY3VzQ29sb3I6IGJhckZvY3VzQ29sb3IsXG4gICAgICAgICAgICBiYXJXaWR0aFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWS5iYXJNYXJnaW5ZID0gYmFyTWFyZ2luWSB8fCA1O1xuXG4gICAgICAgIHRoaXMuX3Njcm9sbEJhclN0YXR1cyA9IHtcbiAgICAgICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICAgICAgIHhzY2FsZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgeXNjYWxlOiB1bmRlZmluZWQsXG5cbiAgICAgICAgICAgIGJhckluaXRYOiAwLFxuICAgICAgICAgICAgYmFySW5pdFk6IDAsXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9wWm9vbXBhbldhdGNoID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignem9vbXBhbicsICgpID0+IHtcbiAgICAgICAgICAgIGlmKCF0aGlzLnN0b3Bab29tcGFuV2F0Y2gpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEJhck9uUGFuQW5kWm9vbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgdGhpcy5zY3JvbGxCYXJPblBhbkFuZFpvb20oKTtcblxuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZLCBjbGllbnRYLCBjbGllbnRZIH0gPSBlO1xuICAgICAgICAgICAgdGhpcy5vblNjcm9sbGJhclByZXNzU3RhcnQob2Zmc2V0WCwgb2Zmc2V0WSwgY2xpZW50WCwgY2xpZW50WSlcbiAgICAgICAgfSlcbiAgICB9LFxuICAgIGNoZWNrU2Nyb2xsRHJhZ2dpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxCYXJTdGF0dXMgJiYgdGhpcy5fc2Nyb2xsQmFyU3RhdHVzLmRyYWdnaW5nO1xuICAgIH0sXG4gICAgb25TY3JvbGxiYXJQcmVzc1N0YXJ0KG9mZnNldFgsIG9mZnNldFksIGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICAgICAgdGhpcy5zdG9wWm9vbXBhbldhdGNoID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeGhpdCA9IHRoaXMuX3Njcm9sbGJhclguaXNIaXQoW29mZnNldFgsIG9mZnNldFldKTtcbiAgICAgICAgaWYoeGhpdCkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9zY3JvbGxCYXJTdGF0dXMsIHtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMuX3Njcm9sbGJhclgsXG4gICAgICAgICAgICAgICAgYmFyU3RhcnRYOiB0aGlzLl9zY3JvbGxiYXJYLmFuY2hvclswXSxcbiAgICAgICAgICAgICAgICBiYXJJbml0WDogY2xpZW50WCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHloaXQgPSB0aGlzLl9zY3JvbGxiYXJZLmlzSGl0KFtvZmZzZXRYLCBvZmZzZXRZXSk7XG4gICAgICAgIGlmKHloaXQpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fc2Nyb2xsQmFyU3RhdHVzLCB7XG4gICAgICAgICAgICAgICAgZHJhZ2dpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLl9zY3JvbGxiYXJZLFxuICAgICAgICAgICAgICAgIGJhclN0YXJ0WTogdGhpcy5fc2Nyb2xsYmFyWS5hbmNob3JbMV0sXG4gICAgICAgICAgICAgICAgYmFySW5pdFk6IGNsaWVudFksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmID0gKGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZLCBjbGllbnRYLCBjbGllbnRZIH0gPSBlO1xuICAgICAgICAgICAgdGhpcy5vbkRyYWdnaW5nU2Nyb2xsYmFyKG9mZnNldFgsIG9mZnNldFksIGNsaWVudFgsIGNsaWVudFkpXG4gICAgICAgICAgICBcbiAgICAgICAgfSkuYmluZCh0aGlzKTtcbiAgICAgICAgXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgZik7XG4gICAgICAgIGNvbnN0IHQgPSAoZSA9PiB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3Njcm9sbEJhclN0YXR1cywge1xuICAgICAgICAgICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgICAgICAgICAgeDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBmKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHQpO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdCk7XG4gICAgICAgICAgICB0aGlzLnN0b3Bab29tcGFuV2F0Y2ggPSBmYWxzZTtcbiAgICAgICAgfSkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdCwge1xuICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCB0LCB7XG4gICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgIH0pXG4gICAgfSxcbiAgICBvbkRyYWdnaW5nU2Nyb2xsYmFyKG9mZnNldFgsIG9mZnNldFksIGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICAgICAgaWYodGhpcy5fc2Nyb2xsYmFyRW5hYmxlICYmIHRoaXMuX3Njcm9sbEJhclN0YXR1cy5kcmFnZ2luZykge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICBiYXJJbml0WCxcbiAgICAgICAgICAgICAgICBiYXJTdGFydFgsXG4gICAgICAgICAgICAgICAgYmFySW5pdFksXG4gICAgICAgICAgICAgICAgYmFyU3RhcnRZLFxuICAgICAgICAgICAgICAgIHhzY2FsZSxcbiAgICAgICAgICAgICAgICB5c2NhbGUsXG4gICAgICAgICAgICAgICAgc2NvbGxiYXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgc2NvbGxiYXJXaWR0aCxcbiAgICAgICAgICAgICAgICByZWFsUixcbiAgICAgICAgICAgICAgICByZWFsTCxcbiAgICAgICAgICAgICAgICByZWFsVCxcbiAgICAgICAgICAgICAgICByZWFsQixcbiAgICAgICAgICAgIH0gPSB0aGlzLl9zY3JvbGxCYXJTdGF0dXM7XG4gICAgICAgICAgICBjb25zdCB7IGFjdHVhbF93aWR0aCwgYWN0dWFsX2hlaWdodCB9ID0gdGhpcy5jYW52YXNNZXRhO1xuICAgICAgICAgICAgY29uc3QgeyBcbiAgICAgICAgICAgICAgICB4OiBwX3gsIFxuICAgICAgICAgICAgICAgIHk6IHBfeSBcbiAgICAgICAgICAgIH0gPSB0aGlzLmJvdW5kaW5nX2JveDtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRhcmdldC5kaXIsIHJlYWxULCByZWFsQilcbiAgICAgICAgICAgIGxldCBkZWx0YVggPSAwLCBkZWx0YVkgPSAwO1xuICAgICAgICAgICAgaWYodGFyZ2V0LmRpciA9PT0gJ3gnKSB7XG4gICAgICAgICAgICAgICAgZGVsdGFYID0gY2xpZW50WCAtIGJhckluaXRYO1xuICAgICAgICAgICAgICAgIGNvbnN0IHhuZXcgPSBiYXJTdGFydFggKyBkZWx0YVg7XG4gICAgICAgICAgICAgICAgY29uc3QgcSA9IHRhcmdldC5hbmNob3JbMF0gPSBNYXRoLm1heChNYXRoLm1pbih4bmV3LCBhY3R1YWxfd2lkdGggLSBzY29sbGJhcldpZHRoKSwgMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF0aW9JblggPSBxIC8gYWN0dWFsX3dpZHRoO1xuICAgICAgICAgICAgICAgIC8vIGNvbnN0IHkgPSAocmVhbEIgLSAocmVhbEIgLSByZWFsVCkgKiByYXRpb0luWSkgKiB0aGlzLnNjYWxlXG4gICAgICAgICAgICAgICAgY29uc3QgcmF0aW9YID0gKHJlYWxSIC0gcmVhbEwpICogcmF0aW9JblggKyByZWFsTFxuICAgICAgICAgICAgICAgIGNvbnN0IHggPSAocF94IC0gcmF0aW9YKSAqIHRoaXMuc2NhbGVcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMucG9zaXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WDogeCAtIHBfeCAqIHRoaXMuc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHRhcmdldC5kaXIgPT09ICd5JykgeyAgICAgIFxuICAgICAgICAgICAgICAgIGRlbHRhWSA9IGNsaWVudFkgLSBiYXJJbml0WTtcbiAgICAgICAgICAgICAgICBjb25zdCB5bmV3ID0gYmFyU3RhcnRZICsgZGVsdGFZO1xuICAgICAgICAgICAgICAgIGNvbnN0IHEgPSB0YXJnZXQuYW5jaG9yWzFdID0gTWF0aC5tYXgoTWF0aC5taW4oeW5ldywgYWN0dWFsX2hlaWdodCAtIHNjb2xsYmFySGVpZ2h0KSwgMCk7O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhdGlvSW5ZID0gcSAvIGFjdHVhbF9oZWlnaHQ7XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgeSA9IChyZWFsQiAtIChyZWFsQiAtIHJlYWxUKSAqIHJhdGlvSW5ZKSAqIHRoaXMuc2NhbGVcbiAgICAgICAgICAgICAgICBjb25zdCByYXRpb1kgPSAocmVhbEIgLSByZWFsVCkgKiByYXRpb0luWSArIHJlYWxUXG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IChwX3kgLSByYXRpb1kpICogdGhpcy5zY2FsZVxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5wb3NpdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRZOiB5IC0gcF95ICogdGhpcy5zY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnem9vbXBhbicsIHtcbiAgICAgICAgICAgICAgICBkZWx0YVgsXG4gICAgICAgICAgICAgICAgZGVsdGFZXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGNoZWNrU2Nyb2xsQmFySG92ZXIob2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgICAgICBpZih0aGlzLl9zY3JvbGxiYXJFbmFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHhoaXQgPSB0aGlzLl9zY3JvbGxiYXJYLmlzSGl0KFtvZmZzZXRYLCBvZmZzZXRZXSk7XG4gICAgICAgICAgICBpZih4aGl0KSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5fc2Nyb2xsQmFyU3RhdHVzLmhvdmVyVGFyZ2V0ID0gdGhpcy5fc2Nyb2xsYmFyWDtcbiAgICAgICAgICAgICAgICBpZighdGhpcy5fc2Nyb2xsYmFyWC5pc0ZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbGJhclguaXNGb2N1cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeWhpdCA9IHRoaXMuX3Njcm9sbGJhclkuaXNIaXQoW29mZnNldFgsIG9mZnNldFldKTtcbiAgICAgICAgICAgIGlmKHloaXQpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9zY3JvbGxCYXJTdGF0dXMuaG92ZXJUYXJnZXQgPSB0aGlzLl9zY3JvbGxiYXJZO1xuICAgICAgICAgICAgICAgIGlmKCF0aGlzLl9zY3JvbGxiYXJZLmlzRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWS5pc0ZvY3VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgcmVzZXRTY3JvbGxCYXJIb3ZlcigpIHtcbiAgICAgICAgaWYodGhpcy5fc2Nyb2xsYmFyRW5hYmxlKSB7XG4gICAgICAgICAgICBpZih0aGlzLl9zY3JvbGxiYXJZLmlzRm9jdXMgfHwgdGhpcy5fc2Nyb2xsYmFyWC5pc0ZvY3VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWS5pc0ZvY3VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWC5pc0ZvY3VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBfZ2V0U2Nyb2xsVmlld0JvdW5kaW5nYm94KCkge1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gMTIwO1xuICAgICAgICBjb25zdCB7IFxuICAgICAgICAgICAgd2lkdGg6IHBfd2lkdGgsIFxuICAgICAgICAgICAgaGVpZ2h0OiBwX2hlaWdodCwgXG4gICAgICAgICAgICB4OiBwX3gsIFxuICAgICAgICAgICAgeTogcF95IFxuICAgICAgICB9ID0gdGhpcy5ib3VuZGluZ19ib3g7XG4gICAgICAgIGNvbnN0IHAgPSBwYWRkaW5nO1xuICAgICAgICBjb25zdCBwMiA9IHBhZGRpbmcgKiAyO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IHBfd2lkdGggKyBwMixcbiAgICAgICAgICAgIGhlaWdodDogcF9oZWlnaHQgKyBwMixcbiAgICAgICAgICAgIHg6IHBfeCAtIHAsXG4gICAgICAgICAgICB5OiBwX3kgLSBwXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNjcm9sbEJhck9uUGFuQW5kWm9vbSgpIHtcbiAgICAgICAgaWYoIXRoaXMuX3Njcm9sbGJhckVuYWJsZSB8fCB0aGlzLl9zY3JvbGxCYXJTdGF0dXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IFxuICAgICAgICAgICAgd2lkdGg6IHBfd2lkdGgsIFxuICAgICAgICAgICAgaGVpZ2h0OiBwX2hlaWdodCwgXG4gICAgICAgICAgICB4OiBwX3gsIFxuICAgICAgICAgICAgeTogcF95IFxuICAgICAgICB9ID0gdGhpcy5fZ2V0U2Nyb2xsVmlld0JvdW5kaW5nYm94KCk7XG4gICAgICAgIFxuICAgICAgICBsZXQgW3gsIHksIHIsIGJdID0gdGhpcy5fZ2V0Vmlld0JveCgpO1xuICAgICAgICBjb25zdCByZWFsUiA9IE1hdGgubWF4KHIsIHBfeCArIHBfd2lkdGgpO1xuICAgICAgICBjb25zdCByZWFsTCA9IE1hdGgubWluKHgsIHBfeCk7XG4gICAgICAgIGNvbnN0IHJlYWxUID0gTWF0aC5taW4oeSwgcF95KTtcbiAgICAgICAgY29uc3QgcmVhbEIgPSBNYXRoLm1heChiLCBwX3kgKyBwX2hlaWdodCk7XG4gICAgICAgIGNvbnN0IHZ3ID0gciAtIHg7XG4gICAgICAgIGNvbnN0IHZoID0gYiAtIHk7XG4gICAgICAgIGNvbnN0IHsgYWN0dWFsX3dpZHRoLCBhY3R1YWxfaGVpZ2h0IH0gPSB0aGlzLmNhbnZhc01ldGE7XG4gICAgICAgIGNvbnN0IHhzY2FsZSA9IHZ3IC8gKHJlYWxSIC0gcmVhbEwpXG4gICAgICAgIGlmKHhzY2FsZSA8IDEpICB7XG4gICAgICAgICAgICBjb25zdCBzY29sbGJhcldpZHRoID0gYWN0dWFsX3dpZHRoICogeHNjYWxlO1xuICAgICAgICAgICAgY29uc3QgYW5jaG9yWCA9ICh4IC0gcmVhbEwpICogeHNjYWxlICogdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbGJhclguYW5jaG9yID0gW2FuY2hvclgsIGFjdHVhbF9oZWlnaHQgLSAxMF07XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxiYXJYLndpZHRoID0gc2NvbGxiYXJXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEJhclN0YXR1cy5zY29sbGJhcldpZHRoID0gc2NvbGxiYXJXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgeXNjYWxlID0gdmggLyAocmVhbEIgLSByZWFsVCk7XG4gICAgICAgIGlmKHlzY2FsZSA8IDEpICB7XG4gICAgICAgICAgICBjb25zdCBzY29sbGJhckhlaWdodCA9IGFjdHVhbF9oZWlnaHQgKiB5c2NhbGU7XG4gICAgICAgICAgICBjb25zdCBhbmNob3JZID0gKHkgLSByZWFsVCkgKiB5c2NhbGUgKiB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWS5hbmNob3IgPSBbYWN0dWFsX3dpZHRoIC0gMTAsIGFuY2hvclldO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWS5oZWlnaHQgPSBzY29sbGJhckhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEJhclN0YXR1cy5zY29sbGJhckhlaWdodCA9IHNjb2xsYmFySGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9zY3JvbGxCYXJTdGF0dXMsIHtcbiAgICAgICAgICAgIHlzY2FsZSxcbiAgICAgICAgICAgIHhzY2FsZSxcbiAgICAgICAgICAgIHJlYWxSLFxuICAgICAgICAgICAgcmVhbEwsXG4gICAgICAgICAgICByZWFsVCxcbiAgICAgICAgICAgIHJlYWxCLFxuICAgICAgICB9KVxuICAgICAgICBcbiAgICB9LFxuICAgIHJlc2V0U2NvbGxCYXJTdGF0dXMoKSB7XG4gICAgICAgIGlmKHRoaXMuX3Njcm9sbGJhckVuYWJsZSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9zY3JvbGxCYXJTdGF0dXMsIHtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICAgICAgICAgIHg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyU2Nyb2xsQmFyKGN0eCkge1xuICAgICAgICBpZih0aGlzLl9zY3JvbGxiYXJFbmFibGUpIHtcbiAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIGN0eC5zY2FsZSh0aGlzLmRwciwgdGhpcy5kcHIpO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHhzY2FsZSxcbiAgICAgICAgICAgICAgICB5c2NhbGVcbiAgICAgICAgICAgIH0gPSB0aGlzLl9zY3JvbGxCYXJTdGF0dXM7XG4gICAgICAgICAgICBpZih4c2NhbGUgPCAxKSAge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbGJhclgucmVuZGVyKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih5c2NhbGUgPCAxKSAge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbGJhclkucmVuZGVyKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59IiwiXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICB0b2dnbGVSZW5kZXIodmFsKSB7XG4gICAgICAgIHRoaXMuX19yZW5kZXJzdG9wX18gPSAhdmFsO1xuICAgIH0sXG4gICAgaW5pdFNjaGVkdWxlKCkge1xuICAgICAgICB0aGlzLl9fY2xvY2tfXyA9IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIHNjaGVkdWxlUmVuZGVyKGNhbGxiYWNrKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgodGltZXN0YW1wKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc0ZpcnN0VGltZSA9IHRoaXMuX19jbG9ja19fICE9PSB0aW1lc3RhbXBcbiAgICAgICAgICAgIGlmKCF0aGlzLl9fcmVuZGVyc3RvcF9fICYmIGlzRmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3JlbmRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh0aW1lc3RhbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fX2Nsb2NrX18gPSB0aW1lc3RhbXA7XG4gICAgICAgIH0pXG4gICAgfVxufSIsIi8qKlxuICog5LqL5Lu25aSE55CG5Ye95pWwXG4gKiBAbmFtZSBFdmVudEFkYXB0ZXJ+SGFuZGxlclxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIOWOn+eUn+S6i+S7tlxuICogQHBhcmFtIHtKRmxvd30gamZsb3cgLSDlvZPliY1qZmxvdyDlr7nosaFcbiAqL1xuXG4vKipcbiAqIEV2ZW50QWRhcHRlciDlr7nosaEgcGx1Z2luIOmFjee9rlxuICogQHR5cGVkZWYge09iamVjdH0gRXZlbnRBZGFwdGVyfnBsdWdpbkRlZlxuICogQHByb3BlcnR5IHtPYmplY3R9IGNhbnZhcyAtIGNhbnZhcyDnm7jlhbPnmoTkuovku7ZcbiAqIEBwcm9wZXJ0eSB7RXZlbnRBZGFwdGVyfkhhbmRsZXJ9IGNhbnZhcy5ldmVudE5hbWUgLSDms6jlhowgY2FudmFzIOS4iueahOS6i+S7tuWkhOeQhlxuICogQHByb3BlcnR5IHtPYmplY3R9IGRvY3VtZW50IC0gZG9jdW1lbnQg55u45YWz55qE5LqL5Lu2XG4gKiBAcHJvcGVydHkge0V2ZW50QWRhcHRlcn5IYW5kbGVyfSBkb2N1bWVudC5ldmVudE5hbWUgLSDms6jlhowgZG9jdW1lbnQg5LiK55qE5LqL5Lu25aSE55CGXG4gKi9cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdFBsdWdpbigpIHtcbiAgICBsZXQgX21vdXNlU3RhdHVzID0ge1xuICAgICAgICAvLyB4OiB1bmRlZmluZWQsXG4gICAgICAgIC8vIHk6IHVuZGVmaW5lZCxcbiAgICAgICAgLy8gZW5hYmxlQ2xpY2s6IGZhbHNlLFxuICAgICAgICBwb2ludGVyRG93bjogZmFsc2UsXG4gICAgICAgIGRpcnR5OiBmYWxzZSxcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2FudmFzOiB7XG4gICAgICAgICAgICB3aGVlbDogZnVuY3Rpb24gKGV2ZW50LCBqZmxvdykge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgbGV0IHsgb2Zmc2V0WCwgb2Zmc2V0WSwgZGVsdGFYLCBkZWx0YVkgfSA9IGV2ZW50XG4gICAgICAgICAgICAgICAgaWYoZXZlbnQuY3RybEtleSkgeyBcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFZID0gLWRlbHRhWTtcbiAgICAgICAgICAgICAgICAgICAgamZsb3cuem9vbUhhbmRsZXIob2Zmc2V0WCwgb2Zmc2V0WSwgZGVsdGFYLCBkZWx0YVksIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBqZmxvdy5wYW5IYW5kbGVyKC1kZWx0YVgsIC1kZWx0YVksIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9pbnRlcmRvd246IGZ1bmN0aW9uIChldmVudCwgamZsb3cpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFksIGRlbHRhWSwgYnV0dG9uIH0gPSBldmVudFxuICAgICAgICAgICAgICAgIGlmKGJ1dHRvbiAhPT0gMCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIF9tb3VzZVN0YXR1cy5wb2ludGVyRG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgamZsb3cucHJlc3NTdGFydEhhbmRsZXIob2Zmc2V0WCwgb2Zmc2V0WSwgZXZlbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvaW50ZXJtb3ZlOiBmdW5jdGlvbiAoZXZlbnQsIGpmbG93KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudFxuICAgICAgICAgICAgICAgIGlmKF9tb3VzZVN0YXR1cy5wb2ludGVyRG93bikge1xuICAgICAgICAgICAgICAgICAgICBfbW91c2VTdGF0dXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqZmxvdy5wcmVzc01vdmVIYW5kbGVyKG9mZnNldFgsIG9mZnNldFksIGV2ZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb2ludGVydXA6IGZ1bmN0aW9uIChldmVudCwgamZsb3cpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIC8vIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyBBTFdBWVMgRU5BQkxFIFBST1BBR0FUSU9OIFxuICAgICAgICAgICAgICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSwgYnV0dG9uIH0gPSBldmVudFxuICAgICAgICAgICAgICAgIGlmKGJ1dHRvbiAhPT0gMCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmKF9tb3VzZVN0YXR1cy5wb2ludGVyRG93biAmJiBfbW91c2VTdGF0dXMuZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgX21vdXNlU3RhdHVzLnBvaW50ZXJEb3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIF9tb3VzZVN0YXR1cy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBqZmxvdy5wcmVzc1VwSGFubGRlcihmYWxzZSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZXh0bWVudTogZnVuY3Rpb24gKGV2ZW50LCBqZmxvdykge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcbiAgICAgICAgICAgICAgICBqZmxvdy5jb250ZXh0TWVudUhhbmxkZXIob2Zmc2V0WCwgb2Zmc2V0WSwgZXZlbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRibGNsaWNrOiBmdW5jdGlvbiAoZXZlbnQsIGpmbG93KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgIGpmbG93LmRibGNsaWNrSGFuZGxlcihvZmZzZXRYLCBvZmZzZXRZLCBldmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKGV2ZW50LCBqZmxvdykge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcbiAgICAgICAgICAgICAgICBpZighX21vdXNlU3RhdHVzLmRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIF9tb3VzZVN0YXR1cy5wb2ludGVyRG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfbW91c2VTdGF0dXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgamZsb3cuY2xpY2tIYW5sZGVyKG9mZnNldFgsIG9mZnNldFksIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRvY3VtZW50OiB7XG4gICAgICAgICAgICBwb2ludGVydXA6IGZ1bmN0aW9uKGV2ZW50LCBqZmxvdykge1xuICAgICAgICAgICAgICAgIGpmbG93LnByZXNzVXBIYW5sZGVyKHRydWUsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqIFxuICogRXZlbnRBZGFwdGVyIOWvueixoVxuICogRXZlbnRBZGFwdGVyIOmAmui/hyBwbHVnaW4g55qE5b2i5byP5a6e546w5aSa56eN5Lqk5LqS5pa55byP55qE5pig5bCEXG4gKiBAY29uc3RydWN0b3IgRXZlbnRBZGFwdGVyXG4gKi9cbmNsYXNzIEV2ZW50QWRhcHRlciB7XG4gICAgY29uc3RydWN0b3IocGx1Z2luID0ge30pIHtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBnZXREZWZhdWx0UGx1Z2luKCk7XG4gICAgICAgIHRoaXMudXNlKHBsdWdpbik7XG4gICAgICAgIHRoaXMuY2FudmFzSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5kb2N1bWVudEhhbmRsZXJzID0gW107XG4gICAgfVxuICAgIHVzZShwbHVnaW4gPSB7fSkge1xuICAgICAgICBjb25zdCB7IGNhbnZhczogY2EsIGRvY3VtZW50OiBkb2NPYmogfSA9IHBsdWdpbjtcbiAgICAgICAgaWYoY2EpIHtcbiAgICAgICAgICAgIGZvcihsZXQgZXZlbnROYW1lIGluIGNhKXtcbiAgICAgICAgICAgICAgICBpZiAoY2EuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5jYW52YXNbZXZlbnROYW1lXSA9IGNhW2V2ZW50TmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGRvY09iaikge1xuICAgICAgICAgICAgZm9yKGxldCBldmVudE5hbWUgaW4gZG9jT2JqKXtcbiAgICAgICAgICAgICAgICBpZiAoZG9jT2JqLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uZG9jdW1lbnRbZXZlbnROYW1lXSA9IGRvY09ialtldmVudE5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFwcGx5KGpmbG93KSB7XG4gICAgICAgIGNvbnN0IHsgY2FudmFzOiBjYSwgZG9jdW1lbnQ6IGRvY09iaiB9ID0gdGhpcy5wbHVnaW47XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGpmbG93LmNhbnZhcztcbiAgICAgICAgZm9yKGxldCBldmVudE5hbWUgaW4gY2Epe1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IGNhW2V2ZW50TmFtZV07XG4gICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVyV3JhcHBlcmQgKGUpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGUsIGpmbG93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcldyYXBwZXJkKVxuICAgICAgICAgICAgdGhpcy5jYW52YXNIYW5kbGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBldmVudE5hbWUsXG4gICAgICAgICAgICAgICAgaGFuZGxlcldyYXBwZXJkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGV2ZW50TmFtZSBpbiBkb2NPYmope1xuICAgICAgICAgICAgbGV0IGhhbmRsZXI7XG4gICAgICAgICAgICBsZXQgb3B0aW9ucyA9IHt9XG4gICAgICAgICAgICBpZih0eXBlb2YgZG9jT2JqW2V2ZW50TmFtZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gZG9jT2JqW2V2ZW50TmFtZV1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IGRvY09ialtldmVudE5hbWVdLmhhbmRsZXI7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBkb2NPYmpbZXZlbnROYW1lXS5vcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZXJXcmFwcGVyZCAoZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoZSwgamZsb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXJXcmFwcGVyZCwgb3B0aW9ucylcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRIYW5kbGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBldmVudE5hbWUsXG4gICAgICAgICAgICAgICAgaGFuZGxlcldyYXBwZXJkLFxuICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdW5sb2FkKGpmbG93KSB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGpmbG93LmNhbnZhcztcbiAgICAgICAgdGhpcy5jYW52YXNIYW5kbGVycy5mb3JFYWNoKCh7IGV2ZW50TmFtZSwgaGFuZGxlcldyYXBwZXJkIH0pID0+IHtcbiAgICAgICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcldyYXBwZXJkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRIYW5kbGVycy5mb3JFYWNoKCh7IGV2ZW50TmFtZSwgaGFuZGxlcldyYXBwZXJkLCBvcHRpb25zIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCd1bmxvYWQnLCBldmVudE5hbWUpXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcldyYXBwZXJkLCBvcHRpb25zKTtcbiAgICAgICAgfSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50QWRhcHRlcjtcbiIsImltcG9ydCBOb2RlIGZyb20gJy4vbm9kZSc7XG5pbXBvcnQgU3RhY2tNaXhpbiBmcm9tICcuL3N0YWNrTWl4aW4nO1xuaW1wb3J0IExheW91dE1peGluIGZyb20gJy4vbGF5b3V0TWl4aW4nO1xuaW1wb3J0IHsgYm91bmRpbmdfYm94IH0gZnJvbSAnLi4vdXRpbHMvZnVuY3Rpb25zJztcbmltcG9ydCB7IERJUkVDVElPTiB9IGZyb20gJy4uL3V0aWxzL2NvbnN0YW5jZSc7XG5jb25zdCBHcm91cE1peGluID0ge1xuICAgIC4uLlN0YWNrTWl4aW4sXG4gICAgLi4uTGF5b3V0TWl4aW4sXG4gICAgX3NldFBhZGRpbmcoY29uZmlncykge1xuICAgICAgICB0aGlzLnBhZGRpbmcgPSB7XG4gICAgICAgICAgICB0b3A6IGNvbmZpZ3MucGFkZGluZ1RvcCB8fCBjb25maWdzLnBhZGRpbmcgfHwgMCxcbiAgICAgICAgICAgIHJpZ2h0OiBjb25maWdzLnBhZGRpbmdSaWdodCB8fCBjb25maWdzLnBhZGRpbmcgfHwgMCxcbiAgICAgICAgICAgIGJvdHRvbTogY29uZmlncy5wYWRkaW5nQm90dG9tIHx8IGNvbmZpZ3MucGFkZGluZyB8fCAwLFxuICAgICAgICAgICAgbGVmdDogY29uZmlncy5wYWRkaW5nTGVmdCB8fCBjb25maWdzLnBhZGRpbmcgfHwgMCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIF9zZXRNYXJnaW4oY29uZmlncykgIHtcbiAgICAgICAgdGhpcy5tYXJnaW4gPSB7XG4gICAgICAgICAgICB0b3A6IGNvbmZpZ3MubWFyZ2luVG9wIHx8IGNvbmZpZ3MubWFyZ2luIHx8IDAsXG4gICAgICAgICAgICByaWdodDogY29uZmlncy5tYXJnaW5SaWdodCB8fCBjb25maWdzLm1hcmdpbiB8fCAwLFxuICAgICAgICAgICAgYm90dG9tOiBjb25maWdzLm1hcmdpbkJvdHRvbSB8fCBjb25maWdzLm1hcmdpbiB8fCAwLFxuICAgICAgICAgICAgbGVmdDogY29uZmlncy5tYXJnaW5MZWZ0IHx8IGNvbmZpZ3MubWFyZ2luIHx8IDAsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBfZ2V0Q2VudGVyKCkge1xuICAgICAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IHRoaXMucGFkZGluZztcbiAgICAgICAgY29uc3QgbWFyZ2luID0gdGhpcy5tYXJnaW47XG4gICAgICAgIGNvbnN0IG14ID0gKG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KS8yO1xuICAgICAgICBjb25zdCBteSA9IChtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSkvMjtcbiAgICAgICAgY29uc3QgY2VudGVyWCA9IChwYWRkaW5nLmxlZnQgLSBwYWRkaW5nLnJpZ2h0KS8yICsgbXg7XG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSAocGFkZGluZy50b3AgLSBwYWRkaW5nLmJvdHRvbSkvMiArIG15O1xuICAgICAgICB0aGlzLl9zaGFwZS5hbmNob3IgPSBbYW5jaG9yWzBdICsgbXgsIGFuY2hvclsxXSArIG15XTtcbiAgICAgICAgdGhpcy5fY2VudGVyWzBdID0gYW5jaG9yWzBdICsgY2VudGVyWDtcbiAgICAgICAgdGhpcy5fY2VudGVyWzFdID0gYW5jaG9yWzFdICsgY2VudGVyWTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlcjtcbiAgICB9LFxuICAgIHNldEFuY2hvclgoeCkge1xuICAgICAgICB0aGlzLmFuY2hvclswXSA9IHg7XG4gICAgICAgIHRoaXMuX2dldENlbnRlcigpOyBcbiAgICB9LFxuICAgIHNldEFuY2hvclkoeSkge1xuICAgICAgICB0aGlzLmFuY2hvclsxXSA9IHk7XG4gICAgICAgIHRoaXMuX2dldENlbnRlcigpOyBcbiAgICB9LFxuICAgIHNldEFuY2hvcih4LCB5KSB7XG4gICAgICAgIHRoaXMuYW5jaG9yWzBdID0geDtcbiAgICAgICAgdGhpcy5hbmNob3JbMV0gPSB5O1xuICAgICAgICB0aGlzLl9nZXRDZW50ZXIoKTsgXG4gICAgfSxcbiAgICBfY2FsY3VsYXRlUG9pbnRCYWNrKHBvaW50KSB7XG4gICAgICAgIGNvbnN0IFtneCwgZ3ldID0gcG9pbnQ7XG4gICAgICAgIGNvbnN0IFtjeCwgY3ldID0gdGhpcy5fZ2V0Q2VudGVyKCk7IFxuICAgICAgICBjb25zdCBwID0gW2d4IC0gY3gsIGd5IC0gY3ldXG4gICAgICAgIHJldHVybiBwXG4gICAgfSxcbiAgICBfY2FsY3VsYXRlUG9pbnRCYWNrV2l0aFBvaW50KGEsIGIsIGFyciwgaWR4MSwgaWR4Mikge1xuICAgICAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IHRoaXMucGFkZGluZztcbiAgICAgICAgY29uc3QgbWFyZ2luID0gdGhpcy5tYXJnaW47XG4gICAgICAgIGFycltpZHgxXSA9IGEgLSAoIGFuY2hvclswXSArIChwYWRkaW5nLmxlZnQgLSBwYWRkaW5nLnJpZ2h0KS8yICsgKG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KS8yICk7XG4gICAgICAgIGFycltpZHgyXSA9IGIgLSAoIGFuY2hvclsxXSArIChwYWRkaW5nLnRvcCAtIHBhZGRpbmcuYm90dG9tKS8yICsgKG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tKS8yICk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiDlj43nrpflm54gY2FudmFzIOmhtuWxguWdkOagh1xuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IHBvaW50XG4gICAgICogQHJldHVybiB7TnVtYmVyW119IOS4lueVjOWdkOagh1xuICAgICAqL1xuICAgIGNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKHBvaW50KSB7XG4gICAgICAgIGNvbnN0IFtneCwgZ3ldID0gcG9pbnQ7XG4gICAgICAgIGNvbnN0IFtjeCwgY3ldID0gdGhpcy5fZ2V0Q2VudGVyKCk7IFxuICAgICAgICAvLyBjb25zdCBwID0gW2N4ICsgYW5jaG9yWzBdIC0gc3BhbkgsIGN5ICsgYW5jaG9yWzFdIC0gc3BhblZdO1xuICAgICAgICBjb25zdCBwID0gW2d4ICsgY3gsIGd5ICsgY3ldXG4gICAgICAgIGlmKHRoaXMuX2JlbG9uZ3MgJiYgdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24ocCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICog5Y+N566X5Zue6aG16Z2i55qE5YOP57Sg5Z2Q5qCH77yM6YeN6L29IHtAbGluayBJbnN0YW5jZSNjYWxjdWxhdGVUb1JlYWxXb3JsZH1cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBwb2ludFxuICAgICAqIEByZXR1cm4ge051bWJlcltdfSDkuJbnlYzlnZDmoIdcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVUb1JlYWxXb3JsZChwb2ludCkge1xuICAgICAgICBjb25zdCBbZ3gsIGd5XSA9IHBvaW50O1xuICAgICAgICBjb25zdCBbY3gsIGN5XSA9IHRoaXMuX2dldENlbnRlcigpOyBcbiAgICAgICAgY29uc3QgcCA9IFtneCArIGN4LCBneSArIGN5XVxuICAgICAgICBpZih0aGlzLl9iZWxvbmdzICYmIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9SZWFsV29ybGQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvUmVhbFdvcmxkKHApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNhbGN1bGF0ZVRvUmVhbFdvcmxkV2l0aFBvaW50ZXIob3V0cG9pbnQsIGlucG9pbnQpIHtcbiAgICAgICAgb3V0cG9pbnRbMF0gPSBpbnBvaW50WzBdICsgdGhpcy5fY2VudGVyWzBdO1xuICAgICAgICBvdXRwb2ludFsxXSA9IGlucG9pbnRbMV0gKyB0aGlzLl9jZW50ZXJbMV07XG4gICAgICAgIGlmKHRoaXMuX2JlbG9uZ3MgJiYgdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb1JlYWxXb3JsZFdpdGhQb2ludGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb1JlYWxXb3JsZFdpdGhQb2ludGVyKG91dHBvaW50LCBvdXRwb2ludCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBDID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgY29uc3QgY29uZmlncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3Jhd0NvbmZpZ3MsIHtcbiAgICAgICAgICAgIGxheW91dDogdGhpcy5fbGF5b3V0ICYmIHRoaXMuX2xheW91dC5jbG9uZSgpLFxuICAgICAgICB9KVxuICAgICAgICBjb25zdCB0ID0gbmV3IEMoY29uZmlncyk7XG4gICAgICAgIHRoaXMuaW50ZXJhdGVOb2RlU3RhY2soKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICB0LmFkZFRvU3RhY2soaW5zdGFuY2UuY2xvbmUoKSk7XG4gICAgICAgIH0pXG4gICAgICAgIHQucmVjYWxjdWxhdGUoKTtcbiAgICAgICAgdC52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9LFxuICAgIGdldEJvdW5kaW5nRGltZW5zaW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXRCb3VuZGluZ1JlY3QoKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aCAvMjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIGNvbnN0IGx0eCA9IGFuY2hvclswXSAtIHc7XG4gICAgICAgIGNvbnN0IGx0eSA9IGFuY2hvclsxXSAtIGg7XG4gICAgICAgIGNvbnN0IHJieCA9IGFuY2hvclswXSArIHc7XG4gICAgICAgIGNvbnN0IHJieSA9IGFuY2hvclsxXSArIGg7XG4gICAgICAgIGNvbnN0IGJyID0gdGhpcy5fYm91bmRpbmdyZWN0O1xuICAgICAgICBiclswXSA9IGx0eDtcbiAgICAgICAgYnJbMV0gPSBsdHk7XG4gICAgICAgIGJyWzJdID0gcmJ4O1xuICAgICAgICBiclszXSA9IHJieTtcbiAgICAgICAgcmV0dXJuIGJyXG4gICAgfSxcbiAgICBnZXRJbnRlcnNlY3Rpb25zSW5Gb3VyRGltZW5zaW9uKCkge1xuICAgICAgICBsZXQgcDIgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgaWYodGhpcy5fYmVsb25ncyAmJiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKSB7XG4gICAgICAgICAgICBwMiA9IHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24ocDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgW3gyLCB5Ml0gPSBwMjtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGgvMjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbRElSRUNUSU9OLlJJR0hUXTogIFt4Mit3LCB5Ml0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLkxFRlRdOiAgIFt4Mi13LCB5Ml0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLkJPVFRPTV06IFt4MiwgeTIraF0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLlRPUF06ICAgIFt4MiwgeTItaF0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLlNFTEZdOiAgIFt4Mit3KjAuNjE4LCB5MitoKjAuNjE4XVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjYWxjdWxhdGVJbnRlcnNlY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgY29uc3QgW3gxLCB5MV0gPSBwb2ludDtcbiAgICAgICAgY29uc3QgW3gyLCB5Ml0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGgvMjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIGNvbnN0IHZlY3ggPSB4MiAtIHgxO1xuICAgICAgICBjb25zdCB2ZWN5ID0geTIgLSB5MTtcbiAgICAgICAgY29uc3QgdGhldGExID0gaC93O1xuICAgICAgICBjb25zdCB0aGV0YTIgPSBNYXRoLmFicyh2ZWN5L3ZlY3gpO1xuICAgICAgICBjb25zdCBkaXJ4ID0geDEgPiB4MjtcbiAgICAgICAgY29uc3QgZGlyeSA9IHkxID4geTI7XG4gICAgICAgIGxldCB4LCB5O1xuICAgICAgICBpZih0aGV0YTIgPCB0aGV0YTEpIHtcbiAgICAgICAgICAgIHggPSB4MiArIChkaXJ4P3c6LXcpO1xuICAgICAgICAgICAgeSA9IHcgKiAoZGlyeT90aGV0YTI6LXRoZXRhMikgKyB5MjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHkgPSB5MiArIChkaXJ5P2g6LWgpO1xuICAgICAgICAgICAgeCA9IGggLyAoZGlyeD90aGV0YTI6LXRoZXRhMikgKyB4MjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgIH0sXG4gICAgb25FbnRlclZpZXdib3goKSB7XG4gICAgICAgIHRoaXMuaW50ZXJhdGVOb2RlU3RhY2soKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICBpbnN0YW5jZS5vbkVudGVyVmlld2JveCgpO1xuICAgICAgICB9KVxuICAgIH0sXG4gICAgb25MZWF2ZVZpZXdib3goKSB7XG4gICAgICAgIHRoaXMuaW50ZXJhdGVOb2RlU3RhY2soKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICBpbnN0YW5jZS5vbkxlYXZlVmlld2JveCgpO1xuICAgICAgICB9KVxuICAgIH0sXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fc2hhcGUuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmludGVyYXRlTm9kZVN0YWNrKChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgICAgaW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgICB9KVxuICAgIH0sXG4gICAgXG4gICAgZG9SZWNhbGN1bGF0ZSgpIHtcbiAgICAgICAgaWYodGhpcy5fX21vdW50ZWRfXykge1xuICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZVVwKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVjYWxjdWxhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuX19tb3VudGVkX18gPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRTaGlmdCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgcmV0dXJuIFt3aWR0aCwgaGVpZ2h0XTtcbn1cblxuLyoqXG4gKiDmoLnmja5wYWRkaW5nYm945a696auY5p2l6K6h566Xc2hhcGVzaGlmdGJveOeahOWuvemrmFxuICogQGZ1bmN0aW9uIHNoYXBlU2hpZnRcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAgICAgICAgICAgIC0gcGFkZGluZ0JveOWuvVxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAgICAgICAgICAgLSBwYWRkaW5nQm946auYXG4gKiBAcmV0dXJuIHtudW1iZXJbXX1cbiAqL1xuXG4vKipcbiAqIOe7hOW3peWOguWHveaVsO+8jOeUqOS6jumAmui/h0pGbG93IOe7mOWbvuiKgueCueadpeWIm+W7uuS4jeWQjOeahOe7hFxuICogQGdsb2JhbCBcbiAqIEBmdW5jdGlvbiBHcm91cEZhY3RvcnlcbiAqIEBwYXJhbSB7Tm9kZX0gamZsb3dOb2RlQ29uc3RydWN0b3IgLSDnu5jlm77oioLngrnmnoTpgKDlmahcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgLSDphY3nva7poblcbiAqIEBwYXJhbSB7c2hhcGVTaGlmdH0gb3B0aW9ucy5zaGFwZVNoaWZ0IC0gc2hpZnTlsYLpgILphY3mlrnms5VcbiAqIEByZXR1cm4ge0dyb3VwfSAtIOe7mOWbvuiKgueCueaehOmAoOWZqFxuICovXG5mdW5jdGlvbiBHcm91cEZhY3RvcnkoamZsb3dOb2RlQ29uc3RydWN0b3IsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHNoYXBlU2hpZnQgPSB0eXBlb2Ygb3B0aW9ucy5zaGFwZVNoaWZ0ID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5zaGFwZVNoaWZ0IDogZGVmYXVsdFNoaWZ0O1xuXG4gICAgLyoqXG4gICAgICogR3JvdXAg6YWN572uXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gR3JvdXBUZW1wbGF0ZX5Hcm91cENvbmZpZ3NcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggICAgICAgICAgICAgLSDorr7lrprlrr3luqZcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWluV2lkdGggICAgICAgICAgLSDmnIDlsI/lrr3luqZcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0ICAgICAgICAgICAgLSDorr7lrprpq5jluqZcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcGFkZGluZyAgICAgICAgICAtIOWGhei+uei3nVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwYWRkaW5nVG9wICAgICAgICAgIC0g5YaF5LiK6L656LedXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHBhZGRpbmdSaWdodCAgICAgICAgIC0g5YaF5Y+z6L656LedXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHBhZGRpbmdCb3R0b20gICAgICAgIC0g5YaF5LiL6L656LedXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHBhZGRpbmdMZWZ0ICAgICAgICAgIC0g5YaF5bem6L656LedXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1hcmdpbiAgICAgICAgICAgIC0g5aSW6L656LedXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1hcmdpblRvcCAgICAgICAgICAtIOWkluS4iui+uei3nVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXJnaW5SaWdodCAgICAgICAgIC0g5aSW5Y+z6L656LedXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1hcmdpbkJvdHRvbSAgICAgICAgLSDlpJbkuIvovrnot51cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWFyZ2luTGVmdCAgICAgICAgICAtIOWkluW3pui+uei3nVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbG9jayAgICAgICAgICAgIC0g5biD5bGA6ZSB5a6a54q25oCBIOm7mOiupCB0cnVlXG4gICAgICovXG4gICAgY2xhc3MgdCBleHRlbmRzIE5vZGUge1xuICAgICAgICAvKipcbiAgICAgICAgKiBAY29uc3RydWN0cyBHcm91cFRlbXBsYXRlXG4gICAgICAgICogQHBhcmFtIHtHcm91cFRlbXBsYXRlfkdyb3VwQ29uZmlnc30gY29uZmlncyAtIOe7hOmFjee9rlxuICAgICAgICAqIEBtaXhlcyBMYXlvdXRNaXhpblxuICAgICAgICAqIEBtaXhlcyBTdGFja01peGluIFxuICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3Rvcihjb25maWdzKSB7XG4gICAgICAgICAgICBzdXBlcihjb25maWdzKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdFN0YWNrKGNvbmZpZ3MpO1xuICAgICAgICAgICAgdGhpcy5pbml0TGF5b3V0KGNvbmZpZ3MpO1xuICAgICAgICAgICAgLyoqIEBtZW1iZXIge05vZGV9ICAgICAgLSDlo7Pnu5jlm77ljZXlhYMgKi9cbiAgICAgICAgICAgIHRoaXMuX3NoYXBlID0gbmV3IGpmbG93Tm9kZUNvbnN0cnVjdG9yKGNvbmZpZ3MpO1xuICAgICAgICAgICAgdGhpcy5fc2hhcGUuYW5jaG9yID0gWzAsIDBdO1xuICAgICAgICAgICAgdGhpcy5fc2hhcGUuX2JlbG9uZ3MgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fY2VudGVyID0gWzAsMF07XG4gICAgICAgICAgICB0aGlzLl9zZXRQYWRkaW5nKGNvbmZpZ3MpO1xuICAgICAgICAgICAgdGhpcy5fc2V0TWFyZ2luKGNvbmZpZ3MpOyAgXG4gICAgICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAgIC0g6K6+5a6a5a695bqmICovXG4gICAgICAgICAgICB0aGlzLmRlZmluZWRXaWR0aCA9ICAgICBjb25maWdzLndpZHRoO1xuICAgICAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgICAtIOacgOWwj+WuveW6piAqL1xuICAgICAgICAgICAgdGhpcy5taW5XaWR0aCA9ICAgICAgICAgY29uZmlncy5taW5XaWR0aDtcbiAgICAgICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgICAgLSDorr7lrprnmoTpq5jluqYgKi9cbiAgICAgICAgICAgIHRoaXMuZGVmaW5lZEhlaWdodCA9ICAgIGNvbmZpZ3MuaGVpZ2h0O1xuICAgICAgICAgICAgLyoqIEBtZW1iZXIge0Jvb2xlYW59ICAgICAgLSDnu4TlhoXlhYPntKDmmK/lkKbplIHlrprvvIwg6buY6K6kdHJ1ZSAqL1xuICAgICAgICAgICAgdGhpcy5sb2NrID0gICAgICAgICAgICAgY29uZmlncy5sb2NrID8/IHRydWUgO1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0gICAgICAgICAgY29uZmlncy5kaXNwbGF5IHx8ICdkZWZhdWx0JztcbiAgICAgICAgICAgIC8qKiBAbWVtYmVyIHtCb29sZWFufSAgICAgIC0g57uE5pys6Lqr5piv5ZCm6L+b5YWl5b2i54q25Yik5a6a6IyD5Zu0ICovXG4gICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW50ID0gICAgICBjb25maWdzLnRyYW5zcGFyZW50ID8/IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZ2V0Qm91bmRpbmdHcm91cFJlY3QoKTtcbiAgICAgICAgICAgIHRoaXMucmVmbG93KCk7XG4gICAgICAgICAgICB0aGlzLl9nZXRCb3VuZGluZ0dyb3VwUmVjdCgpOyAgXG4gICAgICAgICAgICB0aGlzLl9jYWNoZVZpZXdCb3ggPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHQucHJvdG90eXBlLCBHcm91cE1peGluKTtcbiAgICBPYmplY3QuYXNzaWduKHQucHJvdG90eXBlLCB7IFxuICAgICAgICByZWZsb3coKSB7XG4gICAgICAgICAgICBHcm91cE1peGluLnJlZmxvdy5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgbWFyZ2luID0gdGhpcy5tYXJnaW47XG4gICAgICAgICAgICBjb25zdCBbc2hhcGVXaWR0aCwgc2hhcGVIZWlnaHRdID0gc2hhcGVTaGlmdChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tLCB0aGlzLl9zaGFwZSk7XG4gICAgICAgICAgICB0aGlzLl9zaGFwZS53aWR0aCA9IHNoYXBlV2lkdGg7XG4gICAgICAgICAgICB0aGlzLl9zaGFwZS5oZWlnaHQgPSBzaGFwZUhlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Q29uZmlnKGNvbmZpZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoYXBlLnNldENvbmZpZyhjb25maWdzKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFBhZGRpbmcoY29uZmlncyk7XG4gICAgICAgICAgICB0aGlzLl9zZXRNYXJnaW4oY29uZmlncyk7ICBcbiAgICAgICAgICAgIGlmKCdvcGFjaXR5JyBpbiBjb25maWdzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gY29uZmlncy5vcGFjaXR5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGNvbmZpZ3MubGF5b3V0ICYmIHRoaXMuX2xheW91dCAhPT0gY29uZmlncy5sYXlvdXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXlvdXQgPSBjb25maWdzLmxheW91dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2dldEJvdW5kaW5nR3JvdXBSZWN0KCkge1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gdGhpcy5fc3RhY2suZ2V0Qm91bmRpbmdSZWN0UG9pbnRzKCk7XG4gICAgICAgICAgICAvLyBjb250ZW50IGJveCBcbiAgICAgICAgICAgIGNvbnN0IGJib3ggPSBib3VuZGluZ19ib3gocG9pbnRzKTtcblxuICAgICAgICAgICAgIC8vIHBhZGRpbmcgYm94IFxuICAgICAgICAgICAgY29uc3QgcGFkZGluZyA9IHRoaXMucGFkZGluZztcbiAgICAgICAgICAgIGNvbnN0IG1pbldpZHRoID0gdGhpcy5taW5XaWR0aC8vIC0gcGFkZGluZy5sZWZ0IC0gcGFkZGluZy5yaWdodDtcbiAgICAgICAgICAgIGNvbnN0IGRlZmluZWRXaWR0aCA9IHRoaXMuZGVmaW5lZFdpZHRoLy8gLSBwYWRkaW5nLmxlZnQgLSBwYWRkaW5nLnJpZ2h0O1xuICAgICAgICAgICAgY29uc3QgdyA9IGJib3gud2lkdGggKyBwYWRkaW5nLmxlZnQgKyBwYWRkaW5nLnJpZ2h0O1xuICAgICAgICAgICAgY29uc3QgaCA9IGJib3guaGVpZ2h0ICsgcGFkZGluZy50b3AgKyBwYWRkaW5nLmJvdHRvbTtcbiAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdXaWR0aCA9IG1pbldpZHRoID8gTWF0aC5tYXgobWluV2lkdGgsIHcpIDogZGVmaW5lZFdpZHRoIHx8IHc7XG4gICAgICAgICAgICBjb25zdCBwYWRkaW5nSGVpZ2h0ID0gdGhpcy5kZWZpbmVkSGVpZ2h0IHx8IGg7XG4gICAgICAgICAgICB0aGlzLl9wYWRkaW5nV2lkdGggPSBwYWRkaW5nV2lkdGg7XG4gICAgICAgICAgICB0aGlzLl9wYWRkaW5nSGVpZ2h0ID0gcGFkZGluZ0hlaWdodDtcblxuICAgICAgICAgICAgLy8gc2hhcGVCb3hcbiAgICAgICAgICAgIGNvbnN0IFtzaGFwZVdpZHRoLCBzaGFwZUhlaWdodF0gPSBzaGFwZVNoaWZ0KHBhZGRpbmdXaWR0aCwgcGFkZGluZ0hlaWdodCwgdGhpcy5fc2hhcGUpXG4gICAgICAgICAgICB0aGlzLl9zaGFwZS53aWR0aCA9IHNoYXBlV2lkdGg7XG4gICAgICAgICAgICB0aGlzLl9zaGFwZS5oZWlnaHQgPSBzaGFwZUhlaWdodDtcbiAgICAgICAgICAgIC8vIG1hcmdpbkJveFxuICAgICAgICAgICAgY29uc3QgbWFyZ2luID0gdGhpcy5tYXJnaW47XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gc2hhcGVXaWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBzaGFwZUhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRWaWV3Qm94KCkge1xuICAgICAgICAgICAgY29uc3QgYmVsb25nc192Ym94ID0gdGhpcy5fYmVsb25ncy5nZXRDYWNoZVZpZXdCb3goKTtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlVmlld0JveCA9IHRoaXMuX2NhY2hlVmlld0JveDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlUG9pbnRCYWNrV2l0aFBvaW50KGJlbG9uZ3NfdmJveFswXSwgYmVsb25nc192Ym94WzFdLCBjYWNoZVZpZXdCb3gsIDAsIDEpO1xuICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlUG9pbnRCYWNrV2l0aFBvaW50KGJlbG9uZ3NfdmJveFsyXSwgYmVsb25nc192Ym94WzNdLCBjYWNoZVZpZXdCb3gsIDIsIDMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlVmlld0JveDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q2FjaGVWaWV3Qm94KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlVmlld0JveDtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHJlbmRlcihjdHgpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBpZih0aGlzLl9pc01vdmluZyl7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC42XG4gICAgICAgICAgICB9IGVsc2UgaWYodGhpcy5vcGFjaXR5ICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5vcGFjaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW2N4LCBjeV0gPSB0aGlzLl9nZXRDZW50ZXIoKTsgXG4gICAgICAgICAgICB0aGlzLl9zaGFwZS5yZW5kZXIoY3R4KTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY3gsIGN5KTtcbiAgICAgICAgICAgIHRoaXMuX3N0YWNrLnJlbmRlcihjdHgpO1xuICAgICAgICAgICAgLy8gdGhpcy5fbGlua1N0YWNrLnJlbmRlcihjdHgpOyAgICBcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLWN4LCAtY3kpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICAgICAgLy8gY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIC8vIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIC8vIGN0eC5hcmMoY3gsIGN5LCA1LCAwLCBNYXRoLlBJKjIpO1xuICAgICAgICAgICAgLy8gY3R4LmZpbGxTdHlsZSA9ICdyZ2IoMCwwLDApJ1xuICAgICAgICAgICAgLy8gY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIC8vIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzSGl0KHBvaW50LCBjb25kaXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLl9jYWxjdWxhdGVQb2ludEJhY2socG9pbnQpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudHAgPSBwOyAvLyDmmoLlrZjvvIzkuLrkuoblkI7nu63orqHnrpfliKvnmoTkvY3nva5cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX3N0YWNrLmNoZWNrSGl0KHAsIGNvbmRpdGlvbik7XG4gICAgICAgICAgICBpZih0YXJnZXQpIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICBpZighdGhpcy50cmFuc3BhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaGFwZS5pc0hpdChwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sICAgIFxuICAgIH0pO1xuICAgIHJldHVybiB0XG59XG5cbmV4cG9ydCBkZWZhdWx0IEdyb3VwRmFjdG9yeTtcblxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vbm9kZSc7XG5pbXBvcnQgeyBESVJFQ1RJT04gfSBmcm9tICcuLi8uLi91dGlscy9jb25zdGFuY2UnO1xuLyoqXG4gKiDlnIblvaLljZXlhYMg6YWN572uXG4gKiBAdHlwZWRlZiB7Tm9kZX5Db25maWdzfSBQb2ludH5Qb2ludENvbmZpZ3NcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByYWRpdXMgIC0g5Y2K5b6EXG4gKi9cbi8qKlxuICog5ZyG5b2i6IqC54K5XG4gKiBAY29uc3RydWN0b3IgUG9pbnRcbiAqIEBleHRlbmRzIE5vZGVcbiAqIEBwYXJhbSB7UG9pbnR+UG9pbnRDb25maWdzfSBjb25maWdzIC0g6YWN572uXG4gKi9cbmNsYXNzIFBvaW50IGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlncykge1xuICAgICAgICBzdXBlcihjb25maWdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gICAgICAgICAgICAgJ1BvaW50JztcbiAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgICAtIOWNiuW+hCAqL1xuICAgICAgICB0aGlzLnJhZGl1cyA9ICAgICAgICAgICBjb25maWdzLnJhZGl1cyB8fCAxMDtcbiAgICAgICAgdGhpcy5fZG9DYWNoZSgpO1xuICAgIH1cblxuICAgIHNldENvbmZpZyhjb25maWdzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGNvbmZpZ3MpLmZvckVhY2goayA9PiB7XG4gICAgICAgICAgICBpZihjb25maWdzW2tdICE9PSB1bmRlZmluZWQgJiYgY29uZmlnc1trXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXNba10gPSBjb25maWdzW2tdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jhd0NvbmZpZ3Nba10gPSBjb25maWdzW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZG9DYWNoZSgpO1xuICAgIH1cbiAgICBfZG9DYWNoZSgpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMucmFkaXVzICogMjtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnJhZGl1cyAqIDI7XG4gICAgfVxuXG4gICAgcmVuZGVyKGN0eCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBpZih0aGlzLl9pc01vdmluZyl7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjZcbiAgICAgICAgfVxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5hcmModGhpcy5hbmNob3JbMF0sIHRoaXMuYW5jaG9yWzFdLCB0aGlzLnJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGlmKHRoaXMuYm9yZGVyV2lkdGgpIHtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmJvcmRlcldpZHRoO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5ib3JkZXJDb2xvcjtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZih0aGlzLl9pc1RhcmdldGluZykge1xuICAgICAgICAvLyAgICAgdGhpcy5yZW5kZXJGb2N1cyhjdHgpO1xuICAgICAgICAvLyB9XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgaXNIaXQocG9pbnQpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdyhwb2ludFswXSAtIGFuY2hvclswXSwgMikgKyBNYXRoLnBvdyhwb2ludFsxXSAtIGFuY2hvclsxXSwgMikgPCB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzXG4gICAgfVxuXG4gICAgZ2V0Qm91bmRpbmdSZWN0KCkge1xuICAgICAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgciA9IHRoaXMucmFkaXVzO1xuICAgICAgICBjb25zdCBsdHggPSBhbmNob3JbMF0gLSByO1xuICAgICAgICBjb25zdCBsdHkgPSBhbmNob3JbMV0gLSByO1xuICAgICAgICBjb25zdCByYnggPSBhbmNob3JbMF0gKyByO1xuICAgICAgICBjb25zdCByYnkgPSBhbmNob3JbMV0gKyByO1xuICAgICAgICBjb25zdCBiciA9IHRoaXMuX2JvdW5kaW5ncmVjdDtcbiAgICAgICAgYnJbMF0gPSBsdHg7XG4gICAgICAgIGJyWzFdID0gbHR5O1xuICAgICAgICBiclsyXSA9IHJieDtcbiAgICAgICAgYnJbM10gPSByYnk7XG4gICAgICAgIHJldHVybiBiclxuICAgIH1cblxuICAgIGNhbGN1bGF0ZUludGVyc2VjdGlvbihwb2ludCkge1xuICAgICAgICBjb25zdCBbeDEsIHkxXSA9IHBvaW50O1xuICAgICAgICBjb25zdCBbeDIsIHkyXSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCB2ZWN4ID0geDIgLSB4MTtcbiAgICAgICAgY29uc3QgdmVjeSA9IHkyIC0geTE7XG4gICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLnNxcnQodmVjeCAqIHZlY3ggKyB2ZWN5ICogdmVjeSk7XG5cbiAgICAgICAgY29uc3QgcmF0aW8gPSB0aGlzLnJhZGl1cyAvIGRpc3Q7XG4gICAgICAgIHJldHVybiBbeDIgLSByYXRpbyAqIHZlY3gsIHkyIC0gcmF0aW8gKiB2ZWN5XTtcbiAgICB9XG5cbiAgICBnZXRJbnRlcnNlY3Rpb25zSW5Gb3VyRGltZW5zaW9uKCkge1xuICAgICAgICBjb25zdCBbeDIsIHkyXSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCByID0gdGhpcy5yYWRpdXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbRElSRUNUSU9OLlJJR0hUXTogIFt4MiArIHIsIHkyXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uTEVGVF06ICAgW3gyIC0gciwgeTJdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5CT1RUT01dOiBbeDIsIHkyK3JdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5UT1BdOiAgICBbeDIsIHkyLXJdLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlSW50ZXJzZWN0aW9uSW5Gb3VyRGltZW5zaW9uKHBvaW50LCBlbmQpIHtcbiAgICAgICAgY29uc3QgW3gxLCB5MV0gPSBwb2ludDtcbiAgICAgICAgY29uc3QgW3gyLCB5Ml0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgciA9IHRoaXMucmFkaXVzO1xuICAgICAgICBjb25zdCB2ZWN4ID0geDIgLSB4MTtcbiAgICAgICAgY29uc3QgdmVjeSA9IHkyIC0geTE7XG4gICAgICAgIGNvbnN0IGFsbEludGVyc2VjdGlvbnMgPSB7XG4gICAgICAgICAgICBbRElSRUNUSU9OLlJJR0hUXTogIFt4MiArIHIsIHkyXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uTEVGVF06ICAgW3gyIC0gciwgeTJdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5CT1RUT01dOiBbeDIsIHkyK3JdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5UT1BdOiAgICBbeDIsIHkyLXJdLFxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKE1hdGguYWJzKHZlY3gpID4gTWF0aC5hYnModmVjeSksIHZlY3gsIHIpXG4gICAgICAgIC8vIGlmKCkge1xuICAgICAgICAvLyAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gICAgICAgICBwOiBbeDIgKyAodmVjeDwwP3I6LXIpLCB5Ml0sXG4gICAgICAgIC8vICAgICAgICAgZGlyOiB2ZWN4PDAgPyBESVJFQ1RJT04uUklHSFQgOiBESVJFQ1RJT04uTEVGVCxcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgLy8gICAgIHJldHVybiB7XG4gICAgICAgIC8vICAgICAgICAgcDogW3gyLCB5MisodmVjeTwwP3I6LXIpXSxcbiAgICAgICAgLy8gICAgICAgICBkaXI6IHZlY3k8MCA/IERJUkVDVElPTi5CT1RUT00gOiBESVJFQ1RJT04uVE9QLFxuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG4gICAgICAgIGxldCBpbnRlckRpciA9IChNYXRoLmFicyh2ZWN5KSA+IE1hdGguYWJzKHZlY3gpXG4gICAgICAgICAgICA/ICh2ZWN5IDwgMCA/IERJUkVDVElPTi5CT1RUT00gOiBESVJFQ1RJT04uVE9QKVxuICAgICAgICAgICAgOiAodmVjeCA8IDAgPyBESVJFQ1RJT04uUklHSFQgOiBESVJFQ1RJT04uTEVGVCkpO1xuXG4gICAgICAgIC8vIGludGVyRGlyID0gdGhpcy5jaGVja0xpbmtlZChpbnRlckRpciwgZW5kKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHA6IGFsbEludGVyc2VjdGlvbnNbaW50ZXJEaXJdLFxuICAgICAgICAgICAgZGlyOiBpbnRlckRpcixcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEJvdW5kaW5nRGltZW5zaW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9pbnQ7IiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vbm9kZSc7XG5pbXBvcnQgeyBESVJFQ1RJT04sIG9wcG9zaXRlRGlyZWN0aW9uIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uc3RhbmNlJztcbi8qKlxuICogQHR5cGVkZWYgUmVjdGFuZ2xlfmJvcmRlclxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBib3JkZXJDb2xvciAgICAgIC0g6L655qGG5a695bqmLCDpu5jorqQgMFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJvcmRlcldpZHRoICAgICAgLSDovrnmoYbpopzoibIsIOm7mOiupCB0cmFuc3BhcmVudFxuICovXG4vKipcbiAqIEB0eXBlZGVmIFJlY3RhbmdsZX5ib3JkZXJzXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtSZWN0YW5nbGV+Ym9yZGVyfSB0b3AgICAgICAtIOS4iui+ueahhlxuICogQHByb3BlcnR5IHtSZWN0YW5nbGV+Ym9yZGVyfSByaWdodCAgICAgIC0g5Y+z6L655qGGXG4gKiBAcHJvcGVydHkge1JlY3RhbmdsZX5ib3JkZXJ9IGJvdHRvbSAgICAgIC0g5LiL6L655qGGXG4gKiBAcHJvcGVydHkge1JlY3RhbmdsZX5ib3JkZXJ9IGxlZnQgICAgICAtIOW3pui+ueahhlxuICovXG5cbi8qKlxuICog55+p5b2i5Y2V5YWDIOmFjee9rlxuICogQHR5cGVkZWYge05vZGV+Q29uZmlnc30gUmVjdGFuZ2xlflJlY3RhbmdsZUNvbmZpZ3NcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aCAtIOWuvVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAtIOmrmFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJvcmRlclJhZGl1cyAtIOWchuinkuefqeW9ouWNiuW+hFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGJvcmRlckNvbG9yIC0g6L655qGG6aKc6ImyLCDpu5jorqQgdHJhbnNwYXJlbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBib3JkZXJXaWR0aCAtIOi+ueahhuWuveW6piwg6buY6K6kIDBcbiAqIEBwcm9wZXJ0eSB7UmVjdGFuZ2xlfmJvcmRlcnN9IGJvcmRlciAgICAgIC0g6L655qGG6K6+572uXG4gKi9cbi8qKlxuICog55+p5b2i5Y2V5YWDXG4gKiBAY29uc3RydWN0b3IgUmVjdGFuZ2xlXG4gKiBAZXh0ZW5kcyBOb2RlXG4gKiBAcGFyYW0ge1JlY3RhbmdsZX5SZWN0YW5nbGVDb25maWdzfSBjb25maWdzXG4gKi9cbmNsYXNzIFJlY3RhbmdsZSBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3MgPSB7fSkge1xuICAgICAgICBzdXBlcihjb25maWdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gICAgICAgICAgICAgJ1JlY3RhbmdsZSc7XG4gICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAgIC0g5a69ICovXG4gICAgICAgIHRoaXMud2lkdGggPSAgICAgICAgICAgIGNvbmZpZ3Mud2lkdGggfHwgMTA7XG4gICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAgIC0g6auYICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gICAgICAgICAgIGNvbmZpZ3MuaGVpZ2h0IHx8IDEwO1xuICAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgICAtIOWchuinkuefqeW9ouWNiuW+hCAqL1xuICAgICAgICB0aGlzLmJvcmRlclJhZGl1cyA9ICAgICBjb25maWdzLmJvcmRlclJhZGl1cyB8fCAwO1xuICAgICAgICB0aGlzLl9zZXRCb3JkZXIoY29uZmlncyk7XG4gICAgfVxuXG4gICAgX3NldEJvcmRlcihjb25maWdzKXtcbiAgICAgICAgLyoqIEBtZW1iZXIge1JlY3RhbmdsZX5ib3JkZXJzfSAgICAgIC0g6L655qGG6K6+572u77yM5LyY5YWI57qn6auY5LqOIGJvcmRlcldpZHRo77yMYm9yZGVyQ29sb3IgKi9cbiAgICAgICAgdGhpcy5ib3JkZXIgPSB7XG4gICAgICAgICAgICB0b3A6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogY29uZmlncy5ib3JkZXI/LnRvcD8uYm9yZGVyQ29sb3IgfHwgY29uZmlncy5ib3JkZXJDb2xvciB8fCAndHJhbnNwYXJlbnQnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBjb25maWdzLmJvcmRlcj8udG9wPy5ib3JkZXJXaWR0aCB8fCBjb25maWdzLmJvcmRlcldpZHRoIHx8IDAsXG4gICAgICAgICAgICAgICAgZW5hYmxlOiBjb25maWdzLmJvcmRlcj8udG9wPy5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByaWdodDoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBjb25maWdzLmJvcmRlcj8ucmlnaHQ/LmJvcmRlckNvbG9yIHx8IGNvbmZpZ3MuYm9yZGVyQ29sb3IgfHwgJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgICB3aWR0aDogY29uZmlncy5ib3JkZXI/LnJpZ2h0Py5ib3JkZXJXaWR0aCB8fCBjb25maWdzLmJvcmRlcldpZHRoIHx8IDAsXG4gICAgICAgICAgICAgICAgZW5hYmxlOiBjb25maWdzLmJvcmRlcj8ucmlnaHQ/LmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvdHRvbToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBjb25maWdzLmJvcmRlcj8uYm90dG9tPy5ib3JkZXJDb2xvciB8fCBjb25maWdzLmJvcmRlckNvbG9yIHx8ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGNvbmZpZ3MuYm9yZGVyPy5ib3R0b20/LmJvcmRlcldpZHRoIHx8IGNvbmZpZ3MuYm9yZGVyV2lkdGggfHwgMCxcbiAgICAgICAgICAgICAgICBlbmFibGU6IGNvbmZpZ3MuYm9yZGVyPy5ib3R0b20/LmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlZnQ6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogY29uZmlncy5ib3JkZXI/LmxlZnQ/LmJvcmRlckNvbG9yIHx8IGNvbmZpZ3MuYm9yZGVyQ29sb3IgfHwgJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgICB3aWR0aDogY29uZmlncy5ib3JkZXI/LmxlZnQ/LmJvcmRlcldpZHRoIHx8IGNvbmZpZ3MuYm9yZGVyV2lkdGggfHwgMCxcbiAgICAgICAgICAgICAgICBlbmFibGU6IGNvbmZpZ3MuYm9yZGVyPy5sZWZ0Py5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IGNvbmZpZ3MuYm9yZGVyQ29sb3IgfHwgJ3RyYW5zcGFyZW50JztcbiAgICAgICAgdGhpcy5ib3JkZXJXaWR0aCA9IGNvbmZpZ3MuYm9yZGVyV2lkdGggfHwgMDtcbiAgICB9XG5cbiAgICBzZXRDb25maWcoY29uZmlncykge1xuICAgICAgICBPYmplY3Qua2V5cyhjb25maWdzKS5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAgICAgaWYoY29uZmlnc1trXSAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZ3Nba10gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tdID0gY29uZmlnc1trXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXdDb25maWdzW2tdID0gY29uZmlnc1trXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NldEJvcmRlcihjb25maWdzKTtcbiAgICB9XG5cbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGlmKHRoaXMuX2lzTW92aW5nKXtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNlxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiByYWRpdXMsIGFuY2hvciwgd2lkdGgsIGhlaWdodFxuICAgICAgICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuYW5jaG9yWzBdIC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLmFuY2hvclsxXSAtIHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgY29uc3QgeHQgPSB0aGlzLmFuY2hvclswXSArIHRoaXMud2lkdGggLyAyO1xuICAgICAgICBjb25zdCB5dCA9IHRoaXMuYW5jaG9yWzFdICsgdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgICBpZih0aGlzLmJvcmRlclJhZGl1cykge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgcmFkaXVzLCB5KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcmFkaXVzLCB5KTtcbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcmFkaXVzLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHJhZGl1cywgeSArIGhlaWdodCk7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSArIHJhZGl1cyk7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcmFkaXVzLCB5KTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTsgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgucmVjdCh0aGlzLmFuY2hvclswXSAtIHRoaXMud2lkdGggLyAyLCB0aGlzLmFuY2hvclsxXSAtIHRoaXMuaGVpZ2h0IC8gMiwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuYm9yZGVyV2lkdGgpIHtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmJvcmRlcldpZHRoO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5ib3JkZXJDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYodGhpcy5zaGFkb3dDb2xvciAmJiB0aGlzLnNoYWRvd0NvbG9yICE9PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSB0aGlzLnNoYWRvd0NvbG9yO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9qZmxvdy5zY2FsZTtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gdGhpcy5zaGFkb3dCbHVyICogc2NhbGU7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHRoaXMuc2hhZG93T2Zmc2V0WCAqIHNjYWxlO1xuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSB0aGlzLnNoYWRvd09mZnNldFkgKiBzY2FsZTtcbiAgICAgICAgICAgIGxldCBzd2l0Y2hQYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICAgICAgaWYodGhpcy5ib3JkZXJSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2hQYXRoLm1vdmVUbyh4ICsgcmFkaXVzLCB5KTtcbiAgICAgICAgICAgICAgICBzd2l0Y2hQYXRoLmxpbmVUbyh4ICsgd2lkdGggLSByYWRpdXMsIHkpO1xuICAgICAgICAgICAgICAgIHN3aXRjaFBhdGgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHJhZGl1cyk7XG4gICAgICAgICAgICAgICAgc3dpdGNoUGF0aC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2hQYXRoLnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIHN3aXRjaFBhdGgubGluZVRvKHggKyByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIHN3aXRjaFBhdGgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2hQYXRoLmxpbmVUbyh4LCB5ICsgcmFkaXVzKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2hQYXRoLnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJhZGl1cywgeSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoUGF0aC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoUGF0aC5yZWN0KHRoaXMuYW5jaG9yWzBdIC0gdGhpcy53aWR0aCAvIDIsIHRoaXMuYW5jaG9yWzFdIC0gdGhpcy5oZWlnaHQgLyAyLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2hQYXRoLnJlY3QoeCAtIDEwLCB5IC0gMTAsIHRoaXMud2lkdGgrIDIwLCB0aGlzLmhlaWdodCsgMjApO1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC5jbGlwKHN3aXRjaFBhdGgsIFwiZXZlbm9kZFwiKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH0gIFxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGlmKHRoaXMuYm9yZGVyUmFkaXVzICYmIHRoaXMuYm9yZGVyV2lkdGgpIHtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICd0cmFuc3BhcmVudCdcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYodGhpcy5ib3JkZXJSYWRpdXMpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuYm9yZGVyLnRvcC5lbmFibGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eSA9IHkgLSB0aGlzLmJvcmRlci50b3Aud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuYm9yZGVyLnRvcC53aWR0aClcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgbGV0IHRvcFBhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgICAgICAgICAgdG9wUGF0aC5tb3ZlVG8oeCwgdHkgKyByYWRpdXMpO1xuICAgICAgICAgICAgICAgIHRvcFBhdGgucXVhZHJhdGljQ3VydmVUbyh4LCB0eSwgeCArIHJhZGl1cywgdHkpO1xuICAgICAgICAgICAgICAgIHRvcFBhdGgubGluZVRvKHggKyB3aWR0aCAtIHJhZGl1cywgdHkpO1xuICAgICAgICAgICAgICAgIHRvcFBhdGgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHR5LCB4ICsgd2lkdGgsIHR5ICsgcmFkaXVzKTtcbiAgICAgICAgICAgICAgICB0b3BQYXRoLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5jbGlwKHRvcFBhdGgpOyAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYm9yZGVyLnRvcC5jb2xvcjtcbiAgICAgICAgICAgICAgICBjdHgucmVjdCh4LCB0eSwgdGhpcy53aWR0aCwgdGhpcy5ib3JkZXIudG9wLndpZHRoKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgLy8gY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAvLyBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgLy8gY3R4Lm1vdmVUbyh4LCB0eSArIHJhZGl1cyk7XG4gICAgICAgICAgICAgICAgLy8gY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgdHksIHggKyByYWRpdXMsIHR5KTtcbiAgICAgICAgICAgICAgICAvLyBjdHgubGluZVRvKHggKyB3aWR0aCAtIHJhZGl1cywgdHkpO1xuICAgICAgICAgICAgICAgIC8vIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgdHksIHggKyB3aWR0aCwgdHkgKyByYWRpdXMpO1xuICAgICAgICAgICAgICAgIC8vIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgICAgICAgICAgICAgIC8vIC8vIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgLy8gY3R4LmNsaXAoKTtcblxuICAgICAgICAgICAgICAgIC8vIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAvLyBjdHgucmVjdCh4LCB0eSwgdGhpcy53aWR0aCwgdGhpcy5ib3JkZXIudG9wLndpZHRoKTtcbiAgICAgICAgICAgICAgICAvLyBjdHguZmlsbFN0eWxlID0gdGhpcy5ib3JkZXIudG9wLmNvbG9yO1xuICAgICAgICAgICAgICAgIC8vIGN0eC5zaGFkb3dDb2xvciA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICAgICAgLy8gY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAvLyBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYodGhpcy5ib3JkZXIudG9wLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4dCwgeSk7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5ib3JkZXIudG9wLmNvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmJvcmRlci50b3Aud2lkdGg7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih0aGlzLmJvcmRlci5yaWdodC53aWR0aCkge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHh0LCB5KTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHh0LCB5dCk7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5ib3JkZXIucmlnaHQuY29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuYm9yZGVyLnJpZ2h0LndpZHRoO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodGhpcy5ib3JkZXIuYm90dG9tLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeHQsIHl0KTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIHl0KTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmJvcmRlci5ib3R0b20uY29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuYm9yZGVyLmJvdHRvbS53aWR0aDtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHRoaXMuYm9yZGVyLmxlZnQud2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5dCk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmJvcmRlci5sZWZ0LmNvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmJvcmRlci5sZWZ0LndpZHRoO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGlzSGl0KHBvaW50KSB7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aCAvMjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIHJldHVybiBwb2ludFswXSA+IGFuY2hvclswXSAtIHdcbiAgICAgICAgICAgICYmIHBvaW50WzBdIDwgYW5jaG9yWzBdICsgd1xuICAgICAgICAgICAgJiYgcG9pbnRbMV0gPiBhbmNob3JbMV0gLSBoXG4gICAgICAgICAgICAmJiBwb2ludFsxXSA8IGFuY2hvclsxXSArIGg7XG4gICAgfVxuXG4gICAgZ2V0Qm91bmRpbmdSZWN0KCkge1xuICAgICAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGggLzI7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICBjb25zdCBsdHggPSBhbmNob3JbMF0gLSB3O1xuICAgICAgICBjb25zdCBsdHkgPSBhbmNob3JbMV0gLSBoO1xuICAgICAgICBjb25zdCByYnggPSBhbmNob3JbMF0gKyB3O1xuICAgICAgICBjb25zdCByYnkgPSBhbmNob3JbMV0gKyBoO1xuICAgICAgICBjb25zdCBiciA9IHRoaXMuX2JvdW5kaW5ncmVjdDtcbiAgICAgICAgYnJbMF0gPSBsdHg7XG4gICAgICAgIGJyWzFdID0gbHR5O1xuICAgICAgICBiclsyXSA9IHJieDtcbiAgICAgICAgYnJbM10gPSByYnk7XG4gICAgICAgIHJldHVybiBiclxuICAgIH1cblxuICAgIGdldEJvdW5kaW5nRGltZW5zaW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlSW50ZXJzZWN0aW9uKHBvaW50KSB7XG4gICAgICAgIGNvbnN0IFt4MSwgeTFdID0gcG9pbnQ7XG4gICAgICAgIGNvbnN0IFt4MiwgeTJdID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoLzI7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICBjb25zdCB2ZWN4ID0geDIgLSB4MTtcbiAgICAgICAgY29uc3QgdmVjeSA9IHkyIC0geTE7XG4gICAgICAgIGNvbnN0IHRoZXRhMSA9IGgvdztcbiAgICAgICAgY29uc3QgdGhldGEyID0gTWF0aC5hYnModmVjeS92ZWN4KTtcbiAgICAgICAgY29uc3QgZGlyeCA9IHgxID4geDI7XG4gICAgICAgIGNvbnN0IGRpcnkgPSB5MSA+IHkyO1xuICAgICAgICBsZXQgeCwgeTtcbiAgICAgICAgaWYodGhldGEyIDwgdGhldGExKSB7XG4gICAgICAgICAgICB4ID0geDIgKyAoZGlyeD93Oi13KTtcbiAgICAgICAgICAgIHkgPSB3ICogKGRpcnk/dGhldGEyOi10aGV0YTIpICsgeTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5ID0geTIgKyAoZGlyeT9oOi1oKTtcbiAgICAgICAgICAgIHggPSBoIC8gKGRpcng/dGhldGEyOi10aGV0YTIpICsgeDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG5cbiAgICBnZXRJbnRlcnNlY3Rpb25zSW5Gb3VyRGltZW5zaW9uKCkge1xuICAgICAgICBsZXQgcDIgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgaWYodGhpcy5fYmVsb25ncyAmJiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKSB7XG4gICAgICAgICAgICBwMiA9IHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24ocDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgW3gyLCB5Ml0gPSBwMjtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGgvMjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbRElSRUNUSU9OLlJJR0hUXTogIFt4Mit3LCB5Ml0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLkxFRlRdOiAgIFt4Mi13LCB5Ml0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLkJPVFRPTV06IFt4MiwgeTIraF0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLlRPUF06ICAgIFt4MiwgeTItaF0sXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxjdWxhdGVJbnRlcnNlY3Rpb25JbkZvdXJEaW1lbnNpb24ocG9pbnQsIGVuZCkge1xuICAgICAgICBjb25zdCBbeDEsIHkxXSA9IHBvaW50O1xuICAgICAgICBsZXQgcDIgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgaWYodGhpcy5fYmVsb25ncyAmJiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKSB7XG4gICAgICAgICAgICBwMiA9IHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24ocDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgW3gyLCB5Ml0gPSBwMjtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGgvMjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIGNvbnN0IGFsbEludGVyc2VjdGlvbnMgPSB7XG4gICAgICAgICAgICBbRElSRUNUSU9OLlJJR0hUXTogIFt4Mit3LCB5Ml0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLkxFRlRdOiAgIFt4Mi13LCB5Ml0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLkJPVFRPTV06IFt4MiwgeTIraF0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLlRPUF06ICAgIFt4MiwgeTItaF0sXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVjeCA9IHgyIC0geDE7XG4gICAgICAgIGNvbnN0IHZlY3kgPSB5MiAtIHkxO1xuICAgICAgICBjb25zdCB0aGV0YTEgPSBoL3c7XG4gICAgICAgIGNvbnN0IHRoZXRhMiA9IE1hdGguYWJzKHZlY3kvdmVjeCk7XG4gICAgICAgIGNvbnN0IGRpcnggPSB4MSA+IHgyO1xuICAgICAgICBjb25zdCBkaXJ5ID0geTEgPiB5MjtcbiAgICAgICAgbGV0IGludGVyRGlyID0gKHRoZXRhMiA+IHRoZXRhMVxuICAgICAgICAgICAgPyAoZGlyeSA/IERJUkVDVElPTi5CT1RUT00gOiBESVJFQ1RJT04uVE9QKVxuICAgICAgICAgICAgOiAoZGlyeCA/IERJUkVDVElPTi5SSUdIVCA6IERJUkVDVElPTi5MRUZUKSk7XG5cbiAgICAgICAgLy8gaWYodGhpcy5fYmVsb25ncyAmJiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKSB7XG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeSh0aGlzLl9pbnRlcnNlY3Rpb25zKSk7XG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhpbnRlckRpcilcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBpbnRlckRpciA9IHRoaXMuY2hlY2tMaW5rZWQoaW50ZXJEaXIsIGVuZCk7XG4gICAgICAgIC8vIGlmKHRoaXMuX2JlbG9uZ3MgJiYgdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbikge1xuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coaW50ZXJEaXIpXG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBpZighaW50ZXJEaXIpIHtcbiAgICAgICAgLy8gICAgIGRlYnVnZ2VyXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gbGV0IGVuZERpciA9IGludGVyRGlyO1xuICAgICAgICAvLyBpZihlbmQgPT09ICd0bycpIHtcbiAgICAgICAgLy8gICAgIGVuZERpciA9IG9wcG9zaXRlRGlyZWN0aW9uKGVuZERpcilcbiAgICAgICAgLy8gfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcDogYWxsSW50ZXJzZWN0aW9uc1tpbnRlckRpcl0sXG4gICAgICAgICAgICBkaXI6IGludGVyRGlyLFxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSZWN0YW5nbGU7IiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vbm9kZSc7XG5pbXBvcnQgeyBESVJFQ1RJT04sIG9wcG9zaXRlRGlyZWN0aW9uIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uc3RhbmNlJztcbi8qKlxuICog6IO25ZuK5Y2V5YWDIOmFjee9rlxuICogQHR5cGVkZWYge05vZGV+Q29uZmlnc30gQ2Fwc3VsZX5DYXBzdWxlQ29uZmlnc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoICAtIOWGhemDqOefqeW9ouWuvVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAtIOWGhemDqOefqeW9oumrmFxuICovXG4vKipcbiAqIOiDtuWbiuWNleWFg1xuICogQGNvbnN0cnVjdG9yIENhcHN1bGVcbiAqIEBleHRlbmRzIE5vZGVcbiAqIEBwYXJhbSB7Q2Fwc3VsZX5DYXBzdWxlQ29uZmlnc30gY29uZmlncyAtIOmFjee9rlxuICovXG5jbGFzcyBDYXBzdWxlIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlncyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAgICAgICAgICAgICAnQ2Fwc3VsZSc7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgICAgLSDlhoXpg6jnn6nlvaLlrr0gKi9cbiAgICAgICAgdGhpcy53aWR0aCA9ICAgICAgICAgICAgY29uZmlncy53aWR0aCB8fCAyMDtcbiAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgICAtIOWGhemDqOefqeW9oumrmCAqL1xuICAgICAgICB0aGlzLmhlaWdodCA9ICAgICAgICAgICBjb25maWdzLmhlaWdodCB8fCAxMDtcbiAgICB9XG5cbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGlmKHRoaXMuX2lzTW92aW5nKXtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNlxuICAgICAgICB9XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29uc3QgW3gsIHldID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IGh3ID0gdGhpcy53aWR0aC8yO1xuICAgICAgICBjb25zdCBoaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIGNvbnN0IGxlZnRDZW50ZXIgPSB4IC0gaHcgKyBoaDtcbiAgICAgICAgY29uc3QgcmlnaHRDZW50ZXIgPSB4ICsgaHcgLSBoaDtcbiAgICAgICAgY29uc3QgdG9wID0geSAtIGhoO1xuICAgICAgICBjb25zdCBib3R0b20gPSB5ICsgaGg7XG5cbiAgICAgICAgY3R4Lm1vdmVUbyhsZWZ0Q2VudGVyLCB0b3ApO1xuICAgICAgICBjdHgubGluZVRvKHJpZ2h0Q2VudGVyLCB0b3ApO1xuICAgICAgICBjdHguYXJjKHJpZ2h0Q2VudGVyLCB5LCBoaCwgLU1hdGguUEkvMiwgTWF0aC5QSS8yKTtcbiAgICAgICAgY3R4LmxpbmVUbyhsZWZ0Q2VudGVyLCBib3R0b20pO1xuICAgICAgICBjdHguYXJjKGxlZnRDZW50ZXIsIHksIGhoLCBNYXRoLlBJLzIsIE1hdGguUEkvMiozKTtcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGlmICh0aGlzLnNoYWRvd0NvbG9yKSB7XG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSB0aGlzLnNoYWRvd0NvbG9yO1xuICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSB0aGlzLnNoYWRvd0JsdXI7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHRoaXMuc2hhZG93T2Zmc2V0WDtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gdGhpcy5zaGFkb3dPZmZzZXRZO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGlmKHRoaXMuYm9yZGVyV2lkdGgpIHtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmJvcmRlcldpZHRoO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5ib3JkZXJDb2xvcjtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMC4zKSc7XG4gICAgICAgIC8vIGN0eC5maWxsUmVjdCh4LWh3LCB5LWhoLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodClcblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGlzSGl0KHBvaW50KSB7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCBodyA9IHRoaXMud2lkdGgvMjtcbiAgICAgICAgY29uc3QgaGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICBjb25zdCB3dyA9ICBNYXRoLmFicyhodyAtIGhoKTtcbiAgICAgICAgY29uc3QgbGVmdENlbnRlciA9IGFuY2hvclswXSAtIGh3ICsgaGg7XG4gICAgICAgIGNvbnN0IHJpZ2h0Q2VudGVyID0gYW5jaG9yWzBdICsgaHcgLSBoaDtcbiAgICAgICAgY29uc3QgcnIgPSBoaCAqIGhoO1xuICAgICAgICByZXR1cm4gKHBvaW50WzBdID4gYW5jaG9yWzBdIC0gd3dcbiAgICAgICAgICAgICYmIHBvaW50WzBdIDwgYW5jaG9yWzBdICsgd3dcbiAgICAgICAgICAgICYmIHBvaW50WzFdID4gYW5jaG9yWzFdIC0gaGhcbiAgICAgICAgICAgICYmIHBvaW50WzFdIDwgYW5jaG9yWzFdICsgaGgpXG4gICAgICAgICAgICB8fCAoIE1hdGgucG93KHBvaW50WzBdIC0gbGVmdENlbnRlciwgMikgKyBNYXRoLnBvdyhwb2ludFsxXSAtIGFuY2hvclsxXSwgMikgPCBycilcbiAgICAgICAgICAgIHx8ICggTWF0aC5wb3cocG9pbnRbMF0gLSByaWdodENlbnRlciwgMikgKyBNYXRoLnBvdyhwb2ludFsxXSAtIGFuY2hvclsxXSwgMikgPCBycilcbiAgICB9XG5cbiAgICBnZXRCb3VuZGluZ1JlY3QoKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aCAvMjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIGNvbnN0IGx0eCA9IGFuY2hvclswXSAtIHc7XG4gICAgICAgIGNvbnN0IGx0eSA9IGFuY2hvclsxXSAtIGg7XG4gICAgICAgIGNvbnN0IHJieCA9IGFuY2hvclswXSArIHc7XG4gICAgICAgIGNvbnN0IHJieSA9IGFuY2hvclsxXSArIGg7XG4gICAgICAgIGNvbnN0IGJyID0gdGhpcy5fYm91bmRpbmdyZWN0O1xuICAgICAgICBiclswXSA9IGx0eDtcbiAgICAgICAgYnJbMV0gPSBsdHk7XG4gICAgICAgIGJyWzJdID0gcmJ4O1xuICAgICAgICBiclszXSA9IHJieTtcbiAgICAgICAgcmV0dXJuIGJyXG4gICAgfVxuXG4gICAgZ2V0Qm91bmRpbmdEaW1lbnNpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRJbnRlcnNlY3Rpb25zSW5Gb3VyRGltZW5zaW9uKCkge1xuICAgICAgICBsZXQgcDIgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgaWYodGhpcy5fYmVsb25ncyAmJiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKSB7XG4gICAgICAgICAgICBwMiA9IHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24ocDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgW3gyLCB5Ml0gPSBwMjtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGgvMjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbRElSRUNUSU9OLlJJR0hUXTogIFt4Mit3LCB5Ml0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLkxFRlRdOiAgIFt4Mi13LCB5Ml0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLkJPVFRPTV06IFt4MiwgeTIraF0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLlRPUF06ICAgIFt4MiwgeTItaF0sXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhcHN1bGU7IiwiaW1wb3J0IENhcHN1bGUgZnJvbSAnLi9jYXBzdWxlJztcbi8qKlxuICog5Z6C55u06IO25ZuK5Y2V5YWDXG4gKiBAY29uc3RydWN0b3IgQ2Fwc3VsZVZlcnRpY2FsXG4gKiBAZXh0ZW5kcyBDYXBzdWxlXG4gKiBAcGFyYW0ge0NhcHN1bGV+Q2Fwc3VsZUNvbmZpZ3N9IGNvbmZpZ3MgLSDphY3nva5cbiAqL1xuY2xhc3MgQ2Fwc3VsZVZlcnRpY2FsIGV4dGVuZHMgQ2Fwc3VsZSB7XG4gICAgcmVuZGVyKGN0eCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBpZih0aGlzLl9pc01vdmluZyl7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjZcbiAgICAgICAgfVxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnN0IFt4LCB5XSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCBodyA9IHRoaXMud2lkdGgvMjtcbiAgICAgICAgY29uc3QgaGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICBjb25zdCB0b3BDZW50ZXIgPSB5IC0gaGggKyBodztcbiAgICAgICAgY29uc3QgYm90dG9tQ2VudGVyID0geSArIGhoIC0gaHc7XG4gICAgICAgIGNvbnN0IGxlZnQgPSB4IC0gaHc7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0geCArIGh3O1xuXG4gICAgICAgIGN0eC5tb3ZlVG8obGVmdCwgdG9wQ2VudGVyKTtcbiAgICAgICAgY3R4LmFyYyh4LCB0b3BDZW50ZXIsIGh3LCAtTWF0aC5QSSwgMCk7XG4gICAgICAgIGN0eC5saW5lVG8ocmlnaHQsIGJvdHRvbUNlbnRlcik7XG4gICAgICAgIGN0eC5hcmMoeCwgYm90dG9tQ2VudGVyLCBodywgMCwgTWF0aC5QSSk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGlmICh0aGlzLnNoYWRvd0NvbG9yKSB7XG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSB0aGlzLnNoYWRvd0NvbG9yO1xuICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSB0aGlzLnNoYWRvd0JsdXI7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHRoaXMuc2hhZG93T2Zmc2V0WDtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gdGhpcy5zaGFkb3dPZmZzZXRZO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGlmKHRoaXMuYm9yZGVyV2lkdGgpIHtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmJvcmRlcldpZHRoO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5ib3JkZXJDb2xvcjtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMC4zKSc7XG4gICAgICAgIC8vIGN0eC5maWxsUmVjdCh4LWh3LCB5LWhoLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodClcblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGlzSGl0KHBvaW50LCBjb25kaXRpb24pIHtcbiAgICAgICAgY29uc3QgW3gsIHldID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IGh3ID0gdGhpcy53aWR0aC8yO1xuICAgICAgICBjb25zdCBoaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIGNvbnN0IHl5ID0gIE1hdGguYWJzKGhoIC0gaHcpO1xuICAgICAgICBjb25zdCB0b3BDZW50ZXIgPSB5IC0gaGggKyBodztcbiAgICAgICAgY29uc3QgYm90dG9tQ2VudGVyID0geSArIGhoIC0gaHc7XG4gICAgICAgIGNvbnN0IHJyID0gaHcgKiBodztcbiAgICAgICAgcmV0dXJuIChwb2ludFswXSA+IHggLSBod1xuICAgICAgICAgICAgJiYgcG9pbnRbMF0gPCB4ICsgaHdcbiAgICAgICAgICAgICYmIHBvaW50WzFdID4geSAtIHl5XG4gICAgICAgICAgICAmJiBwb2ludFsxXSA8IHkgKyB5eSlcbiAgICAgICAgICAgIHx8ICggTWF0aC5wb3cocG9pbnRbMF0gLSB4LCAyKSArIE1hdGgucG93KHBvaW50WzFdIC0gdG9wQ2VudGVyLCAyKSA8IHJyKVxuICAgICAgICAgICAgfHwgKCBNYXRoLnBvdyhwb2ludFswXSAtIHgsIDIpICsgTWF0aC5wb3cocG9pbnRbMV0gLSBib3R0b21DZW50ZXIsIDIpIDwgcnIpXG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgQ2Fwc3VsZVZlcnRpY2FsOyIsImltcG9ydCBOb2RlIGZyb20gJy4uL25vZGUnO1xuaW1wb3J0IHsgRElSRUNUSU9OIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uc3RhbmNlJztcbi8qKlxuICog6I+x5b2i5Y2V5YWDIOmFjee9rlxuICogQHR5cGVkZWYge05vZGV+Q29uZmlnc30gUmhvbWJ1c35SaG9tYnVzQ29uZmlnc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGRpYWdvbmFsc1YgIC0g5YaF5Y2B5a2X6auY5bqmXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGlhZ29uYWxzSCAgLSDlhoXljYHlrZflrr3luqZcbiAqL1xuLyoqXG4gKiDoj7HlvaLljZXlhYNcbiAqIEBjb25zdHJ1Y3RvciBSaG9tYnVzXG4gKiBAcGFyYW0ge1Job21idXN+UmhvbWJ1c0NvbmZpZ3N9IGNvbmZpZ3MgLSDphY3nva5cbiAqIEBleHRlbmRzIE5vZGVcbiAqL1xuY2xhc3MgUmhvbWJ1cyBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3MgPSB7fSkge1xuICAgICAgICBzdXBlcihjb25maWdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gICAgICAgICAgICAgJ1Job21idXMnO1xuICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAgIC0g5YaF5Y2B5a2X6auY5bqmICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gICAgICAgICAgIGNvbmZpZ3MuZGlhZ29uYWxzViB8fCAxMDtcbiAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgICAtIOWGheWNgeWtl+WuveW6piAqL1xuICAgICAgICB0aGlzLndpZHRoID0gICAgICAgICAgICBjb25maWdzLmRpYWdvbmFsc0ggfHwgMjA7XG4gICAgfVxuXG4gICAgcmVuZGVyKGN0eCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBpZih0aGlzLl9pc01vdmluZyl7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjZcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjdHgudHJhbnNsYXRlKGNlbnRlclswXSwgY2VudGVyWzFdKVxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oMCwgLWgpO1xuICAgICAgICBjdHgubGluZVRvKHcsIDApO1xuICAgICAgICBjdHgubGluZVRvKDAsIGgpO1xuICAgICAgICBjdHgubGluZVRvKC13LCAwKTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBpZih0aGlzLmJvcmRlcldpZHRoKSB7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5ib3JkZXJXaWR0aDtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYm9yZGVyQ29sb3I7XG4gICAgICAgIH1cblxuICAgICAgICBcbiAgICAgICAgaWYodGhpcy5zaGFkb3dDb2xvcikge1xuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gdGhpcy5zaGFkb3dDb2xvcjtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5famZsb3cuc2NhbGU7XG4gICAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IHRoaXMuc2hhZG93Qmx1ciAqIHNjYWxlO1xuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSB0aGlzLnNoYWRvd09mZnNldFggKiBzY2FsZTtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gdGhpcy5zaGFkb3dPZmZzZXRZICogc2NhbGU7XG4gICAgICAgICAgICBsZXQgc3dpdGNoUGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgICAgIHN3aXRjaFBhdGgubW92ZVRvKDAsIC1oKTtcbiAgICAgICAgICAgIHN3aXRjaFBhdGgubGluZVRvKHcsIDApO1xuICAgICAgICAgICAgc3dpdGNoUGF0aC5saW5lVG8oMCwgaCk7XG4gICAgICAgICAgICBzd2l0Y2hQYXRoLmxpbmVUbygtdywgMCk7XG4gICAgICAgICAgICBzd2l0Y2hQYXRoLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgc3dpdGNoUGF0aC5yZWN0KC13IC0gMTAsICAtaCAtIDEwLCB0aGlzLndpZHRoICsgMjAsIHRoaXMuaGVpZ2h0KyAyMCk7XG4gICAgICAgICAgICAvLyBzd2l0Y2hQYXRoLm1vdmVUbyh4LCB5LWgpO1xuICAgICAgICAgICAgLy8gc3dpdGNoUGF0aC5saW5lVG8oeCArIHcsIHkpO1xuICAgICAgICAgICAgLy8gc3dpdGNoUGF0aC5saW5lVG8oeCwgeSArIGgpO1xuICAgICAgICAgICAgLy8gc3dpdGNoUGF0aC5saW5lVG8oeC13LCB5KTtcbiAgICAgICAgICAgIC8vIHN3aXRjaFBhdGguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAvLyBzd2l0Y2hQYXRoLnJlY3QoeCAtIHcgLSAxMCwgeSAtIGggLSAxMCwgdGhpcy53aWR0aCsgMjAsIHRoaXMuaGVpZ2h0KyAyMCk7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LmNsaXAoc3dpdGNoUGF0aCwgXCJldmVub2RkXCIpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGlmICh0aGlzLmJvcmRlcldpZHRoKSB7XG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSAndHJhbnNwYXJlbnQnXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICBcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY2VudGVyWzBdLCAtY2VudGVyWzFdKVxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGlzSGl0KHBvaW50KSB7XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IHggPSBNYXRoLmFicyhwb2ludFswXSAtIGFuY2hvclswXSk7XG4gICAgICAgIGNvbnN0IHkgPSBNYXRoLmFicyhwb2ludFsxXSAtIGFuY2hvclsxXSk7XG4gICAgICAgIHJldHVybiAoeCAvIGggKyB5IC8gdikgPD0gMTtcbiAgICB9XG5cbiAgICBnZXRCb3VuZGluZ1JlY3QoKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aCAvMjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0IC8yO1xuICAgICAgICBjb25zdCBsdHggPSBhbmNob3JbMF0gLSB3O1xuICAgICAgICBjb25zdCBsdHkgPSBhbmNob3JbMV0gLSBoO1xuICAgICAgICBjb25zdCByYnggPSBhbmNob3JbMF0gKyB3O1xuICAgICAgICBjb25zdCByYnkgPSBhbmNob3JbMV0gKyBoO1xuICAgICAgICBjb25zdCBiciA9IHRoaXMuX2JvdW5kaW5ncmVjdDtcbiAgICAgICAgYnJbMF0gPSBsdHg7XG4gICAgICAgIGJyWzFdID0gbHR5O1xuICAgICAgICBiclsyXSA9IHJieDtcbiAgICAgICAgYnJbM10gPSByYnk7XG4gICAgICAgIHJldHVybiBiclxuICAgIH1cblxuICAgIGdldEJvdW5kaW5nRGltZW5zaW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0SW50ZXJzZWN0aW9uc0luRm91ckRpbWVuc2lvbigpIHtcbiAgICAgICAgbGV0IHAyID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGlmKHRoaXMuX2JlbG9uZ3MgJiYgdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbikge1xuICAgICAgICAgICAgcDIgPSB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKHAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IFt4MiwgeTJdID0gcDI7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoLzI7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodC8yO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbRElSRUNUSU9OLlJJR0hUXTogIFt4Mit3LCB5Ml0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLkxFRlRdOiAgIFt4Mi13LCB5Ml0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLkJPVFRPTV06IFt4MiwgeTIraF0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLlRPUF06ICAgIFt4MiwgeTItaF0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLlNFTEZdOiAgIFt4Mit3KjAuNjE4LCB5MitoKjAuNjE4XVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSaG9tYnVzO1xuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vbm9kZSc7XG5pbXBvcnQgeyBESVJFQ1RJT04sIG9wcG9zaXRlRGlyZWN0aW9uIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uc3RhbmNlJztcbi8vIGltcG9ydCB7IG1ha2VCZXppZXJQb2ludHMgfSBmcm9tICcuLi8uLi91dGlscy9mdW5jdGlvbnMnO1xuLyoqXG4gKiDpkrvnn7PlvaLljZXlhYMg6YWN572uXG4gKiBAdHlwZWRlZiB7Tm9kZX5Db25maWdzfSBEaWFtb25kfkRpYW1vbmRDb25maWdzXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggIC0g5YaF6YOo55+p5b2i5a69XG4gKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IC0g5YaF6YOo55+p5b2i6auYXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2lkZSAgIC0g5Lik5L6n5LiJ6KeS5b2i55qE5a69XG4gKi9cbi8qKlxuICog6ZK755+z5b2i5Y2V5YWDXG4gKiBAY29uc3RydWN0b3IgRGlhbW9uZFxuICogQHBhcmFtIHtEaWFtb25kfkRpYW1vbmRDb25maWdzfSBjb25maWdzIC0g6YWN572uXG4gKiBAZXh0ZW5kcyBOb2RlXG4gKi9cblxuY2xhc3MgRGlhbW9uZCBleHRlbmRzIE5vZGUge1xuXG4gICAgY29uc3RydWN0b3IoY29uZmlncyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAgICAgICAgICAgICAnRGlhbW9uZCc7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgICAgLSDlhoXpg6jnn6nlvaLlrr0gKi9cbiAgICAgICAgdGhpcy53aWR0aCA9ICAgICAgICAgICAgY29uZmlncy53aWR0aCB8fCAyMDtcbiAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgICAtIOWGhemDqOefqeW9oumrmCAqL1xuICAgICAgICB0aGlzLmhlaWdodCA9ICAgICAgICAgICBjb25maWdzLmhlaWdodCB8fCAxMDtcbiAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgICAtIOS4pOS+p+S4ieinkuW9oueahOWuvSAqL1xuICAgICAgICB0aGlzLnNpZGUgPSAgICAgICAgICAgICBjb25maWdzLnNpZGUgfHwgNjtcbiAgICAgICAgdGhpcy5fZG9DYWNoZSgpO1xuICAgIH1cblxuICAgIHNldENvbmZpZyhjb25maWdzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGNvbmZpZ3MpLmZvckVhY2goayA9PiB7XG4gICAgICAgICAgICBpZihjb25maWdzW2tdICE9PSB1bmRlZmluZWQgJiYgY29uZmlnc1trXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXNba10gPSBjb25maWdzW2tdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jhd0NvbmZpZ3Nba10gPSBjb25maWdzW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZG9DYWNoZSgpO1xuICAgIH1cblxuICAgIF9kb0NhY2hlKCkge1xuICAgICAgICB0aGlzLnNpblNJREUgPSBNYXRoLnNpbihNYXRoLlBJLzMpICogdGhpcy5zaWRlO1xuICAgICAgICB0aGlzLmNvc1NJREUgPSBNYXRoLmNvcyhNYXRoLlBJLzMpICogdGhpcy5zaWRlO1xuICAgIH1cblxuICAgIHJlbmRlcihjdHgpIHtcbiAgICAgICAgY29uc3QgW3gsIHldID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IGh3ID0gdGhpcy53aWR0aC8yO1xuICAgICAgICBjb25zdCBoaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIGNvbnN0IHh4ID0gaGggLyAxLjczMlxuICAgICAgICBjb25zdCBsZWZ0Q2VudGVyID0geCAtIGh3ICsgeHg7XG4gICAgICAgIGNvbnN0IHJpZ2h0Q2VudGVyID0geCArIGh3IC0geHg7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0geCArIGh3O1xuICAgICAgICBjb25zdCBsZWZ0ID0geCAtIGh3O1xuICAgICAgICBjb25zdCB0b3AgPSB5IC0gaGg7XG4gICAgICAgIGNvbnN0IGJvdHRvbSA9IHkgKyBoaDtcblxuICAgICAgICB0aGlzLl9jYWNoZVBvaW50cyA9IFtcbiAgICAgICAgICAgIFtyaWdodENlbnRlciwgdG9wXSxcbiAgICAgICAgICAgIFtyaWdodCwgeV0sXG4gICAgICAgICAgICBbcmlnaHRDZW50ZXIsIGJvdHRvbV0sXG4gICAgICAgICAgICBbbGVmdENlbnRlciwgYm90dG9tXSxcbiAgICAgICAgICAgIFtsZWZ0LCB5XSxcbiAgICAgICAgICAgIFtsZWZ0Q2VudGVyLCB0b3BdXG4gICAgICAgIF07XG5cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgaWYodGhpcy5faXNNb3Zpbmcpe1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC42XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBzaWRlLCBzaW5TSURFLCBjb3NTSURFXG4gICAgICAgIH0gPSB0aGlzO1xuICAgICAgICBjdHgubW92ZVRvKHgsIHRvcCk7XG4gICAgICAgIGN0eC5saW5lVG8ocmlnaHRDZW50ZXIgLSBzaWRlLCB0b3ApO1xuICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhyaWdodENlbnRlciwgdG9wLCByaWdodENlbnRlciArIGNvc1NJREUsIHRvcCArIHNpblNJREUpO1xuICAgICAgICBjdHgubGluZVRvKHJpZ2h0IC0gY29zU0lERSwgeSAtIHNpblNJREUpO1xuICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhyaWdodCwgeSwgcmlnaHQgLSBjb3NTSURFLCB5ICsgc2luU0lERSk7XG4gICAgICAgIGN0eC5saW5lVG8ocmlnaHRDZW50ZXIgKyBjb3NTSURFLCBib3R0b20gLSBzaW5TSURFKTtcbiAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8ocmlnaHRDZW50ZXIsIGJvdHRvbSwgcmlnaHRDZW50ZXIgLSBzaWRlLCBib3R0b20pO1xuXG4gICAgICAgIGN0eC5saW5lVG8obGVmdENlbnRlciArIHNpZGUsIGJvdHRvbSk7XG4gICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGxlZnRDZW50ZXIsIGJvdHRvbSwgbGVmdENlbnRlciAtIGNvc1NJREUsIGJvdHRvbSAtIHNpblNJREUpO1xuICAgICAgICBjdHgubGluZVRvKGxlZnQgKyBjb3NTSURFLCB5ICsgc2luU0lERSk7XG4gICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGxlZnQsIHksIGxlZnQgKyBjb3NTSURFLCB5IC0gc2luU0lERSk7XG4gICAgICAgIGN0eC5saW5lVG8obGVmdENlbnRlciAtIGNvc1NJREUsIHRvcCArIHNpblNJREUpO1xuICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhsZWZ0Q2VudGVyLCB0b3AsIGxlZnRDZW50ZXIgKyBzaWRlLCB0b3ApO1xuXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGlmICh0aGlzLnNoYWRvd0NvbG9yKSB7XG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSB0aGlzLnNoYWRvd0NvbG9yO1xuICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSB0aGlzLnNoYWRvd0JsdXI7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHRoaXMuc2hhZG93T2Zmc2V0WDtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gdGhpcy5zaGFkb3dPZmZzZXRZO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGlmKHRoaXMuYm9yZGVyV2lkdGgpIHtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmJvcmRlcldpZHRoO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5ib3JkZXJDb2xvcjtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmKHRoaXMuX2lzVGFyZ2V0aW5nKSB7XG4gICAgICAgIC8vICAgICB0aGlzLnJlbmRlckZvY3VzKGN0eCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDAuMyknO1xuICAgICAgICAvLyBjdHguZmlsbFJlY3QoeC1odywgeS1oaCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXG5cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuXG4gICAgfVxuXG4gICAgaXNIaXQocG9pbnQpIHtcbiAgICAgICAgaWYoIXRoaXMuX2NhY2hlUG9pbnRzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHBvbHlnb24gPSB0aGlzLl9jYWNoZVBvaW50cztcbiAgICAgICAgbGV0IG9kZCA9IGZhbHNlO1xuICAgICAgICAvLyBGb3IgZWFjaCBlZGdlIChJbiB0aGlzIGNhc2UgZm9yIGVhY2ggcG9pbnQgb2YgdGhlIHBvbHlnb24gYW5kIHRoZSBwcmV2aW91cyBvbmUpXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gcG9seWdvbi5sZW5ndGggLSAxOyBpIDwgcG9seWdvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gSWYgYSBsaW5lIGZyb20gdGhlIHBvaW50IGludG8gaW5maW5pdHkgY3Jvc3NlcyB0aGlzIGVkZ2VcbiAgICAgICAgICAgIGlmICgoKHBvbHlnb25baV1bMV0gPiBwb2ludFsxXSkgIT09IChwb2x5Z29uW2pdWzFdID4gcG9pbnRbMV0pKSAvLyBPbmUgcG9pbnQgbmVlZHMgdG8gYmUgYWJvdmUsIG9uZSBiZWxvdyBvdXIgeSBjb29yZGluYXRlXG4gICAgICAgICAgICAgICAgLy8gLi4uYW5kIHRoZSBlZGdlIGRvZXNuJ3QgY3Jvc3Mgb3VyIFkgY29ycmRpbmF0ZSBiZWZvcmUgb3VyIHggY29vcmRpbmF0ZSAoYnV0IGJldHdlZW4gb3VyIHggY29vcmRpbmF0ZSBhbmQgaW5maW5pdHkpXG4gICAgICAgICAgICAgICAgJiYgKHBvaW50WzBdIDwgKChwb2x5Z29uW2pdWzBdIC0gcG9seWdvbltpXVswXSkgKiAocG9pbnRbMV0gLSBwb2x5Z29uW2ldWzFdKSAvIChwb2x5Z29uW2pdWzFdIC0gcG9seWdvbltpXVsxXSkgKyBwb2x5Z29uW2ldWzBdKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnZlcnQgb2RkXG4gICAgICAgICAgICAgICAgb2RkID0gIW9kZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGogPSBpO1xuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9kZDtcbiAgICB9XG5cbiAgICBnZXRCb3VuZGluZ1JlY3QoKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aCAvMjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIGNvbnN0IGx0eCA9IGFuY2hvclswXSAtIHc7XG4gICAgICAgIGNvbnN0IGx0eSA9IGFuY2hvclsxXSAtIGg7XG4gICAgICAgIGNvbnN0IHJieCA9IGFuY2hvclswXSArIHc7XG4gICAgICAgIGNvbnN0IHJieSA9IGFuY2hvclsxXSArIGg7XG4gICAgICAgIGNvbnN0IGJyID0gdGhpcy5fYm91bmRpbmdyZWN0O1xuICAgICAgICBiclswXSA9IGx0eDtcbiAgICAgICAgYnJbMV0gPSBsdHk7XG4gICAgICAgIGJyWzJdID0gcmJ4O1xuICAgICAgICBiclszXSA9IHJieTtcbiAgICAgICAgcmV0dXJuIGJyXG4gICAgfVxuXG4gICAgZ2V0Qm91bmRpbmdEaW1lbnNpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRJbnRlcnNlY3Rpb25zSW5Gb3VyRGltZW5zaW9uKCkge1xuICAgICAgICBsZXQgcDIgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgaWYodGhpcy5fYmVsb25ncyAmJiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKSB7XG4gICAgICAgICAgICBwMiA9IHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24ocDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgW3gyLCB5Ml0gPSBwMjtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGgvMjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbRElSRUNUSU9OLlJJR0hUXTogIFt4Mit3LCB5Ml0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLkxFRlRdOiAgIFt4Mi13LCB5Ml0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLkJPVFRPTV06IFt4MiwgeTIraF0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLlRPUF06ICAgIFt4MiwgeTItaF0sXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERpYW1vbmQ7IiwiaW1wb3J0IERpYW1vbmQgZnJvbSAnLi9kaWFtb25kJztcbmNvbnN0IGJhY2tzcXJ0MyA9IDEvTWF0aC5zcXJ0KDMpXG5cbi8qKlxuICog5Z6C55u06ZK755+z5b2i5Y2V5YWDXG4gKiBAY29uc3RydWN0b3IgRGlhbW9uZFZlcnRpY2FsXG4gKiBAcGFyYW0ge0RpYW1vbmR+RGlhbW9uZENvbmZpZ3N9IGNvbmZpZ3MgLSDphY3nva5cbiAqIEBleHRlbmRzIERpYW1vbmRcbiAqL1xuY2xhc3MgRGlhbW9uZFZlcnRpY2FsIGV4dGVuZHMgRGlhbW9uZCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlncykge1xuICAgICAgICBzdXBlcihjb25maWdzKVxuICAgIH1cblxuICAgIHJlbmRlcihjdHgpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgaWYodGhpcy5faXNNb3Zpbmcpe1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC42XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb25zdCBbeCwgeV0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgaHcgPSB0aGlzLndpZHRoLzI7XG4gICAgICAgIGNvbnN0IGhoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgY29uc3QgeXkgPSBodyAvIDEuNzMyXG5cbiAgICAgICAgY29uc3QgdG9wID0geSAtIGhoO1xuICAgICAgICBjb25zdCBib3R0b20gPSB5ICsgaGg7XG4gICAgICAgIGNvbnN0IHRvcG1pZGRsZSA9IHkgLSBoaCArIHl5O1xuICAgICAgICBjb25zdCBib3R0b21taWRkbGUgPSB5ICsgaGggLSB5eTtcbiAgICAgICAgY29uc3QgeGxlZnQgPSB4IC0gaHc7XG4gICAgICAgIGNvbnN0IHhyaWdodCA9IHggKyBodztcblxuICAgICAgICBjdHgubW92ZVRvKHgsIHRvcCk7XG4gICAgICAgIGN0eC5saW5lVG8oeHJpZ2h0LCB0b3BtaWRkbGUpO1xuICAgICAgICBjdHgubGluZVRvKHhyaWdodCwgYm90dG9tbWlkZGxlKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4LCBib3R0b20pO1xuICAgICAgICBjdHgubGluZVRvKHhsZWZ0LCBib3R0b21taWRkbGUpO1xuICAgICAgICBjdHgubGluZVRvKHhsZWZ0LCB0b3BtaWRkbGUpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93Q29sb3IpIHtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHRoaXMuc2hhZG93Q29sb3I7XG4gICAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IHRoaXMuc2hhZG93Qmx1cjtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gdGhpcy5zaGFkb3dPZmZzZXRYO1xuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSB0aGlzLnNoYWRvd09mZnNldFk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgaWYodGhpcy5ib3JkZXJXaWR0aCkge1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuYm9yZGVyV2lkdGg7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmJvcmRlckNvbG9yO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgdGhpcy5fY2FjaGVQb2ludHMgPSBbXG4gICAgICAgICAgICBbeCwgdG9wXSxcbiAgICAgICAgICAgIFt4cmlnaHQsIHRvcG1pZGRsZV0sXG4gICAgICAgICAgICBbeHJpZ2h0LCBib3R0b21taWRkbGVdLFxuICAgICAgICAgICAgW3gsIGJvdHRvbV0sXG4gICAgICAgICAgICBbeGxlZnQsIGJvdHRvbW1pZGRsZV0sXG4gICAgICAgICAgICBbeGxlZnQsIHRvcG1pZGRsZV1cbiAgICAgICAgXTtcbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBEaWFtb25kVmVydGljYWw7IiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vbm9kZSc7XG5pbXBvcnQgU3RhY2tNaXhpbiBmcm9tICcuLi9zdGFja01peGluJztcbmltcG9ydCBMYXlvdXRNaXhpbiBmcm9tICcuLi9sYXlvdXRNaXhpbic7XG5pbXBvcnQgUmVjdGFuZ2xlIGZyb20gJy4uL3NoYXBlcy9yZWN0YW5nbGUnO1xuaW1wb3J0IHsgYm91bmRpbmdfYm94LCBkb092ZXJsYXAgfSBmcm9tICcuLi8uLi91dGlscy9mdW5jdGlvbnMnO1xuaW1wb3J0IHsgRElSRUNUSU9OIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uc3RhbmNlJztcbmltcG9ydCB7IFNjcm9sbEJhciB9IGZyb20gJy4uLy4uL3Njcm9sbGJhci9zY3JvbGxiYXJNaXhpbic7XG5jb25zdCBpc2hpdEtleSA9IFN5bWJvbCgnaXNoaXQnKTtcblxuY2xhc3MgSW5uZXJTY3JvbGxCYXIgZXh0ZW5kcyBTY3JvbGxCYXIge1xuICAgIGNvbnN0cnVjdG9yKGRpciwgY29uZmlncyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKGRpciwgY29uZmlncyk7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIGlmKHRoaXMudmlzaWJsZSkge1xuICAgICAgICAgICAgc3VwZXIucmVuZGVyKGN0eCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRIaXQoaXNoaXQpIHtcbiAgICAgICAgaWYodGhpc1tpc2hpdEtleV0gIT09IGlzaGl0KSB7XG4gICAgICAgICAgICB0aGlzLmlzRm9jdXMgPSBpc2hpdFxuICAgICAgICAgICAgdGhpcy5vbkhpdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbaXNoaXRLZXldID0gaXNoaXQ7XG4gICAgfVxufVxuIFxuY2xhc3MgU2Nyb2xsR3JvdXAgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnU2Nyb2xsR3JvdXAnO1xuICAgICAgICB0aGlzLmluaXRTdGFjayhjb25maWdzKTtcbiAgICAgICAgdGhpcy5pbml0TGF5b3V0KGNvbmZpZ3MpO1xuICAgICAgICB0aGlzLmluaXRTY3JvbGxCYXIoY29uZmlncyk7XG4gICAgICAgIHRoaXMuX3NoYXBlID0gbmV3IFJlY3RhbmdsZShjb25maWdzKTtcbiAgICAgICAgdGhpcy5fc2hhcGUuYW5jaG9yID0gWzAsIDBdO1xuICAgICAgICB0aGlzLl9zaGFwZS5fYmVsb25ncyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5tYXhXaWR0aCA9IGNvbmZpZ3MubWF4V2lkdGggfHwgSW5maW5pdHk7XG4gICAgICAgIHRoaXMuZGVmaW5lZFdpZHRoID0gY29uZmlncy5kZWZpbmVkV2lkdGg7XG4gICAgICAgIHRoaXMubWF4SGVpZ2h0ID0gY29uZmlncy5tYXhIZWlnaHQgfHwgSW5maW5pdHk7XG4gICAgICAgIHRoaXMuZGVmaW5lZEhlaWdodCA9IGNvbmZpZ3MuZGVmaW5lZEhlaWdodDtcblxuICAgICAgICB0aGlzLmxvY2sgPSBjb25maWdzLmxvY2sgPz8gdHJ1ZSA7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IFswLCAwXTtcblxuICAgICAgICB0aGlzLl9nZXRCb3VuZGluZ0dyb3VwUmVjdCgpO1xuICAgICAgICB0aGlzLnJlZmxvdygpO1xuICAgICAgICB0aGlzLl9nZXRCb3VuZGluZ0dyb3VwUmVjdCgpOyAgXG4gICAgICAgIHRoaXMuX3Jlc2V0T2Zmc2V0KCk7XG4gICAgICAgIHRoaXMuX2NhY2hlVmlld0JveCA9IFtdXG5cbiAgICB9XG5cbiAgICBpbml0U2Nyb2xsQmFyKGNvbmZpZ3MpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgYmFyQ29sb3IsXG4gICAgICAgICAgICBiYXJGb2N1c0NvbG9yLFxuICAgICAgICAgICAgYmFyTWFyZ2luWCxcbiAgICAgICAgICAgIGJhck1hcmdpblksXG4gICAgICAgICAgICBiYXJXaWR0aCxcbiAgICAgICAgfSA9IGNvbmZpZ3M7XG4gICAgICAgIHRoaXMuX3Njcm9sbGJhclggPSBuZXcgSW5uZXJTY3JvbGxCYXIoJ3gnLCB7XG4gICAgICAgICAgICBwbGFpbkNvbG9yOiBiYXJDb2xvcixcbiAgICAgICAgICAgIGZvY3VzQ29sb3I6IGJhckZvY3VzQ29sb3IsXG4gICAgICAgICAgICBiYXJXaWR0aCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3Njcm9sbGJhclkgPSBuZXcgSW5uZXJTY3JvbGxCYXIoJ3knLCB7XG4gICAgICAgICAgICBwbGFpbkNvbG9yOiBiYXJDb2xvcixcbiAgICAgICAgICAgIGZvY3VzQ29sb3I6IGJhckZvY3VzQ29sb3IsXG4gICAgICAgICAgICBiYXJXaWR0aFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWC5iYXJNYXJnaW5YID0gYmFyTWFyZ2luWCB8fCAxO1xuICAgICAgICB0aGlzLl9zY3JvbGxiYXJZLmJhck1hcmdpblkgPSBiYXJNYXJnaW5ZIHx8IDE7XG4gICAgICAgIGNvbnN0IF9mID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5famZsb3cuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zY3JvbGxiYXJYLm9uSGl0ID0gX2Y7XG4gICAgICAgIHRoaXMuX3Njcm9sbGJhclkub25IaXQgPSBfZjtcblxuICAgICAgICB0aGlzLl9zY3JvbGxCYXJTdGF0dXMgPSB7XG4gICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICB0YXJnZXQ6IG51bGwsXG5cbiAgICAgICAgICAgIGJhckluaXRYOiAwLFxuICAgICAgICAgICAgYmFySW5pdFk6IDAsXG4gICAgICAgICAgICBiYXJTdGFydFg6IDAsXG4gICAgICAgICAgICBiYXJTdGFydFk6IDAsXG5cbiAgICAgICAgICAgIGhpdFNjcm9sbFg6IGZhbHNlLFxuICAgICAgICAgICAgaGl0U2Nyb2xsWTogZmFsc2UsXG4gICAgICAgIH1cbiAgICAgICAgLy8gLy8gY29uc3QgamZsb3dJbnN0YW5jZSA9IHRoaXMuX2pmbG93O1xuICAgICAgICAvLyB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2luc3RhbmNlbW91c2Vtb3ZlJywgZSA9PiB7XG4gICAgICAgIC8vICAgICBpZih0aGlzLl9zY3JvbGxCYXJTdGF0dXMuaGl0U2Nyb2xsWCkge1xuICAgICAgICAvLyAgICAgICAgIGlmKCF0aGlzLl9zY3JvbGxiYXJYLmlzRm9jdXMpIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWC5pc0ZvY3VzID0gdHJ1ZTtcbiAgICAgICAgLy8gICAgICAgICAgICAgZS5kZXRhaWwuamZsb3cuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgIC8vICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyAgICAgaWYodGhpcy5fc2Nyb2xsYmFyWC5pc0ZvY3VzKSB7XG4gICAgICAgIC8vICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWC5pc0ZvY3VzID0gZmFsc2U7XG4gICAgICAgIC8vICAgICAgICAgZS5kZXRhaWwuamZsb3cuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIH0pXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignaW5zdGFuY2VQcmVzc1N0YXJ0JywgZSA9PiB7XG4gICAgICAgICAgICBpZih0aGlzLl9zY3JvbGxCYXJTdGF0dXMuaGl0U2Nyb2xsWCkge1xuICAgICAgICAgICAgICAgIGUuZGV0YWlsLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5kZXRhaWwuYnViYmxlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFggPSBlLmRldGFpbC5ldmVudC5jbGllbnRYO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fc2Nyb2xsQmFyU3RhdHVzLCB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdnaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMuX3Njcm9sbGJhclgsXG4gICAgICAgICAgICAgICAgICAgIGJhclN0YXJ0WDogdGhpcy5fc2Nyb2xsYmFyWC5hbmNob3JbMF0sXG4gICAgICAgICAgICAgICAgICAgIGJhckluaXRYOiBjbGllbnRYLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMub25TY3JvbGxiYXJQcmVzc1N0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLl9zY3JvbGxCYXJTdGF0dXMuaGl0U2Nyb2xsWSkge1xuICAgICAgICAgICAgICAgIGUuZGV0YWlsLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5kZXRhaWwuYnViYmxlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFkgPSBlLmRldGFpbC5ldmVudC5jbGllbnRZO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fc2Nyb2xsQmFyU3RhdHVzLCB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdnaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMuX3Njcm9sbGJhclksXG4gICAgICAgICAgICAgICAgICAgIGJhclN0YXJ0WTogdGhpcy5fc2Nyb2xsYmFyWS5hbmNob3JbMV0sXG4gICAgICAgICAgICAgICAgICAgIGJhckluaXRZOiBjbGllbnRZLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMub25TY3JvbGxiYXJQcmVzc1N0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgb25TY3JvbGxiYXJQcmVzc1N0YXJ0KCkge1xuICAgICAgICBjb25zdCBqZmxvd0luc3RhbmNlID0gdGhpcy5famZsb3c7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGpmbG93SW5zdGFuY2UuY2FudmFzO1xuICAgICAgICBjb25zdCBmID0gKGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBjbGllbnRYLCBjbGllbnRZIH0gPSBlO1xuICAgICAgICAgICAgdGhpcy5vbkRyYWdnaW5nU2Nyb2xsYmFyKGNsaWVudFgsIGNsaWVudFkpXG4gICAgICAgIH0pLmJpbmQodGhpcyk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgZik7XG4gICAgICAgIGNvbnN0IHQgPSAoZSA9PiB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3Njcm9sbEJhclN0YXR1cywge1xuICAgICAgICAgICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgICAgICAgICAgYmFySW5pdFg6IDAsXG4gICAgICAgICAgICAgICAgYmFySW5pdFk6IDAsXG4gICAgICAgICAgICAgICAgYmFyU3RhcnRYOiAwLFxuICAgICAgICAgICAgICAgIGJhclN0YXJ0WTogMCxcbiAgICAgICAgICAgICAgICBoaXRTY3JvbGxYOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBoaXRTY3JvbGxZOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBmKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHQpO1xuICAgICAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHQpO1xuICAgICAgICB9KS5iaW5kKHRoaXMpO1xuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdCwge1xuICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCB0LCB7XG4gICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgb25EcmFnZ2luZ1Njcm9sbGJhcihjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgICAgIGlmKHRoaXMuX3Njcm9sbGJhclgudmlzaWJsZSAmJiB0aGlzLl9zY3JvbGxCYXJTdGF0dXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IEpGTE9XID0gdGhpcy5famZsb3c7XG4gICAgICAgICAgICBjb25zdCBzY2FsZSA9IEpGTE9XLnNjYWxlO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICBiYXJJbml0WCxcbiAgICAgICAgICAgICAgICBiYXJTdGFydFgsXG4gICAgICAgICAgICAgICAgYmFySW5pdFksXG4gICAgICAgICAgICAgICAgYmFyU3RhcnRZXG4gICAgICAgICAgICB9ID0gdGhpcy5fc2Nyb2xsQmFyU3RhdHVzO1xuICAgICAgICAgICAgaWYodGFyZ2V0LmRpciA9PT0gJ3gnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgX3Njcm9sbFdpZHRoID0gdGhpcy5fc2Nyb2xsYmFyWC53aWR0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBfb3V0ZXJXaWR0aCA9IHRoaXMuX291dGVyV2lkdGg7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGFYID0gY2xpZW50WCAtIGJhckluaXRYO1xuICAgICAgICAgICAgICAgIGNvbnN0IHhuZXcgPSBiYXJTdGFydFggKyBkZWx0YVggLyBzY2FsZTtcbiAgICAgICAgICAgICAgICBjb25zdCBxID0gdGFyZ2V0LmFuY2hvclswXSA9IE1hdGgubWF4KE1hdGgubWluKHhuZXcsIF9vdXRlcldpZHRoIC0gX3Njcm9sbFdpZHRoKSwgMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF0aW9JblggPSBxIC8gKF9vdXRlcldpZHRoIC0gX3Njcm9sbFdpZHRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gKHRoaXMuX2lubmVyV2lkdGggLSBfb3V0ZXJXaWR0aCkvMjtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXRbMF0gPSBzIC0gKHRoaXMuX2lubmVyV2lkdGggLSBfb3V0ZXJXaWR0aCkgKiByYXRpb0luWFxuICAgICAgICAgICAgICAgIEpGTE9XLnNjaGVkdWxlUmVuZGVyKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodGFyZ2V0LmRpciA9PT0gJ3knKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgX3Njcm9sbEhlaWdodCA9IHRoaXMuX3Njcm9sbGJhclkuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNvbnN0IF9vdXRlckhlaWdodCA9IHRoaXMuX291dGVySGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhWSA9IGNsaWVudFkgLSBiYXJJbml0WTtcbiAgICAgICAgICAgICAgICBjb25zdCB5bmV3ID0gYmFyU3RhcnRZICsgZGVsdGFZIC8gc2NhbGU7XG4gICAgICAgICAgICAgICAgY29uc3QgcSA9IHRhcmdldC5hbmNob3JbMV0gPSBNYXRoLm1heChNYXRoLm1pbih5bmV3LCBfb3V0ZXJIZWlnaHQgLSBfc2Nyb2xsSGVpZ2h0KSwgMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF0aW8gPSBxIC8gKF9vdXRlckhlaWdodCAtIF9zY3JvbGxIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSAodGhpcy5faW5uZXJIZWlnaHQgLSBfb3V0ZXJIZWlnaHQpLzI7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0WzFdID0gcyAtICh0aGlzLl9pbm5lckhlaWdodCAtIF9vdXRlckhlaWdodCkgKiByYXRpb1xuICAgICAgICAgICAgICAgIEpGTE9XLnNjaGVkdWxlUmVuZGVyKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgc2V0Q29uZmlnKGNvbmZpZ3MpIHtcbiAgICAgICAgdGhpcy5fc2hhcGUuc2V0Q29uZmlnKGNvbmZpZ3MpO1xuICAgIH1cblxuICAgIF9nZXRCb3VuZGluZ0dyb3VwUmVjdCgpIHtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gdGhpcy5fc3RhY2suZ2V0Qm91bmRpbmdSZWN0UG9pbnRzKCk7XG4gICAgICAgIC8vIGNvbnRlbnQgYm94IFxuICAgICAgICBjb25zdCBiYm94ID0gYm91bmRpbmdfYm94KHBvaW50cyk7XG4gICAgICAgIGNvbnN0IHcgPSBiYm94LndpZHRoO1xuICAgICAgICBjb25zdCBoID0gYmJveC5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IG91dGVyV2lkdGggPSB0aGlzLmRlZmluZWRXaWR0aCB8fCBNYXRoLm1pbih3LCB0aGlzLm1heFdpZHRoKTtcbiAgICAgICAgY29uc3Qgb3V0ZXJIZWlnaHQgPSB0aGlzLmRlZmluZWRIZWlnaHQgfHwgTWF0aC5taW4oaCwgdGhpcy5tYXhIZWlnaHQpO1xuICAgICAgICB0aGlzLl9pbm5lcldpZHRoID0gdztcbiAgICAgICAgdGhpcy5fb3V0ZXJXaWR0aCA9IG91dGVyV2lkdGg7XG4gICAgICAgIHRoaXMuX2lubmVySGVpZ2h0ID0gaDtcbiAgICAgICAgdGhpcy5fb3V0ZXJIZWlnaHQgPSBvdXRlckhlaWdodDtcblxuICAgICAgICB0aGlzLl9zaGFwZS53aWR0aCA9IG91dGVyV2lkdGg7XG4gICAgICAgIHRoaXMuX3NoYXBlLmhlaWdodCA9IG91dGVySGVpZ2h0O1xuICAgICAgICB0aGlzLndpZHRoID0gb3V0ZXJXaWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBvdXRlckhlaWdodDtcbiAgICB9XG5cbiAgICBfY2FsY3VsYXRlUG9pbnRCYWNrKHBvaW50KSB7XG4gICAgICAgIGNvbnN0IFtneCwgZ3ldID0gcG9pbnQ7XG4gICAgICAgIGNvbnN0IFt0eCwgdHldID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgICBjb25zdCBbY3gsIGN5XSA9IHRoaXMuYW5jaG9yOyBcbiAgICAgICAgY29uc3QgcCA9IFtneCAtIGN4IC0gdHgsIGd5IC0gY3kgLSB0eV1cbiAgICAgICAgcmV0dXJuIHBcbiAgICB9XG5cbiAgICBfY2FsY3VsYXRlUG9pbnRCYWNrV2l0aFBvaW50KGEsIGIsIGFyciwgaWR4MSwgaWR4Mikge1xuICAgICAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgICBhcnJbaWR4MV0gPSBhIC0gYW5jaG9yWzBdIC0gb2Zmc2V0WzBdO1xuICAgICAgICBhcnJbaWR4Ml0gPSBiIC0gYW5jaG9yWzFdIC0gb2Zmc2V0WzFdO1xuICAgIH1cblxuICAgIGNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKHBvaW50KSB7XG4gICAgICAgIGNvbnN0IFtneCwgZ3ldID0gcG9pbnQ7XG4gICAgICAgIGNvbnN0IFtjeCwgY3ldID0gdGhpcy5hbmNob3I7ICBcbiAgICAgICAgY29uc3QgW3R4LCB0eV0gPSB0aGlzLl9vZmZzZXQ7XG4gICAgICAgIGNvbnN0IHAgPSBbZ3ggKyBjeCAtIHR4LCBneSArIGN5IC0gdHldXG4gICAgICAgIGlmKHRoaXMuX2JlbG9uZ3MgJiYgdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24ocCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhbGN1bGF0ZVRvUmVhbFdvcmxkKHBvaW50KSB7XG4gICAgICAgIGNvbnN0IFtneCwgZ3ldID0gcG9pbnQ7XG4gICAgICAgIGNvbnN0IFtjeCwgY3ldID0gdGhpcy5hbmNob3I7ICBcbiAgICAgICAgY29uc3QgW3R4LCB0eV0gPSB0aGlzLl9vZmZzZXQ7XG4gICAgICAgIGNvbnN0IHAgPSBbZ3ggKyBjeCAtIHR4LCBneSArIGN5IC0gdHldXG4gICAgICAgIGlmKHRoaXMuX2JlbG9uZ3MgJiYgdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb1JlYWxXb3JsZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9SZWFsV29ybGQocCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxjdWxhdGVUb1JlYWxXb3JsZFdpdGhQb2ludGVyKG91dHBvaW50LCBpbnBvaW50KSB7XG4gICAgICAgIG91dHBvaW50WzBdID0gaW5wb2ludFswXSArIHRoaXMuYW5jaG9yWzBdIC0gdGhpcy5vZmZzZXRbMF07XG4gICAgICAgIG91dHBvaW50WzFdID0gaW5wb2ludFsxXSArIHRoaXMuYW5jaG9yWzFdIC0gdGhpcy5vZmZzZXRbMV07XG4gICAgICAgIGlmKHRoaXMuX2JlbG9uZ3MgJiYgdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb1JlYWxXb3JsZFdpdGhQb2ludGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb1JlYWxXb3JsZFdpdGhQb2ludGVyKG91dHBvaW50LCBvdXRwb2ludCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0Vmlld0JveCgpIHtcbiAgICAgICAgY29uc3QgYmVsb25nc192Ym94ID0gdGhpcy5fYmVsb25ncy5nZXRDYWNoZVZpZXdCb3goKTtcbiAgICAgICAgY29uc3QgY2FjaGVWaWV3Qm94ID0gdGhpcy5fY2FjaGVWaWV3Qm94O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlUG9pbnRCYWNrV2l0aFBvaW50KGJlbG9uZ3NfdmJveFswXSwgYmVsb25nc192Ym94WzFdLCBjYWNoZVZpZXdCb3gsIDAsIDEpO1xuICAgICAgICB0aGlzLl9jYWxjdWxhdGVQb2ludEJhY2tXaXRoUG9pbnQoYmVsb25nc192Ym94WzJdLCBiZWxvbmdzX3Zib3hbM10sIGNhY2hlVmlld0JveCwgMiwgMyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZVZpZXdCb3g7XG4gICAgfVxuXG4gICAgZ2V0Q2FjaGVWaWV3Qm94KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVWaWV3Qm94O1xuICAgIH1cblxuICAgIF9yZXNldE9mZnNldCgpIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gW1xuICAgICAgICAgICAgTWF0aC5tYXgoKHRoaXMuX2lubmVyV2lkdGggLSB0aGlzLl9vdXRlcldpZHRoKS8yLCAwKSxcbiAgICAgICAgICAgIE1hdGgubWF4KCh0aGlzLl9pbm5lckhlaWdodCAtIHRoaXMuX291dGVySGVpZ2h0KS8yLCAwKSxcbiAgICAgICAgXTtcbiAgICAgICAgaWYodGhpcy5faW5uZXJXaWR0aCA+IHRoaXMuX291dGVyV2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbGJhclgudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxiYXJYLndpZHRoID0gdGhpcy5fb3V0ZXJXaWR0aCAqIHRoaXMuX291dGVyV2lkdGggLyB0aGlzLl9pbm5lcldpZHRoO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWC5hbmNob3IgPSBbMCwgdGhpcy5fb3V0ZXJIZWlnaHQgLSA0XVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5faW5uZXJIZWlnaHQgPiB0aGlzLl9vdXRlckhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbGJhclkuaGVpZ2h0ID0gdGhpcy5fb3V0ZXJIZWlnaHQgKiB0aGlzLl9vdXRlckhlaWdodCAvIHRoaXMuX2lubmVySGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWS5hbmNob3IgPSBbdGhpcy5fb3V0ZXJXaWR0aCAtIDQsIDBdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxiYXJZLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcihjdHgpIHtcbiAgICAgICAgaWYodGhpcy5faXNNb3Zpbmcpe1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC42XG4gICAgICAgIH0gZWxzZSBpZih0aGlzLm9wYWNpdHkgIT09IDEpIHtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMub3BhY2l0eTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbY3gsIGN5XSA9IHRoaXMuYW5jaG9yOyBcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGg7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodDtcbiAgICAgICAgY29uc3QgdzIgPSB3LzI7XG4gICAgICAgIGNvbnN0IGgyID0gaC8yO1xuICAgICAgICAvLyBpZigodGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0KSAqIHRoaXMuX2pmbG93LnNjYWxlIDwgMTQ0KSB7XG4gICAgICAgIC8vICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAvLyAgICAgcmV0dXJuO1xuICAgICAgICAvLyB9XG4gICAgICAgIGNvbnN0IFt0eCwgdHldID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgICBjdHgudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgIHRoaXMuX3NoYXBlLnJlbmRlcihjdHgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKC13MiwgLWgyKTtcbiAgICAgICAgaWYodGhpcy5fc2Nyb2xsYmFyWC52aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxiYXJYLnJlbmRlcihjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuX3Njcm9sbGJhclkudmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWS5yZW5kZXIoY3R4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC50cmFuc2xhdGUodzIsIGgyKTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgucmVjdCgtdzIsIC1oMiwgdywgaCk7XG4gICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgICAgdGhpcy5fc3RhY2sucmVuZGVyKGN0eCk7XG4gICAgICAgIHRoaXMuX2xpbmtTdGFjay5yZW5kZXIoY3R4KTsgICAgXG4gICAgICAgIGN0eC50cmFuc2xhdGUoLWN4LXR4LCAtY3ktdHkpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGlzSGl0KHBvaW50LCBjb25kaXRpb24pIHtcbiAgICAgICAgY29uc3QgW2d4LCBneV0gPSBwb2ludDtcbiAgICAgICAgY29uc3QgW2N4LCBjeV0gPSB0aGlzLmFuY2hvcjsgXG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoLzI7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICBjb25zdCBzcCA9IFtneCAtIGN4ICsgdywgZ3kgLSBjeSArIGhdXG4gICAgICAgIHRoaXMuX3Njcm9sbEJhclN0YXR1cy5oaXRTY3JvbGxYID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Njcm9sbEJhclN0YXR1cy5oaXRTY3JvbGxZID0gZmFsc2U7XG4gICAgICAgIGlmKHRoaXMuX3Njcm9sbGJhclgudmlzaWJsZSkge1xuICAgICAgICAgICAgY29uc3QgeGhpdCA9IHRoaXMuX3Njcm9sbGJhclguaXNIaXQoc3ApO1xuICAgICAgICAgICAgaWYoeGhpdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbEJhclN0YXR1cy5oaXRTY3JvbGxYID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxiYXJYLnNldEhpdCh0cnVlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Njcm9sbGJhclguc2V0SGl0KGZhbHNlKVxuXG4gICAgICAgIGlmKHRoaXMuX3Njcm9sbGJhclkudmlzaWJsZSkge1xuICAgICAgICAgICAgY29uc3QgeWhpdCA9IHRoaXMuX3Njcm9sbGJhclkuaXNIaXQoc3ApO1xuICAgICAgICAgICAgaWYoeWhpdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbEJhclN0YXR1cy5oaXRTY3JvbGxZID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxiYXJZLnNldEhpdCh0cnVlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Njcm9sbGJhclkuc2V0SGl0KGZhbHNlKVxuICAgICAgIFxuICAgICAgICAvLyBjb25zdCBiciA9IHRoaXMuX2dldFZpZXdCb3goKTtcbiAgICAgICAgY29uc3QgaXNJbkJvdW5kID0gdGhpcy5fc2hhcGUuaXNIaXQoW2d4IC0gY3gsIGd5IC0gY3ldKTtcbiAgICAgICAgaWYoaXNJbkJvdW5kKSB7XG4gICAgICAgICAgICBjb25zdCBbdHgsIHR5XSA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBbZ3ggLSBjeCAtIHR4LCBneSAtIGN5IC0gdHldO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudHAgPSBwOyAvLyDmmoLlrZjvvIzkuLrkuoblkI7nu63orqHnrpfliKvnmoTkvY3nva5cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX3N0YWNrLmNoZWNrSGl0KHAsIGNvbmRpdGlvbik7IFxuICAgICAgICAgICAgaWYodGFyZ2V0KSByZXR1cm4gdGFyZ2V0OyBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YWNrLnJlc2V0SGl0U3RhdHVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGdldEJvdW5kaW5nRGltZW5zaW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Qm91bmRpbmdSZWN0KCkge1xuICAgICAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGggLzI7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICBjb25zdCBsdHggPSBhbmNob3JbMF0gLSB3O1xuICAgICAgICBjb25zdCBsdHkgPSBhbmNob3JbMV0gLSBoO1xuICAgICAgICBjb25zdCByYnggPSBhbmNob3JbMF0gKyB3O1xuICAgICAgICBjb25zdCByYnkgPSBhbmNob3JbMV0gKyBoO1xuICAgICAgICBjb25zdCBiciA9IHRoaXMuX2JvdW5kaW5ncmVjdDtcbiAgICAgICAgYnJbMF0gPSBsdHg7XG4gICAgICAgIGJyWzFdID0gbHR5O1xuICAgICAgICBiclsyXSA9IHJieDtcbiAgICAgICAgYnJbM10gPSByYnk7XG4gICAgICAgIHJldHVybiBiclxuICAgIH1cblxuICAgIGdldEludGVyc2VjdGlvbnNJbkZvdXJEaW1lbnNpb24oKSB7XG4gICAgICAgIGxldCBwMiA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBpZih0aGlzLl9iZWxvbmdzICYmIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24pIHtcbiAgICAgICAgICAgIHAyID0gdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbihwMik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBbeDIsIHkyXSA9IHAyO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aC8yO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtESVJFQ1RJT04uUklHSFRdOiAgW3gyK3csIHkyXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uTEVGVF06ICAgW3gyLXcsIHkyXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uQk9UVE9NXTogW3gyLCB5MitoXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uVE9QXTogICAgW3gyLCB5Mi1oXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uU0VMRl06ICAgW3gyK3cqMC42MTgsIHkyK2gqMC42MThdXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkVudGVyVmlld2JveCgpIHtcbiAgICAgICAgdGhpcy5pbnRlcmF0ZU5vZGVTdGFjaygoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICAgIGluc3RhbmNlLm9uRW50ZXJWaWV3Ym94KCk7XG4gICAgICAgIH0pXG4gICAgfVxuICAgIG9uTGVhdmVWaWV3Ym94KCkge1xuICAgICAgICB0aGlzLmludGVyYXRlTm9kZVN0YWNrKChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgICAgaW5zdGFuY2Uub25MZWF2ZVZpZXdib3goKTtcbiAgICAgICAgfSlcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fc2hhcGUuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmludGVyYXRlTm9kZVN0YWNrKChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgICAgaW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgICB9KVxuICAgIH1cblxuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBDID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgY29uc3QgY29uZmlncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3Jhd0NvbmZpZ3MsIHtcbiAgICAgICAgICAgIGxheW91dDogdGhpcy5fbGF5b3V0ICYmIHRoaXMuX2xheW91dC5jbG9uZSgpLFxuICAgICAgICB9KVxuICAgICAgICBjb25zdCB0ID0gbmV3IEMoY29uZmlncyk7XG4gICAgICAgIHRoaXMuaW50ZXJhdGVOb2RlU3RhY2soKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICB0LmFkZFRvU3RhY2soaW5zdGFuY2UuY2xvbmUoKSk7XG4gICAgICAgIH0pXG4gICAgICAgIHQucmVjYWxjdWxhdGUoKTtcbiAgICAgICAgdC52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG59XG5cbk9iamVjdC5hc3NpZ24oU2Nyb2xsR3JvdXAucHJvdG90eXBlLCBTdGFja01peGluKTtcbk9iamVjdC5hc3NpZ24oU2Nyb2xsR3JvdXAucHJvdG90eXBlLCBMYXlvdXRNaXhpbik7XG5PYmplY3QuYXNzaWduKFNjcm9sbEdyb3VwLnByb3RvdHlwZSwge1xuICAgIHJlY2FsY3VsYXRlVXAoKSB7XG4gICAgICAgIGxldCBkaXJ0eSA9IHRydWU7XG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLmdldEJvdW5kaW5nRGltZW5zaW9uKSB7XG4gICAgICAgICAgICAvLyBjb25zdCB7IHdpZHRoOiB3b2xkLCBoZWlnaHQ6IGhvbGQgfSA9IHRoaXMuZ2V0Qm91bmRpbmdEaW1lbnNpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHdvbGQgPSB0aGlzLl9pbm5lcldpZHRoO1xuICAgICAgICAgICAgY29uc3QgaG9sZCA9IHRoaXMuX2lubmVySGVpZ2h0O1xuICAgICAgICAgICAgaWYodGhpcy5yZXNldENoaWxkcmVuUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Q2hpbGRyZW5Qb3NpdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5fZ2V0Qm91bmRpbmdHcm91cFJlY3Qpe1xuICAgICAgICAgICAgICAgIHRoaXMuX2dldEJvdW5kaW5nR3JvdXBSZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlZmxvdygpO1xuICAgICAgICAgICAgaWYodGhpcy5fZ2V0Qm91bmRpbmdHcm91cFJlY3Qpe1xuICAgICAgICAgICAgICAgIHRoaXMuX2dldEJvdW5kaW5nR3JvdXBSZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3bm93ID0gdGhpcy5faW5uZXJXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGhub3cgPSB0aGlzLl9pbm5lckhlaWdodDtcbiAgICAgICAgICAgIC8vIGNvbnN0IHsgd2lkdGg6IHdub3csIGhlaWdodDogaG5vdyB9ID0gdGhpcy5nZXRCb3VuZGluZ0RpbWVuc2lvbigpO1xuICAgICAgICAgICAgZGlydHkgPSAod29sZCAhPT0gd25vdyB8fCBob2xkICE9PSBobm93KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWZsb3coKTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLl9iZWxvbmdzICYmIGRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNldE9mZnNldCgpO1xuICAgICAgICAgICAgdGhpcy5fYmVsb25ncy5yZWNhbGN1bGF0ZVVwKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVjYWxjdWxhdGUoKSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGg6IHdvbGQsIGhlaWdodDogaG9sZCB9ID0gdGhpcy5nZXRCb3VuZGluZ0RpbWVuc2lvbigpO1xuICAgICAgICB0aGlzLnJlZmxvdygpO1xuICAgICAgICBpZih0aGlzLl9nZXRCb3VuZGluZ0dyb3VwUmVjdCl7XG4gICAgICAgICAgICB0aGlzLl9nZXRCb3VuZGluZ0dyb3VwUmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgd2lkdGg6IHdub3csIGhlaWdodDogaG5vdyB9ID0gdGhpcy5nZXRCb3VuZGluZ0RpbWVuc2lvbigpO1xuICAgICAgICBpZiAod29sZCAhPT0gd25vdyB8fCBob2xkICE9PSBobm93KSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNldE9mZnNldCgpO1xuICAgICAgICB9XG4gICAgfSxcbn0pXG5cblxuZXhwb3J0IGRlZmF1bHQgU2Nyb2xsR3JvdXAiLCJleHBvcnQgZGVmYXVsdCB7XG4gICAgY2FudmFzOiB7XG4gICAgICAgIHdoZWVsIChldmVudCwgamZsb3cpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBsZXQgeyBvZmZzZXRYLCBvZmZzZXRZLCBkZWx0YVgsIGRlbHRhWSB9ID0gZXZlbnQgXG4gICAgICAgICAgICBpZihldmVudC5jdHJsS2V5KSB7IFxuICAgICAgICAgICAgICAgIGRlbHRhWSA9IC1kZWx0YVk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqZmxvdy56b29tSGFuZGxlcihvZmZzZXRYLCBvZmZzZXRZLCBkZWx0YVgsIGRlbHRhWSwgZXZlbnQpO1xuICAgICAgICB9LFxuICAgIH1cbn0iLCJpbXBvcnQgSW5zdGFuY2UgZnJvbSAnLi9pbnN0YW5jZSc7XG5cbi8qKlxuICogQHR5cGVkZWYge0luc3RhbmNlfkNvbmZpZ3N9IEJhc2VMaW5rfkNvbmZpZ3NcbiAqIEBwcm9wZXJ0eSB7SW5zdGFuY2V9IGZyb20gICAtIOi1t+Wni+WNleWFg1xuICogQHByb3BlcnR5IHtJbnN0YW5jZX0gdG8gICAgIC0g57uI5q2i5Y2V5YWDXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZnJvbURpciAgLSDotbflp4vmlrnlkJEgXG4gKiBAcHJvcGVydHkge1N0cmluZ30gdG9EaXIgICAgLSDnu4jmraLmlrnlkJEgXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5ICAgICAgLSDov57nur/llK/kuIDplK7lgLxcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBiYWNrZ3JvdW5kQ29sb3IgICAgLSDnur/mnaHpopzoibIgXG4gKi9cbi8qKlxuICog6L+e57q/5Z+657G7XG4gKiBAY29uc3RydWN0b3IgQmFzZUxpbmtcbiAqIEBleHRlbmRzIEluc3RhbmNlXG4gKiBAcGFyYW0ge0Jhc2VMaW5rfkNvbmZpZ3N9IGNvbmZpZ3MgLSDphY3nva5cbiAqL1xuY2xhc3MgQmFzZUxpbmsgZXh0ZW5kcyBJbnN0YW5jZXtcbiAgICBJTlNUQU5DRV9UWVBFID0gJ0xJTksnXG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICBpZighdGhpcy5fYmVsb25ncykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhY2sgPSB0aGlzLl9iZWxvbmdzLl9saW5rU3RhY2tcbiAgICAgICAgY29uc3QgaWR4ID0gc3RhY2suZmluZEluZGV4KHMgPT4gcyA9PT0gdGhpcyk7XG4gICAgICAgIGlmKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja1tpZHgrMV07XG4gICAgICAgIH0gXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqIEBtZW1iZXIge0luc3RhbmNlfSAgICAgIC0g6LW35aeL5Y2V5YWDICovXG4gICAgICAgIHRoaXMuZnJvbSAgICAgPSBjb25maWdzLmZyb207XG4gICAgICAgIC8qKiBAbWVtYmVyIHtJbnN0YW5jZX0gICAgICAtIOe7iOatouWNleWFgyAqL1xuICAgICAgICB0aGlzLnRvICAgICAgID0gY29uZmlncy50bztcbiAgICAgICAgLyoqIEBtZW1iZXIge0RJUkVDVElPTn0gICAgICAtIOi1t+Wni+aWueWQkSAqL1xuICAgICAgICB0aGlzLmZyb21EaXIgID0gY29uZmlncy5mcm9tRGlyO1xuICAgICAgICAvKiogQG1lbWJlciB7RElSRUNUSU9OfSAgICAgIC0g57uI5q2i5pa55ZCRICovXG4gICAgICAgIHRoaXMudG9EaXIgICAgPSBjb25maWdzLnRvRGlyO1xuICAgICAgICAvKiogQG1lbWJlciB7bnVtYmVyW11bXX0gICAgIC0g6L+e57q/5o6n5Yi254K557yT5a2YICovXG4gICAgICAgIHRoaXMuX2NhY2hlUG9pbnRzID0gbnVsbDtcbiAgICAgICAgLyoqIEBtZW1iZXIge3N0cmluZ30gICAgIC0g6L+e57q/6aKc6Imy77yM6buY6K6k5Li6ICMwMDAgKi9cbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBjb25maWdzLmJhY2tncm91bmRDb2xvciB8fCAnIzAwMCc7XG5cbiAgICAgICAgdGhpcy5pc1NlbGYgICAgICAgID0gISFjb25maWdzLmlzU2VsZlxuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiDmmK/lkKblh7rnjrDlnKjlvZPliY3op4bnqpflhoVcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSB2aWV3Ym94XG4gICAgICovXG4gICAgaXNJblZpZXdCb3godmlld2JveCl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGJyaW5nVG9Ub3AoKSB7XG4gICAgICAgIGNvbnN0IGxpbmtTdGFjayA9IHRoaXMuX2pmbG93Ll9saW5rU3RhY2s7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbGlua1N0YWNrLmZpbmRJbmRleChsID0+IGwgPT09IHRoaXMpO1xuICAgICAgICBsaW5rU3RhY2suc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgbGlua1N0YWNrLnB1c2godGhpcyk7XG4gICAgICAgIHRoaXMuX2pmbG93Ll9yZW5kZXIoKTtcbiAgICB9XG5cbiAgICBcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZUxpbms7IiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vbm9kZSc7XG5cbmNsYXNzIFNoYWRvd0NhY2hlIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlncykge1xuICAgICAgICBzdXBlcihjb25maWdzKTtcbiAgICAgICAgLy8gdGhpcy5pbWFnZURhdGEgPSBjb25maWdzLmltYWdlRGF0YTtcbiAgICAgICAgdGhpcy53aWR0aCA9IGNvbmZpZ3Mud2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gY29uZmlncy5oZWlnaHQ7XG4gICAgICAgIHRoaXMuaW1hZ2VCdWZmZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdGhpcy5pbWFnZUJ1ZmZlci53aWR0aCA9IHRoaXMud2lkdGggKyAyO1xuICAgICAgICB0aGlzLmltYWdlQnVmZmVyLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgMjtcbiAgICAgICAgY29uZmlncy5jYWNoZSh0aGlzLmltYWdlQnVmZmVyLmdldENvbnRleHQoJzJkJykpO1xuICAgIH1cblxuICAgIHJlbmRlcihjdHgpIHtcbiAgICAgICAgY29uc3QgW2N4LCBjeV0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShjeCwgY3kpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5pbWFnZUJ1ZmZlciwgLXRoaXMud2lkdGgvMiwgLXRoaXMuaGVpZ2h0LzIpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKC1jeCwgLWN5KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBnZXRCb3VuZGluZ0RpbWVuc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlY2FsY3VsYXRlKCl7fVxuICAgIGdldEJvdW5kaW5nUmVjdCgpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoIC8yO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgY29uc3QgbHR4ID0gYW5jaG9yWzBdIC0gdztcbiAgICAgICAgY29uc3QgbHR5ID0gYW5jaG9yWzFdIC0gaDtcbiAgICAgICAgY29uc3QgcmJ4ID0gYW5jaG9yWzBdICsgdztcbiAgICAgICAgY29uc3QgcmJ5ID0gYW5jaG9yWzFdICsgaDtcbiAgICAgICAgY29uc3QgYnIgPSB0aGlzLl9ib3VuZGluZ3JlY3Q7XG4gICAgICAgIGJyWzBdID0gbHR4O1xuICAgICAgICBiclsxXSA9IGx0eTtcbiAgICAgICAgYnJbMl0gPSByYng7XG4gICAgICAgIGJyWzNdID0gcmJ5O1xuICAgICAgICByZXR1cm4gYnJcbiAgICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgU2hhZG93Q2FjaGU7IiwiaW1wb3J0IFJlY3RhbmdsZSBmcm9tIFwiLi4vc2hhcGVzL3JlY3RhbmdsZVwiO1xuaW1wb3J0IHsgcmVxdWVzdENhY2hlQ2FudmFzIH0gZnJvbSAnLi4vLi4vdXRpbHMvY2FudmFzJztcbmltcG9ydCBKRmxvd0V2ZW50IGZyb20gJy4uLy4uL2V2ZW50cydcbmltcG9ydCBTaGFkb3dDYWNoZSBmcm9tICcuLi9zaGFwZXMvc2hhZG93LWNhY2hlJztcblxuY29uc3QgVEVYVF9BTElHTiA9IHtcbiAgICBDRU5URVI6ICdjZW50ZXInLFxuICAgIExFRlQ6ICdsZWZ0JyxcbiAgICBSSUdIVDogJ3JpZ2h0Jyxcbn07XG5jb25zdCBTUEFDRV9SRUcgPSAvXFxzL2c7XG5cbmNsYXNzIFRleHQgZXh0ZW5kcyBSZWN0YW5nbGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3MpIHtcbiAgICAgICAgc3VwZXIoY29uZmlncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICAgICAgICAgJ1RleHQnO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSAgICAgIGNvbmZpZ3MuY29udGVudCB8fCAnJztcbiAgICAgICAgdGhpcy5mb250RmFtaWx5ID0gICAgICAgY29uZmlncy5mb250RmFtaWx5IHx8ICctYXBwbGUtc3lzdGVtLEJsaW5rTWFjU3lzdGVtRm9udCxTZWdvZSBVSSxSb2JvdG8sSGVsdmV0aWNhIE5ldWUsSGVsdmV0aWNhLFRhaG9tYSxBcmlhbCxOb3RvIFNhbnMsUGluZ0ZhbmcgU0MsTWljcm9zb2Z0IFlhSGVpLEhpcmFnaW5vIFNhbnMgR0Isc2Fucy1zZXJpZixBcHBsZSBDb2xvciBFbW9qaSxTZWdvZSBVSSBFbW9qaSxTZWdvZSBVSSBTeW1ib2wsTm90byBDb2xvciBFbW9qaSdcbiAgICAgICAgdGhpcy5mb250U2l6ZSA9ICAgICAgICAgY29uZmlncy5mb250U2l6ZSB8fCAnMTRweCc7XG4gICAgICAgIHRoaXMuZm9udFdlaWdodCA9ICAgICAgIGNvbmZpZ3MuZm9udFdlaWdodCB8fCAnJztcbiAgICAgICAgdGhpcy50ZXh0Q29sb3IgPSAgICAgICAgY29uZmlncy50ZXh0Q29sb3IgfHwgJ3doaXRlJztcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlckNvbG9yID0gY29uZmlncy5wbGFjZWhvbGRlckNvbG9yIHx8ICBjb25maWdzLnRleHRDb2xvciB8fCAnd2hpdGUnO1xuICAgICAgICB0aGlzLnRleHRBbGlnbiA9ICAgICAgICBjb25maWdzLnRleHRBbGlnbiB8fCBURVhUX0FMSUdOLkNFTlRFUjtcbiAgICAgICAgdGhpcy50ZXh0QmFzZWxpbmUgPSAgICAgY29uZmlncy50ZXh0QmFzZWxpbmUgfHwgJ21pZGRsZSc7XG4gICAgICAgIHRoaXMubGluZUhlaWdodCA9ICAgICAgIGNvbmZpZ3MubGluZUhlaWdodCA7XG4gICAgICAgIHRoaXMuaW5kZW50ID0gICAgICAgICAgIGNvbmZpZ3MuaW5kZW50IHx8IDA7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gIGNvbmZpZ3MuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICB0aGlzLmVkaXRhYmxlID0gICAgICAgICBjb25maWdzLmVkaXRhYmxlO1xuICAgICAgICB0aGlzLmRlZmluZWRXaWR0aCA9ICAgICBjb25maWdzLmRlZmluZWRXaWR0aDtcbiAgICAgICAgdGhpcy5taW5XaWR0aCA9ICAgICAgICAgY29uZmlncy5taW5XaWR0aCB8fCAwO1xuICAgICAgICB0aGlzLm1heFdpZHRoID0gICAgICAgICBjb25maWdzLm1heFdpZHRoO1xuICAgICAgICB0aGlzLmVsbGlwc2lzID0gICAgICAgICBjb25maWdzLmVsbGlwc2lzO1xuXG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSAgICAgIGNvbmZpZ3MucGxhY2Vob2xkZXIgfHwgJyc7XG4gICAgICAgIHRoaXMuZW1wdHlXaGVuSW5wdXQgPSAgIGNvbmZpZ3MuZW1wdHlXaGVuSW5wdXQgfHwgZmFsc2U7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmVkaXR0aW5nID0gICAgICAgICBmYWxzZTtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9ICAgICAgICAgY29uZmlncy5kaXNhYmxlZDtcblxuICAgICAgICB0aGlzLmN1cnNvckNvbG9yID0gICAgICBjb25maWdzLmN1cnNvckNvbG9yIHx8ICcjNjBDRkM0JztcbiAgICAgICAgdGhpcy50ZXh0UmFuZ2VDb2xvciA9ICAgY29uZmlncy50ZXh0UmFuZ2VDb2xvciB8fCAnIzRFNzVFQzFBJztcblxuICAgICAgICB0aGlzLnNwYWNlUGxhY2Vob2xkZXIgPSBjb25maWdzLnNwYWNlUGxhY2Vob2xkZXI7XG4gICAgICAgIHRoaXMuc3BhY2VQbGFjZWhvbGRlckNvbG9yID0gY29uZmlncy5zcGFjZVBsYWNlaG9sZGVyQ29sb3I7XG4gICAgICAgIHRoaXMuc3BhY2VSZWNvcmRzID0gW107XG4gICAgICAgIHRoaXMuX3NwYWNlZENvbnRlbnRTZWdtbmVudCA9IFtdO1xuXG4gICAgICAgIHRoaXMuX3N0YXR1cyA9IHtcbiAgICAgICAgICAgIGVkaXRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgY3Vyc29yc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIGN1cnNvcmFuaW1lOiBudWxsLFxuICAgICAgICAgICAgbGFzdEVsYXBzZWQ6IDAsXG4gICAgICAgICAgICByZWZyZXNoRWxhcHNlZDogZmFsc2UsXG5cbiAgICAgICAgICAgIGN1cnNvckRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIHNoaWZ0T246IGZhbHNlLFxuXG4gICAgICAgICAgICBvbGRWYWw6ICcnLFxuICAgICAgICAgICAgaW5wdXRFbGVtZW50OiBudWxsLFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY3Vyc29yT2Zmc2V0ID0gMDtcblxuICAgICAgICB0aGlzLl90ZXh0UmFuZ2UgPSB7XG4gICAgICAgICAgICBlbmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgcmFuZ2Vmcm9tOiBudWxsLCAvLyBvZmZzZXRmcm9tXG4gICAgICAgICAgICByYW5nZVRvOiBudWxsLCAgIC8vIG9mZnNldHRvXG4gICAgICAgICAgICBpbml0aWFsUmFuZ2U6IG51bGwgLy8gb2Zmc2V0XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5lZGl0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFrZUZ1bmN0aW9uYWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJlQ2FsY3VsYXRlVGV4dCgpO1xuICAgICAgICB0aGlzLnNoYWRvd0NhY2hlKCk7XG4gICAgICAgIFxuICAgIH1cblxuICAgIHJlcGxhY2VTcGFjZUhvbGRlcihjb250ZW50LCB1c2VDYWNoZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmKHVzZUNhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudC5yZXBsYWNlKC9cXHMvZywgdGhpcy5zcGFjZVBsYWNlaG9sZGVyKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgciA9IHRoaXMuc3BhY2VSZWNvcmRzO1xuICAgICAgICBjb25zdCBwID0gdGhpcy5zcGFjZVBsYWNlaG9sZGVyXG4gICAgICAgIHIubGVuZ3RoID0gMDtcbiAgICAgICAgbGV0IGxhc3RPZmZzZXQ7XG4gICAgICAgIGNvbnN0IGMgPSBjb250ZW50LnJlcGxhY2UoL1xccy9nLCAoXywgb2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICBpZihsYXN0T2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHIucHVzaChvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYob2Zmc2V0IC0gbGFzdE9mZnNldCA+IDEpIHtcbiAgICAgICAgICAgICAgICByLnB1c2gobGFzdE9mZnNldCk7XG4gICAgICAgICAgICAgICAgci5wdXNoKG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9KVxuICAgICAgICBpZihsYXN0T2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHIucHVzaChsYXN0T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBnZXQgY3VycmVudENvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQgfHwgdGhpcy5wbGFjZWhvbGRlciB8fCAnJztcbiAgICB9XG5cbiAgICBnZXQgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvbnRlbnQ7XG4gICAgfVxuXG4gICAgcHJlQ2FsY3VsYXRlVGV4dCgpIHtcbiAgICAgICAgcmVxdWVzdENhY2hlQ2FudmFzKChjdHgpID0+IHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5mb250ID0gYCR7dGhpcy5mb250V2VpZ2h0fSAke3RoaXMuZm9udFNpemV9ICR7dGhpcy5mb250RmFtaWx5fWA7XG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gdGhpcy50ZXh0QWxpZ247XG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gdGhpcy50ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICBjb25zdCB0X2ggPSBwYXJzZUludCh0aGlzLmZvbnRTaXplKTtcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5jdXJyZW50Q29udGVudDtcbiAgICAgICAgICAgIGlmKHRoaXMuc3BhY2VQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLnJlcGxhY2VTcGFjZUhvbGRlcihjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgLy8gYWN0dWFsQm91bmRpbmdCb3hMZWZ0LFxuICAgICAgICAgICAgICAgIC8vIGFjdHVhbEJvdW5kaW5nQm94UmlnaHQsXG4gICAgICAgICAgICAgICAgZm9udEJvdW5kaW5nQm94QXNjZW50LFxuICAgICAgICAgICAgICAgIGZvbnRCb3VuZGluZ0JveERlc2NlbnQsXG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICB9ID0gY3R4Lm1lYXN1cmVUZXh0KGNvbnRlbnQpO1xuXG4gICAgICAgICAgICB0aGlzLl90ZXh0V2lkdGggPSB0aGlzLmluZGVudCArIHdpZHRoO1xuICAgICAgICAgICAgaWYodGhpcy5kZWZpbmVkV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmVsbGlwc2lzICYmICh0aGlzLl90ZXh0V2lkdGggPiB0aGlzLmRlZmluZWRXaWR0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fY2FsY3VsYXRlT2Zmc2V0KHRoaXMuZGVmaW5lZFdpZHRoIC0gMTIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsbGlwc2lzQ29udGVudCA9IGNvbnRlbnQuc3Vic3RyaW5nKDAsIG9mZnNldCkgKyAnLi4uJzsgXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGxpcHNpc0NvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5kZWZpbmVkV2lkdGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYodGhpcy5tYXhXaWR0aCAmJiB0aGlzLmVsbGlwc2lzKSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5fdGV4dFdpZHRoID4gdGhpcy5tYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByYXRpbyA9dGhpcy5tYXhXaWR0aCAvIHRoaXMuX3RleHRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbCA9IE1hdGguZmxvb3IoY29udGVudC5sZW5ndGggKiByYXRpbyAtIDMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsbGlwc2lzQ29udGVudCA9IGNvbnRlbnQuc3Vic3RyaW5nKDAsIGwpICsgJy4uLic7IFxuICAgICAgICAgICAgICAgIH0gIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsbGlwc2lzQ29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSBNYXRoLm1pbih0aGlzLm1heFdpZHRoLCB0aGlzLl90ZXh0V2lkdGgpO1xuICAgICAgICAgICAgfSBlbHNleyBcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gTWF0aC5tYXgodGhpcy5taW5XaWR0aCwgdGhpcy5fdGV4dFdpZHRoKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBpZih0aGlzLnNwYWNlUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBzX3dpZHRoLFxuICAgICAgICAgICAgICAgIH0gPSBjdHgubWVhc3VyZVRleHQodGhpcy5zcGFjZVBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCByMiA9IHRoaXMuX3NwYWNlZENvbnRlbnRTZWdtbmVudDtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0Q29sb3IgPSB0aGlzLnRleHRDb2xvcjtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdE9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgcjIubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnNwYWNlUmVjb3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IHRoaXMuc3BhY2VSZWNvcmRzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwY29sb3IgPSB0aGlzLnNwYWNlUGxhY2Vob2xkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGwgPSByLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZShpIDwgbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZiA9IHJbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSByW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBxID0gY29udGVudC5zdWJzdHJpbmcobGFzdE9mZnNldCwgZik7XG4gICAgICAgICAgICAgICAgICAgICAgICByMi5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tZWFzdXJlVGV4dChxKS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgcjIucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudC5zdWJzdHJpbmcoZiwgdCsxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodCAtIGYgKyAxKSAqIHNfd2lkdGgsICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE9mZnNldCA9IHQrMVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGxhc3RPZmZzZXQgPCBjb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBxID0gY29udGVudC5zdWJzdHJpbmcobGFzdE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHIyLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgcSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tZWFzdXJlVGV4dChxKS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gKE1hdGguYWJzKGZvbnRCb3VuZGluZ0JveEFzY2VudCkgKyBNYXRoLmFicyhmb250Qm91bmRpbmdCb3hEZXNjZW50KSkgfHwgdF9oO1xuICAgICAgICAgICAgdGhpcy5fdGV4dEhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIGlmKHRoaXMubGluZUhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2hhZG93Q2FjaGUoKSB7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoICogc2NhbGU7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodCAqIHNjYWxlO1xuICAgICAgICBjb25zdCBpID0gdGhpcy5pbmRlbnQgKiBzY2FsZTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlSW50KHRoaXMuZm9udFNpemUpICogc2NhbGU7XG4gICAgICAgIHRoaXMuX3NoYWRvd0NhY2hlID0gbmV3IFNoYWRvd0NhY2hlKHtcbiAgICAgICAgICAgIHdpZHRoOiB3LFxuICAgICAgICAgICAgaGVpZ2h0OiBoLFxuICAgICAgICAgICAgY2FjaGU6IChjdHgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBjb25zdCBbY3gsIGN5XSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICAgICAgICAgIC8vIGN0eC5zY2FsZSg0LCA0KVxuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUody8yLCBoLzIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvbnQgPSBgJHt0aGlzLmZvbnRXZWlnaHR9ICR7c2l6ZX1weCAke3RoaXMuZm9udEZhbWlseX1gO1xuICAgICAgICAgICAgICAgIGN0eC5mb250ID0gZm9udFxuICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSB0aGlzLnRleHRBbGlnbjtcbiAgICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gdGhpcy50ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuaXNFbXB0eSA/IHRoaXMucGxhY2Vob2xkZXJDb2xvciA6IHRoaXMudGV4dENvbG9yO1xuICAgICAgICAgICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5jdXJyZW50Q29udGVudDtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnNwYWNlUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy50ZXh0QWxpZ24gPT09IFRFWFRfQUxJR04uTEVGVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaHcgPSB3LzI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgX3cgPSAgLWh3ICsgaS8yO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3BhY2VkQ29udGVudFNlZ21uZW50LmZvckVhY2goc2VnID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gc2VnWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChzZWdbMF0sIF93LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdyArPSBzZWdbMV0gKiBzY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5lbGxpcHNpc0NvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLmVsbGlwc2lzQ29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZihjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLnRleHRBbGlnbiA9PT0gVEVYVF9BTElHTi5MRUZUKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBodyA9IHcgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChjb250ZW50LCAgLWh3ICsgaSAvIDIsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHRoaXMudGV4dEFsaWduID09PSBURVhUX0FMSUdOLlJJR0hUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaHcgPSB3IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoY29udGVudCwgaHcsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoY29udGVudCwgaSAvIDIsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICB9XG5cbiAgICBzZXRDb25maWcoY29uZmlncykge1xuICAgICAgICBPYmplY3Qua2V5cyhjb25maWdzKS5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAgICAgaWYoY29uZmlnc1trXSAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZ3Nba10gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tdID0gY29uZmlnc1trXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXdDb25maWdzW2tdID0gY29uZmlnc1trXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJlQ2FsY3VsYXRlVGV4dCgpO1xuICAgICAgICB0aGlzLnNoYWRvd0NhY2hlKCk7XG4gICAgfVxuXG4gICAgY2xpY2soKSB7XG4gICAgICAgIGlmKCF0aGlzLl9zdGF0dXMuZWRpdGluZykge1xuICAgICAgICAgICAgbGV0IGZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdlZGl0Jywge1xuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKSAgXG4gICAgICAgICAgICBpZighZmxhZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLl9iZWxvbmdzLl9jdXJyZW50cDtcbiAgICAgICAgICAgIGNvbnN0IGpmbG93ID0gdGhpcy5famZsb3c7IFxuICAgICAgICAgICAgaWYocG9pbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3JPZmZzZXQgPSB0aGlzLl9wb3NpdGlvblRvQ3Vyc29yT2Zmc2V0KHBvaW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgaW5wdXRFbGVtZW50ID0gY3JlYXRlSW5wdXRFbGVtZW50KFxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRyb2xDYWxsYmFjay5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRDYWxsYmFjay5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSBqZmxvdy5ET013cmFwcGVyO1xuICAgICAgICAgICAgd3JhcHBlci5hcHBlbmQoaW5wdXRFbGVtZW50KTsgIFxuICAgICAgICAgICAgaW5wdXRFbGVtZW50LmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTsgICAgICBcbiAgICAgICAgICAgIGpmbG93LnNldEZvY3VzSW5zdGFuY2UodGhpcyk7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fc3RhdHVzLCB7XG4gICAgICAgICAgICAgICAgZWRpdGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBvbGRWYWw6IHRoaXMuY29udGVudCxcbiAgICAgICAgICAgICAgICBpbnB1dEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgY3Vyc29yYW5pbWU6IGpmbG93LnJlcXVlc3RKRmxvd0FuaW1lKChlbGFwc2VkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RFbGFwc2VkID0gdGhpcy5fc3RhdHVzLmxhc3RFbGFwc2VkO1xuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLl9zdGF0dXMucmVmcmVzaEVsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5sYXN0RWxhcHNlZCA9IGVsYXBzZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMucmVmcmVzaEVsYXBzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZihlbGFwc2VkIC0gbGFzdEVsYXBzZWQgPiA1MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5jdXJzb3JzaG93ID0gIXRoaXMuX3N0YXR1cy5jdXJzb3JzaG93O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzLmxhc3RFbGFwc2VkID0gZWxhcHNlZDtcbiAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZih0aGlzLmVtcHR5V2hlbklucHV0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN5bmNTaGFkb3dJbnB1dFBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfbWFrZUZ1bmN0aW9uYWwoKSB7XG4gICAgICAgIGNvbnN0IGJsdXJIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMuZWRpdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYodGhpcy5fc3RhdHVzLmlucHV0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5pbnB1dEVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLl9iZWxvbmdzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5famZsb3cuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmKGV2ZW50LmN1cnJlbnRUYXJnZXQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMuX3N0YXR1cy5lZGl0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0RnVsbFJhbmdlKCk7XG4gICAgICAgICAgICB9IFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYoZXZlbnQuY3VycmVudFRhcmdldCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXZlbnQuZGV0YWlsLmJ1YmJsZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmKHRoaXMuX3N0YXR1cy5lZGl0aW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLl9iZWxvbmdzLl9jdXJyZW50cDtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9wb3NpdGlvblRvQ3Vyc29yT2Zmc2V0KHBvaW50KTtcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9zdGF0dXMuc2hpZnRPbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbml0aWFsUmFuZ2UgPSB0aGlzLl90ZXh0UmFuZ2UuaW5pdGlhbFJhbmdlO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3RleHRSYW5nZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2Vmcm9tOiBNYXRoLm1pbihvZmZzZXQsIGluaXRpYWxSYW5nZSksXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZVRvOiBNYXRoLm1heChvZmZzZXQsIGluaXRpYWxSYW5nZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3JPZmZzZXQgPSB0aGlzLl90ZXh0UmFuZ2UucmFuZ2VUbztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzLmlucHV0RWxlbWVudC5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMuX3JlZnJlc2hDdXJzb3IoKTsgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvck9mZnNldCA9IG9mZnNldFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMuaW5wdXRFbGVtZW50LmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVmcmVzaEN1cnNvcigpOyAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3luY1NoYWRvd0lucHV0UG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgdGhpcy5jbGljaygpO1xuICAgICAgICB9KVxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGJsdXJIYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnY2hhbmdlJywge1xuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICAgICAgICBvbGRWYWw6IHRoaXMuX3N0YXR1cy5vbGRWYWwsXG4gICAgICAgICAgICAgICAgdmFsOiB0aGlzLmNvbnRlbnQsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB0aGlzLl90ZXh0UmFuZ2UuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMuY3Vyc29yYW5pbWU/LmNhbmNlbCgpXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3N0YXR1cywge1xuICAgICAgICAgICAgICAgIGVkaXRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGN1cnNvcnNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgY3Vyc29yYW5pbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgbGFzdEVsYXBzZWQ6IDAsXG4gICAgICAgICAgICAgICAgcmVmcmVzaEVsYXBzZWQ6IGZhbHNlLFxuXG4gICAgICAgICAgICAgICAgY3Vyc29yRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNoaWZ0T246IGZhbHNlLFxuXG4gICAgICAgICAgICAgICAgb2xkVmFsOiAnJyxcbiAgICAgICAgICAgICAgICBpbnB1dEVsZW1lbnQ6IG51bGwsXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2luc3RhbmNlUHJlc3NTdGFydCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYodGhpcy5fc3RhdHVzLmVkaXRpbmcgJiYgIXRoaXMuX3N0YXR1cy5zaGlmdE9uKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuZGV0YWlsLmJ1YmJsZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBldmVudC5kZXRhaWwucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMuX2JlbG9uZ3MuX2N1cnJlbnRwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSB0aGlzLl9wb3NpdGlvblRvQ3Vyc29yT2Zmc2V0KHBvaW50KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRSYW5nZS5pbml0aWFsUmFuZ2UgPSBjO1xuICAgICAgICAgICAgICAgIGNvbnN0IGpmbG93ID0gZXZlbnQuZGV0YWlsLmpmbG93O1xuICAgICAgICAgICAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSAoZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gamZsb3cuX2NhbGN1bGF0ZVBvaW50QmFjayhbb2Zmc2V0WCwgb2Zmc2V0WV0pO1xuICAgICAgICAgICAgICAgICAgICBqZmxvdy5fc3RhY2suY2hlY2tIaXQocClcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLl9iZWxvbmdzLl9jdXJyZW50cDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYyA9IHRoaXMuX3Bvc2l0aW9uVG9DdXJzb3JPZmZzZXQocG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbml0aWFsUmFuZ2UgPSB0aGlzLl90ZXh0UmFuZ2UuaW5pdGlhbFJhbmdlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMuZWRpdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3RleHRSYW5nZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2Vmcm9tOiBNYXRoLm1pbihjLCBpbml0aWFsUmFuZ2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VUbzogTWF0aC5tYXgoYywgaW5pdGlhbFJhbmdlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkuYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgdClcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHQpO1xuICAgICAgICAgICAgICAgICAgICBpZighbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHRSYW5nZS5pbml0aWFsUmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlVG8gPSB0aGlzLl90ZXh0UmFuZ2UucmFuZ2VUbztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yT2Zmc2V0ID0gcmFuZ2VUbztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzLmVkaXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMuaW5wdXRFbGVtZW50LmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTsgICBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dFJhbmdlLmluaXRpYWxSYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9wb3NpdGlvblRvQ3Vyc29yT2Zmc2V0KHBvaW50KSB7XG4gICAgICAgIGNvbnN0IFt4XSA9IHBvaW50O1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aC8yO1xuICAgICAgICBjb25zdCBbb3hdID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSB4IC0gKG94IC0gdyk7XG4gICAgICAgIGxldCBjdXJzb3JPZmZzZXQgPSAwO1xuICAgICAgICBpZihvZmZzZXRYID49IHRoaXMuX3RleHRXaWR0aCkge1xuICAgICAgICAgICAgY3Vyc29yT2Zmc2V0ID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnNvck9mZnNldCA9IHRoaXMuX2NhbGN1bGF0ZU9mZnNldChvZmZzZXRYKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjdXJzb3JPZmZzZXQ7XG4gICAgfVxuXG4gICAgX2NhbGN1bGF0ZU9mZnNldChvZmZ4KSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5jb250ZW50O1xuICAgICAgICBpZih0aGlzLnNwYWNlUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLnJlcGxhY2VTcGFjZUhvbGRlcihjb250ZW50LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXhMID0gY29udGVudC5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBjb250ZW50V2lkdGggPSB0aGlzLl90ZXh0V2lkdGg7XG4gICAgICAgIGlmKGNvbnRlbnRXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsd2lkdGggPSBjb250ZW50V2lkdGg7XG4gICAgICAgIGxldCBpZHggPSBNYXRoLmZsb29yKG9mZnggLyBhbGx3aWR0aCAqIG1heEwpIDtcbiAgICAgICAgcmVxdWVzdENhY2hlQ2FudmFzKChjdHgpID0+IHtcbiAgICAgICAgICAgIGN0eC5mb250ID0gYCR7dGhpcy5mb250U2l6ZX0gJHt0aGlzLmZvbnRGYW1pbHl9YDtcbiAgICAgICAgICAgIGxldCBnMSwgZzI7XG4gICAgICAgICAgICBsZXQgbGFzdGlkeDtcblxuICAgICAgICAgICAgbGV0IGMgPSBjb250ZW50LnN1YnN0cmluZygwLCBpZHgpO1xuICAgICAgICAgICAgbGV0IGMxID0gY29udGVudC5zdWJzdHJpbmcoaWR4LTEsIGlkeCk7XG4gICAgICAgICAgICBsZXQgYzIgPSBjb250ZW50LnN1YnN0cmluZyhpZHgsIGlkeCsxKTtcbiAgICAgICAgICAgIGxldCB3ID0gY3R4Lm1lYXN1cmVUZXh0KGMpLndpZHRoO1xuICAgICAgICAgICAgbGV0IHcxID0gY3R4Lm1lYXN1cmVUZXh0KGMxKS53aWR0aDtcbiAgICAgICAgICAgIGxldCB3MiA9IGN0eC5tZWFzdXJlVGV4dChjMikud2lkdGg7XG4gICAgICAgICAgICBnMSA9IHcgLSB3MS8yO1xuICAgICAgICAgICAgZzIgPSB3ICsgdzIvMjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmKGcxIDw9IG9mZnggJiYgZzIgPj0gb2ZmeCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9ICBcbiAgICAgICAgICAgICAgICBpZihnMSA+IG9mZngpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5bem5L6n5bCR5LqGXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwYW53ID0gZzIgLSBvZmZ4O1xuICAgICAgICAgICAgICAgICAgICBsYXN0aWR4ID0gaWR4O1xuICAgICAgICAgICAgICAgICAgICBpZihzcGFudyA8IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWR4IC09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHggLT0gTWF0aC5mbG9vcihzcGFudyAvIGcyICogbGFzdGlkeClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjID0gY29udGVudC5zdWJzdHJpbmcoaWR4LCBsYXN0aWR4KTtcbiAgICAgICAgICAgICAgICAgICAgdyAtPSBjdHgubWVhc3VyZVRleHQoYykud2lkdGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKGcyIDwgb2ZmeCkge1xuICAgICAgICAgICAgICAgICAgICAvLyDlj7PkvqflsJHkuoZcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BhbncgPSBvZmZ4IC0gZzE7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RpZHggPSBpZHg7XG4gICAgICAgICAgICAgICAgICAgIGlmKHNwYW53IDwgMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeCArPSBNYXRoLmZsb29yKHNwYW53IC8gKGFsbHdpZHRoIC0gZzEpICogKG1heEwgLSBsYXN0aWR4KSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjID0gY29udGVudC5zdWJzdHJpbmcobGFzdGlkeCwgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgdyArPSBjdHgubWVhc3VyZVRleHQoYykud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGMxID0gY29udGVudC5zdWJzdHJpbmcoaWR4LTEsIGlkeCk7XG4gICAgICAgICAgICAgICAgYzIgPSBjb250ZW50LnN1YnN0cmluZyhpZHgsIGlkeCsxKTtcbiAgICAgICAgICAgICAgICB3MSA9IGN0eC5tZWFzdXJlVGV4dChjMSkud2lkdGg7XG4gICAgICAgICAgICAgICAgdzIgPSBjdHgubWVhc3VyZVRleHQoYzIpLndpZHRoO1xuICAgICAgICAgICAgICAgIGcxID0gdyAtIHcxLzI7XG4gICAgICAgICAgICAgICAgZzIgPSB3ICsgdzIvMjtcbiAgICAgICAgICAgIH0gd2hpbGUoaWR4ID49IDAgJiYgaWR4IDw9IG1heEwpXG4gICAgICAgICAgICBcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuXG4gICAgX3JlZnJlc2hDdXJzb3IoKSB7XG4gICAgICAgIGlmKHRoaXMuX3N0YXR1cy5lZGl0aW5nKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3N0YXR1cywge1xuICAgICAgICAgICAgICAgIGN1cnNvcnNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgcmVmcmVzaEVsYXBzZWQ6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLl90ZXh0UmFuZ2UuZW5hYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0UmFuZ2UuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIGlmKHRoaXMuX2lzTW92aW5nKXtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNlxuICAgICAgICB9XG4gICAgICAgIGlmKCFjdHguZGlzYWJsZUNhY2hlICYmICF0aGlzLl9zdGF0dXMuZWRpdGluZyAmJiB0aGlzLl9qZmxvdy5zY2FsZSAqIHBhcnNlSW50KHRoaXMuZm9udFNpemUpIDwgOCkge1xuICAgICAgICAgICAgY29uc3QgW2N4LCBjeV0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgICAgIC8vIHRoaXMuX3NoYWRvd0NhY2hlLnJlbmRlcihjdHgpO1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY3gsIGN5KTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5fc2hhZG93Q2FjaGUuaW1hZ2VCdWZmZXIsIC10aGlzLndpZHRoLzIsIC10aGlzLmhlaWdodC8yLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1jeCwgLWN5KTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmb250ID0gYCR7dGhpcy5mb250V2VpZ2h0fSAke3RoaXMuZm9udFNpemV9ICR7dGhpcy5mb250RmFtaWx5fWA7XG4gICAgICAgIGlmKGN0eC5mb250ICE9PSBmb250KSB7XG4gICAgICAgICAgICBjdHguZm9udCA9IGZvbnRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGN0eC50ZXh0QWxpZ24gIT09IHRoaXMudGV4dEFsaWduKSB7XG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gdGhpcy50ZXh0QWxpZ247XG4gICAgICAgIH1cblxuICAgICAgICBpZihjdHgudGV4dEJhc2VsaW5lICE9PSB0aGlzLnRleHRCYXNlbGluZSkge1xuICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IHRoaXMudGV4dEJhc2VsaW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuaXNFbXB0eSA/IHRoaXMucGxhY2Vob2xkZXJDb2xvciA6IHRoaXMudGV4dENvbG9yO1xuICAgICAgICBsZXQgY29udGVudCA9IHRoaXMuY3VycmVudENvbnRlbnQ7XG4gICAgICAgIGlmKHRoaXMuc3BhY2VQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgaWYodGhpcy50ZXh0QWxpZ24gPT09IFRFWFRfQUxJR04uTEVGVCl7XG4gICAgICAgICAgICAgICAgY29uc3QgaHcgPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICBsZXQgdyA9IHRoaXMuYW5jaG9yWzBdIC0gaHcgKyB0aGlzLmluZGVudCAvIDI7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMuYW5jaG9yWzFdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NwYWNlZENvbnRlbnRTZWdtbmVudC5mb3JFYWNoKHNlZyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBzZWdbMl07XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChzZWdbMF0sIHcsIHkpO1xuICAgICAgICAgICAgICAgICAgICB3ICs9IHNlZ1sxXTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKHRoaXMuZWxsaXBzaXNDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IHRoaXMuZWxsaXBzaXNDb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoY29udGVudCkge1xuICAgICAgICAgICAgICAgIGlmKHRoaXMudGV4dEFsaWduID09PSBURVhUX0FMSUdOLkxFRlQpe1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBodyA9IHRoaXMud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoY29udGVudCwgdGhpcy5hbmNob3JbMF0gLSBodyArIHRoaXMuaW5kZW50IC8gMiwgdGhpcy5hbmNob3JbMV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZih0aGlzLnRleHRBbGlnbiA9PT0gVEVYVF9BTElHTi5SSUdIVCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBodyA9IHRoaXMud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoY29udGVudCwgdGhpcy5hbmNob3JbMF0gKyBodywgdGhpcy5hbmNob3JbMV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChjb250ZW50LCB0aGlzLmFuY2hvclswXSArIHRoaXMuaW5kZW50IC8gMiwgdGhpcy5hbmNob3JbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgY29uc3QgaHcgPSB0aGlzLndpZHRoLzI7XG4gICAgICAgIGNvbnN0IHRleHRoZWlnaHQgPSB0aGlzLl90ZXh0SGVpZ2h0XG4gICAgICAgIGNvbnN0IFt4LCB5XSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCBseCA9IHggLSBodztcbiAgICAgICAgY29uc3QgbHkgPSB5IC0gdGV4dGhlaWdodC8yO1xuXG4gICAgICAgIGlmKHRoaXMuX3N0YXR1cy5jdXJzb3JzaG93ICYmIHRoaXMuX3N0YXR1cy5lZGl0aW5nKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9jdXJzb3JPZmZzZXQ7XG4gICAgICAgICAgICBsZXQgYyA9IGNvbnRlbnQuc3Vic3RyaW5nKDAsIG9mZnNldCk7XG4gICAgICAgICAgICBpZih0aGlzLnNwYWNlUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBjID0gdGhpcy5yZXBsYWNlU3BhY2VIb2xkZXIoYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjdyA9IGx4ICsgY3R4Lm1lYXN1cmVUZXh0KGMpLndpZHRoO1xuICAgICAgICAgICAgY29uc3QgY19sZW4gPSB0aGlzLl90ZXh0SGVpZ2h0LzI7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGN3LCB5IC0gY19sZW4pO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhjdywgeSArIGNfbGVuKTtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jdXJzb3JDb2xvcjtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuX3RleHRSYW5nZS5lbmFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICByYW5nZWZyb20sIHJhbmdlVG9cbiAgICAgICAgICAgIH0gPSB0aGlzLl90ZXh0UmFuZ2U7XG4gICAgICAgICAgICBjb25zdCBjID0gdGhpcy5jb250ZW50LnN1YnN0cmluZygwLCByYW5nZWZyb20pO1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGlzLmNvbnRlbnQuc3Vic3RyaW5nKHJhbmdlZnJvbSwgcmFuZ2VUbylcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgeCA9IGx4ICsgY3R4Lm1lYXN1cmVUZXh0KGMpLndpZHRoO1xuICAgICAgICAgICAgY29uc3QgdyA9IGN0eC5tZWFzdXJlVGV4dChyYW5nZSkud2lkdGg7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgucmVjdCh4LCBseSwgdywgdGV4dGhlaWdodCk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy50ZXh0UmFuZ2VDb2xvclxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfSBcbiAgICB9XG5cbiAgICBfaW5wdXRDb250cm9sKG9wLCBkYXRhKSB7XG4gICAgICAgIGlmKHRoaXMuX3RleHRSYW5nZS5lbmFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICBpZihvcCA9PT0gJ0JhY2tzcGFjZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2lucHV0Jywge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbDogdGhpcy5fc3RhdHVzLm9sZFZhbCxcbiAgICAgICAgICAgICAgICAgICAgdmFsOiB0aGlzLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3luY1NoYWRvd0lucHV0UG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fY3Vyc29yT2Zmc2V0O1xuICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5jb250ZW50O1xuICAgICAgICBsZXQgcHJlQ29udGVudCA9IGNvbnRlbnQuc3Vic3RyaW5nKDAsIG9mZnNldCk7XG4gICAgICAgIGxldCBhZnRlckNvbnRlbnQgXG4gICAgICAgIGlmKHRoaXMuY2FjaGVJZHgpIHtcbiAgICAgICAgICAgIGFmdGVyQ29udGVudCA9IGNvbnRlbnQuc3Vic3RyaW5nKHRoaXMuY2FjaGVJZHhbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWZ0ZXJDb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RvcElucHV0RXZlbnQgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoKG9wKXtcbiAgICAgICAgICAgIGNhc2UgXCJJbnB1dFwiOlxuICAgICAgICAgICAgICAgIHByZUNvbnRlbnQgKz0gZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3JPZmZzZXQgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50ID0gcHJlQ29udGVudCArIGFmdGVyQ29udGVudDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjb21wb3NpdGlvbnN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZUlkeCA9IFtwcmVDb250ZW50Lmxlbmd0aCwgcHJlQ29udGVudC5sZW5ndGhdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNvbXBvc2l0aW9udXBkYXRlXCI6XG4gICAgICAgICAgICAgICAgcHJlQ29udGVudCA9IHByZUNvbnRlbnQuc3Vic3RyaW5nKDAsIHRoaXMuY2FjaGVJZHhbMF0pO1xuICAgICAgICAgICAgICAgIHByZUNvbnRlbnQgKz0gZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSBwcmVDb250ZW50ICsgYWZ0ZXJDb250ZW50O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yT2Zmc2V0ID0gdGhpcy5jYWNoZUlkeFswXSArIGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVJZHhbMV0gPSB0aGlzLmNhY2hlSWR4WzBdICsgZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY29tcG9zaXRpb25lbmRcIjpcbiAgICAgICAgICAgICAgICBwcmVDb250ZW50ID0gcHJlQ29udGVudC5zdWJzdHJpbmcoMCwgdGhpcy5jYWNoZUlkeFswXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yT2Zmc2V0ID0gdGhpcy5jYWNoZUlkeFswXSArIGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVJZHggPSBudWxsO1xuICAgICAgICAgICAgICAgIHByZUNvbnRlbnQgKz0gZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSBwcmVDb250ZW50ICsgYWZ0ZXJDb250ZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkVudGVyXCI6XG4gICAgICAgICAgICAgICAgaWYodGhpcy5jYWNoZUlkeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBkZWZhdWx0QWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2VudGVya2V5cHJlc3NlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyOiAodmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0QWN0ID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdG9wSW5wdXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wSW5wdXRFdmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICBpZihkZWZhdWx0QWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2pmbG93LmJsdXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICBcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJCYWNrc3BhY2VcIjpcbiAgICAgICAgICAgICAgICBpZih0aGlzLmNhY2hlSWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJlQ29udGVudCA9IHByZUNvbnRlbnQuc3Vic3RyaW5nKDAsIHByZUNvbnRlbnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yT2Zmc2V0ID0gTWF0aC5tYXgoMCwgdGhpcy5fY3Vyc29yT2Zmc2V0LTEpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudCA9IHByZUNvbnRlbnQgKyBhZnRlckNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFzdG9wSW5wdXRFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdpbnB1dCcsIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgb2xkVmFsOiB0aGlzLl9zdGF0dXMub2xkVmFsLFxuICAgICAgICAgICAgICAgIHZhbDogdGhpcy5jb250ZW50LFxuICAgICAgICAgICAgfSkpO1xuICAgIFxuICAgICAgICB9XG4gICAgICAgXG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICB0aGlzLnN5bmNTaGFkb3dJbnB1dFBvc2l0aW9uKCk7XG4gICAgfVxuXG4gICAgcmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5wcmVDYWxjdWxhdGVUZXh0KCk7XG4gICAgICAgIHRoaXMuX2JlbG9uZ3MucmVjYWxjdWxhdGVVcCgpO1xuICAgICAgICB0aGlzLl9qZmxvdy5zY2hlZHVsZVJlbmRlcigpO1xuICAgIH1cblxuICAgIHN5bmNTaGFkb3dJbnB1dFBvc2l0aW9uKCkge1xuICAgICAgICBpZih0aGlzLl9zdGF0dXMuZWRpdGluZykge1xuICAgICAgICAgICAgY29uc3QgaHcgPSB0aGlzLndpZHRoLzI7XG4gICAgICAgICAgICBjb25zdCBoaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgICAgICBsZXQgbHggPSB0aGlzLmFuY2hvclswXSAtIGh3O1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fY3Vyc29yT2Zmc2V0O1xuXG4gICAgICAgICAgICByZXF1ZXN0Q2FjaGVDYW52YXMoKGN0eCkgPT4ge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9IGAke3RoaXMuZm9udFNpemV9ICR7dGhpcy5mb250RmFtaWx5fWA7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IHRoaXMuY29udGVudC5zdWJzdHJpbmcoMCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBseCArPSBjdHgubWVhc3VyZVRleHQoYykud2lkdGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy5jYWxjdWxhdGVUb1JlYWxXb3JsZChbbHgsIGhoXSk7XG4gICAgICAgICAgICBjb25zdCBjYW52YXNNZXRhID0gdGhpcy5famZsb3cuY2FudmFzTWV0YTtcbiAgICAgICAgICAgIGNvbnN0IHB4ID0gTWF0aC5taW4oY2FudmFzTWV0YS5hY3R1YWxfd2lkdGggLSAxMjAsIHBvaW50WzBdKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5pbnB1dEVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke3B4fXB4LCAke3BvaW50WzFdfXB4KWBcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jb250cm9sQ2FsbGJhY2sob3AsIGRhdGEsIGUpIHtcbiAgICAgICAgaWYodGhpcy5fc3RhdHVzLmVkaXRpbmcpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fc3RhdHVzLCB7XG4gICAgICAgICAgICAgICAgY3Vyc29yc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICByZWZyZXNoRWxhcHNlZDogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaChvcCl7XG4gICAgICAgICAgICBjYXNlIFwiSW5wdXRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjb21wb3NpdGlvbnN0YXJ0XCI6XG4gICAgICAgICAgICBjYXNlIFwiY29tcG9zaXRpb251cGRhdGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjb21wb3NpdGlvbmVuZFwiOlxuICAgICAgICAgICAgY2FzZSBcIkVudGVyXCI6XG4gICAgICAgICAgICBjYXNlIFwiQmFja3NwYWNlXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5faW5wdXRDb250cm9sKG9wLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgICAgICAgICAgICBpZih0aGlzLl90ZXh0UmFuZ2UuZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHRSYW5nZS5lbmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fb25BcnJvd0xlZnQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6XG4gICAgICAgICAgICAgICAgaWYodGhpcy5fdGV4dFJhbmdlLmVuYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0UmFuZ2UuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX29uQXJyb3dSaWdodCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNoaWZ0XCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TaGlmdFRvZ2dsZShkYXRhKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkN0cmxBXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0RnVsbFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQ09QWVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX2NvcHkoZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQ1VUXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fY3V0KGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlBBU1RFXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFzdGUoZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIF9vbkFycm93TGVmdCgpIHtcbiAgICAgICAgdGhpcy5fY3Vyc29yT2Zmc2V0ID0gTWF0aC5tYXgoMCwgdGhpcy5fY3Vyc29yT2Zmc2V0IC0gMSk7XG4gICAgICAgIHRoaXMuX2pmbG93LnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgIHRoaXMuc3luY1NoYWRvd0lucHV0UG9zaXRpb24oKTtcbiAgICB9XG5cbiAgICBfb25BcnJvd1JpZ2h0KCkge1xuICAgICAgICB0aGlzLl9jdXJzb3JPZmZzZXQgPSBNYXRoLm1pbih0aGlzLmNvbnRlbnQubGVuZ3RoLCB0aGlzLl9jdXJzb3JPZmZzZXQgKyAxKTtcbiAgICAgICAgdGhpcy5famZsb3cuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgdGhpcy5zeW5jU2hhZG93SW5wdXRQb3NpdGlvbigpO1xuICAgIH0gICAgXG5cbiAgICBfb25TaGlmdFRvZ2dsZSh2YWwpIHtcbiAgICAgICAgdGhpcy5fc3RhdHVzLnNoaWZ0T24gPSB2YWw7XG4gICAgICAgIGlmKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fdGV4dFJhbmdlLmluaXRpYWxSYW5nZSA9IHRoaXMuX2N1cnNvck9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHRSYW5nZS5pbml0aWFsUmFuZ2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3NlbGVjdEZ1bGxSYW5nZSgpIHtcbiAgICAgICAgdGhpcy5fdGV4dFJhbmdlID0ge1xuICAgICAgICAgICAgZW5hYmxlOiB0cnVlLFxuICAgICAgICAgICAgcmFuZ2Vmcm9tOiAwLFxuICAgICAgICAgICAgcmFuZ2VUbzogdGhpcy5jb250ZW50Lmxlbmd0aFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnNvck9mZnNldCA9IHRoaXMuY29udGVudC5sZW5ndGg7XG4gICAgfVxuXG4gICAgX2NsZWFyVGV4dFJhbmdlKCkge1xuICAgICAgICBpZih0aGlzLl90ZXh0UmFuZ2UuZW5hYmxlKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJhbmdlZnJvbSwgcmFuZ2VUbyB9ID0gdGhpcy5fdGV4dFJhbmdlO1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuY29udGVudDtcbiAgICAgICAgICAgIGNvbnN0IHByZUNvbnRlbnQgPSBjb250ZW50LnN1YnN0cmluZygwLCByYW5nZWZyb20pO1xuICAgICAgICAgICAgY29uc3QgYWZ0ZXJDb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcocmFuZ2VUbyk7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSBwcmVDb250ZW50ICsgYWZ0ZXJDb250ZW50O1xuICAgICAgICAgICAgdGhpcy5fY3Vyc29yT2Zmc2V0ID0gcHJlQ29udGVudC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLl90ZXh0UmFuZ2UuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0U2VsZWN0aW9uKCkge1xuICAgICAgICBpZih0aGlzLl90ZXh0UmFuZ2UuZW5hYmxlKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJhbmdlZnJvbSwgcmFuZ2VUbyB9ID0gdGhpcy5fdGV4dFJhbmdlO1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuY29udGVudDtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50LnN1YnN0cmluZyhyYW5nZWZyb20sIHJhbmdlVG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIF9jb3B5KGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuX2dldFNlbGVjdGlvbigpO1xuICAgICAgICBpZihzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGV2ZW50LmNsaXBib2FyZERhdGEuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgc2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY3V0KGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuX2dldFNlbGVjdGlvbigpO1xuICAgICAgICBpZihzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGV2ZW50LmNsaXBib2FyZERhdGEuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcGFzdGUoZXZlbnQpIHtcbiAgICAgICAgbGV0IHBhc3RlQ29udGVudCA9IChldmVudC5jbGlwYm9hcmREYXRhIHx8IHdpbmRvdy5jbGlwYm9hcmREYXRhKS5nZXREYXRhKFwidGV4dFwiKTtcbiAgICAgICAgbGV0IGZsYWcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdwYXN0ZScsIHtcbiAgICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHBhc3RlQ29udGVudCxcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc29sdmVQYXN0ZUNvbnRlbnQoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBwYXN0ZUNvbnRlbnQgPSBjYWxsYmFjayhwYXN0ZUNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIGlmKGZsYWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbGVhclRleHRSYW5nZSgpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9jdXJzb3JPZmZzZXQ7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQ7XG4gICAgICAgIGNvbnN0IHByZUNvbnRlbnQgPSBjb250ZW50LnN1YnN0cmluZygwLCBvZmZzZXQpO1xuICAgICAgICBjb25zdCBhZnRlckNvbnRlbnQgPSBjb250ZW50LnN1YnN0cmluZyhvZmZzZXQpO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBwcmVDb250ZW50ICsgcGFzdGVDb250ZW50ICsgYWZ0ZXJDb250ZW50O1xuICAgICAgICB0aGlzLl9jdXJzb3JPZmZzZXQgPSAocHJlQ29udGVudCArIHBhc3RlQ29udGVudCkubGVuZ3RoO1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9XG4gICAgX2RlZmF1bHRDYWxsYmFjayhvcCwgZSkge1xuICAgICAgICBzd2l0Y2gob3Ape1xuICAgICAgICAgICAgY2FzZSAnS2V5RG93bic6IFxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgna2V5ZG93bicsIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGUua2V5LFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBlLmNvZGUsXG4gICAgICAgICAgICAgICAgICAgIHJhd0V2ZW50OiBlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0tleVVwJzogXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdrZXl1cCcsIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGUua2V5LFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBlLmNvZGUsXG4gICAgICAgICAgICAgICAgICAgIHJhd0V2ZW50OiBlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZih0aGlzLl9qZmxvdy5fZm9jdXMuaW5zdGFuY2UgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2pmbG93LmJsdXIoKTtcbiAgICAgICAgfVxuICAgIH1cbn0gICAgICAgXG5cbmV4cG9ydCBkZWZhdWx0IFRleHQ7XG5cblxuZnVuY3Rpb24gY3JlYXRlSW5wdXRFbGVtZW50KGNvbnRyb2xDYWxsYmFjaywgZGVmYXVsdENhbGxiYWNrKSB7XG4gICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnc3R5bGUnLGBcbiAgICAgICAgd2lkdGg6IDEwMHB4O1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgYm9yZGVyOm5vbmU7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgIHotaW5kZXg6IC0xO1xuICAgICAgICBjb250YWluOiBzdHJpY3Q7YCk7XG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIC0xKTtcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ3NwZWxsY2hlY2snLCBmYWxzZSk7XG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKCdhdXRvY29ycmVjdCcsICdvZmYnKTtcblxuXG4gICAgLy8gbGV0IGNvbnRlbnQgPSBjb25maWdzLmNvbnRlbnQ7XG4gICAgLy8gbGV0IHN0YXJ0aWR4ID0gMDtcblxuICAgIC8vIGZ1bmN0aW9uIHJlbmRlckNvbnRlbnQoKSB7XG4gICAgLy8gICAgIGNvbmZpZ3MuY2FsbGJhY2soY29udGVudClcbiAgICAvLyB9XG4gICAgbGV0IHN0b3BJbnB1dCA9IGZhbHNlO1xuICAgIGxldCBzdGF0dXMgPSB7XG4gICAgICAgIGN0cmxPbjogZmFsc2UsXG4gICAgfVxuXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JlaW5wdXQnLCBlID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZihlLmRhdGEpIHtcbiAgICAgICAgICAgIC8vIGNvbnRlbnQgKz0gZS5kYXRhO1xuICAgICAgICAgICAgLy8gcmVuZGVyQ29udGVudCgpO1xuICAgICAgICAgICAgaWYoIXN0b3BJbnB1dCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjaygnSW5wdXQnLCBlLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCAoZSkgPT4ge1xuICAgICAgICAvLyBjYWNoZSBjb21wb3NpdGlvbiBzdGFydCBvZmZzZXRcbiAgICAgICAgLy8gc3RhcnRpZHggPSBjb250ZW50Lmxlbmd0aDtcbiAgICAgICAgY29udHJvbENhbGxiYWNrKCdjb21wb3NpdGlvbnN0YXJ0Jyk7XG4gICAgICAgIHN0b3BJbnB1dCA9IHRydWU7XG4gICAgfSk7XG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb251cGRhdGUnLCAoZSkgPT4ge1xuICAgICAgICAvLyB1cGRhdGUgY29udGVudFxuICAgICAgICAvLyBjb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcoMCwgc3RhcnRpZHgpO1xuICAgICAgICAvLyBjb250ZW50ICs9IGUuZGF0YTtcbiAgICAgICAgLy8gcmVuZGVyQ29udGVudCgpO1xuICAgICAgICBjb250cm9sQ2FsbGJhY2soJ2NvbXBvc2l0aW9udXBkYXRlJywgZS5kYXRhKTtcbiAgICB9KTtcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIChlKSA9PiB7XG4gICAgICAgIC8vIHJlcGxhY2UgdGV4dCBhdCBzdGFydCBvZmZzZXRcbiAgICAgICAgLy8gY29udGVudCA9IGNvbnRlbnQuc3Vic3RyaW5nKDAsIHN0YXJ0aWR4KTtcbiAgICAgICAgLy8gc3RhcnRpZHggPSAwO1xuICAgICAgICAvLyBjb250ZW50ICs9IGUuZGF0YTtcbiAgICAgICAgLy8gcmVuZGVyQ29udGVudCgpO1xuICAgICAgICBjb250cm9sQ2FsbGJhY2soJ2NvbXBvc2l0aW9uZW5kJywgZS5kYXRhKTtcbiAgICAgICAgaW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgc3RvcElucHV0ID0gZmFsc2VcbiAgICB9KTtcblxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIHN3aXRjaChldmVudC5rZXkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJTaGlmdFwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjayhcIlNoaWZ0XCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJNZXRhXCI6XG4gICAgICAgICAgICBjYXNlIFwiQ29udHJvbFwiOlxuICAgICAgICAgICAgICAgIHN0YXR1cy5jdHJsT24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIHN3aXRjaChldmVudC5jb2RlKSB7XG4gICAgICAgICAgICBjYXNlIFwiRW50ZXJcIjpcbiAgICAgICAgICAgICAgICAvLyBjb250ZW50ID0gY29udGVudCArICdcXG4nO1xuICAgICAgICAgICAgICAgIC8vIHJlbmRlckNvbnRlbnQoKTtcbiAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soJ0VudGVyJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQmFja3NwYWNlXCI6XG4gICAgICAgICAgICAgICAgLy8gY29udGVudCA9IGNvbnRlbnQuc3Vic3RyaW5nKDAsIGNvbnRlbnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyQ29udGVudCgpO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjaygnQmFja3NwYWNlJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6XG4gICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKFwiQXJyb3dMZWZ0XCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soXCJBcnJvd1JpZ2h0XCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkFycm93RG93blwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjayhcIkFycm93RG93blwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBcnJvd1VwXCI6XG4gICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKFwiQXJyb3dVcFwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2goZXZlbnQua2V5KSB7XG4gICAgICAgICAgICBjYXNlIFwiU2hpZnRcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soXCJTaGlmdFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJNZXRhXCI6XG4gICAgICAgICAgICBjYXNlIFwiQ29udHJvbFwiOlxuICAgICAgICAgICAgICAgIHN0YXR1cy5jdHJsT24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgaWYoc3RhdHVzLmN0cmxPbikge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soJ0N0cmxBJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSlcblxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGRlZmF1bHRDYWxsYmFjaygnS2V5VXAnLCBldmVudCk7XG4gICAgfSk7XG5cbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGRlZmF1bHRDYWxsYmFjaygnS2V5RG93bicsIGV2ZW50KTtcbiAgICB9KTtcblxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NvcHknLCBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBjb250cm9sQ2FsbGJhY2soJ0NPUFknLCBudWxsLCBldmVudCk7XG4gICAgfSk7XG5cbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjdXQnLCBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBjb250cm9sQ2FsbGJhY2soJ0NVVCcsIG51bGwsIGV2ZW50KTtcbiAgICB9KTtcblxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgZXZlbnQgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgY29udHJvbENhbGxiYWNrKCdQQVNURScsIG51bGwsIGV2ZW50KTtcbiAgICB9KTtcbiAgICByZXR1cm4gaW5wdXQ7XG59XG4iLCJpbXBvcnQgUmVjdGFuZ2xlIGZyb20gJy4vc2hhcGVzL3JlY3RhbmdsZSc7XG5pbXBvcnQgU3RhY2tNaXhpbiBmcm9tICcuL3N0YWNrTWl4aW4nO1xuaW1wb3J0IExheW91dE1peGluIGZyb20gJy4vbGF5b3V0TWl4aW4nO1xuaW1wb3J0IHsgYm91bmRpbmdfYm94IH0gZnJvbSAnLi4vdXRpbHMvZnVuY3Rpb25zJztcbmltcG9ydCB7IERJUkVDVElPTiB9IGZyb20gJy4uL3V0aWxzL2NvbnN0YW5jZSc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSWNvbn5JbWFnZUJvdW5kaW5nXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggICAtIOWbvueJh+WuveW6plxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAgIC0g5Zu+54mH6auY5bqmIFxuICovXG4vKipcbiAqIOWbvueJh+WNleWFgyDphY3nva5cbiAqIEB0eXBlZGVmIHtSZWN0YW5nbGV+UmVjdGFuZ2xlQ29uZmlnc30gSWNvbn5JY29uQ29uZmlnc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGltYWdlICAgLSDlm77niYflnLDlnYBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbWFnZVdpZHRoICAgLSDlm77niYflrr3luqZcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbWFnZUhlaWdodCAgIC0g5Zu+54mH6auY5bqmXG4gKi9cblxuLyoqXG4gKiDlm77niYfljZXlhYNcbiAqIEBkZXNjcmlwdGlvbiDlm77niYfljZXlhYPlj6/ku6Xnu5jliLblm77niYfvvIzlm77niYfliqDovb3lkI7kvJroh6rliqjph43mlrDnu5jliLZcbiAqIEBjb25zdHJ1Y3RvciBJY29uXG4gKiBAZXh0ZW5kcyBSZWN0YW5nbGVcbiAqIEBwYXJhbSB7SWNvbn5JY29uQ29uZmlnc30gY29uZmlncyAtIOmFjee9rlxuICovXG5jbGFzcyBJY29uIGV4dGVuZHMgUmVjdGFuZ2xlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3MpXG4gICAgICAgIC8qKiBAbWVtYmVyIHtDYW52YXNJbWFnZVNvdXJjZX0gICAgICAtIOWbvueJhyAqL1xuICAgICAgICB0aGlzLmltYWdlID0gY29uZmlncy5pbWFnZTtcbiAgICAgICAgdGhpcy5pbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9qZmxvdy5fcmVuZGVyKCk7XG4gICAgICAgICAgICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gfSlcbiAgICAgICAgfVxuICAgICAgICAvKiogQG1lbWJlciB7SWNvbn5JbWFnZUJvdW5kaW5nfSAgICAgIC0g5Zu+54mH57u05bqmICovXG4gICAgICAgIHRoaXMuaW1hZ2VCb3VuZGluZyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBjb25maWdzLmltYWdlV2lkdGggfHwgY29uZmlncy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogY29uZmlncy5pbWFnZUhlaWdodCB8fCAgY29uZmlncy5oZWlnaHQsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRDb25maWcoY29uZmlncykge1xuICAgICAgICBPYmplY3Qua2V5cyhjb25maWdzKS5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAgICAgaWYoY29uZmlnc1trXSAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZ3Nba10gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tdID0gY29uZmlnc1trXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXdDb25maWdzW2tdID0gY29uZmlnc1trXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmKGNvbmZpZ3MuaW1hZ2UgJiYgIWNvbmZpZ3MuaW1hZ2UuY29tcGxldGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2pmbG93Ll9yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vICAgICB0aGlzLl9qZmxvdy5fcmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgLy8gfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmltYWdlQm91bmRpbmcgPSB7XG4gICAgICAgICAgICB3aWR0aDogY29uZmlncy5pbWFnZVdpZHRoIHx8IGNvbmZpZ3Mud2lkdGggfHwgdGhpcy5pbWFnZUJvdW5kaW5nLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBjb25maWdzLmltYWdlSGVpZ2h0IHx8ICBjb25maWdzLmhlaWdodCB8fCB0aGlzLmltYWdlQm91bmRpbmcuaGVpZ2h0LFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKGN0eCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBpZih0aGlzLl9pc01vdmluZyl7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjZcbiAgICAgICAgfVxuICAgICAgICBSZWN0YW5nbGUucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMsIGN0eCk7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLmFuY2hvclswXSAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5hbmNob3JbMV0gLSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgIGlmKHRoaXMub3BhY2l0eSA8IDEpIHtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMub3BhY2l0eTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLmltYWdlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuaW1hZ2UsIHgsIHksIHRoaXMuaW1hZ2VCb3VuZGluZy53aWR0aCwgdGhpcy5pbWFnZUJvdW5kaW5nLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBJY29uOyIsImltcG9ydCBSZWN0YW5nbGUgZnJvbSAnLi9zaGFwZXMvcmVjdGFuZ2xlJztcbi8qKlxuICogQGZ1bnRpb24gZG9tRmFjdG9yeVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgLSBET03lrrnlmahcbiAqL1xuLyoqXG4gKiBET03lhYPntKDlrrnlmagg6YWN572uXG4gKiBAdHlwZWRlZiB7UmVjdGFuZ2xlfkNvbmZpZ3N9IFNoYWRvd0RvbX5SZWN0YW5nbGVDb25maWdzXG4gKiBAcHJvcGVydHkge2RvbUZhY3Rvcnl9IGNyZWF0ZURvY3VtZW50IC0g5a69XG4gKi9cbi8qKlxuICogRE9N5YWD57Sg5a655ZmoIOWGheWuueWPr+i0tCBET00g5YWD57Sg77yM5pSv5oyB57yp5pS+5bmz56e7XG4gKiBAY29uc3RydWN0b3IgU2hhZG93RG9tXG4gKiBAZXh0ZW5kcyBSZWN0YW5nbGVcbiAqIEBwYXJhbSB7U2hhZG93RG9tflJlY3RhbmdsZUNvbmZpZ3N9IGNvbmZpZ3NcbiAqL1xuY2xhc3MgU2hhZG93RG9tIGV4dGVuZHMgUmVjdGFuZ2xlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3MpO1xuICAgICAgICB0aGlzLmRvbUZhY3RvcnkgPSBjb25maWdzLmNyZWF0ZURvY3VtZW50O1xuICAgICAgICB0aGlzLl9kb20gPSBudWxsO1xuICAgIH1cblxuICAgIGdldFJlYWxXb3JsZFBvc2l0aW9uKCkge1xuICAgICAgICBjb25zdCBiID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlVG9SZWFsV29ybGQoYi5zbGljZSgwLCAyKSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKGN0eCkge1xuICAgICAgICBpZighdGhpcy5fZG9tICYmIHRoaXMuZG9tRmFjdG9yeSkge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZighdGhpcy5fZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3MgPSB0aGlzLmdldFJlYWxXb3JsZFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5famZsb3cuc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgYFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICR7dGhpcy53aWR0aH1weDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogJHt0aGlzLmhlaWdodH1weDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKCR7cG9zWzBdfXB4LCAke3Bvc1sxXX1weCkgc2NhbGUoJHtzY2FsZX0pO2ApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb20gPSBjb250YWluZXI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2pmbG93LkRPTXdyYXBwZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb21GYWN0b3J5KGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSB0aGlzLmdldFJlYWxXb3JsZFBvc2l0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2pmbG93LnNjYWxlO1xuICAgICAgICAgICAgdGhpcy5fZG9tLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtwb3NbMF19cHgsICR7cG9zWzFdfXB4KSBzY2FsZSgke3NjYWxlfSlgXG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIucmVuZGVyKGN0eClcbiAgICB9ICAgIFxuXG4gICAgb25FbnRlclZpZXdib3goKSB7XG4gICAgICAgIGlmKHRoaXMuX2RvbSkge1xuICAgICAgICAgICAgdGhpcy5fZG9tLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25MZWF2ZVZpZXdib3goKXtcbiAgICAgICAgaWYodGhpcy5fZG9tKSB7XG4gICAgICAgICAgICB0aGlzLl9kb20uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLl9kb20pIHtcbiAgICAgICAgICAgIHRoaXMuX2pmbG93LkRPTXdyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcy5fZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgU2hhZG93RG9tO1xuIiwiaW1wb3J0IEJhc2VMaW5rIGZyb20gJy4vYmFzZS1saW5rJztcbmltcG9ydCB7IGRpc3RUb1NlZ21lbnRTcXVhcmVkLFxuICAgIGlzUG9seUxpbmVJbnRlcnNlY3Rpb25SZWN0YW5nZSxcbiAgICBjb21wYXJlQm91bmRpbmdib3gsXG4gICAgY29weUJvdW5kaW5nYm94XG59IGZyb20gJy4uL3V0aWxzL2Z1bmN0aW9ucyc7XG5pbXBvcnQgeyBBUFBST1hJTUFURSB9IGZyb20gJy4uL3V0aWxzL2NvbnN0YW5jZSc7XG4vKipcbiAqIEB0eXBlZGVmIHtCYXNlTGlua35Db25maWdzfSBMaW5rfkNvbmZpZ3NcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBhcHByb3hpbWF0ZSAgIC0g54K55Ye75ZON5bqU6IyD5Zu0XG4gKiBAcHJvcGVydHkge051bWJlcltdfSBsaW5lRGFzaCAgICAtIOiZmue6v+aVsOe7hFxuICogQHByb3BlcnR5IHtCb29sZWFufSBkb3VibGVMaW5rICAgLSDlj4zlkJHnrq3lpLRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBmb250RmFtaWx5ICAgIC0g6L+e57q/5LiK55qE5paH5a2X5a2X5L2TXG4gKiBAcHJvcGVydHkge051bWJlcn0gZm9udFNpemUgICAgICAtIOi/nue6v+S4iueahOaWh+Wtl+Wkp+Wwj1xuICogQHByb3BlcnR5IHtTdHJpbmd9IGNvbnRlbnQgICAgICAgLSDov57nur/kuIrnmoTmloflrZdcbiAqL1xuLyoqXG4gKiDnm7Tnur9cbiAqIEBjb25zdHJ1Y3RvciBMaW5rXG4gKiBAZXh0ZW5kcyBCYXNlTGlua1xuICogQHBhcmFtIHtMaW5rfkNvbmZpZ3N9IGNvbmZpZ3MgLSDphY3nva5cbiAqL1xuY2xhc3MgTGluayBleHRlbmRzIEJhc2VMaW5rIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3MpO1xuICAgICAgICB0aGlzLmZvbnRGYW1pbHkgICAgPSBjb25maWdzLmZvbnRGYW1pbHkgPSAnLWFwcGxlLXN5c3RlbSxCbGlua01hY1N5c3RlbUZvbnQsU2Vnb2UgVUksUm9ib3RvLEhlbHZldGljYSBOZXVlLEhlbHZldGljYSxUYWhvbWEsQXJpYWwsTm90byBTYW5zLFBpbmdGYW5nIFNDLE1pY3Jvc29mdCBZYUhlaSxIaXJhZ2lubyBTYW5zIEdCLHNhbnMtc2VyaWYsQXBwbGUgQ29sb3IgRW1vamksU2Vnb2UgVUkgRW1vamksU2Vnb2UgVUkgU3ltYm9sLE5vdG8gQ29sb3IgRW1vamknXG4gICAgICAgIHRoaXMuZm9udFNpemUgICAgICA9IGNvbmZpZ3MuZm9udFNpemUgfHwgJzEycHgnO1xuICAgICAgICB0aGlzLmNvbnRlbnQgICAgICAgPSBjb25maWdzLmNvbnRlbnQgfHwgJyc7XG4gICAgICAgIHRoaXMubGluZURhc2ggICAgICA9IGNvbmZpZ3MubGluZURhc2g7XG4gICAgICAgIHRoaXMuYXBwcm94aW1hdGUgID0gY29uZmlncy5hcHByb3hpbWF0ZSB8fCBBUFBST1hJTUFURTtcblxuICAgICAgICB0aGlzLl9jYWNoZUFuZ2xlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jYWNoZVBvaW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9jYWNoZUJvdW5kaW5nYm94ID0ge1xuICAgICAgICAgICAgZnJvbTogW10sXG4gICAgICAgICAgICB0bzogW11cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBfY2FsY3VsYXRlQW5jaG9yUG9pbnRzKCkge1xuICAgICAgICBjb25zdCBwMCA9IHRoaXMuZnJvbS5jYWxjdWxhdGVJbnRlcnNlY3Rpb24odGhpcy50by5nZXRDZW50ZXIoKSk7XG4gICAgICAgIGNvbnN0IHAxID0gdGhpcy50by5jYWxjdWxhdGVJbnRlcnNlY3Rpb24odGhpcy5mcm9tLmdldENlbnRlcigpKTtcbiAgICAgICAgdGhpcy5fY2FjaGVQb2ludHNbMF0gPSBwMDtcbiAgICAgICAgdGhpcy5fY2FjaGVQb2ludHNbMV0gPSBwMTtcbiAgICAgICAgY29uc3QgZHggPSBwMVswXSAtIHAwWzBdO1xuICAgICAgICBjb25zdCBkeSA9IHAxWzFdIC0gcDBbMV07XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMihkeSwgZHgpO1xuICAgICAgICB0aGlzLl9jYWNoZUFuZ2xlID0gYW5nbGU7XG4gICAgfVxuICAgIFxuICAgIGlzSW5WaWV3Qm94KGJyKSB7XG4gICAgICAgIGNvbnN0IGZyb21ib3ggPSB0aGlzLmZyb20uZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgIGNvbnN0IHRvYm94ID0gdGhpcy50by5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgY29uc3QgX2JveCA9IHRoaXMuX2NhY2hlQm91bmRpbmdib3g7XG4gICAgICAgIGlmKCFjb21wYXJlQm91bmRpbmdib3goX2JveC5mcm9tLCBmcm9tYm94KSB8fCBjb21wYXJlQm91bmRpbmdib3goX2JveC50bywgdG9ib3gpKSB7XG4gICAgICAgICAgICBjb3B5Qm91bmRpbmdib3goX2JveC5mcm9tLCBmcm9tYm94KTtcbiAgICAgICAgICAgIGNvcHlCb3VuZGluZ2JveChfYm94LnRvLCB0b2JveCk7XG4gICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVBbmNob3JQb2ludHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIGNvbnN0IFsgcDAsIHAxIF0gPSB0aGlzLl9jYWNoZVBvaW50cztcbiAgICAgICAgY29uc3QgYW5nbGUgPSB0aGlzLl9jYWNoZUFuZ2xlO1xuICAgICAgICBjb25zdCBkeCA9IHAxWzBdIC0gcDBbMF07XG4gICAgICAgIGNvbnN0IGR5ID0gcDFbMV0gLSBwMFsxXTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGlmKHRoaXMuY29udGVudCl7IFxuXG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICBjdHguZm9udCA9IGAke3RoaXMuZm9udFNpemV9ICR7dGhpcy5mb250RmFtaWx5fWA7XG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgYWN0dWFsQm91bmRpbmdCb3hMZWZ0LFxuICAgICAgICAgICAgICAgIGFjdHVhbEJvdW5kaW5nQm94UmlnaHQsXG4gICAgICAgICAgICAgICAgZm9udEJvdW5kaW5nQm94QXNjZW50LFxuICAgICAgICAgICAgICAgIGZvbnRCb3VuZGluZ0JveERlc2NlbnRcbiAgICAgICAgICAgIH0gPSBjdHgubWVhc3VyZVRleHQodGhpcy5jb250ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBkeCAvMiArIHAwWzBdO1xuICAgICAgICAgICAgY29uc3QgeSA9IGR5IC8yICsgcDBbMV07XG4gICAgICAgICAgICBjdHguZmlsbFRleHQodGhpcy5jb250ZW50LCB4LCB5KTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5hYnMoYWN0dWFsQm91bmRpbmdCb3hMZWZ0KSArIE1hdGguYWJzKGFjdHVhbEJvdW5kaW5nQm94UmlnaHQpICsgMjA7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSAoTWF0aC5hYnMoZm9udEJvdW5kaW5nQm94QXNjZW50KSArIE1hdGguYWJzKGZvbnRCb3VuZGluZ0JveERlc2NlbnQpKSAqIDEuNTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGxldCByZWdpb24gPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgICAgICByZWdpb24ucmVjdCh4IC0gd2lkdGgvMiAsIHkgLSBoZWlnaHQvMiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBjb25zdCByeCA9IE1hdGgubWluKHAxWzBdLCBwMFswXSkgLSAxMDtcbiAgICAgICAgICAgIGNvbnN0IHJ5ID0gTWF0aC5taW4ocDFbMV0sIHAwWzFdKSAtIDEwO1xuICAgICAgICAgICAgY29uc3QgcncgPSBNYXRoLmFicyhkeCkgKyAyMDtcbiAgICAgICAgICAgIGNvbnN0IHJoID0gTWF0aC5hYnMoZHkpICsgMjA7XG4gICAgICAgICAgICByZWdpb24ucmVjdChyeCAsIHJ5LCBydywgcmgpO1xuICAgICAgICAgICAgY3R4LmNsaXAocmVnaW9uLCBcImV2ZW5vZGRcIik7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGN0eC5tb3ZlVG8ocDBbMF0sIHAwWzFdKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwMVswXSwgcDFbMV0pO1xuICAgICAgICBpZih0aGlzLmxpbmVEYXNoKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKHRoaXMubGluZURhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgaWYodGhpcy5saW5lRGFzaCkge1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC50cmFuc2xhdGUocDFbMF0sIHAxWzFdKTtcbiAgICAgICAgY3R4LnJvdGF0ZShhbmdsZSk7XG4gICAgICAgIGN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgIGN0eC5saW5lVG8oLTUsIC00KTtcbiAgICAgICAgY3R4LmxpbmVUbygtNSwgNCk7XG4gICAgICAgIGN0eC5saW5lVG8oMCwgMCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5yb3RhdGUoLWFuZ2xlKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgtcDFbMF0sIC1wMVsxXSk7XG4gICAgfVxuXG4gICAgaXNIaXQocG9pbnQpIHtcbiAgICAgICAgaWYoIXRoaXMuX2NhY2hlUG9pbnRzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IFsgc3RhcnQsIGVuZCBdID0gdGhpcy5fY2FjaGVQb2ludHM7XG4gICAgICAgIGNvbnN0IGRpc3QgPSBkaXN0VG9TZWdtZW50U3F1YXJlZChwb2ludCwgc3RhcnQsIGVuZClcbiAgICAgICAgcmV0dXJuIGRpc3QgPCB0aGlzLmFwcHJveGltYXRlO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGluazsiLCJpbXBvcnQgQmFzZUxpbmsgZnJvbSAnLi9iYXNlLWxpbmsnO1xuaW1wb3J0IHsgXG4gICAgcG9seWxpbmVQb2ludHMsIFxuICAgIGRpc3RUb1NlZ21lbnRTcXVhcmVkLCBcbiAgICBtYWtlUmFkaXVzRnJvbVZlY3RvciwgXG4gICAgbWluSW50ZXJzZWN0aW9uQmV0d2Vlbk5vZGVzLFxuICAgIGlzUG9seUxpbmVJbnRlcnNlY3Rpb25SZWN0YW5nZSxcbn0gZnJvbSAnLi4vdXRpbHMvZnVuY3Rpb25zJztcbmltcG9ydCB7IEFQUFJPWElNQVRFLCBESVJFQ1RJT04gfSBmcm9tICcuLi91dGlscy9jb25zdGFuY2UnO1xuLy8gaW1wb3J0IHsgZGlzdDIsIGJlemllclBvaW50IH0gZnJvbSAnLi4vdXRpbHMvZnVuY3Rpb25zJztcbmNvbnN0IFBJSU5SQVRJTyA9IE1hdGguUEkgLyAxODBcbi8qKlxuICogQHR5cGVkZWYge0Jhc2VMaW5rfkNvbmZpZ3N9IFBvbHlMaW5rfkNvbmZpZ3NcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBhcHByb3hpbWF0ZSAgIC0g54K55Ye75ZON5bqU6IyD5Zu0XG4gKiBAcHJvcGVydHkge051bWJlcn0gcmFkaXVzICAgICAgICAtIOaLkOinkuW8p+W6plxuICogQHByb3BlcnR5IHtOdW1iZXJ9IG1pblNwYW5YICAgICAgLSDotbfngrnnu4jngrnlnKggeCDmlrnlkJHmnIDlsI/nmoTot6jluqZcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtaW5TcGFuWSAgICAgIC0g6LW354K557uI54K55ZyoIHkg5pa55ZCR5pyA5bCP55qE6Leo5bqmXG4gKiBAcHJvcGVydHkge251bWJlcltdfSBsaW5lRGFzaCAgICAtIOiZmue6v+aVsOe7hFxuICogQHByb3BlcnR5IHtCb29sZWFufSBkb3VibGVMaW5rICAgLSDlj4zlkJHnrq3lpLRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBmb250RmFtaWx5ICAgIC0g6L+e57q/5LiK55qE5paH5a2X5a2X5L2TXG4gKiBAcHJvcGVydHkge051bWJlcn0gZm9udFNpemUgICAgICAtIOi/nue6v+S4iueahOaWh+Wtl+Wkp+Wwj1xuICogQHByb3BlcnR5IHtTdHJpbmd9IGNvbnRlbnQgICAgICAgLSDov57nur/kuIrnmoTmloflrZdcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBpc1NlbGYgICAgICAgIC0g5piv5ZCm5Li66Ieq6L+e5o6lXG4gKi9cbi8qKlxuICog5pa55b2i5oqY57q/XG4gKiBAY29uc3RydWN0b3IgUG9seUxpbmtcbiAqIEBleHRlbmRzIEJhc2VMaW5rXG4gKiBAcGFyYW0ge1BvbHlMaW5rfkNvbmZpZ3N9IGNvbmZpZ3MgLSDphY3nva5cbiAqL1xuY2xhc3MgUG9seUxpbmsgZXh0ZW5kcyBCYXNlTGluayB7XG4gICAgIC8qKlxuICAgICAqIOWIm+W7uuaWueW9ouaKmOe6v1xuICAgICAqIEBwYXJhbSB7UG9seUxpbmt+Q29uZmlnc30gY29uZmlncyAtIOmFjee9rlxuICAgICAqKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3MpO1xuICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgIC0g54K55Ye75ZON5bqU6IyD5Zu0ICovXG4gICAgICAgIHRoaXMuYXBwcm94aW1hdGUgICA9IGNvbmZpZ3MuYXBwcm94aW1hdGUgfHwgQVBQUk9YSU1BVEU7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgLSDmi5Dop5LlvKfluqYgKi9cbiAgICAgICAgdGhpcy5yYWRpdXMgICAgICAgID0gY29uZmlncy5yYWRpdXMgfHwgMDtcbiAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAtIOi1t+eCuee7iOeCueWcqCB4IOaWueWQkeacgOWwj+eahOi3qOW6piAqL1xuICAgICAgICB0aGlzLm1pblNwYW5YICAgICAgPSBjb25maWdzLm1pblNwYW5YIHx8IDEwO1xuICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgIC0g6LW354K557uI54K55ZyoIHkg5pa55ZCR5pyA5bCP55qE6Leo5bqmICovXG4gICAgICAgIHRoaXMubWluU3BhblkgICAgICA9IGNvbmZpZ3MubWluU3BhblkgfHwgMTA7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgIC0g6Jma57q/5pWw57uEICovXG4gICAgICAgIHRoaXMubGluZURhc2ggICAgICA9IGNvbmZpZ3MubGluZURhc2g7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgIC0g5Y+M5ZCR566t5aS0ICovXG4gICAgICAgIHRoaXMuZG91YmxlTGluayAgICA9IGNvbmZpZ3MuZG91YmxlTGluaztcbiAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgLSDov57nur/kuIrnmoTmloflrZflrZfkvZMgKi9cbiAgICAgICAgdGhpcy5mb250RmFtaWx5ICAgID0gY29uZmlncy5mb250RmFtaWx5ID0gJy1hcHBsZS1zeXN0ZW0sQmxpbmtNYWNTeXN0ZW1Gb250LFNlZ29lIFVJLFJvYm90byxIZWx2ZXRpY2EgTmV1ZSxIZWx2ZXRpY2EsVGFob21hLEFyaWFsLE5vdG8gU2FucyxQaW5nRmFuZyBTQyxNaWNyb3NvZnQgWWFIZWksSGlyYWdpbm8gU2FucyBHQixzYW5zLXNlcmlmLEFwcGxlIENvbG9yIEVtb2ppLFNlZ29lIFVJIEVtb2ppLFNlZ29lIFVJIFN5bWJvbCxOb3RvIENvbG9yIEVtb2ppJ1xuICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAtIOi/nue6v+S4iueahOaWh+Wtl+Wkp+WwjyAqL1xuICAgICAgICB0aGlzLmZvbnRTaXplICAgICAgPSBjb25maWdzLmZvbnRTaXplIHx8ICcxMnB4JztcbiAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgLSDov57nur/kuIrnmoTmloflrZcgKi9cbiAgICAgICAgdGhpcy5jb250ZW50ICAgICAgID0gY29uZmlncy5jb250ZW50IHx8ICcnO1xuICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAtIOaYr+WQpuS4uuiHqui/nuaOpSAqL1xuICAgICAgICB0aGlzLmlzU2VsZiAgICAgICAgPSAhIWNvbmZpZ3MuaXNTZWxmXG5cbiAgICAgICAgdGhpcy5ub0Fycm93ICAgICAgID0gISFjb25maWdzLm5vQXJyb3cgXG4gICAgICAgIHRoaXMuX2NhY2hlQW5nbGUgPSBbXTtcbiAgICAgICAgdGhpcy5fY2FjaGVQb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy5fY2FjaGVCb3VuZGluZ2JveCA9IHtcbiAgICAgICAgICAgIGZyb206IFtdLFxuICAgICAgICAgICAgdG86IFtdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgX2NhbGN1bGF0ZUFuY2hvclBvaW50cygpIHtcbiAgICAgICAgY29uc3QgZG1zZnJvbSA9IHRoaXMuZnJvbS5nZXRJbnRlcnNlY3Rpb25zSW5Gb3VyRGltZW5zaW9uKCk7XG4gICAgICAgIGNvbnN0IGRtc3RvID0gdGhpcy50by5nZXRJbnRlcnNlY3Rpb25zSW5Gb3VyRGltZW5zaW9uKCk7XG4gICAgICAgIGNvbnN0IF9jYWNoZUFuZ2xlID0gdGhpcy5fY2FjaGVBbmdsZTtcbiAgICAgICAgaWYodGhpcy5pc1NlbGYpe1xuICAgICAgICAgICAgcG9seWxpbmVQb2ludHMoXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVQb2ludHMsXG4gICAgICAgICAgICAgICAgZG1zZnJvbVt0aGlzLmZyb21EaXJdLFxuICAgICAgICAgICAgICAgIGRtc3RvW0RJUkVDVElPTi5TRUxGXSxcbiAgICAgICAgICAgICAgICB0aGlzLmZyb21EaXIsXG4gICAgICAgICAgICAgICAgdGhpcy50b0RpciwgXG4gICAgICAgICAgICAgICAgdGhpcy5taW5TcGFuWCwgXG4gICAgICAgICAgICAgICAgdGhpcy5taW5TcGFuWSxcbiAgICAgICAgICAgICAgICB0cnVlKTtcbiAgICAgICAgICAgIF9jYWNoZUFuZ2xlWzBdID0gdGhpcy5mcm9tRGlyO1xuICAgICAgICAgICAgX2NhY2hlQW5nbGVbMV0gPSB0aGlzLnRvRGlyO1xuICAgICAgICB9IGVsc2UgaWYodGhpcy5mcm9tRGlyICE9PSB1bmRlZmluZWQgJiYgdGhpcy50b0RpciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwb2x5bGluZVBvaW50cyhcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZVBvaW50cyxcbiAgICAgICAgICAgICAgICBkbXNmcm9tW3RoaXMuZnJvbURpcl0sXG4gICAgICAgICAgICAgICAgZG1zdG9bdGhpcy50b0Rpcl0sXG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tRGlyLFxuICAgICAgICAgICAgICAgIHRoaXMudG9EaXIsIHRoaXMubWluU3BhblggLCB0aGlzLm1pblNwYW5ZKTtcbiAgICAgICAgICAgIF9jYWNoZUFuZ2xlWzBdID0gdGhpcy5mcm9tRGlyO1xuICAgICAgICAgICAgX2NhY2hlQW5nbGVbMV0gPSB0aGlzLnRvRGlyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWV0YSA9IG1pbkludGVyc2VjdGlvbkJldHdlZW5Ob2RlcyhkbXNmcm9tLCBkbXN0byk7XG4gICAgICAgICAgICBwb2x5bGluZVBvaW50cyhcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZVBvaW50cyxcbiAgICAgICAgICAgICAgICBtZXRhLmZyb21QLFxuICAgICAgICAgICAgICAgIG1ldGEudG9QLFxuICAgICAgICAgICAgICAgIG1ldGEuZnJvbURpcixcbiAgICAgICAgICAgICAgICBtZXRhLnRvRGlyLFxuICAgICAgICAgICAgICAgIHRoaXMubWluU3BhblggLCB0aGlzLm1pblNwYW5ZKTtcbiAgICAgICAgICAgIF9jYWNoZUFuZ2xlWzBdID0gbWV0YS5mcm9tRGlyO1xuICAgICAgICAgICAgX2NhY2hlQW5nbGVbMV0gPSBtZXRhLnRvRGlyO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlzSW5WaWV3Qm94KGJyKSB7XG4gICAgICAgIGlmKHRoaXMuX3N0YXRpYykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlQW5jaG9yUG9pbnRzKCk7ICAgICBcbiAgICAgICAgcmV0dXJuIGlzUG9seUxpbmVJbnRlcnNlY3Rpb25SZWN0YW5nZSh0aGlzLl9jYWNoZVBvaW50cywgYnIpO1xuICAgIH1cblxuICAgIHJlbmRlcihjdHgpIHtcbiAgICAgICAgLy8gdGhpcy5fY2FsY3VsYXRlQW5jaG9yUG9pbnRzKCk7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IHRoaXMucmFkaXVzO1xuICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9jYWNoZVBvaW50cztcbiAgICAgICAgY29uc3QgcCA9IHBvaW50c1swXTtcbiAgICAgICAgY29uc3QgcEVuZCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IGFuZ2xlRW5kID0gKCh0aGlzLl9jYWNoZUFuZ2xlWzFdICsgMikgJSA0KSAqIDkwICogUElJTlJBVElPO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGlmKHRoaXMuZG91YmxlTGluaykge1xuICAgICAgICAgICAgY29uc3QgYmVnaW5BbmdsZSA9ICgodGhpcy5fY2FjaGVBbmdsZVswXSArIDIpICUgNCkgKiA5MCAqIFBJSU5SQVRJTztcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUocFswXSwgcFsxXSk7XG4gICAgICAgICAgICBjdHgucm90YXRlKGJlZ2luQW5nbGUpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyg1LCAwKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oMCwgLTQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbygwLCA0KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oNSwgMCk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZSgtYmVnaW5BbmdsZSk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1wWzBdLCAtcFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHBbMF0sIHBbMV0pO1xuICAgICAgICBwb2ludHMuc2xpY2UoMSwgcG9pbnRzLmxlbmd0aCAtIDEpLmZvckVhY2goKHAsIGlkeCkgPT4ge1xuICAgICAgICAgICAgaWYodGhpcy5yYWRpdXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwTGFzdCA9IHBvaW50c1tpZHhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBOZXh0ID0gcG9pbnRzW2lkeCsyXTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAxLCBwMiB9ID0gbWFrZVJhZGl1c0Zyb21WZWN0b3IocExhc3QsIHAsIHBOZXh0LCByYWRpdXMpO1xuICAgICAgICAgICAgICAgIGlmKHAxICYmIHAyKXtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwMVswXSwgcDFbMV0pO1xuICAgICAgICAgICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhwWzBdLCBwWzFdLCBwMlswXSwgcDJbMV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocFswXSwgcFsxXSk7XG4gICAgICAgICAgICAgICAgfSAgXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocFswXSwgcFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjdHgubGluZVRvKHBFbmRbMF0sIHBFbmRbMV0pO1xuXG4gICAgICAgIGlmKHRoaXMubGluZURhc2gpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguc2V0TGluZURhc2godGhpcy5saW5lRGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBpZih0aGlzLmxpbmVEYXNoKSB7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXRoaXMubm9BcnJvdykge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShwRW5kWzBdLCBwRW5kWzFdKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoYW5nbGVFbmQpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oLTUsIC00KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oLTUsIDQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbygwLCAwKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICBjdHgucm90YXRlKC1hbmdsZUVuZCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1wRW5kWzBdLCAtcEVuZFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5jb250ZW50KSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguZm9udCA9IGAke3RoaXMuZm9udFNpemV9ICR7dGhpcy5mb250RmFtaWx5fWA7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZnJvbURpcikge1xuICAgICAgICAgICAgICAgIGNhc2UgRElSRUNUSU9OLkJPVFRPTTpcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMuY29udGVudCwgcFswXSArIDIsIHBbMV0gKyAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRElSRUNUSU9OLlJJR0hUOlxuICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGhpcy5jb250ZW50LCBwWzBdICsgMTAsIHBbMV0gLSAyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGlzSGl0KHBvaW50KSB7XG4gICAgICAgIGlmKHRoaXMuX3N0YXRpYykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmKCF0aGlzLl9jYWNoZVBvaW50cykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX2NhY2hlUG9pbnRzO1xuICAgICAgICBsZXQgbGFzdFAgPSBwb2ludHNbMF07XG4gICAgICAgIGNvbnN0IHJlbWFpblBvaW50cyA9IHBvaW50cy5zbGljZSgxKVxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UCA9IHJlbWFpblBvaW50cy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYoY3VycmVudFApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0ID0gZGlzdFRvU2VnbWVudFNxdWFyZWQocG9pbnQsIGxhc3RQLCBjdXJyZW50UCk7XG4gICAgICAgICAgICAgICAgaWYoZGlzdCA8IHRoaXMuYXBwcm94aW1hdGUpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0UCA9IGN1cnJlbnRQO1xuICAgICAgICB9IHdoaWxlKGxhc3RQKVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNsb25lU3RhdGljKCkge1xuICAgICAgICBjb25zdCB0ID0gbmV3IFBvbHlMaW5rKHt9KTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0LCB7XG4gICAgICAgICAgICByYWRpdXM6IHRoaXMucmFkaXVzLFxuICAgICAgICAgICAgX2NhY2hlUG9pbnRzOiB0aGlzLl9jYWNoZVBvaW50cyxcbiAgICAgICAgICAgIF9jYWNoZUFuZ2xlOiB0aGlzLl9jYWNoZUFuZ2xlLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGRvdWJsZUxpbms6IHRoaXMuZG91YmxlTGluayxcbiAgICAgICAgICAgIHJhZGl1czogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICBsaW5lRGFzaDogdGhpcy5saW5lRGFzaCxcbiAgICAgICAgICAgIG5vQXJyb3c6IHRoaXMubm9BcnJvdyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuY29udGVudCxcbiAgICAgICAgICAgIGZvbnRTaXplOiB0aGlzLmZvbnRTaXplLFxuICAgICAgICAgICAgZm9udEZhbWlseTogdGhpcy5mb250RmFtaWx5LFxuICAgICAgICAgICAgZnJvbURpcjogdGhpcy5mcm9tRGlyLFxuICAgICAgICAgICAgX3N0YXRpYzogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9seUxpbms7IiwiaW1wb3J0IEJhc2VMaW5rIGZyb20gJy4vYmFzZS1saW5rJztcbmltcG9ydCB7IGJlemllclBvaW50cywgZGlzdFRvQmV6aWVyU2VnbWVudFNxdWFyZWQsIGdldEJlemllckFuZ2xlLCBtaW5JbnRlcnNlY3Rpb25CZXR3ZWVuTm9kZXMgfSBmcm9tICcuLi91dGlscy9mdW5jdGlvbnMnO1xuaW1wb3J0IHsgQVBQUk9YSU1BVEUsIERJUkVDVElPTiB9IGZyb20gJy4uL3V0aWxzL2NvbnN0YW5jZSc7XG5pbXBvcnQgeyBkaXN0MiwgYmV6aWVyUG9pbnQgfSBmcm9tICcuLi91dGlscy9mdW5jdGlvbnMnO1xuY29uc3QgUElJTlJBVElPID0gTWF0aC5QSSAvIDE4MFxuLyoqXG4gKiBAdHlwZWRlZiB7QmFzZUxpbmt+Q29uZmlnc30gQmV6aWVyTGlua35Db25maWdzXG4gKiBAcHJvcGVydHkge051bWJlcn0gYXBwcm94aW1hdGUgICAtIOeCueWHu+WTjeW6lOiMg+WbtFxuICogQHByb3BlcnR5IHtOdW1iZXJ9IG1pblNwYW5YICAgICAgLSDotbfngrnnu4jngrnlnKggeCDmlrnlkJHmnIDlsI/nmoTot6jluqZcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtaW5TcGFuWSAgICAgIC0g6LW354K557uI54K55ZyoIHkg5pa55ZCR5pyA5bCP55qE6Leo5bqmXG4gKiBAcHJvcGVydHkge051bWJlcltdfSBsaW5lRGFzaCAgICAtIOiZmue6v+aVsOe7hFxuICogQHByb3BlcnR5IHtCb29sZWFufSBkb3VibGVMaW5rICAgLSDlj4zlkJHnrq3lpLRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBmb250RmFtaWx5ICAgIC0g6L+e57q/5LiK55qE5paH5a2X5a2X5L2TXG4gKiBAcHJvcGVydHkge051bWJlcn0gZm9udFNpemUgICAgICAtIOi/nue6v+S4iueahOaWh+Wtl+Wkp+Wwj1xuICogQHByb3BlcnR5IHtTdHJpbmd9IGNvbnRlbnQgICAgICAgLSDov57nur/kuIrnmoTmloflrZdcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNTZWxmICAgICAgICAtIOaYr+WQpuS4uuiHqui/nuaOpVxuICovXG4vKipcbiAqIOi0neWhnuWwlOabsue6v1xuICogQGNvbnN0cnVjdG9yIEJlemllckxpbmtcbiAqIEBleHRlbmRzIEJhc2VMaW5rXG4gKiBAcGFyYW0ge0Jlemllckxpbmt+Q29uZmlnc30gY29uZmlncyAtIOmFjee9rlxuICovXG5jbGFzcyBCZXppZXJMaW5rIGV4dGVuZHMgQmFzZUxpbmsge1xuICAgICAvKipcbiAgICAgKiDliJvlu7rotJ3loZ7lsJTmm7Lnur8uXG4gICAgICogQHBhcmFtIHtCZXppZXJMaW5rfkNvbmZpZ3N9IGNvbmZpZ3MgLSDphY3nva5cbiAgICAgKiovXG4gICAgY29uc3RydWN0b3IoY29uZmlncykge1xuICAgICAgICBzdXBlcihjb25maWdzKTtcbiAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgICAtIOeCueWHu+WTjeW6lOiMg+WbtCAqL1xuICAgICAgICB0aGlzLmFwcHJveGltYXRlICAgPSBjb25maWdzLmFwcHJveGltYXRlIHx8IEFQUFJPWElNQVRFO1xuICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAgIC0g6LW354K557uI54K55ZyoIHgg5pa55ZCR5pyA5bCP55qE6Leo5bqmICovXG4gICAgICAgIHRoaXMubWluU3BhblggICAgICA9IGNvbmZpZ3MubWluU3BhblggfHwgMDtcbiAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgICAtIOi1t+eCuee7iOeCueWcqCB5IOaWueWQkeacgOWwj+eahOi3qOW6piAqL1xuICAgICAgICB0aGlzLm1pblNwYW5ZICAgICAgPSBjb25maWdzLm1pblNwYW5ZIHx8IDA7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJbXX0gICAgICAtIOiZmue6v+aVsOe7hCAqL1xuICAgICAgICB0aGlzLmxpbmVEYXNoICAgICAgPSBjb25maWdzLmxpbmVEYXNoO1xuICAgICAgICB0aGlzLmxpbmVXaWR0aCAgICAgPSBjb25maWdzLmxpbmVXaWR0aCB8fCAxO1xuICAgICAgICAvKiogQG1lbWJlciB7Qm9vbGVhbn0gICAgICAtIOWPjOWQkeeureWktCAqL1xuICAgICAgICB0aGlzLmRvdWJsZUxpbmsgICAgPSBjb25maWdzLmRvdWJsZUxpbms7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtTdHJpbmd9ICAgICAgLSDov57nur/kuIrnmoTmloflrZflrZfkvZMgKi9cbiAgICAgICAgdGhpcy5mb250RmFtaWx5ICAgID0gY29uZmlncy5mb250RmFtaWx5ID0gJy1hcHBsZS1zeXN0ZW0sQmxpbmtNYWNTeXN0ZW1Gb250LFNlZ29lIFVJLFJvYm90byxIZWx2ZXRpY2EgTmV1ZSxIZWx2ZXRpY2EsVGFob21hLEFyaWFsLE5vdG8gU2FucyxQaW5nRmFuZyBTQyxNaWNyb3NvZnQgWWFIZWksSGlyYWdpbm8gU2FucyBHQixzYW5zLXNlcmlmLEFwcGxlIENvbG9yIEVtb2ppLFNlZ29lIFVJIEVtb2ppLFNlZ29lIFVJIFN5bWJvbCxOb3RvIENvbG9yIEVtb2ppJ1xuICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAgIC0g6L+e57q/5LiK55qE5paH5a2X5aSn5bCPICovXG4gICAgICAgIHRoaXMuZm9udFNpemUgICAgICA9IGNvbmZpZ3MuZm9udFNpemUgfHwgJzEycHgnO1xuICAgICAgICAvKiogQG1lbWJlciB7U3RyaW5nfSAgICAgIC0g6L+e57q/5LiK55qE5paH5a2XICovXG4gICAgICAgIHRoaXMuY29udGVudCAgICAgICA9IGNvbmZpZ3MuY29udGVudCB8fCAnJztcbiAgICAgICAgLyoqIEBtZW1iZXIge0Jvb2xlYW59ICAgICAgLSDmmK/lkKbkuLroh6rov57mjqUgKi9cbiAgICAgICAgdGhpcy5pc1NlbGYgICAgICAgID0gISFjb25maWdzLmlzU2VsZlxuICAgIH1cbiAgICBcbiAgICAvLyBnZXRDb2xvcigpIHtcbiAgICAvLyAgICAgaWYodGhpcy5faXNUYXJnZXRpbmcpIHtcbiAgICAvLyAgICAgICAgIHJldHVybiB0aGlzLmhvdmVyU3R5bGU7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdFN0eWxlO1xuICAgIC8vIH1cbiAgICBcbiAgICAvLyBfY2FsY3VsYXRlQW5jaG9yUG9pbnRzKCkge1xuICAgIC8vICAgICBsZXQgc3RhcnQ7XG4gICAgLy8gICAgIGxldCBlbmQ7XG4gICAgLy8gICAgIGlmKHRoaXMuZnJvbURpciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gICAgICAgICBzdGFydCA9IHtcbiAgICAvLyAgICAgICAgICAgICBkaXI6IHRoaXMuZnJvbURpcixcbiAgICAvLyAgICAgICAgICAgICBwOiB0aGlzLmZyb20uZ2V0SW50ZXJzZWN0aW9uc0luRm91ckRpbWVuc2lvbigpW3RoaXMuZnJvbURpcl0sXG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgICBzdGFydCA9IHRoaXMuZnJvbS5jYWxjdWxhdGVJbnRlcnNlY3Rpb25JbkZvdXJEaW1lbnNpb24odGhpcy50by5nZXRDZW50ZXIoKSwgJ2Zyb20nKTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICBpZih0aGlzLnRvRGlyICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyAgICAgICAgIGVuZCA9IHtcbiAgICAvLyAgICAgICAgICAgICBkaXI6IHRoaXMudG9EaXIsXG4gICAgLy8gICAgICAgICAgICAgcDogdGhpcy50by5nZXRJbnRlcnNlY3Rpb25zSW5Gb3VyRGltZW5zaW9uKClbdGhpcy50b0Rpcl0sXG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgICBlbmQgPSB0aGlzLnRvLmNhbGN1bGF0ZUludGVyc2VjdGlvbkluRm91ckRpbWVuc2lvbih0aGlzLmZyb20uZ2V0Q2VudGVyKCksICd0bycpO1xuICAgIC8vICAgICB9XG4gICAgICAgIFxuICAgICAgICBcbiAgICAvLyAgICAgLy8gY29uc3Qgc3RhcnQgPSB0aGlzLmZyb20uY2FsY3VsYXRlSW50ZXJzZWN0aW9uSW5Gb3VyRGltZW5zaW9uKHRoaXMudG8uZ2V0Q2VudGVyKCksICdmcm9tJyk7XG4gICAgLy8gICAgIC8vIGNvbnN0IGVuZCA9IHRoaXMudG8uY2FsY3VsYXRlSW50ZXJzZWN0aW9uSW5Gb3VyRGltZW5zaW9uKHRoaXMuZnJvbS5nZXRDZW50ZXIoKSwgJ3RvJyk7XG4gICAgLy8gICAgIGNvbnN0IHAxID0gc3RhcnQucDtcbiAgICAvLyAgICAgY29uc3QgcDIgPSBlbmQucDtcbiAgICAvLyAgICAgY29uc3QgcG9pbnRzID0gYmV6aWVyUG9pbnRzKHAxLCBwMiwgc3RhcnQuZGlyLCBlbmQuZGlyLCB0aGlzLmFudGljbG9jayk7XG5cbiAgICAvLyAgICAgdGhpcy5fY2FjaGVQb2ludHMgPSBbLi4ucDEsIC4uLnBvaW50c11cbiAgICAvLyB9XG5cbiAgICBfY2FsY3VsYXRlQW5jaG9yUG9pbnRzKCkge1xuICAgICAgICBjb25zdCBkbXNmcm9tID0gdGhpcy5mcm9tLmdldEludGVyc2VjdGlvbnNJbkZvdXJEaW1lbnNpb24oKTtcbiAgICAgICAgY29uc3QgZG1zdG8gPSB0aGlzLnRvLmdldEludGVyc2VjdGlvbnNJbkZvdXJEaW1lbnNpb24oKTtcbiAgICAgICAgaWYodGhpcy5pc1NlbGYpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IGJlemllclBvaW50cyhcbiAgICAgICAgICAgICAgICBkbXNmcm9tW3RoaXMuZnJvbURpcl0sXG4gICAgICAgICAgICAgICAgZG1zdG9bRElSRUNUSU9OLlNFTEZdLFxuICAgICAgICAgICAgICAgIHRoaXMuZnJvbURpcixcbiAgICAgICAgICAgICAgICBESVJFQ1RJT04uQk9UVE9NLCBcbiAgICAgICAgICAgICAgICB0aGlzLm1pblNwYW5YLCBcbiAgICAgICAgICAgICAgICB0aGlzLm1pblNwYW5ZKTtcblxuICAgICAgICAgICAgdGhpcy5fY2FjaGVQb2ludHMgPSBbLi4uZG1zZnJvbVt0aGlzLmZyb21EaXJdLCAuLi5wb2ludHNdIFxuICAgICAgICAgICAgdGhpcy5fY2FjaGVBbmdsZSA9IFt0aGlzLmZyb21EaXIsIERJUkVDVElPTi5CT1RUT01dXG4gICAgICAgIH0gZWxzZSBpZih0aGlzLmZyb21EaXIgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnRvRGlyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IGJlemllclBvaW50cyhcbiAgICAgICAgICAgICAgICBkbXNmcm9tW3RoaXMuZnJvbURpcl0sXG4gICAgICAgICAgICAgICAgZG1zdG9bdGhpcy50b0Rpcl0sXG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tRGlyLFxuICAgICAgICAgICAgICAgIHRoaXMudG9EaXIsIHRoaXMubWluU3BhblggLCB0aGlzLm1pblNwYW5ZKTtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlUG9pbnRzID0gWy4uLmRtc2Zyb21bdGhpcy5mcm9tRGlyXSwgLi4ucG9pbnRzXSBcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlQW5nbGUgPSBbdGhpcy5mcm9tRGlyLCB0aGlzLnRvRGlyXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWV0YSA9IG1pbkludGVyc2VjdGlvbkJldHdlZW5Ob2RlcyhkbXNmcm9tLCBkbXN0byk7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBiZXppZXJQb2ludHMoXG4gICAgICAgICAgICAgICAgbWV0YS5mcm9tUCxcbiAgICAgICAgICAgICAgICBtZXRhLnRvUCxcbiAgICAgICAgICAgICAgICBtZXRhLmZyb21EaXIsXG4gICAgICAgICAgICAgICAgbWV0YS50b0Rpcik7XG5cbiAgICAgICAgICAgIHRoaXMuX2NhY2hlUG9pbnRzID0gWy4uLm1ldGEuZnJvbVAsIC4uLnBvaW50c107XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUFuZ2xlID0gW21ldGEuZnJvbURpciwgbWV0YS50b0Rpcl07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZUFuY2hvclBvaW50cygpO1xuICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9jYWNoZVBvaW50cztcbiAgICAgICAgY29uc3QgYW5nbGUgPSBnZXRCZXppZXJBbmdsZS5hcHBseShudWxsLCBbMSwgLi4ucG9pbnRzXSlcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5saW5lV2lkdGg7XG4gICAgICAgIGlmKHRoaXMuZG91YmxlTGluaykge1xuICAgICAgICAgICAgY29uc3QgYmVnaW5BbmdsZSA9ICgodGhpcy5fY2FjaGVBbmdsZVswXSArIDIpICUgNCkgKiA5MCAqIFBJSU5SQVRJTztcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShiZWdpbkFuZ2xlKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oNSwgMCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKDAsIC00KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oMCwgNCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKDUsIDApO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoLWJlZ2luQW5nbGUpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtcG9pbnRzWzBdLCAtcG9pbnRzWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0pXG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKC4uLnBvaW50cy5zbGljZSgyKSk7XG4gICAgICAgIGlmKHRoaXMubGluZURhc2gpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguc2V0TGluZURhc2godGhpcy5saW5lRGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBpZih0aGlzLmxpbmVEYXNoKSB7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShwb2ludHNbNl0sIHBvaW50c1s3XSk7XG4gICAgICAgIGN0eC5yb3RhdGUoYW5nbGUpO1xuICAgICAgICBjdHgubW92ZVRvKDUsIDApO1xuICAgICAgICBjdHgubGluZVRvKDAsIC00KTtcbiAgICAgICAgY3R4LmxpbmVUbygwLCA0KTtcbiAgICAgICAgY3R4LmxpbmVUbyg1LCAwKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnJvdGF0ZSgtYW5nbGUpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKC1wb2ludHNbNl0sIC1wb2ludHNbN10pO1xuICAgICAgICBpZih0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc0ZsaXAgPSBwb2ludHNbMF0gPiBwb2ludHNbNl07XG4gICAgICAgICAgICBsZXQgW3gsIHksIGFuZ2xlXSA9IGJlemllclBvaW50KDAuNSwgcG9pbnRzKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICAgICAgICBjdHgucm90YXRlKGFuZ2xlKTtcbiAgICAgICAgICAgIGlmKGhhc0ZsaXApe1xuICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoTWF0aC5QSSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZm9udCA9IGAke3RoaXMuZm9udFNpemV9ICR7dGhpcy5mb250RmFtaWx5fWA7XG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQodGhpcy5jb250ZW50LCAwLCAtKHBhcnNlSW50KHRoaXMuZm9udFNpemUpIHx8IDEyKS80KTtcbiAgICAgICAgICAgIGlmKGhhc0ZsaXApe1xuICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoTWF0aC5QSSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgucm90YXRlKC1hbmdsZSk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC14LCAteSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0hpdChwb2ludCkge1xuICAgICAgICBpZighdGhpcy5fY2FjaGVQb2ludHMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gdGhpcy5fY2FjaGVQb2ludHM7XG4gICAgICAgIGNvbnN0IGRpc3QgPSBkaXN0VG9CZXppZXJTZWdtZW50U3F1YXJlZChwb2ludCwgcG9pbnRzKVxuICAgICAgICByZXR1cm4gZGlzdCA8IHRoaXMuYXBwcm94aW1hdGU7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCZXppZXJMaW5rOyIsIi8qKlxuICog57q/5oCn5biD5bGA6YWN572uXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBMaW5lYXJMYXlvdXR+Q29uZmlnc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGRpcmVjdGlvbiAgICAgLSDmjpLliJfmlrnlkJEg6buY6K6kIHZlcnRpY2FsXG4gKiBAcHJvcGVydHkge251bWJlcn0gZ2FwICAgICAgICAgICAtIOi+uei3nSwg6buY6K6k5pivIDVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhbGlnbm1lbnQgICAgIC0g5Z6C55u05o6S5YiX5pa55ZCR5a+56b2Q5pa55byPIOm7mOiupCBjZW50ZXJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBqdXN0aWZ5ICAgICAgIC0g5o6S5YiX5pa55ZCR5a+56b2Q5pa55byPIOm7mOiupCBjZW50ZXJcbiAqL1xuLyoqXG4gICAg57q/5oCn5biD5bGAXG5cbiAgICDmjpLliJfmlrnlkJFcbiAgICBkaXJlY3Rpb246XG4gICAgICAgICsgdmVydGljYWwg5LuO5LiK6Iez5LiL5o6S5biDXG4gICAgICAgICsgaG9yaXpvbnRhbCDku47lt6boh7Plj7PmjpLluINcbiAgICBcbiAgICDkuI3ph43lj6DvvIzkuK3nur/lr7npvZBcbiAgICDlj6rpkojlr7nlvZPliY3nmoQgZ3JvdXBcblxuICAgIOWvuem9kOaWueW8j1xuICAgIGFsaWdubWVudDogXG4gICAgICAgICsgc3RhcnQg5Li76L205bem5L6n5a+56b2QXG4gICAgICAgICsgY2VudGVyIOS4u+i9tOWvuem9kFxuICAgICAgICArIGVuZCAgIOS4u+i9tOWPs+S+p+Wvuem9kFxuICAgIGp1c3RpZnk6IFxuICAgICAgICArIHN0YXJ0IOW8gOWni+aXtuWvuem9kFxuICAgICAgICArIGNlbnRlciDlsYXkuK3lr7npvZBcbiAgICAgICAgKyBlbmQgICDmnKvlsL7lr7npvZBcbiAgICAgICAgKyBzcGFjZS1iZXR3ZWVuIOW5s+Wdh+WIhumFjeepuumXtOWvuem9kFxuXG4gKiBAY29uc3RydWN0b3IgTGluZWFyTGF5b3V0XG4gKiBAaW1wbGVtZW50cyB7TGF5b3V0fVxuICogQHBhcmFtIHtMaW5lYXJMYXlvdXR+Q29uZmlnc30gY29uZmlncyAtIOmFjee9rlxuICovXG5cbmNsYXNzIExpbmVhckxheW91dCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlncyA9IHt9KSB7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtzdHJpbmd9ICAtIOaOkuWIl+aWueWQkSDpu5jorqQgdmVydGljYWwgKi9cbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSAgICAgY29uZmlncy5kaXJlY3Rpb24gfHwgJ3ZlcnRpY2FsJztcbiAgICAgICAgLyoqIEBtZW1iZXIge251bWJlcn0gIC0g6L656LedLCDpu5jorqTmmK8gNSAqL1xuICAgICAgICB0aGlzLmdhcCA9ICAgICAgICAgICBjb25maWdzLmdhcCA/PyA1O1xuICAgICAgICAvKiogQG1lbWJlciB7c3RyaW5nfSAgLSDlnoLnm7TmjpLliJfmlrnlkJHlr7npvZDmlrnlvI8g6buY6K6kIGNlbnRlciAqL1xuICAgICAgICB0aGlzLmFsaWdubWVudCA9ICAgICBjb25maWdzLmFsaWdubWVudCB8fCAnY2VudGVyJztcbiAgICAgICAgLyoqIEBtZW1iZXIge3N0cmluZ30gIC0g5o6S5YiX5pa55ZCR5a+56b2Q5pa55byPIOm7mOiupCBjZW50ZXIgKi9cbiAgICAgICAgdGhpcy5qdXN0aWZ5ID0gICAgICAgY29uZmlncy5qdXN0aWZ5IHx8ICdjZW50ZXInO1xuICAgICAgICAvLyB0aGlzLndpZHRoU2V0QnlQYXJlbnQgPSAgY29uZmlncy53aWR0aCA9PT0gJzEwMCUnXG4gICAgICAgIHRoaXMuX3Jhd0NvbmZpZ3MgPSBjb25maWdzO1xuICAgIH1cblxuXG4gICAgcmVmbG93KGdyb3VwKSB7XG4gICAgICAgIGNvbnN0IHN0YWNrID0gZ3JvdXAuX3N0YWNrLmZpbHRlcihpbnN0YW5jZSA9PiBpbnN0YW5jZS52aXNpYmxlICYmICFpbnN0YW5jZS5hYnNvbHV0ZVBvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgYWJzb2x1dGVTdGFjayA9IGdyb3VwLl9zdGFjay5maWx0ZXIoaW5zdGFuY2UgPT4gaW5zdGFuY2UudmlzaWJsZSAmJiBpbnN0YW5jZS5hYnNvbHV0ZVBvc2l0aW9uKVxuICAgICAgICBjb25zdCBncm91cFdpZHRoID0gZ3JvdXAud2lkdGggLSBncm91cC5wYWRkaW5nLmxlZnQgLSBncm91cC5wYWRkaW5nLnJpZ2h0O1xuICAgICAgICBpZih0aGlzLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgbGV0IHJlZHVjZUhlaWdodCA9IDA7XG4gICAgICAgICAgICBsZXQgbGFzdEluc3RhbmNlSGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIGxldCBtYXhXaWR0aCA9IDA7XG4gICAgICAgICAgICBsZXQgYWxsSGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkQWxsID0gc3RhY2suY29uY2F0KGFic29sdXRlU3RhY2spO1xuICAgICAgICAgICAgY2hpbGRBbGwuZm9yRWFjaCgoaW5zdGFuY2UsIGlkeCkgPT4gIHtcbiAgICAgICAgICAgICAgICBpZihpbnN0YW5jZS5kaXNwbGF5ID09PSAnYmxvY2snKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLndpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5zdGFuY2UuZGVmaW5lZFdpZHRoID0gbWF4V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnJlc2V0Q2hpbGRyZW5Qb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5yZWZsb3coKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuX2dldEJvdW5kaW5nR3JvdXBSZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHN0YWNrLmZvckVhY2goKGluc3RhbmNlLCBpZHgpID0+ICB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBpbnN0YW5jZS5nZXRCb3VuZGluZ0RpbWVuc2lvbigpO1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGhlaWdodCwgaW5zdGFuY2UudHlwZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2FwID0gKGlkeCA+IDAgPyB0aGlzLmdhcCA6IDApO1xuICAgICAgICAgICAgICAgIGlmKGluc3RhbmNlLmRpc3BsYXkgIT09ICdvdXRzdHJldGNoJykge1xuICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KHdpZHRoLCBtYXhXaWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFsbEhlaWdodCArPSAoaGVpZ2h0ICsgZ2FwKTtcbiAgICAgICAgICAgICAgICByZWR1Y2VIZWlnaHQgKz0gKGhlaWdodC8yICsgZ2FwICsgbGFzdEluc3RhbmNlSGVpZ2h0KVxuICAgICAgICAgICAgICAgIGxhc3RJbnN0YW5jZUhlaWdodCA9IGhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuYW5jaG9yID0gWzAsIHJlZHVjZUhlaWdodF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNoaWxkQWxsLmZvckVhY2goKGluc3RhbmNlLCBpZHgpID0+ICB7XG4gICAgICAgICAgICAgICAgaWYoaW5zdGFuY2UuZGlzcGxheSA9PT0gJ2Jsb2NrJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbnN0YW5jZS5kZWZpbmVkV2lkdGggPSBtYXhXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UucmVzZXRDaGlsZHJlblBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLndpZHRoID0gbWF4V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnJlZmxvdygpO1xuICAgICAgICAgICAgICAgICAgICAvLyBpbnN0YW5jZS5fZ2V0Qm91bmRpbmdHcm91cFJlY3QoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoaW5zdGFuY2UuZGlzcGxheSA9PT0gJ291dHN0cmV0Y2gnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHcgPSBncm91cC5fYmVsb25ncy53aWR0aCAtIGdyb3VwLl9iZWxvbmdzLnBhZGRpbmcubGVmdCAtIGdyb3VwLl9iZWxvbmdzLnBhZGRpbmcucmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnJlc2V0Q2hpbGRyZW5Qb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS53aWR0aCA9IE1hdGgubWF4KHcsIG1heFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UucmVmbG93KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1heFdpZHRoID0gTWF0aC5tYXgoZ3JvdXBXaWR0aCwgbWF4V2lkdGgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBhbGxIZWlnaHQgPSBhbGxIZWlnaHQvMjtcbiAgICAgICAgICAgIGlmKHRoaXMuYWxpZ25tZW50ID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgc3RhY2suZm9yRWFjaCgoaW5zdGFuY2UsIGlkeCkgPT4gIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB3aWR0aCB9ID0gaW5zdGFuY2UuZ2V0Qm91bmRpbmdEaW1lbnNpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuYW5jaG9yWzBdID0gLShtYXhXaWR0aCAtIHdpZHRoKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmFuY2hvclsxXSAtPSBhbGxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG1heFdpZHRoLCB3aWR0aCwgaW5zdGFuY2UuYW5jaG9yWzBdKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLmFsaWdubWVudCA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5mb3JFYWNoKChpbnN0YW5jZSwgaWR4KSA9PiAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHdpZHRoIH0gPSBpbnN0YW5jZS5nZXRCb3VuZGluZ0RpbWVuc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5hbmNob3JbMF0gPSAobWF4V2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5hbmNob3JbMV0gLT0gYWxsSGVpZ2h0O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLmFsaWdubWVudCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5mb3JFYWNoKChpbnN0YW5jZSwgaWR4KSA9PiAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHdpZHRoIH0gPSBpbnN0YW5jZS5nZXRCb3VuZGluZ0RpbWVuc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5hbmNob3JbMV0gLT0gYWxsSGVpZ2h0O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gXG4gICAgICAgIGlmKHRoaXMuZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIGxldCByZWR1Y2VXaWR0aCA9IDA7XG4gICAgICAgICAgICBsZXQgbGFzdEluc3RhbmNlV2lkdGggPSAwO1xuICAgICAgICAgICAgbGV0IG1heEhlaWdodCA9IDA7XG4gICAgICAgICAgICBsZXQgYWxsV2lkdGggPSAwO1xuICAgICAgICAgICAgbGV0IGFsbFB1cmVXaWR0aCA9IDA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHN0YWNrLmZvckVhY2goKGluc3RhbmNlLCBpZHgpID0+ICB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBpbnN0YW5jZS5nZXRCb3VuZGluZ0RpbWVuc2lvbigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdhcCA9IChpZHggPiAwID8gdGhpcy5nYXAgOiAwKTtcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIG1heEhlaWdodCk7XG4gICAgICAgICAgICAgICAgYWxsV2lkdGggKz0gKHdpZHRoK2dhcCk7XG4gICAgICAgICAgICAgICAgYWxsUHVyZVdpZHRoICs9IHdpZHRoO1xuICAgICAgICAgICAgICAgIHJlZHVjZVdpZHRoICs9ICh3aWR0aC8yICsgZ2FwICsgbGFzdEluc3RhbmNlV2lkdGgpXG4gICAgICAgICAgICAgICAgbGFzdEluc3RhbmNlV2lkdGggPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuYW5jaG9yID0gW3JlZHVjZVdpZHRoLCAwXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZih0aGlzLmp1c3RpZnkgPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3aXRoZHJhdyA9IGdyb3VwV2lkdGgvMjtcbiAgICAgICAgICAgICAgICBzdGFjay5mb3JFYWNoKChpbnN0YW5jZSwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmFuY2hvclswXSAtPSB3aXRoZHJhdztcbiAgICAgICAgICAgICAgICB9KTsgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5qdXN0aWZ5ID09PSAnZW5kJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpdGhkcmF3ID0gZ3JvdXBXaWR0aC8yIC0gYWxsV2lkdGg7XG4gICAgICAgICAgICAgICAgc3RhY2suZm9yRWFjaCgoaW5zdGFuY2UsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5hbmNob3JbMF0gKz0gd2l0aGRyYXc7XG4gICAgICAgICAgICAgICAgfSk7ICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMuanVzdGlmeSA9PT0gJ2NlbnRlcicpIHsgXG4gICAgICAgICAgICAgICAgY29uc3Qgd2l0aGRyYXcgPSBhbGxXaWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgc3RhY2suZm9yRWFjaCgoaW5zdGFuY2UsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5hbmNob3JbMF0gLT0gd2l0aGRyYXc7XG4gICAgICAgICAgICAgICAgfSkgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLmp1c3RpZnkgPT09ICdzcGFjZS1iZXR3ZWVuJyAmJiBzdGFjay5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heChncm91cFdpZHRoLCBhbGxXaWR0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2FwQXZlcmFnZSA9ICh3aWR0aCAtIGFsbFdpZHRoKSAvIChzdGFjay5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBjb25zdCB3aXRoZHJhdyA9IHdpZHRoLzI7XG4gICAgICAgICAgICAgICAgc3RhY2suZm9yRWFjaCgoaW5zdGFuY2UsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5hbmNob3JbMF0gKz0gKChnYXBBdmVyYWdlICogaWR4KSAtIHdpdGhkcmF3KTtcbiAgICAgICAgICAgICAgICB9KTsgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5hbGlnbm1lbnQgPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5mb3JFYWNoKChpbnN0YW5jZSwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaGVpZ2h0IH0gPSBpbnN0YW5jZS5nZXRCb3VuZGluZ0RpbWVuc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5hbmNob3JbMV0gPSAtKG1heEhlaWdodCAtIGhlaWdodCkgLyAyO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLmFsaWdubWVudCA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5mb3JFYWNoKChpbnN0YW5jZSwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaGVpZ2h0IH0gPSBpbnN0YW5jZS5nZXRCb3VuZGluZ0RpbWVuc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5hbmNob3JbMV0gPSAobWF4SGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGFic29sdXRlU3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICBpZihncm91cC5kaXNwbGF5ID09PSAnYmxvY2snKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAuZ2V0Qm91bmRpbmdEaW1lbnNpb24oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAuX2dldEJvdW5kaW5nR3JvdXBSZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBXSURUSCA9IGdyb3VwLndpZHRoIC8yO1xuICAgICAgICAgICAgY29uc3QgSEVJR0hUID0gZ3JvdXAuaGVpZ2h0IC8yO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnR5ID0gKGdyb3VwLnBhZGRpbmcudG9wIC0gZ3JvdXAucGFkZGluZy5ib3R0b20pLzI7XG4gICAgICAgICAgICBjb25zdCBzaGlmdHggPSAoZ3JvdXAucGFkZGluZy5sZWZ0IC0gZ3JvdXAucGFkZGluZy5yaWdodCkvMjtcbiAgICAgICAgICAgIGFic29sdXRlU3RhY2suZm9yRWFjaChpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuYW5jaG9yID0gdGhpcy5fcmVzb2x2ZUFic29sdXRlQW5jaG9yKGluc3RhbmNlLmFic29sdXRlUG9zaXRpb24sIGluc3RhbmNlLCBXSURUSCwgSEVJR0hULCBzaGlmdHgsIHNoaWZ0eSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3Jlc29sdmVBYnNvbHV0ZUFuY2hvcihjb25maWcsIGluc3RhbmNlLCB3LCBoLCBzaGlmdHgsIHNoaWZ0eSl7XG4gICAgICAgIGNvbnN0IHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCBjZW50ZXJYLCBjZW50ZXJZIH0gPSBjb25maWc7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gaW5zdGFuY2UuZ2V0Qm91bmRpbmdEaW1lbnNpb24oKTtcbiAgICAgICAgY29uc3QgaHcgPSB3aWR0aCAvIDI7XG4gICAgICAgIGNvbnN0IGhoID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgbGV0IHkgPSAwO1xuICAgICAgICBsZXQgeCA9IDA7XG4gICAgICAgIGlmKHR5cGVvZiB0b3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB5ID0gdG9wICsgaGggLSBoIC0gc2hpZnR5O1xuICAgICAgICB9XG4gICAgICAgIGlmKHR5cGVvZiByaWdodCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHggPSB3IC0gcmlnaHQgLSBodyAtIHNoaWZ0eDtcbiAgICAgICAgfVxuICAgICAgICBpZih0eXBlb2YgYm90dG9tID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgeSA9IGggLSBib3R0b20gLSBoaCAtIHNoaWZ0eTtcbiAgICAgICAgfVxuICAgICAgICBpZih0eXBlb2YgbGVmdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHggPSBsZWZ0ICsgaHcgLSB3IC0gc2hpZnR4O1xuICAgICAgICB9XG4gICAgICAgIGlmKHR5cGVvZiBjZW50ZXJYID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgeCA9IGNlbnRlclg7XG4gICAgICAgIH1cbiAgICAgICAgaWYodHlwZW9mIGNlbnRlclkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB5ID0gY2VudGVyWTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3gsIHldXG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluZWFyTGF5b3V0KHRoaXMuX3Jhd0NvbmZpZ3MpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGluZWFyTGF5b3V0OyIsIlxuZXhwb3J0IGNvbnN0IEVESVRPUl9FVkVOVFMgPSB7XG4gICAgSU5QVVQ6ICdpbnB1dCcsXG4gICAgQ09OVFJPTF9DTUQ6ICdjb250cm9sJ1xufVxuXG5leHBvcnQgY29uc3QgS0VZQk9BUkRfSU5QVVQgPSB7XG4gICAgSU5QVVQ6ICdpbnB1dCcsXG4gICAgQ09NUE9TSVRJT05fU1RBUlQ6ICdjb21wb3NpdGlvbnN0YXJ0JyxcbiAgICBDT01QT1NJVElPTl9VUERBVEU6ICdjb21wb3NpdGlvbnVwZGF0ZScsXG4gICAgQ09NUE9TSVRJT05fRU5EOiAnY29tcG9zaXRpb25lbmQnLFxuICAgIEVOVEVSOiAnZW50ZXInLFxuICAgIERFTEVURTogJ2RlbGV0ZScsXG4gICAgQkFDS1NQQUNFOiAnYmFja3NwYWNlJyxcbn1cblxuZXhwb3J0IGNvbnN0IEtFWUJPQVJEX0NPTU1BTkRTID0ge1xuICAgIEFSUk9XX0xFRlQ6ICdhcnJvd0xlZnQnLFxuICAgIEFSUk9XX1JJR0hUOiAnYXJyb3dSaWdodCcsXG4gICAgQVJST1dfVVA6ICdhcnJvd1VwJyxcbiAgICBBUlJPV19ET1dOOiAnYXJyb3dEb3duJyxcbiAgICBVTkRPOiAndW5kbycsXG4gICAgUkVETzogJ3JlZG8nLFxuICAgIFNISUZUX0RPV046ICdzaGlmdF9kb3duJyxcbiAgICBTSElGVF9VUDogJ3NoaWZ0X3VwJyxcbiAgICBDVFJMQTogJ2N0cmxhJyxcbiAgICBDT1BZOiAnY29weScsXG4gICAgQ1VUOiAnY3V0JyxcbiAgICBQQVNURTogJ3Bhc3RlJyxcbn1cblxuZXhwb3J0IGNvbnN0IE1PVVNFX0NPTU1BTkRTID0ge1xuICAgIFNUQVJUX0VESVQ6ICdzdGFydGVkaXQnLFxuICAgIEVESVRfQ0xJQ0s6ICdlZGl0Y2xpY2snLFxuICAgIFNISUZUX09OX0NMSUNLOiAnc2hpZnRvbmNsaWNrJyxcbiAgICBET1VCTEVfQ0xJQ0s6ICdkb3VibGVjbGljaydcbn1cblxuXG5leHBvcnQgY29uc3QgT1BFUlJBVElPTiA9IHtcbiAgICBQTEFJTklOUFVUOiAncGxhaW5pbnB1dCcsXG4gICAgU1BBQ0VJTlBVVDogJ3NwYWNlaW5wdXQnLFxuICAgIFJFVFVSTklOUFVUOiAncmV0dXJuaW5wdXQnLFxuICAgIENBUkVUTU9WRU1FTlQ6ICdjYXJldG1vdmVtZW50JyxcbiAgICBERUxFVEVfSU5fTElORTogJ2RlbGV0ZWlubGluZScsXG4gICAgREVMRVRFX0lOX0VESVRBUkVBOiAnZGVsZXRlaW5lZGl0YXJlYScsXG4gICAgRU5TVVJFX0RFTEVURTogJ2Vuc3VyZWRlbGV0ZScsXG4gICAgU0VMRUNUSU9OX0RFTEVURTogJ3NlbGVjdGlvbmRlbGV0ZScsXG4gICAgU0VMRUNUSU9OX0lOUFVUOiAnc2VsZWN0aW9uaW5wdXQnLFxuICAgIENPTVBPU0lURV9JTlNFUlQ6ICdjb21wb3NpdGVpbnNlcnQnXG59XG4iLCJpbXBvcnQgeyBLRVlCT0FSRF9DT01NQU5EUywgS0VZQk9BUkRfSU5QVVQsIEVESVRPUl9FVkVOVFMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmNsYXNzIFNoYWRvd0lucHV0IGV4dGVuZHMgRXZlbnRUYXJnZXR7XG4gICAgX2lucHV0RWxlbWVudCA9IG51bGw7XG5cbiAgICBjb25zdHJ1Y3Rvcih3cmFwcGVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2lucHV0RWxlbWVudCA9IGNyZWF0ZUlucHV0RWxlbWVudCh0aGlzLmNvbnRyb2xDYWxsYmFjay5iaW5kKHRoaXMpKTtcbiAgICAgICAgd3JhcHBlci5hcHBlbmQodGhpcy5faW5wdXRFbGVtZW50KTtcbiAgICAgICAgdGhpcy5faW5wdXRFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuICAgIGNvbnRyb2xDYWxsYmFjayhraW5kLCBkYXRhKSB7XG4gICAgICAgIHN3aXRjaChraW5kKSB7XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0lOUFVULklOUFVUOlxuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9JTlBVVC5DT01QT1NJVElPTl9TVEFSVDpcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfSU5QVVQuQ09NUE9TSVRJT05fVVBEQVRFOlxuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9JTlBVVC5DT01QT1NJVElPTl9FTkQ6XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0lOUFVULkVOVEVSOlxuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9JTlBVVC5CQUNLU1BBQ0U6XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0lOUFVULkRFTEVURTpcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KEVESVRPUl9FVkVOVFMuSU5QVVQsIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfQ09NTUFORFMuQVJST1dfTEVGVDpcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfQ09NTUFORFMuQVJST1dfUklHSFQ6XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0NPTU1BTkRTLkFSUk9XX1VQOlxuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9DT01NQU5EUy5BUlJPV19ET1dOOlxuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9DT01NQU5EUy5DVFJMQTpcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfQ09NTUFORFMuU0hJRlRfRE9XTjpcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfQ09NTUFORFMuU0hJRlRfVVA6XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0NPTU1BTkRTLlVORE86XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0NPTU1BTkRTLlJFRE86XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0NPTU1BTkRTLkNPUFk6XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0NPTU1BTkRTLkNVVDpcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfQ09NTUFORFMuUEFTVEU6XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChFRElUT1JfRVZFTlRTLkNPTlRST0xfQ01ELCB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvY3VzKCkge1xuICAgICAgICB0aGlzLl9pbnB1dEVsZW1lbnQuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pOyAgXG4gICAgfVxuXG4gICAgc3luY1Bvc2l0aW9uKHgsIHkpIHtcbiAgICAgICAgdGhpcy5faW5wdXRFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHt4fXB4LCAke3l9cHgpYFxuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmKHRoaXMucmVtb3ZlTGlzZW50ZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzZW50ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnB1dEVsZW1lbnQucmVtb3ZlKCk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTaGFkb3dJbnB1dDtcblxuZnVuY3Rpb24gY3JlYXRlSW5wdXRFbGVtZW50KGNvbnRyb2xDYWxsYmFjaykge1xuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJyxgXG4gICAgICAgIHdpZHRoOiAxMDBweDtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGJvcmRlcjpub25lO1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICB6LWluZGV4OiAtMTtcbiAgICAgICAgY29udGFpbjogc3RyaWN0O2ApO1xuICAgIGlucHV0LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAtMSk7XG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKCdzcGVsbGNoZWNrJywgZmFsc2UpO1xuICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnYXV0b2NvcnJlY3QnLCAnb2ZmJyk7XG5cbiAgICBsZXQgc3RvcElucHV0ID0gZmFsc2U7XG4gICAgbGV0IHN0YXR1cyA9IHtcbiAgICAgICAgY3RybE9uOiBmYWxzZSxcbiAgICAgICAgc2hpZnRPbjogZmFsc2UsXG4gICAgfVxuXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JlaW5wdXQnLCBlID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZihlLmRhdGEpIHtcbiAgICAgICAgICAgIC8vIGNvbnRlbnQgKz0gZS5kYXRhO1xuICAgICAgICAgICAgLy8gcmVuZGVyQ29udGVudCgpO1xuICAgICAgICAgICAgaWYoIXN0b3BJbnB1dCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjayhLRVlCT0FSRF9JTlBVVC5JTlBVVCwgZS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsIGUgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnN0IHBhc3RlQ29udGVudCA9IChlLmNsaXBib2FyZERhdGEgfHwgd2luZG93LmNsaXBib2FyZERhdGEpLmdldERhdGEoXCJ0ZXh0XCIpO1xuICAgICAgICBjb250cm9sQ2FsbGJhY2soS0VZQk9BUkRfQ09NTUFORFMuUEFTVEUsIHBhc3RlQ29udGVudCk7XG4gICAgfSk7XG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY29weScsIGUgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnRyb2xDYWxsYmFjayhLRVlCT0FSRF9DT01NQU5EUy5DT1BZLCBlKTtcbiAgICB9KTtcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjdXQnLCBlID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBjb250cm9sQ2FsbGJhY2soS0VZQk9BUkRfQ09NTUFORFMuQ1VULCBlKTtcbiAgICB9KTtcblxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCAoZSkgPT4ge1xuICAgICAgICBjb250cm9sQ2FsbGJhY2soS0VZQk9BUkRfSU5QVVQuQ09NUE9TSVRJT05fU1RBUlQpO1xuICAgICAgICBzdG9wSW5wdXQgPSB0cnVlO1xuICAgIH0pO1xuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9udXBkYXRlJywgKGUpID0+IHtcbiAgICAgICAgY29udHJvbENhbGxiYWNrKEtFWUJPQVJEX0lOUFVULkNPTVBPU0lUSU9OX1VQREFURSwgZS5kYXRhKTtcbiAgICB9KTtcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIChlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xDYWxsYmFjayhLRVlCT0FSRF9JTlBVVC5DT01QT1NJVElPTl9FTkQsIGUuZGF0YSk7XG4gICAgICAgIGlucHV0LnZhbHVlID0gJyc7XG4gICAgICAgIHN0b3BJbnB1dCA9IGZhbHNlXG4gICAgfSk7XG5cbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIChldmVudCkgPT4ge1xuICAgICAgICBpZihzdG9wSW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2goZXZlbnQua2V5KSB7XG4gICAgICAgICAgICBjYXNlIFwiU2hpZnRcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soS0VZQk9BUkRfQ09NTUFORFMuU0hJRlRfVVApO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5zaGlmdE9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiTWV0YVwiOlxuICAgICAgICAgICAgY2FzZSBcIkNvbnRyb2xcIjpcbiAgICAgICAgICAgICAgICBzdGF0dXMuY3RybE9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBcbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmKHN0b3BJbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaChldmVudC5jb2RlKSB7XG4gICAgICAgICAgICBjYXNlIFwiRW50ZXJcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soS0VZQk9BUkRfSU5QVVQuRU5URVIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkJhY2tzcGFjZVwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjayhLRVlCT0FSRF9JTlBVVC5CQUNLU1BBQ0UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkRlbGV0ZVwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjayhLRVlCT0FSRF9JTlBVVC5ERUxFVEUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkFycm93TGVmdFwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjayhLRVlCT0FSRF9DT01NQU5EUy5BUlJPV19MRUZUKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6XG4gICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKEtFWUJPQVJEX0NPTU1BTkRTLkFSUk9XX1JJR0hUKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjpcbiAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soS0VZQk9BUkRfQ09NTUFORFMuQVJST1dfRE9XTik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQXJyb3dVcFwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjayhLRVlCT0FSRF9DT01NQU5EUy5BUlJPV19VUCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKGV2ZW50LmtleSkge1xuICAgICAgICAgICAgY2FzZSBcIlNoaWZ0XCI6XG4gICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKEtFWUJPQVJEX0NPTU1BTkRTLlNISUZUX0RPV04pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5zaGlmdE9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJNZXRhXCI6XG4gICAgICAgICAgICBjYXNlIFwiQ29udHJvbFwiOlxuICAgICAgICAgICAgICAgIHN0YXR1cy5jdHJsT24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgaWYoc3RhdHVzLmN0cmxPbikge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soS0VZQk9BUkRfQ09NTUFORFMuQ1RSTEEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGNhc2UgJ2MnOlxuICAgICAgICAgICAgLy8gICAgIGlmKHN0YXR1cy5jdHJsT24pIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgY29udHJvbENhbGxiYWNrKEtFWUJPQVJEX0NPTU1BTkRTLkNUUkxDKTtcbiAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAvLyAgICAgYnJlYWs7IFxuICAgICAgICAgICAgLy8gY2FzZSAndic6XG4gICAgICAgICAgICAvLyAgICAgaWYoc3RhdHVzLmN0cmxPbikge1xuICAgICAgICAgICAgLy8gICAgICAgICBjb250cm9sQ2FsbGJhY2soS0VZQk9BUkRfQ09NTUFORFMuQ1RSTFYpO1xuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vICAgICBicmVhazsgICBcbiAgICAgICAgICAgIC8vIGNhc2UgJ3gnOlxuICAgICAgICAgICAgLy8gICAgIGlmKHN0YXR1cy5jdHJsT24pIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgY29udHJvbENhbGxiYWNrKEtFWUJPQVJEX0NPTU1BTkRTLkNUUkxYKTtcbiAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAvLyAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgICAgICBpZihzdGF0dXMuY3RybE9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjayhLRVlCT0FSRF9DT01NQU5EUy5SRURPKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgICAgICBpZigoc3RhdHVzLmN0cmxPbiAmJiBzdGF0dXMuc2hpZnRPbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKEtFWUJPQVJEX0NPTU1BTkRTLlJFRE8pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihzdGF0dXMuY3RybE9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjayhLRVlCT0FSRF9DT01NQU5EUy5VTkRPKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gICBcbiAgICB9KVxuICAgIHJldHVybiBpbnB1dDtcbn0iLCJjbGFzcyBDYXJldCB7IFxuICAgIF9yb3cgPSAwO1xuICAgIF9jb2x1bW4gPSBbMCwwXTtcblxuICAgIF9zdGF0dXMgPSB7XG4gICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgIGFuaW1lOiBudWxsLFxuICAgICAgICBsYXN0RWxhcHNlZDogMCxcbiAgICAgICAgcmVmcmVzaEVsYXBzZWQ6IGZhbHNlLFxuICAgIH1cblxuICAgIHNldFJvdyhyb3cpIHtcbiAgICAgICAgdGhpcy5fcm93ID0gcm93O1xuICAgIH1cbiAgICBzZXRDb2x1bW4oY29sdW1ub3JpZHgsIGNvbHVtbikge1xuICAgICAgICBpZihjb2x1bW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fY29sdW1uW2NvbHVtbm9yaWR4XSA9IGNvbHVtbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbHVtbiA9IGNvbHVtbm9yaWR4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Um93KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm93O1xuICAgIH1cblxuICAgIGdldENvbHVtbihpZHgpIHtcbiAgICAgICAgaWYoaWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5baWR4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY29sdW1uO1xuICAgIH1cblxuICAgIGFuaW1hdGUoamZsb3cpIHtcbiAgICAgICAgdGhpcy5fc3RhdHVzLmFuaW1lID0gamZsb3cucmVxdWVzdEpGbG93QW5pbWUoKGVsYXBzZWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RFbGFwc2VkID0gdGhpcy5fc3RhdHVzLmxhc3RFbGFwc2VkO1xuICAgICAgICAgICAgaWYodGhpcy5fc3RhdHVzLnJlZnJlc2hFbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzLmxhc3RFbGFwc2VkID0gZWxhcHNlZDtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMucmVmcmVzaEVsYXBzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGVsYXBzZWQgLSBsYXN0RWxhcHNlZCA+IDUwMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5zaG93ID0gIXRoaXMuX3N0YXR1cy5zaG93O1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5sYXN0RWxhcHNlZCA9IGVsYXBzZWQ7XG4gICAgICAgICAgICB9IFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjYW5jZWxBbmltYXRlKCkge1xuICAgICAgICB0aGlzLl9zdGF0dXMuYW5pbWUuY2FuY2VsKClcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9zdGF0dXMsIHtcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICBhbmltZTogbnVsbCxcbiAgICAgICAgICAgIGxhc3RFbGFwc2VkOiAwLFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGlzU2hvdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXR1cy5zaG93O1xuICAgIH1cblxuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fc3RhdHVzLCB7XG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgcmVmcmVzaEVsYXBzZWQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRvUmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5fcm93LCAuLi50aGlzLl9jb2x1bW5dO1xuICAgIH1cblxuICAgIGZyb21SYW5nZShyYW5nZSkge1xuICAgICAgICB0aGlzLl9yb3cgPSByYW5nZVswXTtcbiAgICAgICAgdGhpcy5fY29sdW1uID0gcmFuZ2Uuc2xpY2UoMSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYXJldDsiLCJpbXBvcnQgeyByZXF1ZXN0Q2FjaGVDYW52YXMgfSBmcm9tICcuLi8uLi91dGlscy9jYW52YXMnO1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldEJ5V2lkdGgoXG4gICAgb2ZmeCwgXG4gICAgdGV4dG1ldGEsXG4gICAgZm9udFNpemUsIGZvbnRGYW1pbHksXG4gICAgc3BhY2VIb2xkZXJcbikge1xuICAgIGNvbnN0IGNvbnRlbnQgPSB0ZXh0bWV0YS5nZXRSZW5kZXJTb3VyY2Uoc3BhY2VIb2xkZXIpO1xuICAgIGNvbnN0IG1heEwgPSBjb250ZW50Lmxlbmd0aCAtIDE7XG4gICAgaWYodGV4dG1ldGEud2lkdGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IGFsbHdpZHRoID0gdGV4dG1ldGEud2lkdGg7XG4gICAgbGV0IGlkeCA9IE1hdGguZmxvb3Iob2ZmeCAvIGFsbHdpZHRoICogbWF4TCkgO1xuICAgIHJlcXVlc3RDYWNoZUNhbnZhcygoY3R4KSA9PiB7XG4gICAgICAgIGN0eC5mb250ID0gYCR7Zm9udFNpemV9ICR7Zm9udEZhbWlseX1gO1xuICAgICAgICBsZXQgZzEsIGcyO1xuICAgICAgICBsZXQgbGFzdGlkeDtcblxuICAgICAgICBsZXQgYyA9IGNvbnRlbnQuc3Vic3RyaW5nKDAsIGlkeCk7XG4gICAgICAgIGxldCBjMSA9IGNvbnRlbnQuc3Vic3RyaW5nKGlkeC0xLCBpZHgpO1xuICAgICAgICBsZXQgYzIgPSBjb250ZW50LnN1YnN0cmluZyhpZHgsIGlkeCsxKTtcbiAgICAgICAgbGV0IHcgPSBjdHgubWVhc3VyZVRleHQoYykud2lkdGg7XG4gICAgICAgIGxldCB3MSA9IGN0eC5tZWFzdXJlVGV4dChjMSkud2lkdGg7XG4gICAgICAgIGxldCB3MiA9IGN0eC5tZWFzdXJlVGV4dChjMikud2lkdGg7XG4gICAgICAgIGcxID0gdyAtIHcxLzI7XG4gICAgICAgIGcyID0gdyArIHcyLzI7XG4gICAgICAgIFxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZihnMSA8PSBvZmZ4ICYmIGcyID49IG9mZngpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgaWYoZzEgPiBvZmZ4KSB7XG4gICAgICAgICAgICAgICAgLy8g5bem5L6n5bCR5LqGXG4gICAgICAgICAgICAgICAgY29uc3Qgc3BhbncgPSBnMiAtIG9mZng7XG4gICAgICAgICAgICAgICAgbGFzdGlkeCA9IGlkeDtcbiAgICAgICAgICAgICAgICBpZihzcGFudyA8IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICBpZHggLT0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZHggLT0gTWF0aC5mbG9vcihzcGFudyAvIGcyICogbGFzdGlkeClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYyA9IGNvbnRlbnQuc3Vic3RyaW5nKGlkeCwgbGFzdGlkeCk7XG4gICAgICAgICAgICAgICAgdyAtPSBjdHgubWVhc3VyZVRleHQoYykud2lkdGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYoZzIgPCBvZmZ4KSB7XG4gICAgICAgICAgICAgICAgLy8g5Y+z5L6n5bCR5LqGXG4gICAgICAgICAgICAgICAgY29uc3Qgc3BhbncgPSBvZmZ4IC0gZzE7XG4gICAgICAgICAgICAgICAgbGFzdGlkeCA9IGlkeDtcbiAgICAgICAgICAgICAgICBpZihzcGFudyA8IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZHggKz0gTWF0aC5mbG9vcihzcGFudyAvIChhbGx3aWR0aCAtIGcxKSAqIChtYXhMIC0gbGFzdGlkeCkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGMgPSBjb250ZW50LnN1YnN0cmluZyhsYXN0aWR4LCBpZHgpO1xuICAgICAgICAgICAgICAgIHcgKz0gY3R4Lm1lYXN1cmVUZXh0KGMpLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjMSA9IGNvbnRlbnQuc3Vic3RyaW5nKGlkeC0xLCBpZHgpO1xuICAgICAgICAgICAgYzIgPSBjb250ZW50LnN1YnN0cmluZyhpZHgsIGlkeCsxKTtcbiAgICAgICAgICAgIHcxID0gY3R4Lm1lYXN1cmVUZXh0KGMxKS53aWR0aDtcbiAgICAgICAgICAgIHcyID0gY3R4Lm1lYXN1cmVUZXh0KGMyKS53aWR0aDtcbiAgICAgICAgICAgIGcxID0gdyAtIHcxLzI7XG4gICAgICAgICAgICBnMiA9IHcgKyB3Mi8yO1xuICAgICAgICB9IHdoaWxlKGlkeCA+PSAwICYmIGlkeCA8PSBtYXhMKVxuICAgICAgICBcbiAgICB9KTtcbiAgICByZXR1cm4gaWR4O1xufSIsImltcG9ydCB7IGNhbGN1bGF0ZU9mZnNldEJ5V2lkdGggfSBmcm9tICcuLi91dGlscydcbmV4cG9ydCBjbGFzcyBBcmVhIHtcbiAgICBfbGluZXMgPSBbXTsgXG5cbiAgICBnZXQoaWR4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lc1tpZHhdO1xuICAgIH1cblxuICAgIGdldExpbmVBYm92ZShvZmZzZXRZKSB7XG4gICAgICAgIGxldCByb3cgPSAwO1xuICAgICAgICBjb25zdCBsaW5lcyA9IHRoaXMuX2xpbmVzO1xuICAgICAgICB3aGlsZShyb3cgPCBsaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmKGxpbmVzW3Jvd10ucmVkdWNlSGVpZ2h0ID4gb2Zmc2V0WSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93ICsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihyb3csIGxpbmVzLmxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIHRydW5jYXRlKGNvbmZpZ3MpIHtcbiAgICAgICAgY29uc3QgbCA9IExpbmUuY3JlYXRlKGNvbmZpZ3MpO1xuICAgICAgICB0aGlzLl9saW5lcyA9IFtsXTtcbiAgICAgICAgcmV0dXJuIGw7XG4gICAgfVxuXG4gICAgcHVzaChsaW5lKSB7XG4gICAgICAgIHRoaXMuX2xpbmVzLnB1c2gobGluZSk7XG4gICAgfVxuXG4gICAgZm9yRWFjaChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9saW5lcy5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lcy5sZW5ndGg7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgTGluZSB7XG4gICAgd2lkdGggPSAwO1xuICAgIGFuY2hvclkgPSAwO1xuICAgIGhlaWdodCA9IDA7XG4gICAgcmVkdWNlSGVpZ2h0ID0gMDtcbiAgICBfZWxlbWVudHMgPSBbXVxuXG4gICAgc3RhdGljIGNyZWF0ZShjb25maWdzKSB7XG4gICAgICAgIGNvbnN0IGwgPSBuZXcgTGluZShjb25maWdzKTtcbiAgICAgICAgcmV0dXJuIGw7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoY29uZmlncyA9IHt9KSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY29uZmlncyk7XG4gICAgfVxuXG4gICAgX2VsZW1lbnRzID0gW107XG5cbiAgICBnZXQoaWR4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50c1tpZHhdO1xuICAgIH1cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50cy5sZW5ndGg7XG4gICAgfVxuXG4gICAgaW5zZXJ0KGlkeCwgZWxlbSkge1xuICAgICAgICB0aGlzLl9lbGVtZW50cy5zcGxpY2UoaWR4LCAwLCBlbGVtKVxuICAgIH1cbiAgICBwdXNoKGVsZW0pIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudHMucHVzaChlbGVtKTtcbiAgICB9XG4gICAgdGFpbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRzW3RoaXMuX2VsZW1lbnRzLmxlbmd0aC0xXTtcbiAgICB9XG4gICAgY29weSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRzLnNsaWNlKCk7XG4gICAgfVxuXG4gICAgZ2V0Q29sdW1uTmVhcmVzdChvZmZzZXRYLCBlbGVtZW50U3BhY2UsIGZvbnRTaXplLCBmb250RmFtaWx5LCBlZGl0b3IpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLl9lbGVtZW50cztcbiAgICAgICAgaWYob2Zmc2V0WCA+PSB0aGlzLndpZHRoKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gZWxlbWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW0gPSBlbGVtZW50c1tjXTtcbiAgICAgICAgICAgIGxldCBxID0gMDtcbiAgICAgICAgICAgIGlmKGVsZW0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgcSA9IGVsZW0uc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICByZXR1cm4gW2MsIHFdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZWxlbV9pZHggPSAwO1xuICAgICAgICAgICAgbGV0IGxhc3RfYyA9IDA7XG4gICAgICAgICAgICBsZXQgX2MgPSAwOyBcbiAgICAgICAgICAgIGxldCBsYXN0ZWwgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUoZWxlbV9pZHggPCBlbGVtZW50cy5sZW5ndGggLTEpIHtcbiAgICAgICAgICAgICAgICBsYXN0X2MgPSBfYztcbiAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGVsZW1lbnRzW2VsZW1faWR4XTtcbiAgICAgICAgICAgICAgICBpZihlbC50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG91YmxlTWFyZ2luID0gKGxhc3RlbCAmJiBsYXN0ZWwudHlwZSA9PT0gJ3RleHQnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFyZ2luID0gZG91YmxlTWFyZ2luID8gZWxlbWVudFNwYWNlKjIgOiBlbGVtZW50U3BhY2U7XG4gICAgICAgICAgICAgICAgICAgIF9jICs9IChlbC53aWR0aCArIG1hcmdpbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX2MgKz0gZWwud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKF9jID4gb2Zmc2V0WCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0ZWwgPSBlbFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdGVsID0gZWxcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBlbGVtX2lkeCsrO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoX2MgPD0gb2Zmc2V0WCkge1xuICAgICAgICAgICAgICAgIGxhc3RfYyA9IF9jO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGV4dG1ldGEgPSBlbGVtZW50c1tlbGVtX2lkeF07XG4gICAgICAgICAgICBpZih0ZXh0bWV0YS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZ4ID0gb2Zmc2V0WCAtIGxhc3RfYztcbiAgICAgICAgICAgICAgICBjb25zdCBpZHggPSBjYWxjdWxhdGVPZmZzZXRCeVdpZHRoKG9mZngsIHRleHRtZXRhLCBmb250U2l6ZSwgZm9udEZhbWlseSwgZWRpdG9yLnNwYWNlSG9sZGVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBbZWxlbV9pZHgsIGlkeF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnggPSBvZmZzZXRYIC0gbGFzdF9jO1xuICAgICAgICAgICAgICAgIGlmKG9mZnggPiBsYXN0ZWwud2lkdGgvMil7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbZWxlbV9pZHgrMSwgMF1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2VsZW1faWR4LCAwXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudHMuZm9yRWFjaChjYWxsYmFjayk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgRmxhdHRlblRleHRFbGVtZW50cyB7XG4gICAgc3RhdGljIGNyZWF0ZShlbGVtZW50cykge1xuICAgICAgICBjb25zdCBfZSA9IG5ldyBGbGF0dGVuVGV4dEVsZW1lbnRzKCk7XG4gICAgICAgIF9lLmZyb20oZWxlbWVudHMpO1xuICAgICAgICByZXR1cm4gX2U7XG4gICAgfVxuICAgIF90ZXh0RWxlbWVudHMgPSBbXTtcbiAgICBfcmVjb3JkcyA9IFtdO1xuICAgIF9jYXJldFJlY29yZCA9IG51bGw7XG5cbiAgICBpbnNlcnRCZWZvcmUoYW5jaG9yLCBlbGVtKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuZmluZEluZGV4KGFuY2hvcik7XG4gICAgICAgIHRoaXMuaW5lcnNldEF0KGlkeCwgZWxlbSk7XG4gICAgfVxuICAgIGluc2VydEFmdGVyKGFuY2hvciwgZWxlbSwgbmVlZFdyYXApIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5maW5kSW5kZXgoYW5jaG9yKTtcbiAgICAgICAgLy8gY29uc3QgbmV4dCA9IHRoaXMuZ2V0KGlkeCsxKTtcbiAgICAgICAgaWYobmVlZFdyYXApIHtcbiAgICAgICAgICAgIGVsZW0uc2V0TmVlZFdyYXAodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmVyc2V0QXQoaWR4KzEsIGVsZW0pO1xuICAgIH1cbiAgICBmaW5kSW5kZXgoZWxlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dEVsZW1lbnRzLmZpbmRJbmRleChlbCA9PiBlbCA9PT0gZWxlbSk7XG4gICAgfVxuICAgIGdldChpZHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRFbGVtZW50c1tpZHhdO1xuICAgIH1cbiAgICBmcm9tKGVsZW1lbnRzKSB7XG4gICAgICAgIHRoaXMuX3RleHRFbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgIH1cbiAgICBpbmVyc2V0QXQoaWR4LCBlbGVtKSB7XG4gICAgICAgIHRoaXMuc3BsaWNlKGlkeCwgMCwgZWxlbSlcbiAgICB9XG4gICAgcHVzaChlbGVtKSB7XG4gICAgICAgIHRoaXMuc3BsaWNlKHRoaXMubGVuZ3RoKCksIDAsIGVsZW0pO1xuICAgIH1cbiAgICByZW1vdmUoaWR4KSB7XG4gICAgICAgIHRoaXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxuICAgIHNwbGljZSgpIHtcbiAgICAgICAgY29uc3QgcmVtb3ZlZCA9IHRoaXMuX3RleHRFbGVtZW50cy5zcGxpY2UoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fcmVjb3Jkcy5wdXNoKHtcbiAgICAgICAgICAgIG9wOiAnc3BsaWNlJyxcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIHJlbW92ZWQsXG4gICAgICAgIH0pXG4gICAgfVxuICAgIHNsaWNlKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRFbGVtZW50cy5zbGljZSguLi5hcmdzKVxuICAgIH1cbiAgICBjb3B5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dEVsZW1lbnRzLnNsaWNlKCk7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0RWxlbWVudHMubGVuZ3RoID09PSAxICYmIHRoaXMuX3RleHRFbGVtZW50c1swXS5zb3VyY2UgPT09ICcnO1xuICAgIH1cbiAgICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX3RleHRFbGVtZW50cy5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgdGFpbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRFbGVtZW50c1t0aGlzLl90ZXh0RWxlbWVudHMubGVuZ3RoLTFdO1xuICAgIH1cbiAgICBmaWx0ZXIoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRFbGVtZW50cy5maWx0ZXIoY2FsbGJhY2spO1xuICAgIH1cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0RWxlbWVudHMubGVuZ3RoO1xuICAgIH1cblxuICAgIHN0YXJ0UmVjb3JkKCkge1xuICAgICAgICB0aGlzLl9jYXJldFJlY29yZCA9IHtcbiAgICAgICAgICAgIGJlZm9yZTogbnVsbCxcbiAgICAgICAgICAgIGFmdGVyOiBudWxsLFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlY29yZHMgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29yZHM7XG4gICAgfVxuXG4gICAgZ2V0UmVjb3JkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVjb3JkcztcbiAgICB9XG5cbiAgICByZWNvcmRCZWZvcmVDYXJldChjYXJldCkge1xuICAgICAgICB0aGlzLl9jYXJldFJlY29yZC5iZWZvcmUgPSBjYXJldC50b1JhbmdlKCk7XG4gICAgfVxuXG4gICAgcmVjb3JkQWZ0ZXJDYXJldChjYXJldCkge1xuICAgICAgICB0aGlzLl9jYXJldFJlY29yZC5hZnRlciA9IGNhcmV0LnRvUmFuZ2UoKTtcbiAgICB9XG5cbiAgICBnZXRDYXJldFJlY29yZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhcmV0UmVjb3JkO1xuICAgIH1cblxuICAgIGNvbGxlY3RSZWNvcmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVjb3JkcztcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBUZXh0RWxlbWVudCB7XG4gICAgbmVlZFdyYXAgPSBmYWxzZTtcbiAgICB3aWR0aCA9IDA7XG4gICAgcmVkdWNlV2lkdGggPSAwO1xuICAgIGhlaWdodCA9IDA7XG4gICAgYW5jaG9yWCA9IDA7XG4gICAgYW5jaG9yWSA9IDA7XG4gICAgZGlydHkgPSB0cnVlO1xuICAgIGlzVGFpbCA9IGZhbHNlO1xuXG4gICAgX3NwYWNlUmVjb3JkcyA9IFtdO1xuICAgIF9zcGFjZWRDb250ZW50U2VnbW5lbnQgPSBbXTtcbiAgICBfcmV0dXJuU3ltYm9sID0ge1xuICAgICAgICBzeW1ib2w6ICfihrInLFxuICAgICAgICB3aWR0aDogMCxcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IodHlwZSwgc291cmNlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cblxuICAgIGdldFJlbmRlclNvdXJjZShzcGFjZUhvbGRlcikge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5zb3VyY2U7XG4gICAgICAgIGlmKHNwYWNlSG9sZGVyLmVuYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZSgvXFxzL2csIHNwYWNlSG9sZGVyLnNwYWNlUGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuXG4gICAgc2V0U291cmNlV2l0aFJlY29yZChzb3VyY2UsIHNwYWNlSG9sZGVyLCByZWNvcmRzKSB7XG4gICAgICAgIGNvbnN0IGxhc3RTb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgdGhpcy5zZXRTb3VyY2Uoc291cmNlLCBzcGFjZUhvbGRlcik7XG4gICAgICAgIGlmKHJlY29yZHMpIHtcbiAgICAgICAgICAgIHJlY29yZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3A6ICdzZXRTb3VyY2UnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFt0aGlzLCBzb3VyY2UsIGxhc3RTb3VyY2VdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRTb3VyY2Uoc291cmNlLCBzcGFjZUhvbGRlcikge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIGlmKHNwYWNlSG9sZGVyLmVuYWJsZSkge1xuICAgICAgICAgICAgY29uc3QgciA9IHRoaXMuX3NwYWNlUmVjb3JkcztcbiAgICAgICAgICAgIGNvbnN0IHAgPSBzcGFjZUhvbGRlci5zcGFjZVBsYWNlaG9sZGVyXG4gICAgICAgICAgICByLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBsZXQgbGFzdE9mZnNldDtcbiAgICAgICAgICAgIHNvdXJjZS5yZXBsYWNlKC9cXHMvZywgKF8sIG9mZnNldCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmKGxhc3RPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICByLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYob2Zmc2V0IC0gbGFzdE9mZnNldCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgci5wdXNoKGxhc3RPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGlmKGxhc3RPZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHIucHVzaChsYXN0T2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldE5lZWRXcmFwKG5lZWRXcmFwLCByZWNvcmRzKSB7XG4gICAgICAgIGNvbnN0IGxhc3RXcmFwID0gdGhpcy5uZWVkV3JhcDtcbiAgICAgICAgdGhpcy5uZWVkV3JhcCA9IG5lZWRXcmFwO1xuICAgICAgICBpZihsYXN0V3JhcCE9PSBuZWVkV3JhcCAmJiByZWNvcmRzKSB7XG4gICAgICAgICAgICByZWNvcmRzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9wOiAnc2V0TmVlZFdyYXAnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFt0aGlzLCBuZWVkV3JhcCwgbGFzdFdyYXBdLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNoaWZ0KG9mZnNldCwgc3RlcCkge1xuICAgICAgICBpZih0aGlzLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuc291cmNlO1xuICAgICAgICAgICAgY29uc3QgbCA9IGNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgbmV4dE9mZnNldCA9IG9mZnNldCArIHN0ZXA7XG4gICAgICAgICAgICBpZihuZXh0T2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAncHJldic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihuZXh0T2Zmc2V0ID4gbCApey8vLSAoKGlzVGFpbCB8fCB0aGlzLm5lZWRXcmFwKSA/IDAgOiAxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbmV4dCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ3NlbGYnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoc3RlcCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25leHQnO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIGlmKHN0ZXAgPCAwKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3ByZXYnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGFpbE9mZnNldCgpIHtcbiAgICAgICAgaWYodGhpcy50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIGlmKHRoaXMubmVlZFdyYXAgfHwgdGhpcy5pc1RhaWwpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCB0aGlzLnNvdXJjZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGVhZE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcHJlQ2FsY3VsYXRlVGV4dChjdHgsIHNwYWNlSG9sZGVyKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmdldFJlbmRlclNvdXJjZShzcGFjZUhvbGRlcik7XG4gICAgICAgIHRoaXMud2lkdGggPSBjdHgubWVhc3VyZVRleHQoY29udGVudCkud2lkdGg7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgaWYoc3BhY2VIb2xkZXIuZW5hYmxlKSB7XG4gICAgICAgICAgICBjb25zdCBzX3dpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHNwYWNlSG9sZGVyLnNwYWNlUGxhY2Vob2xkZXIpLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5fcmV0dXJuU3ltYm9sLndpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHRoaXMuX3JldHVyblN5bWJvbC5zeW1ib2wpLndpZHRoO1xuICAgICAgICAgICAgY29uc3QgcjIgPSB0aGlzLl9zcGFjZWRDb250ZW50U2VnbW5lbnQ7XG4gICAgICAgICAgICBsZXQgbGFzdE9mZnNldCA9IDA7XG4gICAgICAgICAgICByMi5sZW5ndGggPSAwO1xuICAgICAgICAgICAgaWYodGhpcy5fc3BhY2VSZWNvcmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLl9zcGFjZVJlY29yZHM7ICAgICAgXG4gICAgICAgICAgICAgICAgY29uc3QgbCA9IHIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZShpIDwgbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmID0gcltpKytdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gcltpKytdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBxID0gY29udGVudC5zdWJzdHJpbmcobGFzdE9mZnNldCwgZik7XG4gICAgICAgICAgICAgICAgICAgIHIyLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgcSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tZWFzdXJlVGV4dChxKS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgcjIucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LnN1YnN0cmluZyhmLCB0KzEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHQgLSBmICsgMSkgKiBzX3dpZHRoLCAgXG4gICAgICAgICAgICAgICAgICAgICAgICAncGxhY2Vob2xkZXInLFxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gdCsxXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYobGFzdE9mZnNldCA8IGNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcSA9IGNvbnRlbnQuc3Vic3RyaW5nKGxhc3RPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHIyLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICBxLFxuICAgICAgICAgICAgICAgICAgICBjdHgubWVhc3VyZVRleHQocSkud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0JyxcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih0aGlzLm5lZWRXcmFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCArPSB0aGlzLl9yZXR1cm5TeW1ib2wud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfVxuXG4gICAgcmVuZGVyKGN0eCwgc3BhY2VIb2xkZXIsIHRleHRDb2xvcikge1xuICAgICAgICBpZihzcGFjZUhvbGRlci5lbmFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGh3ID0gdGhpcy53aWR0aC8yO1xuICAgICAgICAgICAgbGV0IF93ID0gIC1odyArIHRoaXMuYW5jaG9yWDtcbiAgICAgICAgICAgIGNvbnN0IHNwYWNlUGxhY2Vob2xkZXJDb2xvciA9IHNwYWNlSG9sZGVyLnNwYWNlUGxhY2Vob2xkZXJDb2xvcjtcbiAgICAgICAgICAgIHRoaXMuX3NwYWNlZENvbnRlbnRTZWdtbmVudC5mb3JFYWNoKHNlZyA9PiB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHNlZ1syXSA9PT0gJ3RleHQnID8gdGV4dENvbG9yIDogc3BhY2VQbGFjZWhvbGRlckNvbG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBzZWdbMV0vMjtcbiAgICAgICAgICAgICAgICBfdyArPSB0O1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChzZWdbMF0sIF93LCB0aGlzLmFuY2hvclkpO1xuICAgICAgICAgICAgICAgIF93ICs9IHQ7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgaWYodGhpcy5uZWVkV3JhcCkge1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSBzcGFjZUhvbGRlci5yZXR1cm5Gb250O1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBzcGFjZVBsYWNlaG9sZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMuX3JldHVyblN5bWJvbC5zeW1ib2wsIFxuICAgICAgICAgICAgICAgICAgICBfdyArIHRoaXMuX3JldHVyblN5bWJvbC53aWR0aC8yLCB0aGlzLmFuY2hvclkpO1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47ICAgXG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMuc291cmNlLCB0aGlzLmFuY2hvclgsIHRoaXMuYW5jaG9yWSlcbiAgICB9XG59IiwiaW1wb3J0IHsgVGV4dEVsZW1lbnQgfSBmcm9tIFwiLi4vc3RvcmFnZVwiO1xuY2xhc3MgUmFuZ2Uge1xuICAgIF9lbmFibGUgPSBmYWxzZTtcbiAgICBfcmFuZ2VGcm9tID0gbnVsbDsgLy8gW3JvdywgZWxlbV9pZHgsIG9mZnNldF1cbiAgICBfcmFuZ2VUbyA9IG51bGw7ICAgLy8gW3JvdywgZWxlbV9pZHgsIG9mZnNldF1cbiAgICBfaW5pdGlhbFJhbmdlID0gbnVsbDsgXG5cbiAgICBzZXRJbml0aWFsUmFuZ2UoaW5pdGlhbFJhbmdlKSB7XG4gICAgICAgIHRoaXMuX2luaXRpYWxSYW5nZSA9IGluaXRpYWxSYW5nZTtcbiAgICB9XG5cbiAgICBnZXRSYW5nZUZyb20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYW5nZUZyb207XG4gICAgfVxuXG4gICAgZ2V0UmFuZ2VUbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhbmdlVG87XG4gICAgfVxuXG4gICAgaXNFbmFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmFibGU7XG4gICAgfVxuXG4gICAgZW5hYmxlKCkge1xuICAgICAgICB0aGlzLl9lbmFibGUgPSB0cnVlO1xuICAgIH1cbiAgICBkaXNhYmxlKCkge1xuICAgICAgICB0aGlzLl9lbmFibGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBoYW5kbGVDYXJldChjYXJldCkge1xuICAgICAgICBjb25zdCBbYSwgYiwgY10gPSB0aGlzLl9yYW5nZVRvO1xuICAgICAgICBjYXJldC5zZXRSb3coYSk7XG4gICAgICAgIGNhcmV0LnNldENvbHVtbihbYiwgY10pO1xuICAgIH1cblxuICAgIHNldFJhbmdlKGFub3RoZXIpIHtcbiAgICAgICAgY29uc3QgYSA9IHRoaXMuX2luaXRpYWxSYW5nZTtcbiAgICAgICAgaWYodGhpcy5fY29tcGFyZVJhbmdlKGEsIGFub3RoZXIpKSB7XG4gICAgICAgICAgICB0aGlzLl9yYW5nZUZyb20gPSBhO1xuICAgICAgICAgICAgdGhpcy5fcmFuZ2VUbyA9IGFub3RoZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yYW5nZUZyb20gPSBhbm90aGVyO1xuICAgICAgICAgICAgdGhpcy5fcmFuZ2VUbyA9IGE7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIF9jb21wYXJlUmFuZ2UocjEsIHIyKSB7XG4gICAgICAgIGlmKHIxWzBdID4gcjJbMF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZihyMVswXSA9PT0gcjJbMF0gJiYgcjFbMV0gPiByMlsxXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHIxWzBdID09PSByMlswXSAmJiByMVsxXSA9PT0gcjJbMV0gJiYgcjFbMl0gPiByMlsyXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFRPRE8gXG4gICAgZ2V0UmFuZ2VDb3B5KGVkaXRvcikge1xuICAgICAgICBpZih0aGlzLl9lbmFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyZWEgPSBlZGl0b3IuX2FyZWE7XG4gICAgICAgICAgICBjb25zdCBjYXJldCA9IGVkaXRvci5fY2FyZXQ7XG4gICAgICAgICAgICBjb25zdCByYW5nZUZyb20gPSB0aGlzLl9yYW5nZUZyb207XG4gICAgICAgICAgICBjb25zdCByYW5nZVRvID0gdGhpcy5fcmFuZ2VUbztcbiAgICAgICAgICAgIGNvbnN0IGVsZW1Gcm9tID0gYXJlYS5nZXQocmFuZ2VGcm9tWzBdKS5nZXQocmFuZ2VGcm9tWzFdKTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1UbyA9IGFyZWEuZ2V0KHJhbmdlVG9bMF0pLmdldChyYW5nZVRvWzFdKTtcbiAgICAgICAgICAgIGlmKGVsZW1Gcm9tID09PSBlbGVtVG8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gZWxlbUZyb20uc291cmNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBjLnN1YnN0cmluZyhyYW5nZUZyb21bMl0sIHJhbmdlVG9bMl0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBmbGF0dGVuVHh0RWxlbSA9IGVkaXRvci5fZmxhdHRlblR4dEVsZW1cbiAgICAgICAgICAgIGxldCBwcmVDb250ZW50ID0gJyc7XG4gICAgICAgICAgICBsZXQgYWZ0ZXJDb250ZW50ID0gJyc7XG4gICAgICAgICAgICBjb25zdCBmcm9tSWR4ID0gZmxhdHRlblR4dEVsZW0uZmluZEluZGV4KGVsZW1Gcm9tKTtcbiAgICAgICAgICAgIGNvbnN0IHRvSWR4ID0gZmxhdHRlblR4dEVsZW0uZmluZEluZGV4KGVsZW1Ubyk7XG4gICAgICAgICAgICBjb25zdCBlbGVtcyA9IGZsYXR0ZW5UeHRFbGVtLnNsaWNlKGZyb21JZHgsIHRvSWR4KzEpO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBlbGVtcy5zbGljZSgxLCBlbGVtcy5sZW5ndGgtMSkuZmlsdGVyKChlbCkgPT4gZWwudHlwZSA9PT0gJ3RleHQnKTtcbiAgICAgICAgICAgIHByZUNvbnRlbnQgPSBlbGVtRnJvbS5zb3VyY2Uuc3Vic3RyaW5nKHJhbmdlRnJvbVsyXSk7XG4gICAgICAgICAgICBhZnRlckNvbnRlbnQgPSBlbGVtVG8uc291cmNlLnN1YnN0cmluZygwLCByYW5nZVRvWzJdKTtcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gcHJlQ29udGVudDtcbiAgICAgICAgICAgIGlmKGVsZW1Gcm9tLm5lZWRXcmFwKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCArPSAnXFxuJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICAgICAgY29udGVudCArPSBlbC5zb3VyY2VcbiAgICAgICAgICAgICAgICBpZihlbC5uZWVkV3JhcCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50ICs9ICdcXG4nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudCArIGFmdGVyQ29udGVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlbGV0ZShlZGl0b3IsIHJlY29yZHMpIHtcbiAgICAgICAgaWYodGhpcy5fZW5hYmxlKSB7XG4gICAgICAgICAgICBjb25zdCBhcmVhID0gZWRpdG9yLl9hcmVhO1xuICAgICAgICAgICAgY29uc3QgY2FyZXQgPSBlZGl0b3IuX2NhcmV0O1xuICAgICAgICAgICAgY29uc3QgcmFuZ2VGcm9tID0gdGhpcy5fcmFuZ2VGcm9tO1xuICAgICAgICAgICAgY29uc3QgcmFuZ2VUbyA9IHRoaXMuX3JhbmdlVG87XG4gICAgICAgICAgICBjb25zdCBlbGVtRnJvbSA9IGFyZWEuZ2V0KHJhbmdlRnJvbVswXSkuZ2V0KHJhbmdlRnJvbVsxXSk7XG4gICAgICAgICAgICBjb25zdCBlbGVtVG8gPSBhcmVhLmdldChyYW5nZVRvWzBdKS5nZXQocmFuZ2VUb1sxXSk7XG4gICAgICAgICAgICBsZXQgW3JvdywgZWxlbV9pZHgsIG9mZnNldF0gPSByYW5nZUZyb207XG4gICAgICAgICAgICByZWNvcmRzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9wOiAncmFuZ2UnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtyYW5nZUZyb20uc2xpY2UoKSwgcmFuZ2VUby5zbGljZSgpXSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBpZihlbGVtRnJvbSA9PT0gZWxlbVRvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IGVsZW1Gcm9tLnNvdXJjZTtcbiAgICAgICAgICAgICAgICBlbGVtRnJvbS5zZXRTb3VyY2VXaXRoUmVjb3JkKFxuICAgICAgICAgICAgICAgICAgICBjLnN1YnN0cmluZygwLCByYW5nZUZyb21bMl0pICsgYy5zdWJzdHJpbmcocmFuZ2VUb1syXSksIFxuICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc3BhY2VIb2xkZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmbGF0dGVuVHh0RWxlbSA9IGVkaXRvci5fZmxhdHRlblR4dEVsZW1cbiAgICAgICAgICAgICAgICBsZXQgcHJlQ29udGVudCA9ICcnO1xuICAgICAgICAgICAgICAgIGxldCBhZnRlckNvbnRlbnQgPSAnJztcbiAgICAgICAgICAgICAgICBsZXQgcHJlRWxlbWVudDtcbiAgICAgICAgICAgICAgICBsZXQgYWZ0ZXJFbGVtZW50OyAgXG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbUlkeCA9IGZsYXR0ZW5UeHRFbGVtLmZpbmRJbmRleChlbGVtRnJvbSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9JZHggPSBmbGF0dGVuVHh0RWxlbS5maW5kSW5kZXgoZWxlbVRvKTtcbiAgICAgICAgICAgICAgICBsZXQgZW5kVGV4dE5lZWRXcmFwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYoZWxlbUZyb20udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZUNvbnRlbnQgPSBlbGVtRnJvbS5zb3VyY2Uuc3Vic3RyaW5nKDAsIHJhbmdlRnJvbVsyXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlRWxlbWVudCA9IGZsYXR0ZW5UeHRFbGVtLmdldChmcm9tSWR4LTEpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGVsZW1Uby50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJDb250ZW50ID0gZWxlbVRvLnNvdXJjZS5zdWJzdHJpbmcocmFuZ2VUb1syXSk7XG4gICAgICAgICAgICAgICAgICAgIGVuZFRleHROZWVkV3JhcCA9IGVsZW1Uby5uZWVkV3JhcDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZnRlckVsZW1lbnQgPSBmbGF0dGVuVHh0RWxlbS5nZXQodG9JZHgtMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYocHJlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBmbGF0dGVuVHh0RWxlbS5zcGxpY2UoZnJvbUlkeCwgdG9JZHgtZnJvbUlkeCsxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYocHJlRWxlbWVudC50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHByZUVsZW1lbnQubmVlZFdyYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbV9pZHggLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IHByZUVsZW1lbnQuc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZUVsZW1lbnQuc2V0U291cmNlV2l0aFJlY29yZChwcmVFbGVtZW50LnNvdXJjZSArIGFmdGVyQ29udGVudCwgZWRpdG9yLnNwYWNlSG9sZGVyLCByZWNvcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZUVsZW1lbnQuc2V0TmVlZFdyYXAoZW5kVGV4dE5lZWRXcmFwLCByZWNvcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBuZXcgVGV4dEVsZW1lbnQoJ3RleHQnLCBwcmVDb250ZW50ICsgYWZ0ZXJDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuc2V0TmVlZFdyYXAoZW5kVGV4dE5lZWRXcmFwLCByZWNvcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5UeHRFbGVtLnNwbGljZShmcm9tSWR4LCAwLCB0KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhdHRlblR4dEVsZW0uc3BsaWNlKGZyb21JZHgsIHRvSWR4LWZyb21JZHgpO1xuICAgICAgICAgICAgICAgICAgICBpZihhZnRlckVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBuZXcgVGV4dEVsZW1lbnQoJ3RleHQnLCBwcmVDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5UeHRFbGVtLnNwbGljZShmcm9tSWR4LCAwLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1Uby5zZXRTb3VyY2VXaXRoUmVjb3JkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZUNvbnRlbnQgKyBhZnRlckNvbnRlbnQsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5zcGFjZUhvbGRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihmbGF0dGVuVHh0RWxlbS5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbGVtX2lkeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5UeHRFbGVtLnB1c2gobmV3IFRleHRFbGVtZW50KCd0ZXh0JywgJycpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYXJldC5zZXRSb3cocm93KTtcbiAgICAgICAgICAgIGNhcmV0LnNldENvbHVtbihbZWxlbV9pZHgsIG9mZnNldF0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgUmFuZ2U7IiwiXG5mdW5jdGlvbiBpc1NldFNvdXJjZUJhdGNoKHgpIHtcbiAgICByZXR1cm4geC5sZW5ndGggPT09IDEgJiYgeFswXS5vcCA9PT0gJ3NldFNvdXJjZSc7XG59XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVbmRvUmVkbyB7XG4gICAgc3RhdGljIF9sZW5ndGggPSA1MDtcbiAgICBfdW5kbyA9IFtdO1xuICAgIF9yZWRvID0gW107XG4gICAgX2VkaXRvciA9IG51bGw7XG5cbiAgICB3cml0ZSh4LCBjYXJldFJlY29yZCkge1xuICAgICAgICBpZih4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmKGlzU2V0U291cmNlQmF0Y2goeCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB4WzBdO1xuICAgICAgICAgICAgY29uc3QgbGFzdFVuZG8gPSB0aGlzLmdldExhc3RVbmRvKCk7XG4gICAgICAgICAgICBpZihsYXN0VW5kbyAmJiBpc1NldFNvdXJjZUJhdGNoKGxhc3RVbmRvLl9iYXRjaCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBxID0gbGFzdFVuZG8uX2JhdGNoWzBdO1xuICAgICAgICAgICAgICAgIGlmKHEuYXJnc1swXSA9PT0gdC5hcmdzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHEuYXJnc1sxXSA9IHQuYXJnc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFVuZG8uX2NhcmV0TWV0YVRvID0gY2FyZXRSZWNvcmQuYWZ0ZXI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgciA9IG5ldyBCYXRjaEFjdGlvbih4KTtcbiAgICAgICAgci5fY2FyZXRNZXRhRnJvbSA9IGNhcmV0UmVjb3JkLmJlZm9yZTtcbiAgICAgICAgci5fY2FyZXRNZXRhVG8gPSBjYXJldFJlY29yZC5hZnRlcjtcbiAgICAgICAgdGhpcy5fdW5kby5wdXNoKHIpO1xuICAgICAgICBcbiAgICAgICAgaWYodGhpcy5fdW5kby5sZW5ndGggPiBVbmRvUmVkby5fbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl91bmRvLnNwbGljZSgwLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLl9yZWRvLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fcmVkbyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0TGFzdFVuZG8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91bmRvW3RoaXMuX3VuZG8ubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgdW5kbygpIHtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuX3VuZG8ucG9wKCk7XG4gICAgICAgIGlmKHgpIHtcbiAgICAgICAgICAgIHgudW5kbyh0aGlzLl9lZGl0b3IpXG4gICAgICAgICAgICB0aGlzLl9yZWRvLnB1c2goeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgcmVkbygpIHtcbiAgICAgICAgbGV0IHggPSB0aGlzLl9yZWRvLnBvcCgpO1xuICAgICAgICB3aGlsZSh4ICYmIHguU0tJUF9SRURPKSB7XG4gICAgICAgICAgICB4ID0gdGhpcy5fcmVkby5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpZih4KSB7XG4gICAgICAgICAgICB4LnJlZG8odGhpcy5fZWRpdG9yKVxuICAgICAgICAgICAgdGhpcy5fdW5kby5wdXNoKHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbn1cblxuY2xhc3MgQmF0Y2hBY3Rpb24ge1xuICAgIF9iYXRjaCA9IFtdO1xuICAgIF9jYXJldE1ldGFGcm9tID0gbnVsbDtcbiAgICBfY2FyZXRNZXRhVG8gPSBudWxsO1xuICAgIGNvbnN0cnVjdG9yKGJhdGNoKSB7XG4gICAgICAgIHRoaXMuX2JhdGNoID0gYmF0Y2g7XG4gICAgfVxuXG4gICAgdXBkYXRlQ2FyZXRNZXRhVG8obWV0YSkge1xuICAgICAgICB0aGlzLl9jYXJldE1ldGFUbyA9IG1ldGE7XG4gICAgfVxuXG4gICAgdW5kbyhlZGl0b3IpIHtcbiAgICAgICAgdGhpcy5fYmF0Y2guc2xpY2UoKS5yZXZlcnNlKCkuZm9yRWFjaChhY3Rpb24gPT4ge1xuICAgICAgICAgICAgc3dpdGNoKGFjdGlvbi5vcCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JhbmdlJzpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW3JhbmdlRnJvbSwgcmFuZ2VUb10gPSBhY3Rpb24uYXJncztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBlZGl0b3IuX3JhbmdlO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRJbml0aWFsUmFuZ2UocmFuZ2VGcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0UmFuZ2UocmFuZ2VUbyk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzZXRTb3VyY2UnOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbZWxlbSwgcywgbHNdID0gYWN0aW9uLmFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0U291cmNlKGxzLCBlZGl0b3Iuc3BhY2VIb2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzZXROZWVkV3JhcCc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtvLCBwLCBxXSA9IGFjdGlvbi5hcmdzO1xuICAgICAgICAgICAgICAgICAgICBvLm5lZWRXcmFwID0gcTtcbiAgICAgICAgICAgICAgICAgICAgby5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZsYXR0ZW5UeHRFbGVtID0gZWRpdG9yLl9mbGF0dGVuVHh0RWxlbTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2EsIGIsIC4uLmNdID0gYWN0aW9uLmFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW92ZWQgPSBhY3Rpb24ucmVtb3ZlZDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSAwXG4gICAgICAgICAgICAgICAgICAgIGlmKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBjLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5UeHRFbGVtLnNwbGljZShhLCBpLCAuLi5yZW1vdmVkKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVkaXRvci5fY2FyZXQuZnJvbVJhbmdlKHRoaXMuX2NhcmV0TWV0YUZyb20pO1xuICAgIH1cblxuICAgIHJlZG8oZWRpdG9yKSB7XG4gICAgICAgIHRoaXMuX2JhdGNoLmZvckVhY2goYWN0aW9uID0+IHtcbiAgICAgICAgICAgIHN3aXRjaChhY3Rpb24ub3ApIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzZXRTb3VyY2UnOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbZWxlbSwgcywgbHNdID0gYWN0aW9uLmFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0U291cmNlKHMsIGVkaXRvci5zcGFjZUhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NldE5lZWRXcmFwJzpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW28sIHAsIHFdID0gYWN0aW9uLmFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIG8ubmVlZFdyYXAgPSBwO1xuICAgICAgICAgICAgICAgICAgICBvLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmxhdHRlblR4dEVsZW0gPSBlZGl0b3IuX2ZsYXR0ZW5UeHRFbGVtO1xuICAgICAgICAgICAgICAgICAgICBmbGF0dGVuVHh0RWxlbS5zcGxpY2UoLi4uYWN0aW9uLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgZWRpdG9yLl9jYXJldC5mcm9tUmFuZ2UodGhpcy5fY2FyZXRNZXRhVG8pO1xuICAgIH1cbn0iLCJjbGFzcyBDb21tYW5kIHtcbiAgICBzdGF0aWMgY3JlYXRlKGVkaXRvcikge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoZWRpdG9yKVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgICAgICB0aGlzLl9lZGl0b3IgPSBlZGl0b3I7XG4gICAgfVxuXG4gICAgZXhlYygpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbW1hbmQ7IiwiaW1wb3J0IENvbW1hbmQgZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7IEtFWUJPQVJEX0NPTU1BTkRTIH0gZnJvbSAnLi4vYmFzZS9jb25zdGFudHMnO1xuXG5leHBvcnQgY2xhc3MgQXJyb3dMZWZ0Q29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICAgIHN0YXRpYyBfbmFtZSA9IEtFWUJPQVJEX0NPTU1BTkRTLkFSUk9XX0xFRlQ7XG5cbiAgICBleGVjKCkge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLl9lZGl0b3I7XG4gICAgICAgIGVkaXRvci5fcmFuZ2UuZGlzYWJsZSgpO1xuICAgICAgICBjb25zdCBmbGF0dGVuVHh0RWxlbSA9IGVkaXRvci5fZmxhdHRlblR4dEVsZW1cbiAgICAgICAgY29uc3QgY2FyZXQgPSBlZGl0b3IuX2NhcmV0O1xuICAgICAgICBjb25zdCByb3cgPSBjYXJldC5nZXRSb3coKTtcbiAgICAgICAgY29uc3QgY29sdW1uID0gY2FyZXQuZ2V0Q29sdW1uKCk7XG4gICAgICAgIGNvbnN0IFtlbGVtaWR4LCBvZmZzZXRdID0gY29sdW1uO1xuICAgICAgICBjb25zdCBsaW5lID0gZWRpdG9yLl9hcmVhLmdldChyb3cpO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gbGluZS5nZXQoZWxlbWlkeCk7XG4gICAgICAgIGNvbnN0IGlkeCA9IGZsYXR0ZW5UeHRFbGVtLmZpbmRJbmRleChlbGVtZW50KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZWxlbWVudC5zaGlmdChvZmZzZXQsIC0xKTtcbiAgICAgICAgc3dpdGNoKHJlc3VsdCkge1xuICAgICAgICAgICAgY2FzZSAncHJldic6XG4gICAgICAgICAgICAgICAgaWYoZWxlbWlkeCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWwgPSBsaW5lLmdldChlbGVtaWR4IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGNhcmV0LnNldENvbHVtbihbZWxlbWlkeCAtIDEsIGVsLnRhaWxPZmZzZXQoKV0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKGlkeCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlUm93ID0gcm93IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlRWxlbWlkeCA9IGVkaXRvci5fYXJlYS5nZXQocHJlUm93KS5sZW5ndGgoKSAtIDFcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZmxhdHRlblR4dEVsZW0uZ2V0KGlkeC0xKS50YWlsT2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNhcmV0LnNldFJvdyhwcmVSb3cpO1xuICAgICAgICAgICAgICAgICAgICBjYXJldC5zZXRDb2x1bW4oW3ByZUVsZW1pZHgsIG9mZnNldF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlbGYnOlxuICAgICAgICAgICAgICAgIGNhcmV0LnNldENvbHVtbigxLCBvZmZzZXQgLSAxKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhcmV0LnJlZnJlc2goKTtcbiAgICAgICAgZWRpdG9yLnN5bmNTaGFkb3dJbnB1dFBvc2l0aW9uKCk7XG4gICAgICAgIGVkaXRvci5famZsb3cuX3JlbmRlcigpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBcnJvd1JpZ2h0Q29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICAgIHN0YXRpYyBfbmFtZSA9IEtFWUJPQVJEX0NPTU1BTkRTLkFSUk9XX1JJR0hUO1xuXG4gICAgZXhlYygpIHtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5fZWRpdG9yO1xuICAgICAgICBlZGl0b3IuX3JhbmdlLmRpc2FibGUoKTtcbiAgICAgICAgY29uc3QgZmxhdHRlblR4dEVsZW0gPSBlZGl0b3IuX2ZsYXR0ZW5UeHRFbGVtXG4gICAgICAgIGNvbnN0IGNhcmV0ID0gZWRpdG9yLl9jYXJldDtcbiAgICAgICAgY29uc3Qgcm93ID0gY2FyZXQuZ2V0Um93KCk7XG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IGNhcmV0LmdldENvbHVtbigpO1xuICAgICAgICBjb25zdCBbZWxlbWlkeCwgb2Zmc2V0XSA9IGNvbHVtbjtcbiAgICAgICAgY29uc3QgbGluZSA9IGVkaXRvci5fYXJlYS5nZXQocm93KTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGxpbmUuZ2V0KGVsZW1pZHgpO1xuICAgICAgICBjb25zdCBpZHggPSBmbGF0dGVuVHh0RWxlbS5maW5kSW5kZXgoZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGVsZW1lbnQuc2hpZnQob2Zmc2V0LCAxLCBpZHggPT09IGZsYXR0ZW5UeHRFbGVtLmxlbmd0aCgpLTEpO1xuICAgICAgICBzd2l0Y2gocmVzdWx0KSB7XG4gICAgICAgICAgICBjYXNlICduZXh0JzpcbiAgICAgICAgICAgICAgICBpZihlbGVtaWR4IDwgbGluZS5sZW5ndGgoKS0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gbGluZS5nZXQoZWxlbWlkeCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZihlbGVtZW50LnR5cGUgPT09ICd0ZXh0JyAmJiBlbC50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0LnNldENvbHVtbihbZWxlbWlkeCArIDIsIGVsLmhlYWRPZmZzZXQoKV0pXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldC5zZXRDb2x1bW4oW2VsZW1pZHggKyAxLCBlbC5oZWFkT2Zmc2V0KCldKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKGlkeCA8IGZsYXR0ZW5UeHRFbGVtLmxlbmd0aCgpLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWZ0ZXJSb3cgPSByb3cgKyAxO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBmbGF0dGVuVHh0RWxlbS5nZXQoaWR4ICsgMSkuaGVhZE9mZnNldCgpO1xuICAgICAgICAgICAgICAgICAgICBjYXJldC5zZXRSb3coYWZ0ZXJSb3cpO1xuICAgICAgICAgICAgICAgICAgICBjYXJldC5zZXRDb2x1bW4oWzAsIG9mZnNldF0pO1xuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlbGYnOlxuICAgICAgICAgICAgICAgIGNhcmV0LnNldENvbHVtbigxLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNhcmV0LnJlZnJlc2goKTtcbiAgICAgICAgZWRpdG9yLnN5bmNTaGFkb3dJbnB1dFBvc2l0aW9uKCk7XG4gICAgICAgIGVkaXRvci5famZsb3cuX3JlbmRlcigpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBcnJvd1VwQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICAgIHN0YXRpYyBfbmFtZSA9IEtFWUJPQVJEX0NPTU1BTkRTLkFSUk9XX1VQO1xuXG4gICAgZXhlYygpIHtcbiAgICAgICAgdGhpcy5fZWRpdG9yLl9yYW5nZS5kaXNhYmxlKCk7XG4gICAgICAgIGNvbnN0IG5leHRSb3cgPSB0aGlzLl9lZGl0b3IuX2NhcmV0LmdldFJvdygpIC0gMTtcbiAgICAgICAgaWYobmV4dFJvdyA+IC0xKXtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIobmV4dFJvdyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQXJyb3dEb3duQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICAgIHN0YXRpYyBfbmFtZSA9IEtFWUJPQVJEX0NPTU1BTkRTLkFSUk9XX0RPV047XG5cbiAgICBleGVjKCkge1xuICAgICAgICB0aGlzLl9lZGl0b3IuX3JhbmdlLmRpc2FibGUoKTtcbiAgICAgICAgY29uc3QgbmV4dFJvdyA9IHRoaXMuX2VkaXRvci5fY2FyZXQuZ2V0Um93KCkgKyAxO1xuICAgICAgICBpZihuZXh0Um93IDwgdGhpcy5fZWRpdG9yLl9hcmVhLmxlbmd0aCgpKXtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIobmV4dFJvdyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBfbWl4aW4gPSB7XG4gICAgX2hhbmRsZXIobmV4dFJvdykge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLl9lZGl0b3I7XG4gICAgICAgIGNvbnN0IGNhcmV0ID0gZWRpdG9yLl9jYXJldDtcbiAgICAgICAgY29uc3Qgcm93ID0gY2FyZXQuZ2V0Um93KCk7XG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IGNhcmV0LmdldENvbHVtbigpO1xuICAgICAgICBjb25zdCBbZWxlbWlkeCwgb2Zmc2V0XSA9IGNvbHVtbjtcbiAgICAgICAgY29uc3QgYXJlYSA9IGVkaXRvci5fYXJlYTtcbiAgICAgICAgY29uc3QgbGluZSA9IGFyZWEuZ2V0KHJvdyk7XG4gICAgICAgIGxldCBjdXJyRWxlbSA9IGxpbmUuZ2V0KGVsZW1pZHgpO1xuICAgICAgICBsZXQgY3VyckVsZW1SZWR1Y2VXaWR0aCA9IGN1cnJFbGVtLnJlZHVjZVdpZHRoO1xuICAgICAgICBpZihvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBjdXJyRWxlbVJlZHVjZVdpZHRoICs9IGVkaXRvci5tZWFzdXJlVGV4dFdpZHRoKGN1cnJFbGVtLmdldFJlbmRlclNvdXJjZShlZGl0b3Iuc3BhY2VIb2xkZXIpLnN1YnN0cmluZygwLCBvZmZzZXQpKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBuZXh0TGluZSA9IGFyZWEuZ2V0KG5leHRSb3cpO1xuICAgICAgICBjb25zdCBuZXh0Q29sdW1uID0gbmV4dExpbmUuZ2V0Q29sdW1uTmVhcmVzdChjdXJyRWxlbVJlZHVjZVdpZHRoLCBlZGl0b3IuZWxlbWVudFNwYWNlLCBlZGl0b3IuZm9udFNpemUsIGVkaXRvci5mb250RmFtaWx5LCBlZGl0b3IpXG4gICAgICAgIGNhcmV0LnNldFJvdyhuZXh0Um93KTtcbiAgICAgICAgY2FyZXQuc2V0Q29sdW1uKG5leHRDb2x1bW4pO1xuICAgICAgICBcbiAgICAgICAgY2FyZXQucmVmcmVzaCgpO1xuICAgICAgICBlZGl0b3Iuc3luY1NoYWRvd0lucHV0UG9zaXRpb24oKTtcbiAgICAgICAgZWRpdG9yLl9qZmxvdy5fcmVuZGVyKCk7XG4gICAgfVxufVxuXG5PYmplY3QuYXNzaWduKEFycm93VXBDb21tYW5kLnByb3RvdHlwZSwgX21peGluKTtcbk9iamVjdC5hc3NpZ24oQXJyb3dEb3duQ29tbWFuZC5wcm90b3R5cGUsIF9taXhpbik7IiwiaW1wb3J0IENvbW1hbmQgZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7IFRleHRFbGVtZW50IH0gZnJvbSAnLi4vc3RvcmFnZSc7XG5pbXBvcnQgeyBFRElUT1JfRVZFTlRTLCBLRVlCT0FSRF9JTlBVVCB9IGZyb20gJy4uL2Jhc2UvY29uc3RhbnRzJztcbmZ1bmN0aW9uIF9ibGFuZEFkamFjZW50RWxlbWVudChlZGl0b3IsIGVsZW0xLCBlbGVtMiwgZGVmYXVsdE9mZnNldCwgcmVjb3Jkcykge1xuICAgIGlmKCFlbGVtMSkge1xuICAgICAgICByZXR1cm4gW2RlZmF1bHRPZmZzZXQsIGZhbHNlXTtcbiAgICB9XG4gICAgaWYoZWxlbTEudHlwZSA9PT0gJ3RleHQnICYmIGVsZW0yLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBlbGVtMS5zb3VyY2UubGVuZ3RoO1xuICAgICAgICBlbGVtMS5zZXRTb3VyY2VXaXRoUmVjb3JkKGVsZW0xLnNvdXJjZSArIGVsZW0yLnNvdXJjZSwgZWRpdG9yLnNwYWNlSG9sZGVyLCByZWNvcmRzKTtcbiAgICAgICAgZWxlbTEuc2V0TmVlZFdyYXAoZWxlbTIubmVlZFdyYXAsIHJlY29yZHMpXG4gICAgICAgIHJldHVybiBbb2Zmc2V0LCB0cnVlXTtcbiAgICB9XG4gICAgcmV0dXJuIFtkZWZhdWx0T2Zmc2V0LCBmYWxzZV07XG59XG5cbmV4cG9ydCBjbGFzcyBJbnB1dCBleHRlbmRzIENvbW1hbmQge1xuICAgIHN0YXRpYyBfbmFtZSA9IEVESVRPUl9FVkVOVFMuSU5QVVQ7XG5cbiAgICBjYWNoZUlkeCA9IG51bGw7XG5cbiAgICBleGVjKGtpbmQsIGRhdGEpIHtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5fZWRpdG9yO1xuICAgICAgICBjb25zdCByYW5nZSA9IGVkaXRvci5fcmFuZ2U7XG4gICAgICAgIGNvbnN0IGNhcmV0ID0gZWRpdG9yLl9jYXJldDtcbiAgICAgICAgY29uc3QgZmxhdHRlblR4dEVsZW0gPSBlZGl0b3IuX2ZsYXR0ZW5UeHRFbGVtO1xuICAgICAgICBjb25zdCB1bmRvcmVkbyA9IGVkaXRvci5fdW5kb3JlZG87XG4gICAgICAgIGNvbnN0IHJlY29yZHMgPSBmbGF0dGVuVHh0RWxlbS5zdGFydFJlY29yZCgpO1xuICAgICAgICBmbGF0dGVuVHh0RWxlbS5yZWNvcmRCZWZvcmVDYXJldChjYXJldCk7XG4gICAgICAgIC8vIGxldCBfYWZ0ZXJSYW5nZURlbGV0ZSA9IGZhbHNlO1xuICAgICAgICBpZihyYW5nZS5pc0VuYWJsZSgpKSB7XG4gICAgICAgICAgICByYW5nZS5kZWxldGUoZWRpdG9yLCByZWNvcmRzKTtcbiAgICAgICAgICAgIGlmKGtpbmQgPT09IEtFWUJPQVJEX0lOUFVULkJBQ0tTUEFDRSB8fCBraW5kID09PSBLRVlCT0FSRF9JTlBVVC5ERUxFVEUpIHtcbiAgICAgICAgICAgICAgICBmbGF0dGVuVHh0RWxlbS5jb2xsZWN0UmVjb3JkcygpO1xuICAgICAgICAgICAgICAgIGZsYXR0ZW5UeHRFbGVtLnJlY29yZEFmdGVyQ2FyZXQoY2FyZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VkaXRvci5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgdW5kb3JlZG8ud3JpdGUocmVjb3JkcywgZmxhdHRlblR4dEVsZW0uZ2V0Q2FyZXRSZWNvcmQoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lZGl0b3IucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIC8vIF9hZnRlclJhbmdlRGVsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3Qgcm93ID0gY2FyZXQuZ2V0Um93KCk7XG4gICAgICAgIGxldCBbZWxlbV9pZHgsIG9mZnNldF0gPSBjYXJldC5nZXRDb2x1bW4oKTtcbiAgICAgICAgY29uc3QgYXJlYSA9IGVkaXRvci5fYXJlYTtcbiAgICAgICAgY29uc3QgbGluZSA9IGFyZWEuZ2V0KHJvdyk7XG4gICAgICAgIGxldCBlbGVtZW50ID0gbGluZS5nZXQoZWxlbV9pZHgpO1xuICAgICAgICBsZXQgcHJlRWxlbSA9IGxpbmUuZ2V0KGVsZW1faWR4LTEpO1xuICAgICAgICBcbiAgICAgICAgbGV0IGNvbnRlbnQgPSAnJztcbiAgICAgICAgaWYoZWxlbWVudC50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBlbGVtZW50LnNvdXJjZTtcbiAgICAgICAgfSBlbHNlIGlmKHByZUVsZW0/LnR5cGUgPT09J3RleHQnKXtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBwcmVFbGVtLnNvdXJjZTtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBwcmVFbGVtO1xuICAgICAgICAgICAgb2Zmc2V0ID0gY29udGVudC5sZW5ndGg7XG4gICAgICAgICAgICBlbGVtX2lkeCAtPSAxO1xuICAgICAgICAgICAgY2FyZXQuc2V0Q29sdW1uKFtlbGVtX2lkeCwgY29udGVudC5sZW5ndGhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBuZXcgVGV4dEVsZW1lbnQoJ3RleHQnLCAnJyk7XG4gICAgICAgICAgICBmbGF0dGVuVHh0RWxlbS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgbmV3RWxlbWVudCk7XG4gICAgICAgICAgICBlbGVtZW50ID0gbmV3RWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwcmVDb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcoMCwgb2Zmc2V0KTtcbiAgICAgICAgbGV0IGFmdGVyQ29udGVudCBcbiAgICAgICAgaWYodGhpcy5jYWNoZUlkeCkge1xuICAgICAgICAgICAgYWZ0ZXJDb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcodGhpcy5jYWNoZUlkeFsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZnRlckNvbnRlbnQgPSBjb250ZW50LnN1YnN0cmluZyhvZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoKGtpbmQpe1xuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9JTlBVVC5JTlBVVDpcbiAgICAgICAgICAgICAgICAvLyBpZihfYWZ0ZXJSYW5nZURlbGV0ZSkge1xuICAgICAgICAgICAgICAgIC8vICAgICBlbGVtZW50ID0gZmxhdHRlblR4dEVsZW0uZ2V0KDApO1xuICAgICAgICAgICAgICAgIC8vICAgICBhZnRlckNvbnRlbnQgPSAnJztcbiAgICAgICAgICAgICAgICAvLyAgICAgcHJlQ29udGVudCA9ICcnO1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZigvXFxyP1tcXG5cXHRdLy50ZXN0KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByb3dzID0gZGF0YS5zcGxpdCgvXFxyP1tcXG5cXHRdLykgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKC9cXHQvLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IGZsYXR0ZW5UeHRFbGVtLmZpbmRJbmRleChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdE5lZWRXcmFwID0gZWxlbWVudC5uZWVkV3JhcDtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZXRTb3VyY2VXaXRoUmVjb3JkKHByZUNvbnRlbnQgKyByb3dzLnNoaWZ0KCksIGVkaXRvci5zcGFjZUhvbGRlciwgcmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0TmVlZFdyYXAodHJ1ZSwgcmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRuO1xuICAgICAgICAgICAgICAgICAgICBsZXQgX3JvdyA9IHJvdztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUocm93cy5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG4gPSBuZXcgVGV4dEVsZW1lbnQoJ3RleHQnLCByb3dzLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG4ubmVlZFdyYXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcC5wdXNoKHRuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yb3crKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb2wgPSB0bi5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0bi5zb3VyY2UgKz0gYWZ0ZXJDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICB0bi5uZWVkV3JhcCA9IGxhc3ROZWVkV3JhcDtcbiAgICAgICAgICAgICAgICAgICAgdGVtcC5mb3JFYWNoKCh0LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGF0dGVuVHh0RWxlbS5pbmVyc2V0QXQoaWR4ICsgMSArIGksIHQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2FyZXQuc2V0Um93KF9yb3cpO1xuICAgICAgICAgICAgICAgICAgICBjYXJldC5zZXRDb2x1bW4oWzAsIGNvbF0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlQ29udGVudCArPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICBjYXJldC5zZXRDb2x1bW4oMSwgY2FyZXQuZ2V0Q29sdW1uKDEpICsgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNldFNvdXJjZVdpdGhSZWNvcmQocHJlQ29udGVudCArIGFmdGVyQ29udGVudCwgZWRpdG9yLnNwYWNlSG9sZGVyLCByZWNvcmRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0lOUFVULkNPTVBPU0lUSU9OX1NUQVJUOlxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVJZHggPSBbcHJlQ29udGVudC5sZW5ndGgsIHByZUNvbnRlbnQubGVuZ3RoXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfSU5QVVQuQ09NUE9TSVRJT05fVVBEQVRFOlxuICAgICAgICAgICAgICAgIHByZUNvbnRlbnQgPSBwcmVDb250ZW50LnN1YnN0cmluZygwLCB0aGlzLmNhY2hlSWR4WzBdKTtcbiAgICAgICAgICAgICAgICBwcmVDb250ZW50ICs9IGRhdGE7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRTb3VyY2VXaXRoUmVjb3JkKHByZUNvbnRlbnQgKyBhZnRlckNvbnRlbnQsIGVkaXRvci5zcGFjZUhvbGRlciwgcmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgX3QgPSB0aGlzLmNhY2hlSWR4WzBdICsgZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY2FyZXQuc2V0Q29sdW1uKDEsIF90KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlSWR4WzFdID0gX3Q7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0lOUFVULkNPTVBPU0lUSU9OX0VORDpcbiAgICAgICAgICAgICAgICBwcmVDb250ZW50ID0gcHJlQ29udGVudC5zdWJzdHJpbmcoMCwgdGhpcy5jYWNoZUlkeFswXSk7XG4gICAgICAgICAgICAgICAgY2FyZXQuc2V0Q29sdW1uKDEsIHRoaXMuY2FjaGVJZHhbMF0gKyBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZUlkeCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcHJlQ29udGVudCArPSBkYXRhO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0U291cmNlV2l0aFJlY29yZChwcmVDb250ZW50ICsgYWZ0ZXJDb250ZW50LCBlZGl0b3Iuc3BhY2VIb2xkZXIsIHJlY29yZHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9JTlBVVC5FTlRFUjpcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0TmVlZFdyYXAgPSBlbGVtZW50Lm5lZWRXcmFwO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0U291cmNlV2l0aFJlY29yZChwcmVDb250ZW50LCBlZGl0b3Iuc3BhY2VIb2xkZXIsIHJlY29yZHMpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0TmVlZFdyYXAodHJ1ZSwgcmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IG5ldyBUZXh0RWxlbWVudCgndGV4dCcsIGFmdGVyQ29udGVudCk7XG4gICAgICAgICAgICAgICAgZmxhdHRlblR4dEVsZW0uaW5zZXJ0QWZ0ZXIoZWxlbWVudCwgdCwgbGFzdE5lZWRXcmFwKTtcbiAgICAgICAgICAgICAgICBjYXJldC5zZXRSb3cocm93KzEpO1xuICAgICAgICAgICAgICAgIGNhcmV0LnNldENvbHVtbihbMCwgMF0pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfSU5QVVQuQkFDS1NQQUNFOlxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGVsZW1lbnQuc2hpZnQob2Zmc2V0LCAtMSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdwcmV2JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpZHggPSBmbGF0dGVuVHh0RWxlbS5maW5kSW5kZXgoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihlbGVtX2lkeCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDooYzlhoVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGF0dGVuVHh0RWxlbS5zcGxpY2UoaWR4LTEsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQuc2V0U291cmNlKGFmdGVyQ29udGVudCwgcmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxlbWVudC5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW29mZnNldCwgZGVsZXRlb3BdID0gX2JsYW5kQWRqYWNlbnRFbGVtZW50KGVkaXRvciwgZmxhdHRlblR4dEVsZW0uZ2V0KGlkeC0xKSwgZWxlbWVudCwgMCwgcmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGVsZXRlb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhdHRlblR4dEVsZW0ucmVtb3ZlKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0LnNldENvbHVtbihbZWxlbV9pZHggLSAoKG9mZnNldCA+IDAgfHwgZGVsZXRlb3ApPzI6MSksIG9mZnNldF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoaWR4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOaNouihjOS6hlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZVJvdyA9IHJvdyAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlRWxlbWlkeCA9IGFyZWEuZ2V0KHByZVJvdykubGVuZ3RoKCkgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtvZmZzZXQsIGRlbGV0ZW9wXSA9IF9ibGFuZEFkamFjZW50RWxlbWVudChlZGl0b3IsIGZsYXR0ZW5UeHRFbGVtLmdldChpZHgtMSksIGVsZW1lbnQsIDAsIHJlY29yZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRlbGV0ZW9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5UeHRFbGVtLnJlbW92ZShpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldC5zZXRSb3cocHJlUm93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldC5zZXRDb2x1bW4oW3ByZUVsZW1pZHgsIG9mZnNldF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlbGYnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlQ29udGVudCA9IHByZUNvbnRlbnQuc3Vic3RyaW5nKDAsIHByZUNvbnRlbnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldC5zZXRDb2x1bW4oMSwgY2FyZXQuZ2V0Q29sdW1uKDEpLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNldFNvdXJjZVdpdGhSZWNvcmQocHJlQ29udGVudCArIGFmdGVyQ29udGVudCwgZWRpdG9yLnNwYWNlSG9sZGVyLCByZWNvcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfSU5QVVQuREVMRVRFOlxuICAgICAgICAgICAgICAgIGNvbnN0IHNoaWZ0cmVzdWx0ID0gZWxlbWVudC5zaGlmdChvZmZzZXQsIDEpO1xuICAgICAgICAgICAgICAgIHN3aXRjaChzaGlmdHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICduZXh0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpZHggPSBmbGF0dGVuVHh0RWxlbS5maW5kSW5kZXgoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihlbGVtX2lkeCA8IGxpbmUubGVuZ3RoKCktMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOihjOWGhVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5UeHRFbGVtLnNwbGljZShpZHgrMSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dEVsZW0gPSBmbGF0dGVuVHh0RWxlbS5nZXQoaWR4KzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtvZmZzZXQsIGRlbGV0ZW9wXSA9IF9ibGFuZEFkamFjZW50RWxlbWVudChlbGVtZW50LCBuZXh0RWxlbSwgZWxlbWVudC5zb3VyY2UubGVuZ3RoLCByZWNvcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihkZWxldGVvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGF0dGVuVHh0RWxlbS5yZW1vdmUoaWR4KzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldC5zZXRDb2x1bW4oW2VsZW1faWR4LCBvZmZzZXRdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKGlkeCA8IGZsYXR0ZW5UeHRFbGVtLmxlbmd0aCgpLTEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOaNouihjOS6hlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRFbGVtID0gZmxhdHRlblR4dEVsZW0uZ2V0KGlkeCsxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbb2Zmc2V0LCBkZWxldGVvcF0gPSBfYmxhbmRBZGphY2VudEVsZW1lbnQoZWxlbWVudCwgbmV4dEVsZW0sIGVsZW1lbnQuc291cmNlLmxlbmd0aCwgcmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGVsZXRlb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhdHRlblR4dEVsZW0ucmVtb3ZlKGlkeCsxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXQuc2V0Q29sdW1uKFtlbGVtX2lkeCwgb2Zmc2V0XSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZWxmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyQ29udGVudCA9IGFmdGVyQ29udGVudC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNldFNvdXJjZVdpdGhSZWNvcmQocHJlQ29udGVudCArIGFmdGVyQ29udGVudCwgZWRpdG9yLnNwYWNlSG9sZGVyLCByZWNvcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGZsYXR0ZW5UeHRFbGVtLmNvbGxlY3RSZWNvcmRzKCk7XG4gICAgICAgIGZsYXR0ZW5UeHRFbGVtLnJlY29yZEFmdGVyQ2FyZXQoY2FyZXQpO1xuICAgICAgICB1bmRvcmVkby53cml0ZShyZWNvcmRzLCBmbGF0dGVuVHh0RWxlbS5nZXRDYXJldFJlY29yZCgpKTtcbiAgICAgICAgdGhpcy5fZWRpdG9yLnJlZnJlc2goKTtcbiAgICB9XG5cbiAgICBcbn0iLCJpbXBvcnQgQ29tbWFuZCBmcm9tICcuL2Jhc2UnO1xuXG5pbXBvcnQgeyBNT1VTRV9DT01NQU5EUyB9IGZyb20gJy4uL2Jhc2UvY29uc3RhbnRzJztcbmltcG9ydCBKRmxvd0V2ZW50IGZyb20gJy4uLy4uLy4uL2V2ZW50cy9pbmRleCc7XG5cbmV4cG9ydCBjbGFzcyBTdGFydEVkaXRDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gICAgc3RhdGljIF9uYW1lID0gTU9VU0VfQ09NTUFORFMuU1RBUlRfRURJVDtcblxuICAgIGV4ZWMoKSB7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuX2VkaXRvcjtcbiAgICAgICAgaWYoIXRoaXMuX3N0YXJ0RWRpdCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgamZsb3cgPSBlZGl0b3IuX2pmbG93O1xuICAgICAgICBlZGl0b3IubW92ZUNhcmV0QnlIaXRQb2ludCgpO1xuICAgICAgICBlZGl0b3IuY3JlYXRlU2hhZG93SW5wdXQoKTtcbiAgICAgICAgZWRpdG9yLl9jYXJldC5hbmltYXRlKGpmbG93KTtcbiAgICAgICAgZWRpdG9yLnN5bmNTaGFkb3dJbnB1dFBvc2l0aW9uKCk7XG4gICAgfVxuXG4gICAgX3N0YXJ0RWRpdCgpIHtcbiAgICAgICAgbGV0IGZsYWcgPSB0cnVlO1xuICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLl9lZGl0b3I7XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdlZGl0Jywge1xuICAgICAgICAgICAgdGFyZ2V0OiBlZGl0b3IsXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKSBcbiAgICAgICAgcmV0dXJuIGZsYWc7IFxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBFZGl0Q2xpY2tDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gICAgc3RhdGljIF9uYW1lID0gTU9VU0VfQ09NTUFORFMuRURJVF9DTElDSztcblxuICAgIGV4ZWMoKSB7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuX2VkaXRvcjtcbiAgICAgICAgZWRpdG9yLm1vdmVDYXJldEJ5SGl0UG9pbnQoKTtcbiAgICAgICAgZWRpdG9yLl9jYXJldC5yZWZyZXNoKCk7XG4gICAgICAgIGVkaXRvci5zeW5jU2hhZG93SW5wdXRQb3NpdGlvbigpO1xuICAgICAgICBlZGl0b3IuX3JhbmdlLmRpc2FibGUoKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEb3VibGVDbGlja0NvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgICBzdGF0aWMgX25hbWUgPSBNT1VTRV9DT01NQU5EUy5ET1VCTEVfQ0xJQ0s7XG5cbiAgICBleGVjKCkge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLl9lZGl0b3I7XG4gICAgICAgIGVkaXRvci5tb3ZlQ2FyZXRCeUhpdFBvaW50KCk7XG4gICAgICAgIGNvbnN0IGNhcmV0ID0gZWRpdG9yLl9jYXJldDtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBlZGl0b3IuX3JhbmdlO1xuICAgICAgICBjb25zdCBhcmVhID0gZWRpdG9yLl9hcmVhO1xuICAgICAgICBjb25zdCByb3cgPSBjYXJldC5nZXRSb3coKTtcbiAgICAgICAgY29uc3QgbGluZSA9IGFyZWEuZ2V0KHJvdyk7XG4gICAgICAgIGNvbnN0IGVsZW1faWR4ID0gbGluZS5sZW5ndGgoKSAtIDE7XG4gICAgICAgIHJhbmdlLnNldEluaXRpYWxSYW5nZShbcm93LCAwLCAwXSk7XG4gICAgICAgIHJhbmdlLnNldFJhbmdlKFtcbiAgICAgICAgICAgIHJvdywgZWxlbV9pZHgsIGxpbmUudGFpbCgpLnRhaWxPZmZzZXQoKVxuICAgICAgICBdKTtcbiAgICAgICAgcmFuZ2UuaGFuZGxlQ2FyZXQoY2FyZXQpO1xuICAgICAgICByYW5nZS5lbmFibGUoKTtcbiAgICAgICAgZWRpdG9yLnN5bmNTaGFkb3dJbnB1dFBvc2l0aW9uKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IENvbW1hbmQgZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7IEtFWUJPQVJEX0NPTU1BTkRTLCBNT1VTRV9DT01NQU5EUyB9IGZyb20gJy4uL2Jhc2UvY29uc3RhbnRzJztcblxuZXhwb3J0IGNsYXNzIFNoaWZ0VXBDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gICAgc3RhdGljIF9uYW1lID0gS0VZQk9BUkRfQ09NTUFORFMuU0hJRlRfVVA7XG4gICAgZXhlYygpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGlzLl9lZGl0b3IuX3JhbmdlO1xuICAgICAgICByYW5nZS5zZXRJbml0aWFsUmFuZ2UobnVsbCk7XG4gICAgICAgIHRoaXMuX2VkaXRvci50b2dnbGVTaGlmdChmYWxzZSlcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTaGlmdERvd25Db21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gICAgc3RhdGljIF9uYW1lID0gS0VZQk9BUkRfQ09NTUFORFMuU0hJRlRfRE9XTjtcbiAgICBcbiAgICBleGVjKCkge1xuICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMuX2VkaXRvci5fcmFuZ2U7XG4gICAgICAgIGNvbnN0IGNhcmV0ID0gdGhpcy5fZWRpdG9yLl9jYXJldDtcbiAgICAgICAgcmFuZ2Uuc2V0SW5pdGlhbFJhbmdlKGNhcmV0LnRvUmFuZ2UoKSk7XG4gICAgICAgIHRoaXMuX2VkaXRvci50b2dnbGVTaGlmdCh0cnVlKVxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNoaWZ0T25DbGlja0NvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgICBzdGF0aWMgX25hbWUgPSBNT1VTRV9DT01NQU5EUy5TSElGVF9PTl9DTElDSztcblxuICAgIGV4ZWMoKSB7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuX2VkaXRvcjtcbiAgICAgICAgZWRpdG9yLm1vdmVDYXJldEJ5SGl0UG9pbnQoKTtcbiAgICAgICAgY29uc3QgY2FyZXQgPSB0aGlzLl9lZGl0b3IuX2NhcmV0O1xuICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMuX2VkaXRvci5fcmFuZ2U7XG4gICAgICAgIHJhbmdlLnNldFJhbmdlKGNhcmV0LnRvUmFuZ2UoKSk7XG4gICAgICAgIHJhbmdlLmVuYWJsZSgpO1xuICAgICAgICByYW5nZS5oYW5kbGVDYXJldChjYXJldCk7XG4gICAgICAgIGNhcmV0LnJlZnJlc2goKTtcbiAgICAgICAgZWRpdG9yLnN5bmNTaGFkb3dJbnB1dFBvc2l0aW9uKCk7XG4gICAgfVxufSIsImltcG9ydCBDb21tYW5kIGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgeyBLRVlCT0FSRF9DT01NQU5EUyB9IGZyb20gJy4uL2Jhc2UvY29uc3RhbnRzJztcblxuZXhwb3J0IGNsYXNzIEN0cmxBQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICAgIHN0YXRpYyBfbmFtZSA9IEtFWUJPQVJEX0NPTU1BTkRTLkNUUkxBO1xuICAgIGV4ZWMoKSB7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuX2VkaXRvcjtcbiAgICAgICAgY29uc3QgY2FyZXQgPSBlZGl0b3IuX2NhcmV0O1xuICAgICAgICBjb25zdCByYW5nZSA9IGVkaXRvci5fcmFuZ2U7XG4gICAgICAgIGNvbnN0IGFyZWEgPSBlZGl0b3IuX2FyZWE7XG4gICAgICAgIGNvbnN0IHJvdyA9IGFyZWEubGVuZ3RoKCkgLSAxO1xuICAgICAgICBjb25zdCBsaW5lID0gYXJlYS5nZXQocm93KTtcbiAgICAgICAgY29uc3QgZWxlbV9pZHggPSBsaW5lLmxlbmd0aCgpIC0gMTtcbiAgICAgICAgcmFuZ2Uuc2V0SW5pdGlhbFJhbmdlKFswLCAwLCAwXSk7XG4gICAgICAgIHJhbmdlLnNldFJhbmdlKFtcbiAgICAgICAgICAgIHJvdywgZWxlbV9pZHgsIGxpbmUudGFpbCgpLnRhaWxPZmZzZXQoKVxuICAgICAgICBdKTtcbiAgICAgICAgcmFuZ2UuaGFuZGxlQ2FyZXQoY2FyZXQpO1xuICAgICAgICByYW5nZS5lbmFibGUoKTtcbiAgICAgICAgZWRpdG9yLnN5bmNTaGFkb3dJbnB1dFBvc2l0aW9uKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IENvbW1hbmQgZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7IEtFWUJPQVJEX0NPTU1BTkRTIH0gZnJvbSAnLi4vYmFzZS9jb25zdGFudHMnO1xuXG5leHBvcnQgY2xhc3MgVW5kb0NvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgICBzdGF0aWMgX25hbWUgPSBLRVlCT0FSRF9DT01NQU5EUy5VTkRPO1xuICAgIGV4ZWMoKSB7XG4gICAgICAgIHRoaXMuX2VkaXRvci5fcmFuZ2UuZGlzYWJsZSgpXG4gICAgICAgIHRoaXMuX2VkaXRvci5fdW5kb3JlZG8udW5kbygpO1xuICAgICAgICB0aGlzLl9lZGl0b3IucmVmcmVzaCgpO1xuXG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVkb0NvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgICBzdGF0aWMgX25hbWUgPSBLRVlCT0FSRF9DT01NQU5EUy5SRURPO1xuICAgIGV4ZWMoKSB7XG4gICAgICAgIHRoaXMuX2VkaXRvci5fcmFuZ2UuZGlzYWJsZSgpXG4gICAgICAgIHRoaXMuX2VkaXRvci5fdW5kb3JlZG8ucmVkbygpO1xuICAgICAgICB0aGlzLl9lZGl0b3IucmVmcmVzaCgpO1xuICAgIH1cbn0iLCJpbXBvcnQgQ29tbWFuZCBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHsgS0VZQk9BUkRfQ09NTUFORFMsIEVESVRPUl9FVkVOVFMsIEtFWUJPQVJEX0lOUFVUIH0gZnJvbSAnLi4vYmFzZS9jb25zdGFudHMnO1xuaW1wb3J0IEpGbG93RXZlbnQgZnJvbSAnLi4vLi4vLi4vZXZlbnRzJztcbmV4cG9ydCBjbGFzcyBDb3B5Q29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICAgIHN0YXRpYyBfbmFtZSA9IEtFWUJPQVJEX0NPTU1BTkRTLkNPUFk7XG4gICAgZXhlYyhldmVudCkge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLl9lZGl0b3I7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gZWRpdG9yLl9yYW5nZTtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHJhbmdlLmdldFJhbmdlQ29weShlZGl0b3IpO1xuICAgICAgICBpZihjb250ZW50KSB7XG4gICAgICAgICAgICBldmVudC5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ3V0Q29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICAgIHN0YXRpYyBfbmFtZSA9IEtFWUJPQVJEX0NPTU1BTkRTLkNVVDtcbiAgICBleGVjKGV2ZW50KSB7ICAgXG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuX2VkaXRvcjtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBlZGl0b3IuX3JhbmdlO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gcmFuZ2UuZ2V0UmFuZ2VDb3B5KGVkaXRvcik7XG4gICAgICAgIGlmKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LmNsaXBib2FyZERhdGEuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYocmFuZ2UuaXNFbmFibGUoKSkge1xuICAgICAgICAgICAgY29uc3QgY21kID0gZWRpdG9yLmNvbW1hbmRzLmdldChFRElUT1JfRVZFTlRTLklOUFVUKTtcbiAgICAgICAgICAgIGNtZC5leGVjKEtFWUJPQVJEX0lOUFVULkJBQ0tTUEFDRSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQYXN0ZUNvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgICBzdGF0aWMgX25hbWUgPSBLRVlCT0FSRF9DT01NQU5EUy5QQVNURTtcbiAgICBleGVjKHBhc3RlQ29udGVudCkge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLl9lZGl0b3I7XG4gICAgICAgIGlmKHBhc3RlQ29udGVudCkge1xuICAgICAgICAgICAgbGV0IF9wcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICAgICAgZWRpdG9yLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ3Bhc3RlJywge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHBhc3RlQ29udGVudCxcbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBfcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmKCFfcHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbWQgPSBlZGl0b3IuY29tbWFuZHMuZ2V0KEVESVRPUl9FVkVOVFMuSU5QVVQpO1xuICAgICAgICAgICAgICAgIGNtZC5leGVjKEtFWUJPQVJEX0lOUFVULklOUFVULCBwYXN0ZUNvbnRlbnQpOyAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuIiwiZXhwb3J0IHtcbiAgICBBcnJvd0xlZnRDb21tYW5kLCBcbiAgICBBcnJvd1JpZ2h0Q29tbWFuZCxcbiAgICBBcnJvd1VwQ29tbWFuZCxcbiAgICBBcnJvd0Rvd25Db21tYW5kXG59IGZyb20gJy4vbW92ZW1lbnQnO1xuZXhwb3J0IHsgSW5wdXQgfSBmcm9tICcuL2lucHV0JztcbmV4cG9ydCB7IFxuICAgIFN0YXJ0RWRpdENvbW1hbmQsXG4gICAgRWRpdENsaWNrQ29tbWFuZCxcbiAgICBEb3VibGVDbGlja0NvbW1hbmQsXG59IGZyb20gJy4vbW91c2UnXG5leHBvcnQge1xuICAgIFNoaWZ0RG93bkNvbW1hbmQsXG4gICAgU2hpZnRVcENvbW1hbmQsXG4gICAgU2hpZnRPbkNsaWNrQ29tbWFuZFxufSBmcm9tICcuL3NoaWZ0JztcblxuZXhwb3J0IHtcbiAgICBDdHJsQUNvbW1hbmRcbn0gZnJvbSAnLi9jdHJsJztcblxuZXhwb3J0ICB7XG4gICAgVW5kb0NvbW1hbmQsXG4gICAgUmVkb0NvbW1hbmRcbn0gZnJvbSAnLi91bmRvcmVkbyc7XG5cblxuZXhwb3J0IHtcbiAgICBDb3B5Q29tbWFuZCxcbiAgICBQYXN0ZUNvbW1hbmQsXG4gICAgQ3V0Q29tbWFuZCxcbn0gZnJvbSAnLi9jbGlwYm9hcmQnIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vbm9kZSc7XG5pbXBvcnQgU3RhY2tNaXhpbiBmcm9tICcuLi9zdGFja01peGluJztcbmltcG9ydCBMYXlvdXRNaXhpbiBmcm9tICcuLi9sYXlvdXRNaXhpbic7XG5pbXBvcnQgSkZsb3dFdmVudCBmcm9tICcuLi8uLi9ldmVudHMvaW5kZXgnO1xuaW1wb3J0IHsgcmVxdWVzdENhY2hlQ2FudmFzIH0gZnJvbSAnLi4vLi4vdXRpbHMvY2FudmFzJztcbmltcG9ydCBTaGFkb3dDYWNoZSBmcm9tICcuLi9zaGFwZXMvc2hhZG93LWNhY2hlJztcbmltcG9ydCBTaGFkb3dJbnB1dCBmcm9tICcuL2Jhc2Uvc2hhZG93LWlucHV0JztcblxuaW1wb3J0IENhcmV0IGZyb20gJy4vYmFzZS9jYXJldCc7XG5pbXBvcnQgUmFuZ2UgZnJvbSAnLi9iYXNlL3JhbmdlJztcbmltcG9ydCBVbmRvUmVkbyBmcm9tICcuL3VuZG9yZWRvJztcbmltcG9ydCB7XG4gICAgQXJlYSxcbiAgICBGbGF0dGVuVGV4dEVsZW1lbnRzLFxuICAgIExpbmUsXG4gICAgVGV4dEVsZW1lbnRcbn0gZnJvbSAnLi9zdG9yYWdlJztcblxuaW1wb3J0IHsgXG4gICAgSW5wdXQsXG4gICAgQXJyb3dMZWZ0Q29tbWFuZCxcbiAgICBBcnJvd1JpZ2h0Q29tbWFuZCxcbiAgICBBcnJvd1VwQ29tbWFuZCxcbiAgICBBcnJvd0Rvd25Db21tYW5kLFxuICAgIFN0YXJ0RWRpdENvbW1hbmQsXG4gICAgU2hpZnREb3duQ29tbWFuZCxcbiAgICBTaGlmdFVwQ29tbWFuZCxcbiAgICBTaGlmdE9uQ2xpY2tDb21tYW5kLFxuICAgIEVkaXRDbGlja0NvbW1hbmQsXG4gICAgQ3RybEFDb21tYW5kLFxuICAgIERvdWJsZUNsaWNrQ29tbWFuZCxcbiAgICAvLyBSZXR1cm5Db21tYW5kLFxuICAgIC8vIERlbGV0ZUNvbW1hbmQsXG4gICAgVW5kb0NvbW1hbmQsXG4gICAgUmVkb0NvbW1hbmQsXG4gICAgQ29weUNvbW1hbmQsXG4gICAgUGFzdGVDb21tYW5kLFxuICAgIEN1dENvbW1hbmQsXG59IGZyb20gJy4vY29tbWFuZCdcbmltcG9ydCB7IEVESVRPUl9FVkVOVFMsIEtFWUJPQVJEX0NPTU1BTkRTLCBNT1VTRV9DT01NQU5EUyB9IGZyb20gJy4vYmFzZS9jb25zdGFudHMnO1xuXG5jbGFzcyBUZXh0R3JvdXAgZXh0ZW5kcyBOb2RlIHtcblxuICAgIGdldCBjdXJyZW50TGluZUhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUhlaWdodCB8fCBwYXJzZUludCh0aGlzLmZvbnRTaXplKTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnVGV4dEdyb3VwJztcbiAgICAgICAgdGhpcy5pbml0U3RhY2soY29uZmlncyk7XG4gICAgICAgIHRoaXMuaW5pdExheW91dChjb25maWdzKTtcblxuICAgICAgICB0aGlzLl91bmRvcmVkbyA9IG5ldyBVbmRvUmVkbygpO1xuICAgICAgICB0aGlzLl91bmRvcmVkby5fZWRpdG9yID0gdGhpcztcbiAgICAgICAgdGhpcy5fY2FyZXQgPSBuZXcgQ2FyZXQoKTtcbiAgICAgICAgdGhpcy5fcmFuZ2UgPSBuZXcgUmFuZ2UoKTtcbiAgICAgICAgdGhpcy5fc2hhZG93SW5wdXQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdGhpcy50ZXh0Q29sb3IgPSBjb25maWdzLnRleHRDb2xvciB8fCAndHJhbnNwYXJlbnQnO1xuICAgICAgICB0aGlzLmZvbnRGYW1pbHkgPSBjb25maWdzLmZvbnRGYW1pbHkgfHwgJy1hcHBsZS1zeXN0ZW0sQmxpbmtNYWNTeXN0ZW1Gb250LFNlZ29lIFVJLFJvYm90byxIZWx2ZXRpY2EgTmV1ZSxIZWx2ZXRpY2EsVGFob21hLEFyaWFsLE5vdG8gU2FucyxQaW5nRmFuZyBTQyxNaWNyb3NvZnQgWWFIZWksSGlyYWdpbm8gU2FucyBHQixzYW5zLXNlcmlmLEFwcGxlIENvbG9yIEVtb2ppLFNlZ29lIFVJIEVtb2ppLFNlZ29lIFVJIFN5bWJvbCxOb3RvIENvbG9yIEVtb2ppJ1xuICAgICAgICB0aGlzLmZvbnRTaXplID0gY29uZmlncy5mb250U2l6ZSB8fCAnMjhweCc7XG4gICAgICAgIHRoaXMuZm9udFdlaWdodCA9IGNvbmZpZ3MuZm9udFdlaWdodCB8fCAnJztcbiAgICAgICAgdGhpcy5lbGVtZW50U3BhY2UgPSBjb25maWdzLmVsZW1lbnRTcGFjZSB8fCA1O1xuICAgICAgICB0aGlzLmxpbmVTcGFjZSA9IGNvbmZpZ3MubGluZVNwYWNlIHx8IDU7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBjb25maWdzLnBsYWNlaG9sZGVyIHx8ICfor7fovpPlhaUnO1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyQ29sb3IgPSBjb25maWdzLnBsYWNlaG9sZGVyQ29sb3IgfHwgJyNlZWUnO1xuICAgICAgICB0aGlzLmN1cnNvckNvbG9yID0gY29uZmlncy5jdXJzb3JDb2xvciB8fCAnIzYwQ0ZDNCc7XG4gICAgICAgIHRoaXMudGV4dFJhbmdlQ29sb3IgPSBjb25maWdzLnRleHRSYW5nZUNvbG9yIHx8ICcjNEU3NUVDMUEnO1xuICAgICAgICB0aGlzLm1pbldpZHRoID0gY29uZmlncy5taW5XaWR0aCB8fCAwO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5zcGFjZUhvbGRlciA9IHtcbiAgICAgICAgICAgIGVuYWJsZTogZmFsc2UsXG4gICAgICAgIH1cbiAgICAgICAgaWYoY29uZmlncy5zcGFjZVBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuc3BhY2VIb2xkZXIsIHtcbiAgICAgICAgICAgICAgICBlbmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgc3BhY2VQbGFjZWhvbGRlcjogY29uZmlncy5zcGFjZVBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICAgIHNwYWNlUGxhY2Vob2xkZXJDb2xvcjogY29uZmlncy5zcGFjZVBsYWNlaG9sZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgcmV0dXJuRm9udDogY29uZmlncy5yZXR1cm5Gb250LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBcblxuXG4gICAgICAgIHRoaXMucmVzb2x2ZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IGNvbmZpZ3MucmVzb2x2ZXIoKTtcbiAgICAgICAgICAgIGlmKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCB8fCBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGgtMV0udHlwZSAhPT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChuZXcgVGV4dEVsZW1lbnQoJ3RleHQnLCAnJykpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAgICBpZihlbC50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc2V0U291cmNlKGVsLnNvdXJjZSwgdGhpcy5zcGFjZUhvbGRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoaXMuX2xpbmVzID0gW107XG4gICAgICAgIHRoaXMuX2FyZWEgPSBuZXcgQXJlYSgpO1xuICAgICAgICB0aGlzLl9mbGF0dGVuVHh0RWxlbSA9IEZsYXR0ZW5UZXh0RWxlbWVudHMuY3JlYXRlKHRoaXMucmVzb2x2ZXIoKSk7IFxuICAgICAgICB0aGlzLl9zdGF0dXMgPSB7XG4gICAgICAgICAgICBlZGl0aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGRyYWdvdmVyOiBmYWxzZSxcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb21tYW5kcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5yZWdpc3RDb21tYW5kKFN0YXJ0RWRpdENvbW1hbmQpO1xuICAgICAgICB0aGlzLnJlZ2lzdENvbW1hbmQoRWRpdENsaWNrQ29tbWFuZCk7XG4gICAgICAgIHRoaXMucmVnaXN0Q29tbWFuZChTaGlmdFVwQ29tbWFuZCk7XG4gICAgICAgIHRoaXMucmVnaXN0Q29tbWFuZChTaGlmdERvd25Db21tYW5kKTtcbiAgICAgICAgdGhpcy5yZWdpc3RDb21tYW5kKFNoaWZ0T25DbGlja0NvbW1hbmQpO1xuICAgICAgICB0aGlzLnJlZ2lzdENvbW1hbmQoSW5wdXQpO1xuICAgICAgICB0aGlzLnJlZ2lzdENvbW1hbmQoQXJyb3dMZWZ0Q29tbWFuZCk7XG4gICAgICAgIHRoaXMucmVnaXN0Q29tbWFuZChBcnJvd1JpZ2h0Q29tbWFuZCk7XG4gICAgICAgIHRoaXMucmVnaXN0Q29tbWFuZChBcnJvd1VwQ29tbWFuZCk7XG4gICAgICAgIHRoaXMucmVnaXN0Q29tbWFuZChBcnJvd0Rvd25Db21tYW5kKTtcbiAgICAgICAgdGhpcy5yZWdpc3RDb21tYW5kKEN0cmxBQ29tbWFuZCk7XG4gICAgICAgIHRoaXMucmVnaXN0Q29tbWFuZChEb3VibGVDbGlja0NvbW1hbmQpO1xuICAgICAgICAvLyB0aGlzLnJlZ2lzdENvbW1hbmQoUmV0dXJuQ29tbWFuZCk7XG4gICAgICAgIC8vIHRoaXMucmVnaXN0Q29tbWFuZChEZWxldGVDb21tYW5kKTtcbiAgICAgICAgdGhpcy5yZWdpc3RDb21tYW5kKFVuZG9Db21tYW5kKTtcbiAgICAgICAgdGhpcy5yZWdpc3RDb21tYW5kKFJlZG9Db21tYW5kKTtcbiAgICAgICAgdGhpcy5yZWdpc3RDb21tYW5kKENvcHlDb21tYW5kKTtcbiAgICAgICAgdGhpcy5yZWdpc3RDb21tYW5kKEN1dENvbW1hbmQpO1xuICAgICAgICB0aGlzLnJlZ2lzdENvbW1hbmQoUGFzdGVDb21tYW5kKTtcbiAgICAgICAgdGhpcy5fbWFrZUZ1bmN0aW9uYWwoKTtcblxuICAgICAgICB0aGlzLl9jYWNoZVZpZXdCb3ggPSBbXTtcbiAgICB9XG5cbiAgICByZWdpc3RDb21tYW5kKGNtZCkge1xuICAgICAgICBpZighdGhpcy5jb21tYW5kcy5oYXMoY21kLl9uYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5jb21tYW5kcy5zZXQoY21kLl9uYW1lLCBjbWQuY3JlYXRlKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9tYWtlRnVuY3Rpb25hbCgpIHtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYoZXZlbnQuY3VycmVudFRhcmdldCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQuZGV0YWlsLmJ1YmJsZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmKHRoaXMuX3N0YXR1cy5lZGl0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leGVjQ29tbWFuZChNT1VTRV9DT01NQU5EUy5ET1VCTEVfQ0xJQ0spXG4gICAgICAgICAgICB9IFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYoZXZlbnQuY3VycmVudFRhcmdldCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQuZGV0YWlsLmJ1YmJsZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBjb21tbmQ7XG4gICAgICAgICAgICBpZih0aGlzLl9zdGF0dXMuZWRpdGluZykge1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuX3N0YXR1cy5zaGlmdE9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1uZCA9IE1PVVNFX0NPTU1BTkRTLlNISUZUX09OX0NMSUNLXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbW5kID0gTU9VU0VfQ09NTUFORFMuRURJVF9DTElDS1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tbW5kID0gTU9VU0VfQ09NTUFORFMuU1RBUlRfRURJVFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5leGVjQ29tbWFuZChjb21tbmQpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc3RhdHVzLmVkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmKHRoaXMuX3NoYWRvd0lucHV0KSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5fc2hhZG93SW5wdXQucmVsZWFzZUV2ZW50TGlzdGVucigpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWRvd0lucHV0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFkb3dJbnB1dCA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5fYmVsb25ncykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2pmbG93Ll9yZW5kZXIoKTtcbiAgICAgICAgICAgIH0gXG5cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnY2hhbmdlJywge1xuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICAgICAgICB0ZXh0RWxlbWVudHM6IHRoaXMuX2ZsYXR0ZW5UeHRFbGVtLmNvcHkoKSxcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgdGhpcy5fcmFuZ2UuZGlzYWJsZSgpO1xuICAgICAgICAgICAgdGhpcy5fY2FyZXQuY2FuY2VsQW5pbWF0ZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2luc3RhbmNlUHJlc3NTdGFydCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYodGhpcy5fc3RhdHVzLmVkaXRpbmcgJiYgIXRoaXMuX3N0YXR1cy5zaGlmdE9uKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuZGV0YWlsLmJ1YmJsZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBldmVudC5kZXRhaWwucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAvLyBldmVudC5kZXRhaWwuamZsb3cuc2V0TW92aW5nVGFyZ2V0cyhudWxsKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMuX2N1cnJlbnRwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSB0aGlzLl9wb3NpdGlvblRvQ3Vyc29yT2Zmc2V0KHBvaW50KTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9jdXJzb3IgPSBjO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5fcmFuZ2U7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0SW5pdGlhbFJhbmdlKFtjLnJvdywgLi4uYy5jb2x1bW5dKTtcbiAgICAgICAgICAgICAgICBjb25zdCBqZmxvdyA9IGV2ZW50LmRldGFpbC5qZmxvdztcbiAgICAgICAgICAgICAgICBsZXQgbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gKGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMuZWRpdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IGpmbG93Ll9jYWxjdWxhdGVQb2ludEJhY2soW29mZnNldFgsIG9mZnNldFldKTtcbiAgICAgICAgICAgICAgICAgICAgamZsb3cuX3N0YWNrLmNoZWNrSGl0KHApXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy5fY3VycmVudHA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGMgPSB0aGlzLl9wb3NpdGlvblRvQ3Vyc29yT2Zmc2V0KHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy5fY3Vyc29yID0gYztcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0UmFuZ2UoW2Mucm93LCAuLi5jLmNvbHVtbl0pO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5lbmFibGUoKTtcbiAgICAgICAgICAgICAgICB9KS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCB0KVxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgdCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEluaXRpYWxSYW5nZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoIW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuaGFuZGxlQ2FyZXQodGhpcy5fY2FyZXQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5lZGl0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hhZG93SW5wdXQuZm9jdXMoKTsgICBcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1vdmVDYXJldEJ5SGl0UG9pbnQoKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5kcmFnb3ZlciA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ2FyZXRCeUhpdFBvaW50KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdsZWF2ZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5kcmFnb3ZlciA9IGZhbHNlO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBvbkRyb3AgPSAoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZighdGhpcy5fc3RhdHVzLmRyYWdvdmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQuZGV0YWlsLmJ1YmJsZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5kcmFnb3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgY2FyZXQgPSB0aGlzLl9jYXJldDtcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IGNhcmV0LmdldFJvdygpO1xuICAgICAgICAgICAgY29uc3QgY29sdW1uID0gY2FyZXQuZ2V0Q29sdW1uKCk7XG4gICAgICAgICAgICBjb25zdCBsaW5lID0gdGhpcy5fYXJlYS5nZXQocm93KTtcbiAgICAgICAgICAgIGxldCBbZWxlbWlkeCwgb2Zmc2V0XSA9IGNvbHVtbjtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBsaW5lLmdldChlbGVtaWR4KTtcbiAgICAgICAgICAgIGNvbnN0IHByZUVsZW0gPSBsaW5lLmdldChlbGVtaWR4LTEpO1xuICAgICAgICAgICAgbGV0IGZsYXR0ZW5UeHRFbGVtID0gdGhpcy5fZmxhdHRlblR4dEVsZW07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCBpZHggPSBmbGF0dGVuVHh0RWxlbS5maW5kSW5kZXgoZWxlbWVudClcbiAgICAgICAgICAgIGlmKGVsZW1lbnQudHlwZSAhPT0gJ3RleHQnICYmIHByZUVsZW0/LnR5cGUgPT09J3RleHQnKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gcHJlRWxlbS5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlkeCA9IGZsYXR0ZW5UeHRFbGVtLmZpbmRJbmRleChwcmVFbGVtKSAgIFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBsYXN0TGVuZ3RoID0gZmxhdHRlblR4dEVsZW0ubGVuZ3RoKClcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnaW5zZXJ0Jywge1xuICAgICAgICAgICAgICAgIC4uLmV2ZW50LmRldGFpbCxcbiAgICAgICAgICAgICAgICB0eXBlOiBldmVudC50eXBlLFxuICAgICAgICAgICAgICAgIHRleHRFbGVtZW50czogZmxhdHRlblR4dEVsZW0uY29weSgpLFxuICAgICAgICAgICAgICAgIGlkeCwgb2Zmc2V0LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgLy8gYWZ0ZXIgaW5zZXJ0XG4gICAgICAgICAgICBmbGF0dGVuVHh0RWxlbSA9IHRoaXMuX2ZsYXR0ZW5UeHRFbGVtO1xuICAgICAgICAgICAgaWYodGhpcy5fc3RhdHVzLmVkaXRpbmcpIHtcbiAgICAgICAgICAgICAgICBpZihmbGF0dGVuVHh0RWxlbS5sZW5ndGgoKSA+IGxhc3RMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FyZXQuc2V0Q29sdW1uKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1pZHggKyBmbGF0dGVuVHh0RWxlbS5sZW5ndGgoKSAtIGxhc3RMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWRvd0lucHV0LmZvY3VzKCk7IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5fc3RhdHVzLmVkaXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYXJldC5yZWZyZXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN5bmNTaGFkb3dJbnB1dFBvc2l0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLl9yYW5nZS5kaXNhYmxlKCk7XG4gICAgICAgIH0pLmJpbmQodGhpcylcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdwcmVzc0VuZCcsIG9uRHJvcClcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkcm9wJywgb25Ecm9wKTtcbiAgICB9XG5cbiAgICB0b2dnbGVTaGlmdCh2YWwpIHtcbiAgICAgICAgdGhpcy5fc3RhdHVzLnNoaWZ0T24gPSB2YWw7XG4gICAgfVxuXG4gICAgZXhlY0NvbW1hbmQoa2luZCwgZGF0YSkge1xuICAgICAgICBjb25zdCBjbWQgPSB0aGlzLmNvbW1hbmRzLmdldChraW5kKTtcbiAgICAgICAgY21kLmV4ZWMoZGF0YSk7XG4gICAgfVxuXG4gICAgY3JlYXRlU2hhZG93SW5wdXQoKSB7XG4gICAgICAgIGNvbnN0IGpmbG93ID0gdGhpcy5famZsb3c7XG4gICAgICAgIGxldCBzaGFkb3dJbnB1dCA9IG5ldyBTaGFkb3dJbnB1dChqZmxvdy5ET013cmFwcGVyKTtcbiAgICAgICAgY29uc3QgX2EgPSBlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtpbmQgPSBlLmRldGFpbC5raW5kO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGUuZGV0YWlsLmRhdGE7XG4gICAgICAgICAgICB0aGlzLmV4ZWNDb21tYW5kKGtpbmQsIGRhdGEpXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IF9iID0gZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBraW5kID0gZS5kZXRhaWwua2luZDtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBlLmRldGFpbC5kYXRhO1xuICAgICAgICAgICAgY29uc3QgY21kID0gdGhpcy5jb21tYW5kcy5nZXQoRURJVE9SX0VWRU5UUy5JTlBVVCk7XG4gICAgICAgICAgICBjbWQuZXhlYyhraW5kLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBzaGFkb3dJbnB1dC5hZGRFdmVudExpc3RlbmVyKEVESVRPUl9FVkVOVFMuQ09OVFJPTF9DTUQsIF9hKTtcbiAgICAgICAgc2hhZG93SW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihFRElUT1JfRVZFTlRTLklOUFVULCBfYik7XG5cbiAgICAgICAgc2hhZG93SW5wdXQucmVtb3ZlTGlzZW50ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNoYWRvd0lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoRURJVE9SX0VWRU5UUy5DT05UUk9MX0NNRCwgX2EpO1xuICAgICAgICAgICAgc2hhZG93SW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihFRElUT1JfRVZFTlRTLklOUFVULCBfYik7XG4gICAgICAgICAgICBzaGFkb3dJbnB1dC5yZW1vdmVMaXNlbnRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2hhZG93SW5wdXQgPSBzaGFkb3dJbnB1dDtcbiAgICAgICAgdGhpcy5fc3RhdHVzLmVkaXRpbmcgPSB0cnVlO1xuICAgICAgICBqZmxvdy5zZXRGb2N1c0luc3RhbmNlKHRoaXMpO1xuICAgIH1cblxuICAgIG1vdmVDYXJldEJ5SGl0UG9pbnQoKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy5fY3VycmVudHA7XG4gICAgICAgIGNvbnN0IGNhcmV0ID0gdGhpcy5fY2FyZXQ7XG4gICAgICAgIGNvbnN0IHsgcm93LCBjb2x1bW4gfSA9IHRoaXMuX3Bvc2l0aW9uVG9DdXJzb3JPZmZzZXQocG9pbnQpO1xuICAgICAgICBjYXJldC5zZXRSb3cocm93KTtcbiAgICAgICAgY2FyZXQuc2V0Q29sdW1uKGNvbHVtbik7XG4gICAgfVxuXG4gICAgcmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZVVwKCk7XG4gICAgICAgIHRoaXMuc3luY1NoYWRvd0lucHV0UG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5famZsb3cuX3JlbmRlcigpO1xuICAgIH1cblxuICAgIHJlZnJlc2hUZXh0RWxlbWVudHMoKSB7XG4gICAgICAgIHRoaXMuX2ZsYXR0ZW5UeHRFbGVtID0gRmxhdHRlblRleHRFbGVtZW50cy5jcmVhdGUodGhpcy5yZXNvbHZlcigpKTsgXG4gICAgfVxuXG4gICAgX3Bvc2l0aW9uVG9DdXJzb3JPZmZzZXQocG9pbnQpIHtcbiAgICAgICAgY29uc3QgW3gsIHldID0gcG9pbnQ7XG4gICAgICAgIC8vIGNvbnN0IFt4MCwgeTBdID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IGFyZWEgPSB0aGlzLl9hcmVhO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aC8yO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IHggKyB3O1xuICAgICAgICBjb25zdCBvZmZzZXRZID0geSArIGg7XG4gICAgICAgIGNvbnN0IHJvdyA9IGFyZWEuZ2V0TGluZUFib3ZlKG9mZnNldFkpXG4gICAgICAgIGNvbnN0IGN1cnJMaW5lID0gYXJlYS5nZXQocm93KTtcbiAgICAgICAgY29uc3QgY29sdW1uID0gY3VyckxpbmUuZ2V0Q29sdW1uTmVhcmVzdChvZmZzZXRYLCB0aGlzLmVsZW1lbnRTcGFjZSwgdGhpcy5mb250U2l6ZSwgdGhpcy5mb250RmFtaWx5LCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvdywgXG4gICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY2FyZXRUb1Bvc2l0aW9uKCkge1xuICAgICAgICBjb25zdCByb3cgPSB0aGlzLl9jYXJldC5nZXRSb3coKTtcbiAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5fY2FyZXQuZ2V0Q29sdW1uKCk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSB0aGlzLl9hcmVhLmdldChyb3cpO1xuICAgICAgICBjb25zdCBbZWxlbWlkeCwgb2Zmc2V0XSA9IGNvbHVtbjtcbiAgICAgICAgY29uc3QgbWV0YSA9IGxpbmUuZ2V0KGVsZW1pZHgpO1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9mbGF0dGVuVHh0RWxlbS5maW5kSW5kZXgobWV0YSk7XG4gICAgICAgIGNvbnN0IHByZUVsZW0gPSB0aGlzLl9mbGF0dGVuVHh0RWxlbS5nZXQoaWR4LTEpO1xuICAgICAgICBsZXQgY3c7XG4gICAgICAgIGxldCBjX2xlbiA9IHRoaXMuY3VycmVudExpbmVIZWlnaHQvMjtcbiAgICAgICAgaWYobWV0YS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBtZXRhLmdldFJlbmRlclNvdXJjZSh0aGlzLnNwYWNlSG9sZGVyKS5zdWJzdHJpbmcoMCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHJlcXVlc3RDYWNoZUNhbnZhcygoY3R4KSA9PiB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5mb250ID0gYCR7dGhpcy5mb250U2l6ZX0gJHt0aGlzLmZvbnRGYW1pbHl9YDtcbiAgICAgICAgICAgICAgICBjdyA9IG1ldGEuYW5jaG9yWCAtIG1ldGEud2lkdGgvMiArIGN0eC5tZWFzdXJlVGV4dChjKS53aWR0aFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN3ID0gbWV0YS5hbmNob3JYIC0gbWV0YS53aWR0aC8yXG4gICAgICAgICAgICBjX2xlbiA9IE1hdGgubWF4KGNfbGVuLCBtZXRhLmhlaWdodC8yKTtcbiAgICAgICAgfVxuICAgICAgICBpZihvZmZzZXQgPT09IDAgJiYgcHJlRWxlbSAmJiBwcmVFbGVtLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgY19sZW4gPSBNYXRoLm1heChjX2xlbiwgcHJlRWxlbS5oZWlnaHQvMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtjdywgY19sZW4sIGxpbmUuYW5jaG9yWSwgcHJlRWxlbSwgbWV0YV1cbiAgICB9XG5cbiAgICBzeW5jU2hhZG93SW5wdXRQb3NpdGlvbigpIHtcbiAgICAgICAgaWYodGhpcy5fc3RhdHVzLmVkaXRpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IFtjdywgY19sZW4sIGFuY2hvclldID0gdGhpcy5fY2FyZXRUb1Bvc2l0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMuY2FsY3VsYXRlVG9SZWFsV29ybGQoW2N3LCBhbmNob3JZICsgY19sZW5dKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhc01ldGEgPSB0aGlzLl9qZmxvdy5jYW52YXNNZXRhO1xuICAgICAgICAgICAgY29uc3QgcHggPSBNYXRoLm1pbihjYW52YXNNZXRhLmFjdHVhbF93aWR0aCAtIDEyMCwgcG9pbnRbMF0pO1xuICAgICAgICAgICAgLy8gcmV0dXJuIFtweCwgcG9pbnRbMV1dO1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93SW5wdXQuc3luY1Bvc2l0aW9uKHB4LCBwb2ludFsxXSk7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dJbnB1dC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGlmKHRoaXMuX2lzTW92aW5nKXtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNlxuICAgICAgICB9IGVsc2UgaWYodGhpcy5vcGFjaXR5ICE9PSAxKSB7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLm9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2N4LCBjeV0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgamZsb3cgPSB0aGlzLl9qZmxvdztcbiAgICAgICAgY29uc3QgYXJlYSA9IHRoaXMuX2FyZWE7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoY3gsIGN5KTtcbiAgICAgICAgLy8gY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAvLyBjdHgucmVjdCgtd2lkdGgvMiwgLWhlaWdodC8yLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgLy8gY3R4LnN0cm9rZSgpO1xuICAgICAgICBjb25zdCBmbGF0dGVuVHh0RWxlbSA9IHRoaXMuX2ZsYXR0ZW5UeHRFbGVtO1xuICAgICAgICBpZihmbGF0dGVuVHh0RWxlbS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5mb250ID0gYCR7dGhpcy5mb250V2VpZ2h0fSAke3RoaXMuZm9udFNpemV9ICR7dGhpcy5mb250RmFtaWx5fWA7XG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5wbGFjZWhvbGRlckNvbG9yO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMucGxhY2Vob2xkZXIsIDAsIDApO1xuXG4gICAgICAgICAgICB0aGlzLl9yYW5kZXJDdXJzb3IoY3R4KTtcblxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguZm9udCA9IGAke3RoaXMuZm9udFdlaWdodH0gJHt0aGlzLmZvbnRTaXplfSAke3RoaXMuZm9udEZhbWlseX1gO1xuICAgICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMudGV4dENvbG9yO1xuICAgICAgICBhcmVhLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgICAgICBsaW5lLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgICAgIGlmKGVsLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBlbC5yZW5kZXIoY3R4LCB0aGlzLnNwYWNlSG9sZGVyLCB0aGlzLnRleHRDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGN0eC5maWxsVGV4dChlbC5zb3VyY2UsIGVsLmFuY2hvclgsIGVsLmFuY2hvclkpXG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIGZsYXR0ZW5UeHRFbGVtLmZvckVhY2goZWxlbSA9PiB7XG4gICAgICAgICAgICBpZihlbGVtLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gamZsb3cuZ2V0UmVuZGVyTm9kZUJ5U291cmNlKGVsZW0uc291cmNlKTtcbiAgICAgICAgICAgICAgICBpZihpbnN0YW5jZSAmJiBpbnN0YW5jZS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnJlbmRlcihjdHgpO1xuICAgICAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLl9yYW5kZXJDdXJzb3IoY3R4KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyUmFuZ2UoY3R4KTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgX3JhbmRlckN1cnNvcihjdHgpIHtcbiAgICAgICAgaWYodGhpcy5fY2FyZXQuaXNTaG93KCkgJiYgKHRoaXMuX3N0YXR1cy5lZGl0aW5nIHx8IHRoaXMuX3N0YXR1cy5kcmFnb3ZlcikpIHtcbiAgICAgICAgICAgIGNvbnN0IFtjdywgY19sZW4sIGFuY2hvclldID0gdGhpcy5fY2FyZXRUb1Bvc2l0aW9uKCk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGN3LCBhbmNob3JZIC0gY19sZW4pO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhjdywgYW5jaG9yWSArIGNfbGVuKTtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jdXJzb3JDb2xvcjtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9yZW5kZXJSYW5nZShjdHgpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGlzLl9yYW5nZTtcbiAgICAgICAgaWYocmFuZ2UuaXNFbmFibGUoKSkge1xuICAgICAgICAgICAgY29uc3QgYXJlYSA9IHRoaXMuX2FyZWE7XG4gICAgICAgICAgICBjb25zdCB0ZXh0UmFuZ2VDb2xvciA9IHRoaXMudGV4dFJhbmdlQ29sb3I7XG4gICAgICAgICAgICBjb25zdCBibG9ja2hlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgYmxvY2t3aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgICAgICBjb25zdCBsaW5lU3BhY2UgPSB0aGlzLmxpbmVTcGFjZTtcbiAgICAgICAgICAgIGNvbnN0IFtyX2YsIGlkeF9mLCBvZmZzZXRfZl0gPSByYW5nZS5nZXRSYW5nZUZyb20oKTtcbiAgICAgICAgICAgIGNvbnN0IFtyX3QsIGlkeF90LCBvZmZzZXRfdF0gPSByYW5nZS5nZXRSYW5nZVRvKCk7XG4gICAgICAgICAgICBpZihyX2YgPT09IHJfdCkge1xuICAgICAgICAgICAgICAgIGlmKGlkeF9mID09PSBpZHhfdCAmJiBvZmZzZXRfZiA9PSBvZmZzZXRfdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBhcmVhLmdldChyX2YpO1xuICAgICAgICAgICAgICAgIGxldCBzcGFjZSA9IChyX2YgPT09IGFyZWEubGVuZ3RoKCktMSA/IDAgOiBsaW5lU3BhY2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGx0eSA9IGxpbmUucmVkdWNlSGVpZ2h0IC0gc3BhY2UgLSBsaW5lLmhlaWdodCAtIGJsb2NraGVpZ2h0LzI7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gbGluZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgeDEgPSB0aGlzLl9tZWFzdXJlRWxlbWVudE9mZnNldFgobGluZS5nZXQoaWR4X2YpLCBvZmZzZXRfZiwgY3R4KTtcbiAgICAgICAgICAgICAgICBjb25zdCB4MiA9IHRoaXMuX21lYXN1cmVFbGVtZW50T2Zmc2V0WChsaW5lLmdldChpZHhfdCksIG9mZnNldF90LCBjdHgpO1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgucmVjdCh4MSwgbHR5ICwgeDIgLSB4MSwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGV4dFJhbmdlQ29sb3JcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgX3IgPSByX2Y7XG4gICAgICAgICAgICAgICAgbGV0IGJlZ2lubmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgd2hpbGUoX3IgPD0gcl90KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBhcmVhLmdldChfcik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZSA9IChfciA9PT0gYXJlYS5sZW5ndGgoKS0xID8gMCA6IGxpbmVTcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGx0eSA9IGxpbmUucmVkdWNlSGVpZ2h0IC0gc3BhY2UgLSBsaW5lLmhlaWdodCAtIGJsb2NraGVpZ2h0LzI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGxpbmUuaGVpZ2h0O1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBpZihiZWdpbm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW0gPSBsaW5lLmdldChpZHhfZik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB4ID0gdGhpcy5fbWVhc3VyZUVsZW1lbnRPZmZzZXRYKGVsZW0sIG9mZnNldF9mLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdEVsZW0gPSBsaW5lLnRhaWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBsYXN0RWxlbS5hbmNob3JYICsgbGFzdEVsZW0ud2lkdGgvMjtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KHgsIGx0eSwgdCAtIHgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGV4dFJhbmdlQ29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihfciA9PT0gcl90KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW0gPSBsaW5lLmdldChpZHhfdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB4ID0gdGhpcy5fbWVhc3VyZUVsZW1lbnRPZmZzZXRYKGVsZW0sIG9mZnNldF90LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoLWJsb2Nrd2lkdGgvMiwgbHR5ICwgZWxlbS5yZWR1Y2VXaWR0aCArICh4IC0gZWxlbS5hbmNob3JYICsgZWxlbS53aWR0aC8yKSwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0UmFuZ2VDb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KC1ibG9ja3dpZHRoLzIsIGx0eSwgbGluZS53aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0UmFuZ2VDb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgYmVnaW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIF9yKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX21lYXN1cmVFbGVtZW50T2Zmc2V0WChlbGVtZW50LCBvZmZzZXQsIGN0eCkge1xuICAgICAgICBpZihlbGVtZW50LnR5cGUgIT09ICd0ZXh0JyB8fCBvZmZzZXQgPT09IDApe1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuYW5jaG9yWCAtIGVsZW1lbnQud2lkdGgvMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudC5hbmNob3JYIC0gZWxlbWVudC53aWR0aC8yICsgY3R4Lm1lYXN1cmVUZXh0KGVsZW1lbnQuZ2V0UmVuZGVyU291cmNlKHRoaXMuc3BhY2VIb2xkZXIpLnN1YnN0cmluZygwLCBvZmZzZXQpKS53aWR0aDtcbiAgICB9XG5cbiAgICBtZWFzdXJlVGV4dFdpZHRoKGNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHQ7XG4gICAgICAgIHJlcXVlc3RDYWNoZUNhbnZhcygoY3R4KSA9PiB7XG4gICAgICAgICAgICBjdHguZm9udCA9IGAke3RoaXMuZm9udFNpemV9ICR7dGhpcy5mb250RmFtaWx5fWA7XG4gICAgICAgICAgICB0ID0gY3R4Lm1lYXN1cmVUZXh0KGNvbnRlbnQpLndpZHRoO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuXG4gICAgZ2V0Qm91bmRpbmdEaW1lbnNpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgIH0gXG4gICAgfVxuXG4gICAgZ2V0Qm91bmRpbmdSZWN0KCkge1xuICAgICAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGggLzI7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICBjb25zdCBsdHggPSBhbmNob3JbMF0gLSB3O1xuICAgICAgICBjb25zdCBsdHkgPSBhbmNob3JbMV0gLSBoO1xuICAgICAgICBjb25zdCByYnggPSBhbmNob3JbMF0gKyB3O1xuICAgICAgICBjb25zdCByYnkgPSBhbmNob3JbMV0gKyBoO1xuICAgICAgICBjb25zdCBiciA9IHRoaXMuX2JvdW5kaW5ncmVjdDtcbiAgICAgICAgYnJbMF0gPSBsdHg7XG4gICAgICAgIGJyWzFdID0gbHR5O1xuICAgICAgICBiclsyXSA9IHJieDtcbiAgICAgICAgYnJbM10gPSByYnk7XG4gICAgICAgIHJldHVybiBiclxuICAgIH1cblxuICAgIF9nZXRWaWV3Qm94KCkge1xuICAgICAgICBjb25zdCBiZWxvbmdzX3Zib3ggPSB0aGlzLl9iZWxvbmdzLmdldENhY2hlVmlld0JveCgpO1xuICAgICAgICBjb25zdCBjYWNoZVZpZXdCb3ggPSB0aGlzLl9jYWNoZVZpZXdCb3g7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVQb2ludEJhY2tXaXRoUG9pbnQoYmVsb25nc192Ym94WzBdLCBiZWxvbmdzX3Zib3hbMV0sIGNhY2hlVmlld0JveCwgMCwgMSk7XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVBvaW50QmFja1dpdGhQb2ludChiZWxvbmdzX3Zib3hbMl0sIGJlbG9uZ3NfdmJveFszXSwgY2FjaGVWaWV3Qm94LCAyLCAzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlVmlld0JveDtcbiAgICB9XG4gICAgXG4gICAgZ2V0Q2FjaGVWaWV3Qm94KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVWaWV3Qm94O1xuICAgIH1cblxuICAgIGNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKHBvaW50KSB7XG4gICAgICAgIGNvbnN0IFtneCwgZ3ldID0gcG9pbnQ7XG4gICAgICAgIGNvbnN0IFtjeCwgY3ldID0gdGhpcy5hbmNob3I7XG4gICAgICAgIC8vIGNvbnN0IHAgPSBbY3ggKyBhbmNob3JbMF0gLSBzcGFuSCwgY3kgKyBhbmNob3JbMV0gLSBzcGFuVl07XG4gICAgICAgIGNvbnN0IHAgPSBbZ3ggKyBjeCwgZ3kgKyBjeV1cbiAgICAgICAgaWYodGhpcy5fYmVsb25ncyAmJiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbihwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlVG9SZWFsV29ybGQocG9pbnQpIHtcbiAgICAgICAgY29uc3QgW2d4LCBneV0gPSBwb2ludDtcbiAgICAgICAgY29uc3QgW2N4LCBjeV0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgcCA9IFtneCArIGN4LCBneSArIGN5XVxuICAgICAgICBpZih0aGlzLl9iZWxvbmdzICYmIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9SZWFsV29ybGQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvUmVhbFdvcmxkKHApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlVG9SZWFsV29ybGRXaXRoUG9pbnRlcihvdXRwb2ludCwgaW5wb2ludCkge1xuICAgICAgICBvdXRwb2ludFswXSA9IGlucG9pbnRbMF0gKyB0aGlzLmFuY2hvclswXTtcbiAgICAgICAgb3V0cG9pbnRbMV0gPSBpbnBvaW50WzFdICsgdGhpcy5hbmNob3JbMV07XG4gICAgICAgIGlmKHRoaXMuX2JlbG9uZ3MgJiYgdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb1JlYWxXb3JsZFdpdGhQb2ludGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb1JlYWxXb3JsZFdpdGhQb2ludGVyKG91dHBvaW50LCBvdXRwb2ludCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY2FsY3VsYXRlUG9pbnRCYWNrKHBvaW50KSB7XG4gICAgICAgIGNvbnN0IFtneCwgZ3ldID0gcG9pbnQ7XG4gICAgICAgIGNvbnN0IFtjeCwgY3ldID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IHAgPSBbZ3ggLSBjeCwgZ3kgLSBjeV1cbiAgICAgICAgcmV0dXJuIHBcbiAgICB9XG5cbiAgICBfY2FsY3VsYXRlUG9pbnRCYWNrV2l0aFBvaW50KGEsIGIsIGFyciwgaWR4MSwgaWR4Mikge1xuICAgICAgICBhcnJbaWR4MV0gPSBhIC0gdGhpcy5hbmNob3JbMF07XG4gICAgICAgIGFycltpZHgyXSA9IGIgLSB0aGlzLmFuY2hvclsxXTtcbiAgICB9XG5cbiAgICBpc0hpdChwb2ludCwgY29uZGl0aW9uKSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLl9jYWxjdWxhdGVQb2ludEJhY2socG9pbnQpO1xuICAgICAgICBjb25zdCBqZmxvdyA9IHRoaXMuX2pmbG93O1xuICAgICAgICB0aGlzLl9jdXJyZW50cCA9IHA7IC8vIOaaguWtmO+8jOS4uuS6huWQjue7reiuoeeul+WIq+eahOS9jee9rlxuICAgICAgICBsZXQgdmFsaWRJbnN0YW5jZSA9IFtdO1xuICAgICAgICBjb25zdCBmbGF0dGVuVHh0RWxlbSA9IHRoaXMuX2ZsYXR0ZW5UeHRFbGVtO1xuICAgICAgICBmbGF0dGVuVHh0RWxlbS5mb3JFYWNoKGVsZW0gPT4ge1xuICAgICAgICAgICAgaWYoZWxlbS50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGpmbG93LmdldFJlbmRlck5vZGVCeVNvdXJjZShlbGVtLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaWYoaW5zdGFuY2UudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZEluc3RhbmNlLnB1c2goaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fc3RhY2suY2hlY2tIaXQocCwgY29uZGl0aW9uLCAoaSkgPT4gdmFsaWRJbnN0YW5jZS5pbmNsdWRlcyhpKSk7XG4gICAgICAgIFxuICAgICAgICBpZih0YXJnZXQpIHJldHVybiB0YXJnZXQ7XG5cbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoIC8yO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgcmV0dXJuIHBvaW50WzBdID4gYW5jaG9yWzBdIC0gd1xuICAgICAgICAgICAgJiYgcG9pbnRbMF0gPCBhbmNob3JbMF0gKyB3XG4gICAgICAgICAgICAmJiBwb2ludFsxXSA+IGFuY2hvclsxXSAtIGhcbiAgICAgICAgICAgICYmIHBvaW50WzFdIDwgYW5jaG9yWzFdICsgaDtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgdCA9IG5ldyBTaGFkb3dDYWNoZSh7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICBjYWNoZTogKGN0eCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtjeCwgY3ldID0gdGhpcy5hbmNob3I7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY3ggKyB0aGlzLndpZHRoLzIsIC1jeSArIHRoaXMuaGVpZ2h0LzIpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYodGhpcy5famZsb3cuX2ZvY3VzLmluc3RhbmNlID09PSB0aGlzKSB7XG4gICAgICAgICAgICB0aGlzLl9qZmxvdy5ibHVyKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbk9iamVjdC5hc3NpZ24oVGV4dEdyb3VwLnByb3RvdHlwZSwgU3RhY2tNaXhpbik7XG5PYmplY3QuYXNzaWduKFRleHRHcm91cC5wcm90b3R5cGUsIExheW91dE1peGluKTtcbk9iamVjdC5hc3NpZ24oVGV4dEdyb3VwLnByb3RvdHlwZSwge1xuICAgICAgICAvLyDlsY/olL3ov5nkuKTkuKrmlrnms5XvvIzlj6rmoLnmja5yZWZsb3fph43nrpdcbiAgICBfZ2V0Qm91bmRpbmdHcm91cFJlY3QoKSB7fSxcbiAgICByZXNldENoaWxkcmVuUG9zaXRpb24oKSB7fSxcbiAgICByZWZsb3coKSB7XG4gICAgICAgIGxldCBsaW5lSGVpZ2h0ID0gdGhpcy5jdXJyZW50TGluZUhlaWdodDtcbiAgICAgICAgY29uc3QgZmxhdHRlblR4dEVsZW0gPSB0aGlzLl9mbGF0dGVuVHh0RWxlbTtcbiAgICAgICAgY29uc3QgYXJlYSA9IHRoaXMuX2FyZWE7XG4gICAgICAgIGlmKGZsYXR0ZW5UeHRFbGVtLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBmbGF0dGVuVHh0RWxlbS5nZXQoMCk7XG4gICAgICAgICAgICByZXF1ZXN0Q2FjaGVDYW52YXMoKGN0eCkgPT4ge1xuICAgICAgICAgICAgICAgIGN0eC5mb250ID0gYCR7dGhpcy5mb250U2l6ZX0gJHt0aGlzLmZvbnRGYW1pbHl9YDtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh0aGlzLnBsYWNlaG9sZGVyKS53aWR0aDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IGFyZWEudHJ1bmNhdGUoe1xuICAgICAgICAgICAgICAgIGhlaWdodDogbGluZUhlaWdodCxcbiAgICAgICAgICAgICAgICByZWR1Y2VIZWlnaHQ6IGxpbmVIZWlnaHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxpbmUuaW5zZXJ0KDAsIHQpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0LCB7XG4gICAgICAgICAgICAgICAgYW5jaG9yWDogLXdpZHRoLzIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBsaW5lSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGlzVGFpbDogdHJ1ZSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgamZsb3cgPSB0aGlzLl9qZmxvdztcbiAgICAgICAgY29uc3Qgc3BhY2VIb2xkZXIgPSB0aGlzLnNwYWNlSG9sZGVyO1xuICAgICAgICByZXF1ZXN0Q2FjaGVDYW52YXMoKGN0eCkgPT4ge1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBgJHt0aGlzLmZvbnRTaXplfSAke3RoaXMuZm9udEZhbWlseX1gO1xuICAgICAgICAgICAgZmxhdHRlblR4dEVsZW0uZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZihlbGVtZW50LnR5cGUgPT09ICd0ZXh0JyAmJiBlbGVtZW50LmRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucHJlQ2FsY3VsYXRlVGV4dChjdHgsIHNwYWNlSG9sZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG5leHRBcmVhID0gbmV3IEFyZWEoKTtcbiAgICAgICAgbmV4dEFyZWEudHJ1bmNhdGUoe1xuICAgICAgICAgICAgaGVpZ2h0OiBsaW5lSGVpZ2h0LFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGxpbmUgPSBuZXh0QXJlYS5nZXQoMCk7XG4gICAgICAgIGxldCBhbGxIZWlnaHQgPSAwO1xuICAgICAgICBsZXQgYWxsV2lkdGggPSAwO1xuICAgICAgICBsZXQgbGFzdEVsZW0gPSBudWxsO1xuICAgICAgICBjb25zdCBsaW5lU3BhY2UgPSB0aGlzLmxpbmVTcGFjZTtcbiAgICAgICAgY29uc3QgZWxlbWVudFNwYWNlID0gdGhpcy5lbGVtZW50U3BhY2U7XG4gICAgICAgIGZsYXR0ZW5UeHRFbGVtLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICBsaW5lLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICBlbGVtZW50LnJlZHVjZVdpZHRoID0gbGluZS53aWR0aDtcbiAgICAgICAgICAgIGlmKGVsZW1lbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5oZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGxpbmUud2lkdGggKz0gZWxlbWVudC53aWR0aDtcbiAgICAgICAgICAgICAgICBpZihlbGVtZW50Lm5lZWRXcmFwKXtcbiAgICAgICAgICAgICAgICAgICAgYWxsSGVpZ2h0ICs9IChsaW5lLmhlaWdodCArIGxpbmVTcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUucmVkdWNlSGVpZ2h0ID0gYWxsSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBhbGxXaWR0aCA9IE1hdGgubWF4KGxpbmUud2lkdGgsIGFsbFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IExpbmUuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogbGluZUhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRBcmVhLnB1c2gobGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gamZsb3cuZ2V0UmVuZGVyTm9kZUJ5U291cmNlKGVsZW1lbnQuc291cmNlKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmhlaWdodCA9IG5vZGUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGxpbmUuaGVpZ2h0ID0gTWF0aC5tYXgobGluZS5oZWlnaHQsIG5vZGUuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJnaW4gPSAoIWxhc3RFbGVtIHx8IGxhc3RFbGVtLnR5cGUgPT09ICd0ZXh0JykgPyBlbGVtZW50U3BhY2UqMiA6IGVsZW1lbnRTcGFjZTtcbiAgICAgICAgICAgICAgICBsaW5lLndpZHRoICs9IG5vZGUud2lkdGgrbWFyZ2luO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEVsZW0gPSBlbGVtZW50O1xuICAgICAgICB9KTtcblxuICAgICAgICBmbGF0dGVuVHh0RWxlbS50YWlsKCkuaXNUYWlsID0gdHJ1ZTtcbiAgICAgICAgYWxsSGVpZ2h0ICs9IGxpbmUuaGVpZ2h0XG4gICAgICAgIGxpbmUucmVkdWNlSGVpZ2h0ID0gYWxsSGVpZ2h0O1xuICAgICAgICBhbGxXaWR0aCA9IE1hdGgubWF4KHRoaXMubWluV2lkdGgsIE1hdGgubWF4KGxpbmUud2lkdGgsIGFsbFdpZHRoKSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBoaCA9IGFsbEhlaWdodC8yO1xuICAgICAgICBjb25zdCBodyA9IGFsbFdpZHRoLzI7XG4gICAgICAgIGxldCB0eSA9IC1oaDtcbiAgICAgICAgbGV0IGxhc3RSZWR1Y2VZID0gMDtcblxuICAgICAgICBuZXh0QXJlYS5mb3JFYWNoKGwgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBoZWlnaHQsIHJlZHVjZUhlaWdodCB9ID0gbDtcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvclkgPSB0eSArIGxhc3RSZWR1Y2VZICsgaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIGwuYW5jaG9yWSA9IGFuY2hvclk7XG4gICAgICAgICAgICBsZXQgcmVkdWNlWCA9IC1odztcbiAgICAgICAgICAgIGxldCBsYXN0ZWwgPSBudWxsO1xuICAgICAgICAgICAgbC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAgICBpZihlbC50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuYW5jaG9yWSA9IGFuY2hvclk7XG4gICAgICAgICAgICAgICAgICAgIGVsLmFuY2hvclggPSByZWR1Y2VYICsgZWwud2lkdGgvMjtcbiAgICAgICAgICAgICAgICAgICAgcmVkdWNlWCArPSBlbC53aWR0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJOb2RlID0gamZsb3cuZ2V0UmVuZGVyTm9kZUJ5U291cmNlKGVsLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvdWJsZU1hcmdpbiA9ICghbGFzdGVsIHx8IGxhc3RlbC50eXBlID09PSAndGV4dCcpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXJnaW4gPSBkb3VibGVNYXJnaW4gPyBlbGVtZW50U3BhY2UqMiA6IGVsZW1lbnRTcGFjZTtcbiAgICAgICAgICAgICAgICAgICAgZWwud2lkdGggPSByZW5kZXJOb2RlLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBlbC5hbmNob3JZID0gYW5jaG9yWTtcbiAgICAgICAgICAgICAgICAgICAgZWwuYW5jaG9yWCA9IHJlZHVjZVggKyBlbC53aWR0aC8yICsgKGRvdWJsZU1hcmdpbiA/IG1hcmdpbi8yIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlck5vZGUuYW5jaG9yID0gW2VsLmFuY2hvclgsIGVsLmFuY2hvclldO1xuICAgICAgICAgICAgICAgICAgICByZWR1Y2VYICs9IChlbC53aWR0aCArIG1hcmdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RlbCA9IGVsO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGxhc3RSZWR1Y2VZID0gcmVkdWNlSGVpZ2h0O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYXJlYSA9IG5leHRBcmVhO1xuICAgICAgICB0aGlzLndpZHRoID0gYWxsV2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gYWxsSGVpZ2h0O1xuICAgIH0sXG4gICAgZG9SZWNhbGN1bGF0ZSgpIHtcbiAgICAgICAgaWYodGhpcy5fX21vdW50ZWRfXykge1xuICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZVVwKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVjYWxjdWxhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuX19tb3VudGVkX18gPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG59KVxuZXhwb3J0IGRlZmF1bHQgVGV4dEdyb3VwO1xuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi9ub2RlJztcblxuLy8gZXhwb3J0IGNvbnN0IFBMQUNFSE9MREVSX1NZTUJPTCA9IFN5bWJvbCgnUExBQ0VIT0xERVJfU1lNQk9MJyk7XG5cbmV4cG9ydCBjbGFzcyBOb2RlUGxhY2Vob2xkZXIgZXh0ZW5kcyBOb2RlIHtcbiAgICB0eXBlID0gJ05PREVfUExBQ0VIT0xERVInXG59IiwiaW1wb3J0IHsgY3JlYXRlQ2FudmFzLCByZXNpemVDYW52YXMsIGxpc3Rlbk9uRGV2aWNlUGl4ZWxSYXRpbyB9IGZyb20gJy4uL3V0aWxzL2NhbnZhcyc7XG5pbXBvcnQgeyBib3VuZGluZ19ib3gsIGRvT3ZlcmxhcCwgZGVib3VuY2UgfSBmcm9tICcuLi91dGlscy9mdW5jdGlvbnMnO1xuaW1wb3J0IHsgSkZMT1dfTU9ERSB9IGZyb20gJy4uL3V0aWxzL2NvbnN0YW5jZSc7XG5pbXBvcnQgR2hvc3ROb2RlIGZyb20gJy4uL2luc3RhbmNlL2dob3N0Tm9kZSc7XG5pbXBvcnQgeyBOb2RlV2Vha01hcE1peGluIH0gZnJvbSAnLi4vaW5zdGFuY2Uvbm9kZVdlYWtNYXAnO1xuaW1wb3J0IFN0YWNrTWl4aW4gZnJvbSAnLi4vaW5zdGFuY2Uvc3RhY2tNaXhpbic7XG5pbXBvcnQgTGF5b3V0TWl4aW4gZnJvbSAnLi4vaW5zdGFuY2UvbGF5b3V0TWl4aW4nO1xuaW1wb3J0IE1lc3NhZ2VNaXhpbiBmcm9tICcuLi9pbnN0YW5jZS9tZXNzYWdlTWl4aW4nO1xuaW1wb3J0IEFuaW1lTWl4aW4gZnJvbSAnLi4vYW5pbWUvYW5pbWVNaXhpbic7XG5pbXBvcnQgTWluaU1hcE1peGluIGZyb20gJy4uL21pbmlNYXAvbWluaW1hcC1taXhpbic7XG5pbXBvcnQgU2Nyb2xsQmFyTWl4aW4gZnJvbSAnLi4vc2Nyb2xsYmFyL3Njcm9sbGJhck1peGluJztcbmltcG9ydCBTY2hlZHVsZU1peGluIGZyb20gJy4vc2NoZWR1bGUnO1xuLy8gaW1wb3J0IHsgc2V0VW5pcXVlSWQsIGdldFVuaXF1ZUlkIH0gZnJvbSAnLi4vdXRpbHMvZnVuY3Rpb25zJztcbmltcG9ydCBKRmxvd0V2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5cbmltcG9ydCBFdmVudEFkYXB0ZXIgZnJvbSAnLi4vZXZlbnRzL2FkYXB0ZXInO1xuXG5pbXBvcnQgR3JvdXBGYWN0b3J5IGZyb20gJy4uL2luc3RhbmNlL2dyb3VwRmFjdG9yeSc7XG5pbXBvcnQgUG9pbnQgZnJvbSAnLi4vaW5zdGFuY2Uvc2hhcGVzL3BvaW50JztcbmltcG9ydCBSZWN0YW5nbGUgZnJvbSAnLi4vaW5zdGFuY2Uvc2hhcGVzL3JlY3RhbmdsZSc7XG5pbXBvcnQgQ2Fwc3VsZSBmcm9tICcuLi9pbnN0YW5jZS9zaGFwZXMvY2Fwc3VsZSc7XG5pbXBvcnQgQ2Fwc3VsZVZlcnRpY2FsIGZyb20gJy4uL2luc3RhbmNlL3NoYXBlcy9jYXBzdWxlLXZlcnRpY2FsJztcbmltcG9ydCBSaG9tYnVzIGZyb20gJy4uL2luc3RhbmNlL3NoYXBlcy9yaG9tYnVzJztcbmltcG9ydCBEaWFtb25kIGZyb20gJy4uL2luc3RhbmNlL3NoYXBlcy9kaWFtb25kJztcbmltcG9ydCBEaWFtb25kVmVydGljYWwgZnJvbSAnLi4vaW5zdGFuY2Uvc2hhcGVzL2RpYW1vbmQtdmVydGljYWwnO1xuLy8gaW1wb3J0IHsgY3JlYXRlSW5wdXRUZXh0U3R5bGUgfSBmcm9tICcuLi9pbnN0YW5jZS90ZXh0Jztcbi8vIGNyZWF0ZUlucHV0VGV4dFN0eWxlKCk7XG4vKipcbiAqIEBmdW50aW9uIHNldEluaXRpYWxQb3NpdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IFJlYWxib3hYIC0g5YaF5a655pig5bCE5YiwY2FudmFz5LiK55qEIFhcbiAqIEBwYXJhbSB7TnVtYmVyfSBSZWFsYm94WSAtIOWGheWuueaYoOWwhOWIsGNhbnZhc+S4iueahCBZIFxuICogQHBhcmFtIHtOdW1iZXJ9IFJlYWxib3hXIC0g5YaF5a655pig5bCE5YiwY2FudmFz5LiK55qE5a695bqmXG4gKiBAcGFyYW0ge051bWJlcn0gUmVhbGJveEggLSDlhoXlrrnmmKDlsITliLBjYW52YXPkuIrnmoTpq5jluqYgXG4gKiBAcGFyYW0ge051bWJlcn0gQ2FudmFzV2lkdGggIC0g6KeG56qX5a695bqmXG4gKiBAcGFyYW0ge051bWJlcn0gQ2FudmFzSGVpZ2h0ICAtIOinhueql+mrmOW6plxuICogQHJldHVybiB7T2JqZWN0fSAtIOWIneWni+S9jee9riB7IHgsIHkgfVxuICovXG5cbi8qKlxuICogQGZ1bnRpb24gbGlua0dlblxuICogQHBhcmFtIHtOb2RlfSBmcm9tIC0g5Ye65Y+R57uY5Zu+6IqC54K5XG4gKiBAcGFyYW0ge05vZGV9IHRvIC0g5Li05pe26IqC54K577yM5b2T5YmN6byg5qCH5oyH55qE5Zyw5pa5XG4gKiBAcmV0dXJuIHtCYXNlZUxpbmt9IC0g6L+e57q/5a+56LGhXG4gKi9cblxuXG4vKiogXG4gKiBAY2xhc3MgR3JvdXBcbiAqIEBjbGFzc2Rlc2Mg55+p5b2i57uE5Y2V5YWDIOeUsSB7QGxpbmsgR3JvdXBGYWN0b3J5fSDpgJrov4cge0BsaW5rIFJlY3RhbmdsZX0g55Sf5oiQXG4gKiBAZ3JvdXBmcm9tIFJlY3RhbmdsZVxuICogQGF1Z21lbnRzIEdyb3VwVGVtcGxhdGVcbiAqIEBhdWdtZW50cyBSZWN0YW5nbGVcbiAqIEBwYXJhbSB7KFJlY3RhbmdsZX5SZWN0YW5nbGVDb25maWdzfEdyb3VwVGVtcGxhdGV+R3JvdXBDb25maWdzKX0gY29uZmlncyAtIOmFjee9rlxuICovXG5leHBvcnQgY29uc3QgR3JvdXAgPSBHcm91cEZhY3RvcnkoUmVjdGFuZ2xlKTtcbi8qKiBcbiAqIEBjbGFzcyBDYXBzdWxlR3JvdXBcbiAqIEBjbGFzc2Rlc2Mg6IO25ZuK57uE5Y2V5YWDIOeUsSB7QGxpbmsgR3JvdXBGYWN0b3J5fSDpgJrov4cge0BsaW5rIENhcHN1bGV9IOeUn+aIkFxuICogQGdyb3VwZnJvbSBDYXBzdWxlXG4gKiBAYXVnbWVudHMgR3JvdXBUZW1wbGF0ZVxuICogQGF1Z21lbnRzIENhcHN1bGVcbiAqIEBwYXJhbSB7KENhcHN1bGV+Q2Fwc3VsZUNvbmZpZ3N8R3JvdXBUZW1wbGF0ZX5Hcm91cENvbmZpZ3MpfSBjb25maWdzIC0g6YWN572uXG4gKi9cbmV4cG9ydCBjb25zdCBDYXBzdWxlR3JvdXAgPSBHcm91cEZhY3RvcnkoQ2Fwc3VsZSk7XG4vKiogXG4gKiBAY2xhc3MgUmhvbWJ1c0dyb3VwXG4gKiBAY2xhc3NkZXNjIOiPseW9oue7hOWNleWFgyDnlLEge0BsaW5rIEdyb3VwRmFjdG9yeX0g6YCa6L+HIHtAbGluayBSaG9tYnVzfSDnlJ/miJBcbiAqIEBhdWdtZW50cyBHcm91cFRlbXBsYXRlXG4gKiBAYXVnbWVudHMgUmhvbWJ1c1xuICogQGdyb3VwZnJvbSBSaG9tYnVzXG4gKiBAcGFyYW0geyhSaG9tYnVzflJob21idXNDb25maWdzfEdyb3VwVGVtcGxhdGV+R3JvdXBDb25maWdzKX0gY29uZmlncyAtIOmFjee9rlxuICovXG5leHBvcnQgY29uc3QgUmhvbWJ1c0dyb3VwID0gR3JvdXBGYWN0b3J5KFJob21idXMpO1xuLyoqIFxuICogQGNsYXNzIERpYW1vbmRHcm91cFxuICogQGNsYXNzZGVzYyDpkrvnn7PlvaLnu4TljZXlhYMg55SxIHtAbGluayBHcm91cEZhY3Rvcnl9IOmAmui/hyB7QGxpbmsgRGlhbW9uZH0g55Sf5oiQXG4gKiBAZ3JvdXBmcm9tIERpYW1vbmRcbiAqIEBhdWdtZW50cyBHcm91cFRlbXBsYXRlXG4gKiBAYXVnbWVudHMgRGlhbW9uZFxuICogQHBhcmFtIHsoRGlhbW9uZH5EaWFtb25kQ29uZmlnc3xHcm91cFRlbXBsYXRlfkdyb3VwQ29uZmlncyl9IGNvbmZpZ3MgLSDphY3nva5cbiAqL1xuZXhwb3J0IGNvbnN0IERpYW1vbmRHcm91cCA9IEdyb3VwRmFjdG9yeShEaWFtb25kLCB7XG4gICAgc2hhcGVTaGlmdCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBbd2lkdGggKyBoZWlnaHQgKiAwLjI4ODY1LCBoZWlnaHRdXG4gICAgfVxufSk7XG4vKiogXG4gKiBAY2xhc3MgRGlhbW9uZFZlcnRpY2FsR3JvdXBcbiAqIEBjbGFzc2Rlc2Mg5Z6C55u06ZK755+z5b2i57uE5Y2V5YWDIOeUsSB7QGxpbmsgR3JvdXBGYWN0b3J5fSDpgJrov4cge0BsaW5rIERpYW1vbmRWZXJ0aWNhbH0g55Sf5oiQXG4gKiBAZ3JvdXBmcm9tIERpYW1vbmRWZXJ0aWNhbFxuICogQGF1Z21lbnRzIEdyb3VwVGVtcGxhdGVcbiAqIEBhdWdtZW50cyBEaWFtb25kVmVydGljYWxcbiAqIEBwYXJhbSB7KERpYW1vbmR+RGlhbW9uZENvbmZpZ3N8R3JvdXBUZW1wbGF0ZX5Hcm91cENvbmZpZ3MpfSBjb25maWdzIC0g6YWN572uXG4gKi9cbmV4cG9ydCBjb25zdCBEaWFtb25kVmVydGljYWxHcm91cCA9IEdyb3VwRmFjdG9yeShEaWFtb25kVmVydGljYWwsIHtcbiAgICBzaGFwZVNoaWZ0KHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIFt3aWR0aCwgaGVpZ2h0ICsgd2lkdGggKiAwLjU3NzNdXG4gICAgfVxufSk7XG4vKiogXG4gKiBAY2xhc3MgQ2Fwc3VsZVZlcnRpY2FsR3JvdXBcbiAqIEBjbGFzc2Rlc2Mg5Z6C55u06ZK755+z5b2i57uE5Y2V5YWDIOeUsSB7QGxpbmsgR3JvdXBGYWN0b3J5fSDpgJrov4cge0BsaW5rIENhcHN1bGVWZXJ0aWNhbH0g55Sf5oiQXG4gKiBAZ3JvdXBmcm9tIENhcHN1bGVWZXJ0aWNhbFxuICogQGF1Z21lbnRzIEdyb3VwVGVtcGxhdGVcbiAqIEBhdWdtZW50cyBDYXBzdWxlVmVydGljYWxcbiAqIEBwYXJhbSB7KENhcHN1bGV+Q2Fwc3VsZUNvbmZpZ3N8R3JvdXBUZW1wbGF0ZX5Hcm91cENvbmZpZ3MpfSBjb25maWdzIC0g6YWN572uXG4gKi9cbmV4cG9ydCBjb25zdCBDYXBzdWxlVmVydGljYWxHcm91cCA9IEdyb3VwRmFjdG9yeShDYXBzdWxlVmVydGljYWwpO1xuXG5leHBvcnQgY29uc3QgUG9pbnRHcm91cCA9IEdyb3VwRmFjdG9yeShQb2ludCwge1xuICAgIHNoYXBlU2hpZnQod2lkdGgsIGhlaWdodCwgcCkge1xuICAgICAgICBjb25zdCByID0gTWF0aC5jZWlsKE1hdGguc3FydCh3aWR0aCAqIHdpZHRoICsgaGVpZ2h0ICogaGVpZ2h0KSAvIDIpO1xuICAgICAgICBwLnJhZGl1cyA9IHI7XG4gICAgICAgIGNvbnN0IHcgPSByICogMjtcbiAgICAgICAgcmV0dXJuIFt3LCB3XTtcbiAgICB9XG59KTtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTY3JvbGxHcm91cCB9IGZyb20gJy4uL2luc3RhbmNlL2dyb3Vwcy9zY3JvbGwtZ3JvdXAnOyBcbi8qKlxuICogQHR5cGVkZWYgSkZsb3d+SkZsb3dDb25maWdzXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtCb29sZWFufSBhbGxvd0Ryb3AgICAgICAtIOaYr+WQpuWFgeiuuCBkcmFnZHJvcFxuICogQHByb3BlcnR5IHtOdW1iZXJ9IG1heFpvb20gICAgICAgICAtIOacgOWkp+e8qeaUvlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IG1pblpvb20gICAgICAgICAtIOacgOWwj+e8qeaUvlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGluaXRpYWxab29tICAgICAtIOWIneWni+e8qeaUvuavlFxuICogQHByb3BlcnR5IHtFdmVudEFkYXB0ZXJ+cGx1Z2luRGVmfSBldmVudEFkYXB0ZXJcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtKRmxvd35KRmxvd0NvbmZpZ3MgfCBMYXlvdXRNaXhpbn5MYXlvdXRDb25maWdzfSBKRmxvd35KRmxvd0xheW91dENvbmZpZ3NcbiAqL1xuLyoqIFxuICogSkZsb3cg5a+56LGhXG4gKiBKRmxvdyDmmK8gY2FudmFzIOS4iumdouWwgeijheeahOS4gOS4qumhtuWxguWvueixoe+8jOWFt+acieWkhOeQhuS6i+S7tuWSjOe7mOWItueahOWKn+iDvVxuICogQGNvbnN0cnVjdG9yIEpGbG93XG4gKiBAcGFyYW0ge0pGbG93fkpGbG93TGF5b3V0Q29uZmlnc30gY29uZmlncyAtIOmFjee9rumhuVxuICogQG1peGVzIExheW91dE1peGluXG4gKiBAbWl4ZXMgU3RhY2tNaXhpblxuICogQG1peGVzIE1lc3NhZ2VNaXhpblxuICovXG5jbGFzcyBKRmxvdyBleHRlbmRzIEV2ZW50VGFyZ2V0e1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3MpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy51bmlxdWVOYW1lID0gJ2pmbG93JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0V2ZW50QWRhcHRlcn0gZXZlbnRBZGFwdGVyICAgIC0gZXZlbnRBZGFwdGVyIOWvueixoVxuICAgICAgICAgKiovXG4gICAgICAgIHRoaXMuZXZlbnRBZGFwdGVyID0gbmV3IEV2ZW50QWRhcHRlcihjb25maWdzLmV2ZW50QWRhcHRlcik7XG4gICAgICAgIHRoaXMuaW5pdE5vZGVXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMuaW5pdEFuaW1lKCk7XG4gICAgICAgIHRoaXMuaW5pdFN0YWNrKGNvbmZpZ3MpO1xuICAgICAgICB0aGlzLmluaXRMYXlvdXQoY29uZmlncyk7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtDb250ZXh0MmR9ICAgICAtIENvbnRleHQyZCDlr7nosaEgKi9cbiAgICAgICAgdGhpcy5jdHggPSBudWxsO1xuICAgICAgICAvKiogQG1lbWJlciB7RWxlbWVudH0gICAgICAgLSBjYW52YXMg5YWD57SgICovXG4gICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgICAgLyoqIEBtZW1iZXIge251bWJlcn0gICAgICAgLSDorr7lpIdEUFIgKi9cbiAgICAgICAgdGhpcy5kcHIgPSAxO1xuICAgICAgICAvKiogQG1lbWJlciB7bnVtYmVyfSAgICAgICAtIOWGhei+uei3nSAqL1xuICAgICAgICB0aGlzLnBhZGRpbmcgPSAyMDtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG51bGw7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtudW1iZXJ9ICAgICAtIOe8qeaUviAqL1xuXHRcdHRoaXMuc2NhbGUgPSBudWxsO1xuICAgICAgICAvKiogQG1lbWJlciB7bnVtYmVyfSAgICAgLSDliJ3lp4vnvKnmlL4gKi9cbiAgICAgICAgdGhpcy5pbml0aWFsWm9vbSA9IGNvbmZpZ3MuaW5pdGlhbFpvb207XG4gICAgICAgIC8qKiBAbWVtYmVyIHtzZXRJbml0aWFsUG9zaXRpb259IC0g5Yid5aeL5L2N572u6K6h566XICovXG4gICAgICAgIHRoaXMuaW5pdGlhbFBvc2l0aW9uID0gY29uZmlncy5zZXRJbml0aWFsUG9zaXRpb247XG4gICAgICAgIC8qKiBAbWVtYmVyIHtudW1iZXJ9ICAgICAtIOacgOWkp+e8qeaUviAqL1xuICAgICAgICB0aGlzLm1heFpvb20gPSBjb25maWdzLm1heFpvb20gfHwgMztcbiAgICAgICAgLyoqIEBtZW1iZXIge251bWJlcn0gICAgIC0g5pyA5bCP57yp5pS+ICovXG4gICAgICAgIHRoaXMubWluWm9vbSA9IGNvbmZpZ3MubWluWm9vbSB8fCAuNTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuTm9kZVJlbmRlclRvcCA9ICEhY29uZmlncy5Ob2RlUmVuZGVyVG9wXG5cbiAgICAgICAgdGhpcy53b3JsZE1hcmdpbiA9IGNvbmZpZ3Mud29ybGRNYXJnaW47XG5cbiAgICAgICAgdGhpcy5kcmFnZ2luZ2JlaGF2aW9yID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBwYW5JbkJvcmRlcjoge1xuICAgICAgICAgICAgICAgIGVuYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAyMCxcbiAgICAgICAgICAgICAgICBkZWx0YW1vdmVtZW50OiA4LFxuICAgICAgICAgICAgICAgIGFsbG93TW92aW5nVGFyZ2V0SW5QYW46IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LCBjb25maWdzLmRyYWdnaW5nYmVoYXZpb3IgfHwge30pO1xuICAgICAgICB0aGlzLnNjcm9sbEJhckJlaGF2aW9yID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBlbmFibGU6IHRydWUsXG4gICAgICAgIH0sIGNvbmZpZ3Muc2Nyb2xsQmFyQmVoYXZpb3IgfHwge30pXG5cdFx0Ly8gdGhpcy5pbml0U2NhbGUgPSAxO1xuXHRcdC8vIHRoaXMuaW5pdFBvc2l0aW9uID0gbnVsbFxuXHRcdHRoaXMub2ZmZXNldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xhc3RTdGF0ZSA9IHtcbiAgICAgICAgICAgIHg6IG51bGwsXG4gICAgICAgICAgICB5OiBudWxsLFxuICAgICAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAgICAgcHJvY2Vzc2luZzogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbGFzdERyYWdTdGF0ZSA9IHtcbiAgICAgICAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICAgICAgIHRhcmdldExpbms6IG51bGwsXG4gICAgICAgICAgICBwcm9jZXNzaW5nOiBmYWxzZSxcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RhcmdldCA9IHtcbiAgICAgICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICAgICAgbGluazogbnVsbCxcbiAgICAgICAgICAgIG1vdmluZzogbnVsbCxcbiAgICAgICAgICAgIGlzSW5zdGFuY2VEaXJ0eTogZmFsc2UsIFxuICAgICAgICAgICAgaXNMaW5rRGlydHk6IGZhbHNlLCBcbiAgICAgICAgICAgIC8vIGlzTW92aW5nRGlydHk6IGZhbHNlLCBcbiAgICAgICAgICAgIGNhY2hlOiB7XG4gICAgICAgICAgICAgICAgc3RhY2s6IG51bGwsXG4gICAgICAgICAgICAgICAgYmVsb25nczogbnVsbCxcbiAgICAgICAgICAgICAgICBwb2ludDogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgeDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBpbml0aWFsWDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGluaXRpYWxZOiB1bmRlZmluZWQsIFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgIGRyYWdvdmVyaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgbW92aW5nU3RhdGU6IGZhbHNlLFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZm9jdXMgPSB7XG4gICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2RyYWdPdmVyVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgLy8gdGhpcy5sb2NrID0gY29uZmlncy5sb2NrO1xuXG4gICAgICAgIHRoaXMuYWxsb3dEcm9wID0gY29uZmlncy5hbGxvd0Ryb3A7XG4gICAgICAgIC8vIOS4tOaXtue7mOWItueahOWvueixoVxuICAgICAgICB0aGlzLl90ZW1wTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RlbXBMaW5rID0gbnVsbDtcblxuICAgICAgICB0aGlzLm1vZGUgPSBKRkxPV19NT0RFLkRFRkFVTFQ7XG5cbiAgICAgICAgdGhpcy5fYWxsb3dNb3ZpbmdUYXJnZXQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuY2FudmFzTWV0YSA9IHt9XG5cbiAgICAgICAgdGhpcy5fY2FjaGVWaWV3Qm94ID0gW11cblxuICAgICAgICB0aGlzLl9fbW91bnRlZF9fID0gZmFsc2U7XG5cbiAgICAgICAgLy8gdGhpcy5fYWxsb3dab29tID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBhbGxvd1pvb20oKSB7XG4gICAgLy8gICAgIHRoaXMuX2FsbG93Wm9vbSA9IHRydWU7XG4gICAgLy8gfVxuXG4gICAgLy8gYWJhbmRvblpvb20oKSB7XG4gICAgLy8gICAgIHRoaXMuX2FsbG93Wm9vbSA9IGZhbHNlO1xuICAgIC8vIH1cbiAgICAvKipcbiAgICAgKiDorr7nva7lvZPliY3mi5bliqjnmoQgSkZsb3cg5a+56LGhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gdGFyZ2V0cyAtIOWFt+aciSBhbmNob3Ig5bGe5oCn55qE5a+56LGhXG4gICAgICovXG4gICAgc2V0TW92aW5nVGFyZ2V0cyh0YXJnZXRzKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fdGFyZ2V0LCB7XG4gICAgICAgICAgICBtb3Zpbmc6IHRhcmdldHMsICAgICAgIFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuvue9ruW9k+WJjeaLluWKqOeahCBKRmxvdyDlr7nosaFcbiAgICAgKiBAcGFyYW0ge0luc3RhbmNlfSBpbnN0YW5jZSAtIEpGbG93IOWvueixoVxuICAgICAqL1xuICAgIHNldFRlbXBEcmFnZ2luZ0luc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgICAgIGluc3RhbmNlLl9iZWxvbmdzID0gdGhpcztcbiAgICAgICAgdGhpcy5fdGVtcE5vZGUgPSBpbnN0YW5jZTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl90YXJnZXQsIHtcbiAgICAgICAgICAgIG1vdmluZzogW3RoaXMuX3RlbXBOb2RlXSxcbiAgICAgICAgICAgIGRyYWdnaW5nOiB0cnVlLFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWPlua2iOW9k+WJjeaLluWKqOeahCBKRmxvdyDlr7nosaFcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJbXX0gcG9pbnQgLSBKRmxvdyDlnZDmoIdcbiAgICAgKi9cbiAgICByZW1vdmVUZW1wRHJhZ2dpbmdJbnN0YW5jZSgpIHtcbiAgICAgICAgaWYodGhpcy5fdGVtcE5vZGUpIHtcbiAgICAgICAgICAgIC8vIHRoaXMucmVtb3ZlRnJvbVN0YWNrKHRoaXMuX3RlbXBOb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuX3RlbXBOb2RlLmFuY2hvcjtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBOb2RlID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBhbmNob3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICog5YWz6Zet6buY6K6k5a+56LGh5ouW5Yqo5pWI5p6cXG4gICAgICovXG4gICAgcHJldmVudERlZmF1bHREcmFnZ2luZygpIHtcbiAgICAgICAgdGhpcy5fYWxsb3dNb3ZpbmdUYXJnZXQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog5byA5ZCv6buY6K6k5a+56LGh5ouW5Yqo5pWI5p6cXG4gICAgICovXG4gICAgYWxsb3dEZWZhdWx0RHJhZ2dpbmcoKSB7XG4gICAgICAgIHRoaXMuX2FsbG93TW92aW5nVGFyZ2V0ID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog5ZyoIERvY3VtZW50IOWFg+e0oOS4iuWIneWni+WMluWunuS+i1xuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZG9tIFxuICAgICAqL1xuICAgICRtb3VudChkb20pIHtcbiAgICAgICAgY29uc3QgeyBcbiAgICAgICAgICAgIGNhbnZhcywgXG4gICAgICAgICAgICBjdHgsIFxuICAgICAgICAgICAgc2NhbGU6IGRwciwgXG4gICAgICAgICAgICB3aWR0aDogY193aWR0aCwgXG4gICAgICAgICAgICBoZWlnaHQ6IGNfaGVpZ2h0LCBcbiAgICAgICAgICAgIHJhd193aWR0aCxcbiAgICAgICAgICAgIHJhd19oZWlnaHQsXG4gICAgICAgICAgICBsZWZ0LCB0b3AgXG4gICAgICAgIH0gPSBjcmVhdGVDYW52YXMoZG9tKTtcbiAgICAgICAgdGhpcy5yZWZsb3coKTtcbiAgICAgICAgdGhpcy5jdHggPSBjdHggLy9uZXcgQ2FudmFzQ29udGV4dDJkKGN0eCwgZHByKTtcbiAgICAgICAgdGhpcy5ET013cmFwcGVyID0gZG9tO1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgdGhpcy5jYW52YXMuc2V0QXR0cmlidXRlKCdkYXRhLWpmbG93JywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuY2FudmFzLiRqZmxvdyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2FudmFzTWV0YSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiByYXdfd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHJhd19oZWlnaHQsXG4gICAgICAgICAgICBhY3R1YWxfd2lkdGg6IGNfd2lkdGgsXG4gICAgICAgICAgICBhY3R1YWxfaGVpZ2h0OiBjX2hlaWdodFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHByID0gZHByO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5fZ2V0Qm91bmRpbmdHcm91cFJlY3QoKTtcblxuICAgICAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5wYWRkaW5nO1xuICAgICAgICBjb25zdCB7IHdpZHRoOiBwX3dpZHRoLCBoZWlnaHQ6IHBfaGVpZ2h0LCB4OiBwX3gsIHk6IHBfeSB9ID0gdGhpcy5ib3VuZGluZ19ib3g7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRCb3ggPSB7XG4gICAgICAgICAgICB4OiBwYWRkaW5nLFxuICAgICAgICAgICAgeTogcGFkZGluZyxcbiAgICAgICAgICAgIHdpZHRoOiBjX3dpZHRoIC0gcGFkZGluZyAqIDIsXG4gICAgICAgICAgICBoZWlnaHQ6IGNfaGVpZ2h0IC0gcGFkZGluZyAqIDIsXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB7IHg6IDAsIHk6IDAsIG9mZnNldFg6IDAsIG9mZnNldFk6IDAgfTtcbiAgICAgICAgY29uc3Qgd19yYXRpbyA9IGNvbnRlbnRCb3gud2lkdGggLyBwX3dpZHRoO1xuICAgICAgICBjb25zdCBoX3JhdGlvID0gY29udGVudEJveC5oZWlnaHQgLyBwX2hlaWdodDtcbiAgICAgICAgY29uc3QgYWxpZ24gPSB3X3JhdGlvIDw9IGhfcmF0aW8gPyAneCcgOiAneSc7XG4gICAgICAgIGxldCBzY2FsZVJhdGlvO1xuICAgICAgICBpZih0aGlzLmluaXRpYWxab29tKSB7XG4gICAgICAgICAgICBzY2FsZVJhdGlvID0gdGhpcy5pbml0aWFsWm9vbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjYWxlUmF0aW8gPSBNYXRoLm1pbih3X3JhdGlvLCBoX3JhdGlvKTtcbiAgICAgICAgfVxuICAgICAgIFxuICAgICAgICB0aGlzLnNjYWxlID0gc2NhbGVSYXRpbztcbiAgICAgICAgaWYoc2NhbGVSYXRpbyA+IHRoaXMubWF4Wm9vbSkge1xuICAgICAgICAgICAgdGhpcy5tYXhab29tID0gc2NhbGVSYXRpbztcbiAgICAgICAgfVxuICAgICAgICBpZihzY2FsZVJhdGlvIDwgdGhpcy5taW5ab29tKSB7XG4gICAgICAgICAgICB0aGlzLm1pblpvb20gPSBzY2FsZVJhdGlvO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlYWxib3hYID0gcF94ICogc2NhbGVSYXRpbztcbiAgICAgICAgY29uc3QgcmVhbGJveFkgPSBwX3kgKiBzY2FsZVJhdGlvO1xuICAgICAgICBjb25zdCByZWFsYm94VyA9IGNvbnRlbnRCb3gud2lkdGg7XG4gICAgICAgIGNvbnN0IHJlYWxib3hIID0gY29udGVudEJveC5oZWlnaHQ7XG4gICAgICAgIGlmKHRoaXMuaW5pdGlhbFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMuaW5pdGlhbFBvc2l0aW9uKHJlYWxib3hYLCByZWFsYm94WSwgcmVhbGJveFcsIHJlYWxib3hILCBjb250ZW50Qm94LngsIGNvbnRlbnRCb3gueSwgY193aWR0aCwgY19oZWlnaHQsIHBfeCwgcF95LCBwX3dpZHRoLCBwX2hlaWdodCk7XG4gICAgICAgICAgICBwb3NpdGlvbi54ID0geDtcbiAgICAgICAgICAgIHBvc2l0aW9uLnkgPSB5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zaXRpb24ueCA9IGFsaWduID09PSAneCcgPyBjb250ZW50Qm94LnggOiAocmVhbGJveFcgLSBwX3dpZHRoICogc2NhbGVSYXRpbykgLyAyICsgcGFkZGluZ1xuICAgICAgICAgICAgcG9zaXRpb24ueSA9IGFsaWduID09PSAneScgPyBjb250ZW50Qm94LnkgOiAocmVhbGJveEggLSBwX2hlaWdodCAqIHNjYWxlUmF0aW8pIC8gMiArIHBhZGRpbmdcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcG9zaXRpb24ub2Zmc2V0WCA9IHBvc2l0aW9uLnggLSByZWFsYm94WDtcbiAgICAgICAgcG9zaXRpb24ub2Zmc2V0WSA9IHBvc2l0aW9uLnkgLSByZWFsYm94WTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICB0aGlzLl9yZWFkeVRvUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgaWYodGhpcy5zY3JvbGxCYXJCZWhhdmlvci5lbmFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdFNjcm9sbEJhcih0aGlzLnNjcm9sbEJhckJlaGF2aW9yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzLmluaXRTY2hlZHVsZSgpO1xuICAgICAgICAvLyB0aGlzLnNjaGVkdWxlUmVuZGVyKCgpID0+IHtcbiAgICAgICAgLy8gICAgIHRoaXMuX2NyZWF0ZUV2ZW50SGFuZGxlcigpO1xuICAgICAgICAvLyB9KTtcbiAgICAgICAgdGhpcy5fX3JlbmRlcigpO1xuICAgICAgICB0aGlzLl9jcmVhdGVFdmVudEhhbmRsZXIoKTtcbiAgICAgICAgXG4gICAgICAgIGxpc3Rlbk9uRGV2aWNlUGl4ZWxSYXRpbygoZHByKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRwciA9IGRwcjtcbiAgICAgICAgICAgIC8vIHRoaXMuY3R4LnNldERQUihkcHIpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZUNhbnZhcygpO1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICB9LCAoaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95RHByTGlzdGVuZXIgPSBoYW5kbGVyO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fX21vdW50ZWRfXyA9IHRydWU7XG4gICAgICAgIFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuvue9rkpmbG936L+b5YWl6L+e57q/5qih5byPXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSAtIOW9k+WJjei/nue6v+eahOWHuuWPkeWOn+Wni+aVsOaNrlxuICAgICAqIEBwYXJhbSB7bGlua0dlbn0gbGlua0dlbiAtIOeUn+aIkOi/nue6v+WNleWFg+eahOaWueazlVxuICAgICAqL1xuICAgIHNldExpbmtpbmdNb2RlKHNvdXJjZSwgbGlua0dlbiwgaXNUYWlsKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlck5vZGUgPSB0aGlzLmdldFJlbmRlck5vZGVCeVNvdXJjZShzb3VyY2UpXG4gICAgICAgIHRoaXMuX3RlbXBOb2RlID0gbmV3IEdob3N0Tm9kZSgpO1xuICAgICAgICBpZihpc1RhaWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBMaW5rID0gbGlua0dlbih7XG4gICAgICAgICAgICAgICAgZnJvbTogdGhpcy5fdGVtcE5vZGUsXG4gICAgICAgICAgICAgICAgdG86IHJlbmRlck5vZGUsXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdGVtcExpbmsgPSBsaW5rR2VuKHtcbiAgICAgICAgICAgICAgICBmcm9tOiByZW5kZXJOb2RlLFxuICAgICAgICAgICAgICAgIHRvOiB0aGlzLl90ZW1wTm9kZSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgaW5zdGFuY2U6IHNvdXJjZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tb2RlID0gSkZMT1dfTU9ERS5MSU5LSU5HO1xuICAgIH1cblxuICAgIGlzSW5MaW5raW5nTW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZSA9PT0gSkZMT1dfTU9ERS5MSU5LSU5HO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOi/nue6v+aooeW8j+S4i++8jOiuvue9ruW9k+WJjeS4tOaXtui/nue6v+eahOWxnuaAp1xuICAgICAqIEBwYXJhbSB7QmFzZUxpbmt+Q29uZmlnc30gY29uZmlncyAtIOW9k+WJjei/nue6v+eahOWHuuWPkeWOn+Wni+aVsOaNrlxuICAgICAqL1xuICAgIHNldExpbmtpbmdMaW5rKGNvbmZpZ3MpIHtcbiAgICAgICAgaWYodGhpcy5tb2RlID09PSBKRkxPV19NT0RFLkxJTktJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBMaW5rLnNldENvbmZpZyhjb25maWdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiDov57nur/mqKHlvI/kuIvvvIzph43ov57lm57kuLTml7bpvKDmoIfoioLngrlcbiAgICAgKi9cbiAgICByZXNldExpbmtpbmdMaW5rKCkge1xuICAgICAgICBpZih0aGlzLm1vZGUgPT09IEpGTE9XX01PREUuTElOS0lORykge1xuICAgICAgICAgICAgdGhpcy5fdGVtcExpbmsuc2V0Q29uZmlnKHtcbiAgICAgICAgICAgICAgICB0bzogdGhpcy5fdGVtcE5vZGVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGVhclRlbXAoKSB7XG4gICAgICAgIGlmKHRoaXMuX3RlbXBOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl90ZW1wTm9kZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLl90ZW1wTm9kZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5fdGVtcExpbmspIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBMaW5rLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBMaW5rID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB9XG5cbiAgICBwcmV2ZW50Q2xlYXJUZW1wKCkge1xuICAgICAgICB0aGlzLl9wcmV2ZW50Q2xlYXJUZW1wID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlpJblsYLlrrnlmajlpKflsI/lj5jljJblkI7vvIzosIPnlKjmraTmlrnms5Xlj6/ku6XmlLnlj5jlvZPliY1jYW52YXPnmoTnirbmgIFcbiAgICAgKi9cbiAgICByZXNpemVDYW52YXMoKSB7XG4gICAgICAgIGlmKHRoaXMuY2FudmFzICYmIHRoaXMuRE9Nd3JhcHBlcikge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBjX3dpZHRoLCBcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGNfaGVpZ2h0LCBcbiAgICAgICAgICAgICAgICByYXdfd2lkdGgsXG4gICAgICAgICAgICAgICAgcmF3X2hlaWdodCxcbiAgICAgICAgICAgIH0gPSByZXNpemVDYW52YXModGhpcy5jYW52YXMsIHRoaXMuRE9Nd3JhcHBlcik7XG4gICAgICAgICAgICB0aGlzLmNhbnZhc01ldGEgPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHJhd193aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHJhd19oZWlnaHQsXG4gICAgICAgICAgICAgICAgYWN0dWFsX3dpZHRoOiBjX3dpZHRoLFxuICAgICAgICAgICAgICAgIGFjdHVhbF9oZWlnaHQ6IGNfaGVpZ2h0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRGb2N1c0luc3RhbmNlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5fZm9jdXMuaW5zdGFuY2UgPSBub2RlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOenu+WKqOeUu+W4g+WIsOS7peebruagh+e7mOWbvuiKgueCueS4uuS4reW/g+eahOS9jee9ruS4ilxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIOe7mOWbvuiKgueCuVxuICAgICAqL1xuICAgIGZvY3VzT24obm9kZSkge1xuICAgICAgICBjb25zdCBjZW50ZXIgPSB0aGlzLl9jYWxjdWxhdGVQb2ludEJhY2soW1xuICAgICAgICAgICAgdGhpcy5jYW52YXNNZXRhLmFjdHVhbF93aWR0aC8yLFxuICAgICAgICAgICAgdGhpcy5jYW52YXNNZXRhLmFjdHVhbF9oZWlnaHQvMlxuICAgICAgICBdKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IG5vZGUuYW5jaG9yO1xuICAgICAgICBpZihub2RlLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBub2RlLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKG9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZWx0YVggPSAoY2VudGVyWzBdIC0gb2Zmc2V0WzBdKSAqIHRoaXMuc2NhbGU7XG4gICAgICAgIGNvbnN0IGRlbHRhWSA9IChjZW50ZXJbMV0gLSBvZmZzZXRbMV0pICogdGhpcy5zY2FsZTtcbiAgICAgICAgXG5cbiAgICAgICAgdGhpcy5fcmVjYWxjdWxhdGVQb3NpdGlvbihkZWx0YVgsIGRlbHRhWSlcbiAgICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgfVxuICAgIFxuICAgIF9nZXRCb3VuZGluZ0dyb3VwUmVjdCgpIHtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gdGhpcy5fc3RhY2suZ2V0Qm91bmRpbmdSZWN0UG9pbnRzKCk7XG4gICAgICAgIGlmKHRoaXMuYm91bmRpbmdfYm94KSB7XG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nX2JveCA9IGJvdW5kaW5nX2JveChwb2ludHMpO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHg6IG5vd3gsXG4gICAgICAgICAgICAgICAgeTogbm93eSxcbiAgICAgICAgICAgIH0gPSB0aGlzLmJvdW5kaW5nX2JveDtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ueCA9IHRoaXMucG9zaXRpb24ub2Zmc2V0WCArIG5vd3ggKiBzY2FsZTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ueSA9IHRoaXMucG9zaXRpb24ub2Zmc2V0WSArIG5vd3kgKiBzY2FsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdfYm94ID0gYm91bmRpbmdfYm94KHBvaW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY3JlYXRlRXZlbnRIYW5kbGVyKCkgeyBcbiAgICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICAgIGxldCBkZXN0cm95TGlzdGVuZXI7XG4gICAgICAgIHRoaXMuZXZlbnRBZGFwdGVyLmFwcGx5KHRoaXMpO1xuICAgICAgICBjb25zdCBkZXN0cm95UGxhaW5FdmVudExpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ldmVudEFkYXB0ZXIudW5sb2FkKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95RHByTGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0cm95TGlzdGVuZXIgPSBkZXN0cm95UGxhaW5FdmVudExpc3RlbmVyO1xuXG4gICAgICAgIGlmKHRoaXMuYWxsb3dEcm9wKSB7XG4gICAgICAgICAgICBjb25zdCBkcmFnb3ZlckhhbmRsZXIgPSB0aGlzLl9vbkRyYWdvdmVyLmJpbmQodGhpcyk7XG4gICAgICAgICAgICBjb25zdCBkcm9wSGFuZGxlciA9IHRoaXMuX29uRHJvcC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgZHJhZ2xlYXZlSGFubGRlciA9IHRoaXMuX29uRHJhZ0xlYXZlLmJpbmQodGhpcyk7XG4gICAgICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCBkcmFnb3ZlckhhbmRsZXIpO1xuICAgICAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCBkcm9wSGFuZGxlcik7XG4gICAgICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2xlYXZlJywgZHJhZ2xlYXZlSGFubGRlcik7XG4gICAgICAgICAgICBkZXN0cm95TGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVzdHJveVBsYWluRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIGRyYWdvdmVySGFuZGxlcik7XG4gICAgICAgICAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCBkcm9wSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdsZWF2ZScsIGRyYWdsZWF2ZUhhbmxkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IFxuICAgICAgICB0aGlzLmRlc3Ryb3kgPSBkZXN0cm95TGlzdGVuZXI7XG4gICAgfVxuXG4gICAgX3RhcmdldExvY2tPbihvZmZzZXRQb2ludCwgZXZlbnQpIHtcbiAgICAgICAgbGV0IHBvaW50ID0gdGhpcy5fY2FsY3VsYXRlUG9pbnRCYWNrKG9mZnNldFBvaW50KTtcbiAgICAgICAgY29uc3QgdG9wTGF5ZXJQb2ludCA9IHBvaW50O1xuICAgICAgICB0aGlzLl9jdXJyZW50cCA9IHBvaW50O1xuICAgICAgICBsZXQgc3RhY2sgPSB0aGlzLl9zdGFjaztcbiAgICAgICAgY29uc3QgYnIgPSB0aGlzLl9nZXRWaWV3Qm94KCk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHN0YWNrLmNoZWNrSGl0KFxuICAgICAgICAgICAgcG9pbnQsIFxuICAgICAgICAgICAgLy8g5bqU55So5LqO5omA5pyJXG4gICAgICAgICAgICAoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuX3RhcmdldC5zdGF0dXMuZHJhZ2dpbmcgXG4gICAgICAgICAgICAgICAgICAgICYmIChpbnN0YW5jZSA9PT0gdGhpcy5fZ2V0TW92aW5nVGFyZ2V0KCkpKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIOS7heWvueS6juacrOWxgui/h+a7pFxuICAgICAgICAgICAgKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvT3ZlcmxhcChiciwgaW5zdGFuY2UuZ2V0Qm91bmRpbmdSZWN0KCkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgbGV0IGxpbmtTdGFjayA9IHRoaXMuX2xpbmtTdGFjaztcbiAgICAgICAgbGV0IGJlbG9uZ3MgPSB0aGlzO1xuICAgICAgICAvKlxuICAgICAgICBpZih0YXJnZXQpIHtcbiAgICAgICAgICAgIGxpbmtTdGFjayA9IHRhcmdldC5fYmVsb25ncy5fbGlua1N0YWNrO1xuICAgICAgICAgICAgcG9pbnQgPSB0YXJnZXQuX2JlbG9uZ3MuX2N1cnJlbnRwO1xuICAgICAgICAgICAgc3RhY2sgPSB0YXJnZXQuX2JlbG9uZ3MuX3N0YWNrO1xuICAgICAgICAgICAgYmVsb25ncyA9IHRhcmdldC5fYmVsb25nc1xuICAgICAgICB9Ki9cbiAgICAgICAgLy8g5pqC5pe26K6+5a6a5Y+q5pyJ6aG25bGC5pyJ6L+e57q/XG4gICAgICAgIGxldCB0YXJnZXRMaW5rO1xuICAgICAgICBpZighdGFyZ2V0IHx8IHRhcmdldC5fYmVsb25ncyA9PT0gdGhpcykge1xuICAgICAgICAgICAgdGFyZ2V0TGluayA9IGxpbmtTdGFjay5jaGVja0hpdChwb2ludCwgKGxpbmspID0+IHtcbiAgICAgICAgICAgICAgICBpZighdGhpcy5fdGFyZ2V0LnN0YXR1cy5kcmFnZ2luZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG1vdmluZ3RhcmdldCA9IHRoaXMuX2dldE1vdmluZ1RhcmdldCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsaW5rLmZyb20gPT09IG1vdmluZ3RhcmdldCB8fCBsaW5rLnRvID09PSBtb3Zpbmd0YXJnZXQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZighdGFyZ2V0TGluaykge1xuICAgICAgICAgICAgdGFyZ2V0TGluayA9IGxpbmtTdGFjay5jaGVja0hpdChwb2ludCwgKGxpbmspID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWxpbmsuT05fVE9QO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fdGFyZ2V0LCB7XG4gICAgICAgICAgICBpbnN0YW5jZTogdGFyZ2V0LFxuICAgICAgICAgICAgbGluazogdGFyZ2V0TGluaywgXG4gICAgICAgICAgICBpc0luc3RhbmNlRGlydHk6IHRhcmdldCA9PT0gdGhpcy5fdGFyZ2V0Lmluc3RhbmNlLFxuICAgICAgICAgICAgaXNMaW5rRGlydHk6IHRhcmdldExpbmsgPT09IHRoaXMuX3RhcmdldC5saW5rLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl90YXJnZXQuY2FjaGUsIHtcbiAgICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgICAgYmVsb25ncyxcbiAgICAgICAgICAgIHBvaW50LFxuICAgICAgICAgICAgdG9wTGF5ZXJQb2ludCxcbiAgICAgICAgfSlcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl90YXJnZXQubWV0YSwge1xuICAgICAgICAgICAgeDogb2Zmc2V0UG9pbnRbMF0sXG4gICAgICAgICAgICB5OiBvZmZzZXRQb2ludFsxXSxcbiAgICAgICAgfSk7XG4gICAgIFxuICAgICAgICBpZihldmVudCA9PT0gJ3ByZXNzU3RhcnQnICYmICF0aGlzLl90YXJnZXQuc3RhdHVzLmRyYWdnaW5nICYmICF0aGlzLl90YXJnZXQuc3RhdHVzLmRyYWdvdmVyaW5nKSB7XG4gICAgICAgICAgICBsZXQgbW92aW5ndGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgd2hpbGUgKG1vdmluZ3RhcmdldCAmJiBtb3Zpbmd0YXJnZXQuX2JlbG9uZ3MubG9jayAmJiBtb3Zpbmd0YXJnZXQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICBtb3Zpbmd0YXJnZXQgPSBtb3Zpbmd0YXJnZXQuX2JlbG9uZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldE1vdmluZ1RhcmdldHMobW92aW5ndGFyZ2V0ICYmIFsgbW92aW5ndGFyZ2V0IF0pXG4gICAgICAgICAgICBpZihtb3Zpbmd0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAgICAgKiDlvIDlp4vmi5bmi73ml7bvvIzmi5bmi73lr7nosaHorr7nva7kuYvliY1cbiAgICAgICAgICAgICAgICAgKiBAZXZlbnQgTm9kZSNhZnRlclJlc29sdmVNb3ZpbmdUYXJnZXRcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IGV2ZW50ICAgICAgICAgICAtIOWOn+Wni+S6i+S7tiBcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0pGbG93fSBqZmxvdyAgICAgICAgICAgLSDlvZPliY1KRmxvd+WvueixoSBcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge05vZGV9IHRhcmdldCAgICAgICAgICAgLSDnm67moIfoioLngrlcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0YXJnZXQuYnViYmxlRXZlbnQobmV3IEpGbG93RXZlbnQoJ2FmdGVyUmVzb2x2ZU1vdmluZ1RhcmdldCcsIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogbW92aW5ndGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoWydwcmVzc1N0YXJ0JywgJ2NsaWNrJywgJ2RibGNsaWNrJywgJ2NvbnRleHRjbGljayddLmluY2x1ZGVzKGV2ZW50KSkge1xuICAgICAgICAgICAgaWYodGhpcy5fZm9jdXMuaW5zdGFuY2UgJiYgdGhpcy5fZm9jdXMuaW5zdGFuY2UgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZvY3VzLmluc3RhbmNlLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2JsdXInLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9jdXMuaW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgfSAgIFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXQ7XG4gICAgfVxuXG4gICAgYmx1cigpIHtcbiAgICAgICAgaWYodGhpcy5fZm9jdXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzLmluc3RhbmNlLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2JsdXInLCB7XG4gICAgICAgICAgICAgICAgcmVsYXRlZFRhcmdldDogbnVsbCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzLmluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgfSAgXG4gICAgfVxuXG4gICAgX2dldE1vdmluZ1RhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldC5tb3ZpbmcgJiYgdGhpcy5fdGFyZ2V0Lm1vdmluZ1swXTtcbiAgICB9XG5cbiAgICBfcHJvY2Vzc0RyYWdPdmVyKGluc3RhbmNlLCBldmVudCkge1xuICAgICAgICBpZih0aGlzLl9kcmFnT3ZlclRhcmdldCAhPT0gaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMucmVhZE1lc3NhZ2UoKT8uaW5zdGFuY2U7XG4gICAgICAgICAgICB0aGlzLl9kcmFnQ3VycmVudERhdGEgPSB0YXJnZXQ7XG4gICAgICAgICAgICBjb25zdCB7IHBvaW50IH0gPSB0aGlzLl90YXJnZXQuY2FjaGU7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnX3Byb2Nlc3NEcmFnT3ZlcicsIHRoaXMuX2RyYWdPdmVyVGFyZ2V0KVxuICAgICAgICAgICAgaWYodGhpcy5fZHJhZ092ZXJUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRJbnMgPSB0aGlzLl9kcmFnT3ZlclRhcmdldDtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAqIGRyYWdsZWF2ZSDpgIDlh7rkuovku7ZcbiAgICAgICAgICAgICAgICAqIEBldmVudCBJbnN0YW5jZSNkcmFnbGVhdmVcbiAgICAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0V2ZW50fSBldmVudCAgICAgICAgICAgLSDljp/lp4vkuovku7YgXG4gICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gaW5zdGFuY2UgICAgICAgLSBkcmFnbGVhdmXnmoTlr7nosaEgXG4gICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge3RhcmdldH0gdGFyZ2V0ICAgICAgICAgLSBkcmFnIOaQuuW4pueahOWvueixoe+8iOeJueaMh+S7juWklumdouaLlui/m2NhbnZhc+eahOWvueixoe+8iSBcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIG9sZElucy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdkcmFnbGVhdmUnLCB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZTogb2xkSW5zLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICogZHJhZ2VudGVyIOi/m+WFpeS6i+S7tlxuICAgICAgICAgICAgICAgICogQGV2ZW50IEluc3RhbmNlI2RyYWdlbnRlclxuICAgICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IGV2ZW50ICAgICAgICAgICAtIOWOn+Wni+S6i+S7tiBcbiAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBpbnN0YW5jZSAgICAgICAtIGRyYWdlbnRlcueahOWvueixoSBcbiAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7dGFyZ2V0fSB0YXJnZXQgICAgICAgICAtIGRyYWcg5pC65bim55qE5a+56LGh77yI54m55oyH5LuO5aSW6Z2i5ouW6L+bY2FudmFz55qE5a+56LGh77yJIFxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnZHJhZ2VudGVyJywge1xuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZHJhZ092ZXJUYXJnZXQgPSBpbnN0YW5jZTtcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMuX2RyYWdPdmVyVGFyZ2V0KXtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgKiBkcmFnb3ZlciDov5vlhaXkuovku7ZcbiAgICAgICAgICAgICogQGV2ZW50IEluc3RhbmNlI2RyYWdvdmVyXG4gICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IGV2ZW50ICAgICAgICAgICAtIOWOn+Wni+S6i+S7tiBcbiAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IGluc3RhbmNlICAgICAgIC0gZHJhZ292ZXLnmoTlr7nosaEgXG4gICAgICAgICAgICAqIEBwcm9wZXJ0eSB7dGFyZ2V0fSB0YXJnZXQgICAgICAgICAtIGRyYWcg5pC65bim55qE5a+56LGh77yI54m55oyH5LuO5aSW6Z2i5ouW6L+bY2FudmFz55qE5a+56LGh77yJIFxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2RyYWdPdmVyVGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2RyYWdvdmVyJywge1xuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy5fZHJhZ0N1cnJlbnREYXRhLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcHJvY2Vzc1BhbkluQm9yZGVyKCk7XG4gICAgfVxuXG4gICAgX3Byb2Nlc3NQYW5JbkJvcmRlcigpIHtcbiAgICAgICAgaWYodGhpcy5kcmFnZ2luZ2JlaGF2aW9yPy5wYW5JbkJvcmRlcj8uZW5hYmxlKSB7XG4gICAgICAgICAgICBpZighdGhpcy5kcmFnZ2luZ2JlaGF2aW9yLnBhbkluQm9yZGVyLnRpbWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ2JlaGF2aW9yLnBhbkluQm9yZGVyLnRpbWVyID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKERhdGUubm93KCkgLSB0aGlzLmRyYWdnaW5nYmVoYXZpb3IucGFuSW5Cb3JkZXIudGltZXIgPiA1MDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbeCwgeSwgdywgaF0gPSB0aGlzLl9jYWNoZVZpZXdCb3g7XG4gICAgICAgICAgICAgICAgY29uc3QgW3B4LCBweV0gPSB0aGlzLl9jdXJyZW50cDtcbiAgICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhbW92ZW1lbnRcbiAgICAgICAgICAgICAgICB9ID0gdGhpcy5kcmFnZ2luZ2JlaGF2aW9yLnBhbkluQm9yZGVyO1xuICAgICAgICAgICAgICAgIGxldCBkZWx0YVggPSAwO1xuICAgICAgICAgICAgICAgIGxldCBkZWx0YVkgPSAwO1xuICAgICAgICAgICAgICAgIGlmKHB4IDwgeCArIHBhZGRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFYID0gZGVsdGFtb3ZlbWVudDtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgIGlmKHB4ID4gdyAtIHBhZGRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFYID0gLWRlbHRhbW92ZW1lbnQ7XG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICBpZihweSA8IHkgKyBwYWRkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhWSA9IGRlbHRhbW92ZW1lbnQ7XG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICBpZihweSA+IGggLSBwYWRkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhWSA9IC1kZWx0YW1vdmVtZW50O1xuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fX3Byb2Nlc3NPdmVyQW5pbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3Byb2Nlc3NPdmVyQW5pbWUuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGRlbHRhWCB8fCBkZWx0YVkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3Byb2Nlc3NPdmVyQW5pbWUgPSB0aGlzLnJlcXVlc3RKRmxvd0FuaW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFuSGFuZGxlcihkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgICAgICAgICAgICAgIH0pIFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdiZWhhdmlvci5wYW5JbkJvcmRlci50aW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX29uRHJhZ292ZXIoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmKHRoaXMuX2xhc3REcmFnU3RhdGUucHJvY2Vzc2luZykgcmV0dXJuO1xuICAgICAgICB0aGlzLl9sYXN0RHJhZ1N0YXRlLnByb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGV2ZW50XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fdGFyZ2V0LnN0YXR1cywge1xuICAgICAgICAgICAgZHJhZ292ZXJpbmc6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuX3RhcmdldExvY2tPbihbb2Zmc2V0WCwgb2Zmc2V0WV0pXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5fdGFyZ2V0Lmluc3RhbmNlIHx8IHRoaXMuX3RhcmdldC5saW5rO1xuICAgICAgICB0aGlzLl9wcm9jZXNzRHJhZ092ZXIoaW5zdGFuY2UsIGV2ZW50KTtcbiAgICAgICAgaWYodGhpcy5fdGFyZ2V0LmlzTGlua0RpcnR5IHx8IHRoaXMuX3RhcmdldC5pc0luc3RhbmNlRGlydHkpIHtcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuX3JlbmRlcigpOyAgICBcbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXQuaXNMaW5rRGlydHkgPSBmYWxzZTsgXG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LmlzSW5zdGFuY2VEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3REcmFnU3RhdGUucHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3REcmFnU3RhdGUucHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICB9IFxuICAgIH1cblxuICAgIF9jYW5jZWxQYW5JbkJvcmRlcigpIHtcbiAgICAgICAgaWYodGhpcy5fX3Byb2Nlc3NPdmVyQW5pbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX19wcm9jZXNzT3ZlckFuaW1lLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuZHJhZ2dpbmdiZWhhdmlvcj8ucGFuSW5Cb3JkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdiZWhhdmlvci5wYW5JbkJvcmRlci50aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfb25EcmFnTGVhdmUoKSB7XG4gICAgICAgIHRoaXMuX2NhbmNlbFBhbkluQm9yZGVyKCk7XG4gICAgfVxuXG4gICAgX29uRHJvcChldmVudCkge1xuICAgICAgICB0aGlzLl9jYW5jZWxQYW5JbkJvcmRlcigpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5jb25zdW1lTWVzc2FnZSgpO1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHBheWxvYWQ/Lmluc3RhbmNlO1xuICAgICAgICBpZih0aGlzLl9kcmFnT3ZlclRhcmdldCkge1xuICAgICAgICAgICAgY29uc3Qgb2xkSW5zID0gdGhpcy5fZHJhZ092ZXJUYXJnZXQ7XG4gICAgICAgICAgICBvbGRJbnMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnZHJhZ292ZXJlbmQnLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IG9sZElucyxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdPdmVyVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBsaW5rLFxuICAgICAgICAgICAgaW5zdGFuY2U6IHRhcmdldCxcbiAgICAgICAgfSA9IHRoaXMuX3RhcmdldDtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgcG9pbnQsIGJlbG9uZ3NcbiAgICAgICAgfSA9IHRoaXMuX3RhcmdldC5jYWNoZTtcbiAgICAgICAgaWYobGluaykgeyAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDkuKLlnKjnur/kuIrkuovku7ZcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXZlbnQgQmFzZUxpbmsjZHJvcFxuICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IGV2ZW50ICAgICAgICAgICAtIOWOn+Wni+S6i+S7tiBcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBpbnN0YW5jZSAgICAgICAtIOaLluWKqOeahOWvueixoSBcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QmFzZUxpbmt9IGxpbmsgICAgICAgICAtIOebruagh+i/nue6vyBcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SkZsb3d9IGpmbG93ICAgICAgICAgICAtIOW9k+WJjUpGbG935a+56LGhIFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtHcm91cHxKRmxvd30gYmVsb25ncyAgIC0g6L+e57q/5omA5Zyo55qE57uY5Zu+5qCI55qE5a+56LGhXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcltdfSBwb2ludCAgICAgICAgLSDlt7Lnu4/orqHnrpfliLDnu5jlm77moIjlr7nlupTlnZDmoIfns7vkuIvnmoTlnZDmoIdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gaW5zdGFuY2UuYW5jaG9yID0gcG9pbnQ7XG4gICAgICAgICAgICBsaW5rLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2Ryb3AnLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgbGluayxcbiAgICAgICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgICAgICBiZWxvbmdzLFxuICAgICAgICAgICAgICAgIHBvaW50XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfSBlbHNlIGlmKHRhcmdldCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDkuKLlnKjoioLngrnkuIrkuovku7ZcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXZlbnQgTm9kZSNkcm9wXG4gICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtFdmVudH0gZXZlbnQgICAgICAgICAgIC0g5Y6f5aeL5LqL5Lu2IFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IGluc3RhbmNlICAgICAgIC0g5ouW5Yqo55qE5a+56LGhIFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtKRmxvd30gamZsb3cgICAgICAgICAgIC0g5b2T5YmNSkZsb3flr7nosaEgXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge05vZGV9IHRhcmdldCAgICAgICAgICAgLSDnm67moIfoioLngrlcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IHBvaW50ICAgICAgICAtIOW3sue7j+iuoeeul+WIsOe7mOWbvuagiOWvueW6lOWdkOagh+ezu+S4i+eahOWdkOagh1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0YXJnZXQuYnViYmxlRXZlbnQobmV3IEpGbG93RXZlbnQoJ2Ryb3AnLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHBvaW50LFxuICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICog5Lii5Zyo5Li75Zu+5LiK5LqL5Lu2XG4gICAgICAgICAgICAqXG4gICAgICAgICAgICAqIEBldmVudCBKRmxvdyNkcm9wXG4gICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IGV2ZW50ICAgICAgICAgICAtIOWOn+Wni+S6i+S7tiBcbiAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IGluc3RhbmNlICAgICAgIC0g5ouW5Yqo55qE5a+56LGhIFxuICAgICAgICAgICAgKiBAcHJvcGVydHkge0pGbG93fSBqZmxvdyAgICAgICAgICAgLSDlvZPliY1KRmxvd+WvueixoSBcbiAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJbXX0gcG9pbnQgICAgICAgIC0g5bey57uP6K6h566X5Yiw57uY5Zu+5qCI5a+55bqU5Z2Q5qCH57O75LiL55qE5Z2Q5qCHXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdkcm9wJywge1xuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgIH0pKVxuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbERyb3AoKTtcbiAgICAgICAgfSlcbiAgICB9XG4gICAgY2FuY2VsRHJvcCgpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0Lmluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmxpbmsgPSBudWxsO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3RhcmdldC5zdGF0dXMsIHtcbiAgICAgICAgICAgIGRyYWdvdmVyaW5nOiBmYWxzZSxcbiAgICAgICAgfSlcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICog57yp5pS+5pON5L2c5aSE55CG5Ye95pWwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFggLSDkuovku7blr7nosaHkuI5jYW52YXPnmoTlhoXloavlhYXovrnvvIhwYWRkaW5nIGVkZ2XvvInlnKggWCDovbTmlrnlkJHkuIrnmoTlgY/np7vph4/jgIJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0WSAtIOS6i+S7tuWvueixoeS4jmNhbnZhc+eahOWGheWhq+WFhei+ue+8iHBhZGRpbmcgZWRnZe+8ieWcqCBZIOi9tOaWueWQkeS4iueahOWBj+enu+mHj+OAgiBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFYICAtIOawtOW5s+a7muWKqOmHj1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVkgIC0g5Z6C55u05rua5Yqo6YePXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50IC0g5Y6f55Sf5LqL5Lu2XG4gICAgICovXG4gICAgem9vbUhhbmRsZXIob2Zmc2V0WCwgb2Zmc2V0WSwgZGVsdGFYLCBkZWx0YVksIGV2ZW50KSB7XG4gICAgICAgIC8vIGlmKCF0aGlzLl9hbGxvd1pvb20pIHJldHVybjtcbiAgICAgICAgaWYodGhpcy5fem9vbWluZykgcmV0dXJuO1xuICAgICAgICB0aGlzLl96b29taW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyB3aWR0aDogcF93aWR0aCwgaGVpZ2h0OiBwX2hlaWdodCwgeCwgeSB9ID0gdGhpcy5ib3VuZGluZ19ib3g7XG4gICAgICAgIGNvbnN0IHsgYWN0dWFsX3dpZHRoOiBjdywgYWN0dWFsX2hlaWdodDogY2ggfSA9IHRoaXMuY2FudmFzTWV0YTtcbiAgICAgICAgbGV0IG1pblpvb20gPSB0aGlzLm1pblpvb207XG4gICAgICAgIGlmKHRoaXMud29ybGRNYXJnaW4pIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSB0aGlzLndvcmxkTWFyZ2luO1xuICAgICAgICAgICAgY29uc3QgbWF4V2lkdGggPSBwX3dpZHRoICsgbSAqIDI7XG4gICAgICAgICAgICBjb25zdCBtYXhIZWlnaHQgPSBwX2hlaWdodCArIG0gKiAyO1xuICAgICAgICAgICAgbWluWm9vbSA9IE1hdGgubWF4KG1pblpvb20sIE1hdGgubWF4KGN3IC8gbWF4V2lkdGgsIGNoIC8gbWF4SGVpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1NjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgY29uc3QgYW1vdW50ID0gZGVsdGFZID4gMCA/IDEuMDUgOiAxIC8gMS4wNTtcbiAgICAgICAgbmV3U2NhbGUgKj0gYW1vdW50O1xuICAgICAgICBuZXdTY2FsZSA9IE1hdGgubWluKHRoaXMubWF4Wm9vbSwgTWF0aC5tYXgobWluWm9vbSwgbmV3U2NhbGUpKVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhuZXdTY2FsZSk7XG4gICAgICAgIC8vIGlmICh0aGlzLm1heFpvb20gJiYgbmV3U2NhbGUgPiB0aGlzLm1heFpvb20pe1xuICAgICAgICAvLyAgICAgLy8gY291bGQganVzdCByZXR1cm4gYnV0IHRoZW4gd29uJ3Qgc3RvcCBleGFjdGx5IGF0IG1heFpvb21cbiAgICAgICAgLy8gICAgIG5ld1NjYWxlID0gdGhpcy5tYXhab29tO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gaWYodGhpcy5taW5ab29tICYmIG5ld1NjYWxlIDwgdGhpcy5taW5ab29tKSB7XG4gICAgICAgIC8vICAgICBuZXdTY2FsZSA9IHRoaXMubWluWm9vbTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIHZhciBkZWx0YVNjYWxlICAgID0gbmV3U2NhbGUgLSB0aGlzLnNjYWxlO1xuICAgICAgICB2YXIgY3VycmVudFdpZHRoICA9IHBfd2lkdGggKiB0aGlzLnNjYWxlO1xuICAgICAgICB2YXIgY3VycmVudEhlaWdodCA9IHBfaGVpZ2h0ICogdGhpcy5zY2FsZTtcbiAgICAgICAgdmFyIGRlbHRhV2lkdGggICAgPSBwX3dpZHRoICogZGVsdGFTY2FsZTtcbiAgICAgICAgdmFyIGRlbHRhSGVpZ2h0ICAgPSBwX2hlaWdodCAqIGRlbHRhU2NhbGU7XG5cbiAgICAgICAgdmFyIHRYID0gb2Zmc2V0WCAtIHRoaXMucG9zaXRpb24ueDtcbiAgICAgICAgdmFyIHRZID0gb2Zmc2V0WSAtIHRoaXMucG9zaXRpb24ueTtcbiAgICAgICAgdmFyIHBYID0gLXRYIC8gY3VycmVudFdpZHRoO1xuICAgICAgICB2YXIgcFkgPSAtdFkgLyBjdXJyZW50SGVpZ2h0O1xuXG4gICAgICAgIHRoaXMuc2NhbGUgPSBuZXdTY2FsZTtcbiAgICAgICAgdGhpcy5fcmVjYWxjdWxhdGVQb3NpdGlvbihwWCAqIGRlbHRhV2lkdGgsIHBZICogZGVsdGFIZWlnaHQpO1xuICAgICAgICBcbiAgICAgICAgLy8gdGhpcy5wb3NpdGlvbi54ICs9IHBYICogZGVsdGFXaWR0aDtcbiAgICAgICAgLy8gdGhpcy5wb3NpdGlvbi55ICs9IHBZICogZGVsdGFIZWlnaHQ7XG4gICAgICAgIC8vIHRoaXMucG9zaXRpb24ub2Zmc2V0WCA9IHRoaXMucG9zaXRpb24ueCAtIHggKiBuZXdTY2FsZTtcbiAgICAgICAgLy8gdGhpcy5wb3NpdGlvbi5vZmZzZXRZID0gdGhpcy5wb3NpdGlvbi55IC0geSAqIG5ld1NjYWxlO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ3pvb21wYW4nLCB7XG4gICAgICAgICAgICAgZGVsdGFYOiAwLCBkZWx0YVk6IDBcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyB0aGlzLnNldEFuaW1lQ2xvY2soKVxuICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgfSlcbiAgICAgICAgLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCh0aW1lc3RhbXApID0+IHtcbiAgICAgICAgLy8gICAgIHRoaXMuc2V0QW5pbWVDbG9jayh0aW1lc3RhbXApO1xuICAgICAgICAvLyAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgICAgIC8vICAgICB0aGlzLl96b29taW5nID0gZmFsc2U7XG4gICAgICAgIC8vIH0pXG4gICAgfVxuICAgIC8qKlxuICAgICAqIOW5s+enu+eUu+W4g+aTjeS9nOWkhOeQhuWHveaVsFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVggIC0g5rC05bmz5rua5Yqo6YePXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWSAgLSDlnoLnm7Tmu5rliqjph49cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQgLSDljp/nlJ/kuovku7ZcbiAgICAgKi9cbiAgICBwYW5IYW5kbGVyKGRlbHRhWCwgZGVsdGFZLCBldmVudCkge1xuICAgICAgICBpZih0aGlzLl9wYW5uaW5nKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3Bhbm5pbmcgPSB0cnVlO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBkcmFnZ2luZyxcbiAgICAgICAgfSA9IHRoaXMuX3RhcmdldC5zdGF0dXM7XG4gICAgICAgIGlmKGRyYWdnaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBtb3Zpbmd0YXJnZXQgPSB0aGlzLl90YXJnZXQubW92aW5nO1xuICAgICAgICAgICAgaWYobW92aW5ndGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5kcmFnZ2luZ2JlaGF2aW9yLnBhbkluQm9yZGVyLmFsbG93TW92aW5nVGFyZ2V0SW5QYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbW92aW5ndGFyZ2V0LmZvckVhY2godCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LmFuY2hvclswXSArPSAtZGVsdGFYIC8gdGhpcy5zY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuYW5jaG9yWzFdICs9IC1kZWx0YVkgLyB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlY2FsY3VsYXRlUG9zaXRpb24oZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICAvKipcbiAgICAgICAgICog57yp5pS+5bmz56e75LqL5Lu2XG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBKRmxvdyN6b29tcGFuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnem9vbXBhbicsIHtcbiAgICAgICAgICAgIGRlbHRhWCxcbiAgICAgICAgICAgIGRlbHRhWVxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcGFubmluZyA9IGZhbHNlO1xuICAgICAgICB9KVxuICAgICAgICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHRpbWVzdGFtcCkgPT4ge1xuICAgICAgICAvLyAgICAgdGhpcy5zZXRBbmltZUNsb2NrKHRpbWVzdGFtcCk7XG4gICAgICAgIC8vICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICAgICAgLy8gICAgIHRoaXMuX3Bhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gfSlcbiAgICB9XG4gICAgLyoqXG4gICAgICog5byA5aeL5oyJ5Y6L5aSE55CG5Ye95pWwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFggLSDkuovku7blr7nosaHkuI5jYW52YXPnmoTlhoXloavlhYXovrnvvIhwYWRkaW5nIGVkZ2XvvInlnKggWCDovbTmlrnlkJHkuIrnmoTlgY/np7vph4/jgIJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0WSAtIOS6i+S7tuWvueixoeS4jmNhbnZhc+eahOWGheWhq+WFhei+ue+8iHBhZGRpbmcgZWRnZe+8ieWcqCBZIOi9tOaWueWQkeS4iueahOWBj+enu+mHj+OAgiBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQgLSDljp/nlJ/kuovku7ZcbiAgICAgKi9cbiAgICBwcmVzc1N0YXJ0SGFuZGxlcihvZmZzZXRYLCBvZmZzZXRZLCBldmVudCkge1xuICAgICAgICBpZih0aGlzLmNoZWNrU2Nyb2xsRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fdGFyZ2V0Lm1ldGEsIHtcbiAgICAgICAgICAgIGluaXRpYWxYOiBvZmZzZXRYLFxuICAgICAgICAgICAgaW5pdGlhbFk6IG9mZnNldFksXG4gICAgICAgIH0pXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGxpbmssXG4gICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICB9ID0gdGhpcy5fdGFyZ2V0TG9ja09uKFtvZmZzZXRYLCBvZmZzZXRZXSwgJ3ByZXNzU3RhcnQnKTtcbiAgICAgICAgLy8g5ZCO57ut5Y+q5pSv5oyBIGNsaWNrIOWKqOS9nFxuICAgICAgICBpZih0aGlzLm1vZGUgPT09IEpGTE9XX01PREUuTElOS0lORykgcmV0dXJuO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3RhcmdldC5zdGF0dXMsIHtcbiAgICAgICAgICAgIGRyYWdnaW5nOiB0cnVlLFxuICAgICAgICAgICAgcHJvY2Vzc2luZzogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBpZih0aGlzLl90YXJnZXQubW92aW5nKSB7XG4gICAgICAgICAgICBjb25zdCBtb3ZpbmcgPSB0aGlzLl9nZXRNb3ZpbmdUYXJnZXQoKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5byA5aeL5ouW5Yqo57uE55qE5LqL5Lu277yI54m55oyHbG9ja+eahOmhtuWxgue7hO+8iVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBldmVudCBOb2RlI3ByZXNzU3RhcnRcbiAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0V2ZW50fSBldmVudCAgICAgICAgICAgLSDljp/lp4vkuovku7YgXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge05vZGV9IGluc3RhbmNlICAgICAgIC0g5ouW5Yqo55qE5a+56LGhIFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtKRmxvd30gamZsb3cgICAgICAgICAgIC0g5b2T5YmNSkZsb3flr7nosaEgXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG1vdmluZy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdwcmVzc1N0YXJ0Jywge1xuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiBtb3ZpbmcsXG4gICAgICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ID0gdGhpcy5fcmVzb2x2ZUxvY2tPblRhcmdldChsaW5rLCBpbnN0YW5jZSlcbiAgICAgICAgaWYodCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDlvIDlp4vmi5bliqjlr7nosaHkuovku7bvvIjlsLHmmK/nm67moIflr7nosaHnmoTmi5bliqjkuovku7bvvIzkuovku7bmlK/mjIHlhpLms6HvvIlcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXZlbnQgTm9kZSNpbnN0YW5jZVByZXNzU3RhcnRcbiAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0V2ZW50fSBldmVudCAgICAgICAgICAgLSDljp/lp4vkuovku7YgXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge05vZGV9IGluc3RhbmNlICAgICAtIOaLluWKqOeahOWvueixoSBcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SkZsb3d9IGpmbG93ICAgICAgICAgICAtIOW9k+WJjUpGbG935a+56LGhIFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBidWJibGVzICAgICAgIC0g5YaS5rOhXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIGNvbnN0IHQgPSB0aGlzLl90YXJnZXQuaW5zdGFuY2U7XG4gICAgICAgICAgICB0LmJ1YmJsZUV2ZW50KG5ldyBKRmxvd0V2ZW50KCdpbnN0YW5jZVByZXNzU3RhcnQnLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0LFxuICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJldmVudFByZXNzU2VxdWVlbmNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJUYXJnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJldmVudFByZXNzU2VxdWVlbmNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0sIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfVxuICAgICAgICBpZighdGhpcy5fcHJldmVudFByZXNzU2VxdWVlbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2pmbG93UHJlc3NTdGFydCcsIHtcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiDmjInljovkuK3lpITnkIblh73mlbBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0WCAtIOS6i+S7tuWvueixoeS4jmNhbnZhc+eahOWGheWhq+WFhei+ue+8iHBhZGRpbmcgZWRnZe+8ieWcqCBYIOi9tOaWueWQkeS4iueahOWBj+enu+mHj+OAglxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRZIC0g5LqL5Lu25a+56LGh5LiOY2FudmFz55qE5YaF5aGr5YWF6L6577yIcGFkZGluZyBlZGdl77yJ5ZyoIFkg6L205pa55ZCR5LiK55qE5YGP56e76YeP44CCIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudCAtIOWOn+eUn+S6i+S7tlxuICAgICAqL1xuICAgIHByZXNzTW92ZUhhbmRsZXIob2Zmc2V0WCwgb2Zmc2V0WSwgZXZlbnQpIHtcbiAgICAgICAgaWYodGhpcy5fcHJldmVudFByZXNzU2VxdWVlbmNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5jaGVja1Njcm9sbERyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBkcmFnZ2luZywgcHJvY2Vzc2luZ1xuICAgICAgICB9ID0gdGhpcy5fdGFyZ2V0LnN0YXR1cztcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLl90YXJnZXQubWV0YTtcbiAgICAgICAgLy8gdGhpcy5jYW52YXMuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuICAgICAgICBpZighZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuY2hlY2tTY3JvbGxCYXJIb3ZlcihvZmZzZXRYLCBvZmZzZXRZKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldFNjcm9sbEJhckhvdmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFkcmFnZ2luZyAmJiAhcHJvY2Vzc2luZykge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGxpbmssXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICAgIH0gPSB0aGlzLl90YXJnZXRMb2NrT24oW29mZnNldFgsIG9mZnNldFldKTtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLl9yZXNvbHZlTG9ja09uVGFyZ2V0KGxpbmssIGluc3RhbmNlKTtcbiAgICAgICAgICAgIGlmKHQpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAqIGluc3RhbmNlIG1vdXNlbW92ZSDljp/nlJ/kuovku7bvvIzku4XlnKjml6Dmi5bmi73ml7bop6blj5FcbiAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgKiBAZXZlbnQgTm9kZSNpbnN0YW5jZW1vdXNlbW92ZVxuICAgICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IGV2ZW50ICAgICAgICAgICAtIOWOn+Wni+S6i+S7tlxuICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtOb2RlfSBpbnN0YW5jZSAgICAgICAgICAgLSDljp/lp4vkuovku7ZcbiAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SkZsb3d9IGpmbG93ICAgICAgICAgICAtIOW9k+WJjUpGbG935a+56LGhIFxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLy8gaW5zdGFuY2UuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnaW5zdGFuY2Vtb3VzZW1vdmUnLCB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIC8vICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAvLyAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICAgICAgLy8gfSkpXG4gICAgICAgICAgICAgICAgdC5idWJibGVFdmVudChuZXcgSkZsb3dFdmVudCgnaW5zdGFuY2Vtb3VzZW1vdmUnLCB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZTogdCxcbiAgICAgICAgICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnaW5zdGFuY2Vtb3VzZW1vdmUnLCB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIGlmKHRoaXMubW9kZSA9PT0gSkZMT1dfTU9ERS5MSU5LSU5HKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgaW5zdGFuY2UuYnViYmxlRXZlbnQobmV3IEpGbG93RXZlbnQoJ2xpbmtpbmcnLCB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHRhcmdldDogaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBjYWxsYmFjazogKHApID0+IHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICB0aGlzLl9jdXJyZW50cCA9IHA7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gICAgIH0pKVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBOb2RlLmFuY2hvciA9IHRoaXMuX2N1cnJlbnRwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXQuaXNMaW5rRGlydHkgPSBmYWxzZTsgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldC5pc0luc3RhbmNlRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LnN0YXR1cy5wcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzUGFuSW5Cb3JkZXIoKTtcbiAgICAgICAgICAgICAgICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHRpbWVzdGFtcCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vICAgICB0aGlzLnNldEFuaW1lQ2xvY2sodGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgLy8gICAgIHRoaXMuX3RhcmdldC5pc0xpbmtEaXJ0eSA9IGZhbHNlOyBcbiAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5fdGFyZ2V0LmlzSW5zdGFuY2VEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vICAgICB0aGlzLl90YXJnZXQuc3RhdHVzLnByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyB9KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogY2FudmFzIG1vdXNlbW92ZSDljp/nlJ/kuovku7ZcbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IEpGbG93I2NhbnZhc21vdXNlbW92ZVxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAcHJvcGVydHkge0V2ZW50fSBldmVudCAgICAgICAgICAgLSDljp/lp4vkuovku7ZcbiAgICAgICAgICogQHByb3BlcnR5IHtKRmxvd30gamZsb3cgICAgICAgICAgIC0g5b2T5YmNSkZsb3flr7nosaEgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2NhbnZhc21vdXNlbW92ZScsIHtcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgIH0pKVxuXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgaWYoIWRyYWdnaW5nKSByZXR1cm47XG4gICAgICAgIC8vIHRoaXMuY2FudmFzLnN0eWxlLmN1cnNvciA9ICdncmFiYmluZyc7XG4gICAgICAgIGlmKHByb2Nlc3NpbmcpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IG1vdmluZ3RhcmdldCA9IHRoaXMuX3RhcmdldC5tb3Zpbmc7Ly8gdGhpcy5fdGVtcE5vZGUgPyBbdGhpcy5fdGVtcE5vZGVdIDogdGhpcy5fdGFyZ2V0Lm1vdmluZztcbiAgICAgICAgdGhpcy5fdGFyZ2V0LnN0YXR1cy5tb3ZpbmdTdGF0ZSA9IHRydWVcbiAgICAgICAgdGhpcy5fdGFyZ2V0LnN0YXR1cy5wcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZGVsdGFYID0gb2Zmc2V0WCAtIHg7XG4gICAgICAgIGNvbnN0IGRlbHRhWSA9IG9mZnNldFkgLSB5O1xuICAgICAgICBpZihtb3Zpbmd0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuX2FsbG93TW92aW5nVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgbW92aW5ndGFyZ2V0LmZvckVhY2godCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHQuYW5jaG9yWzBdICs9IGRlbHRhWCAvIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIHQuYW5jaG9yWzFdICs9IGRlbHRhWSAvIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlY2FsY3VsYXRlUG9zaXRpb24oZGVsdGFYLCBkZWx0YVkpOyAgICBcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnem9vbXBhbicsIHtcbiAgICAgICAgICAgICAgICBkZWx0YVgsIGRlbHRhWVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaW5zdGFuY2UsIGxpbmsgfSA9IHRoaXMuX3RhcmdldExvY2tPbihbb2Zmc2V0WCwgb2Zmc2V0WV0pO1xuXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NEcmFnT3ZlcihpbnN0YW5jZSB8fCBsaW5rLCBldmVudCk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldC5pc0xpbmtEaXJ0eSA9IGZhbHNlOyBcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldC5pc0luc3RhbmNlRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldC5zdGF0dXMucHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICB9KVxuICAgICAgICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHRpbWVzdGFtcCkgPT4ge1xuICAgICAgICAvLyAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgICAgIC8vICAgICB0aGlzLl90YXJnZXQuaXNMaW5rRGlydHkgPSBmYWxzZTsgXG4gICAgICAgIC8vICAgICB0aGlzLl90YXJnZXQuaXNJbnN0YW5jZURpcnR5ID0gZmFsc2U7XG4gICAgICAgIC8vICAgICB0aGlzLl90YXJnZXQuc3RhdHVzLnByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gfSlcbiAgICB9XG4gICAgLyoqXG4gICAgICog5oyJ5Y6L57uT5p2f5aSE55CG5Ye95pWwXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc0RvY3VtZW50IC0g5piv5ZCm5Li6IGRvY3VtZW50IOinpuWPkVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudCAtIOWOn+eUn+S6i+S7tlxuICAgICAqL1xuICAgIHByZXNzVXBIYW5sZGVyKGlzRG9jdW1lbnQsIGV2ZW50KSB7XG4gICAgICAgIGlmKHRoaXMuX3ByZXZlbnRQcmVzc1NlcXVlZW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLl9fcHJvY2Vzc092ZXJBbmltZSkge1xuICAgICAgICAgICAgdGhpcy5fX3Byb2Nlc3NPdmVyQW5pbWUuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZHJhZ092ZXJUYXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYW5jZWxQYW5JbkJvcmRlcigpO1xuICAgICAgICAvLyB0aGlzLnJlc2V0U2NvbGxCYXJTdGF0dXMoKTtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX3RhcmdldC5tZXRhO1xuICAgICAgICBpZih0aGlzLm1vZGUgPT09IEpGTE9XX01PREUuTElOS0lORykge1xuICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMuX3RhcmdldC5pbnN0YW5jZTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB0aGlzLmNvbnN1bWVNZXNzYWdlKCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhwYXlsb2FkKVxuICAgICAgICAgICAgbGV0IF9wcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgcHJldmVudERlZmF1bHQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgX3ByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBpZih0KSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogY2FudmFzIG1vdXNlbW92ZSDljp/nlJ/kuovku7ZcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBldmVudCBOb2RlI2xpbmtcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IGV2ZW50ICAgICAgICAgICAtIOWOn+Wni+S6i+S7tlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Tm9kZX0gdGFyZ2V0ICAgICAgICAgICAtIOWOn+Wni+S6i+S7tlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBwYXlsb2FkICAgICAgICAtIOS8oOWFpeeahOa2iOaBr1xuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SkZsb3d9IGpmbG93ICAgICAgICAgICAtIOW9k+WJjUpGbG935a+56LGhICAgICAgIC0g5b2T5YmNSkZsb3flr7nosaEgXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdC5idWJibGVFdmVudChuZXcgSkZsb3dFdmVudCgnbGluaycsIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdCxcbiAgICAgICAgICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGxpbms6IHRoaXMuX3RlbXBMaW5rLFxuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCxcbiAgICAgICAgICAgICAgICB9KSkgICAgICAgIFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGV2ZW50XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdsaW5rJywge1xuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvcjogdGhpcy5fY2FsY3VsYXRlUG9pbnRCYWNrKFtvZmZzZXRYLCBvZmZzZXRZXSksXG4gICAgICAgICAgICAgICAgICAgIGxpbms6IHRoaXMuX3RlbXBMaW5rLFxuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKF9wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NsZWFyVGFyZ2V0KCk7XG4gICAgICAgICAgICBpZighdGhpcy5fcHJldmVudENsZWFyVGVtcCkge1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuX3RlbXBOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBOb2RlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcE5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZih0aGlzLl90ZW1wTGluaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wTGluay5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBMaW5rID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wcmV2ZW50Q2xlYXJUZW1wID0gZmFsc2VcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IEpGTE9XX01PREUuREVGQVVMVDtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLl90YXJnZXQubW92aW5nKSB7XG4gICAgICAgICAgICBsZXQgY2hlY2tyZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmKHRoaXMuX2xheW91dC5zdGF0aWMpIHtcbiAgICAgICAgICAgICAgICBjaGVja3Jlc3VsdCA9IHRoaXMuc3RhdGljQ2hlY2sodGhpcy5fZ2V0TW92aW5nVGFyZ2V0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZighY2hlY2tyZXN1bHQgJiYgdGhpcy5fdGFyZ2V0LmxpbmspIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50LCBiZWxvbmdzXG4gICAgICAgICAgICAgICAgfSA9IHRoaXMuX3RhcmdldC5jYWNoZTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5rID0gdGhpcy5fdGFyZ2V0Lmxpbms7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLl9nZXRNb3ZpbmdUYXJnZXQoKTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiDmi5bliqjliLDnur/kuIrkuovku7ZcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBldmVudCBCYXNlTGluayNkcm9wXG4gICAgICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0V2ZW50fSBldmVudCAgICAgICAgICAgLSDljp/lp4vkuovku7YgXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IGluc3RhbmNlICAgICAtIOaLluWKqOeahOWvueixoSBcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0Jhc2VMaW5rfSBsaW5rICAgICAgICAgLSDnm67moIfov57nur8gXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtKRmxvd30gamZsb3cgICAgICAgICAgIC0g5b2T5YmNSkZsb3flr7nosaEgXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtHcm91cHxKRmxvd30gYmVsb25ncyAgIC0g6L+e57q/5omA5Zyo55qE57uY5Zu+5qCI55qE5a+56LGhXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbGluay5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdkcm9wJywge1xuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIGxpbmssXG4gICAgICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBiZWxvbmdzLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXQubGluayA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0Lmluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZih0aGlzLl90YXJnZXQubW92aW5nKSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5fdGFyZ2V0Lmluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiDmi5bliqjlkI7mlL7nva7liLAgSW5zdGFuY2Ug5LiK55qE5LqL5Lu277yM55Sx6KKr5ouW5Yqo5Yiw55qE5a+56LGh6Kem5Y+RXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqIEBldmVudCBOb2RlI3ByZXNzRW5kXG4gICAgICAgICAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IGV2ZW50ICAgICAgICAgICAtIOWOn+Wni+S6i+S7tiBcbiAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtOb2RlfSBpbnN0YW5jZSAgICAgICAgIC0g5ouW5Yqo55qE5a+56LGhIFxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0pGbG93fSBqZmxvdyAgICAgICAgICAgLSDlvZPliY1KRmxvd+WvueixoSBcbiAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtJbnN0YW5jZX0gdGFyZ2V0ICAgICAgIC0g5ouW5Yqo5Yiw55qE5a+56LGhXG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYnViYmxlcyAgICAgICAtIOWGkuazoVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgLy8gIGNvbnNvbGUubG9nKCdwcmVzc0VuZCcsIHRoaXMuX3RhcmdldC5pbnN0YW5jZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0Lmluc3RhbmNlLmJ1YmJsZUV2ZW50KG5ldyBKRmxvd0V2ZW50KCdwcmVzc0VuZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMuX2dldE1vdmluZ1RhcmdldCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMuX3RhcmdldC5pbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiDmi5bliqjlkI7mlL7nva7liLDkuLvlm77kuIrnmoTkuovku7ZcbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogQGV2ZW50IEpGbG93I3ByZXNzRW5kXG4gICAgICAgICAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IGV2ZW50ICAgICAgICAgICAtIOWOn+Wni+S6i+S7tiBcbiAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtJbnN0YW5jZX0gaW5zdGFuY2UgICAgICAgLSDmi5bliqjnmoTlr7nosaEgXG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SkZsb3d9IGpmbG93ICAgICAgICAgICAtIOW9k+WJjUpGbG935a+56LGhIFxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdwcmVzc0VuZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMuX2dldE1vdmluZ1RhcmdldCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RhcmdldC5tb3ZpbmcgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVUZW1wRHJhZ2dpbmdJbnN0YW5jZSgpXG4gICAgICAgICAgICAvLyB0aGlzLl90YXJnZXQuaXNNb3ZpbmdEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xlYXJUYXJnZXQoKTtcbiAgICB9XG4gICAgIC8qKlxuICAgICAqIOiPnOWNleW8ueWHuuWkhOeQhuWHveaVsFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRYIC0g5LqL5Lu25a+56LGh5LiOY2FudmFz55qE5YaF5aGr5YWF6L6577yIcGFkZGluZyBlZGdl77yJ5ZyoIFgg6L205pa55ZCR5LiK55qE5YGP56e76YeP44CCXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFkgLSDkuovku7blr7nosaHkuI5jYW52YXPnmoTlhoXloavlhYXovrnvvIhwYWRkaW5nIGVkZ2XvvInlnKggWSDovbTmlrnlkJHkuIrnmoTlgY/np7vph4/jgIIgXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50IC0g5Y6f55Sf5LqL5Lu2XG4gICAgICovXG4gICAgY2xpY2tIYW5sZGVyKG9mZnNldFgsIG9mZnNldFksIGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGxpbmssXG4gICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgIG1ldGFcbiAgICAgICAgfSA9IHRoaXMuX3RhcmdldExvY2tPbihbb2Zmc2V0WCwgb2Zmc2V0WV0sICdjbGljaycpO1xuICAgICAgICBpZihNYXRoLmFicyhtZXRhLmluaXRpYWxYIC0gbWV0YS54KSA8IDFcbiAgICAgICAgICAgICYmIE1hdGguYWJzKG1ldGEuaW5pdGlhbFkgLSBtZXRhLnkpIDwgMSkgeyBcbiAgICAgICAgICAgICAgICBpZihldmVudC50YXJnZXQgIT09IHRoaXMuY2FudmFzKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJUYXJnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl90YXJnZXQubWV0YSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxZOiB1bmRlZmluZWQsIFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHRvcExheWVyUG9pbnQgfSA9IHRoaXMuX3RhcmdldC5jYWNoZVxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLl9yZXNvbHZlTG9ja09uVGFyZ2V0KGxpbmssIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBpZih0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHQ7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiDngrnlh7vkuovku7bvvIjlhpLms6HvvIlcbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogQGV2ZW50IEluc3RhbmNlI2NvbnRleHRjbGlja1xuICAgICAgICAgICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0V2ZW50fSBldmVudCAgICAgICAgICAgLSDljp/lp4vkuovku7YgXG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SW5zdGFuY2V9IHRhcmdldCAgICAgICAtIOWPs+mUruWvueixoSBcbiAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtKRmxvd30gamZsb3cgICAgICAgICAgIC0g5b2T5YmNSkZsb3flr7nosaFcbiAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJbXX0gdG9wTGF5ZXJQb2ludCAgLSBqZmxvd+WdkOagh+ezu+S4iueahOS9jee9rlxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGJ1YmJsZXMgICAgICAgLSDlhpLms6FcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5idWJibGVFdmVudChuZXcgSkZsb3dFdmVudCgnY2xpY2snLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wTGF5ZXJQb2ludCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiDngrnlh7vkuovku7ZcbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogQGV2ZW50IEpGbG93I2NvbnRleHRjbGlja1xuICAgICAgICAgICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0V2ZW50fSBldmVudCAgICAgICAgICAgLSDljp/lp4vkuovku7YgXG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SkZsb3d9IGpmbG93ICAgICAgICAgICAtIOW9k+WJjUpGbG935a+56LGhXG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IHRvcExheWVyUG9pbnQgIC0gamZsb3flnZDmoIfns7vkuIrnmoTkvY3nva5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnY2xpY2snLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wTGF5ZXJQb2ludCxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhclRhcmdldCgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fdGFyZ2V0Lm1ldGEsIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFk6IHVuZGVmaW5lZCwgXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOiPnOWNleW8ueWHuuWkhOeQhuWHveaVsFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRYIC0g5LqL5Lu25a+56LGh5LiOY2FudmFz55qE5YaF5aGr5YWF6L6577yIcGFkZGluZyBlZGdl77yJ5ZyoIFgg6L205pa55ZCR5LiK55qE5YGP56e76YeP44CCXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFkgLSDkuovku7blr7nosaHkuI5jYW52YXPnmoTlhoXloavlhYXovrnvvIhwYWRkaW5nIGVkZ2XvvInlnKggWSDovbTmlrnlkJHkuIrnmoTlgY/np7vph4/jgIIgXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50IC0g5Y6f55Sf5LqL5Lu2XG4gICAgICovXG4gICAgY29udGV4dE1lbnVIYW5sZGVyKG9mZnNldFgsIG9mZnNldFksIGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGxpbmssXG4gICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICB9ID0gdGhpcy5fdGFyZ2V0TG9ja09uKFtvZmZzZXRYLCBvZmZzZXRZXSwgJ2NvbnRleHRjbGljaycpO1xuICAgICAgICBjb25zdCB7IHRvcExheWVyUG9pbnQgfSA9IHRoaXMuX3RhcmdldC5jYWNoZVxuICAgICAgICBjb25zdCB0ID0gdGhpcy5fcmVzb2x2ZUxvY2tPblRhcmdldChsaW5rLCBpbnN0YW5jZSk7XG4gICAgICAgIGlmKHQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHQ7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOWPs+mUruS6i+S7tu+8iOWGkuazoe+8iVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBldmVudCBJbnN0YW5jZSNjb250ZXh0Y2xpY2tcbiAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0V2ZW50fSBldmVudCAgICAgICAgICAgLSDljp/lp4vkuovku7YgXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0luc3RhbmNlfSB0YXJnZXQgICAgICAgLSDlj7PplK7lr7nosaEgXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0pGbG93fSBqZmxvdyAgICAgICAgICAgLSDlvZPliY1KRmxvd+WvueixoVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJbXX0gdG9wTGF5ZXJQb2ludCAgLSBqZmxvd+WdkOagh+ezu+S4iueahOS9jee9rlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBidWJibGVzICAgICAgIC0g5YaS5rOhXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRhcmdldC5idWJibGVFdmVudChuZXcgSkZsb3dFdmVudCgnY29udGV4dGNsaWNrJywge1xuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICB0b3BMYXllclBvaW50LFxuICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5Y+z6ZSu5LqL5Lu2XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV2ZW50IEpGbG93I2NvbnRleHRjbGlja1xuICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IGV2ZW50ICAgICAgICAgICAtIOWOn+Wni+S6i+S7tiBcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SkZsb3d9IGpmbG93ICAgICAgICAgICAtIOW9k+WJjUpGbG935a+56LGhXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcltdfSB0b3BMYXllclBvaW50ICAtIGpmbG935Z2Q5qCH57O75LiK55qE5L2N572uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnY29udGV4dGNsaWNrJywge1xuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgICAgIHRvcExheWVyUG9pbnQsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkYmxjbGlja0hhbmRsZXIob2Zmc2V0WCwgb2Zmc2V0WSwgZXZlbnQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgbGluayxcbiAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgIH0gPSB0aGlzLl90YXJnZXRMb2NrT24oW29mZnNldFgsIG9mZnNldFldLCAnZGJsY2xpY2snKTtcbiAgICAgICAgY29uc3QgeyB0b3BMYXllclBvaW50IH0gPSB0aGlzLl90YXJnZXQuY2FjaGVcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuX3Jlc29sdmVMb2NrT25UYXJnZXQobGluaywgaW5zdGFuY2UpO1xuICAgICAgICBpZih0KSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDlj7PplK7kuovku7ZcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXZlbnQgSW5zdGFuY2UjZGJsY2xpY2tcbiAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0V2ZW50fSBldmVudCAgICAgICAgICAgLSDljp/lp4vkuovku7YgXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0luc3RhbmNlfSB0YXJnZXQgICAgICAgLSDlj7PplK7lr7nosaEgXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0pGbG93fSBqZmxvdyAgICAgICAgICAgLSDlvZPliY1KRmxvd+WvueixoVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJbXX0gdG9wTGF5ZXJQb2ludCAgLSBqZmxvd+WdkOagh+ezu+S4iueahOS9jee9rlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBidWJibGVzICAgICAgIC0g5YaS5rOhXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRhcmdldC5idWJibGVFdmVudChuZXcgSkZsb3dFdmVudCgnZGJsY2xpY2snLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHRvcExheWVyUG9pbnQsXG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdkYmxjbGljaycsIHtcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgICAgICB0b3BMYXllclBvaW50LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypfb25ab29tKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGxldCB7IG9mZnNldFgsIG9mZnNldFksIGRlbHRhWCwgZGVsdGFZIH0gPSBldmVudFxuICAgICAgICBpZihldmVudC5jdHJsS2V5KSB7IFxuICAgICAgICAgICAgZGVsdGFZID0gLWRlbHRhWTtcbiAgICAgICAgICAgIHRoaXMuem9vbUhhbmRsZXIob2Zmc2V0WCwgb2Zmc2V0WSwgZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYW5IYW5kbGVyKC1kZWx0YVgsIC1kZWx0YVkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX29uUHJlc3NTdGFydChldmVudCkgeyBcbiAgICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZLCBkZWx0YVksIGJ1dHRvbiB9ID0gZXZlbnRcbiAgICAgICAgaWYoYnV0dG9uICE9PSAwKSByZXR1cm47XG4gICAgICAgIHRoaXMucHJlc3NTdGFydEhhbmRsZXIob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgfVxuXG4gICAgX29uUHJlc3NNb3ZlKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnRcbiAgICAgICAgdGhpcy5wcmVzc01vdmVIYW5kbGVyKG9mZnNldFgsIG9mZnNldFkpO1xuICAgIH1cblxuICAgIF9vblByZXNzVXAoZXZlbnQsIGlzRG9jdW1lbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgYnV0dG9uIH0gPSBldmVudFxuICAgICAgICBpZihidXR0b24gIT09IDApIHJldHVybjtcbiAgICAgICAgdGhpcy5wcmVzc1VwSGFubGRlcihpc0RvY3VtZW50KVxuICAgIH1cblxuICAgIF9vblByZXNzVXBEb2N1bWVudChldmVudCkge1xuICAgICAgICB0aGlzLl9vblByZXNzVXAoZXZlbnQsIHRydWUpO1xuICAgIH1cblxuICAgIF9vbkNvbnRleHRNZW51KGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGV2ZW50O1xuICAgICAgICB0aGlzLmNvbnRleHRNZW51SGFubGRlcihvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICB9Ki9cbiAgICBfcmVzb2x2ZUxvY2tPblRhcmdldChsaW5rLCBpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gbGluaz8uT05fVE9QID8gbGluayA6IChpbnN0YW5jZSB8fCBsaW5rKTtcbiAgICB9XG5cbiAgICBfY2xlYXJUYXJnZXQoKXtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl90YXJnZXQubWV0YSwge1xuICAgICAgICAgICAgeDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgeTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gaW5pdGlhbFg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIGluaXRpYWxZOiB1bmRlZmluZWQsIFxuICAgICAgICB9KVxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3RhcmdldC5zdGF0dXMsIHtcbiAgICAgICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIHByb2Nlc3Npbmc6IGZhbHNlLFxuICAgICAgICAgICAgbW92aW5nU3RhdGU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl90YXJnZXQsIHtcbiAgICAgICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICAgICAgbGluazogbnVsbCxcbiAgICAgICAgICAgIG1vdmluZzogbnVsbCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX3JlY2FsY3VsYXRlUG9zaXRpb24oZGVsdGFYLCBkZWx0YVksIHNjYWxlKSB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5ib3VuZGluZ19ib3g7XG4gICAgICAgIGNvbnN0IHsgYWN0dWFsX3dpZHRoOiBjdywgYWN0dWFsX2hlaWdodDogY2ggfSA9IHRoaXMuY2FudmFzTWV0YTtcbiAgICAgICAgaWYoc2NhbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIFxuXG4gICAgICAgIGlmKHRoaXMud29ybGRNYXJnaW4pIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHNjYWxlKVxuICAgICAgICAgICAgY29uc3QgbSA9IHRoaXMud29ybGRNYXJnaW47XG4gICAgICAgICAgICBjb25zdCBieDEgPSAoeCArIHdpZHRoICsgbSkqc2NhbGUgLSBjdztcbiAgICAgICAgICAgIGNvbnN0IGJ4MiA9ICh4IC0gbSkqc2NhbGU7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhieDEsIGJ4MilcbiAgICAgICAgICAgIGNvbnN0IHN4ID0geCAqIHNjYWxlO1xuICAgICAgICAgICAgY29uc3QgcHggPSB0aGlzLnBvc2l0aW9uLnggKyBkZWx0YVg7XG4gICAgICAgICAgICBjb25zdCBjeCA9IHB4IC0gc3g7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLm9mZnNldFggPSBNYXRoLm1pbihNYXRoLm1heCgtYngxLCBjeCksIC1ieDIpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5wb3NpdGlvbi5vZmZzZXRYKVxuICAgICAgICAgICAgLy8gdGhpcy5wb3NpdGlvbi5vZmZzZXRYID0gTWF0aC5tYXgoTWF0aC5taW4oLWJ4MiwgY3gpLCAtYngxKTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ueCA9IHRoaXMucG9zaXRpb24ub2Zmc2V0WCArIHN4O1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5wb3NpdGlvbi54LCBkZWx0YVgpXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnBvc2l0aW9uLm9mZnNldFgpXG5cbiAgICAgICAgICAgIGNvbnN0IGJ5MSA9ICh5ICsgaGVpZ2h0ICsgbSkqc2NhbGUgLSBjaDtcbiAgICAgICAgICAgIGNvbnN0IGJ5MiA9ICh5IC0gbSkqc2NhbGU7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhieTEsIGJ5MilcbiAgICAgICAgICAgIGNvbnN0IHN5ID0geSAqIHNjYWxlO1xuICAgICAgICAgICAgY29uc3QgcHkgPSB0aGlzLnBvc2l0aW9uLnkgKyBkZWx0YVk7XG4gICAgICAgICAgICBjb25zdCBjeSA9IHB5IC0gc3k7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLm9mZnNldFkgPSBNYXRoLm1pbihNYXRoLm1heCgtYnkxLCBjeSksIC1ieTIpO1xuICAgICAgICAgICAgLy8gdGhpcy5wb3NpdGlvbi5vZmZzZXRZID0gTWF0aC5tYXgoTWF0aC5taW4oLWJ5MiwgY3kpLCAtYnkxKTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ueSA9IHRoaXMucG9zaXRpb24ub2Zmc2V0WSArIHN5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi54ICs9IGRlbHRhWDtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ueSArPSBkZWx0YVk7IFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi5vZmZzZXRYID0gdGhpcy5wb3NpdGlvbi54IC0geCAqIHNjYWxlO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi5vZmZzZXRZID0gdGhpcy5wb3NpdGlvbi55IC0geSAqIHNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cblxuICAgIGNhbGN1bGF0ZVRvUmVhbFdvcmxkKHApIHtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIHJldHVybiBbcFswXSAqIHNjYWxlICsgcG9zaXRpb24ub2Zmc2V0WCwgcFsxXSAqIHNjYWxlICsgcG9zaXRpb24ub2Zmc2V0WV1cbiAgICB9XG5cbiAgICBfY2FsY3VsYXRlUG9pbnRCYWNrKHApIHtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIHJldHVybiBbKHBbMF0gLSBwb3NpdGlvbi5vZmZzZXRYKS9zY2FsZSwgKHBbMV0gLSBwb3NpdGlvbi5vZmZzZXRZKSAvIHNjYWxlXTtcbiAgICB9XG5cbiAgICBfY2FsY3VsYXRlUG9pbnRCYWNrV2l0aFBvaW50KGEsIGIsIGFyciwgaWR4MSwgaWR4Mikge1xuICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgYXJyW2lkeDFdID0gKGEgLSBwb3NpdGlvbi5vZmZzZXRYKSAvIHNjYWxlO1xuICAgICAgICBhcnJbaWR4Ml0gPSAoYiAtIHBvc2l0aW9uLm9mZnNldFkpIC8gc2NhbGVcbiAgICB9XG5cbiAgICBfY2FsY3VsYXRlRGlzdGFuY2UobCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZSAqIGw7XG4gICAgfVxuXG4gICAgX3Jlc2V0VHJhbnNmb3JtKCkge1xuICAgICAgICBjb25zdCB7IHdpZHRoOiBjX3dpZHRoLCBoZWlnaHQ6IGNfaGVpZ2h0IH0gPSB0aGlzLmNhbnZhc01ldGE7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgpO1xuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNfd2lkdGgsIGNfaGVpZ2h0KTtcbiAgICAgICAgY3R4LnNjYWxlKHRoaXMuZHByLCB0aGlzLmRwcik7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0oc2NhbGUsIDAsIDAsIHNjYWxlLCBwb3NpdGlvbi5vZmZzZXRYLCBwb3NpdGlvbi5vZmZzZXRZKTtcbiAgICAgICAgLy8gY3R4Ll9jdHguc2V0VHJhbnNmb3JtKCk7XG4gICAgICAgIC8vIGN0eC5fY3R4LmNsZWFyUmVjdCgwLCAwLCBjX3dpZHRoLCBjX2hlaWdodCk7XG4gICAgICAgIC8vIGN0eC5fY3R4LnNjYWxlKHRoaXMuZHByLCB0aGlzLmRwcik7XG4gICAgICAgIC8vIGN0eC50cmFuc2Zvcm0oc2NhbGUsIHBvc2l0aW9uLm9mZnNldFgsIHBvc2l0aW9uLm9mZnNldFkpO1xuICAgIH1cblxuICAgIHJlc2V0VHJhbnNmb3JtKGN0eCkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgpO1xuICAgICAgICBjdHguc2NhbGUodGhpcy5kcHIsIHRoaXMuZHByKTtcbiAgICAgICAgY3R4LnRyYW5zZm9ybShzY2FsZSwgMCwgMCwgc2NhbGUsIHBvc2l0aW9uLm9mZnNldFgsIHBvc2l0aW9uLm9mZnNldFkpO1xuICAgIH1cblxuICAgIF9nZXRWaWV3Qm94KCkge1xuICAgICAgICAvLyBjb25zdCBjYWNoZVZpZXdCb3ggPSBbXG4gICAgICAgIC8vICAgICAuLi50aGlzLl9jYWxjdWxhdGVQb2ludEJhY2soWzAsMF0pLFxuICAgICAgICAvLyAgICAgLi4udGhpcy5fY2FsY3VsYXRlUG9pbnRCYWNrKFt0aGlzLmNhbnZhc01ldGEuYWN0dWFsX3dpZHRoLHRoaXMuY2FudmFzTWV0YS5hY3R1YWxfaGVpZ2h0XSksXG4gICAgICAgIC8vIF07XG4gICAgICAgIGNvbnN0IGNhY2hlVmlld0JveCA9IHRoaXMuX2NhY2hlVmlld0JveDtcbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlUG9pbnRCYWNrV2l0aFBvaW50KDAsMCwgY2FjaGVWaWV3Qm94LCAwLCAxKTtcbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlUG9pbnRCYWNrV2l0aFBvaW50KFxuICAgICAgICAgICAgdGhpcy5jYW52YXNNZXRhLmFjdHVhbF93aWR0aCxcbiAgICAgICAgICAgIHRoaXMuY2FudmFzTWV0YS5hY3R1YWxfaGVpZ2h0LCBcbiAgICAgICAgICAgIGNhY2hlVmlld0JveCwgMiwgMyk7XG4gICAgICAgIHJldHVybiBjYWNoZVZpZXdCb3g7XG4gICAgfVxuXG4gICAgc2V0Tm9kZVRvVG9wTGF5ZXIobm9kZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX3N0YWNrLmZpbmRJbmRleChuID0+IG4gPT09IG5vZGUpO1xuICAgICAgICBpZihpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IFtyZW5kZXJOb2RlXSA9IHRoaXMuX3N0YWNrLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLl9zdGFjay5wdXNoKHJlbmRlck5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Q2FjaGVWaWV3Qm94KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVWaWV3Qm94O1xuICAgIH1cblxuICAgIFxuICAgIF9yZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICB9XG5cbiAgICAgLyoqXG4gICAgICog57uY5Yi255S75biDXG4gICAgICovXG4gICAgX19yZW5kZXIoKSB7XG4gICAgICAgIGlmKCF0aGlzLl9yZWFkeVRvUmVuZGVyKSByZXR1cm47XG4gICAgICAgIC8vIGlmKHRoaXMuaGFzQW5pbWVBbmRGcmFtZVJlbmRlcmVkKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5ydW5BbmltZUZyYW1lKCk7XG4gICAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtKCk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2JlZm9yZUpmbG93UmVuZGVyJywge1xuICAgICAgICAgICAgY3R4XG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3QgYnIgPSB0aGlzLl9nZXRWaWV3Qm94KCk7XG5cbiAgICAgICAgaWYodGhpcy5Ob2RlUmVuZGVyVG9wKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5rU3RhY2sucmVuZGVyKGN0eCwgKGxpbmspID0+ICFsaW5rLk9OX1RPUCAmJiBsaW5rLmlzSW5WaWV3Qm94KGJyKSk7XG4gICAgICAgICAgICB0aGlzLl9zdGFjay5yZW5kZXIoY3R4LCAoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkb092ZXJsYXAoYnIsIGluc3RhbmNlLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5faXNJblZpZXdCb3ggPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fbGlua1N0YWNrLnJlbmRlcihjdHgsIChsaW5rKSA9PiBsaW5rLk9OX1RPUCAmJiBsaW5rLmlzSW5WaWV3Qm94KGJyKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFjay5yZW5kZXIoY3R4LCAoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkb092ZXJsYXAoYnIsIGluc3RhbmNlLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhpbnN0YW5jZS5fbGF5b3V0Tm9kZS50eXBlLCByZXN1bHQpXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuX2lzSW5WaWV3Qm94ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2xpbmtTdGFjay5yZW5kZXIoY3R4LCAobGluaykgPT4gbGluay5pc0luVmlld0JveChicikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGN0eC5zYXZlKCk7XG4gICAgICAgIC8vIGZvcihsZXQgaSA9MDtpPDIwMDA7aSsrKSB7XG4gICAgICAgIC8vICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIC8vICAgICBjdHguZmlsbFN0eWxlID0gYHJnYigke3BhcnNlSW50KE1hdGgucmFuZG9tKCkqMjU1KX0sJHtwYXJzZUludChNYXRoLnJhbmRvbSgpKjI1NSl9LCR7cGFyc2VJbnQoTWF0aC5yYW5kb20oKSoyNTUpfSlgXG4gICAgICAgIC8vICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgIC8vICAgICAgICAgTWF0aC5yYW5kb20oKSoyNTAsIFxuICAgICAgICAvLyAgICAgICAgIE1hdGgucmFuZG9tKCkqMjQwLCBcbiAgICAgICAgLy8gICAgICAgICBNYXRoLnJhbmRvbSgpKjIwMCwgXG4gICAgICAgIC8vICAgICAgICAgTWF0aC5yYW5kb20oKSozMDApXG4gICAgICAgIC8vIH1cbiAgICAgICAgXG4gICAgICAgIC8vIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgaWYodGhpcy5fdGVtcE5vZGUpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICB0aGlzLl90ZW1wTm9kZS5yZW5kZXIoY3R4KVxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLl90ZW1wTGluaykge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBMaW5rLmlzSW5WaWV3Qm94KGJyKVxuICAgICAgICAgICAgdGhpcy5fdGVtcExpbmsucmVuZGVyKGN0eClcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2FmdGVySmZsb3dSZW5kZXInLCB7XG4gICAgICAgICAgICBjdHhcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLnJlbmRlclNjcm9sbEJhcihjdHgpO1xuICAgICAgICAvLyB0aGlzLnNldEZyYW1lUmVuZGVyZWQoKTtcbiAgICB9XG59XG5PYmplY3QuYXNzaWduKEpGbG93LnByb3RvdHlwZSwgTWVzc2FnZU1peGluKTtcbk9iamVjdC5hc3NpZ24oSkZsb3cucHJvdG90eXBlLCBTdGFja01peGluKTtcbk9iamVjdC5hc3NpZ24oSkZsb3cucHJvdG90eXBlLCBMYXlvdXRNaXhpbik7XG5PYmplY3QuYXNzaWduKEpGbG93LnByb3RvdHlwZSwge1xuICAgIHJlY2FsY3VsYXRlVXAoKSB7XG4gICAgICAgIGlmKHRoaXMuX19tb3VudGVkX18pIHtcbiAgICAgICAgICAgIHRoaXMucmVmbG93KCk7XG4gICAgICAgIH1cbiAgICB9XG59KVxuXG5PYmplY3QuYXNzaWduKEpGbG93LnByb3RvdHlwZSwgTm9kZVdlYWtNYXBNaXhpbik7XG5PYmplY3QuYXNzaWduKEpGbG93LnByb3RvdHlwZSwgQW5pbWVNaXhpbik7XG5PYmplY3QuYXNzaWduKEpGbG93LnByb3RvdHlwZSwgTWluaU1hcE1peGluKTtcbk9iamVjdC5hc3NpZ24oSkZsb3cucHJvdG90eXBlLCBTY2hlZHVsZU1peGluKTtcbk9iamVjdC5hc3NpZ24oSkZsb3cucHJvdG90eXBlLCBTY3JvbGxCYXJNaXhpbik7XG5cbmV4cG9ydCBkZWZhdWx0IEpGbG93O1xuZXhwb3J0IHsgSkZMT1dfTU9ERSB9IGZyb20gJy4uL3V0aWxzL2NvbnN0YW5jZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEpGbG93RXZlbnQgfSBmcm9tICcuLi9ldmVudHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjb21tb25FdmVudEFkYXB0ZXIgfSBmcm9tICcuLi9ldmVudHMvY29tbW9uQWRhcHRlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEluc3RhbmNlIH0gZnJvbSAnLi4vaW5zdGFuY2UvaW5zdGFuY2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBOb2RlIH0gZnJvbSAnLi4vaW5zdGFuY2Uvbm9kZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEJhc2VMaW5rIH0gZnJvbSAnLi4vaW5zdGFuY2UvYmFzZS1saW5rJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUG9pbnQgfSBmcm9tICcuLi9pbnN0YW5jZS9zaGFwZXMvcG9pbnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSZWN0YW5nbGUgfSBmcm9tICcuLi9pbnN0YW5jZS9zaGFwZXMvcmVjdGFuZ2xlJztcbi8vIGV4cG9ydCB7IGRlZmF1bHQgYXMgR3JvdXAgfSBmcm9tICcuLi9pbnN0YW5jZS9zaGFwZXMvcmVjdGFuZ2xlLWdyb3VwJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2Fwc3VsZSB9IGZyb20gJy4uL2luc3RhbmNlL3NoYXBlcy9jYXBzdWxlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2Fwc3VsZVZlcnRpY2FsIH0gZnJvbSAnLi4vaW5zdGFuY2Uvc2hhcGVzL2NhcHN1bGUtdmVydGljYWwnO1xuLy8gZXhwb3J0IHsgZGVmYXVsdCBhcyBDYXBzdWxlR3JvdXAgfSBmcm9tICcuLi9pbnN0YW5jZS9zaGFwZXMvY2Fwc3VsZS1ncm91cCc7XG4vLyBleHBvcnQgeyBkZWZhdWx0IGFzIENhcHN1bGVWZXJ0aWNhbEdyb3VwIH0gZnJvbSAnLi4vaW5zdGFuY2Uvc2hhcGVzL2NhcHN1bGUtdmVydGljYWwtZ3JvdXAnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEaWFtb25kIH0gZnJvbSAnLi4vaW5zdGFuY2Uvc2hhcGVzL2RpYW1vbmQnO1xuLy8gZXhwb3J0IHsgZGVmYXVsdCBhcyBEaWFtb25kR3JvdXAgfSBmcm9tICcuLi9pbnN0YW5jZS9zaGFwZXMvZGlhbW9uZC1ncm91cCc7XG4vLyBleHBvcnQgeyBkZWZhdWx0IGFzIERpYW1vbmRWZXJ0aWNhbEdyb3VwIH0gZnJvbSAnLi4vaW5zdGFuY2Uvc2hhcGVzL2RpYW1vbmQtdmVydGljYWwtZ3JvdXAnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSaG9tYnVzIH0gZnJvbSAnLi4vaW5zdGFuY2Uvc2hhcGVzL3Job21idXMnO1xuLy8gZXhwb3J0IHsgZGVmYXVsdCBhcyBSaG9tYnVzR3JvdXAgfSBmcm9tICcuLi9pbnN0YW5jZS9zaGFwZXMvcmhvbWJ1cy1ncm91cCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRleHQgfSBmcm9tICcuLi9pbnN0YW5jZS9lbGVtZW50cy90ZXh0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSWNvbiB9IGZyb20gJy4uL2luc3RhbmNlL2ltYWdlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2hhZG93RG9tIH0gZnJvbSAnLi4vaW5zdGFuY2Uvc2hhZG93RG9tJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgR3JvdXBGYWN0b3J5IH0gZnJvbSAnLi4vaW5zdGFuY2UvZ3JvdXBGYWN0b3J5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGluayB9IGZyb20gJy4uL2luc3RhbmNlL2xpbmsnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQb2x5TGluayB9IGZyb20gJy4uL2luc3RhbmNlL3BvbHktbGluayc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEJlemllckxpbmsgfSBmcm9tICcuLi9pbnN0YW5jZS9iZXppZXItbGluayc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIExpbmVhckxheW91dH0gZnJvbSAnLi4vbGF5b3V0L2xpbmVhci1sYXlvdXQnO1xuLy8gZXhwb3J0IHsgZGVmYXVsdCBhcyBUcmVlTGF5b3V0IH0gZnJvbSAnLi4vbGVyLWxheW91dGE7eW91dC90cmVlLWxheW91dCc7XG4vLyBleHBvcnQgeyBkZWZhdWx0IGFzIExvd2NvZGVsYXlvdXQgfSBmcm9tICcuLi9sYXlvdXQvbG93LWNvZGUtbGF5b3V0Jztcbi8vIGV4cG9ydCB7IGRlZmF1bHQgYXMgRVJMYXlvdXQgfSBmcm9tICcuLi9sYXlvdXQvZXItbGF5b3V0L2VyLWxheW91dCc7XG4vLyBleHBvcnQgeyBkZWZhdWx0IGFzIE9yYW5nZSB9IGZyb20gJy4uL2luc3RhbmNlL25vZGVXcmFwcGVyL29yYW5nZS9vcmFuZ2UnXG4vLyBleHBvcnQgeyBkZWZhdWx0IGFzIFRleHRFZGl0b3IgfSBmcm9tICcuLi9pbnN0YW5jZS90ZXh0LWVkaXRvcic7XG4vLyBleHBvcnQgeyBkZWZhdWx0IGFzIFRleHRHcm91cH0gZnJvbSAnLi4vaW5zdGFuY2UvdGV4dC1ncm91cCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRleHRHcm91cH0gZnJvbSAnLi4vaW5zdGFuY2UvdGV4dC1ncm91cC90ZXh0LWdyb3VwJztcbmV4cG9ydCB7IFRleHRFbGVtZW50IH0gZnJvbSAnLi4vaW5zdGFuY2UvdGV4dC1ncm91cC9zdG9yYWdlJztcbi8vIGV4cG9ydCB7IEpGbG93UGF0aDJEIH0gZnJvbSAnLi4vdXRpbHMvcGF0aC0yZCc7XG5cbmV4cG9ydCB7IE5vZGVQbGFjZWhvbGRlciB9IGZyb20gJy4uL2luc3RhbmNlL25vZGUtcGxhY2Vob2xkZXInO1xuZXhwb3J0IHsgYWRkUmVmbG93V29yayB9IGZyb20gJy4uL2RpcnR5LXdvcmsvZGlydHktd29yayc7XG4iLCJpbXBvcnQgcGFja2FnZUpzb24gZnJvbSAnLi4vcGFja2FnZS5qc29uJztcbmltcG9ydCB7IGRlZmF1bHQgYXMgSkZsb3cgfSBmcm9tICcuL2NvcmUvZmxvdyc7IFxuZXhwb3J0IGRlZmF1bHQgSkZsb3c7XG5leHBvcnQgKiBmcm9tICcuL2NvcmUvZmxvdyc7XG4vLyBleHBvcnQgeyBkZWZhdWx0IGFzIEpGbG93VnVlUGx1Z2luLCBKRmxvd0xpbmtHcm91cCB9IGZyb20gJy4vdnVlLXBsdWdpbi9KRmxvd1BsdWdpbi5qcyc7XG5KRmxvdy4kamZsb3dfdmVyc2lvbiA9IHBhY2thZ2VKc29uLnZlcnNpb247XG4vLyBjb25zb2xlLmxvZyhgamZsb3cgdmVyc2lvbkAke3BhY2thZ2VKc29uLnZlcnNpb259YCkiXSwibmFtZXMiOlsiY3JlYXRlQ2FudmFzIiwid3JhcHBlciIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImN0eCIsImdldENvbnRleHQiLCJfd3JhcHBlciRnZXRCb3VuZGluZ0MiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aWR0aCIsImhlaWdodCIsImxlZnQiLCJ0b3AiLCJzdHlsZSIsInVzZXJTZWxlY3QiLCJzY2FsZSIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJNYXRoIiwiZmxvb3IiLCJwb3NpdGlvbiIsIm92ZXJmbG93IiwiYXBwZW5kIiwicmF3X3dpZHRoIiwicmF3X2hlaWdodCIsInJlc2l6ZUNhbnZhcyIsIl93cmFwcGVyJGdldEJvdW5kaW5nQzIiLCJjYWhlQ2FudmFzIiwiY2FoZUNhbnZhc2N0eCIsInJlcXVlc3RDYWNoZUNhbnZhcyIsInJlbmRlciIsImNsZWFyUmVjdCIsInNhdmUiLCJyZXN0b3JlIiwibGlzdGVuT25EZXZpY2VQaXhlbFJhdGlvIiwiY2FsbGJhY2siLCJkZXN0cm95SGFuZGxlciIsInRhcmdldCIsIm1hdGNoTWVkaWEiLCJjb25jYXQiLCJvbkNoYW5nZSIsImNvbnNvbGUiLCJsb2ciLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib25jZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJESVJFQ1RJT04iLCJSSUdIVCIsIkJPVFRPTSIsIkxFRlQiLCJUT1AiLCJTRUxGIiwibmV4dERpcmVjdGlvbiIsImRpcmVjdGlvbiIsImNsb2Nrd2lzZSIsIm5leHREaXIiLCJvcHBvc2l0ZURpcmVjdGlvbiIsIkFQUFJPWElNQVRFIiwiSkZMT1dfTU9ERSIsIkRFRkFVTFQiLCJMSU5LSU5HIiwiTElORV9ESVIiLCJGUk9NIiwiVE8iLCJCZXppZXIiLCJib3VuZGluZ19ib3giLCJwb2ludHMiLCJsZW5ndGgiLCJ4IiwieSIsIm1pbl94IiwiSW5maW5pdHkiLCJtaW5feSIsIm1heF94IiwibWF4X3kiLCJpZHgiLCJpdGVtIiwibWF4Iiwic3FyIiwiZGlzdDIiLCJ2IiwidyIsImRpc3RUb1NlZ21lbnRTcXVhcmVkIiwicCIsImwyIiwidCIsIm1pbiIsIm1pbkludGVyc2VjdGlvbkJldHdlZW5Ob2RlcyIsImRtc2Zyb20iLCJkbXN0byIsIm1ldGEiLCJmcm9tRGlyIiwiZnJvbVAiLCJ0b0RpciIsInRvUCIsImRpc3RNaW4iLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImRmIiwicGYiLCJkdCIsInB0IiwiZGlzdCIsImFzc2lnbiIsIl9yZXNvbHZlQ29udHJvbFBvaW50IiwiZGlyIiwic3BhbngiLCJzcGFueSIsImJlemllclBvaW50cyIsInAxIiwicDIiLCJzdGFydF9kaXIiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJlbmRfZGlyIiwibWluU3BhblgiLCJtaW5TcGFuWSIsImFicyIsImNwMSIsImNwMiIsImFycm93c3BhbiIsImluY2x1ZGVzIiwiaXNWZXJ0aWNhbEVuZCIsImVuZFgiLCJlbmRZIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiYmV6aWVyUG9pbnQiLCJQIiwicSIsInUiLCJhbmdsZSIsImF0YW4yIiwiZGlzdFRvQmV6aWVyU2VnbWVudFNxdWFyZWQiLCJiIiwiX2NvbnN0cnVjdCIsInBvaW50IiwicHJvamVjdCIsImQiLCJnZXRCZXppZXJBbmdsZSIsInN4Iiwic3kiLCJjcDF4IiwiY3AxeSIsImNwMngiLCJjcDJ5IiwiZXgiLCJleSIsImR4IiwicG93IiwiZHkiLCJQSSIsImdldEluc3RhbmNlSGVpZ2h0IiwiaW5zdGFuY2UiLCJyZWN0IiwiZ2V0Qm91bmRpbmdSZWN0IiwicG9seWxpbmVQb2ludHMiLCJpc1NlbGYiLCJkaXJTcGFuIiwiaXNWZXJ0aWNhbFN0YXJ0IiwieXAiLCJwdXNoIiwieHAiLCJwbWlkZGxlIiwidW5zaGlmdCIsIm1pbnVzVmVjIiwiYWJzVmVjIiwidmVjIiwic3FydCIsInNjYWxlVmVjIiwibWFrZVJhZGl1c0Zyb21WZWN0b3IiLCJwYmVmb3JlIiwicG5leHQiLCJyYWRpdXMiLCJ2ZWMxIiwidmVjMiIsImFic1ZlYzEiLCJhYnNWZWMyIiwicjEiLCJyMiIsImRvT3ZlcmxhcCIsInJlYzEiLCJyZWMyIiwiaXNQb2x5TGluZUludGVyc2VjdGlvblJlY3RhbmdlIiwicG9seWxpbmUiLCJsIiwiaSIsIl9yZWN0IiwiX3NsaWNlZFRvQXJyYXkiLCJsMCIsImwxIiwicjAiLCJjcCIsImRlYm91bmNlIiwiZnVuYyIsIl90aGlzIiwidGltZW91dCIsInRpbWVyIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImNhbGwiLCJjb21wYXJlQm91bmRpbmdib3giLCJhIiwiY29weUJvdW5kaW5nYm94IiwiaXNoaXRLZXkiLCJTeW1ib2wiLCJpc0luVmlld0JveCIsIkluc3RhbmNlIiwiX0V2ZW50VGFyZ2V0IiwiX2luaGVyaXRzIiwiX3N1cGVyIiwiX2NyZWF0ZVN1cGVyIiwiY29uZmlncyIsIl9jbGFzc0NhbGxDaGVjayIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJ2aXNpYmxlIiwiX2JlbG9uZ3MiLCJib3JkZXJXaWR0aCIsImJvcmRlckNvbG9yIiwiYmFja2dyb3VuZENvbG9yIiwic2hhZG93Q29sb3IiLCJzaGFkb3dCbHVyIiwic2hhZG93T2Zmc2V0WCIsInNoYWRvd09mZnNldFkiLCJvcGFjaXR5IiwiX2JvdW5kaW5ncmVjdCIsIl9jcmVhdGVDbGFzcyIsImtleSIsImdldCIsIl9qZmxvdyIsIl90YXJnZXQiLCJsaW5rIiwiX2dldE1vdmluZ1RhcmdldCIsInN0YXR1cyIsIm1vdmluZ1N0YXRlIiwic2V0IiwiaXNoaXQiLCJkaXNwYXRjaEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJqZmxvdyIsIl9qZmxvd1Jvb3QiLCJ1bmlxdWVOYW1lIiwidmFsIiwib2xkdmFsIiwib25FbnRlclZpZXdib3giLCJvbkxlYXZlVmlld2JveCIsInZhbHVlIiwic2V0Q29uZmlnIiwiX3RoaXMyIiwiayIsImlzSGl0IiwiY2FsY3VsYXRlSW50ZXJzZWN0aW9uIiwiZ2V0SW50ZXJzZWN0aW9uc0luRm91ckRpbWVuc2lvbiIsImdldENlbnRlciIsImFuY2hvciIsImdldEJvdW5kaW5nRGltZW5zaW9uIiwiYnViYmxlRXZlbnQiLCJjdXN0b21FdmVudCIsImN1cnJlbnRUYXJnZXQiLCJidWJibGVzIiwiY2FsY3VsYXRlVG9SZWFsV29ybGQiLCJjYWxjdWxhdGVUb1JlYWxXb3JsZFdpdGhQb2ludGVyIiwib3V0cG9pbnQiLCJpbnBvaW50IiwiY2FsY3VsYXRlVG9SZWFsV29ybGRXaXRoU2NhbGFyIiwicmVjYWxjdWxhdGVVcCIsImRlc3Ryb3kiLCJfd3JhcE5hdGl2ZVN1cGVyIiwiRXZlbnRUYXJnZXQiLCJxdWV1ZSIsImNsZWFyUXVldWUiLCJxdWV1ZVNldCIsIldlYWtTZXQiLCJjaGVja1dvcmsiLCJoYXMiLCJnZXRTdGFja1BhdGgiLCJub2RlIiwiZXhwIiwiX3N0YWNrIiwiZmluZEluZGV4IiwibiIsInNvcnRCeVBhdGgiLCJtYXAiLCJXZWFrTWFwIiwic29ydCIsImFwYXRoIiwiYnBhdGgiLCJfYSIsInNwbGl0IiwiX2IiLCJfcCIsIl9xIiwiYWRkQ2xlYXJTb3VyY2VXb3JrIiwic291cmNlIiwiYWRkUmVmbG93V29yayIsInBhcmVudCIsImRvUmVjYWxjdWxhdGUiLCJhZGQiLCJmbHVzaCIsImluRmx1c2giLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJyb290cyIsIlNldCIsInNoaWZ0IiwiX2NsZWFyUXVldWUkc2hpZnQiLCJfY2xlYXJRdWV1ZSRzaGlmdDIiLCJnZXRSZW5kZXJOb2RlQnlTb3VyY2UiLCJjbGVhclNvdXJjZSIsIkFycmF5IiwiZnJvbSIsIl9yZW5kZXIiLCJOb2RlIiwiX0luc3RhbmNlIiwiX2RlZmluZVByb3BlcnR5IiwiX3Jhd0NvbmZpZ3MiLCJhYnNvbHV0ZVBvc2l0aW9uIiwic3RhY2siLCJzIiwiX3RoaXMzIiwic2V0QW5jaG9yWCIsInNldEFuY2hvclkiLCJzZXRBbmNob3IiLCJiZWZvcmVSZW5kZXIiLCJfZ2V0Vmlld0JveCIsImNsb25lIiwiQyIsImNvbnN0cnVjdG9yIiwiR2hvc3ROb2RlIiwiX05vZGUiLCJfdGhpcyRhbmNob3IiLCJ4MiIsInkyIiwiX3JlZiIsIl90aGlzJGFuY2hvcjIiLCJnZXRNYXBPYmplY3QiLCJsYXlvdXROb2RlIiwiamZsb3dOb2RlIiwiamZsb3dsaW5rcyIsImpmbG93RnJvbUxpbmtzIiwiamZsb3dUb0xpbmtzIiwiTm9kZVdlYWtNYXAiLCJfbWFwIiwiTWFwIiwib2JqIiwiX2RlbGV0ZSIsImNsZWFyIiwiTm9kZVdlYWtNYXBNaXhpbiIsImluaXROb2RlV2Vha01hcCIsInNvdXJjZV9MYXlvdXRfUmVuZGVyX05vZGVNYXAiLCJtYXBwaW5nIiwicmVtb3ZlUmVuZGVyTm9kZUJ5U291cmNlIiwic2l6ZSIsImdldExheW91dE5vZGVCeVNvdXJjZSIsImdldFNvdXJjZVJlbmRlck1ldGEiLCJfbWV0YSIsIl9vYmplY3RTcHJlYWQiLCJfZ2V0TWFwIiwic2V0TGF5b3V0Tm9kZUJ5U291cmNlIiwic2V0UmVuZGVyTm9kZUJ5U291cmNlIiwidG8iLCJhZGRMaW5rTm9kZUJ5U291cmNlIiwic291cmNlRnJvbSIsInNvdXJjZVRvIiwicmVtb3ZlTGlua05vZGVCeVNvdXJjZSIsImNoYW5nZUxpbmtOb2RlQnlTb3VyY2UiLCJwcmV2U291cmNlIiwibmV4dFNvdXJjZSIsImNoYW5nZU5vZGVCeVNvdXJjZSIsIm9sZG9iaiIsIm5ld29iaiIsIkluc3RhbmNlU3RhY2siLCJfQXJyYXkiLCJfY3VycmVudEhpdCIsImNiIiwiX2dldCIsIl9nZXRQcm90b3R5cGVPZiIsInByb3RvdHlwZSIsInR5cGUiLCJmaWx0ZXIiLCJzbGljZSIsInN1cGVyZmlsdGVyIiwiY29uZGl0aW9uIiwibW92aW5nVGFyZ2V0IiwiX2lzTW92aW5nIiwicmVzZXRIaXRTdGF0dXMiLCJfaXNIaXQiLCJjaGVja0hpdCIsImN1cnJlbnRDb25zdHJhaW50IiwiaWdub3JlSGl0IiwiZ2V0Qm91bmRpbmdSZWN0UG9pbnRzIiwiZ2V0QW5jaG9yUmVjdFBvaW50cyIsIlN0YWNrTWl4aW4iLCJpbnN0YW5jZXMiLCJsaW5rcyIsIl9saW5rU3RhY2siLCJpbml0U3RhY2siLCJkYXRhIiwiYWRkVG9TdGFjayIsImluc2VydFRvU3RhY2tCZWZvcmUiLCJhbmNob3JOb2RlIiwicmVtb3ZlRnJvbVN0YWNrIiwic3BsaWNlIiwicmVwbGFjZUZyb21TdGFjayIsImluZGV4IiwiYWRkVG9MaW5rU3RhY2siLCJmaW5kIiwicmVtb3ZlRnJvbUxpbmtTdGFjayIsImVtcHR5TGluayIsInJlc2V0Q2hpbGRyZW5Qb3NpdGlvbiIsImFkZEluc3RhbmNlVG9MaW5rIiwidGFyZ2V0TGluayIsIl9jb25zdHVjdG9yIiwiX19wcm90b19fIiwiaW50ZXJhdGVOb2RlU3RhY2siLCJMYXlvdXRNaXhpbiIsIl9sYXlvdXQiLCJpbml0TGF5b3V0IiwibGF5b3V0IiwiX3RoaXMkX2JlbG9uZ3MiLCJkaXJ0eSIsIl90aGlzJGdldEJvdW5kaW5nRGltZSIsIndvbGQiLCJob2xkIiwiX2dldEJvdW5kaW5nR3JvdXBSZWN0IiwicmVmbG93IiwiX3RoaXMkZ2V0Qm91bmRpbmdEaW1lMiIsIndub3ciLCJobm93IiwicmVjYWxjdWxhdGVEb3duIiwicmVmbG93QWZ0ZXIiLCJyZWNhbGN1bGF0ZSIsInN0YXRpY0NoZWNrIiwiTWVzc2FnZU1peGluIiwiX21lc3NhZ2UiLCJzZW5kTWVzc2FnZSIsIm1zZyIsImNvbnN1bWVNZXNzYWdlIiwicmVhZE1lc3NhZ2UiLCJpbml0QW5pbWUiLCJhbmltZV9xdWV1ZSIsIl9fYW5pbWVDbG9ja19fIiwicmVxdWVzdEpGbG93QW5pbWUiLCJmcmFtZUNhbGxCYWNrIiwiZW5xdWV1ZUFuaW1lIiwiX3J1bkFuaW1lIiwiYW5pbWVNZXRhIiwic3RhcnQiLCJjYW5jZWwiLCJfY2FuY2VsQW5pbWUiLCJtIiwicnVuQW5pbWUiLCJzY2hlZHVsZVJlbmRlciIsInJ1bkFuaW1lRnJhbWUiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93IiwiZWxhcHNlZCIsImNhcHR1cmVNYXAiLCJfcmVmJHBhZGRpbmciLCJwYWRkaW5nIiwiX3JlZiRwbGFjZW1lbnQiLCJwbGFjZW1lbnQiLCJfdGhpcyRib3VuZGluZ19ib3giLCJwX3dpZHRoIiwicF9oZWlnaHQiLCJwX3giLCJwX3kiLCJtaW5pTWFwIiwiX3RoaXMkbWluaU1hcCIsIl9yZW5kZXJNYXAiLCJwcmVzc0Rvd24iLCJldmVudCIsIm9mZnNldFgiLCJvZmZzZXRZIiwiZGVsdGFYIiwiZGVsdGFZIiwiX29uTW92ZU1hcCIsImNhY2hlTWluaW1hcEN0eCIsIl90aGlzJG1pbmlNYXAyIiwicGFkMiIsInBhZCIsInIiLCJtX3giLCJtX3kiLCJjYWNoZWN0eCIsInNldFRyYW5zZm9ybSIsInRyYW5zZm9ybSIsImJyIiwiTm9kZVJlbmRlclRvcCIsIl9jYWNoZU1hcEltYWdlRGF0YSIsImdldEltYWdlRGF0YSIsInB1dEltYWdlRGF0YSIsIl90aGlzJF9nZXRWaWV3Qm94IiwiX3RoaXMkX2dldFZpZXdCb3gyIiwiYmVnaW5QYXRoIiwiY2xpcCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiX3RoaXMkX2dldFZpZXdCb3gzIiwiX3RoaXMkX2dldFZpZXdCb3g0IiwiX3JlY2FsY3VsYXRlUG9zaXRpb24iLCJKRmxvd0V2ZW50IiwiX0N1c3RvbUV2ZW50Iiwib3JpZ2luRXZlbnQiLCJTY3JvbGxCYXIiLCJiYXJXaWR0aCIsImJhck1hcmdpblgiLCJiYXJNYXJnaW5ZIiwicGxhaW5Db2xvciIsImZvY3VzQ29sb3IiLCJpc0ZvY3VzIiwiY3kiLCJieSIsInJjIiwibGMiLCJtb3ZlVG8iLCJhcmMiLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJ0YyIsImJjIiwiY3giLCJyeCIsImZpbGwiLCJoIiwiaW5pdFNjcm9sbEJhciIsImJhckNvbG9yIiwiYmFyRm9jdXNDb2xvciIsIl9zY3JvbGxiYXJFbmFibGUiLCJfc2Nyb2xsYmFyWCIsIl9zY3JvbGxiYXJZIiwiX3Njcm9sbEJhclN0YXR1cyIsImRyYWdnaW5nIiwieHNjYWxlIiwieXNjYWxlIiwiYmFySW5pdFgiLCJiYXJJbml0WSIsInN0b3Bab29tcGFuV2F0Y2giLCJzY3JvbGxCYXJPblBhbkFuZFpvb20iLCJlIiwiY2xpZW50WCIsImNsaWVudFkiLCJvblNjcm9sbGJhclByZXNzU3RhcnQiLCJjaGVja1Njcm9sbERyYWdnaW5nIiwieGhpdCIsImJhclN0YXJ0WCIsInloaXQiLCJiYXJTdGFydFkiLCJmIiwib25EcmFnZ2luZ1Njcm9sbGJhciIsImJpbmQiLCJfdGhpcyRfc2Nyb2xsQmFyU3RhdHUiLCJzY29sbGJhckhlaWdodCIsInNjb2xsYmFyV2lkdGgiLCJyZWFsUiIsInJlYWxMIiwicmVhbFQiLCJyZWFsQiIsIl90aGlzJGNhbnZhc01ldGEiLCJjYW52YXNNZXRhIiwiYWN0dWFsX3dpZHRoIiwiYWN0dWFsX2hlaWdodCIsInhuZXciLCJyYXRpb0luWCIsInJhdGlvWCIsInluZXciLCJyYXRpb0luWSIsInJhdGlvWSIsImNoZWNrU2Nyb2xsQmFySG92ZXIiLCJjdXJzb3IiLCJyZXNldFNjcm9sbEJhckhvdmVyIiwiX2dldFNjcm9sbFZpZXdCb3VuZGluZ2JveCIsIl90aGlzJGJvdW5kaW5nX2JveDIiLCJfdGhpcyRfZ2V0U2Nyb2xsVmlld0IiLCJ2dyIsInZoIiwiX3RoaXMkY2FudmFzTWV0YTIiLCJhbmNob3JYIiwiYW5jaG9yWSIsInJlc2V0U2NvbGxCYXJTdGF0dXMiLCJyZW5kZXJTY3JvbGxCYXIiLCJkcHIiLCJfdGhpcyRfc2Nyb2xsQmFyU3RhdHUyIiwidG9nZ2xlUmVuZGVyIiwiX19yZW5kZXJzdG9wX18iLCJpbml0U2NoZWR1bGUiLCJfX2Nsb2NrX18iLCJpc0ZpcnN0VGltZSIsIl9fcmVuZGVyIiwiZ2V0RGVmYXVsdFBsdWdpbiIsIl9tb3VzZVN0YXR1cyIsInBvaW50ZXJEb3duIiwid2hlZWwiLCJwcmV2ZW50RGVmYXVsdCIsImN0cmxLZXkiLCJ6b29tSGFuZGxlciIsInBhbkhhbmRsZXIiLCJwb2ludGVyZG93biIsImJ1dHRvbiIsInByZXNzU3RhcnRIYW5kbGVyIiwicG9pbnRlcm1vdmUiLCJwcmVzc01vdmVIYW5kbGVyIiwicG9pbnRlcnVwIiwicHJlc3NVcEhhbmxkZXIiLCJjb250ZXh0bWVudSIsInN0b3BQcm9wYWdhdGlvbiIsImNvbnRleHRNZW51SGFubGRlciIsImRibGNsaWNrIiwiZGJsY2xpY2tIYW5kbGVyIiwiY2xpY2siLCJjbGlja0hhbmxkZXIiLCJFdmVudEFkYXB0ZXIiLCJwbHVnaW4iLCJ1c2UiLCJjYW52YXNIYW5kbGVycyIsImRvY3VtZW50SGFuZGxlcnMiLCJjYSIsImRvY09iaiIsImV2ZW50TmFtZSIsImhhc093blByb3BlcnR5IiwiYXBwbHkiLCJfdGhpcyRwbHVnaW4iLCJfbG9vcCIsImhhbmRsZXIiLCJoYW5kbGVyV3JhcHBlcmQiLCJfbG9vcDIiLCJvcHRpb25zIiwidW5sb2FkIiwiX3JlZjIiLCJHcm91cE1peGluIiwiX3NldFBhZGRpbmciLCJwYWRkaW5nVG9wIiwicmlnaHQiLCJwYWRkaW5nUmlnaHQiLCJib3R0b20iLCJwYWRkaW5nQm90dG9tIiwicGFkZGluZ0xlZnQiLCJfc2V0TWFyZ2luIiwibWFyZ2luIiwibWFyZ2luVG9wIiwibWFyZ2luUmlnaHQiLCJtYXJnaW5Cb3R0b20iLCJtYXJnaW5MZWZ0IiwiX2dldENlbnRlciIsIm14IiwibXkiLCJjZW50ZXJYIiwiY2VudGVyWSIsIl9zaGFwZSIsIl9jZW50ZXIiLCJfY2FsY3VsYXRlUG9pbnRCYWNrIiwiX3BvaW50IiwiZ3giLCJneSIsIl90aGlzJF9nZXRDZW50ZXIiLCJfdGhpcyRfZ2V0Q2VudGVyMiIsIl9jYWxjdWxhdGVQb2ludEJhY2tXaXRoUG9pbnQiLCJhcnIiLCJpZHgxIiwiaWR4MiIsImNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uIiwiX3BvaW50MiIsIl90aGlzJF9nZXRDZW50ZXIzIiwiX3RoaXMkX2dldENlbnRlcjQiLCJfcG9pbnQzIiwiX3RoaXMkX2dldENlbnRlcjUiLCJfdGhpcyRfZ2V0Q2VudGVyNiIsImx0eCIsImx0eSIsInJieCIsInJieSIsIl9wMiIsIl9wb2ludDQiLCJ4MSIsInkxIiwidmVjeCIsInZlY3kiLCJ0aGV0YTEiLCJ0aGV0YTIiLCJkaXJ4IiwiZGlyeSIsIl9fbW91bnRlZF9fIiwiZGVmYXVsdFNoaWZ0IiwiR3JvdXBGYWN0b3J5IiwiamZsb3dOb2RlQ29uc3RydWN0b3IiLCJzaGFwZVNoaWZ0IiwiX2NvbmZpZ3MkbG9jayIsIl9jb25maWdzJHRyYW5zcGFyZW50IiwiZGVmaW5lZFdpZHRoIiwibWluV2lkdGgiLCJkZWZpbmVkSGVpZ2h0IiwibG9jayIsImRpc3BsYXkiLCJ0cmFuc3BhcmVudCIsIl9jYWNoZVZpZXdCb3giLCJfc2hhcGVTaGlmdCIsIl9zaGFwZVNoaWZ0MiIsInNoYXBlV2lkdGgiLCJzaGFwZUhlaWdodCIsImJib3giLCJwYWRkaW5nV2lkdGgiLCJwYWRkaW5nSGVpZ2h0IiwiX3BhZGRpbmdXaWR0aCIsIl9wYWRkaW5nSGVpZ2h0IiwiX3NoYXBlU2hpZnQzIiwiX3NoYXBlU2hpZnQ0IiwiYmVsb25nc192Ym94IiwiZ2V0Q2FjaGVWaWV3Qm94IiwiY2FjaGVWaWV3Qm94IiwiZ2xvYmFsQWxwaGEiLCJfdGhpcyRfZ2V0Q2VudGVyNyIsIl90aGlzJF9nZXRDZW50ZXI4IiwidHJhbnNsYXRlIiwiX2N1cnJlbnRwIiwiUG9pbnQiLCJfZG9DYWNoZSIsImxpbmVXaWR0aCIsInN0cm9rZVN0eWxlIiwic3Ryb2tlIiwicmF0aW8iLCJjYWxjdWxhdGVJbnRlcnNlY3Rpb25JbkZvdXJEaW1lbnNpb24iLCJlbmQiLCJfYWxsSW50ZXJzZWN0aW9ucyIsIl90aGlzJGFuY2hvcjMiLCJhbGxJbnRlcnNlY3Rpb25zIiwiaW50ZXJEaXIiLCJSZWN0YW5nbGUiLCJib3JkZXJSYWRpdXMiLCJfc2V0Qm9yZGVyIiwiX2NvbmZpZ3MkYm9yZGVyIiwiX2NvbmZpZ3MkYm9yZGVyMiIsIl9jb25maWdzJGJvcmRlcjMiLCJfY29uZmlncyRib3JkZXI0IiwiX2NvbmZpZ3MkYm9yZGVyNSIsIl9jb25maWdzJGJvcmRlcjYiLCJfY29uZmlncyRib3JkZXI3IiwiX2NvbmZpZ3MkYm9yZGVyOCIsIl9jb25maWdzJGJvcmRlcjkiLCJfY29uZmlncyRib3JkZXIxMCIsIl9jb25maWdzJGJvcmRlcjExIiwiX2NvbmZpZ3MkYm9yZGVyMTIiLCJib3JkZXIiLCJjb2xvciIsImVuYWJsZSIsInh0IiwieXQiLCJxdWFkcmF0aWNDdXJ2ZVRvIiwic3dpdGNoUGF0aCIsIlBhdGgyRCIsInR5IiwidG9wUGF0aCIsIl9wMyIsIl9wNCIsIkNhcHN1bGUiLCJodyIsImhoIiwibGVmdENlbnRlciIsInJpZ2h0Q2VudGVyIiwid3ciLCJyciIsIkNhcHN1bGVWZXJ0aWNhbCIsIl9DYXBzdWxlIiwidG9wQ2VudGVyIiwiYm90dG9tQ2VudGVyIiwieXkiLCJSaG9tYnVzIiwiZGlhZ29uYWxzViIsImRpYWdvbmFsc0giLCJjZW50ZXIiLCJEaWFtb25kIiwic2lkZSIsInNpblNJREUiLCJzaW4iLCJjb3NTSURFIiwiY29zIiwieHgiLCJfY2FjaGVQb2ludHMiLCJwb2x5Z29uIiwib2RkIiwiaiIsImJhY2tzcXJ0MyIsIkRpYW1vbmRWZXJ0aWNhbCIsIl9EaWFtb25kIiwidG9wbWlkZGxlIiwiYm90dG9tbWlkZGxlIiwieGxlZnQiLCJ4cmlnaHQiLCJJbm5lclNjcm9sbEJhciIsIl9TY3JvbGxCYXIiLCJzZXRIaXQiLCJvbkhpdCIsIlNjcm9sbEdyb3VwIiwiX3N1cGVyMiIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwiX29mZnNldCIsIl9yZXNldE9mZnNldCIsIl9mIiwiaGl0U2Nyb2xsWCIsImhpdFNjcm9sbFkiLCJfdGhpczQiLCJqZmxvd0luc3RhbmNlIiwiSkZMT1ciLCJfc2Nyb2xsV2lkdGgiLCJfb3V0ZXJXaWR0aCIsIl9pbm5lcldpZHRoIiwiX3Njcm9sbEhlaWdodCIsIl9vdXRlckhlaWdodCIsIl9pbm5lckhlaWdodCIsIm91dGVyV2lkdGgiLCJvdXRlckhlaWdodCIsIl90aGlzJF9vZmZzZXQiLCJ0eCIsIm9mZnNldCIsIl90aGlzJF9vZmZzZXQyIiwiX3RoaXMkX29mZnNldDMiLCJfdGhpcyRhbmNob3I0IiwidzIiLCJoMiIsIl90aGlzJF9vZmZzZXQ0IiwiX3RoaXMkYW5jaG9yNSIsInNwIiwiaXNJbkJvdW5kIiwiX3RoaXMkX29mZnNldDUiLCJCYXNlTGluayIsInZpZXdib3giLCJicmluZ1RvVG9wIiwibGlua1N0YWNrIiwiU2hhZG93Q2FjaGUiLCJpbWFnZUJ1ZmZlciIsImNhY2hlIiwiZHJhd0ltYWdlIiwiVEVYVF9BTElHTiIsIkNFTlRFUiIsIlNQQUNFX1JFRyIsIlRleHQiLCJfUmVjdGFuZ2xlIiwiY29udGVudCIsImZvbnRGYW1pbHkiLCJmb250U2l6ZSIsImZvbnRXZWlnaHQiLCJ0ZXh0Q29sb3IiLCJwbGFjZWhvbGRlckNvbG9yIiwidGV4dEFsaWduIiwidGV4dEJhc2VsaW5lIiwibGluZUhlaWdodCIsImluZGVudCIsImVkaXRhYmxlIiwiZWxsaXBzaXMiLCJwbGFjZWhvbGRlciIsImVtcHR5V2hlbklucHV0IiwiZWRpdHRpbmciLCJkaXNhYmxlZCIsImN1cnNvckNvbG9yIiwidGV4dFJhbmdlQ29sb3IiLCJzcGFjZVBsYWNlaG9sZGVyIiwic3BhY2VQbGFjZWhvbGRlckNvbG9yIiwic3BhY2VSZWNvcmRzIiwiX3NwYWNlZENvbnRlbnRTZWdtbmVudCIsIl9zdGF0dXMiLCJlZGl0aW5nIiwiY3Vyc29yc2hvdyIsImN1cnNvcmFuaW1lIiwibGFzdEVsYXBzZWQiLCJyZWZyZXNoRWxhcHNlZCIsImN1cnNvckRyYWdnaW5nIiwic2hpZnRPbiIsIm9sZFZhbCIsImlucHV0RWxlbWVudCIsIl9jdXJzb3JPZmZzZXQiLCJfdGV4dFJhbmdlIiwicmFuZ2Vmcm9tIiwicmFuZ2VUbyIsImluaXRpYWxSYW5nZSIsIl9tYWtlRnVuY3Rpb25hbCIsInByZUNhbGN1bGF0ZVRleHQiLCJzaGFkb3dDYWNoZSIsInJlcGxhY2VTcGFjZUhvbGRlciIsInVzZUNhY2hlIiwicmVwbGFjZSIsImxhc3RPZmZzZXQiLCJjIiwiXyIsImZvbnQiLCJ0X2giLCJwYXJzZUludCIsImN1cnJlbnRDb250ZW50IiwiX2N0eCRtZWFzdXJlVGV4dCIsIm1lYXN1cmVUZXh0IiwiZm9udEJvdW5kaW5nQm94QXNjZW50IiwiZm9udEJvdW5kaW5nQm94RGVzY2VudCIsIl90ZXh0V2lkdGgiLCJfY2FsY3VsYXRlT2Zmc2V0IiwiZWxsaXBzaXNDb250ZW50Iiwic3Vic3RyaW5nIiwiX2N0eCRtZWFzdXJlVGV4dDIiLCJzX3dpZHRoIiwicGNvbG9yIiwiX3RleHRIZWlnaHQiLCJfc2hhZG93Q2FjaGUiLCJpc0VtcHR5IiwiX3ciLCJzZWciLCJmaWxsVGV4dCIsIl90aGlzNSIsImZsYWciLCJfcG9zaXRpb25Ub0N1cnNvck9mZnNldCIsImNyZWF0ZUlucHV0RWxlbWVudCIsIl9jb250cm9sQ2FsbGJhY2siLCJfZGVmYXVsdENhbGxiYWNrIiwiRE9Nd3JhcHBlciIsImZvY3VzIiwicHJldmVudFNjcm9sbCIsInNldEZvY3VzSW5zdGFuY2UiLCJzeW5jU2hhZG93SW5wdXRQb3NpdGlvbiIsIl90aGlzNiIsImJsdXJIYW5kbGVyIiwicmVtb3ZlIiwiX3NlbGVjdEZ1bGxSYW5nZSIsIl9yZWZyZXNoQ3Vyc29yIiwiX3RoaXM2JF9zdGF0dXMkY3Vyc29yIiwibW92ZWQiLCJveCIsImN1cnNvck9mZnNldCIsIm9mZngiLCJfdGhpczciLCJtYXhMIiwiY29udGVudFdpZHRoIiwiYWxsd2lkdGgiLCJnMSIsImcyIiwibGFzdGlkeCIsImMxIiwiYzIiLCJ3MSIsInNwYW53IiwiZGlzYWJsZUNhY2hlIiwidGV4dGhlaWdodCIsImx4IiwibHkiLCJjdyIsImNfbGVuIiwiX3RoaXMkX3RleHRSYW5nZSIsInJhbmdlIiwiX2lucHV0Q29udHJvbCIsIm9wIiwiX2NsZWFyVGV4dFJhbmdlIiwicmVmcmVzaCIsInByZUNvbnRlbnQiLCJhZnRlckNvbnRlbnQiLCJjYWNoZUlkeCIsInN0b3BJbnB1dEV2ZW50IiwiZGVmYXVsdEFjdCIsInN0b3BJbnB1dCIsImJsdXIiLCJfdGhpczgiLCJweCIsIl9vbkFycm93TGVmdCIsIl9vbkFycm93UmlnaHQiLCJfb25TaGlmdFRvZ2dsZSIsIl9jb3B5IiwiX2N1dCIsIl9wYXN0ZSIsIl90aGlzJF90ZXh0UmFuZ2UyIiwiX2dldFNlbGVjdGlvbiIsIl90aGlzJF90ZXh0UmFuZ2UzIiwic2VsZWN0aW9uIiwiY2xpcGJvYXJkRGF0YSIsInNldERhdGEiLCJwYXN0ZUNvbnRlbnQiLCJnZXREYXRhIiwicmVzb2x2ZVBhc3RlQ29udGVudCIsImNvZGUiLCJyYXdFdmVudCIsIl9mb2N1cyIsImNvbnRyb2xDYWxsYmFjayIsImRlZmF1bHRDYWxsYmFjayIsImlucHV0Iiwic2V0QXR0cmlidXRlIiwiY3RybE9uIiwiSWNvbiIsImltYWdlIiwib25sb2FkIiwiaW1hZ2VCb3VuZGluZyIsImltYWdlV2lkdGgiLCJpbWFnZUhlaWdodCIsImNvbXBsZXRlIiwiU2hhZG93RG9tIiwiZG9tRmFjdG9yeSIsImNyZWF0ZURvY3VtZW50IiwiX2RvbSIsImdldFJlYWxXb3JsZFBvc2l0aW9uIiwiY29udGFpbmVyIiwicG9zIiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmVDaGlsZCIsIkxpbmsiLCJfQmFzZUxpbmsiLCJsaW5lRGFzaCIsImFwcHJveGltYXRlIiwiX2NhY2hlQW5nbGUiLCJfY2FjaGVCb3VuZGluZ2JveCIsIl9jYWxjdWxhdGVBbmNob3JQb2ludHMiLCJwMCIsImZyb21ib3giLCJ0b2JveCIsIl9ib3giLCJfdGhpcyRfY2FjaGVQb2ludHMiLCJhY3R1YWxCb3VuZGluZ0JveExlZnQiLCJhY3R1YWxCb3VuZGluZ0JveFJpZ2h0IiwicmVnaW9uIiwicnkiLCJydyIsInJoIiwic2V0TGluZURhc2giLCJyb3RhdGUiLCJfdGhpcyRfY2FjaGVQb2ludHMyIiwiUElJTlJBVElPIiwiUG9seUxpbmsiLCJkb3VibGVMaW5rIiwibm9BcnJvdyIsIl9zdGF0aWMiLCJwRW5kIiwiYW5nbGVFbmQiLCJiZWdpbkFuZ2xlIiwicExhc3QiLCJwTmV4dCIsIl9tYWtlUmFkaXVzRnJvbVZlY3RvciIsImxhc3RQIiwicmVtYWluUG9pbnRzIiwiY3VycmVudFAiLCJjbG9uZVN0YXRpYyIsIl9PYmplY3QkYXNzaWduIiwiQmV6aWVyTGluayIsImJlemllckN1cnZlVG8iLCJoYXNGbGlwIiwiX2JlemllclBvaW50IiwiX2JlemllclBvaW50MiIsIkxpbmVhckxheW91dCIsIl9jb25maWdzJGdhcCIsImdhcCIsImFsaWdubWVudCIsImp1c3RpZnkiLCJncm91cCIsImFic29sdXRlU3RhY2siLCJncm91cFdpZHRoIiwicmVkdWNlSGVpZ2h0IiwibGFzdEluc3RhbmNlSGVpZ2h0IiwiYWxsSGVpZ2h0IiwiY2hpbGRBbGwiLCJfaW5zdGFuY2UkZ2V0Qm91bmRpbmciLCJfaW5zdGFuY2UkZ2V0Qm91bmRpbmcyIiwiX2luc3RhbmNlJGdldEJvdW5kaW5nMyIsIl9pbnN0YW5jZSRnZXRCb3VuZGluZzQiLCJyZWR1Y2VXaWR0aCIsImxhc3RJbnN0YW5jZVdpZHRoIiwiYWxsV2lkdGgiLCJhbGxQdXJlV2lkdGgiLCJfaW5zdGFuY2UkZ2V0Qm91bmRpbmc1Iiwid2l0aGRyYXciLCJnYXBBdmVyYWdlIiwiX2luc3RhbmNlJGdldEJvdW5kaW5nNiIsIl9pbnN0YW5jZSRnZXRCb3VuZGluZzciLCJXSURUSCIsIkhFSUdIVCIsInNoaWZ0eSIsInNoaWZ0eCIsIl9yZXNvbHZlQWJzb2x1dGVBbmNob3IiLCJjb25maWciLCJfaW5zdGFuY2UkZ2V0Qm91bmRpbmc4IiwiRURJVE9SX0VWRU5UUyIsIklOUFVUIiwiQ09OVFJPTF9DTUQiLCJLRVlCT0FSRF9JTlBVVCIsIkNPTVBPU0lUSU9OX1NUQVJUIiwiQ09NUE9TSVRJT05fVVBEQVRFIiwiQ09NUE9TSVRJT05fRU5EIiwiRU5URVIiLCJERUxFVEUiLCJCQUNLU1BBQ0UiLCJLRVlCT0FSRF9DT01NQU5EUyIsIkFSUk9XX0xFRlQiLCJBUlJPV19SSUdIVCIsIkFSUk9XX1VQIiwiQVJST1dfRE9XTiIsIlVORE8iLCJSRURPIiwiU0hJRlRfRE9XTiIsIlNISUZUX1VQIiwiQ1RSTEEiLCJDT1BZIiwiQ1VUIiwiUEFTVEUiLCJNT1VTRV9DT01NQU5EUyIsIlNUQVJUX0VESVQiLCJFRElUX0NMSUNLIiwiU0hJRlRfT05fQ0xJQ0siLCJET1VCTEVfQ0xJQ0siLCJPUEVSUkFUSU9OIiwiUExBSU5JTlBVVCIsIlNQQUNFSU5QVVQiLCJSRVRVUk5JTlBVVCIsIkNBUkVUTU9WRU1FTlQiLCJERUxFVEVfSU5fTElORSIsIkRFTEVURV9JTl9FRElUQVJFQSIsIkVOU1VSRV9ERUxFVEUiLCJTRUxFQ1RJT05fREVMRVRFIiwiU0VMRUNUSU9OX0lOUFVUIiwiQ09NUE9TSVRFX0lOU0VSVCIsIlNoYWRvd0lucHV0IiwiX2lucHV0RWxlbWVudCIsImtpbmQiLCJzeW5jUG9zaXRpb24iLCJyZW1vdmVMaXNlbnRlciIsIkNhcmV0Iiwic2hvdyIsImFuaW1lIiwic2V0Um93Iiwicm93IiwiX3JvdyIsInNldENvbHVtbiIsImNvbHVtbm9yaWR4IiwiY29sdW1uIiwiX2NvbHVtbiIsImdldFJvdyIsImdldENvbHVtbiIsImFuaW1hdGUiLCJjYW5jZWxBbmltYXRlIiwiaXNTaG93IiwidG9SYW5nZSIsImZyb21SYW5nZSIsImNhbGN1bGF0ZU9mZnNldEJ5V2lkdGgiLCJ0ZXh0bWV0YSIsInNwYWNlSG9sZGVyIiwiZ2V0UmVuZGVyU291cmNlIiwiQXJlYSIsIl9saW5lcyIsImdldExpbmVBYm92ZSIsImxpbmVzIiwidHJ1bmNhdGUiLCJMaW5lIiwiY3JlYXRlIiwibGluZSIsIl9lbGVtZW50cyIsImluc2VydCIsImVsZW0iLCJ0YWlsIiwiY29weSIsImdldENvbHVtbk5lYXJlc3QiLCJlbGVtZW50U3BhY2UiLCJlZGl0b3IiLCJlbGVtZW50cyIsImVsZW1faWR4IiwibGFzdF9jIiwiX2MiLCJsYXN0ZWwiLCJlbCIsImRvdWJsZU1hcmdpbiIsIkZsYXR0ZW5UZXh0RWxlbWVudHMiLCJpbnNlcnRCZWZvcmUiLCJpbmVyc2V0QXQiLCJpbnNlcnRBZnRlciIsIm5lZWRXcmFwIiwic2V0TmVlZFdyYXAiLCJfdGV4dEVsZW1lbnRzIiwiX3RoaXMkX3RleHRFbGVtZW50cyIsInJlbW92ZWQiLCJfcmVjb3JkcyIsImFyZ3MiLCJfdGhpcyRfdGV4dEVsZW1lbnRzMiIsInN0YXJ0UmVjb3JkIiwiX2NhcmV0UmVjb3JkIiwiYmVmb3JlIiwiYWZ0ZXIiLCJnZXRSZWNvcmQiLCJyZWNvcmRCZWZvcmVDYXJldCIsImNhcmV0IiwicmVjb3JkQWZ0ZXJDYXJldCIsImdldENhcmV0UmVjb3JkIiwiY29sbGVjdFJlY29yZHMiLCJfZSIsIlRleHRFbGVtZW50Iiwic3ltYm9sIiwic2V0U291cmNlV2l0aFJlY29yZCIsInJlY29yZHMiLCJsYXN0U291cmNlIiwic2V0U291cmNlIiwiX3NwYWNlUmVjb3JkcyIsImxhc3RXcmFwIiwic3RlcCIsIm5leHRPZmZzZXQiLCJ0YWlsT2Zmc2V0IiwiaXNUYWlsIiwiaGVhZE9mZnNldCIsIl9yZXR1cm5TeW1ib2wiLCJyZXR1cm5Gb250IiwiUmFuZ2UiLCJzZXRJbml0aWFsUmFuZ2UiLCJfaW5pdGlhbFJhbmdlIiwiZ2V0UmFuZ2VGcm9tIiwiX3JhbmdlRnJvbSIsImdldFJhbmdlVG8iLCJfcmFuZ2VUbyIsImlzRW5hYmxlIiwiX2VuYWJsZSIsImRpc2FibGUiLCJoYW5kbGVDYXJldCIsIl90aGlzJF9yYW5nZVRvIiwic2V0UmFuZ2UiLCJhbm90aGVyIiwiX2NvbXBhcmVSYW5nZSIsImdldFJhbmdlQ29weSIsImFyZWEiLCJfYXJlYSIsIl9jYXJldCIsInJhbmdlRnJvbSIsImVsZW1Gcm9tIiwiZWxlbVRvIiwiZmxhdHRlblR4dEVsZW0iLCJfZmxhdHRlblR4dEVsZW0iLCJmcm9tSWR4IiwidG9JZHgiLCJlbGVtcyIsInByZUVsZW1lbnQiLCJhZnRlckVsZW1lbnQiLCJlbmRUZXh0TmVlZFdyYXAiLCJpc1NldFNvdXJjZUJhdGNoIiwiVW5kb1JlZG8iLCJ3cml0ZSIsImNhcmV0UmVjb3JkIiwibGFzdFVuZG8iLCJnZXRMYXN0VW5kbyIsIl9iYXRjaCIsIl9jYXJldE1ldGFUbyIsIkJhdGNoQWN0aW9uIiwiX2NhcmV0TWV0YUZyb20iLCJfdW5kbyIsIl9sZW5ndGgiLCJfcmVkbyIsInVuZG8iLCJwb3AiLCJfZWRpdG9yIiwicmVkbyIsIlNLSVBfUkVETyIsImRlZmF1bHQiLCJiYXRjaCIsInVwZGF0ZUNhcmV0TWV0YVRvIiwicmV2ZXJzZSIsImFjdGlvbiIsIl9hY3Rpb24kYXJncyIsIl9yYW5nZSIsIl9hY3Rpb24kYXJnczIiLCJscyIsIl9hY3Rpb24kYXJnczMiLCJvIiwiX2FjdGlvbiRhcmdzNCIsIl90b0FycmF5IiwiX2FjdGlvbiRhcmdzNSIsIl9hY3Rpb24kYXJnczYiLCJDb21tYW5kIiwiZXhlYyIsIkFycm93TGVmdENvbW1hbmQiLCJfQ29tbWFuZCIsImVsZW1pZHgiLCJlbGVtZW50IiwicmVzdWx0IiwicHJlUm93IiwicHJlRWxlbWlkeCIsIkFycm93UmlnaHRDb21tYW5kIiwiX0NvbW1hbmQyIiwiX2NvbHVtbjIiLCJhZnRlclJvdyIsIkFycm93VXBDb21tYW5kIiwiX0NvbW1hbmQzIiwiX3N1cGVyMyIsIm5leHRSb3ciLCJfaGFuZGxlciIsIkFycm93RG93bkNvbW1hbmQiLCJfQ29tbWFuZDQiLCJfc3VwZXI0IiwiX21peGluIiwiX2NvbHVtbjMiLCJjdXJyRWxlbSIsImN1cnJFbGVtUmVkdWNlV2lkdGgiLCJtZWFzdXJlVGV4dFdpZHRoIiwibmV4dExpbmUiLCJuZXh0Q29sdW1uIiwiX2JsYW5kQWRqYWNlbnRFbGVtZW50IiwiZWxlbTEiLCJlbGVtMiIsImRlZmF1bHRPZmZzZXQiLCJJbnB1dCIsIl9sZW4iLCJfa2V5IiwidW5kb3JlZG8iLCJfdW5kb3JlZG8iLCJfY2FyZXQkZ2V0Q29sdW1uIiwiX2NhcmV0JGdldENvbHVtbjIiLCJwcmVFbGVtIiwibmV3RWxlbWVudCIsInRlc3QiLCJyb3dzIiwibGFzdE5lZWRXcmFwIiwidGVtcCIsInRuIiwiY29sIiwiX3QiLCJfYmxhbmRBZGphY2VudEVsZW1lbnQyIiwiX2JsYW5kQWRqYWNlbnRFbGVtZW50MyIsImRlbGV0ZW9wIiwiX2JsYW5kQWRqYWNlbnRFbGVtZW50NCIsIl9ibGFuZEFkamFjZW50RWxlbWVudDUiLCJzaGlmdHJlc3VsdCIsIm5leHRFbGVtIiwiX2JsYW5kQWRqYWNlbnRFbGVtZW50NiIsIl9ibGFuZEFkamFjZW50RWxlbWVudDciLCJfYmxhbmRBZGphY2VudEVsZW1lbnQ4IiwiX2JsYW5kQWRqYWNlbnRFbGVtZW50OSIsIlN0YXJ0RWRpdENvbW1hbmQiLCJfc3RhcnRFZGl0IiwibW92ZUNhcmV0QnlIaXRQb2ludCIsImNyZWF0ZVNoYWRvd0lucHV0IiwiRWRpdENsaWNrQ29tbWFuZCIsIkRvdWJsZUNsaWNrQ29tbWFuZCIsIlNoaWZ0VXBDb21tYW5kIiwidG9nZ2xlU2hpZnQiLCJTaGlmdERvd25Db21tYW5kIiwiU2hpZnRPbkNsaWNrQ29tbWFuZCIsIkN0cmxBQ29tbWFuZCIsIlVuZG9Db21tYW5kIiwiUmVkb0NvbW1hbmQiLCJDb3B5Q29tbWFuZCIsIkN1dENvbW1hbmQiLCJjbWQiLCJjb21tYW5kcyIsIlBhc3RlQ29tbWFuZCIsIl9wcmV2ZW50RGVmYXVsdCIsIlRleHRHcm91cCIsIl9zaGFkb3dJbnB1dCIsImxpbmVTcGFjZSIsInJlc29sdmVyIiwiZHJhZ292ZXIiLCJyZWdpc3RDb21tYW5kIiwiX25hbWUiLCJleGVjQ29tbWFuZCIsImNvbW1uZCIsInRleHRFbGVtZW50cyIsIm9uRHJvcCIsImxhc3RMZW5ndGgiLCJzaGFkb3dJbnB1dCIsIl90aGlzJF9wb3NpdGlvblRvQ3VycyIsInJlZnJlc2hUZXh0RWxlbWVudHMiLCJjdXJyTGluZSIsIl9jYXJldFRvUG9zaXRpb24iLCJjdXJyZW50TGluZUhlaWdodCIsIl90aGlzJF9jYXJldFRvUG9zaXRpbyIsIl90aGlzJF9jYXJldFRvUG9zaXRpbzIiLCJfcmFuZGVyQ3Vyc29yIiwiX3JlbmRlclJhbmdlIiwiX3RoaXMkX2NhcmV0VG9Qb3NpdGlvMyIsIl90aGlzJF9jYXJldFRvUG9zaXRpbzQiLCJibG9ja2hlaWdodCIsImJsb2Nrd2lkdGgiLCJfcmFuZ2UkZ2V0UmFuZ2VGcm9tIiwiX3JhbmdlJGdldFJhbmdlRnJvbTIiLCJyX2YiLCJpZHhfZiIsIm9mZnNldF9mIiwiX3JhbmdlJGdldFJhbmdlVG8iLCJfcmFuZ2UkZ2V0UmFuZ2VUbzIiLCJyX3QiLCJpZHhfdCIsIm9mZnNldF90Iiwic3BhY2UiLCJfbWVhc3VyZUVsZW1lbnRPZmZzZXRYIiwiX3IiLCJiZWdpbm5pbmciLCJsYXN0RWxlbSIsInZhbGlkSW5zdGFuY2UiLCJfdGhpczckYW5jaG9yIiwibmV4dEFyZWEiLCJsYXN0UmVkdWNlWSIsInJlZHVjZVgiLCJyZW5kZXJOb2RlIiwiTm9kZVBsYWNlaG9sZGVyIiwiQW5pbWVNaXhpbiIsIk1pbmlNYXBNaXhpbiIsIlNjcm9sbEJhck1peGluIiwiU2NoZWR1bGVNaXhpbiIsIkdyb3VwIiwiQ2Fwc3VsZUdyb3VwIiwiUmhvbWJ1c0dyb3VwIiwiRGlhbW9uZEdyb3VwIiwiRGlhbW9uZFZlcnRpY2FsR3JvdXAiLCJDYXBzdWxlVmVydGljYWxHcm91cCIsIlBvaW50R3JvdXAiLCJjZWlsIiwiSkZsb3ciLCJldmVudEFkYXB0ZXIiLCJpbml0aWFsWm9vbSIsImluaXRpYWxQb3NpdGlvbiIsInNldEluaXRpYWxQb3NpdGlvbiIsIm1heFpvb20iLCJtaW5ab29tIiwid29ybGRNYXJnaW4iLCJkcmFnZ2luZ2JlaGF2aW9yIiwicGFuSW5Cb3JkZXIiLCJkZWx0YW1vdmVtZW50IiwiYWxsb3dNb3ZpbmdUYXJnZXRJblBhbiIsInNjcm9sbEJhckJlaGF2aW9yIiwib2ZmZXNldCIsIl9sYXN0U3RhdGUiLCJwcm9jZXNzaW5nIiwiX2xhc3REcmFnU3RhdGUiLCJtb3ZpbmciLCJpc0luc3RhbmNlRGlydHkiLCJpc0xpbmtEaXJ0eSIsImJlbG9uZ3MiLCJpbml0aWFsWCIsImluaXRpYWxZIiwiZHJhZ292ZXJpbmciLCJfZHJhZ092ZXJUYXJnZXQiLCJhbGxvd0Ryb3AiLCJfdGVtcE5vZGUiLCJfdGVtcExpbmsiLCJtb2RlIiwiX2FsbG93TW92aW5nVGFyZ2V0Iiwic2V0TW92aW5nVGFyZ2V0cyIsInRhcmdldHMiLCJzZXRUZW1wRHJhZ2dpbmdJbnN0YW5jZSIsInJlbW92ZVRlbXBEcmFnZ2luZ0luc3RhbmNlIiwicHJldmVudERlZmF1bHREcmFnZ2luZyIsImFsbG93RGVmYXVsdERyYWdnaW5nIiwiJG1vdW50IiwiZG9tIiwiX2NyZWF0ZUNhbnZhcyIsImNfd2lkdGgiLCJjX2hlaWdodCIsIiRqZmxvdyIsImNvbnRlbnRCb3giLCJ3X3JhdGlvIiwiaF9yYXRpbyIsImFsaWduIiwic2NhbGVSYXRpbyIsInJlYWxib3hYIiwicmVhbGJveFkiLCJyZWFsYm94VyIsInJlYWxib3hIIiwiX3RoaXMkaW5pdGlhbFBvc2l0aW9uIiwiX3JlYWR5VG9SZW5kZXIiLCJfY3JlYXRlRXZlbnRIYW5kbGVyIiwiZGVzdHJveURwckxpc3RlbmVyIiwic2V0TGlua2luZ01vZGUiLCJsaW5rR2VuIiwiaXNJbkxpbmtpbmdNb2RlIiwic2V0TGlua2luZ0xpbmsiLCJyZXNldExpbmtpbmdMaW5rIiwiY2xlYXJUZW1wIiwicHJldmVudENsZWFyVGVtcCIsIl9wcmV2ZW50Q2xlYXJUZW1wIiwiX3Jlc2l6ZUNhbnZhczIiLCJmb2N1c09uIiwibm93eCIsIm5vd3kiLCJkZXN0cm95TGlzdGVuZXIiLCJkZXN0cm95UGxhaW5FdmVudExpc3RlbmVyIiwiZHJhZ292ZXJIYW5kbGVyIiwiX29uRHJhZ292ZXIiLCJkcm9wSGFuZGxlciIsIl9vbkRyb3AiLCJkcmFnbGVhdmVIYW5sZGVyIiwiX29uRHJhZ0xlYXZlIiwiX3RhcmdldExvY2tPbiIsIm9mZnNldFBvaW50IiwidG9wTGF5ZXJQb2ludCIsIm1vdmluZ3RhcmdldCIsIk9OX1RPUCIsInJlbGF0ZWRUYXJnZXQiLCJfcHJvY2Vzc0RyYWdPdmVyIiwiX3RoaXMkcmVhZE1lc3NhZ2UiLCJfZHJhZ0N1cnJlbnREYXRhIiwib2xkSW5zIiwiX3Byb2Nlc3NQYW5JbkJvcmRlciIsIl90aGlzJGRyYWdnaW5nYmVoYXZpbyIsIl90aGlzJF9jYWNoZVZpZXdCb3giLCJfdGhpcyRfY3VycmVudHAiLCJweSIsIl90aGlzJGRyYWdnaW5nYmVoYXZpbzIiLCJfX3Byb2Nlc3NPdmVyQW5pbWUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJfY2FuY2VsUGFuSW5Cb3JkZXIiLCJfdGhpcyRkcmFnZ2luZ2JlaGF2aW8zIiwicGF5bG9hZCIsIl90aGlzJF90YXJnZXQiLCJfdGhpcyRfdGFyZ2V0JGNhY2hlIiwiY2FuY2VsRHJvcCIsIl96b29taW5nIiwiX3RoaXMkYm91bmRpbmdfYm94MyIsImNoIiwibmV3U2NhbGUiLCJhbW91bnQiLCJkZWx0YVNjYWxlIiwiY3VycmVudFdpZHRoIiwiY3VycmVudEhlaWdodCIsImRlbHRhV2lkdGgiLCJkZWx0YUhlaWdodCIsInRYIiwidFkiLCJwWCIsInBZIiwiX3RoaXM5IiwiX3Bhbm5pbmciLCJfdGhpczEwIiwiX3RoaXMkX3RhcmdldExvY2tPbiIsIl9yZXNvbHZlTG9ja09uVGFyZ2V0IiwiX3ByZXZlbnRQcmVzc1NlcXVlZW5jZSIsIl9jbGVhclRhcmdldCIsIl90aGlzMTEiLCJfdGhpcyRfdGFyZ2V0JHN0YXR1cyIsIl90aGlzJF90YXJnZXQkbWV0YSIsIl90aGlzJF90YXJnZXRMb2NrT24yIiwiX3RoaXMkX3RhcmdldExvY2tPbjMiLCJpc0RvY3VtZW50IiwiY2hlY2tyZXN1bHQiLCJfdGhpcyRfdGFyZ2V0JGNhY2hlMiIsIl90aGlzJF90YXJnZXRMb2NrT240IiwiX3RoaXMkX3RhcmdldExvY2tPbjUiLCJfdGhpcyRfdGFyZ2V0TG9ja09uNiIsIl90aGlzJGJvdW5kaW5nX2JveDQiLCJieDEiLCJieDIiLCJieTEiLCJieTIiLCJfY2FsY3VsYXRlRGlzdGFuY2UiLCJfcmVzZXRUcmFuc2Zvcm0iLCJfdGhpcyRjYW52YXNNZXRhMyIsInJlc2V0VHJhbnNmb3JtIiwic2V0Tm9kZVRvVG9wTGF5ZXIiLCJfdGhpcyRfc3RhY2skc3BsaWNlIiwiX3RoaXMkX3N0YWNrJHNwbGljZTIiLCJfaXNJblZpZXdCb3giLCJjb21tb25FdmVudEFkYXB0ZXIiLCJwYWNrYWdlSnNvbiIsIiRqZmxvd192ZXJzaW9uIiwidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///406\n')}},__webpack_require__={d:(Q,U)=>{for(var F in U)__webpack_require__.o(U,F)&&!__webpack_require__.o(Q,F)&&Object.defineProperty(Q,F,{enumerable:!0,get:U[F]})},o:(Q,U)=>Object.prototype.hasOwnProperty.call(Q,U),r:Q=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})}},__webpack_exports__={};return __webpack_modules__[406](0,__webpack_exports__,__webpack_require__),__webpack_exports__})()}));
!function(Q,U){"object"==typeof exports&&"object"==typeof module?module.exports=U():"function"==typeof define&&define.amd?define([],U):"object"==typeof exports?exports["@joskii/jflow"]=U():Q["@joskii/jflow"]=U()}(self,(function(){return(()=>{"use strict";var __webpack_modules__={406:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "BaseLink": () => (/* reexport */ base_link),\n  "BezierLink": () => (/* reexport */ bezier_link),\n  "Capsule": () => (/* reexport */ capsule),\n  "CapsuleGroup": () => (/* reexport */ CapsuleGroup),\n  "CapsuleVertical": () => (/* reexport */ capsule_vertical),\n  "CapsuleVerticalGroup": () => (/* reexport */ CapsuleVerticalGroup),\n  "Diamond": () => (/* reexport */ diamond),\n  "DiamondGroup": () => (/* reexport */ DiamondGroup),\n  "DiamondVerticalGroup": () => (/* reexport */ DiamondVerticalGroup),\n  "Group": () => (/* reexport */ Group),\n  "GroupFactory": () => (/* reexport */ groupFactory),\n  "Icon": () => (/* reexport */ instance_image),\n  "Instance": () => (/* reexport */ instance_instance),\n  "JFLOW_MODE": () => (/* reexport */ JFLOW_MODE),\n  "JFlowEvent": () => (/* reexport */ events),\n  "LinearLayout": () => (/* reexport */ linear_layout),\n  "Link": () => (/* reexport */ instance_link),\n  "Node": () => (/* reexport */ node),\n  "NodePlaceholder": () => (/* reexport */ NodePlaceholder),\n  "Point": () => (/* reexport */ point),\n  "PointGroup": () => (/* reexport */ PointGroup),\n  "PolyLink": () => (/* reexport */ poly_link),\n  "Rectangle": () => (/* reexport */ rectangle),\n  "Rhombus": () => (/* reexport */ rhombus),\n  "RhombusGroup": () => (/* reexport */ RhombusGroup),\n  "ScrollGroup": () => (/* reexport */ scroll_group),\n  "ShadowDom": () => (/* reexport */ shadowDom),\n  "Text": () => (/* reexport */ elements_text),\n  "TextElement": () => (/* reexport */ TextElement),\n  "TextGroup": () => (/* reexport */ text_group),\n  "addReflowWork": () => (/* reexport */ dirty_work_addReflowWork),\n  "commonEventAdapter": () => (/* reexport */ commonAdapter),\n  "default": () => (/* binding */ src)\n});\n\n;// CONCATENATED MODULE: ./package.json\nconst package_namespaceObject = {"i8":"1.0.5"};\n;// CONCATENATED MODULE: ./src/core/utils/canvas.js\n/**\n * @typedef {Object} CanvasMeta\n * @property {Element} canvas - canvas 元素\n * @property {number} width - 画布宽度\n * @property {number} height - 画布高度\n * @property {number} raw_width - 画布元素宽度\n * @property {number} raw_height - 画布元素高度\n * @property {number} left - 画布距离左端距离\n * @property {number} top - 画布距离顶端距离\n * @property {Context2d} ctx - Context2d\n * @property {number} scale - 当前的像素设备比\n */\n/**\n * 创建一个 canvas 元素\n * @param  {Element} wrapper - dom元素\n * @return {CanvasMeta}\n */\nfunction createCanvas(wrapper) {\n  var canvas = document.createElement(\'canvas\');\n  var ctx = canvas.getContext(\'2d\');\n  var _wrapper$getBoundingC = wrapper.getBoundingClientRect(),\n    width = _wrapper$getBoundingC.width,\n    height = _wrapper$getBoundingC.height,\n    left = _wrapper$getBoundingC.left,\n    top = _wrapper$getBoundingC.top;\n  canvas.style.width = width + "px";\n  canvas.style.height = height + "px";\n  canvas.style.userSelect = \'none\';\n  var scale = window.devicePixelRatio;\n  canvas.width = Math.floor(width * scale);\n  canvas.height = Math.floor(height * scale);\n  if (wrapper) {\n    wrapper.style.position = \'relative\';\n    wrapper.style.overflow = \'hidden\';\n    wrapper.append(canvas);\n  }\n  return {\n    canvas: canvas,\n    width: width,\n    height: height,\n    raw_width: canvas.width,\n    raw_height: canvas.height,\n    left: left,\n    top: top,\n    ctx: ctx,\n    scale: scale\n  };\n}\nfunction canvas_resizeCanvas(canvas, wrapper) {\n  var _wrapper$getBoundingC2 = wrapper.getBoundingClientRect(),\n    width = _wrapper$getBoundingC2.width,\n    height = _wrapper$getBoundingC2.height,\n    left = _wrapper$getBoundingC2.left,\n    top = _wrapper$getBoundingC2.top;\n  canvas.style.width = width + "px";\n  canvas.style.height = height + "px";\n  var scale = window.devicePixelRatio;\n  canvas.width = Math.floor(width * scale);\n  canvas.height = Math.floor(height * scale);\n  return {\n    width: width,\n    height: height,\n    raw_width: canvas.width,\n    raw_height: canvas.height\n  };\n}\nvar caheCanvas = document.createElement(\'canvas\');\ncaheCanvas.width = 1;\ncaheCanvas.height = 1;\nvar caheCanvasctx = caheCanvas.getContext(\'2d\');\nvar scale = window.devicePixelRatio;\ncaheCanvasctx.scale(scale, scale);\n\n/**\n * 在离线canvas上绘制元素\n * @param  {render} render - 绘图函数\n */\nfunction requestCacheCanvas(render) {\n  caheCanvasctx.clearRect(0, 0, 5, 5);\n  caheCanvasctx.save();\n  render(caheCanvasctx);\n  caheCanvasctx.restore();\n  caheCanvasctx.clearRect(0, 0, 5, 5);\n}\nfunction listenOnDevicePixelRatio(callback, destroyHandler) {\n  var target = matchMedia("(resolution: ".concat(window.devicePixelRatio, "dppx)"));\n  function onChange() {\n    console.log("devicePixelRatio changed: " + window.devicePixelRatio);\n    callback(window.devicePixelRatio);\n    listenOnDevicePixelRatio(callback, destroyHandler);\n  }\n  destroyHandler(function () {\n    console.log(\'remove devicePixelRatio event handler\');\n    target.removeEventListener("change", onChange, {\n      once: true\n    });\n  });\n  target.addEventListener("change", onChange, {\n    once: true\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/bezier-js/src/utils.js\n\n\n// math-inlining.\nconst { abs, cos, sin, acos, atan2, sqrt, pow } = Math;\n\n// cube root function yielding real roots\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n}\n\n// trig constants\nconst pi = Math.PI,\n  tau = 2 * pi,\n  quart = pi / 2,\n  // float precision significant decimal\n  epsilon = 0.000001,\n  // extremas used in bbox calculation and similar algorithms\n  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n  // a zero coordinate, which is surprisingly useful\n  ZERO = { x: 0, y: 0, z: 0 };\n\n// Bezier utility functions\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [\n    -0.0640568928626056260850430826247450385909,\n    0.0640568928626056260850430826247450385909,\n    -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404,\n    -0.3150426796961633743867932913198102407864,\n    0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524,\n    0.4337935076260451384870842319133497124524,\n    -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107,\n    -0.6480936519369755692524957869107476266696,\n    0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232,\n    0.7401241915785543642438281030999784255232,\n    -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761,\n    -0.8864155270044010342131543419821967550873,\n    0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548,\n    0.9382745520027327585236490017087214496548,\n    -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411,\n    -0.9951872199970213601799974097007368118745,\n    0.9951872199970213601799974097007368118745,\n  ],\n\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [\n    0.1279381953467521569740561652246953718517,\n    0.1279381953467521569740561652246953718517,\n    0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264,\n    0.121670472927803391204463153476262425607,\n    0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622,\n    0.1155056680537256013533444839067835598622,\n    0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946,\n    0.0976186521041138882698806644642471544279,\n    0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185,\n    0.086190161531953275917185202983742667185,\n    0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193,\n    0.0592985849154367807463677585001085845412,\n    0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593,\n    0.0442774388174198061686027482113382288593,\n    0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491,\n    0.0123412297999871995468056670700372915759,\n    0.0123412297999871995468056670700372915759,\n  ],\n\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== "undefined") {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points;\n\n    // constant?\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    }\n\n    // linear?\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n      return ret;\n    }\n\n    // quadratic/cubic curve?\n    if (order < 4) {\n      let mt2 = mt * mt,\n        t2 = t * t,\n        a,\n        b,\n        c,\n        d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n      return ret;\n    }\n\n    // higher order curves: use de Casteljau\'s computation\n    const dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,\n        };\n        if (typeof dCpts[i].z !== "undefined") {\n          dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n      r = ratios,\n      p = points;\n\n    let f1 = r[0],\n      f2 = r[1],\n      f3 = r[2],\n      f4 = r[3],\n      d;\n\n    // spec for linear\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to quadratic\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to cubic\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d\n          ? false\n          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t,\n      };\n    }\n  },\n\n  derive: function (points, _3d) {\n    const dpoints = [];\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y),\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n        list.push(dpt);\n      }\n      dpoints.push(list);\n      p = list;\n    }\n    return dpoints;\n  },\n\n  between: function (v, m, M) {\n    return (\n      (m <= v && v <= M) ||\n      utils.approximately(v, m) ||\n      utils.approximately(v, M)\n    );\n  },\n\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n\n  length: function (derivativeFn) {\n    const z = 0.5,\n      len = utils.Tvalues.length;\n\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n    return z * sum;\n  },\n\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n      d2 = te - ts,\n      v2 = v - ds,\n      r = v2 / d1;\n    return ts + d2 * r;\n  },\n\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y),\n    };\n    if (v1.z !== undefined && v2.z !== undefined) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n\n  pointToString: function (p) {\n    let s = p.x + "/" + p.y;\n    if (typeof p.z !== "undefined") {\n      s += "/" + p.z;\n    }\n    return s;\n  },\n\n  pointsToString: function (points) {\n    return "[" + points.map(utils.pointToString).join(", ") + "]";\n  },\n\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n      dy1 = v1.y - o.y,\n      dx2 = v2.x - o.x,\n      dy2 = v2.y - o.y,\n      cross = dx1 * dy2 - dy1 * dx2,\n      dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = "" + v;\n    const pos = s.indexOf(".");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n      dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n      mpos,\n      d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return { mdist: mdist, mpos: mpos };\n  },\n\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === "undefined") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const bottom = pow(t, n) + pow(1 - t, n),\n      top = bottom - 1;\n    return abs(top / bottom);\n  },\n\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === "undefined") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const top = pow(1 - t, n),\n      bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx =\n        (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d == 0) {\n      return false;\n    }\n    return { x: nx / d, y: ny / d };\n  },\n\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      x3 = p3.x,\n      y3 = p3.y,\n      x4 = p4.x,\n      y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n\n  makeline: function (p1, p2) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      dx = (x2 - x1) / 3,\n      dy = (y2 - y1) / 3;\n    return new Bezier(\n      x1,\n      y1,\n      x1 + dx,\n      y1 + dy,\n      x1 + 2 * dx,\n      y1 + 2 * dy,\n      x2,\n      y2\n    );\n  },\n\n  findbbox: function (sections) {\n    let mx = nMax,\n      my = nMax,\n      MX = nMin,\n      MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },\n    };\n  },\n\n  shapeintersections: function (\n    s1,\n    bbox1,\n    s2,\n    bbox2,\n    curveIntersectionThreshold\n  ) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end]),\n    };\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(\n        shape,\n        shape.bbox,\n        s2,\n        s2.bbox,\n        curveIntersectionThreshold\n      );\n    };\n    return shape;\n  },\n\n  getminmax: function (curve, d, list) {\n    if (!list) return { min: 0, max: 0 };\n    let min = nMax,\n      max = nMin,\n      t,\n      c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n      if (c[d] < min) {\n        min = c[d];\n      }\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n    return { min: min, mid: (min + max) / 2, max: max, size: max - min };\n  },\n\n  align: function (points, line) {\n    const tx = line.p1.x,\n      ty = line.p1.y,\n      a = -atan2(line.p2.y - ty, line.p2.x - tx),\n      d = function (v) {\n        return {\n          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a),\n        };\n      };\n    return points.map(d);\n  },\n\n  roots: function (points, line) {\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\n\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n        b = aligned[1].y,\n        c = aligned[2].y,\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n      return [];\n    }\n\n    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n    const pa = aligned[0].y,\n      pb = aligned[1].y,\n      pc = aligned[2].y,\n      pd = aligned[3].y;\n\n    let d = -pa + 3 * pb - 3 * pc + pd,\n      a = 3 * pa - 6 * pb + 3 * pc,\n      b = -3 * pa + 3 * pb,\n      c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        }\n        // linear solution:\n        return [-c / b].filter(reduce);\n      }\n      // quadratic solution:\n      const q = sqrt(b * b - 4 * a * c),\n        a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    }\n\n    // at this point, we know we need a cubic solution:\n\n    a /= d;\n    b /= d;\n    c /= d;\n\n    const p = (3 * b - a * a) / 3,\n      p3 = p / 3,\n      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n      q2 = q / 2,\n      discriminant = q2 * q2 + p3 * p3 * p3;\n\n    let u1, v1, x1, x2, x3;\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n        mp33 = mp3 * mp3 * mp3,\n        r = sqrt(mp33),\n        t = -q / (2 * r),\n        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n        phi = acos(cosphi),\n        crtr = crt(r),\n        t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n        b = p[1],\n        c = p[2],\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    }\n\n    // linear roots are even easier\n    if (p.length === 2) {\n      const a = p[0],\n        b = p[1];\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n      return [];\n    }\n\n    return [];\n  },\n\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n      dnm,\n      adk,\n      dk,\n      k = 0,\n      r = 0;\n\n    //\n    // We\'re using the following formula for curvature:\n    //\n    //              x\'y" - y\'x"\n    //   k(t) = ------------------\n    //           (x\'² + y\'²)^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y\'z" - y"z\')² + (z\'x" - z"x\')² + (x\'y" - x"y\')²)\n    //   k(t) = -------------------------------------------------------\n    //                     (x\'² + y\'² + z\'²)^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(\n        pow(d.y * dd.z - dd.y * d.z, 2) +\n          pow(d.z * dd.x - dd.z * d.x, 2) +\n          pow(d.x * dd.y - dd.x * d.y, 2)\n      );\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return { k: 0, r: 0 };\n    }\n\n    k = num / dnm;\n    r = dnm / num;\n\n    // We\'re also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we\'re just going to\n    // ballpark it based on an epsilon.\n    if (!kOnly) {\n      // compute k\'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return { k: k, r: r, dk: dk, adk: adk };\n  },\n\n  inflections: function (points) {\n    if (points.length < 4) return [];\n\n    // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),\n      a = p[2].x * p[1].y,\n      b = p[3].x * p[1].y,\n      c = p[1].x * p[2].y,\n      d = p[3].x * p[2].y,\n      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n      v2 = 18 * (3 * a - b - 3 * c),\n      v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n      return [];\n    }\n\n    const trm = v2 * v2 - 4 * v1 * v3,\n      sq = Math.sqrt(trm),\n      d2 = 2 * v1;\n\n    if (utils.approximately(d2, 0)) return [];\n\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n\n  bboxoverlap: function (b1, b2) {\n    const dims = ["x", "y"],\n      len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n    return true;\n  },\n\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n      c2b = c2.bbox(),\n      r = 100000,\n      threshold = curveIntersectionThreshold || 0.5;\n\n    if (\n      c1b.x.size + c1b.y.size < threshold &&\n      c2b.x.size + c2b.y.size < threshold\n    ) {\n      return [\n        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +\n          "/" +\n          (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,\n      ];\n    }\n\n    let cc1 = c1.split(0.5),\n      cc2 = c2.split(0.5),\n      pairs = [\n        { left: cc1.left, right: cc2.left },\n        { left: cc1.left, right: cc2.right },\n        { left: cc1.right, right: cc2.right },\n        { left: cc1.right, right: cc2.left },\n      ];\n\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n\n    let results = [];\n\n    if (pairs.length === 0) return results;\n\n    pairs.forEach(function (pair) {\n      results = results.concat(\n        utils.pairiteration(pair.left, pair.right, threshold)\n      );\n    });\n\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n\n    return results;\n  },\n\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n      dy1 = p2.y - p1.y,\n      dx2 = p3.x - p2.x,\n      dy2 = p3.y - p2.y,\n      dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n      dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n      dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n      dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n      // chord midpoints\n      mx1 = (p1.x + p2.x) / 2,\n      my1 = (p1.y + p2.y) / 2,\n      mx2 = (p2.x + p3.x) / 2,\n      my2 = (p2.y + p3.y) / 2,\n      // midpoint offsets\n      mx1n = mx1 + dx1p,\n      my1n = my1 + dy1p,\n      mx2n = mx2 + dx2p,\n      my2n = my2 + dy2p,\n      // intersection of these lines:\n      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n      r = utils.dist(arc, p1);\n\n    // arc start/end values, over mid point:\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n      m = atan2(p2.y - arc.y, p2.x - arc.x),\n      e = atan2(p3.y - arc.y, p3.x - arc.x),\n      _;\n\n    // determine arc direction (cw/ccw correction)\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    }\n    // assign and done.\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n\n  numberSort: function (a, b) {\n    return a - b;\n  },\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/bezier-js/src/poly-bezier.js\n\n\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return (\n      "[" +\n      this.curves\n        .map(function (curve) {\n          return utils.pointsToString(curve.points);\n        })\n        .join(", ") +\n      "]"\n    );\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves\n      .map(function (v) {\n        return v.length();\n      })\n      .reduce(function (a, b) {\n        return a + b;\n      });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/bezier-js/src/bezier.js\n/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\n\n\n\n// math-inlining.\nconst { abs: bezier_abs, min, max, cos: bezier_cos, sin: bezier_sin, acos: bezier_acos, sqrt: bezier_sqrt } = Math;\nconst bezier_pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst bezier_ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === "object") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        ["x", "y", "z"].forEach(function (d) {\n          if (typeof point[d] !== "undefined") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            "Only new Bezier(point[]) is accepted for 4th and higher order curves"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            "Only new Bezier(point[]) is accepted for 4th and higher order curves"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== "undefined"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = ["x", "y"]);\n    if (_3d) dims.push("z");\n    this.dimlen = dims.length;\n\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    this._linear = !aligned.some((p) => bezier_abs(p.y) > 0.0001);\n\n    this._lut = [];\n\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === "undefined") {\n      t = 0.5;\n    }\n    // shortcuts, although they\'re really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === "undefined") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === "undefined") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = ["M", x, y, this.order === 2 ? "Q" : "C"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(" ");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error("incorrect number of ratio values");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return "" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join("");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps) {\n      return this._lut;\n    }\n    this._lut = [];\n    // We want a range from 0 to 1 inclusive, so\n    // we decrement and then use <= rather than <:\n    steps--;\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = bezier_sqrt(d.x * d.x + d.y * d.y);\n    return { x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = bezier_sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = bezier_sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = bezier_sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use "de Casteljau" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we\'re done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== "undefined") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return bezier_abs(bezier_acos(s)) < bezier_pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (bezier_abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === "function") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for degenerate (=linear) curves.\n    const clockwise = this.clockwise;\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const points = this.points;\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error("cannot scale this curve. Try reducing it first.");\n    }\n    // move all points by distance \'d\' wrt the origin \'o\'\n\n    // move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by "however much necessary to\n    // ensure the correct tangent to endpoint".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = bezier_sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = typeof d2 === "undefined" ? d1 : d2;\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== "undefined" && typeof d4 !== "undefined";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the "return" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves),\n      slen = segments.length;\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // "simple" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return bezier_abs(d1 - ref) + bezier_abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the "good `t` closest to no-longer-good"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move \'e\' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we\'re done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc\'s end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * bezier_cos(arc.e),\n                y: arc.y + arc.r * bezier_sin(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move \'e\' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log("L835: [F] arc found", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\n\n\n;// CONCATENATED MODULE: ./src/core/utils/constance.js\n/**\n * 方向\n * @readonly\n * @enum {number}\n */\nvar DIRECTION = {\n  /** RIGHT */\n  RIGHT: 0,\n  /** BOTTOM */\n  BOTTOM: 1,\n  /** LEFT */\n  LEFT: 2,\n  /** TOP */\n  TOP: 3,\n  /** SELF */\n  SELF: 100\n};\nfunction nextDirection(direction, clockwise) {\n  var nextDir = (direction + (clockwise ? 1 : -1)) % 4;\n  return nextDir;\n}\nfunction oppositeDirection(direction) {\n  return (direction + 2) % 4;\n}\nvar APPROXIMATE = 6;\nvar JFLOW_MODE = {\n  DEFAULT: \'DEFAULT\',\n  LINKING: \'LINKING\'\n};\nvar LINE_DIR = {\n  FROM: \'from\',\n  TO: \'to\'\n};\n;// CONCATENATED MODULE: ./src/core/utils/functions.js\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n\n\n/**\n * 根据点计算最小外接矩形\n * @param {number[][]} points - 点集合\n * @return {Object} demension 宽高，坐标\n */\nfunction bounding_box(points) {\n  if (points.length === 0) {\n    return {\n      width: 1,\n      height: 1,\n      x: 0,\n      y: 0\n    };\n  }\n  var min_x = Infinity;\n  var min_y = Infinity;\n  var max_x = -Infinity;\n  var max_y = -Infinity;\n  for (var idx in points) {\n    var item = points[idx];\n    if (item[0] < min_x) {\n      min_x = item[0];\n    }\n    if (item[0] > max_x) {\n      max_x = item[0];\n    }\n    if (item[1] < min_y) {\n      min_y = item[1];\n    }\n    if (item[1] > max_y) {\n      max_y = item[1];\n    }\n  }\n  return {\n    // points: [(min_x,min_y),(max_x,min_y),(max_x,max_y),(min_x,max_y)],\n    width: Math.max(max_x - min_x, 10),\n    height: Math.max(max_y - min_y, 10),\n    x: min_x,\n    y: min_y\n  };\n}\nfunction sqr(x) {\n  return x * x;\n}\nfunction dist2(v, w) {\n  return sqr(v[0] - w[0]) + sqr(v[1] - w[1]);\n}\n\n// p - point\n// v - start point of segment\n// w - end point of segment\nfunction distToSegmentSquared(p, v, w) {\n  var l2 = dist2(v, w);\n  if (l2 === 0) return dist2(p, v);\n  var t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\n  t = Math.max(0, Math.min(1, t));\n  return dist2(p, [v[0] + t * (w[0] - v[0]), v[1] + t * (w[1] - v[1])]);\n}\nfunction minIntersectionBetweenNodes(dmsfrom, dmsto) {\n  var meta = {\n    fromDir: null,\n    fromP: null,\n    toDir: null,\n    toP: null,\n    distMin: Infinity\n  };\n  Object.keys(dmsfrom).forEach(function (df) {\n    if (+df === DIRECTION.SELF) {\n      return;\n    }\n    var pf = dmsfrom[df];\n    Object.keys(dmsto).forEach(function (dt) {\n      if (+dt === DIRECTION.SELF) {\n        return;\n      }\n      var pt = dmsto[dt];\n      var dist = dist2(pf, pt);\n      if (dist < meta.distMin) {\n        Object.assign(meta, {\n          distMin: dist,\n          fromDir: +df,\n          fromP: pf,\n          toDir: +dt,\n          toP: pt\n        });\n      }\n    });\n  });\n  return meta;\n}\n\n// export function bezierPoints(p1, p2, start_dir = DIRECTION.TOP, end_dir = DIRECTION.TOP, anticlock = false) {\n//     const isSameDirection = start_dir === end_dir;\n//     const isVerticalStart = [DIRECTION.TOP, DIRECTION.BOTTOM].includes(start_dir);   \n//     const isVerticalEnd = [DIRECTION.TOP, DIRECTION.BOTTOM].includes(end_dir);\n//     const arrowspan = [DIRECTION.TOP, DIRECTION.LEFT].includes(end_dir) ? -5 : 5;\n//     const endX = isVerticalEnd ? p2[0] : p2[0] + arrowspan;\n//     const endY = isVerticalEnd ? p2[1] + arrowspan : p2[1];\n//     if(isSameDirection) {\n//         let span = Math.abs(isVerticalStart ? (endY - p1[1]) : (endX - p1[0]))\n//         span = Math.min(span, 50);\n//         const symb = [DIRECTION.RIGHT, DIRECTION.BOTTOM].includes(end_dir)\n//         span = symb ? span : - span;\n//         const cp1 = isVerticalStart ? [p1[0], p1[1] + span] : [p1[0] + span, p1[1]];\n//         const cp2 = isVerticalEnd ? [endX, endY + span] : [endX + span, endY];\n//         return [ \n//             ...cp1,\n//             ...cp2,\n//             endX, endY ];\n//     }\n//     let spanStart = (anticlock ? -5 : 1) * (isVerticalStart ? (endY - p1[1]) / 2 : (endX - p1[0]) / 2)\n//     let spanEnd = (anticlock ? -4 : 1) * (isVerticalEnd ? (p1[1] - endY) / 2 : (p1[0] - endX) / 2)\n//     let u1 = spanStart / Math.abs(spanStart);\n//     spanStart = u1 * Math.min(Math.abs(spanStart), 50);\n//     let u2 = spanEnd / Math.abs(spanEnd);\n//     spanEnd = u2 * Math.min(Math.abs(spanEnd), 50);\n//     const cp1 = isVerticalStart ? [p1[0], p1[1] + spanStart] : [p1[0] + spanStart, p1[1]];\n//     const cp2 = isVerticalEnd ? [endX, endY + spanEnd] : [endX + spanEnd, endY];\n//     return [ \n//         ...cp1,\n//         ...cp2,\n//         endX, endY ];\n// }\nfunction _resolveControlPoint(p, dir, spanx, spany) {\n  if (dir === DIRECTION.TOP) {\n    return [p[0], p[1] - spany];\n  }\n  if (dir === DIRECTION.BOTTOM) {\n    return [p[0], p[1] + spany];\n  }\n  if (dir === DIRECTION.LEFT) {\n    return [p[0] - spanx, p[1]];\n  }\n  if (dir === DIRECTION.RIGHT) {\n    return [p[0] + spanx, p[1]];\n  }\n}\nfunction bezierPoints(p1, p2) {\n  var start_dir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DIRECTION.TOP;\n  var end_dir = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DIRECTION.TOP;\n  var minSpanX = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  var minSpanY = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  var spanx = Math.max(Math.abs((p1[0] - p2[0]) / 2), minSpanX);\n  var spany = Math.max(Math.abs((p1[1] - p2[1]) / 2), minSpanY);\n  var cp1 = _resolveControlPoint(p1, start_dir, spanx, spany);\n  var cp2 = _resolveControlPoint(p2, end_dir, spanx, spany);\n  var arrowspan = [DIRECTION.TOP, DIRECTION.LEFT].includes(end_dir) ? -5 : 5;\n  var isVerticalEnd = [DIRECTION.TOP, DIRECTION.BOTTOM].includes(end_dir);\n  var endX = isVerticalEnd ? p2[0] : p2[0] + arrowspan;\n  var endY = isVerticalEnd ? p2[1] + arrowspan : p2[1];\n  return [].concat(_toConsumableArray(cp1), _toConsumableArray(cp2), [endX, endY]);\n}\nfunction bezierPoint(t, P) {\n  var q = 1 - t;\n  var x = q * q * q * P[0] + 3 * q * q * t * P[2] + 3 * q * t * t * P[4] + t * t * t * P[6];\n  var y = q * q * q * P[1] + 3 * q * q * t * P[3] + 3 * q * t * t * P[5] + t * t * t * P[7];\n  var u = q * q * (P[2] - P[0]) + 2 * t * q * (P[4] - P[2]) + t * t * (P[6] - P[4]);\n  var v = q * q * (P[3] - P[1]) + 2 * t * q * (P[5] - P[3]) + t * t * (P[7] - P[5]);\n  var angle = Math.atan2(v, u);\n  // console.log(angle * 180)\n  // if(angle < 0) {\n  //     angle = Math.PI + angle;\n  // }\n  return [x, y, angle];\n}\n\n// export function bezierPoints(p1, p2, start_vec, end_vec) {\n\n// }\n\nfunction distToBezierSegmentSquared(p, points) {\n  var b = _construct(Bezier, _toConsumableArray(points));\n  var point = b.project({\n    x: p[0],\n    y: p[1]\n  });\n  var d = dist2(p, [point.x, point.y]);\n  return d;\n}\nfunction getBezierAngle(t, sx, sy, cp1x, cp1y, cp2x, cp2y, ex, ey) {\n  var dx = Math.pow(1 - t, 2) * (cp1x - sx) + 2 * t * (1 - t) * (cp2x - cp1x) + t * t * (ex - cp2x);\n  var dy = Math.pow(1 - t, 2) * (cp1y - sy) + 2 * t * (1 - t) * (cp2y - cp1y) + t * t * (ey - cp2y);\n  return -Math.atan2(dx, dy) + 0.5 * Math.PI;\n}\nfunction getInstanceHeight(instance) {\n  var rect = instance.getBoundingRect();\n  // let min_y = Infinity;\n  // let max_y = -Infinity;\n  // let min_x = Infinity;\n  // let max_x = -Infinity;\n  // rect.forEach(point => {\n  //     max_y = Math.max(max_y, point[1]);\n  //     min_y = Math.min(min_y, point[1]);\n  //     max_x = Math.max(max_x, point[0]);\n  //     min_x = Math.min(min_x, point[0]);\n  // });\n  return {\n    height: rect[3] - rect[1],\n    width: rect[2] - rect[0]\n  };\n}\nfunction polylinePoints(points, p1, p2) {\n  var start_dir = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DIRECTION.TOP;\n  var end_dir = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DIRECTION.TOP;\n  var minSpanX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 10;\n  var minSpanY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 10;\n  var isSelf = arguments.length > 7 ? arguments[7] : undefined;\n  var dirSpan = Math.abs(start_dir - end_dir);\n  // const spanx = Math.max(Math.abs((p1[0] - p2[0])/2), minSpanX);\n  // const spany = Math.max(Math.abs((p1[1] - p2[1])/2), minSpanY);\n  var isVerticalStart = start_dir === DIRECTION.TOP || start_dir === DIRECTION.BOTTOM;\n  points.length = 0;\n  switch (dirSpan) {\n    case 0:\n      // 都按向右好了\n      if (start_dir === DIRECTION.TOP) {\n        var y = Math.min(p1[1], p2[1]);\n        var yp = y - minSpanY;\n        points.push([p1[0], yp]);\n        points.push([p2[0], yp]);\n      }\n      if (start_dir === DIRECTION.BOTTOM) {\n        var _y = Math.max(p1[1], p2[1]);\n        var _yp = _y + minSpanY;\n        points.push([p1[0], _yp]);\n        points.push([p2[0], _yp]);\n      }\n      if (start_dir === DIRECTION.LEFT) {\n        var x = Math.min(p1[0], p2[0]);\n        var xp = x - minSpanX;\n        points.push([xp, p1[1]]);\n        points.push([xp, p2[1]]);\n      }\n      if (start_dir === DIRECTION.RIGHT) {\n        var _x = Math.max(p1[0], p2[0]);\n        var _xp = _x + minSpanX;\n        points.push([_xp, p1[1]]);\n        points.push([_xp, p2[1]]);\n      }\n      break;\n    case 1:\n    case 3:\n      if (isSelf) {\n        if (!isVerticalStart) {\n          points.push([p1[0] + minSpanX, p1[1]]);\n          points.push([p1[0] + minSpanX, p2[1] + minSpanY]);\n          points.push([p2[0], p2[1] + minSpanY]);\n        } else {\n          points.push([p1[0], p1[1] + minSpanY]);\n          points.push([p2[0] + minSpanX, p1[1] + minSpanY]);\n          points.push([p2[0] + minSpanX, p2[1]]);\n        }\n      } else {\n        var point = isVerticalStart ? [p1[0], p2[1]] : [p2[0], p1[1]];\n        points.push(point);\n      }\n      break;\n    case 2:\n      var pmiddle = [(p1[0] - p2[0]) / 2 + p2[0], (p1[1] - p2[1]) / 2 + p2[1]];\n      if (isVerticalStart) {\n        points.push([p1[0], pmiddle[1]]);\n        points.push([p2[0], pmiddle[1]]);\n      } else {\n        points.push([pmiddle[0], p1[1]]);\n        points.push([pmiddle[0], p2[1]]);\n      }\n      break;\n    default:\n      break;\n  }\n  points.unshift(p1);\n  points.push(p2);\n}\nfunction minusVec(p1, p2) {\n  return [p1[0] - p2[0], p1[1] - p2[1]];\n}\nfunction absVec(vec) {\n  return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);\n}\nfunction scaleVec(vec, scale) {\n  return [vec[0] * scale, vec[1] * scale];\n}\nfunction makeRadiusFromVector(pbefore, p, pnext, radius) {\n  var vec1 = minusVec(p, pbefore);\n  var vec2 = minusVec(p, pnext);\n  var absVec1 = absVec(vec1);\n  var absVec2 = absVec(vec2);\n  if (!absVec1 || !absVec2) {\n    return {\n      p1: null,\n      p2: null\n    };\n  }\n  var r1 = scaleVec(vec1, radius / absVec1);\n  var r2 = scaleVec(vec2, radius / absVec2);\n  return {\n    p1: minusVec(p, r1),\n    p2: minusVec(p, r2)\n  };\n}\n// 矩形重叠计算\nfunction doOverlap(rec1, rec2) {\n  if (rec1[0] == rec1[2] || rec1[1] == rec1[3] || rec2[0] == rec2[2] || rec2[1] == rec2[3]) {\n    // the line cannot have positive overlap\n    return false;\n  }\n  return !(rec1[2] <= rec2[0] ||\n  // left\n  rec1[3] <= rec2[1] ||\n  // bottom\n  rec1[0] >= rec2[2] ||\n  // right\n  rec1[1] >= rec2[3]); // top\n}\n\nfunction isPolyLineIntersectionRectange(polyline, rect) {\n  var p = polyline[0];\n  var l = polyline.length;\n  var i = 1;\n  var _rect = _slicedToArray(rect, 4),\n    l0 = _rect[0],\n    l1 = _rect[1],\n    r0 = _rect[2],\n    r1 = _rect[3];\n  while (i < l) {\n    var cp = polyline[i];\n    if (p[0] === cp[0]) {\n      // vertical\n      if (p[0] < r0 && p[0] > l0 && !(p[1] > r1 && cp[1] > r1 || p[1] < l1 && cp[1] < l1)) {\n        return true;\n      }\n    } else {\n      // horizontal\n      if (p[1] < r1 && p[1] > l1 && !(p[0] > r0 && cp[0] > r0 || p[0] < l0 && cp[0] < l0)) {\n        return true;\n      }\n    }\n    p = cp;\n    i++;\n  }\n  return false;\n}\nfunction debounce(func) {\n  var _this = this;\n  var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;\n  var timer;\n  return function () {\n    clearTimeout(timer);\n    timer = setTimeout(function () {\n      func.call(_this);\n    }, timeout);\n  };\n}\nfunction compareBoundingbox(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\nfunction copyBoundingbox(a, b) {\n  a[0] = b[0];\n  a[1] = b[1];\n  a[2] = b[2];\n  a[3] = b[3];\n}\n;// CONCATENATED MODULE: ./src/core/instance/instance.js\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) instance_setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = instance_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return instance_construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return instance_setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction instance_construct(Parent, args, Class) { if (instance_isNativeReflectConstruct()) { instance_construct = Reflect.construct.bind(); } else { instance_construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) instance_setPrototypeOf(instance, Class.prototype); return instance; }; } return instance_construct.apply(null, arguments); }\nfunction instance_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }\nfunction instance_setPrototypeOf(o, p) { instance_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return instance_setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n// import { setUniqueId, getUniqueId } from \'../utils/functions\';\n// import { nextDirection } from \'../utils/constance\';\n// const margin = 5;\nvar ishitKey = Symbol(\'ishit\');\nvar isInViewBox = Symbol(\'isInViewBox\');\n/**\n * @typedef Instance~Configs\n * @type {object}\n * @property {number} borderWidth      - 边的宽度 默认是 2\n * @property {string} borderColor      - 边框颜色 默认 black\n * @property {string} color            - 填充颜色 默认 white\n * @property {string} shadowColor      - 阴影颜色\n * @property {string} shadowBlur       - 阴影扩散范围\n * @property {string} shadowOffsetX    - 阴影偏移 X\n * @property {string} shadowOffsetX    - 阴影偏移 Y\n */\n\n/** \n * 图中的最小单元\n * @constructor Instance\n * @extends EventTarget\n * @param {Instance~Configs} configs - 最小单元的一些通用属性配置\n */\nvar Instance = /*#__PURE__*/function (_EventTarget) {\n  _inherits(Instance, _EventTarget);\n  var _super = _createSuper(Instance);\n  function Instance() {\n    var _this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, Instance);\n    _this = _super.call(this);\n    Object.assign(_assertThisInitialized(_this), configs);\n    // this.anchor = configs.anchor || [0, 0];\n    // this.belongs = undefined;\n    /** @member {boolean}      - 元素可见 默认 true */\n    _this.visible = true;\n    // this._jflow = undefined;\n    _this._belongs = undefined;\n    _this[ishitKey] = false;\n\n    /** @member {number}      - 边的宽度 默认是 0 */\n    _this.borderWidth = configs.borderWidth || 0;\n    /** @member {string}     - 边框颜色 默认 transparent */\n    _this.borderColor = configs.borderColor || \'transparent\';\n    /** @member {string}     - 填充颜色 默认 transparent */\n    _this.backgroundColor = configs.backgroundColor || \'transparent\';\n    /** @member {string}     - 阴影颜色 空就不显示阴影 */\n    _this.shadowColor = configs.shadowColor;\n    /** @member {string}     - 阴影扩散范围 默认 5 */\n    _this.shadowBlur = configs.shadowBlur || 5;\n    /** @member {string}     - 阴影偏移 X */\n    _this.shadowOffsetX = configs.shadowOffsetX || 0;\n    /** @member {string}     - 阴影偏移 Y */\n    _this.shadowOffsetY = configs.shadowOffsetY || 0;\n    /** @member {number}     - 透明度 */\n    _this.opacity = configs.opacity || 1;\n    _this._boundingrect = [0, 0, 0, 0];\n    return _this;\n  }\n  /**\n   * @member {boolean} - 当前单元选中状态\n   */\n  _createClass(Instance, [{\n    key: "_isTargeting",\n    get: function get() {\n      return this === (this._jflow._target.instance || this._jflow._target.link);\n    }\n    /**\n     * @member {boolean} - 当前单元移动状态\n     */\n  }, {\n    key: "_isMoving",\n    get: function get() {\n      return this === this._jflow._getMovingTarget() && this._jflow._target.status.movingState; // 移动了之后才能被当做移动状态\n    }\n    /**\n     * @member {boolean}  - 当前单元碰撞检测状态\n     */\n  }, {\n    key: "_isHit",\n    get: function get() {\n      return this[ishitKey];\n    }\n    /**\n     * @member {JFlow}  - canvas上 jflow 实体\n     */,\n    set: function set(ishit) {\n      if (this[ishitKey] !== ishit) {\n        /**\n         * 鼠标移入事件\n         *\n         * @event Instance#mouseenter\n         * @type {object}\n         * @property {Instance} instance      - 移入的对象 \n         */\n        /**\n         * 鼠标移出事件\n         *\n         * @event Instance#mouseleave\n         * @type {object}\n         * @property {Instance} instance      - 移入的对象 \n         */\n        this.dispatchEvent(new CustomEvent(ishit ? \'mouseenter\' : \'mouseleave\', {\n          detail: {\n            instance: this,\n            jflow: this._jflow\n          }\n        }));\n      }\n      this[ishitKey] = ishit; // validation could be checked here such as only allowing non numerical values\n    }\n  }, {\n    key: "_jflow",\n    get: function get() {\n      if (this._jflowRoot) {\n        return this._jflowRoot;\n      }\n      if (!this._belongs) {\n        return undefined;\n      }\n      return this._belongs.uniqueName === \'jflow\' ? this._belongs : this._belongs._jflow;\n    }\n  }, {\n    key: "isInViewBox",\n    get: function get() {\n      return this[isInViewBox];\n    }\n  }, {\n    key: "_isInViewBox",\n    set: function set(val) {\n      var oldval = this[isInViewBox];\n      if (val !== oldval) {\n        if (val) {\n          this.onEnterViewbox();\n        } else {\n          this.onLeaveViewbox();\n        }\n      }\n      this[isInViewBox] = val;\n    }\n\n    /**\n     * 当节点离开可视区域的回调\n     */\n  }, {\n    key: "onEnterViewbox",\n    value: function onEnterViewbox() {\n      return;\n    }\n\n    /**\n     * 当节点离开可视区域的回调\n     */\n  }, {\n    key: "onLeaveViewbox",\n    value: function onLeaveViewbox() {\n      return;\n    }\n\n    /**\n     * 改变当前配置\n     * @param {Configs} configs - The string containing two comma-separated numbers.\n     */\n  }, {\n    key: "setConfig",\n    value: function setConfig(configs) {\n      var _this2 = this;\n      Object.keys(configs).forEach(function (k) {\n        if (configs[k] !== undefined && configs[k] !== null) {\n          _this2[k] = configs[k];\n        }\n      });\n    }\n    /**\n     * 绘制单元\n     * @param {Context2d} ctx \n     */\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      throw \'require render implement\';\n    }\n    /**\n     * 判断当前单元是否被命中\n     * @param {number[]} point \n     * @return {Boolean}\n     */\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      throw \'require isHit implement\';\n    }\n    /**\n     * 计算当前的最大外接矩形的\n     * @return {number[]} [leftx, lefty, rightx, righty]\n     */\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      throw \'require getBoundingRect implement\';\n    }\n  }, {\n    key: "calculateIntersection",\n    value: function calculateIntersection() {\n      throw \'require calculateIntersection implement\';\n    }\n    /**\n     * 计算当前连线接入点的位置\n     * @return {Object} intersection 交叉点\n     * @return {number} intersection[DIRECTION.TOP] 上\n     * @return {number} intersection[DIRECTION.BOTTOM] 下\n     * @return {number} intersection[DIRECTION.LEFT] 上\n     * @return {number} intersection[DIRECTION.RIGHT] 右\n     */\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      throw \'require getIntersectionsInFourDimension implement\';\n    }\n\n    /**\n     * 获取当前所在层级的坐标\n     * @return {Number[]} 坐标\n     */\n  }, {\n    key: "getCenter",\n    value: function getCenter() {\n      return this.anchor;\n    }\n    /**\n     * 获取宽高\n     * @return {Object} demension 宽高\n     * @return {number} demension.width 宽\n     * @return {number} demension.height 高\n     */\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      var rect = instance.getBoundingRect();\n      var min_y = Infinity;\n      var max_y = -Infinity;\n      var min_x = Infinity;\n      var max_x = -Infinity;\n      rect.forEach(function (point) {\n        max_y = Math.max(max_y, point[1]);\n        min_y = Math.min(min_y, point[1]);\n        max_x = Math.max(max_x, point[0]);\n        min_x = Math.min(min_x, point[0]);\n      });\n      return {\n        height: max_y - min_y,\n        width: max_x - min_x\n      };\n    }\n    /**\n     * 冒泡事件\n     * @param {JFlowEvent} customEvent 自定义事件\n     */\n  }, {\n    key: "bubbleEvent",\n    value: function bubbleEvent(customEvent) {\n      customEvent.detail.currentTarget = this;\n      this.dispatchEvent(customEvent);\n      if (customEvent.detail.bubbles) {\n        if (this._belongs.bubbleEvent) {\n          this._belongs.bubbleEvent(customEvent);\n        } else {\n          this._belongs.dispatchEvent(customEvent);\n        }\n      }\n    }\n    /**\n     * 反算回页面的像素坐标\n     * @param {Number[]} point\n     * @return {Number[]} 世界坐标\n     */\n  }, {\n    key: "calculateToRealWorld",\n    value: function calculateToRealWorld(point) {\n      if (this._belongs && this._belongs.calculateToRealWorld) {\n        return this._belongs.calculateToRealWorld(point);\n      } else {\n        return point;\n      }\n    }\n  }, {\n    key: "calculateToRealWorldWithPointer",\n    value: function calculateToRealWorldWithPointer(outpoint, inpoint) {\n      if (this._belongs && this._belongs.calculateToRealWorldWithPointer) {\n        this._belongs.calculateToRealWorldWithPointer(outpoint, inpoint);\n      }\n    }\n  }, {\n    key: "calculateToRealWorldWithScalar",\n    value: function calculateToRealWorldWithScalar(length) {\n      return this._jflow.scale * length;\n    }\n\n    /**\n     * 从当前布局中删除虚拟布局节点\n     */\n    // removeFromLayoutSource() {\n    //     if(this._layoutNode) {\n    //         this._layoutNode.remove();\n    //     }\n    // }\n  }, {\n    key: "recalculateUp",\n    value: function recalculateUp() {\n      if (this._belongs) {\n        this._belongs.recalculateUp();\n      }\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      // this._belongs = undefined;\n      // this.removeEventListener();\n    }\n  }]);\n  return Instance;\n}( /*#__PURE__*/_wrapNativeSuper(EventTarget));\n/* harmony default export */ const instance_instance = (Instance);\n;// CONCATENATED MODULE: ./src/core/dirty-work/dirty-work.js\nfunction dirty_work_slicedToArray(arr, i) { return dirty_work_arrayWithHoles(arr) || dirty_work_iterableToArrayLimit(arr, i) || dirty_work_unsupportedIterableToArray(arr, i) || dirty_work_nonIterableRest(); }\nfunction dirty_work_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction dirty_work_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return dirty_work_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dirty_work_arrayLikeToArray(o, minLen); }\nfunction dirty_work_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction dirty_work_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction dirty_work_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar queue = [];\nvar clearQueue = [];\nvar queueSet = new WeakSet();\nvar checkWork = function checkWork(target) {\n  return queueSet.has(target);\n};\nvar getStackPath = function getStackPath(node) {\n  var t = node;\n  var exp = 1;\n  var p = \'\';\n  while (t && t._belongs) {\n    var idx = t._belongs._stack.findIndex(function (n) {\n      return n === t;\n    });\n    p = idx + (p && \'.\' + p);\n    t = t._belongs;\n  }\n  return p;\n};\nvar sortByPath = function sortByPath() {\n  var map = new WeakMap();\n  queue.sort(function (a, b) {\n    var apath = map.get(a);\n    if (apath === undefined) {\n      apath = getStackPath(a);\n      map.set(a, apath);\n    }\n    var bpath = map.get(b);\n    if (bpath === undefined) {\n      bpath = getStackPath(b);\n      map.set(b, bpath);\n    }\n    var _a = apath.split(\'.\');\n    var _b = bpath.split(\'.\');\n    if (_a.length < _b.length) {\n      return 1;\n    }\n    if (_a.length > _b.length) {\n      return -1;\n    }\n    for (var i = 0; i < _a.length; i++) {\n      var _p = +_a[i];\n      var _q = +_b[i];\n      if (_p < _q) {\n        return 1;\n      }\n      if (_p > _q) {\n        return -1;\n      }\n    }\n    return 0;\n  });\n};\nvar addClearSourceWork = function addClearSourceWork(jflow, source) {\n  clearQueue.push([jflow, source]);\n};\n\n// work is sync function!!\nvar dirty_work_addReflowWork = function addReflowWork(target, parent) {\n  if (target.doRecalculate) {\n    if (!queueSet.has(target)) {\n      queue.push(target);\n      queueSet.add(target);\n    }\n  }\n  if (parent && parent.doRecalculate && !queueSet.has(parent)) {\n    queue.push(parent);\n    queueSet.add(parent);\n  }\n\n  // if(target.doRecalculate) {\n  //     if(!checkWork(target)) {\n  //         queue.push(target);\n  //         queueSet.add(target);\n  //     }\n  // }  \n  // if(parent) {\n  //     if(checkWork(parent)) {\n  //         const idx = queue.findIndex(p => p === parent);\n  //         queue.splice(idx, 1);\n  //         queue.push(parent);\n  //     } else {\n  //         queue.push(parent);\n  //         queueSet.add(parent);\n  //     }\n\n  // }\n  flush();\n};\nvar inFlush = false;\nvar flush = function flush() {\n  if (inFlush) {\n    return;\n  }\n  inFlush = true;\n  requestAnimationFrame(function () {\n    var roots = new Set();\n    sortByPath();\n    while (queue.length) {\n      var target = queue.shift();\n      if (target.doRecalculate) {\n        target.doRecalculate();\n        roots.add(target._jflow);\n      }\n      // console.log(target.width, target.height)\n    }\n\n    while (clearQueue.length) {\n      var _clearQueue$shift = clearQueue.shift(),\n        _clearQueue$shift2 = dirty_work_slicedToArray(_clearQueue$shift, 2),\n        jflow = _clearQueue$shift2[0],\n        source = _clearQueue$shift2[1];\n      if (!jflow.getRenderNodeBySource(source)) {\n        jflow.clearSource(source);\n      }\n    }\n    // console.log(\'-----dirty---flush-----\')\n    queueSet = new WeakSet();\n    inFlush = false;\n    Array.from(roots).forEach(function (jflow) {\n      jflow._render();\n    });\n  });\n};\n;// CONCATENATED MODULE: ./src/core/instance/node.js\nfunction node_typeof(obj) { "@babel/helpers - typeof"; return node_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, node_typeof(obj); }\nfunction node_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction node_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, node_toPropertyKey(descriptor.key), descriptor); } }\nfunction node_createClass(Constructor, protoProps, staticProps) { if (protoProps) node_defineProperties(Constructor.prototype, protoProps); if (staticProps) node_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction node_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) node_setPrototypeOf(subClass, superClass); }\nfunction node_setPrototypeOf(o, p) { node_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return node_setPrototypeOf(o, p); }\nfunction node_createSuper(Derived) { var hasNativeReflectConstruct = node_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = node_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = node_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return node_possibleConstructorReturn(this, result); }; }\nfunction node_possibleConstructorReturn(self, call) { if (call && (node_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return node_assertThisInitialized(self); }\nfunction node_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction node_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction node_getPrototypeOf(o) { node_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return node_getPrototypeOf(o); }\nfunction _defineProperty(obj, key, value) { key = node_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction node_toPropertyKey(arg) { var key = node_toPrimitive(arg, "string"); return node_typeof(key) === "symbol" ? key : String(key); }\nfunction node_toPrimitive(input, hint) { if (node_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (node_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n\n\n/**\n * 绝对定位 配置， 绝对定位不受布局影响，相对于当前组来定位\n * @typedef {object} Node~AbsolutePosition \n * @property {number} top       - 上距离\n * @property {number} bottom    - 下距离\n * @property {number} right     - 右距离\n * @property {number} left      - 左距离\n */\n/**\n * Node 配置\n * @typedef {Instance~Configs} Node~Configs \n * @property {number[]} anchor - 坐标\n * @property {Node~AbsolutePosition} absolutePosition - 绝对定位位置\n */\n/**\n * 节点基类\n * @constructor Node\n * @extends Instance\n * @param {Node~Configs} configs - 节点配置\n */\nvar Node = /*#__PURE__*/function (_Instance) {\n  node_inherits(Node, _Instance);\n  var _super = node_createSuper(Node);\n  function Node() {\n    var _this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    node_classCallCheck(this, Node);\n    _this = _super.call(this, configs);\n    _defineProperty(node_assertThisInitialized(_this), "INSTANCE_TYPE", \'NODE\');\n    _this._rawConfigs = configs;\n    // for layout\n    /** @member {number[]} */\n    _this.anchor = configs.anchor || [0, 0];\n    /** @member {Node~AbsolutePosition} */\n    _this.absolutePosition = configs.absolutePosition;\n    return _this;\n  }\n  node_createClass(Node, [{\n    key: "nextSibling",\n    get: function get() {\n      var _this2 = this;\n      if (!this._belongs) {\n        return null;\n      }\n      var stack = this._belongs._stack;\n      var idx = stack.findIndex(function (s) {\n        return s === _this2;\n      });\n      if (idx !== -1) {\n        return stack[idx + 1];\n      }\n      return null;\n    }\n  }, {\n    key: "setConfig",\n    value: function setConfig(configs) {\n      var _this3 = this;\n      Object.keys(configs).forEach(function (k) {\n        if (configs[k] !== undefined && configs[k] !== null) {\n          _this3[k] = configs[k];\n          _this3._rawConfigs[k] = configs[k];\n        }\n      });\n    }\n  }, {\n    key: "setAnchorX",\n    value: function setAnchorX(x) {\n      this.anchor[0] = x;\n    }\n  }, {\n    key: "setAnchorY",\n    value: function setAnchorY(y) {\n      this.anchor[1] = y;\n    }\n  }, {\n    key: "setAnchor",\n    value: function setAnchor(x, y) {\n      this.anchor[0] = x;\n      this.anchor[1] = y;\n    }\n  }, {\n    key: "beforeRender",\n    value: function beforeRender() {\n      return doOverlap(this._belongs._getViewBox(), this.getBoundingRect());\n    }\n  }, {\n    key: "addReflowWork",\n    value: function addReflowWork() {\n      dirty_work_addReflowWork(this, this._belongs);\n    }\n\n    /**\n     * 克隆当前节点.\n     * @return {Node} 当前节点的副本\n     */\n  }, {\n    key: "clone",\n    value: function clone() {\n      var C = this.constructor;\n      var t = new C(this._rawConfigs);\n      t.visible = this.visible;\n      return t;\n    }\n  }]);\n  return Node;\n}(instance_instance);\n/* harmony default export */ const node = (Node);\n;// CONCATENATED MODULE: ./src/core/instance/ghostNode.js\nfunction ghostNode_typeof(obj) { "@babel/helpers - typeof"; return ghostNode_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, ghostNode_typeof(obj); }\nfunction ghostNode_defineProperty(obj, key, value) { key = ghostNode_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction ghostNode_slicedToArray(arr, i) { return ghostNode_arrayWithHoles(arr) || ghostNode_iterableToArrayLimit(arr, i) || ghostNode_unsupportedIterableToArray(arr, i) || ghostNode_nonIterableRest(); }\nfunction ghostNode_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction ghostNode_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return ghostNode_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ghostNode_arrayLikeToArray(o, minLen); }\nfunction ghostNode_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ghostNode_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction ghostNode_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction ghostNode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction ghostNode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, ghostNode_toPropertyKey(descriptor.key), descriptor); } }\nfunction ghostNode_createClass(Constructor, protoProps, staticProps) { if (protoProps) ghostNode_defineProperties(Constructor.prototype, protoProps); if (staticProps) ghostNode_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction ghostNode_toPropertyKey(arg) { var key = ghostNode_toPrimitive(arg, "string"); return ghostNode_typeof(key) === "symbol" ? key : String(key); }\nfunction ghostNode_toPrimitive(input, hint) { if (ghostNode_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (ghostNode_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction ghostNode_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) ghostNode_setPrototypeOf(subClass, superClass); }\nfunction ghostNode_setPrototypeOf(o, p) { ghostNode_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return ghostNode_setPrototypeOf(o, p); }\nfunction ghostNode_createSuper(Derived) { var hasNativeReflectConstruct = ghostNode_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = ghostNode_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = ghostNode_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return ghostNode_possibleConstructorReturn(this, result); }; }\nfunction ghostNode_possibleConstructorReturn(self, call) { if (call && (ghostNode_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return ghostNode_assertThisInitialized(self); }\nfunction ghostNode_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction ghostNode_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction ghostNode_getPrototypeOf(o) { ghostNode_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return ghostNode_getPrototypeOf(o); }\n\n\nvar GhostNode = /*#__PURE__*/function (_Node) {\n  ghostNode_inherits(GhostNode, _Node);\n  var _super = ghostNode_createSuper(GhostNode);\n  function GhostNode(configs) {\n    ghostNode_classCallCheck(this, GhostNode);\n    return _super.call(this, configs);\n  }\n  ghostNode_createClass(GhostNode, [{\n    key: "render",\n    value: function render(ctx) {}\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      return false;\n    }\n  }, {\n    key: "calculateIntersection",\n    value: function calculateIntersection(point) {\n      return this.anchor;\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var _this$anchor = ghostNode_slicedToArray(this.anchor, 2),\n        x2 = _this$anchor[0],\n        y2 = _this$anchor[1];\n      return [x2, y2, x2, y2];\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        width: 0,\n        height: 0\n      };\n    }\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      var _ref;\n      var _this$anchor2 = ghostNode_slicedToArray(this.anchor, 2),\n        x2 = _this$anchor2[0],\n        y2 = _this$anchor2[1];\n      return _ref = {}, ghostNode_defineProperty(_ref, DIRECTION.RIGHT, [x2 + 1, y2]), ghostNode_defineProperty(_ref, DIRECTION.LEFT, [x2 - 1, y2]), ghostNode_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + 1]), ghostNode_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - 1]), _ref;\n    }\n  }]);\n  return GhostNode;\n}(node);\n/* harmony default export */ const ghostNode = (GhostNode);\n;// CONCATENATED MODULE: ./src/core/instance/nodeWeakMap.js\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { nodeWeakMap_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction nodeWeakMap_defineProperty(obj, key, value) { key = nodeWeakMap_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction nodeWeakMap_typeof(obj) { "@babel/helpers - typeof"; return nodeWeakMap_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, nodeWeakMap_typeof(obj); }\nfunction nodeWeakMap_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction nodeWeakMap_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, nodeWeakMap_toPropertyKey(descriptor.key), descriptor); } }\nfunction nodeWeakMap_createClass(Constructor, protoProps, staticProps) { if (protoProps) nodeWeakMap_defineProperties(Constructor.prototype, protoProps); if (staticProps) nodeWeakMap_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction nodeWeakMap_toPropertyKey(arg) { var key = nodeWeakMap_toPrimitive(arg, "string"); return nodeWeakMap_typeof(key) === "symbol" ? key : String(key); }\nfunction nodeWeakMap_toPrimitive(input, hint) { if (nodeWeakMap_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (nodeWeakMap_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction getMapObject() {\n  return {\n    layoutNode: undefined,\n    jflowNode: undefined,\n    jflowlinks: [],\n    jflowFromLinks: new Set(),\n    jflowToLinks: new Set()\n  };\n}\nvar NodeWeakMap = /*#__PURE__*/function () {\n  function NodeWeakMap() {\n    nodeWeakMap_classCallCheck(this, NodeWeakMap);\n    this._map = new Map();\n  }\n  nodeWeakMap_createClass(NodeWeakMap, [{\n    key: "get",\n    value: function get(source) {\n      return this._map.get(source);\n    }\n  }, {\n    key: "set",\n    value: function set(source) {\n      var obj = getMapObject();\n      this._map.set(source, obj);\n      return obj;\n    }\n  }, {\n    key: "has",\n    value: function has(source) {\n      return this._map.has(source);\n    }\n  }, {\n    key: "delete",\n    value: function _delete(source) {\n      this._map["delete"](source);\n    }\n  }, {\n    key: "clear",\n    value: function clear() {\n      this._map.clear();\n    }\n  }]);\n  return NodeWeakMap;\n}();\nvar NodeWeakMapMixin = {\n  initNodeWeakMap: function initNodeWeakMap() {\n    this.source_Layout_Render_NodeMap = new NodeWeakMap();\n  },\n  getRenderNodeBySource: function getRenderNodeBySource(source) {\n    var mapping = this.source_Layout_Render_NodeMap.get(source);\n    if (mapping) {\n      return mapping.jflowNode;\n    }\n    return undefined;\n  },\n  removeRenderNodeBySource: function removeRenderNodeBySource(source) {\n    var map = this.source_Layout_Render_NodeMap;\n    var obj = map.get(source);\n    if (obj) {\n      obj.jflowNode = undefined;\n    }\n    if (obj.jflowFromLinks.size === 0 && obj.jflowToLinks.size === 0) {\n      this.source_Layout_Render_NodeMap["delete"](source);\n    }\n  },\n  getLayoutNodeBySource: function getLayoutNodeBySource(source) {\n    var mapping = this.source_Layout_Render_NodeMap.get(source);\n    if (mapping) {\n      return mapping.layoutNode;\n    }\n    return undefined;\n  },\n  getSourceRenderMeta: function getSourceRenderMeta(source) {\n    var map = this.source_Layout_Render_NodeMap;\n    var _meta = map.get(source);\n    return _objectSpread(_objectSpread({}, _meta), {}, {\n      jflowFromLinks: Array.from(_meta.jflowFromLinks),\n      jflowToLinks: Array.from(_meta.jflowToLinks)\n    });\n  },\n  _getMap: function _getMap(source) {\n    if (!source) {\n      return null;\n    }\n    var map = this.source_Layout_Render_NodeMap;\n    var obj;\n    if (map.has(source)) {\n      obj = map.get(source);\n    } else {\n      obj = map.set(source);\n    }\n    return obj;\n  },\n  setLayoutNodeBySource: function setLayoutNodeBySource(source, layoutNode) {\n    var obj = this._getMap(source);\n    obj.layoutNode = layoutNode;\n  },\n  setRenderNodeBySource: function setRenderNodeBySource(source, instance) {\n    var obj = this._getMap(source);\n    obj.jflowNode = instance;\n    if (obj.jflowFromLinks.size > 0) {\n      obj.jflowFromLinks.forEach(function (link) {\n        link.from = instance;\n      });\n    }\n    if (obj.jflowToLinks.size > 0) {\n      obj.jflowToLinks.forEach(function (link) {\n        link.to = instance;\n      });\n    }\n  },\n  addLinkNodeBySource: function addLinkNodeBySource(sourceFrom, sourceTo, link) {\n    var obj = this._getMap(sourceFrom);\n    obj.jflowFromLinks.add(link);\n    obj = this._getMap(sourceTo);\n    obj.jflowToLinks.add(link);\n  },\n  removeLinkNodeBySource: function removeLinkNodeBySource(sourceFrom, sourceTo, link) {\n    var map = this.source_Layout_Render_NodeMap;\n    var obj = map.get(sourceFrom);\n    if (obj) {\n      obj.jflowFromLinks["delete"](link);\n      if (obj.jflowFromLinks.size === 0 && obj.jflowToLinks.size === 0 && !obj.jflowNode) {\n        this.source_Layout_Render_NodeMap["delete"](sourceFrom);\n      }\n    }\n    obj = map.get(sourceTo);\n    if (obj) {\n      obj.jflowToLinks["delete"](link);\n      if (obj.jflowFromLinks.size === 0 && obj.jflowToLinks.size === 0 && !obj.jflowNode) {\n        this.source_Layout_Render_NodeMap["delete"](sourceTo);\n      }\n    }\n  },\n  changeLinkNodeBySource: function changeLinkNodeBySource(prevSource, nextSource, link, dir) {\n    var obj = this._getMap(prevSource);\n    if (obj) {\n      if (dir === \'from\') {\n        obj.jflowFromLinks["delete"](link);\n      }\n      if (dir === \'to\') {\n        obj.jflowToLinks["delete"](link);\n      }\n    }\n    obj = this._getMap(nextSource);\n    if (obj) {\n      if (dir === \'from\') {\n        obj.jflowFromLinks.add(link);\n        if (obj.jflowNode) {\n          link.from = obj.jflowNode;\n        }\n      }\n      if (dir === \'to\') {\n        obj.jflowToLinks.add(link);\n        if (obj.jflowNode) {\n          link.to = obj.jflowNode;\n        }\n      }\n    }\n  }\n};\n/* harmony default export */ const nodeWeakMap = ((/* unused pure expression or super */ null && (NodeWeakMap)));\n;// CONCATENATED MODULE: ./src/core/instance/stack.js\nfunction stack_typeof(obj) { "@babel/helpers - typeof"; return stack_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, stack_typeof(obj); }\nfunction stack_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction stack_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, stack_toPropertyKey(descriptor.key), descriptor); } }\nfunction stack_createClass(Constructor, protoProps, staticProps) { if (protoProps) stack_defineProperties(Constructor.prototype, protoProps); if (staticProps) stack_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction stack_toPropertyKey(arg) { var key = stack_toPrimitive(arg, "string"); return stack_typeof(key) === "symbol" ? key : String(key); }\nfunction stack_toPrimitive(input, hint) { if (stack_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (stack_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = stack_getPrototypeOf(object); if (object === null) break; } return object; }\nfunction stack_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) stack_setPrototypeOf(subClass, superClass); }\nfunction stack_createSuper(Derived) { var hasNativeReflectConstruct = stack_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = stack_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = stack_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return stack_possibleConstructorReturn(this, result); }; }\nfunction stack_possibleConstructorReturn(self, call) { if (call && (stack_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return stack_assertThisInitialized(self); }\nfunction stack_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction stack_wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; stack_wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !stack_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return stack_construct(Class, arguments, stack_getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return stack_setPrototypeOf(Wrapper, Class); }; return stack_wrapNativeSuper(Class); }\nfunction stack_construct(Parent, args, Class) { if (stack_isNativeReflectConstruct()) { stack_construct = Reflect.construct.bind(); } else { stack_construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) stack_setPrototypeOf(instance, Class.prototype); return instance; }; } return stack_construct.apply(null, arguments); }\nfunction stack_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction stack_isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }\nfunction stack_setPrototypeOf(o, p) { stack_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return stack_setPrototypeOf(o, p); }\nfunction stack_getPrototypeOf(o) { stack_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return stack_getPrototypeOf(o); }\n// import { NodePlaceholder } from \'./node-placeholder\';\n/**\n * 绘图栈\n * @extends Array\n */\nvar InstanceStack = /*#__PURE__*/function (_Array) {\n  stack_inherits(InstanceStack, _Array);\n  var _super = stack_createSuper(InstanceStack);\n  function InstanceStack() {\n    var _this;\n    stack_classCallCheck(this, InstanceStack);\n    _this = _super.call(this);\n    _this._currentHit = null;\n    return _this;\n  }\n  stack_createClass(InstanceStack, [{\n    key: "forEach",\n    value: function forEach(cb) {\n      return _get(stack_getPrototypeOf(InstanceStack.prototype), "forEach", this).call(this, function (i, idx) {\n        if (i.type === \'NODE_PLACEHOLDER\') {\n          return;\n        }\n        cb(i, idx);\n      });\n    }\n  }, {\n    key: "filter",\n    value: function filter(cb) {\n      return Array.from(_get(stack_getPrototypeOf(InstanceStack.prototype), "filter", this).call(this, function (i, idx) {\n        if (i.type === \'NODE_PLACEHOLDER\') {\n          return false;\n        }\n        return cb(i, idx);\n      }));\n    }\n  }, {\n    key: "slice",\n    value: function slice() {\n      return Array.from(_get(stack_getPrototypeOf(InstanceStack.prototype), "filter", this).call(this, function (i, idx) {\n        return i.type !== \'NODE_PLACEHOLDER\';\n      }));\n    }\n  }, {\n    key: "superfilter",\n    value: function superfilter(cb) {\n      return _get(stack_getPrototypeOf(InstanceStack.prototype), "filter", this).call(this, function (i, idx) {\n        return cb(i, idx);\n      });\n    }\n    /**\n     * 绘制当前栈\n     * @param {Context2d} ctx - canvas context2d\n     */\n  }, {\n    key: "render",\n    value: function render(ctx, condition) {\n      var movingTarget;\n      this.forEach(function (instance) {\n        if (instance._isMoving) {\n          movingTarget = instance;\n          return;\n        }\n        if (instance.visible && (!condition || condition(instance))) {\n          if (instance.beforeRender) {\n            if (!instance.beforeRender(ctx)) {\n              return;\n            }\n          }\n          ctx.save();\n          instance.render(ctx);\n          ctx.restore();\n        }\n      });\n      if (movingTarget) {\n        ctx.save();\n        // if(movingTarget.reflow && !movingTarget._reflowed) {\n        //     movingTarget.reflow();\n        //     movingTarget._reflowed = true;\n        // }\n        movingTarget.render(ctx);\n        ctx.restore();\n      }\n    }\n  }, {\n    key: "resetHitStatus",\n    value: function resetHitStatus() {\n      this._currentHit = null;\n      this.forEach(function (i) {\n        if (i._stack) {\n          i._stack.resetHitStatus();\n        }\n        i._isHit = false;\n      });\n    }\n\n    /**\n     * 碰撞对象过滤条件\n     * @name InstanceStack~InstanceFilter\n     * @function\n     * @param {Instance} instance - 当前对象\n    */\n    /**\n     * 碰撞检测\n     * @param {number[]} point - 碰撞点\n     * @param {InstanceStack~InstanceFilter} condition - 碰撞对象过滤条件\n     * @return {Instance}\n     */\n  }, {\n    key: "checkHit",\n    value: function checkHit(point, condition, currentConstraint) {\n      var i = this.length - 1;\n      while (i >= 0) {\n        var instance = this[i];\n        if (instance.type === \'NODE_PLACEHOLDER\') {\n          i--;\n          continue;\n        }\n        if (instance.visible && !instance.ignoreHit) {\n          if (condition && condition(instance)) {\n            i--;\n            continue;\n          }\n          if (currentConstraint && !currentConstraint(instance)) {\n            i--;\n            continue;\n          }\n          var ishit = instance.isHit(point, condition);\n          if (ishit) {\n            if (this._currentHit !== instance) {\n              if (this._currentHit) {\n                this._currentHit._isHit = false;\n              }\n              instance._isHit = true;\n              this._currentHit = instance;\n            }\n            if (typeof ishit !== \'boolean\') {\n              return ishit;\n            }\n            return instance;\n          } else {\n            instance._isHit = false;\n          }\n        }\n        i--;\n      }\n      if (this._currentHit) {\n        this._currentHit._isHit = false;\n      }\n      this._currentHit = null;\n      return null;\n    }\n    /**\n     * 获取当前层栈的最小外接矩形\n     * @return {number[][]} - 外接矩形坐标\n     */\n  }, {\n    key: "getBoundingRectPoints",\n    value: function getBoundingRectPoints() {\n      var points = [];\n      this.forEach(function (instance) {\n        if (instance.visible && !instance.absolutePosition) {\n          var rect = instance.getBoundingRect();\n          points.push([rect[0], rect[1]]);\n          points.push([rect[2], rect[3]]);\n        }\n      });\n      return points;\n    }\n\n    /**\n     * 获取当前层栈的锚点矩形\n     * @return {number[][]} - 锚点矩形坐标\n     */\n  }, {\n    key: "getAnchorRectPoints",\n    value: function getAnchorRectPoints() {\n      var points = [];\n      this.forEach(function (instance) {\n        if (instance.visible && !instance.absolutePosition) {\n          points.push(instance.anchor);\n        }\n      });\n      return points;\n    }\n  }]);\n  return InstanceStack;\n}( /*#__PURE__*/stack_wrapNativeSuper(Array));\n/* harmony default export */ const stack = (InstanceStack);\n;// CONCATENATED MODULE: ./src/core/instance/stackMixin.js\n\n\n\n// import { setUniqueId, getUniqueId } from \'../utils/functions\';\n/**\n * 对象栈 mixin 用于方便控制节点栈和连线栈\n *\n * @mixin\n */\nvar StackMixin = {\n  /** @property {Node[]}          - 对象数组 */\n  instances: [],\n  /** @property {BaseLink[]}      - 连线数组 */\n  links: [],\n  /** @property {InstanceStack}       - 对象栈 */\n  _stack: null,\n  /** @property {InstanceStack}       - 连线栈 */\n  _linkStack: null,\n  /**\n   * 初始化对象栈\n   * @param {JflowConfigs} configs - 配置\n   */\n  initStack: function initStack() {\n    var _this = this;\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      data = _ref.data;\n    this._stack = new stack();\n    this._linkStack = new stack();\n    if (!data) return;\n    this.instances = data.instances;\n    this.links = data.links;\n    this.instances.forEach(function (i) {\n      _this._stack.push(i);\n      i._belongs = _this;\n    });\n    this.links.forEach(function (link) {\n      _this._linkStack.push(link);\n      link._belongs = _this;\n    });\n  },\n  /**\n   * 加入节点对象\n   * @param {Node} instance - 节点对象\n   */\n  addToStack: function addToStack(instance) {\n    // console.log(\'-----addToStack----\', instance)\n    instance._belongs = this;\n    this._stack.push(instance);\n    dirty_work_addReflowWork(instance, this);\n    // this.recalculate()\n  },\n  insertToStackBefore: function insertToStackBefore(instance, anchorNode) {\n    // console.log(\'-----insertToStackBefore----\')\n    if (instance._belongs) {\n      instance._belongs.removeFromStack(instance);\n    }\n    instance._belongs = this;\n    var idx = this._stack.findIndex(function (s) {\n      return s === anchorNode;\n    });\n    if (idx !== -1) {\n      this._stack.splice(idx, 0, instance);\n      dirty_work_addReflowWork(instance, this);\n    } else {\n      this.addToStack(instance);\n    }\n  },\n  /**\n   * 替换对象\n   * @param {Instance} target - 被替换的对象\n   * @param {Instance} instance - 替换对象\n   */\n  replaceFromStack: function replaceFromStack(target, instance) {\n    var index = this._stack.findIndex(function (i) {\n      return i === target;\n    });\n    this._stack.splice(index, 1, instance);\n    target._belongs = null;\n    instance._belongs = this;\n    // this.recalculate()\n  },\n  /**\n   * 加入连线对象\n   * @param {BaseLink} instance - 连线对象\n   */\n  addToLinkStack: function addToLinkStack(link) {\n    if (this._linkStack.find(function (l) {\n      return l === link;\n    })) {\n      return;\n    }\n    link._belongs = this;\n    this._linkStack.push(link);\n  },\n  /**\n   * 删除节点对象\n   * @param {Node} target - 节点对象\n   */\n  removeFromStack: function removeFromStack(target) {\n    // console.log(\'-----removeFromStack----\')\n    // this.removeLinkOnInstance(target);\n    var index = this._stack.findIndex(function (i) {\n      return i === target;\n    });\n    if (index !== -1) {\n      this._stack.splice(index, 1);\n      dirty_work_addReflowWork(this);\n    }\n    // this.recalculate()\n  },\n  /**\n   * 删除连线对象\n   * @param {Node} target - 连线对象\n   */\n  removeFromLinkStack: function removeFromLinkStack(target) {\n    var index = this._linkStack.findIndex(function (i) {\n      return i === target;\n    });\n    if (index !== -1) {\n      this._linkStack.splice(index, 1);\n    }\n  },\n  emptyLink: function emptyLink() {\n    this._linkStack = new stack();\n  },\n  /**\n   * 重置当前栈中对象的位置\n   */\n  resetChildrenPosition: function resetChildrenPosition() {\n    this._stack.forEach(function (i) {\n      i.anchor = [0, 0];\n    });\n  },\n  addInstanceToLink: function addInstanceToLink(targetLink, instance) {\n    this.addToStack(instance);\n    var from = targetLink.from,\n      to = targetLink.to;\n    var index = this._linkStack.findIndex(function (l) {\n      return l === targetLink;\n    });\n    var _constuctor = targetLink.__proto__.constructor;\n    var l1 = new _constuctor({\n      from: from,\n      to: instance\n    });\n    l1._belongs = this;\n    var l2 = new _constuctor({\n      from: instance,\n      to: to\n    });\n    l2._belongs = this;\n    this._linkStack.splice(index, 1, l1, l2);\n  },\n  /**\n   * 循环当前栈中节点\n   * @property {stackIteratorCallback} 循环访问栈中每个节点\n   */\n  interateNodeStack: function interateNodeStack(callback) {\n    this._stack.forEach(function (instance) {\n      callback(instance);\n    });\n  }\n  /**\n  * 循环访问栈中每个节点\n  * @callback stackIteratorCallback\n  * @param {Node} instance 栈中节点\n  */\n};\n/* harmony default export */ const stackMixin = (StackMixin);\n;// CONCATENATED MODULE: ./src/core/instance/layoutMixin.js\n/**\n * Layout mixin 配置\n * @typedef {Object} LayoutMixin~LayoutConfigs\n * @property {Layout} layout             - 布局对象 \n */\n/**\n * 布局 mixin 用于注册和方便控制布局\n *\n * @mixin\n */\nvar LayoutMixin = {\n  /** @property {Layout}      - 布局对象 */\n  _layout: null,\n  /**\n   * 初始化布局\n   * @param {LayoutMixin~LayoutConfigs} configs - 配置\n   */\n  initLayout: function initLayout() {\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._layout = configs.layout;\n  },\n  /**\n   * 从当前层出发，向上层递归重排\n   */\n  recalculateUp: function recalculateUp() {\n    var _this$_belongs;\n    // console.log(\'----recalculateUp----\')\n    var dirty = true;\n    if (this.getBoundingDimension) {\n      var _this$getBoundingDime = this.getBoundingDimension(),\n        wold = _this$getBoundingDime.width,\n        hold = _this$getBoundingDime.height;\n      if (this.resetChildrenPosition) {\n        this.resetChildrenPosition();\n      }\n      if (this._getBoundingGroupRect) {\n        this._getBoundingGroupRect();\n      }\n      this.reflow();\n      if (this._getBoundingGroupRect) {\n        this._getBoundingGroupRect();\n      }\n      var _this$getBoundingDime2 = this.getBoundingDimension(),\n        wnow = _this$getBoundingDime2.width,\n        hnow = _this$getBoundingDime2.height;\n      dirty = wold !== wnow || hold !== hnow;\n    } else {\n      this.reflow();\n    }\n    if (this._belongs && dirty) {\n      this._belongs.recalculateUp();\n    }\n    if (!dirty || ((_this$_belongs = this._belongs) === null || _this$_belongs === void 0 ? void 0 : _this$_belongs.uniqueName) === \'jflow\') {\n      this.recalculateDown();\n    }\n  },\n  recalculateDown: function recalculateDown() {\n    if (this._layout && this._layout.reflowAfter) {\n      this._layout.reflowAfter(this);\n    }\n    this._stack.forEach(function (instance) {\n      if (instance.recalculateDown) {\n        instance.recalculateDown();\n      }\n    });\n  },\n  /**\n   * 重新计算布局，相当于浏览器里面重排，并重算当前布局下的最小外接矩形\n   */\n  recalculate: function recalculate() {\n    // console.log(\'----recalculate----\')\n    this.reflow();\n    if (this._getBoundingGroupRect) {\n      this._getBoundingGroupRect();\n    }\n  },\n  /**\n   * 布局静态检查\n   * @param {Instance} instance - 检查单元\n   * @return {Boolean} - 检查结果 \n   */\n  staticCheck: function staticCheck(instance) {\n    if (this._layout) {\n      return this._layout.staticCheck(instance, this);\n    }\n    return false;\n  },\n  /**\n   * 重新计算布局，相当于浏览器里面重排\n   */\n  reflow: function reflow() {\n    if (this._layout) {\n      this._layout.reflow(this);\n    }\n  }\n};\n/* harmony default export */ const layoutMixin = (LayoutMixin);\n;// CONCATENATED MODULE: ./src/core/instance/messageMixin.js\n/**\n * 消息 mixin 用于给Jflow传递消息\n *\n * @mixin\n */\nvar MessageMixin = {\n  _message: null,\n  /**\n   * 发送消息\n   * @param {Object} msg - 消息体\n   */\n  sendMessage: function sendMessage(msg) {\n    this._message = msg;\n  },\n  /**\n   * 接收消息\n   * @return {Object} msg - 消息体\n   */\n  consumeMessage: function consumeMessage() {\n    var msg = this._message;\n    this._message = null;\n    return msg;\n  },\n  readMessage: function readMessage() {\n    return this._message;\n  }\n};\n/* harmony default export */ const messageMixin = (MessageMixin);\n;// CONCATENATED MODULE: ./src/core/anime/animeMixin.js\n/* harmony default export */ const animeMixin = ({\n  initAnime: function initAnime() {\n    this.anime_queue = [];\n    this.__animeClock__ = undefined;\n    // this.animeclock = undefined;\n    // this.frameRendered = false;\n  },\n  // setAnimeClock(time) {\n  //     if(time !== this.animeclock) {\n  //         this.frameRendered = false;\n  //         this.animeclock = time;\n  //     }\n  // },\n  // hasAnimeAndFrameRendered() {\n  //     return this.anime_queue.length && this.frameRendered;\n  // },\n  // setFrameRendered() {\n  //     if(this.anime_queue.length) {\n  //         this.frameRendered = true;\n  //     }\n  // },\n  requestJFlowAnime: function requestJFlowAnime(frameCallBack) {\n    var meta = this.enqueueAnime(frameCallBack);\n    this._runAnime();\n    return meta;\n  },\n  enqueueAnime: function enqueueAnime(callback) {\n    var _this = this;\n    var animeMeta = {\n      start: undefined,\n      callback: callback,\n      cancel: function cancel() {\n        _this._cancelAnime(animeMeta);\n        _this._render();\n      }\n    };\n    this.anime_queue.push(animeMeta);\n    return animeMeta;\n  },\n  _cancelAnime: function _cancelAnime(meta) {\n    var idx = this.anime_queue.findIndex(function (m) {\n      return m === meta;\n    });\n    ~idx && this.anime_queue.splice(idx, 1);\n  },\n  runAnime: function runAnime() {\n    this._runAnime();\n    // requestAnimationFrame(this._runAnime.bind(this));\n  },\n  _runAnime: function _runAnime() {\n    var _this2 = this;\n    if (this.anime_queue.length) {\n      requestAnimationFrame(function () {\n        _this2.scheduleRender();\n        _this2._runAnime();\n      });\n      // requestAnimationFrame(this._runAnime.bind(this))\n    }\n  },\n  runAnimeFrame: function runAnimeFrame() {\n    this.anime_queue.forEach(function (meta) {\n      var timestamp = Date.now();\n      if (!meta.start) {\n        meta.start = timestamp;\n      }\n      var elapsed = timestamp - meta.start;\n      meta.callback(elapsed);\n    });\n  }\n});\n;// CONCATENATED MODULE: ./src/core/miniMap/minimap-mixin.js\nfunction minimap_mixin_slicedToArray(arr, i) { return minimap_mixin_arrayWithHoles(arr) || minimap_mixin_iterableToArrayLimit(arr, i) || minimap_mixin_unsupportedIterableToArray(arr, i) || minimap_mixin_nonIterableRest(); }\nfunction minimap_mixin_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction minimap_mixin_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return minimap_mixin_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return minimap_mixin_arrayLikeToArray(o, minLen); }\nfunction minimap_mixin_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction minimap_mixin_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction minimap_mixin_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/* harmony default export */ const minimap_mixin = ({\n  // 传入一个别的 context2d 来绘制\n  captureMap: function captureMap(wrapper, _ref) {\n    var _this = this;\n    var _ref$padding = _ref.padding,\n      padding = _ref$padding === void 0 ? 0 : _ref$padding,\n      _ref$placement = _ref.placement,\n      placement = _ref$placement === void 0 ? \'normal\' : _ref$placement;\n    this._getBoundingGroupRect();\n    var _this$bounding_box = this.bounding_box,\n      p_width = _this$bounding_box.width,\n      p_height = _this$bounding_box.height,\n      p_x = _this$bounding_box.x,\n      p_y = _this$bounding_box.y;\n    var miniMap = this.miniMap;\n    if (!miniMap) {\n      this.miniMap = createCanvas(wrapper);\n      var _this$miniMap = this.miniMap,\n        _width = _this$miniMap.width,\n        _height = _this$miniMap.height,\n        _raw_width = _this$miniMap.raw_width,\n        _raw_height = _this$miniMap.raw_height;\n      this.addEventListener(\'zoompan\', function () {\n        _this._renderMap && _this._renderMap();\n      });\n      var pressDown = false;\n      this.miniMap.canvas.addEventListener(\'pointerdown\', function (event) {\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY,\n          deltaX = event.deltaX,\n          deltaY = event.deltaY;\n        pressDown = true;\n        _this._onMoveMap && _this._onMoveMap(offsetX, offsetY);\n      });\n      this.miniMap.canvas.addEventListener(\'pointermove\', function (event) {\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY,\n          deltaX = event.deltaX,\n          deltaY = event.deltaY;\n        if (pressDown) {\n          _this._onMoveMap && _this._onMoveMap(offsetX, offsetY);\n        }\n        if (offsetY < 5 || offsetX < 5 || offsetX > _width - 5 || offsetY > _height - 5) {\n          pressDown = false;\n        }\n      });\n      this.miniMap.canvas.addEventListener(\'pointerup\', function () {\n        pressDown = false;\n      });\n      var caheCanvas = document.createElement(\'canvas\');\n      caheCanvas.width = _raw_width;\n      caheCanvas.height = _raw_height;\n      this.cacheMinimapCtx = caheCanvas.getContext(\'2d\');\n    }\n    var _this$miniMap2 = this.miniMap,\n      width = _this$miniMap2.width,\n      height = _this$miniMap2.height,\n      raw_width = _this$miniMap2.raw_width,\n      raw_height = _this$miniMap2.raw_height,\n      left = _this$miniMap2.left,\n      top = _this$miniMap2.top,\n      scale = _this$miniMap2.scale,\n      ctx = _this$miniMap2.ctx;\n    var pad2 = padding * 2;\n    var pad = padding;\n    var r1 = (width - pad2) / p_width;\n    var r2 = (height - pad2) / p_height;\n    var r = Math.min(r1, r2);\n    var m_x = 0;\n    var m_y = 0;\n    if (placement === \'center\') {\n      m_y = (height - p_height * r) / 2 - p_y * r;\n      m_x = (width - p_width * r) / 2 - p_x * r;\n    } else {\n      if (r1 < r2) {\n        m_y = (height - p_height * r) / 2 - p_y * r;\n        m_x = pad;\n      } else {\n        m_x = (width - p_width * r) / 2 - p_x * r;\n        m_y = pad;\n      }\n    }\n    var cachectx = this.cacheMinimapCtx;\n    cachectx.setTransform();\n    cachectx.clearRect(0, 0, raw_width, raw_height);\n    cachectx.scale(scale, scale);\n    cachectx.transform(r, 0, 0, r, m_x, m_y);\n    // ctx.fillStyle = \'red\';\n    // ctx.arc( 30, 30, 100, 0, 2*Math.PI);\n    // ctx.fill()\n    // debugger\n    var br = [0, 0, 0, 0];\n    if (this.NodeRenderTop) {\n      this._linkStack.render(cachectx, function (link) {\n        link.isInViewBox(br);\n        return true;\n      });\n      // this._linkStack.render(cachectx);\n      this._stack.render(cachectx);\n    } else {\n      this._stack.render(cachectx);\n      this._linkStack.render(cachectx, function (link) {\n        link.isInViewBox(br);\n        return true;\n      });\n    }\n    var _cacheMapImageData = cachectx.getImageData(0, 0, raw_width, raw_height);\n    this._renderMap = function () {\n      ctx.save();\n      ctx.setTransform();\n      ctx.clearRect(0, 0, raw_width, raw_height);\n      // if(!i) {\n      ctx.scale(scale, scale);\n      ctx.putImageData(_cacheMapImageData, 0, 0);\n      ctx.transform(r, 0, 0, r, m_x, m_y);\n      var _this$_getViewBox = _this._getViewBox(),\n        _this$_getViewBox2 = minimap_mixin_slicedToArray(_this$_getViewBox, 4),\n        x = _this$_getViewBox2[0],\n        y = _this$_getViewBox2[1],\n        t = _this$_getViewBox2[2],\n        d = _this$_getViewBox2[3];\n      ctx.beginPath();\n      ctx.rect(x, y, t - x, d - y);\n      ctx.setTransform();\n      ctx.rect(0, 0, raw_width, raw_height);\n      ctx.clip("evenodd");\n      ctx.fillStyle = \'rgba(0,0,0,0.4)\';\n      ctx.fillRect(0, 0, raw_width, raw_height);\n      ctx.restore();\n      // }\n    };\n\n    this._renderMap();\n    this._onMoveMap = function (offsetX, offsetY) {\n      var _this$_getViewBox3 = _this._getViewBox(),\n        _this$_getViewBox4 = minimap_mixin_slicedToArray(_this$_getViewBox3, 4),\n        x = _this$_getViewBox4[0],\n        y = _this$_getViewBox4[1],\n        t = _this$_getViewBox4[2],\n        d = _this$_getViewBox4[3];\n      // const w = t-x;\n      var a = (t - x) / 2 + x;\n      var b = (d - y) / 2 + y;\n      var p = [a * r + m_x, b * r + m_y];\n      _this._recalculatePosition((p[0] - offsetX) / r * _this.scale, (p[1] - offsetY) / r * _this.scale);\n      _this._render();\n      _this._renderMap();\n    };\n    // this._render(ctx);\n  }\n});\n;// CONCATENATED MODULE: ./src/core/events/index.js\nfunction events_typeof(obj) { "@babel/helpers - typeof"; return events_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, events_typeof(obj); }\nfunction events_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction events_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? events_ownKeys(Object(source), !0).forEach(function (key) { events_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : events_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction events_defineProperty(obj, key, value) { key = events_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction events_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, events_toPropertyKey(descriptor.key), descriptor); } }\nfunction events_createClass(Constructor, protoProps, staticProps) { if (protoProps) events_defineProperties(Constructor.prototype, protoProps); if (staticProps) events_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction events_toPropertyKey(arg) { var key = events_toPrimitive(arg, "string"); return events_typeof(key) === "symbol" ? key : String(key); }\nfunction events_toPrimitive(input, hint) { if (events_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (events_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction events_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction events_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) events_setPrototypeOf(subClass, superClass); }\nfunction events_createSuper(Derived) { var hasNativeReflectConstruct = events_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = events_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = events_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return events_possibleConstructorReturn(this, result); }; }\nfunction events_possibleConstructorReturn(self, call) { if (call && (events_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return events_assertThisInitialized(self); }\nfunction events_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction events_wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; events_wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !events_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return events_construct(Class, arguments, events_getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return events_setPrototypeOf(Wrapper, Class); }; return events_wrapNativeSuper(Class); }\nfunction events_construct(Parent, args, Class) { if (events_isNativeReflectConstruct()) { events_construct = Reflect.construct.bind(); } else { events_construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) events_setPrototypeOf(instance, Class.prototype); return instance; }; } return events_construct.apply(null, arguments); }\nfunction events_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction events_isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }\nfunction events_setPrototypeOf(o, p) { events_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return events_setPrototypeOf(o, p); }\nfunction events_getPrototypeOf(o) { events_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return events_getPrototypeOf(o); }\n/**\n * JFlow 抛出事件\n * @extends CustomEvent\n * @property {Event}  originEvent      - 原始事件\n * @property {Instance} target         - 事件触发对象\n * @property {JFlow} jflow             - JFlow 对象\n * @property {boolean} bubbles         - 冒泡标识\n */\nvar JFlowEvent = /*#__PURE__*/function (_CustomEvent) {\n  events_inherits(JFlowEvent, _CustomEvent);\n  var _super = events_createSuper(JFlowEvent);\n  function JFlowEvent(event) {\n    var configs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    events_classCallCheck(this, JFlowEvent);\n    var detail = events_objectSpread(events_objectSpread({}, configs), {}, {\n      originEvent: configs.event,\n      target: configs.target,\n      jflow: configs.jflow,\n      bubbles: configs.bubbles || false\n    });\n    return _super.call(this, event, {\n      detail: detail\n    });\n  }\n  return events_createClass(JFlowEvent);\n}( /*#__PURE__*/events_wrapNativeSuper(CustomEvent));\n/* harmony default export */ const events = (JFlowEvent);\n;// CONCATENATED MODULE: ./src/core/scrollbar/scrollbarMixin.js\nfunction scrollbarMixin_typeof(obj) { "@babel/helpers - typeof"; return scrollbarMixin_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, scrollbarMixin_typeof(obj); }\nfunction scrollbarMixin_slicedToArray(arr, i) { return scrollbarMixin_arrayWithHoles(arr) || scrollbarMixin_iterableToArrayLimit(arr, i) || scrollbarMixin_unsupportedIterableToArray(arr, i) || scrollbarMixin_nonIterableRest(); }\nfunction scrollbarMixin_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction scrollbarMixin_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return scrollbarMixin_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return scrollbarMixin_arrayLikeToArray(o, minLen); }\nfunction scrollbarMixin_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction scrollbarMixin_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction scrollbarMixin_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction scrollbarMixin_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction scrollbarMixin_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, scrollbarMixin_toPropertyKey(descriptor.key), descriptor); } }\nfunction scrollbarMixin_createClass(Constructor, protoProps, staticProps) { if (protoProps) scrollbarMixin_defineProperties(Constructor.prototype, protoProps); if (staticProps) scrollbarMixin_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction scrollbarMixin_toPropertyKey(arg) { var key = scrollbarMixin_toPrimitive(arg, "string"); return scrollbarMixin_typeof(key) === "symbol" ? key : String(key); }\nfunction scrollbarMixin_toPrimitive(input, hint) { if (scrollbarMixin_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (scrollbarMixin_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\nvar ScrollBar = /*#__PURE__*/function () {\n  function ScrollBar(dir) {\n    var configs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    scrollbarMixin_classCallCheck(this, ScrollBar);\n    this.anchor = [0, 0];\n    this.width = configs.barWidth || 4;\n    this.height = configs.barWidth || 4;\n    this.barMarginX = 0;\n    this.barMarginY = 0;\n    this.dir = dir;\n    this.plainColor = configs.plainColor || \'rgba(0, 0, 0, 0.15)\';\n    this.focusColor = configs.focusColor || \'rgba(0, 0, 0, 0.25)\';\n    this.isFocus = false;\n  }\n  scrollbarMixin_createClass(ScrollBar, [{\n    key: "render",\n    value: function render(ctx) {\n      var _this$anchor = scrollbarMixin_slicedToArray(this.anchor, 2),\n        x = _this$anchor[0],\n        y = _this$anchor[1];\n      ctx.save();\n      ctx.beginPath();\n      if (this.dir === \'x\') {\n        var radius = this.height / 2;\n        var cy = y + radius;\n        var by = y + this.height;\n        var rc = x + this.width - this.barMarginX * 2 - radius;\n        var lc = x + this.barMarginX + radius;\n        ctx.moveTo(lc, by);\n        ctx.arc(lc, cy, radius, Math.PI / 2, Math.PI / 2 * 3);\n        ctx.lineTo(rc, y);\n        ctx.arc(rc, cy, radius, -Math.PI / 2, Math.PI / 2);\n        ctx.closePath();\n      } else {\n        var _radius = this.width / 2;\n        var tc = y + this.barMarginY + _radius;\n        var bc = y + this.height - this.barMarginY * 2 - _radius;\n        var cx = x + _radius;\n        var rx = x + this.width;\n        ctx.moveTo(x, tc);\n        ctx.arc(cx, tc, _radius, -Math.PI, 0);\n        ctx.lineTo(rx, bc);\n        ctx.arc(cx, bc, _radius, 0, Math.PI);\n        ctx.closePath();\n      }\n      //   ctx.rect(\n      // x + this.barMarginX,\n      // y + this.barMarginY,\n      // this.width - this.barMarginX*2,\n      // this.height - this.barMarginY*2);\n\n      ctx.fillStyle = this.isFocus ? this.focusColor : this.plainColor;\n      ctx.fill();\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      var anchor = this.anchor;\n      var w = this.width;\n      var h = this.height;\n      return point[0] > anchor[0] - 5 && point[0] < anchor[0] + w + 5 && point[1] > anchor[1] - 5 && point[1] < anchor[1] + h + 5;\n    }\n  }]);\n  return ScrollBar;\n}();\n/* harmony default export */ const scrollbarMixin = ({\n  initScrollBar: function initScrollBar() {\n    var _this = this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var barColor = configs.barColor,\n      barFocusColor = configs.barFocusColor,\n      barMarginX = configs.barMarginX,\n      barMarginY = configs.barMarginY,\n      barWidth = configs.barWidth;\n    this._scrollbarEnable = true;\n    this._scrollbarX = new ScrollBar(\'x\', {\n      plainColor: barColor,\n      focusColor: barFocusColor,\n      barWidth: barWidth\n    });\n    this._scrollbarX.barMarginX = barMarginX || 5;\n    this._scrollbarY = new ScrollBar(\'y\', {\n      plainColor: barColor,\n      focusColor: barFocusColor,\n      barWidth: barWidth\n    });\n    this._scrollbarY.barMarginY = barMarginY || 5;\n    this._scrollBarStatus = {\n      dragging: false,\n      target: null,\n      xscale: undefined,\n      yscale: undefined,\n      barInitX: 0,\n      barInitY: 0\n    };\n    this.stopZoompanWatch = false;\n    this.addEventListener(\'zoompan\', function () {\n      if (!_this.stopZoompanWatch) {\n        _this.scrollBarOnPanAndZoom();\n      }\n    });\n    this.scrollBarOnPanAndZoom();\n    this.canvas.addEventListener(\'pointerdown\', function (e) {\n      var offsetX = e.offsetX,\n        offsetY = e.offsetY,\n        clientX = e.clientX,\n        clientY = e.clientY;\n      _this.onScrollbarPressStart(offsetX, offsetY, clientX, clientY);\n    });\n  },\n  checkScrollDragging: function checkScrollDragging() {\n    return this._scrollBarStatus && this._scrollBarStatus.dragging;\n  },\n  onScrollbarPressStart: function onScrollbarPressStart(offsetX, offsetY, clientX, clientY) {\n    var _this2 = this;\n    this.stopZoompanWatch = true;\n    var xhit = this._scrollbarX.isHit([offsetX, offsetY]);\n    if (xhit) {\n      Object.assign(this._scrollBarStatus, {\n        dragging: true,\n        target: this._scrollbarX,\n        barStartX: this._scrollbarX.anchor[0],\n        barInitX: clientX\n      });\n    }\n    var yhit = this._scrollbarY.isHit([offsetX, offsetY]);\n    if (yhit) {\n      Object.assign(this._scrollBarStatus, {\n        dragging: true,\n        target: this._scrollbarY,\n        barStartY: this._scrollbarY.anchor[1],\n        barInitY: clientY\n      });\n    }\n    var f = function (e) {\n      var offsetX = e.offsetX,\n        offsetY = e.offsetY,\n        clientX = e.clientX,\n        clientY = e.clientY;\n      _this2.onDraggingScrollbar(offsetX, offsetY, clientX, clientY);\n    }.bind(this);\n    document.addEventListener(\'pointermove\', f);\n    var t = function (e) {\n      Object.assign(_this2._scrollBarStatus, {\n        dragging: false,\n        target: null,\n        x: undefined,\n        y: undefined\n      });\n      document.removeEventListener(\'pointermove\', f);\n      document.removeEventListener(\'pointerup\', t);\n      _this2.canvas.removeEventListener(\'pointerup\', t);\n      _this2.stopZoompanWatch = false;\n    }.bind(this);\n    this.canvas.addEventListener(\'pointerup\', t, {\n      once: true\n    });\n    document.addEventListener(\'pointerup\', t, {\n      once: true\n    });\n  },\n  onDraggingScrollbar: function onDraggingScrollbar(offsetX, offsetY, clientX, clientY) {\n    if (this._scrollbarEnable && this._scrollBarStatus.dragging) {\n      var _this$_scrollBarStatu = this._scrollBarStatus,\n        target = _this$_scrollBarStatu.target,\n        barInitX = _this$_scrollBarStatu.barInitX,\n        barStartX = _this$_scrollBarStatu.barStartX,\n        barInitY = _this$_scrollBarStatu.barInitY,\n        barStartY = _this$_scrollBarStatu.barStartY,\n        xscale = _this$_scrollBarStatu.xscale,\n        yscale = _this$_scrollBarStatu.yscale,\n        scollbarHeight = _this$_scrollBarStatu.scollbarHeight,\n        scollbarWidth = _this$_scrollBarStatu.scollbarWidth,\n        realR = _this$_scrollBarStatu.realR,\n        realL = _this$_scrollBarStatu.realL,\n        realT = _this$_scrollBarStatu.realT,\n        realB = _this$_scrollBarStatu.realB;\n      var _this$canvasMeta = this.canvasMeta,\n        actual_width = _this$canvasMeta.actual_width,\n        actual_height = _this$canvasMeta.actual_height;\n      var _this$bounding_box = this.bounding_box,\n        p_x = _this$bounding_box.x,\n        p_y = _this$bounding_box.y;\n      // console.log(target.dir, realT, realB)\n      var deltaX = 0,\n        deltaY = 0;\n      if (target.dir === \'x\') {\n        deltaX = clientX - barInitX;\n        var xnew = barStartX + deltaX;\n        var q = target.anchor[0] = Math.max(Math.min(xnew, actual_width - scollbarWidth), 0);\n        var ratioInX = q / actual_width;\n        // const y = (realB - (realB - realT) * ratioInY) * this.scale\n        var ratioX = (realR - realL) * ratioInX + realL;\n        var x = (p_x - ratioX) * this.scale;\n        Object.assign(this.position, {\n          offsetX: x - p_x * this.scale,\n          x: x\n        });\n      }\n      if (target.dir === \'y\') {\n        deltaY = clientY - barInitY;\n        var ynew = barStartY + deltaY;\n        var _q = target.anchor[1] = Math.max(Math.min(ynew, actual_height - scollbarHeight), 0);\n        ;\n        var ratioInY = _q / actual_height;\n        // const y = (realB - (realB - realT) * ratioInY) * this.scale\n        var ratioY = (realB - realT) * ratioInY + realT;\n        var y = (p_y - ratioY) * this.scale;\n        Object.assign(this.position, {\n          offsetY: y - p_y * this.scale,\n          y: y\n        });\n      }\n      this.dispatchEvent(new events(\'zoompan\', {\n        deltaX: deltaX,\n        deltaY: deltaY\n      }));\n      this.scheduleRender();\n      return true;\n    }\n    return false;\n  },\n  checkScrollBarHover: function checkScrollBarHover(offsetX, offsetY) {\n    if (this._scrollbarEnable) {\n      var xhit = this._scrollbarX.isHit([offsetX, offsetY]);\n      if (xhit) {\n        // this._scrollBarStatus.hoverTarget = this._scrollbarX;\n        if (!this._scrollbarX.isFocus) {\n          this._scrollbarX.isFocus = true;\n          this.scheduleRender();\n        }\n        this.canvas.style.cursor = \'default\';\n        return true;\n      }\n      var yhit = this._scrollbarY.isHit([offsetX, offsetY]);\n      if (yhit) {\n        // this._scrollBarStatus.hoverTarget = this._scrollbarY;\n        if (!this._scrollbarY.isFocus) {\n          this._scrollbarY.isFocus = true;\n          this.scheduleRender();\n        }\n        this.canvas.style.cursor = \'default\';\n        return true;\n      }\n    }\n    return false;\n  },\n  resetScrollBarHover: function resetScrollBarHover() {\n    if (this._scrollbarEnable) {\n      if (this._scrollbarY.isFocus || this._scrollbarX.isFocus) {\n        this._scrollbarY.isFocus = false;\n        this._scrollbarX.isFocus = false;\n        this.scheduleRender();\n      }\n    }\n  },\n  _getScrollViewBoundingbox: function _getScrollViewBoundingbox() {\n    var padding = 120;\n    var _this$bounding_box2 = this.bounding_box,\n      p_width = _this$bounding_box2.width,\n      p_height = _this$bounding_box2.height,\n      p_x = _this$bounding_box2.x,\n      p_y = _this$bounding_box2.y;\n    var p = padding;\n    var p2 = padding * 2;\n    return {\n      width: p_width + p2,\n      height: p_height + p2,\n      x: p_x - p,\n      y: p_y - p\n    };\n  },\n  scrollBarOnPanAndZoom: function scrollBarOnPanAndZoom() {\n    if (!this._scrollbarEnable || this._scrollBarStatus.dragging) {\n      return;\n    }\n    var _this$_getScrollViewB = this._getScrollViewBoundingbox(),\n      p_width = _this$_getScrollViewB.width,\n      p_height = _this$_getScrollViewB.height,\n      p_x = _this$_getScrollViewB.x,\n      p_y = _this$_getScrollViewB.y;\n    var _this$_getViewBox = this._getViewBox(),\n      _this$_getViewBox2 = scrollbarMixin_slicedToArray(_this$_getViewBox, 4),\n      x = _this$_getViewBox2[0],\n      y = _this$_getViewBox2[1],\n      r = _this$_getViewBox2[2],\n      b = _this$_getViewBox2[3];\n    var realR = Math.max(r, p_x + p_width);\n    var realL = Math.min(x, p_x);\n    var realT = Math.min(y, p_y);\n    var realB = Math.max(b, p_y + p_height);\n    var vw = r - x;\n    var vh = b - y;\n    var _this$canvasMeta2 = this.canvasMeta,\n      actual_width = _this$canvasMeta2.actual_width,\n      actual_height = _this$canvasMeta2.actual_height;\n    var xscale = vw / (realR - realL);\n    if (xscale < 1) {\n      var scollbarWidth = actual_width * xscale;\n      var anchorX = (x - realL) * xscale * this.scale;\n      this._scrollbarX.anchor = [anchorX, actual_height - 10];\n      this._scrollbarX.width = scollbarWidth;\n      this._scrollBarStatus.scollbarWidth = scollbarWidth;\n    }\n    var yscale = vh / (realB - realT);\n    if (yscale < 1) {\n      var scollbarHeight = actual_height * yscale;\n      var anchorY = (y - realT) * yscale * this.scale;\n      this._scrollbarY.anchor = [actual_width - 10, anchorY];\n      this._scrollbarY.height = scollbarHeight;\n      this._scrollBarStatus.scollbarHeight = scollbarHeight;\n    }\n    Object.assign(this._scrollBarStatus, {\n      yscale: yscale,\n      xscale: xscale,\n      realR: realR,\n      realL: realL,\n      realT: realT,\n      realB: realB\n    });\n  },\n  resetScollBarStatus: function resetScollBarStatus() {\n    if (this._scrollbarEnable) {\n      Object.assign(this._scrollBarStatus, {\n        dragging: false,\n        target: null,\n        x: undefined,\n        y: undefined\n      });\n    }\n  },\n  renderScrollBar: function renderScrollBar(ctx) {\n    if (this._scrollbarEnable) {\n      ctx.setTransform();\n      ctx.scale(this.dpr, this.dpr);\n      var _this$_scrollBarStatu2 = this._scrollBarStatus,\n        xscale = _this$_scrollBarStatu2.xscale,\n        yscale = _this$_scrollBarStatu2.yscale;\n      if (xscale < 1) {\n        this._scrollbarX.render(ctx);\n      }\n      if (yscale < 1) {\n        this._scrollbarY.render(ctx);\n      }\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/core/flow/schedule.js\n/* harmony default export */ const schedule = ({\n  toggleRender: function toggleRender(val) {\n    this.__renderstop__ = !val;\n  },\n  initSchedule: function initSchedule() {\n    this.__clock__ = undefined;\n  },\n  scheduleRender: function scheduleRender(callback) {\n    var _this = this;\n    requestAnimationFrame(function (timestamp) {\n      var isFirstTime = _this.__clock__ !== timestamp;\n      if (!_this.__renderstop__ && isFirstTime) {\n        _this.__render();\n      }\n      if (callback) {\n        callback(timestamp);\n      }\n      _this.__clock__ = timestamp;\n    });\n  }\n});\n;// CONCATENATED MODULE: ./src/core/events/adapter.js\nfunction adapter_typeof(obj) { "@babel/helpers - typeof"; return adapter_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, adapter_typeof(obj); }\nfunction adapter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction adapter_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, adapter_toPropertyKey(descriptor.key), descriptor); } }\nfunction adapter_createClass(Constructor, protoProps, staticProps) { if (protoProps) adapter_defineProperties(Constructor.prototype, protoProps); if (staticProps) adapter_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction adapter_toPropertyKey(arg) { var key = adapter_toPrimitive(arg, "string"); return adapter_typeof(key) === "symbol" ? key : String(key); }\nfunction adapter_toPrimitive(input, hint) { if (adapter_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (adapter_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n/**\n * 事件处理函数\n * @name EventAdapter~Handler\n * @function\n * @param {Event} event - 原生事件\n * @param {JFlow} jflow - 当前jflow 对象\n */\n\n/**\n * EventAdapter 对象 plugin 配置\n * @typedef {Object} EventAdapter~pluginDef\n * @property {Object} canvas - canvas 相关的事件\n * @property {EventAdapter~Handler} canvas.eventName - 注册 canvas 上的事件处理\n * @property {Object} document - document 相关的事件\n * @property {EventAdapter~Handler} document.eventName - 注册 document 上的事件处理\n */\n\nfunction getDefaultPlugin() {\n  var _mouseStatus = {\n    // x: undefined,\n    // y: undefined,\n    // enableClick: false,\n    pointerDown: false,\n    dirty: false\n  };\n  return {\n    canvas: {\n      wheel: function wheel(event, jflow) {\n        event.preventDefault();\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY,\n          deltaX = event.deltaX,\n          deltaY = event.deltaY;\n        if (event.ctrlKey) {\n          deltaY = -deltaY;\n          jflow.zoomHandler(offsetX, offsetY, deltaX, deltaY, event);\n        } else {\n          jflow.panHandler(-deltaX, -deltaY, event);\n        }\n      },\n      pointerdown: function pointerdown(event, jflow) {\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY,\n          deltaY = event.deltaY,\n          button = event.button;\n        if (button !== 0) return;\n        _mouseStatus.pointerDown = true;\n        jflow.pressStartHandler(offsetX, offsetY, event);\n      },\n      pointermove: function pointermove(event, jflow) {\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY;\n        if (_mouseStatus.pointerDown) {\n          _mouseStatus.dirty = true;\n        }\n        jflow.pressMoveHandler(offsetX, offsetY, event);\n      },\n      pointerup: function pointerup(event, jflow) {\n        event.preventDefault();\n        // event.stopPropagation(); ALWAYS ENABLE PROPAGATION \n        var offsetX = event.offsetX,\n          offsetY = event.offsetY,\n          button = event.button;\n        if (button !== 0) return;\n        if (_mouseStatus.pointerDown && _mouseStatus.dirty) {\n          _mouseStatus.pointerDown = false;\n          _mouseStatus.dirty = false;\n          jflow.pressUpHanlder(false, event);\n        }\n      },\n      contextmenu: function contextmenu(event, jflow) {\n        event.preventDefault();\n        event.stopPropagation();\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY;\n        jflow.contextMenuHanlder(offsetX, offsetY, event);\n      },\n      dblclick: function dblclick(event, jflow) {\n        event.preventDefault();\n        event.stopPropagation();\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY;\n        jflow.dblclickHandler(offsetX, offsetY, event);\n      },\n      click: function click(event, jflow) {\n        event.preventDefault();\n        event.stopPropagation();\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY;\n        if (!_mouseStatus.dirty) {\n          _mouseStatus.pointerDown = false;\n          _mouseStatus.dirty = false;\n          jflow.clickHanlder(offsetX, offsetY, event);\n        }\n      }\n    },\n    document: {\n      pointerup: function pointerup(event, jflow) {\n        jflow.pressUpHanlder(true, event);\n      }\n    }\n  };\n}\n\n/** \n * EventAdapter 对象\n * EventAdapter 通过 plugin 的形式实现多种交互方式的映射\n * @constructor EventAdapter\n */\nvar EventAdapter = /*#__PURE__*/function () {\n  function EventAdapter() {\n    var plugin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    adapter_classCallCheck(this, EventAdapter);\n    this.plugin = getDefaultPlugin();\n    this.use(plugin);\n    this.canvasHandlers = [];\n    this.documentHandlers = [];\n  }\n  adapter_createClass(EventAdapter, [{\n    key: "use",\n    value: function use() {\n      var plugin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var ca = plugin.canvas,\n        docObj = plugin.document;\n      if (ca) {\n        for (var eventName in ca) {\n          if (ca.hasOwnProperty(eventName)) {\n            this.plugin.canvas[eventName] = ca[eventName];\n          }\n        }\n      }\n      if (docObj) {\n        for (var _eventName in docObj) {\n          if (docObj.hasOwnProperty(_eventName)) {\n            this.plugin.document[_eventName] = docObj[_eventName];\n          }\n        }\n      }\n    }\n  }, {\n    key: "apply",\n    value: function apply(jflow) {\n      var _this = this;\n      var _this$plugin = this.plugin,\n        ca = _this$plugin.canvas,\n        docObj = _this$plugin.document;\n      var canvas = jflow.canvas;\n      var _loop = function _loop() {\n        var handler = ca[eventName];\n        function handlerWrapperd(e) {\n          handler(e, jflow);\n        }\n        canvas.addEventListener(eventName, handlerWrapperd);\n        _this.canvasHandlers.push({\n          eventName: eventName,\n          handlerWrapperd: handlerWrapperd\n        });\n      };\n      for (var eventName in ca) {\n        _loop();\n      }\n      var _loop2 = function _loop2() {\n        var handler;\n        var options = {};\n        if (typeof docObj[_eventName2] === \'function\') {\n          handler = docObj[_eventName2];\n        } else {\n          handler = docObj[_eventName2].handler;\n          Object.assign(options, docObj[_eventName2].options);\n        }\n        function handlerWrapperd(e) {\n          handler(e, jflow);\n        }\n        document.addEventListener(_eventName2, handlerWrapperd, options);\n        _this.documentHandlers.push({\n          eventName: _eventName2,\n          handlerWrapperd: handlerWrapperd,\n          options: options\n        });\n      };\n      for (var _eventName2 in docObj) {\n        _loop2();\n      }\n    }\n  }, {\n    key: "unload",\n    value: function unload(jflow) {\n      var canvas = jflow.canvas;\n      this.canvasHandlers.forEach(function (_ref) {\n        var eventName = _ref.eventName,\n          handlerWrapperd = _ref.handlerWrapperd;\n        canvas.removeEventListener(eventName, handlerWrapperd);\n      });\n      this.documentHandlers.forEach(function (_ref2) {\n        var eventName = _ref2.eventName,\n          handlerWrapperd = _ref2.handlerWrapperd,\n          options = _ref2.options;\n        console.log(\'unload\', eventName);\n        document.removeEventListener(eventName, handlerWrapperd, options);\n      });\n    }\n  }]);\n  return EventAdapter;\n}();\n/* harmony default export */ const adapter = (EventAdapter);\n;// CONCATENATED MODULE: ./src/core/instance/groupFactory.js\nfunction groupFactory_typeof(obj) { "@babel/helpers - typeof"; return groupFactory_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, groupFactory_typeof(obj); }\nfunction groupFactory_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, groupFactory_toPropertyKey(descriptor.key), descriptor); } }\nfunction groupFactory_createClass(Constructor, protoProps, staticProps) { if (protoProps) groupFactory_defineProperties(Constructor.prototype, protoProps); if (staticProps) groupFactory_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction groupFactory_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction groupFactory_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) groupFactory_setPrototypeOf(subClass, superClass); }\nfunction groupFactory_setPrototypeOf(o, p) { groupFactory_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return groupFactory_setPrototypeOf(o, p); }\nfunction groupFactory_createSuper(Derived) { var hasNativeReflectConstruct = groupFactory_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = groupFactory_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = groupFactory_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return groupFactory_possibleConstructorReturn(this, result); }; }\nfunction groupFactory_possibleConstructorReturn(self, call) { if (call && (groupFactory_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return groupFactory_assertThisInitialized(self); }\nfunction groupFactory_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction groupFactory_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction groupFactory_getPrototypeOf(o) { groupFactory_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return groupFactory_getPrototypeOf(o); }\nfunction groupFactory_slicedToArray(arr, i) { return groupFactory_arrayWithHoles(arr) || groupFactory_iterableToArrayLimit(arr, i) || groupFactory_unsupportedIterableToArray(arr, i) || groupFactory_nonIterableRest(); }\nfunction groupFactory_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction groupFactory_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return groupFactory_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return groupFactory_arrayLikeToArray(o, minLen); }\nfunction groupFactory_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction groupFactory_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction groupFactory_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction groupFactory_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction groupFactory_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? groupFactory_ownKeys(Object(source), !0).forEach(function (key) { groupFactory_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : groupFactory_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction groupFactory_defineProperty(obj, key, value) { key = groupFactory_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction groupFactory_toPropertyKey(arg) { var key = groupFactory_toPrimitive(arg, "string"); return groupFactory_typeof(key) === "symbol" ? key : String(key); }\nfunction groupFactory_toPrimitive(input, hint) { if (groupFactory_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (groupFactory_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n\n\n\nvar GroupMixin = groupFactory_objectSpread(groupFactory_objectSpread(groupFactory_objectSpread({}, stackMixin), layoutMixin), {}, {\n  _setPadding: function _setPadding(configs) {\n    this.padding = {\n      top: configs.paddingTop || configs.padding || 0,\n      right: configs.paddingRight || configs.padding || 0,\n      bottom: configs.paddingBottom || configs.padding || 0,\n      left: configs.paddingLeft || configs.padding || 0\n    };\n  },\n  _setMargin: function _setMargin(configs) {\n    this.margin = {\n      top: configs.marginTop || configs.margin || 0,\n      right: configs.marginRight || configs.margin || 0,\n      bottom: configs.marginBottom || configs.margin || 0,\n      left: configs.marginLeft || configs.margin || 0\n    };\n  },\n  _getCenter: function _getCenter() {\n    var anchor = this.anchor;\n    var padding = this.padding;\n    var margin = this.margin;\n    var mx = (margin.left - margin.right) / 2;\n    var my = (margin.top - margin.bottom) / 2;\n    var centerX = (padding.left - padding.right) / 2 + mx;\n    var centerY = (padding.top - padding.bottom) / 2 + my;\n    this._shape.anchor = [anchor[0] + mx, anchor[1] + my];\n    this._center[0] = anchor[0] + centerX;\n    this._center[1] = anchor[1] + centerY;\n    return this._center;\n  },\n  setAnchorX: function setAnchorX(x) {\n    this.anchor[0] = x;\n    this._getCenter();\n  },\n  setAnchorY: function setAnchorY(y) {\n    this.anchor[1] = y;\n    this._getCenter();\n  },\n  setAnchor: function setAnchor(x, y) {\n    this.anchor[0] = x;\n    this.anchor[1] = y;\n    this._getCenter();\n  },\n  _calculatePointBack: function _calculatePointBack(point) {\n    var _point = groupFactory_slicedToArray(point, 2),\n      gx = _point[0],\n      gy = _point[1];\n    var _this$_getCenter = this._getCenter(),\n      _this$_getCenter2 = groupFactory_slicedToArray(_this$_getCenter, 2),\n      cx = _this$_getCenter2[0],\n      cy = _this$_getCenter2[1];\n    var p = [gx - cx, gy - cy];\n    return p;\n  },\n  _calculatePointBackWithPoint: function _calculatePointBackWithPoint(a, b, arr, idx1, idx2) {\n    var anchor = this.anchor;\n    var padding = this.padding;\n    var margin = this.margin;\n    arr[idx1] = a - (anchor[0] + (padding.left - padding.right) / 2 + (margin.left - margin.right) / 2);\n    arr[idx2] = b - (anchor[1] + (padding.top - padding.bottom) / 2 + (margin.top - margin.bottom) / 2);\n  },\n  /**\n   * 反算回 canvas 顶层坐标\n   * @param {Number[]} point\n   * @return {Number[]} 世界坐标\n   */\n  calculateToCoordination: function calculateToCoordination(point) {\n    var _point2 = groupFactory_slicedToArray(point, 2),\n      gx = _point2[0],\n      gy = _point2[1];\n    var _this$_getCenter3 = this._getCenter(),\n      _this$_getCenter4 = groupFactory_slicedToArray(_this$_getCenter3, 2),\n      cx = _this$_getCenter4[0],\n      cy = _this$_getCenter4[1];\n    // const p = [cx + anchor[0] - spanH, cy + anchor[1] - spanV];\n    var p = [gx + cx, gy + cy];\n    if (this._belongs && this._belongs.calculateToCoordination) {\n      return this._belongs.calculateToCoordination(p);\n    } else {\n      return p;\n    }\n  },\n  /**\n   * 反算回页面的像素坐标，重载 {@link Instance#calculateToRealWorld}\n   * @param {Number[]} point\n   * @return {Number[]} 世界坐标\n   */\n  calculateToRealWorld: function calculateToRealWorld(point) {\n    var _point3 = groupFactory_slicedToArray(point, 2),\n      gx = _point3[0],\n      gy = _point3[1];\n    var _this$_getCenter5 = this._getCenter(),\n      _this$_getCenter6 = groupFactory_slicedToArray(_this$_getCenter5, 2),\n      cx = _this$_getCenter6[0],\n      cy = _this$_getCenter6[1];\n    var p = [gx + cx, gy + cy];\n    if (this._belongs && this._belongs.calculateToRealWorld) {\n      return this._belongs.calculateToRealWorld(p);\n    }\n  },\n  calculateToRealWorldWithPointer: function calculateToRealWorldWithPointer(outpoint, inpoint) {\n    outpoint[0] = inpoint[0] + this._center[0];\n    outpoint[1] = inpoint[1] + this._center[1];\n    if (this._belongs && this._belongs.calculateToRealWorldWithPointer) {\n      return this._belongs.calculateToRealWorldWithPointer(outpoint, outpoint);\n    }\n  },\n  clone: function clone() {\n    var C = this.constructor;\n    var configs = Object.assign({}, this._rawConfigs, {\n      layout: this._layout && this._layout.clone()\n    });\n    var t = new C(configs);\n    this.interateNodeStack(function (instance) {\n      t.addToStack(instance.clone());\n    });\n    t.recalculate();\n    t.visible = this.visible;\n    return t;\n  },\n  getBoundingDimension: function getBoundingDimension() {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  },\n  getBoundingRect: function getBoundingRect() {\n    var anchor = this.anchor;\n    var w = this.width / 2;\n    var h = this.height / 2;\n    var ltx = anchor[0] - w;\n    var lty = anchor[1] - h;\n    var rbx = anchor[0] + w;\n    var rby = anchor[1] + h;\n    var br = this._boundingrect;\n    br[0] = ltx;\n    br[1] = lty;\n    br[2] = rbx;\n    br[3] = rby;\n    return br;\n  },\n  getIntersectionsInFourDimension: function getIntersectionsInFourDimension() {\n    var _ref;\n    var p2 = this.anchor;\n    if (this._belongs && this._belongs.calculateToCoordination) {\n      p2 = this._belongs.calculateToCoordination(p2);\n    }\n    var _p = p2,\n      _p2 = groupFactory_slicedToArray(_p, 2),\n      x2 = _p2[0],\n      y2 = _p2[1];\n    var w = this.width / 2;\n    var h = this.height / 2;\n    return _ref = {}, groupFactory_defineProperty(_ref, DIRECTION.RIGHT, [x2 + w, y2]), groupFactory_defineProperty(_ref, DIRECTION.LEFT, [x2 - w, y2]), groupFactory_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + h]), groupFactory_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - h]), groupFactory_defineProperty(_ref, DIRECTION.SELF, [x2 + w * 0.618, y2 + h * 0.618]), _ref;\n  },\n  calculateIntersection: function calculateIntersection(point) {\n    var _point4 = groupFactory_slicedToArray(point, 2),\n      x1 = _point4[0],\n      y1 = _point4[1];\n    var _this$anchor = groupFactory_slicedToArray(this.anchor, 2),\n      x2 = _this$anchor[0],\n      y2 = _this$anchor[1];\n    var w = this.width / 2;\n    var h = this.height / 2;\n    var vecx = x2 - x1;\n    var vecy = y2 - y1;\n    var theta1 = h / w;\n    var theta2 = Math.abs(vecy / vecx);\n    var dirx = x1 > x2;\n    var diry = y1 > y2;\n    var x, y;\n    if (theta2 < theta1) {\n      x = x2 + (dirx ? w : -w);\n      y = w * (diry ? theta2 : -theta2) + y2;\n    } else {\n      y = y2 + (diry ? h : -h);\n      x = h / (dirx ? theta2 : -theta2) + x2;\n    }\n    return [x, y];\n  },\n  onEnterViewbox: function onEnterViewbox() {\n    this.interateNodeStack(function (instance) {\n      instance.onEnterViewbox();\n    });\n  },\n  onLeaveViewbox: function onLeaveViewbox() {\n    this.interateNodeStack(function (instance) {\n      instance.onLeaveViewbox();\n    });\n  },\n  destroy: function destroy() {\n    this._shape.destroy();\n    this.interateNodeStack(function (instance) {\n      instance.destroy();\n    });\n  },\n  doRecalculate: function doRecalculate() {\n    if (this.__mounted__) {\n      this.recalculateUp();\n    } else {\n      this.recalculate();\n      this.__mounted__ = true;\n    }\n  }\n});\nfunction defaultShift(width, height) {\n  return [width, height];\n}\n\n/**\n * 根据paddingbox宽高来计算shapeshiftbox的宽高\n * @function shapeShift\n * @param {number} width            - paddingBox宽\n * @param {number} height           - paddingBox高\n * @return {number[]}\n */\n\n/**\n * 组工厂函数，用于通过JFlow 绘图节点来创建不同的组\n * @global \n * @function GroupFactory\n * @param {Node} jflowNodeConstructor - 绘图节点构造器\n * @param {object} options            - 配置项\n * @param {shapeShift} options.shapeShift - shift层适配方法\n * @return {Group} - 绘图节点构造器\n */\nfunction GroupFactory(jflowNodeConstructor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var shapeShift = typeof options.shapeShift === \'function\' ? options.shapeShift : defaultShift;\n\n  /**\n   * Group 配置\n   * @typedef {Object} GroupTemplate~GroupConfigs\n   * @property {number} width             - 设定宽度\n   * @property {number} minWidth          - 最小宽度\n   * @property {number} height            - 设定高度\n   * @property {number} padding          - 内边距\n   * @property {number} paddingTop          - 内上边距\n   * @property {number} paddingRight         - 内右边距\n   * @property {number} paddingBottom        - 内下边距\n   * @property {number} paddingLeft          - 内左边距\n   * @property {number} margin            - 外边距\n   * @property {number} marginTop          - 外上边距\n   * @property {number} marginRight         - 外右边距\n   * @property {number} marginBottom        - 外下边距\n   * @property {number} marginLeft          - 外左边距\n   * @property {boolean} lock            - 布局锁定状态 默认 true\n   */\n  var t = /*#__PURE__*/function (_Node) {\n    groupFactory_inherits(t, _Node);\n    var _super = groupFactory_createSuper(t);\n    /**\n    * @constructs GroupTemplate\n    * @param {GroupTemplate~GroupConfigs} configs - 组配置\n    * @mixes LayoutMixin\n    * @mixes StackMixin \n    */\n    function t(configs) {\n      var _configs$lock, _configs$transparent;\n      var _this;\n      groupFactory_classCallCheck(this, t);\n      _this = _super.call(this, configs);\n      _this.initStack(configs);\n      _this.initLayout(configs);\n      /** @member {Node}      - 壳绘图单元 */\n      _this._shape = new jflowNodeConstructor(configs);\n      _this._shape.anchor = [0, 0];\n      _this._shape._belongs = groupFactory_assertThisInitialized(_this);\n      _this._center = [0, 0];\n      _this._setPadding(configs);\n      _this._setMargin(configs);\n      /** @member {Number}      - 设定宽度 */\n      _this.definedWidth = configs.width;\n      /** @member {Number}      - 最小宽度 */\n      _this.minWidth = configs.minWidth;\n      /** @member {Number}      - 设定的高度 */\n      _this.definedHeight = configs.height;\n      /** @member {Boolean}      - 组内元素是否锁定， 默认true */\n      _this.lock = (_configs$lock = configs.lock) !== null && _configs$lock !== void 0 ? _configs$lock : true;\n      _this.display = configs.display || \'default\';\n      /** @member {Boolean}      - 组本身是否进入形状判定范围 */\n      _this.transparent = (_configs$transparent = configs.transparent) !== null && _configs$transparent !== void 0 ? _configs$transparent : false;\n      _this._getBoundingGroupRect();\n      _this.reflow();\n      _this._getBoundingGroupRect();\n      _this._cacheViewBox = [];\n      return _this;\n    }\n    return groupFactory_createClass(t);\n  }(node);\n  Object.assign(t.prototype, GroupMixin);\n  Object.assign(t.prototype, {\n    reflow: function reflow() {\n      GroupMixin.reflow.call(this);\n      var margin = this.margin;\n      var _shapeShift = shapeShift(this.width - margin.left - margin.right, this.height - margin.top - margin.bottom, this._shape),\n        _shapeShift2 = groupFactory_slicedToArray(_shapeShift, 2),\n        shapeWidth = _shapeShift2[0],\n        shapeHeight = _shapeShift2[1];\n      this._shape.width = shapeWidth;\n      this._shape.height = shapeHeight;\n    },\n    setConfig: function setConfig(configs) {\n      this._shape.setConfig(configs);\n      this._setPadding(configs);\n      this._setMargin(configs);\n      if (\'opacity\' in configs) {\n        this.opacity = configs.opacity;\n      }\n      if (configs.layout && this._layout !== configs.layout) {\n        this._layout = configs.layout;\n      }\n    },\n    _getBoundingGroupRect: function _getBoundingGroupRect() {\n      var points = this._stack.getBoundingRectPoints();\n      // content box \n      var bbox = bounding_box(points);\n\n      // padding box \n      var padding = this.padding;\n      var minWidth = this.minWidth; // - padding.left - padding.right;\n      var definedWidth = this.definedWidth; // - padding.left - padding.right;\n      var w = bbox.width + padding.left + padding.right;\n      var h = bbox.height + padding.top + padding.bottom;\n      var paddingWidth = minWidth ? Math.max(minWidth, w) : definedWidth || w;\n      var paddingHeight = this.definedHeight || h;\n      this._paddingWidth = paddingWidth;\n      this._paddingHeight = paddingHeight;\n\n      // shapeBox\n      var _shapeShift3 = shapeShift(paddingWidth, paddingHeight, this._shape),\n        _shapeShift4 = groupFactory_slicedToArray(_shapeShift3, 2),\n        shapeWidth = _shapeShift4[0],\n        shapeHeight = _shapeShift4[1];\n      this._shape.width = shapeWidth;\n      this._shape.height = shapeHeight;\n      // marginBox\n      var margin = this.margin;\n      this.width = shapeWidth + margin.left + margin.right;\n      this.height = shapeHeight + margin.top + margin.bottom;\n    },\n    _getViewBox: function _getViewBox() {\n      var belongs_vbox = this._belongs.getCacheViewBox();\n      var cacheViewBox = this._cacheViewBox;\n      this._calculatePointBackWithPoint(belongs_vbox[0], belongs_vbox[1], cacheViewBox, 0, 1);\n      this._calculatePointBackWithPoint(belongs_vbox[2], belongs_vbox[3], cacheViewBox, 2, 3);\n      return this._cacheViewBox;\n    },\n    getCacheViewBox: function getCacheViewBox() {\n      return this._cacheViewBox;\n    },\n    render: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      } else if (this.opacity !== 1) {\n        ctx.globalAlpha = this.opacity;\n      }\n      var _this$_getCenter7 = this._getCenter(),\n        _this$_getCenter8 = groupFactory_slicedToArray(_this$_getCenter7, 2),\n        cx = _this$_getCenter8[0],\n        cy = _this$_getCenter8[1];\n      this._shape.render(ctx);\n      ctx.translate(cx, cy);\n      this._stack.render(ctx);\n      // this._linkStack.render(ctx);    \n      ctx.translate(-cx, -cy);\n      ctx.restore();\n\n      // ctx.save();\n      // ctx.beginPath();\n      // ctx.arc(cx, cy, 5, 0, Math.PI*2);\n      // ctx.fillStyle = \'rgb(0,0,0)\'\n      // ctx.fill();\n      // ctx.restore();\n    },\n    isHit: function isHit(point, condition) {\n      var p = this._calculatePointBack(point);\n      this._currentp = p; // 暂存，为了后续计算别的位置\n      var target = this._stack.checkHit(p, condition);\n      if (target) return target;\n      if (!this.transparent) {\n        return this._shape.isHit(point);\n      }\n      return false;\n    }\n  });\n  return t;\n}\n/* harmony default export */ const groupFactory = (GroupFactory);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/point.js\nfunction point_typeof(obj) { "@babel/helpers - typeof"; return point_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, point_typeof(obj); }\nfunction point_defineProperty(obj, key, value) { key = point_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction point_slicedToArray(arr, i) { return point_arrayWithHoles(arr) || point_iterableToArrayLimit(arr, i) || point_unsupportedIterableToArray(arr, i) || point_nonIterableRest(); }\nfunction point_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction point_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return point_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return point_arrayLikeToArray(o, minLen); }\nfunction point_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction point_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction point_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction point_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction point_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, point_toPropertyKey(descriptor.key), descriptor); } }\nfunction point_createClass(Constructor, protoProps, staticProps) { if (protoProps) point_defineProperties(Constructor.prototype, protoProps); if (staticProps) point_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction point_toPropertyKey(arg) { var key = point_toPrimitive(arg, "string"); return point_typeof(key) === "symbol" ? key : String(key); }\nfunction point_toPrimitive(input, hint) { if (point_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (point_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction point_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) point_setPrototypeOf(subClass, superClass); }\nfunction point_setPrototypeOf(o, p) { point_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return point_setPrototypeOf(o, p); }\nfunction point_createSuper(Derived) { var hasNativeReflectConstruct = point_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = point_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = point_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return point_possibleConstructorReturn(this, result); }; }\nfunction point_possibleConstructorReturn(self, call) { if (call && (point_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return point_assertThisInitialized(self); }\nfunction point_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction point_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction point_getPrototypeOf(o) { point_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return point_getPrototypeOf(o); }\n\n\n/**\n * 圆形单元 配置\n * @typedef {Node~Configs} Point~PointConfigs\n * @property {number} radius  - 半径\n */\n/**\n * 圆形节点\n * @constructor Point\n * @extends Node\n * @param {Point~PointConfigs} configs - 配置\n */\nvar Point = /*#__PURE__*/function (_Node) {\n  point_inherits(Point, _Node);\n  var _super = point_createSuper(Point);\n  function Point(configs) {\n    var _this;\n    point_classCallCheck(this, Point);\n    _this = _super.call(this, configs);\n    _this.type = \'Point\';\n    /** @member {Number}      - 半径 */\n    _this.radius = configs.radius || 10;\n    _this._doCache();\n    return _this;\n  }\n  point_createClass(Point, [{\n    key: "setConfig",\n    value: function setConfig(configs) {\n      var _this2 = this;\n      Object.keys(configs).forEach(function (k) {\n        if (configs[k] !== undefined && configs[k] !== null) {\n          _this2[k] = configs[k];\n          _this2._rawConfigs[k] = configs[k];\n        }\n      });\n      this._doCache();\n    }\n  }, {\n    key: "_doCache",\n    value: function _doCache() {\n      this.width = this.radius * 2;\n      this.height = this.radius * 2;\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      ctx.beginPath();\n      ctx.arc(this.anchor[0], this.anchor[1], this.radius, 0, 2 * Math.PI);\n      ctx.fillStyle = this.backgroundColor;\n      ctx.fill();\n      if (this.borderWidth) {\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeStyle = this.borderColor;\n        ctx.stroke();\n      }\n      // if(this._isTargeting) {\n      //     this.renderFocus(ctx);\n      // }\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      var anchor = this.anchor;\n      return Math.pow(point[0] - anchor[0], 2) + Math.pow(point[1] - anchor[1], 2) < this.radius * this.radius;\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var r = this.radius;\n      var ltx = anchor[0] - r;\n      var lty = anchor[1] - r;\n      var rbx = anchor[0] + r;\n      var rby = anchor[1] + r;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }, {\n    key: "calculateIntersection",\n    value: function calculateIntersection(point) {\n      var _point = point_slicedToArray(point, 2),\n        x1 = _point[0],\n        y1 = _point[1];\n      var _this$anchor = point_slicedToArray(this.anchor, 2),\n        x2 = _this$anchor[0],\n        y2 = _this$anchor[1];\n      var vecx = x2 - x1;\n      var vecy = y2 - y1;\n      var dist = Math.sqrt(vecx * vecx + vecy * vecy);\n      var ratio = this.radius / dist;\n      return [x2 - ratio * vecx, y2 - ratio * vecy];\n    }\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      var _ref;\n      var _this$anchor2 = point_slicedToArray(this.anchor, 2),\n        x2 = _this$anchor2[0],\n        y2 = _this$anchor2[1];\n      var r = this.radius;\n      return _ref = {}, point_defineProperty(_ref, DIRECTION.RIGHT, [x2 + r, y2]), point_defineProperty(_ref, DIRECTION.LEFT, [x2 - r, y2]), point_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + r]), point_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - r]), _ref;\n    }\n  }, {\n    key: "calculateIntersectionInFourDimension",\n    value: function calculateIntersectionInFourDimension(point, end) {\n      var _allIntersections;\n      var _point2 = point_slicedToArray(point, 2),\n        x1 = _point2[0],\n        y1 = _point2[1];\n      var _this$anchor3 = point_slicedToArray(this.anchor, 2),\n        x2 = _this$anchor3[0],\n        y2 = _this$anchor3[1];\n      var r = this.radius;\n      var vecx = x2 - x1;\n      var vecy = y2 - y1;\n      var allIntersections = (_allIntersections = {}, point_defineProperty(_allIntersections, DIRECTION.RIGHT, [x2 + r, y2]), point_defineProperty(_allIntersections, DIRECTION.LEFT, [x2 - r, y2]), point_defineProperty(_allIntersections, DIRECTION.BOTTOM, [x2, y2 + r]), point_defineProperty(_allIntersections, DIRECTION.TOP, [x2, y2 - r]), _allIntersections);\n      // console.log(Math.abs(vecx) > Math.abs(vecy), vecx, r)\n      // if() {\n      //     return {\n      //         p: [x2 + (vecx<0?r:-r), y2],\n      //         dir: vecx<0 ? DIRECTION.RIGHT : DIRECTION.LEFT,\n      //     }\n      // } else {\n      //     return {\n      //         p: [x2, y2+(vecy<0?r:-r)],\n      //         dir: vecy<0 ? DIRECTION.BOTTOM : DIRECTION.TOP,\n      //     }\n      // }\n      var interDir = Math.abs(vecy) > Math.abs(vecx) ? vecy < 0 ? DIRECTION.BOTTOM : DIRECTION.TOP : vecx < 0 ? DIRECTION.RIGHT : DIRECTION.LEFT;\n\n      // interDir = this.checkLinked(interDir, end);\n      return {\n        p: allIntersections[interDir],\n        dir: interDir\n      };\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        width: this.width,\n        height: this.height\n      };\n    }\n  }]);\n  return Point;\n}(node);\n/* harmony default export */ const point = (Point);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/rectangle.js\nfunction rectangle_typeof(obj) { "@babel/helpers - typeof"; return rectangle_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, rectangle_typeof(obj); }\nfunction rectangle_defineProperty(obj, key, value) { key = rectangle_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction rectangle_slicedToArray(arr, i) { return rectangle_arrayWithHoles(arr) || rectangle_iterableToArrayLimit(arr, i) || rectangle_unsupportedIterableToArray(arr, i) || rectangle_nonIterableRest(); }\nfunction rectangle_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction rectangle_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return rectangle_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return rectangle_arrayLikeToArray(o, minLen); }\nfunction rectangle_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction rectangle_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction rectangle_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction rectangle_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction rectangle_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, rectangle_toPropertyKey(descriptor.key), descriptor); } }\nfunction rectangle_createClass(Constructor, protoProps, staticProps) { if (protoProps) rectangle_defineProperties(Constructor.prototype, protoProps); if (staticProps) rectangle_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction rectangle_toPropertyKey(arg) { var key = rectangle_toPrimitive(arg, "string"); return rectangle_typeof(key) === "symbol" ? key : String(key); }\nfunction rectangle_toPrimitive(input, hint) { if (rectangle_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (rectangle_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction rectangle_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) rectangle_setPrototypeOf(subClass, superClass); }\nfunction rectangle_setPrototypeOf(o, p) { rectangle_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rectangle_setPrototypeOf(o, p); }\nfunction rectangle_createSuper(Derived) { var hasNativeReflectConstruct = rectangle_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rectangle_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rectangle_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rectangle_possibleConstructorReturn(this, result); }; }\nfunction rectangle_possibleConstructorReturn(self, call) { if (call && (rectangle_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return rectangle_assertThisInitialized(self); }\nfunction rectangle_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction rectangle_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction rectangle_getPrototypeOf(o) { rectangle_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rectangle_getPrototypeOf(o); }\n\n\n/**\n * @typedef Rectangle~border\n * @type {object}\n * @property {number} borderColor      - 边框宽度, 默认 0\n * @property {number} borderWidth      - 边框颜色, 默认 transparent\n */\n/**\n * @typedef Rectangle~borders\n * @type {object}\n * @property {Rectangle~border} top      - 上边框\n * @property {Rectangle~border} right      - 右边框\n * @property {Rectangle~border} bottom      - 下边框\n * @property {Rectangle~border} left      - 左边框\n */\n\n/**\n * 矩形单元 配置\n * @typedef {Node~Configs} Rectangle~RectangleConfigs\n * @property {number} width - 宽\n * @property {number} height - 高\n * @property {number} borderRadius - 圆角矩形半径\n * @property {string} borderColor - 边框颜色, 默认 transparent\n * @property {string} borderWidth - 边框宽度, 默认 0\n * @property {Rectangle~borders} border      - 边框设置\n */\n/**\n * 矩形单元\n * @constructor Rectangle\n * @extends Node\n * @param {Rectangle~RectangleConfigs} configs\n */\nvar Rectangle = /*#__PURE__*/function (_Node) {\n  rectangle_inherits(Rectangle, _Node);\n  var _super = rectangle_createSuper(Rectangle);\n  function Rectangle() {\n    var _this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    rectangle_classCallCheck(this, Rectangle);\n    _this = _super.call(this, configs);\n    _this.type = \'Rectangle\';\n    /** @member {Number}      - 宽 */\n    _this.width = configs.width || 10;\n    /** @member {Number}      - 高 */\n    _this.height = configs.height || 10;\n    /** @member {Number}      - 圆角矩形半径 */\n    _this.borderRadius = configs.borderRadius || 0;\n    _this._setBorder(configs);\n    return _this;\n  }\n  rectangle_createClass(Rectangle, [{\n    key: "_setBorder",\n    value: function _setBorder(configs) {\n      var _configs$border, _configs$border2, _configs$border3, _configs$border4, _configs$border5, _configs$border6, _configs$border7, _configs$border8, _configs$border9, _configs$border10, _configs$border11, _configs$border12;\n      /** @member {Rectangle~borders}      - 边框设置，优先级高于 borderWidth，borderColor */\n      this.border = {\n        top: {\n          color: ((_configs$border = configs.border) === null || _configs$border === void 0 || (_configs$border = _configs$border.top) === null || _configs$border === void 0 ? void 0 : _configs$border.borderColor) || configs.borderColor || \'transparent\',\n          width: ((_configs$border2 = configs.border) === null || _configs$border2 === void 0 || (_configs$border2 = _configs$border2.top) === null || _configs$border2 === void 0 ? void 0 : _configs$border2.borderWidth) || configs.borderWidth || 0,\n          enable: (_configs$border3 = configs.border) === null || _configs$border3 === void 0 || (_configs$border3 = _configs$border3.top) === null || _configs$border3 === void 0 ? void 0 : _configs$border3.borderWidth\n        },\n        right: {\n          color: ((_configs$border4 = configs.border) === null || _configs$border4 === void 0 || (_configs$border4 = _configs$border4.right) === null || _configs$border4 === void 0 ? void 0 : _configs$border4.borderColor) || configs.borderColor || \'transparent\',\n          width: ((_configs$border5 = configs.border) === null || _configs$border5 === void 0 || (_configs$border5 = _configs$border5.right) === null || _configs$border5 === void 0 ? void 0 : _configs$border5.borderWidth) || configs.borderWidth || 0,\n          enable: (_configs$border6 = configs.border) === null || _configs$border6 === void 0 || (_configs$border6 = _configs$border6.right) === null || _configs$border6 === void 0 ? void 0 : _configs$border6.borderWidth\n        },\n        bottom: {\n          color: ((_configs$border7 = configs.border) === null || _configs$border7 === void 0 || (_configs$border7 = _configs$border7.bottom) === null || _configs$border7 === void 0 ? void 0 : _configs$border7.borderColor) || configs.borderColor || \'transparent\',\n          width: ((_configs$border8 = configs.border) === null || _configs$border8 === void 0 || (_configs$border8 = _configs$border8.bottom) === null || _configs$border8 === void 0 ? void 0 : _configs$border8.borderWidth) || configs.borderWidth || 0,\n          enable: (_configs$border9 = configs.border) === null || _configs$border9 === void 0 || (_configs$border9 = _configs$border9.bottom) === null || _configs$border9 === void 0 ? void 0 : _configs$border9.borderWidth\n        },\n        left: {\n          color: ((_configs$border10 = configs.border) === null || _configs$border10 === void 0 || (_configs$border10 = _configs$border10.left) === null || _configs$border10 === void 0 ? void 0 : _configs$border10.borderColor) || configs.borderColor || \'transparent\',\n          width: ((_configs$border11 = configs.border) === null || _configs$border11 === void 0 || (_configs$border11 = _configs$border11.left) === null || _configs$border11 === void 0 ? void 0 : _configs$border11.borderWidth) || configs.borderWidth || 0,\n          enable: (_configs$border12 = configs.border) === null || _configs$border12 === void 0 || (_configs$border12 = _configs$border12.left) === null || _configs$border12 === void 0 ? void 0 : _configs$border12.borderWidth\n        }\n      };\n      this.borderColor = configs.borderColor || \'transparent\';\n      this.borderWidth = configs.borderWidth || 0;\n    }\n  }, {\n    key: "setConfig",\n    value: function setConfig(configs) {\n      var _this2 = this;\n      Object.keys(configs).forEach(function (k) {\n        if (configs[k] !== undefined && configs[k] !== null) {\n          _this2[k] = configs[k];\n          _this2._rawConfigs[k] = configs[k];\n        }\n      });\n      this._setBorder(configs);\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      var radius = this.borderRadius,\n        anchor = this.anchor,\n        width = this.width,\n        height = this.height;\n      var x = this.anchor[0] - this.width / 2;\n      var y = this.anchor[1] - this.height / 2;\n      var xt = this.anchor[0] + this.width / 2;\n      var yt = this.anchor[1] + this.height / 2;\n      if (this.borderRadius) {\n        ctx.beginPath();\n        ctx.moveTo(x + radius, y);\n        ctx.lineTo(x + width - radius, y);\n        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n        ctx.lineTo(x + width, y + height - radius);\n        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n        ctx.lineTo(x + radius, y + height);\n        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n        ctx.lineTo(x, y + radius);\n        ctx.quadraticCurveTo(x, y, x + radius, y);\n        ctx.closePath();\n      } else {\n        ctx.beginPath();\n        ctx.rect(this.anchor[0] - this.width / 2, this.anchor[1] - this.height / 2, this.width, this.height);\n      }\n      if (this.borderWidth) {\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeStyle = this.borderColor;\n      }\n      if (this.shadowColor && this.shadowColor !== \'transparent\') {\n        ctx.shadowColor = this.shadowColor;\n        var scale = this._jflow.scale;\n        ctx.shadowBlur = this.shadowBlur * scale;\n        ctx.shadowOffsetX = this.shadowOffsetX * scale;\n        ctx.shadowOffsetY = this.shadowOffsetY * scale;\n        var switchPath = new Path2D();\n        if (this.borderRadius) {\n          switchPath.moveTo(x + radius, y);\n          switchPath.lineTo(x + width - radius, y);\n          switchPath.quadraticCurveTo(x + width, y, x + width, y + radius);\n          switchPath.lineTo(x + width, y + height - radius);\n          switchPath.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n          switchPath.lineTo(x + radius, y + height);\n          switchPath.quadraticCurveTo(x, y + height, x, y + height - radius);\n          switchPath.lineTo(x, y + radius);\n          switchPath.quadraticCurveTo(x, y, x + radius, y);\n          switchPath.closePath();\n        } else {\n          switchPath.rect(this.anchor[0] - this.width / 2, this.anchor[1] - this.height / 2, this.width, this.height);\n        }\n        switchPath.rect(x - 10, y - 10, this.width + 20, this.height + 20);\n        ctx.save();\n        ctx.clip(switchPath, "evenodd");\n        ctx.stroke();\n        ctx.restore();\n      }\n      ctx.fillStyle = this.backgroundColor;\n      ctx.fill();\n      if (this.borderRadius && this.borderWidth) {\n        ctx.shadowColor = \'transparent\';\n        ctx.stroke();\n      }\n      if (this.borderRadius) {\n        if (this.border.top.enable) {\n          var ty = y - this.border.top.width / 2;\n          // console.log(this.border.top.width)\n          ctx.beginPath();\n          var topPath = new Path2D();\n          topPath.moveTo(x, ty + radius);\n          topPath.quadraticCurveTo(x, ty, x + radius, ty);\n          topPath.lineTo(x + width - radius, ty);\n          topPath.quadraticCurveTo(x + width, ty, x + width, ty + radius);\n          topPath.closePath();\n          ctx.clip(topPath);\n          ctx.save();\n          ctx.shadowColor = \'transparent\';\n          ctx.fillStyle = this.border.top.color;\n          ctx.rect(x, ty, this.width, this.border.top.width);\n          ctx.fill();\n          ctx.restore();\n\n          // ctx.stroke();\n          // ctx.save();\n          // ctx.beginPath();\n          // ctx.moveTo(x, ty + radius);\n          // ctx.quadraticCurveTo(x, ty, x + radius, ty);\n          // ctx.lineTo(x + width - radius, ty);\n          // ctx.quadraticCurveTo(x + width, ty, x + width, ty + radius);\n          // ctx.closePath();\n\n          // // ctx.fill();\n          // ctx.clip();\n\n          // ctx.beginPath();\n          // ctx.rect(x, ty, this.width, this.border.top.width);\n          // ctx.fillStyle = this.border.top.color;\n          // ctx.shadowColor = \'transparent\';\n          // ctx.fill();\n          // ctx.restore();\n        }\n      } else {\n        if (this.border.top.width) {\n          ctx.beginPath();\n          ctx.moveTo(x, y);\n          ctx.lineTo(xt, y);\n          ctx.strokeStyle = this.border.top.color;\n          ctx.lineWidth = this.border.top.width;\n          ctx.stroke();\n        }\n        if (this.border.right.width) {\n          ctx.beginPath();\n          ctx.moveTo(xt, y);\n          ctx.lineTo(xt, yt);\n          ctx.strokeStyle = this.border.right.color;\n          ctx.lineWidth = this.border.right.width;\n          ctx.stroke();\n        }\n        if (this.border.bottom.width) {\n          ctx.beginPath();\n          ctx.moveTo(xt, yt);\n          ctx.lineTo(x, yt);\n          ctx.strokeStyle = this.border.bottom.color;\n          ctx.lineWidth = this.border.bottom.width;\n          ctx.stroke();\n        }\n        if (this.border.left.width) {\n          ctx.beginPath();\n          ctx.moveTo(x, yt);\n          ctx.lineTo(x, y);\n          ctx.strokeStyle = this.border.left.color;\n          ctx.lineWidth = this.border.left.width;\n          ctx.stroke();\n        }\n      }\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      return point[0] > anchor[0] - w && point[0] < anchor[0] + w && point[1] > anchor[1] - h && point[1] < anchor[1] + h;\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var ltx = anchor[0] - w;\n      var lty = anchor[1] - h;\n      var rbx = anchor[0] + w;\n      var rby = anchor[1] + h;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        height: this.height,\n        width: this.width\n      };\n    }\n  }, {\n    key: "calculateIntersection",\n    value: function calculateIntersection(point) {\n      var _point = rectangle_slicedToArray(point, 2),\n        x1 = _point[0],\n        y1 = _point[1];\n      var _this$anchor = rectangle_slicedToArray(this.anchor, 2),\n        x2 = _this$anchor[0],\n        y2 = _this$anchor[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var vecx = x2 - x1;\n      var vecy = y2 - y1;\n      var theta1 = h / w;\n      var theta2 = Math.abs(vecy / vecx);\n      var dirx = x1 > x2;\n      var diry = y1 > y2;\n      var x, y;\n      if (theta2 < theta1) {\n        x = x2 + (dirx ? w : -w);\n        y = w * (diry ? theta2 : -theta2) + y2;\n      } else {\n        y = y2 + (diry ? h : -h);\n        x = h / (dirx ? theta2 : -theta2) + x2;\n      }\n      return [x, y];\n    }\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      var _ref;\n      var p2 = this.anchor;\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        p2 = this._belongs.calculateToCoordination(p2);\n      }\n      var _p = p2,\n        _p2 = rectangle_slicedToArray(_p, 2),\n        x2 = _p2[0],\n        y2 = _p2[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      return _ref = {}, rectangle_defineProperty(_ref, DIRECTION.RIGHT, [x2 + w, y2]), rectangle_defineProperty(_ref, DIRECTION.LEFT, [x2 - w, y2]), rectangle_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + h]), rectangle_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - h]), _ref;\n    }\n  }, {\n    key: "calculateIntersectionInFourDimension",\n    value: function calculateIntersectionInFourDimension(point, end) {\n      var _allIntersections;\n      var _point2 = rectangle_slicedToArray(point, 2),\n        x1 = _point2[0],\n        y1 = _point2[1];\n      var p2 = this.anchor;\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        p2 = this._belongs.calculateToCoordination(p2);\n      }\n      var _p3 = p2,\n        _p4 = rectangle_slicedToArray(_p3, 2),\n        x2 = _p4[0],\n        y2 = _p4[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var allIntersections = (_allIntersections = {}, rectangle_defineProperty(_allIntersections, DIRECTION.RIGHT, [x2 + w, y2]), rectangle_defineProperty(_allIntersections, DIRECTION.LEFT, [x2 - w, y2]), rectangle_defineProperty(_allIntersections, DIRECTION.BOTTOM, [x2, y2 + h]), rectangle_defineProperty(_allIntersections, DIRECTION.TOP, [x2, y2 - h]), _allIntersections);\n      var vecx = x2 - x1;\n      var vecy = y2 - y1;\n      var theta1 = h / w;\n      var theta2 = Math.abs(vecy / vecx);\n      var dirx = x1 > x2;\n      var diry = y1 > y2;\n      var interDir = theta2 > theta1 ? diry ? DIRECTION.BOTTOM : DIRECTION.TOP : dirx ? DIRECTION.RIGHT : DIRECTION.LEFT;\n\n      // if(this._belongs && this._belongs.calculateToCoordination) {\n      //     console.log(JSON.stringify(this._intersections));\n      //     console.log(interDir)\n      // }\n      // interDir = this.checkLinked(interDir, end);\n      // if(this._belongs && this._belongs.calculateToCoordination) {\n      //     console.log(interDir)\n      // }\n\n      // if(!interDir) {\n      //     debugger\n      // }\n      // let endDir = interDir;\n      // if(end === \'to\') {\n      //     endDir = oppositeDirection(endDir)\n      // }\n      return {\n        p: allIntersections[interDir],\n        dir: interDir\n      };\n    }\n  }]);\n  return Rectangle;\n}(node);\n/* harmony default export */ const rectangle = (Rectangle);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/capsule.js\nfunction capsule_typeof(obj) { "@babel/helpers - typeof"; return capsule_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, capsule_typeof(obj); }\nfunction capsule_defineProperty(obj, key, value) { key = capsule_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction capsule_slicedToArray(arr, i) { return capsule_arrayWithHoles(arr) || capsule_iterableToArrayLimit(arr, i) || capsule_unsupportedIterableToArray(arr, i) || capsule_nonIterableRest(); }\nfunction capsule_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction capsule_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return capsule_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return capsule_arrayLikeToArray(o, minLen); }\nfunction capsule_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction capsule_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction capsule_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction capsule_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction capsule_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, capsule_toPropertyKey(descriptor.key), descriptor); } }\nfunction capsule_createClass(Constructor, protoProps, staticProps) { if (protoProps) capsule_defineProperties(Constructor.prototype, protoProps); if (staticProps) capsule_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction capsule_toPropertyKey(arg) { var key = capsule_toPrimitive(arg, "string"); return capsule_typeof(key) === "symbol" ? key : String(key); }\nfunction capsule_toPrimitive(input, hint) { if (capsule_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (capsule_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction capsule_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) capsule_setPrototypeOf(subClass, superClass); }\nfunction capsule_setPrototypeOf(o, p) { capsule_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return capsule_setPrototypeOf(o, p); }\nfunction capsule_createSuper(Derived) { var hasNativeReflectConstruct = capsule_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = capsule_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = capsule_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return capsule_possibleConstructorReturn(this, result); }; }\nfunction capsule_possibleConstructorReturn(self, call) { if (call && (capsule_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return capsule_assertThisInitialized(self); }\nfunction capsule_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction capsule_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction capsule_getPrototypeOf(o) { capsule_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return capsule_getPrototypeOf(o); }\n\n\n/**\n * 胶囊单元 配置\n * @typedef {Node~Configs} Capsule~CapsuleConfigs\n * @property {number} width  - 内部矩形宽\n * @property {number} height - 内部矩形高\n */\n/**\n * 胶囊单元\n * @constructor Capsule\n * @extends Node\n * @param {Capsule~CapsuleConfigs} configs - 配置\n */\nvar Capsule = /*#__PURE__*/function (_Node) {\n  capsule_inherits(Capsule, _Node);\n  var _super = capsule_createSuper(Capsule);\n  function Capsule() {\n    var _this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    capsule_classCallCheck(this, Capsule);\n    _this = _super.call(this, configs);\n    _this.type = \'Capsule\';\n    /** @member {Number}      - 内部矩形宽 */\n    _this.width = configs.width || 20;\n    /** @member {Number}      - 内部矩形高 */\n    _this.height = configs.height || 10;\n    return _this;\n  }\n  capsule_createClass(Capsule, [{\n    key: "render",\n    value: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      ctx.beginPath();\n      var _this$anchor = capsule_slicedToArray(this.anchor, 2),\n        x = _this$anchor[0],\n        y = _this$anchor[1];\n      var hw = this.width / 2;\n      var hh = this.height / 2;\n      var leftCenter = x - hw + hh;\n      var rightCenter = x + hw - hh;\n      var top = y - hh;\n      var bottom = y + hh;\n      ctx.moveTo(leftCenter, top);\n      ctx.lineTo(rightCenter, top);\n      ctx.arc(rightCenter, y, hh, -Math.PI / 2, Math.PI / 2);\n      ctx.lineTo(leftCenter, bottom);\n      ctx.arc(leftCenter, y, hh, Math.PI / 2, Math.PI / 2 * 3);\n      ctx.fillStyle = this.backgroundColor;\n      if (this.shadowColor) {\n        ctx.shadowColor = this.shadowColor;\n        ctx.shadowBlur = this.shadowBlur;\n        ctx.shadowOffsetX = this.shadowOffsetX;\n        ctx.shadowOffsetY = this.shadowOffsetY;\n      }\n      ctx.fill();\n      if (this.borderWidth) {\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeStyle = this.borderColor;\n        ctx.stroke();\n      }\n      // ctx.fillStyle = \'rgba(0,0,0,0.3)\';\n      // ctx.fillRect(x-hw, y-hh, this.width, this.height)\n\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      var anchor = this.anchor;\n      var hw = this.width / 2;\n      var hh = this.height / 2;\n      var ww = Math.abs(hw - hh);\n      var leftCenter = anchor[0] - hw + hh;\n      var rightCenter = anchor[0] + hw - hh;\n      var rr = hh * hh;\n      return point[0] > anchor[0] - ww && point[0] < anchor[0] + ww && point[1] > anchor[1] - hh && point[1] < anchor[1] + hh || Math.pow(point[0] - leftCenter, 2) + Math.pow(point[1] - anchor[1], 2) < rr || Math.pow(point[0] - rightCenter, 2) + Math.pow(point[1] - anchor[1], 2) < rr;\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var ltx = anchor[0] - w;\n      var lty = anchor[1] - h;\n      var rbx = anchor[0] + w;\n      var rby = anchor[1] + h;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        height: this.height,\n        width: this.width\n      };\n    }\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      var _ref;\n      var p2 = this.anchor;\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        p2 = this._belongs.calculateToCoordination(p2);\n      }\n      var _p = p2,\n        _p2 = capsule_slicedToArray(_p, 2),\n        x2 = _p2[0],\n        y2 = _p2[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      return _ref = {}, capsule_defineProperty(_ref, DIRECTION.RIGHT, [x2 + w, y2]), capsule_defineProperty(_ref, DIRECTION.LEFT, [x2 - w, y2]), capsule_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + h]), capsule_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - h]), _ref;\n    }\n  }]);\n  return Capsule;\n}(node);\n/* harmony default export */ const capsule = (Capsule);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/capsule-vertical.js\nfunction capsule_vertical_typeof(obj) { "@babel/helpers - typeof"; return capsule_vertical_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, capsule_vertical_typeof(obj); }\nfunction capsule_vertical_slicedToArray(arr, i) { return capsule_vertical_arrayWithHoles(arr) || capsule_vertical_iterableToArrayLimit(arr, i) || capsule_vertical_unsupportedIterableToArray(arr, i) || capsule_vertical_nonIterableRest(); }\nfunction capsule_vertical_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction capsule_vertical_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return capsule_vertical_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return capsule_vertical_arrayLikeToArray(o, minLen); }\nfunction capsule_vertical_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction capsule_vertical_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction capsule_vertical_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction capsule_vertical_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction capsule_vertical_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, capsule_vertical_toPropertyKey(descriptor.key), descriptor); } }\nfunction capsule_vertical_createClass(Constructor, protoProps, staticProps) { if (protoProps) capsule_vertical_defineProperties(Constructor.prototype, protoProps); if (staticProps) capsule_vertical_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction capsule_vertical_toPropertyKey(arg) { var key = capsule_vertical_toPrimitive(arg, "string"); return capsule_vertical_typeof(key) === "symbol" ? key : String(key); }\nfunction capsule_vertical_toPrimitive(input, hint) { if (capsule_vertical_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (capsule_vertical_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction capsule_vertical_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) capsule_vertical_setPrototypeOf(subClass, superClass); }\nfunction capsule_vertical_setPrototypeOf(o, p) { capsule_vertical_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return capsule_vertical_setPrototypeOf(o, p); }\nfunction capsule_vertical_createSuper(Derived) { var hasNativeReflectConstruct = capsule_vertical_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = capsule_vertical_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = capsule_vertical_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return capsule_vertical_possibleConstructorReturn(this, result); }; }\nfunction capsule_vertical_possibleConstructorReturn(self, call) { if (call && (capsule_vertical_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return capsule_vertical_assertThisInitialized(self); }\nfunction capsule_vertical_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction capsule_vertical_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction capsule_vertical_getPrototypeOf(o) { capsule_vertical_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return capsule_vertical_getPrototypeOf(o); }\n\n/**\n * 垂直胶囊单元\n * @constructor CapsuleVertical\n * @extends Capsule\n * @param {Capsule~CapsuleConfigs} configs - 配置\n */\nvar CapsuleVertical = /*#__PURE__*/function (_Capsule) {\n  capsule_vertical_inherits(CapsuleVertical, _Capsule);\n  var _super = capsule_vertical_createSuper(CapsuleVertical);\n  function CapsuleVertical() {\n    capsule_vertical_classCallCheck(this, CapsuleVertical);\n    return _super.apply(this, arguments);\n  }\n  capsule_vertical_createClass(CapsuleVertical, [{\n    key: "render",\n    value: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      ctx.beginPath();\n      var _this$anchor = capsule_vertical_slicedToArray(this.anchor, 2),\n        x = _this$anchor[0],\n        y = _this$anchor[1];\n      var hw = this.width / 2;\n      var hh = this.height / 2;\n      var topCenter = y - hh + hw;\n      var bottomCenter = y + hh - hw;\n      var left = x - hw;\n      var right = x + hw;\n      ctx.moveTo(left, topCenter);\n      ctx.arc(x, topCenter, hw, -Math.PI, 0);\n      ctx.lineTo(right, bottomCenter);\n      ctx.arc(x, bottomCenter, hw, 0, Math.PI);\n      ctx.closePath();\n      ctx.fillStyle = this.backgroundColor;\n      if (this.shadowColor) {\n        ctx.shadowColor = this.shadowColor;\n        ctx.shadowBlur = this.shadowBlur;\n        ctx.shadowOffsetX = this.shadowOffsetX;\n        ctx.shadowOffsetY = this.shadowOffsetY;\n      }\n      ctx.fill();\n      if (this.borderWidth) {\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeStyle = this.borderColor;\n        ctx.stroke();\n      }\n      // ctx.fillStyle = \'rgba(0,0,0,0.3)\';\n      // ctx.fillRect(x-hw, y-hh, this.width, this.height)\n\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point, condition) {\n      var _this$anchor2 = capsule_vertical_slicedToArray(this.anchor, 2),\n        x = _this$anchor2[0],\n        y = _this$anchor2[1];\n      var hw = this.width / 2;\n      var hh = this.height / 2;\n      var yy = Math.abs(hh - hw);\n      var topCenter = y - hh + hw;\n      var bottomCenter = y + hh - hw;\n      var rr = hw * hw;\n      return point[0] > x - hw && point[0] < x + hw && point[1] > y - yy && point[1] < y + yy || Math.pow(point[0] - x, 2) + Math.pow(point[1] - topCenter, 2) < rr || Math.pow(point[0] - x, 2) + Math.pow(point[1] - bottomCenter, 2) < rr;\n    }\n  }]);\n  return CapsuleVertical;\n}(capsule);\n/* harmony default export */ const capsule_vertical = (CapsuleVertical);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/rhombus.js\nfunction rhombus_typeof(obj) { "@babel/helpers - typeof"; return rhombus_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, rhombus_typeof(obj); }\nfunction rhombus_defineProperty(obj, key, value) { key = rhombus_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction rhombus_slicedToArray(arr, i) { return rhombus_arrayWithHoles(arr) || rhombus_iterableToArrayLimit(arr, i) || rhombus_unsupportedIterableToArray(arr, i) || rhombus_nonIterableRest(); }\nfunction rhombus_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction rhombus_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return rhombus_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return rhombus_arrayLikeToArray(o, minLen); }\nfunction rhombus_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction rhombus_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction rhombus_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction rhombus_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction rhombus_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, rhombus_toPropertyKey(descriptor.key), descriptor); } }\nfunction rhombus_createClass(Constructor, protoProps, staticProps) { if (protoProps) rhombus_defineProperties(Constructor.prototype, protoProps); if (staticProps) rhombus_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction rhombus_toPropertyKey(arg) { var key = rhombus_toPrimitive(arg, "string"); return rhombus_typeof(key) === "symbol" ? key : String(key); }\nfunction rhombus_toPrimitive(input, hint) { if (rhombus_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (rhombus_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction rhombus_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) rhombus_setPrototypeOf(subClass, superClass); }\nfunction rhombus_setPrototypeOf(o, p) { rhombus_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rhombus_setPrototypeOf(o, p); }\nfunction rhombus_createSuper(Derived) { var hasNativeReflectConstruct = rhombus_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rhombus_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rhombus_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rhombus_possibleConstructorReturn(this, result); }; }\nfunction rhombus_possibleConstructorReturn(self, call) { if (call && (rhombus_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return rhombus_assertThisInitialized(self); }\nfunction rhombus_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction rhombus_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction rhombus_getPrototypeOf(o) { rhombus_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rhombus_getPrototypeOf(o); }\n\n\n/**\n * 菱形单元 配置\n * @typedef {Node~Configs} Rhombus~RhombusConfigs\n * @property {number} diagonalsV  - 内十字高度\n * @property {number} diagonalsH  - 内十字宽度\n */\n/**\n * 菱形单元\n * @constructor Rhombus\n * @param {Rhombus~RhombusConfigs} configs - 配置\n * @extends Node\n */\nvar Rhombus = /*#__PURE__*/function (_Node) {\n  rhombus_inherits(Rhombus, _Node);\n  var _super = rhombus_createSuper(Rhombus);\n  function Rhombus() {\n    var _this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    rhombus_classCallCheck(this, Rhombus);\n    _this = _super.call(this, configs);\n    _this.type = \'Rhombus\';\n    /** @member {Number}      - 内十字高度 */\n    _this.height = configs.diagonalsV || 10;\n    /** @member {Number}      - 内十字宽度 */\n    _this.width = configs.diagonalsH || 20;\n    return _this;\n  }\n  rhombus_createClass(Rhombus, [{\n    key: "render",\n    value: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var center = this.anchor;\n      ctx.translate(center[0], center[1]);\n      ctx.beginPath();\n      ctx.moveTo(0, -h);\n      ctx.lineTo(w, 0);\n      ctx.lineTo(0, h);\n      ctx.lineTo(-w, 0);\n      ctx.closePath();\n      if (this.borderWidth) {\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeStyle = this.borderColor;\n      }\n      if (this.shadowColor) {\n        ctx.shadowColor = this.shadowColor;\n        var scale = this._jflow.scale;\n        ctx.shadowBlur = this.shadowBlur * scale;\n        ctx.shadowOffsetX = this.shadowOffsetX * scale;\n        ctx.shadowOffsetY = this.shadowOffsetY * scale;\n        var switchPath = new Path2D();\n        switchPath.moveTo(0, -h);\n        switchPath.lineTo(w, 0);\n        switchPath.lineTo(0, h);\n        switchPath.lineTo(-w, 0);\n        switchPath.closePath();\n        switchPath.rect(-w - 10, -h - 10, this.width + 20, this.height + 20);\n        // switchPath.moveTo(x, y-h);\n        // switchPath.lineTo(x + w, y);\n        // switchPath.lineTo(x, y + h);\n        // switchPath.lineTo(x-w, y);\n        // switchPath.closePath();\n        // switchPath.rect(x - w - 10, y - h - 10, this.width+ 20, this.height+ 20);\n        ctx.save();\n        ctx.clip(switchPath, "evenodd");\n        ctx.stroke();\n        ctx.restore();\n      }\n      ctx.fillStyle = this.backgroundColor;\n      ctx.fill();\n      if (this.borderWidth) {\n        ctx.shadowColor = \'transparent\';\n        ctx.stroke();\n      }\n      ctx.translate(-center[0], -center[1]);\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      var v = this.height / 2;\n      var h = this.width / 2;\n      var anchor = this.anchor;\n      var x = Math.abs(point[0] - anchor[0]);\n      var y = Math.abs(point[1] - anchor[1]);\n      return x / h + y / v <= 1;\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var ltx = anchor[0] - w;\n      var lty = anchor[1] - h;\n      var rbx = anchor[0] + w;\n      var rby = anchor[1] + h;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        height: this.height,\n        width: this.width\n      };\n    }\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      var _ref;\n      var p2 = this.anchor;\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        p2 = this._belongs.calculateToCoordination(p2);\n      }\n      var _p = p2,\n        _p2 = rhombus_slicedToArray(_p, 2),\n        x2 = _p2[0],\n        y2 = _p2[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      return _ref = {}, rhombus_defineProperty(_ref, DIRECTION.RIGHT, [x2 + w, y2]), rhombus_defineProperty(_ref, DIRECTION.LEFT, [x2 - w, y2]), rhombus_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + h]), rhombus_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - h]), rhombus_defineProperty(_ref, DIRECTION.SELF, [x2 + w * 0.618, y2 + h * 0.618]), _ref;\n    }\n  }]);\n  return Rhombus;\n}(node);\n/* harmony default export */ const rhombus = (Rhombus);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/diamond.js\nfunction diamond_typeof(obj) { "@babel/helpers - typeof"; return diamond_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, diamond_typeof(obj); }\nfunction diamond_defineProperty(obj, key, value) { key = diamond_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction diamond_slicedToArray(arr, i) { return diamond_arrayWithHoles(arr) || diamond_iterableToArrayLimit(arr, i) || diamond_unsupportedIterableToArray(arr, i) || diamond_nonIterableRest(); }\nfunction diamond_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction diamond_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return diamond_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return diamond_arrayLikeToArray(o, minLen); }\nfunction diamond_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction diamond_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction diamond_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction diamond_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction diamond_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, diamond_toPropertyKey(descriptor.key), descriptor); } }\nfunction diamond_createClass(Constructor, protoProps, staticProps) { if (protoProps) diamond_defineProperties(Constructor.prototype, protoProps); if (staticProps) diamond_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction diamond_toPropertyKey(arg) { var key = diamond_toPrimitive(arg, "string"); return diamond_typeof(key) === "symbol" ? key : String(key); }\nfunction diamond_toPrimitive(input, hint) { if (diamond_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (diamond_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction diamond_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) diamond_setPrototypeOf(subClass, superClass); }\nfunction diamond_setPrototypeOf(o, p) { diamond_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return diamond_setPrototypeOf(o, p); }\nfunction diamond_createSuper(Derived) { var hasNativeReflectConstruct = diamond_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = diamond_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = diamond_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return diamond_possibleConstructorReturn(this, result); }; }\nfunction diamond_possibleConstructorReturn(self, call) { if (call && (diamond_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return diamond_assertThisInitialized(self); }\nfunction diamond_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction diamond_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction diamond_getPrototypeOf(o) { diamond_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return diamond_getPrototypeOf(o); }\n\n\n// import { makeBezierPoints } from \'../../utils/functions\';\n/**\n * 钻石形单元 配置\n * @typedef {Node~Configs} Diamond~DiamondConfigs\n * @property {number} width  - 内部矩形宽\n * @property {number} height - 内部矩形高\n * @property {number} side   - 两侧三角形的宽\n */\n/**\n * 钻石形单元\n * @constructor Diamond\n * @param {Diamond~DiamondConfigs} configs - 配置\n * @extends Node\n */\nvar Diamond = /*#__PURE__*/function (_Node) {\n  diamond_inherits(Diamond, _Node);\n  var _super = diamond_createSuper(Diamond);\n  function Diamond() {\n    var _this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    diamond_classCallCheck(this, Diamond);\n    _this = _super.call(this, configs);\n    _this.type = \'Diamond\';\n    /** @member {Number}      - 内部矩形宽 */\n    _this.width = configs.width || 20;\n    /** @member {Number}      - 内部矩形高 */\n    _this.height = configs.height || 10;\n    /** @member {Number}      - 两侧三角形的宽 */\n    _this.side = configs.side || 6;\n    _this._doCache();\n    return _this;\n  }\n  diamond_createClass(Diamond, [{\n    key: "setConfig",\n    value: function setConfig(configs) {\n      var _this2 = this;\n      Object.keys(configs).forEach(function (k) {\n        if (configs[k] !== undefined && configs[k] !== null) {\n          _this2[k] = configs[k];\n          _this2._rawConfigs[k] = configs[k];\n        }\n      });\n      this._doCache();\n    }\n  }, {\n    key: "_doCache",\n    value: function _doCache() {\n      this.sinSIDE = Math.sin(Math.PI / 3) * this.side;\n      this.cosSIDE = Math.cos(Math.PI / 3) * this.side;\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      var _this$anchor = diamond_slicedToArray(this.anchor, 2),\n        x = _this$anchor[0],\n        y = _this$anchor[1];\n      var hw = this.width / 2;\n      var hh = this.height / 2;\n      var xx = hh / 1.732;\n      var leftCenter = x - hw + xx;\n      var rightCenter = x + hw - xx;\n      var right = x + hw;\n      var left = x - hw;\n      var top = y - hh;\n      var bottom = y + hh;\n      this._cachePoints = [[rightCenter, top], [right, y], [rightCenter, bottom], [leftCenter, bottom], [left, y], [leftCenter, top]];\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      ctx.beginPath();\n      var side = this.side,\n        sinSIDE = this.sinSIDE,\n        cosSIDE = this.cosSIDE;\n      ctx.moveTo(x, top);\n      ctx.lineTo(rightCenter - side, top);\n      ctx.quadraticCurveTo(rightCenter, top, rightCenter + cosSIDE, top + sinSIDE);\n      ctx.lineTo(right - cosSIDE, y - sinSIDE);\n      ctx.quadraticCurveTo(right, y, right - cosSIDE, y + sinSIDE);\n      ctx.lineTo(rightCenter + cosSIDE, bottom - sinSIDE);\n      ctx.quadraticCurveTo(rightCenter, bottom, rightCenter - side, bottom);\n      ctx.lineTo(leftCenter + side, bottom);\n      ctx.quadraticCurveTo(leftCenter, bottom, leftCenter - cosSIDE, bottom - sinSIDE);\n      ctx.lineTo(left + cosSIDE, y + sinSIDE);\n      ctx.quadraticCurveTo(left, y, left + cosSIDE, y - sinSIDE);\n      ctx.lineTo(leftCenter - cosSIDE, top + sinSIDE);\n      ctx.quadraticCurveTo(leftCenter, top, leftCenter + side, top);\n      ctx.closePath();\n      ctx.fillStyle = this.backgroundColor;\n      if (this.shadowColor) {\n        ctx.shadowColor = this.shadowColor;\n        ctx.shadowBlur = this.shadowBlur;\n        ctx.shadowOffsetX = this.shadowOffsetX;\n        ctx.shadowOffsetY = this.shadowOffsetY;\n      }\n      ctx.fill();\n      if (this.borderWidth) {\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeStyle = this.borderColor;\n        ctx.stroke();\n      }\n\n      // if(this._isTargeting) {\n      //     this.renderFocus(ctx);\n      // }\n      // ctx.fillStyle = \'rgba(0,0,0,0.3)\';\n      // ctx.fillRect(x-hw, y-hh, this.width, this.height)\n\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      if (!this._cachePoints) return false;\n      var polygon = this._cachePoints;\n      var odd = false;\n      // For each edge (In this case for each point of the polygon and the previous one)\n      for (var i = 0, j = polygon.length - 1; i < polygon.length; i++) {\n        // If a line from the point into infinity crosses this edge\n        if (polygon[i][1] > point[1] !== polygon[j][1] > point[1] // One point needs to be above, one below our y coordinate\n        // ...and the edge doesn\'t cross our Y corrdinate before our x coordinate (but between our x coordinate and infinity)\n        && point[0] < (polygon[j][0] - polygon[i][0]) * (point[1] - polygon[i][1]) / (polygon[j][1] - polygon[i][1]) + polygon[i][0]) {\n          // Invert odd\n          odd = !odd;\n        }\n        j = i;\n      }\n      return odd;\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var ltx = anchor[0] - w;\n      var lty = anchor[1] - h;\n      var rbx = anchor[0] + w;\n      var rby = anchor[1] + h;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        height: this.height,\n        width: this.width\n      };\n    }\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      var _ref;\n      var p2 = this.anchor;\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        p2 = this._belongs.calculateToCoordination(p2);\n      }\n      var _p = p2,\n        _p2 = diamond_slicedToArray(_p, 2),\n        x2 = _p2[0],\n        y2 = _p2[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      return _ref = {}, diamond_defineProperty(_ref, DIRECTION.RIGHT, [x2 + w, y2]), diamond_defineProperty(_ref, DIRECTION.LEFT, [x2 - w, y2]), diamond_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + h]), diamond_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - h]), _ref;\n    }\n  }]);\n  return Diamond;\n}(node);\n/* harmony default export */ const diamond = (Diamond);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/diamond-vertical.js\nfunction diamond_vertical_typeof(obj) { "@babel/helpers - typeof"; return diamond_vertical_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, diamond_vertical_typeof(obj); }\nfunction diamond_vertical_slicedToArray(arr, i) { return diamond_vertical_arrayWithHoles(arr) || diamond_vertical_iterableToArrayLimit(arr, i) || diamond_vertical_unsupportedIterableToArray(arr, i) || diamond_vertical_nonIterableRest(); }\nfunction diamond_vertical_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction diamond_vertical_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return diamond_vertical_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return diamond_vertical_arrayLikeToArray(o, minLen); }\nfunction diamond_vertical_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction diamond_vertical_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction diamond_vertical_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction diamond_vertical_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction diamond_vertical_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, diamond_vertical_toPropertyKey(descriptor.key), descriptor); } }\nfunction diamond_vertical_createClass(Constructor, protoProps, staticProps) { if (protoProps) diamond_vertical_defineProperties(Constructor.prototype, protoProps); if (staticProps) diamond_vertical_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction diamond_vertical_toPropertyKey(arg) { var key = diamond_vertical_toPrimitive(arg, "string"); return diamond_vertical_typeof(key) === "symbol" ? key : String(key); }\nfunction diamond_vertical_toPrimitive(input, hint) { if (diamond_vertical_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (diamond_vertical_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction diamond_vertical_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) diamond_vertical_setPrototypeOf(subClass, superClass); }\nfunction diamond_vertical_setPrototypeOf(o, p) { diamond_vertical_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return diamond_vertical_setPrototypeOf(o, p); }\nfunction diamond_vertical_createSuper(Derived) { var hasNativeReflectConstruct = diamond_vertical_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = diamond_vertical_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = diamond_vertical_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return diamond_vertical_possibleConstructorReturn(this, result); }; }\nfunction diamond_vertical_possibleConstructorReturn(self, call) { if (call && (diamond_vertical_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return diamond_vertical_assertThisInitialized(self); }\nfunction diamond_vertical_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction diamond_vertical_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction diamond_vertical_getPrototypeOf(o) { diamond_vertical_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return diamond_vertical_getPrototypeOf(o); }\n\nvar backsqrt3 = 1 / Math.sqrt(3);\n\n/**\n * 垂直钻石形单元\n * @constructor DiamondVertical\n * @param {Diamond~DiamondConfigs} configs - 配置\n * @extends Diamond\n */\nvar DiamondVertical = /*#__PURE__*/function (_Diamond) {\n  diamond_vertical_inherits(DiamondVertical, _Diamond);\n  var _super = diamond_vertical_createSuper(DiamondVertical);\n  function DiamondVertical(configs) {\n    diamond_vertical_classCallCheck(this, DiamondVertical);\n    return _super.call(this, configs);\n  }\n  diamond_vertical_createClass(DiamondVertical, [{\n    key: "render",\n    value: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      ctx.beginPath();\n      var _this$anchor = diamond_vertical_slicedToArray(this.anchor, 2),\n        x = _this$anchor[0],\n        y = _this$anchor[1];\n      var hw = this.width / 2;\n      var hh = this.height / 2;\n      var yy = hw / 1.732;\n      var top = y - hh;\n      var bottom = y + hh;\n      var topmiddle = y - hh + yy;\n      var bottommiddle = y + hh - yy;\n      var xleft = x - hw;\n      var xright = x + hw;\n      ctx.moveTo(x, top);\n      ctx.lineTo(xright, topmiddle);\n      ctx.lineTo(xright, bottommiddle);\n      ctx.lineTo(x, bottom);\n      ctx.lineTo(xleft, bottommiddle);\n      ctx.lineTo(xleft, topmiddle);\n      ctx.closePath();\n      ctx.fillStyle = this.backgroundColor;\n      if (this.shadowColor) {\n        ctx.shadowColor = this.shadowColor;\n        ctx.shadowBlur = this.shadowBlur;\n        ctx.shadowOffsetX = this.shadowOffsetX;\n        ctx.shadowOffsetY = this.shadowOffsetY;\n      }\n      ctx.fill();\n      if (this.borderWidth) {\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeStyle = this.borderColor;\n        ctx.stroke();\n      }\n      ctx.restore();\n      this._cachePoints = [[x, top], [xright, topmiddle], [xright, bottommiddle], [x, bottom], [xleft, bottommiddle], [xleft, topmiddle]];\n    }\n  }]);\n  return DiamondVertical;\n}(diamond);\n/* harmony default export */ const diamond_vertical = (DiamondVertical);\n;// CONCATENATED MODULE: ./src/core/instance/groups/scroll-group.js\nfunction scroll_group_typeof(obj) { "@babel/helpers - typeof"; return scroll_group_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, scroll_group_typeof(obj); }\nfunction scroll_group_defineProperty(obj, key, value) { key = scroll_group_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction scroll_group_slicedToArray(arr, i) { return scroll_group_arrayWithHoles(arr) || scroll_group_iterableToArrayLimit(arr, i) || scroll_group_unsupportedIterableToArray(arr, i) || scroll_group_nonIterableRest(); }\nfunction scroll_group_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction scroll_group_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return scroll_group_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return scroll_group_arrayLikeToArray(o, minLen); }\nfunction scroll_group_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction scroll_group_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction scroll_group_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction scroll_group_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction scroll_group_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, scroll_group_toPropertyKey(descriptor.key), descriptor); } }\nfunction scroll_group_createClass(Constructor, protoProps, staticProps) { if (protoProps) scroll_group_defineProperties(Constructor.prototype, protoProps); if (staticProps) scroll_group_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction scroll_group_toPropertyKey(arg) { var key = scroll_group_toPrimitive(arg, "string"); return scroll_group_typeof(key) === "symbol" ? key : String(key); }\nfunction scroll_group_toPrimitive(input, hint) { if (scroll_group_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (scroll_group_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction scroll_group_get() { if (typeof Reflect !== "undefined" && Reflect.get) { scroll_group_get = Reflect.get.bind(); } else { scroll_group_get = function _get(target, property, receiver) { var base = scroll_group_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return scroll_group_get.apply(this, arguments); }\nfunction scroll_group_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = scroll_group_getPrototypeOf(object); if (object === null) break; } return object; }\nfunction scroll_group_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) scroll_group_setPrototypeOf(subClass, superClass); }\nfunction scroll_group_setPrototypeOf(o, p) { scroll_group_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return scroll_group_setPrototypeOf(o, p); }\nfunction scroll_group_createSuper(Derived) { var hasNativeReflectConstruct = scroll_group_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = scroll_group_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = scroll_group_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return scroll_group_possibleConstructorReturn(this, result); }; }\nfunction scroll_group_possibleConstructorReturn(self, call) { if (call && (scroll_group_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return scroll_group_assertThisInitialized(self); }\nfunction scroll_group_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction scroll_group_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction scroll_group_getPrototypeOf(o) { scroll_group_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return scroll_group_getPrototypeOf(o); }\n\n\n\n\n\n\n\nvar scroll_group_ishitKey = Symbol(\'ishit\');\nvar InnerScrollBar = /*#__PURE__*/function (_ScrollBar) {\n  scroll_group_inherits(InnerScrollBar, _ScrollBar);\n  var _super = scroll_group_createSuper(InnerScrollBar);\n  function InnerScrollBar(dir) {\n    var _this;\n    var configs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    scroll_group_classCallCheck(this, InnerScrollBar);\n    _this = _super.call(this, dir, configs);\n    _this.visible = false;\n    return _this;\n  }\n  scroll_group_createClass(InnerScrollBar, [{\n    key: "render",\n    value: function render(ctx) {\n      if (this.visible) {\n        scroll_group_get(scroll_group_getPrototypeOf(InnerScrollBar.prototype), "render", this).call(this, ctx);\n      }\n    }\n  }, {\n    key: "setHit",\n    value: function setHit(ishit) {\n      if (this[scroll_group_ishitKey] !== ishit) {\n        this.isFocus = ishit;\n        this.onHit();\n      }\n      this[scroll_group_ishitKey] = ishit;\n    }\n  }]);\n  return InnerScrollBar;\n}(ScrollBar);\nvar ScrollGroup = /*#__PURE__*/function (_Node) {\n  scroll_group_inherits(ScrollGroup, _Node);\n  var _super2 = scroll_group_createSuper(ScrollGroup);\n  function ScrollGroup(configs) {\n    var _configs$lock;\n    var _this2;\n    scroll_group_classCallCheck(this, ScrollGroup);\n    _this2 = _super2.call(this, configs);\n    _this2.type = \'ScrollGroup\';\n    _this2.initStack(configs);\n    _this2.initLayout(configs);\n    _this2.initScrollBar(configs);\n    _this2._shape = new rectangle(configs);\n    _this2._shape.anchor = [0, 0];\n    _this2._shape._belongs = scroll_group_assertThisInitialized(_this2);\n    _this2.maxWidth = configs.maxWidth || Infinity;\n    _this2.definedWidth = configs.definedWidth;\n    _this2.maxHeight = configs.maxHeight || Infinity;\n    _this2.definedHeight = configs.definedHeight;\n    _this2.lock = (_configs$lock = configs.lock) !== null && _configs$lock !== void 0 ? _configs$lock : true;\n    _this2._offset = [0, 0];\n    _this2._getBoundingGroupRect();\n    _this2.reflow();\n    _this2._getBoundingGroupRect();\n    _this2._resetOffset();\n    _this2._cacheViewBox = [];\n    return _this2;\n  }\n  scroll_group_createClass(ScrollGroup, [{\n    key: "initScrollBar",\n    value: function initScrollBar(configs) {\n      var _this3 = this;\n      var barColor = configs.barColor,\n        barFocusColor = configs.barFocusColor,\n        barMarginX = configs.barMarginX,\n        barMarginY = configs.barMarginY,\n        barWidth = configs.barWidth;\n      this._scrollbarX = new InnerScrollBar(\'x\', {\n        plainColor: barColor,\n        focusColor: barFocusColor,\n        barWidth: barWidth\n      });\n      this._scrollbarY = new InnerScrollBar(\'y\', {\n        plainColor: barColor,\n        focusColor: barFocusColor,\n        barWidth: barWidth\n      });\n      this._scrollbarX.barMarginX = barMarginX || 1;\n      this._scrollbarY.barMarginY = barMarginY || 1;\n      var _f = function _f() {\n        _this3._jflow.scheduleRender();\n      };\n      this._scrollbarX.onHit = _f;\n      this._scrollbarY.onHit = _f;\n      this._scrollBarStatus = {\n        dragging: false,\n        target: null,\n        barInitX: 0,\n        barInitY: 0,\n        barStartX: 0,\n        barStartY: 0,\n        hitScrollX: false,\n        hitScrollY: false\n      };\n      // // const jflowInstance = this._jflow;\n      // this.addEventListener(\'instancemousemove\', e => {\n      //     if(this._scrollBarStatus.hitScrollX) {\n      //         if(!this._scrollbarX.isFocus) {\n      //             this._scrollbarX.isFocus = true;\n      //             e.detail.jflow.scheduleRender();\n      //         }\n      //         return;\n      //     }\n      //     if(this._scrollbarX.isFocus) {\n      //         this._scrollbarX.isFocus = false;\n      //         e.detail.jflow.scheduleRender();\n      //     }\n\n      // })\n      this.addEventListener(\'instancePressStart\', function (e) {\n        if (_this3._scrollBarStatus.hitScrollX) {\n          e.detail.preventDefault();\n          e.detail.bubbles = false;\n          var clientX = e.detail.event.clientX;\n          Object.assign(_this3._scrollBarStatus, {\n            dragging: true,\n            target: _this3._scrollbarX,\n            barStartX: _this3._scrollbarX.anchor[0],\n            barInitX: clientX\n          });\n          _this3.onScrollbarPressStart();\n        }\n        if (_this3._scrollBarStatus.hitScrollY) {\n          e.detail.preventDefault();\n          e.detail.bubbles = false;\n          var clientY = e.detail.event.clientY;\n          Object.assign(_this3._scrollBarStatus, {\n            dragging: true,\n            target: _this3._scrollbarY,\n            barStartY: _this3._scrollbarY.anchor[1],\n            barInitY: clientY\n          });\n          _this3.onScrollbarPressStart();\n        }\n      });\n    }\n  }, {\n    key: "onScrollbarPressStart",\n    value: function onScrollbarPressStart() {\n      var _this4 = this;\n      var jflowInstance = this._jflow;\n      var canvas = jflowInstance.canvas;\n      var f = function (e) {\n        var clientX = e.clientX,\n          clientY = e.clientY;\n        _this4.onDraggingScrollbar(clientX, clientY);\n      }.bind(this);\n      document.addEventListener(\'pointermove\', f);\n      var t = function (e) {\n        Object.assign(_this4._scrollBarStatus, {\n          dragging: false,\n          target: null,\n          barInitX: 0,\n          barInitY: 0,\n          barStartX: 0,\n          barStartY: 0,\n          hitScrollX: false,\n          hitScrollY: false\n        });\n        document.removeEventListener(\'pointermove\', f);\n        document.removeEventListener(\'pointerup\', t);\n        canvas.removeEventListener(\'pointerup\', t);\n      }.bind(this);\n      canvas.addEventListener(\'pointerup\', t, {\n        once: true\n      });\n      document.addEventListener(\'pointerup\', t, {\n        once: true\n      });\n    }\n  }, {\n    key: "onDraggingScrollbar",\n    value: function onDraggingScrollbar(clientX, clientY) {\n      if (this._scrollbarX.visible && this._scrollBarStatus.dragging) {\n        var JFLOW = this._jflow;\n        var scale = JFLOW.scale;\n        var _this$_scrollBarStatu = this._scrollBarStatus,\n          target = _this$_scrollBarStatu.target,\n          barInitX = _this$_scrollBarStatu.barInitX,\n          barStartX = _this$_scrollBarStatu.barStartX,\n          barInitY = _this$_scrollBarStatu.barInitY,\n          barStartY = _this$_scrollBarStatu.barStartY;\n        if (target.dir === \'x\') {\n          var _scrollWidth = this._scrollbarX.width;\n          var _outerWidth = this._outerWidth;\n          var deltaX = clientX - barInitX;\n          var xnew = barStartX + deltaX / scale;\n          var q = target.anchor[0] = Math.max(Math.min(xnew, _outerWidth - _scrollWidth), 0);\n          var ratioInX = q / (_outerWidth - _scrollWidth);\n          var s = (this._innerWidth - _outerWidth) / 2;\n          this._offset[0] = s - (this._innerWidth - _outerWidth) * ratioInX;\n          JFLOW.scheduleRender();\n        }\n        if (target.dir === \'y\') {\n          var _scrollHeight = this._scrollbarY.height;\n          var _outerHeight = this._outerHeight;\n          var deltaY = clientY - barInitY;\n          var ynew = barStartY + deltaY / scale;\n          var _q = target.anchor[1] = Math.max(Math.min(ynew, _outerHeight - _scrollHeight), 0);\n          var ratio = _q / (_outerHeight - _scrollHeight);\n          var _s = (this._innerHeight - _outerHeight) / 2;\n          this._offset[1] = _s - (this._innerHeight - _outerHeight) * ratio;\n          JFLOW.scheduleRender();\n        }\n      }\n    }\n  }, {\n    key: "setConfig",\n    value: function setConfig(configs) {\n      this._shape.setConfig(configs);\n    }\n  }, {\n    key: "_getBoundingGroupRect",\n    value: function _getBoundingGroupRect() {\n      var points = this._stack.getBoundingRectPoints();\n      // content box \n      var bbox = bounding_box(points);\n      var w = bbox.width;\n      var h = bbox.height;\n      var outerWidth = this.definedWidth || Math.min(w, this.maxWidth);\n      var outerHeight = this.definedHeight || Math.min(h, this.maxHeight);\n      this._innerWidth = w;\n      this._outerWidth = outerWidth;\n      this._innerHeight = h;\n      this._outerHeight = outerHeight;\n      this._shape.width = outerWidth;\n      this._shape.height = outerHeight;\n      this.width = outerWidth;\n      this.height = outerHeight;\n    }\n  }, {\n    key: "_calculatePointBack",\n    value: function _calculatePointBack(point) {\n      var _point = scroll_group_slicedToArray(point, 2),\n        gx = _point[0],\n        gy = _point[1];\n      var _this$_offset = scroll_group_slicedToArray(this._offset, 2),\n        tx = _this$_offset[0],\n        ty = _this$_offset[1];\n      var _this$anchor = scroll_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor[0],\n        cy = _this$anchor[1];\n      var p = [gx - cx - tx, gy - cy - ty];\n      return p;\n    }\n  }, {\n    key: "_calculatePointBackWithPoint",\n    value: function _calculatePointBackWithPoint(a, b, arr, idx1, idx2) {\n      var anchor = this.anchor;\n      var offset = this._offset;\n      arr[idx1] = a - anchor[0] - offset[0];\n      arr[idx2] = b - anchor[1] - offset[1];\n    }\n  }, {\n    key: "calculateToCoordination",\n    value: function calculateToCoordination(point) {\n      var _point2 = scroll_group_slicedToArray(point, 2),\n        gx = _point2[0],\n        gy = _point2[1];\n      var _this$anchor2 = scroll_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor2[0],\n        cy = _this$anchor2[1];\n      var _this$_offset2 = scroll_group_slicedToArray(this._offset, 2),\n        tx = _this$_offset2[0],\n        ty = _this$_offset2[1];\n      var p = [gx + cx - tx, gy + cy - ty];\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        return this._belongs.calculateToCoordination(p);\n      } else {\n        return p;\n      }\n    }\n  }, {\n    key: "calculateToRealWorld",\n    value: function calculateToRealWorld(point) {\n      var _point3 = scroll_group_slicedToArray(point, 2),\n        gx = _point3[0],\n        gy = _point3[1];\n      var _this$anchor3 = scroll_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor3[0],\n        cy = _this$anchor3[1];\n      var _this$_offset3 = scroll_group_slicedToArray(this._offset, 2),\n        tx = _this$_offset3[0],\n        ty = _this$_offset3[1];\n      var p = [gx + cx - tx, gy + cy - ty];\n      if (this._belongs && this._belongs.calculateToRealWorld) {\n        return this._belongs.calculateToRealWorld(p);\n      }\n    }\n  }, {\n    key: "calculateToRealWorldWithPointer",\n    value: function calculateToRealWorldWithPointer(outpoint, inpoint) {\n      outpoint[0] = inpoint[0] + this.anchor[0] - this.offset[0];\n      outpoint[1] = inpoint[1] + this.anchor[1] - this.offset[1];\n      if (this._belongs && this._belongs.calculateToRealWorldWithPointer) {\n        return this._belongs.calculateToRealWorldWithPointer(outpoint, outpoint);\n      }\n    }\n  }, {\n    key: "_getViewBox",\n    value: function _getViewBox() {\n      var belongs_vbox = this._belongs.getCacheViewBox();\n      var cacheViewBox = this._cacheViewBox;\n      this._calculatePointBackWithPoint(belongs_vbox[0], belongs_vbox[1], cacheViewBox, 0, 1);\n      this._calculatePointBackWithPoint(belongs_vbox[2], belongs_vbox[3], cacheViewBox, 2, 3);\n      return this._cacheViewBox;\n    }\n  }, {\n    key: "getCacheViewBox",\n    value: function getCacheViewBox() {\n      return this._cacheViewBox;\n    }\n  }, {\n    key: "_resetOffset",\n    value: function _resetOffset() {\n      this._offset = [Math.max((this._innerWidth - this._outerWidth) / 2, 0), Math.max((this._innerHeight - this._outerHeight) / 2, 0)];\n      if (this._innerWidth > this._outerWidth) {\n        this._scrollbarX.visible = true;\n        this._scrollbarX.width = this._outerWidth * this._outerWidth / this._innerWidth;\n        this._scrollbarX.anchor = [0, this._outerHeight - 4];\n      } else {\n        this._scrollbarX.visible = false;\n      }\n      if (this._innerHeight > this._outerHeight) {\n        this._scrollbarY.visible = true;\n        this._scrollbarY.height = this._outerHeight * this._outerHeight / this._innerHeight;\n        this._scrollbarY.anchor = [this._outerWidth - 4, 0];\n      } else {\n        this._scrollbarY.visible = false;\n      }\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      } else if (this.opacity !== 1) {\n        ctx.globalAlpha = this.opacity;\n      }\n      var _this$anchor4 = scroll_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor4[0],\n        cy = _this$anchor4[1];\n      var w = this.width;\n      var h = this.height;\n      var w2 = w / 2;\n      var h2 = h / 2;\n      // if((this.width * this.height) * this._jflow.scale < 144) {\n      //     ctx.restore();\n      //     return;\n      // }\n      var _this$_offset4 = scroll_group_slicedToArray(this._offset, 2),\n        tx = _this$_offset4[0],\n        ty = _this$_offset4[1];\n      ctx.translate(cx, cy);\n      this._shape.render(ctx);\n      ctx.translate(-w2, -h2);\n      if (this._scrollbarX.visible) {\n        this._scrollbarX.render(ctx);\n      }\n      if (this._scrollbarY.visible) {\n        this._scrollbarY.render(ctx);\n      }\n      ctx.translate(w2, h2);\n      ctx.save();\n      ctx.beginPath();\n      ctx.rect(-w2, -h2, w, h);\n      ctx.clip();\n      ctx.translate(tx, ty);\n      this._stack.render(ctx);\n      this._linkStack.render(ctx);\n      ctx.translate(-cx - tx, -cy - ty);\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point, condition) {\n      var _point4 = scroll_group_slicedToArray(point, 2),\n        gx = _point4[0],\n        gy = _point4[1];\n      var _this$anchor5 = scroll_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor5[0],\n        cy = _this$anchor5[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var sp = [gx - cx + w, gy - cy + h];\n      this._scrollBarStatus.hitScrollX = false;\n      this._scrollBarStatus.hitScrollY = false;\n      if (this._scrollbarX.visible) {\n        var xhit = this._scrollbarX.isHit(sp);\n        if (xhit) {\n          this._scrollBarStatus.hitScrollX = true;\n          this._scrollbarX.setHit(true);\n          return true;\n        }\n      }\n      this._scrollbarX.setHit(false);\n      if (this._scrollbarY.visible) {\n        var yhit = this._scrollbarY.isHit(sp);\n        if (yhit) {\n          this._scrollBarStatus.hitScrollY = true;\n          this._scrollbarY.setHit(true);\n          return true;\n        }\n      }\n      this._scrollbarY.setHit(false);\n\n      // const br = this._getViewBox();\n      var isInBound = this._shape.isHit([gx - cx, gy - cy]);\n      if (isInBound) {\n        var _this$_offset5 = scroll_group_slicedToArray(this._offset, 2),\n          tx = _this$_offset5[0],\n          ty = _this$_offset5[1];\n        var p = [gx - cx - tx, gy - cy - ty];\n        this._currentp = p; // 暂存，为了后续计算别的位置\n        var target = this._stack.checkHit(p, condition);\n        if (target) return target;\n      } else {\n        this._stack.resetHitStatus();\n      }\n      return false;\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        width: this.width,\n        height: this.height\n      };\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var ltx = anchor[0] - w;\n      var lty = anchor[1] - h;\n      var rbx = anchor[0] + w;\n      var rby = anchor[1] + h;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      var _ref;\n      var p2 = this.anchor;\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        p2 = this._belongs.calculateToCoordination(p2);\n      }\n      var _p = p2,\n        _p2 = scroll_group_slicedToArray(_p, 2),\n        x2 = _p2[0],\n        y2 = _p2[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      return _ref = {}, scroll_group_defineProperty(_ref, DIRECTION.RIGHT, [x2 + w, y2]), scroll_group_defineProperty(_ref, DIRECTION.LEFT, [x2 - w, y2]), scroll_group_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + h]), scroll_group_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - h]), scroll_group_defineProperty(_ref, DIRECTION.SELF, [x2 + w * 0.618, y2 + h * 0.618]), _ref;\n    }\n  }, {\n    key: "onEnterViewbox",\n    value: function onEnterViewbox() {\n      this.interateNodeStack(function (instance) {\n        instance.onEnterViewbox();\n      });\n    }\n  }, {\n    key: "onLeaveViewbox",\n    value: function onLeaveViewbox() {\n      this.interateNodeStack(function (instance) {\n        instance.onLeaveViewbox();\n      });\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      this._shape.destroy();\n      this.interateNodeStack(function (instance) {\n        instance.destroy();\n      });\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      var C = this.constructor;\n      var configs = Object.assign({}, this._rawConfigs, {\n        layout: this._layout && this._layout.clone()\n      });\n      var t = new C(configs);\n      this.interateNodeStack(function (instance) {\n        t.addToStack(instance.clone());\n      });\n      t.recalculate();\n      t.visible = this.visible;\n      return t;\n    }\n  }]);\n  return ScrollGroup;\n}(node);\nObject.assign(ScrollGroup.prototype, stackMixin);\nObject.assign(ScrollGroup.prototype, layoutMixin);\nObject.assign(ScrollGroup.prototype, {\n  recalculateUp: function recalculateUp() {\n    var dirty = true;\n    if (this.getBoundingDimension) {\n      // const { width: wold, height: hold } = this.getBoundingDimension();\n      var wold = this._innerWidth;\n      var hold = this._innerHeight;\n      if (this.resetChildrenPosition) {\n        this.resetChildrenPosition();\n      }\n      if (this._getBoundingGroupRect) {\n        this._getBoundingGroupRect();\n      }\n      this.reflow();\n      if (this._getBoundingGroupRect) {\n        this._getBoundingGroupRect();\n      }\n      var wnow = this._innerWidth;\n      var hnow = this._innerHeight;\n      // const { width: wnow, height: hnow } = this.getBoundingDimension();\n      dirty = wold !== wnow || hold !== hnow;\n    } else {\n      this.reflow();\n    }\n    if (this._belongs && dirty) {\n      this._resetOffset();\n      this._belongs.recalculateUp();\n    }\n  },\n  recalculate: function recalculate() {\n    var _this$getBoundingDime = this.getBoundingDimension(),\n      wold = _this$getBoundingDime.width,\n      hold = _this$getBoundingDime.height;\n    this.reflow();\n    if (this._getBoundingGroupRect) {\n      this._getBoundingGroupRect();\n    }\n    var _this$getBoundingDime2 = this.getBoundingDimension(),\n      wnow = _this$getBoundingDime2.width,\n      hnow = _this$getBoundingDime2.height;\n    if (wold !== wnow || hold !== hnow) {\n      this._resetOffset();\n    }\n  }\n});\n/* harmony default export */ const scroll_group = (ScrollGroup);\n;// CONCATENATED MODULE: ./src/core/events/commonAdapter.js\n/* harmony default export */ const commonAdapter = ({\n  canvas: {\n    wheel: function wheel(event, jflow) {\n      event.preventDefault();\n      var offsetX = event.offsetX,\n        offsetY = event.offsetY,\n        deltaX = event.deltaX,\n        deltaY = event.deltaY;\n      if (event.ctrlKey) {\n        deltaY = -deltaY;\n      }\n      jflow.zoomHandler(offsetX, offsetY, deltaX, deltaY, event);\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/core/instance/base-link.js\nfunction base_link_typeof(obj) { "@babel/helpers - typeof"; return base_link_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, base_link_typeof(obj); }\nfunction base_link_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction base_link_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, base_link_toPropertyKey(descriptor.key), descriptor); } }\nfunction base_link_createClass(Constructor, protoProps, staticProps) { if (protoProps) base_link_defineProperties(Constructor.prototype, protoProps); if (staticProps) base_link_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction base_link_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) base_link_setPrototypeOf(subClass, superClass); }\nfunction base_link_setPrototypeOf(o, p) { base_link_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return base_link_setPrototypeOf(o, p); }\nfunction base_link_createSuper(Derived) { var hasNativeReflectConstruct = base_link_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = base_link_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = base_link_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return base_link_possibleConstructorReturn(this, result); }; }\nfunction base_link_possibleConstructorReturn(self, call) { if (call && (base_link_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return base_link_assertThisInitialized(self); }\nfunction base_link_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction base_link_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction base_link_getPrototypeOf(o) { base_link_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return base_link_getPrototypeOf(o); }\nfunction base_link_defineProperty(obj, key, value) { key = base_link_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction base_link_toPropertyKey(arg) { var key = base_link_toPrimitive(arg, "string"); return base_link_typeof(key) === "symbol" ? key : String(key); }\nfunction base_link_toPrimitive(input, hint) { if (base_link_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (base_link_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n/**\n * @typedef {Instance~Configs} BaseLink~Configs\n * @property {Instance} from   - 起始单元\n * @property {Instance} to     - 终止单元\n * @property {String} fromDir  - 起始方向 \n * @property {String} toDir    - 终止方向 \n * @property {String} key      - 连线唯一键值\n * @property {String} backgroundColor    - 线条颜色 \n */\n/**\n * 连线基类\n * @constructor BaseLink\n * @extends Instance\n * @param {BaseLink~Configs} configs - 配置\n */\nvar BaseLink = /*#__PURE__*/function (_Instance) {\n  base_link_inherits(BaseLink, _Instance);\n  var _super = base_link_createSuper(BaseLink);\n  function BaseLink() {\n    var _this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    base_link_classCallCheck(this, BaseLink);\n    _this = _super.call(this);\n    /** @member {Instance}      - 起始单元 */\n    base_link_defineProperty(base_link_assertThisInitialized(_this), "INSTANCE_TYPE", \'LINK\');\n    _this.from = configs.from;\n    /** @member {Instance}      - 终止单元 */\n    _this.to = configs.to;\n    /** @member {DIRECTION}      - 起始方向 */\n    _this.fromDir = configs.fromDir;\n    /** @member {DIRECTION}      - 终止方向 */\n    _this.toDir = configs.toDir;\n    /** @member {number[][]}     - 连线控制点缓存 */\n    _this._cachePoints = null;\n    /** @member {string}     - 连线颜色，默认为 #000 */\n    _this.backgroundColor = configs.backgroundColor || \'#000\';\n    _this.isSelf = !!configs.isSelf;\n    return _this;\n  }\n\n  /**\n   * 是否出现在当前视窗内\n   * @param {number[]} viewbox\n   */\n  base_link_createClass(BaseLink, [{\n    key: "nextSibling",\n    get: function get() {\n      var _this2 = this;\n      if (!this._belongs) {\n        return null;\n      }\n      var stack = this._belongs._linkStack;\n      var idx = stack.findIndex(function (s) {\n        return s === _this2;\n      });\n      if (idx !== -1) {\n        return stack[idx + 1];\n      }\n      return null;\n    }\n  }, {\n    key: "isInViewBox",\n    value: function isInViewBox(viewbox) {\n      return true;\n    }\n  }, {\n    key: "bringToTop",\n    value: function bringToTop() {\n      var _this3 = this;\n      var linkStack = this._jflow._linkStack;\n      var index = linkStack.findIndex(function (l) {\n        return l === _this3;\n      });\n      linkStack.splice(index, 1);\n      linkStack.push(this);\n      this._jflow._render();\n    }\n  }]);\n  return BaseLink;\n}(instance_instance);\n/* harmony default export */ const base_link = (BaseLink);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/shadow-cache.js\nfunction shadow_cache_typeof(obj) { "@babel/helpers - typeof"; return shadow_cache_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, shadow_cache_typeof(obj); }\nfunction shadow_cache_slicedToArray(arr, i) { return shadow_cache_arrayWithHoles(arr) || shadow_cache_iterableToArrayLimit(arr, i) || shadow_cache_unsupportedIterableToArray(arr, i) || shadow_cache_nonIterableRest(); }\nfunction shadow_cache_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction shadow_cache_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return shadow_cache_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return shadow_cache_arrayLikeToArray(o, minLen); }\nfunction shadow_cache_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction shadow_cache_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction shadow_cache_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction shadow_cache_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction shadow_cache_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, shadow_cache_toPropertyKey(descriptor.key), descriptor); } }\nfunction shadow_cache_createClass(Constructor, protoProps, staticProps) { if (protoProps) shadow_cache_defineProperties(Constructor.prototype, protoProps); if (staticProps) shadow_cache_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction shadow_cache_toPropertyKey(arg) { var key = shadow_cache_toPrimitive(arg, "string"); return shadow_cache_typeof(key) === "symbol" ? key : String(key); }\nfunction shadow_cache_toPrimitive(input, hint) { if (shadow_cache_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (shadow_cache_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction shadow_cache_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) shadow_cache_setPrototypeOf(subClass, superClass); }\nfunction shadow_cache_setPrototypeOf(o, p) { shadow_cache_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return shadow_cache_setPrototypeOf(o, p); }\nfunction shadow_cache_createSuper(Derived) { var hasNativeReflectConstruct = shadow_cache_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = shadow_cache_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = shadow_cache_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return shadow_cache_possibleConstructorReturn(this, result); }; }\nfunction shadow_cache_possibleConstructorReturn(self, call) { if (call && (shadow_cache_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return shadow_cache_assertThisInitialized(self); }\nfunction shadow_cache_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction shadow_cache_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction shadow_cache_getPrototypeOf(o) { shadow_cache_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return shadow_cache_getPrototypeOf(o); }\n\nvar ShadowCache = /*#__PURE__*/function (_Node) {\n  shadow_cache_inherits(ShadowCache, _Node);\n  var _super = shadow_cache_createSuper(ShadowCache);\n  function ShadowCache(configs) {\n    var _this;\n    shadow_cache_classCallCheck(this, ShadowCache);\n    _this = _super.call(this, configs);\n    // this.imageData = configs.imageData;\n    _this.width = configs.width;\n    _this.height = configs.height;\n    _this.imageBuffer = document.createElement(\'canvas\');\n    _this.imageBuffer.width = _this.width + 2;\n    _this.imageBuffer.height = _this.height + 2;\n    configs.cache(_this.imageBuffer.getContext(\'2d\'));\n    return _this;\n  }\n  shadow_cache_createClass(ShadowCache, [{\n    key: "render",\n    value: function render(ctx) {\n      var _this$anchor = shadow_cache_slicedToArray(this.anchor, 2),\n        cx = _this$anchor[0],\n        cy = _this$anchor[1];\n      ctx.save();\n      ctx.translate(cx, cy);\n      ctx.beginPath();\n      ctx.drawImage(this.imageBuffer, -this.width / 2, -this.height / 2);\n      ctx.translate(-cx, -cy);\n      ctx.restore();\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        height: this.height,\n        width: this.width\n      };\n    }\n  }, {\n    key: "recalculate",\n    value: function recalculate() {}\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var ltx = anchor[0] - w;\n      var lty = anchor[1] - h;\n      var rbx = anchor[0] + w;\n      var rby = anchor[1] + h;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }]);\n  return ShadowCache;\n}(node);\n/* harmony default export */ const shadow_cache = (ShadowCache);\n;// CONCATENATED MODULE: ./src/core/instance/elements/text.js\nfunction text_typeof(obj) { "@babel/helpers - typeof"; return text_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, text_typeof(obj); }\nfunction text_slicedToArray(arr, i) { return text_arrayWithHoles(arr) || text_iterableToArrayLimit(arr, i) || text_unsupportedIterableToArray(arr, i) || text_nonIterableRest(); }\nfunction text_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction text_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return text_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return text_arrayLikeToArray(o, minLen); }\nfunction text_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction text_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction text_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction text_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction text_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, text_toPropertyKey(descriptor.key), descriptor); } }\nfunction text_createClass(Constructor, protoProps, staticProps) { if (protoProps) text_defineProperties(Constructor.prototype, protoProps); if (staticProps) text_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction text_toPropertyKey(arg) { var key = text_toPrimitive(arg, "string"); return text_typeof(key) === "symbol" ? key : String(key); }\nfunction text_toPrimitive(input, hint) { if (text_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (text_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction text_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) text_setPrototypeOf(subClass, superClass); }\nfunction text_setPrototypeOf(o, p) { text_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return text_setPrototypeOf(o, p); }\nfunction text_createSuper(Derived) { var hasNativeReflectConstruct = text_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = text_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = text_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return text_possibleConstructorReturn(this, result); }; }\nfunction text_possibleConstructorReturn(self, call) { if (call && (text_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return text_assertThisInitialized(self); }\nfunction text_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction text_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction text_getPrototypeOf(o) { text_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return text_getPrototypeOf(o); }\n\n\n\n\nvar TEXT_ALIGN = {\n  CENTER: \'center\',\n  LEFT: \'left\',\n  RIGHT: \'right\'\n};\nvar SPACE_REG = /\\s/g;\nvar Text = /*#__PURE__*/function (_Rectangle) {\n  text_inherits(Text, _Rectangle);\n  var _super = text_createSuper(Text);\n  function Text(configs) {\n    var _this;\n    text_classCallCheck(this, Text);\n    _this = _super.call(this, configs);\n    _this.type = \'Text\';\n    _this.content = configs.content || \'\';\n    _this.fontFamily = configs.fontFamily || \'-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Tahoma,Arial,Noto Sans,PingFang SC,Microsoft YaHei,Hiragino Sans GB,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji\';\n    _this.fontSize = configs.fontSize || \'14px\';\n    _this.fontWeight = configs.fontWeight || \'\';\n    _this.textColor = configs.textColor || \'white\';\n    _this.placeholderColor = configs.placeholderColor || configs.textColor || \'white\';\n    _this.textAlign = configs.textAlign || TEXT_ALIGN.CENTER;\n    _this.textBaseline = configs.textBaseline || \'middle\';\n    _this.lineHeight = configs.lineHeight;\n    _this.indent = configs.indent || 0;\n    _this.backgroundColor = configs.backgroundColor;\n    _this.editable = configs.editable;\n    _this.definedWidth = configs.definedWidth;\n    _this.minWidth = configs.minWidth || 0;\n    _this.maxWidth = configs.maxWidth;\n    _this.ellipsis = configs.ellipsis;\n    _this.placeholder = configs.placeholder || \'\';\n    _this.emptyWhenInput = configs.emptyWhenInput || false;\n    _this.editting = false;\n    _this.disabled = configs.disabled;\n    _this.cursorColor = configs.cursorColor || \'#60CFC4\';\n    _this.textRangeColor = configs.textRangeColor || \'#4E75EC1A\';\n    _this.spacePlaceholder = configs.spacePlaceholder;\n    _this.spacePlaceholderColor = configs.spacePlaceholderColor;\n    _this.spaceRecords = [];\n    _this._spacedContentSegmnent = [];\n    _this._status = {\n      editing: false,\n      cursorshow: true,\n      cursoranime: null,\n      lastElapsed: 0,\n      refreshElapsed: false,\n      cursorDragging: false,\n      shiftOn: false,\n      oldVal: \'\',\n      inputElement: null\n    };\n    _this._cursorOffset = 0;\n    _this._textRange = {\n      enable: false,\n      rangefrom: null,\n      // offsetfrom\n      rangeTo: null,\n      // offsetto\n      initialRange: null // offset\n    };\n\n    if (_this.editable) {\n      _this._makeFunctional();\n    }\n    _this.preCalculateText();\n    _this.shadowCache();\n    return _this;\n  }\n  text_createClass(Text, [{\n    key: "replaceSpaceHolder",\n    value: function replaceSpaceHolder(content) {\n      var useCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (useCache) {\n        return content.replace(/\\s/g, this.spacePlaceholder);\n      }\n      var r = this.spaceRecords;\n      var p = this.spacePlaceholder;\n      r.length = 0;\n      var lastOffset;\n      var c = content.replace(/\\s/g, function (_, offset) {\n        if (lastOffset === undefined) {\n          lastOffset = offset;\n          r.push(offset);\n        }\n        if (offset - lastOffset > 1) {\n          r.push(lastOffset);\n          r.push(offset);\n        }\n        lastOffset = offset;\n        return p;\n      });\n      if (lastOffset !== undefined) {\n        r.push(lastOffset);\n      }\n      return c;\n    }\n  }, {\n    key: "currentContent",\n    get: function get() {\n      return this.content || this.placeholder || \'\';\n    }\n  }, {\n    key: "isEmpty",\n    get: function get() {\n      return !this.content;\n    }\n  }, {\n    key: "preCalculateText",\n    value: function preCalculateText() {\n      var _this2 = this;\n      requestCacheCanvas(function (ctx) {\n        ctx.beginPath();\n        ctx.font = "".concat(_this2.fontWeight, " ").concat(_this2.fontSize, " ").concat(_this2.fontFamily);\n        ctx.textAlign = _this2.textAlign;\n        ctx.textBaseline = _this2.textBaseline;\n        var t_h = parseInt(_this2.fontSize);\n        var content = _this2.currentContent;\n        if (_this2.spacePlaceholder) {\n          content = _this2.replaceSpaceHolder(content);\n        }\n        var _ctx$measureText = ctx.measureText(content),\n          fontBoundingBoxAscent = _ctx$measureText.fontBoundingBoxAscent,\n          fontBoundingBoxDescent = _ctx$measureText.fontBoundingBoxDescent,\n          width = _ctx$measureText.width;\n        _this2._textWidth = _this2.indent + width;\n        if (_this2.definedWidth) {\n          if (_this2.ellipsis && _this2._textWidth > _this2.definedWidth) {\n            var offset = _this2._calculateOffset(_this2.definedWidth - 12);\n            _this2.ellipsisContent = content.substring(0, offset) + \'...\';\n          } else {\n            _this2.ellipsisContent = content;\n          }\n          _this2.width = _this2.definedWidth;\n        } else if (_this2.maxWidth && _this2.ellipsis) {\n          if (_this2._textWidth > _this2.maxWidth) {\n            var ratio = _this2.maxWidth / _this2._textWidth;\n            var l = Math.floor(content.length * ratio - 3);\n            _this2.ellipsisContent = content.substring(0, l) + \'...\';\n          } else {\n            _this2.ellipsisContent = content;\n          }\n          _this2.width = Math.min(_this2.maxWidth, _this2._textWidth);\n        } else {\n          _this2.width = Math.max(_this2.minWidth, _this2._textWidth);\n        }\n        if (_this2.spacePlaceholder) {\n          var _ctx$measureText2 = ctx.measureText(_this2.spacePlaceholder),\n            s_width = _ctx$measureText2.width;\n          var r2 = _this2._spacedContentSegmnent;\n          var textColor = _this2.textColor;\n          var lastOffset = 0;\n          r2.length = 0;\n          if (_this2.spaceRecords.length) {\n            var r = _this2.spaceRecords;\n            var pcolor = _this2.spacePlaceholderColor;\n            var _l = r.length;\n            var i = 0;\n            while (i < _l) {\n              var f = r[i++];\n              var t = r[i++];\n              var q = content.substring(lastOffset, f);\n              r2.push([q, ctx.measureText(q).width, textColor]);\n              r2.push([content.substring(f, t + 1), (t - f + 1) * s_width, pcolor]);\n              lastOffset = t + 1;\n            }\n          }\n          if (lastOffset < content.length) {\n            var _q = content.substring(lastOffset);\n            r2.push([_q, ctx.measureText(_q).width, textColor]);\n          }\n        }\n        var height = Math.abs(fontBoundingBoxAscent) + Math.abs(fontBoundingBoxDescent) || t_h;\n        _this2._textHeight = height;\n        if (_this2.lineHeight) {\n          _this2.height = _this2.lineHeight;\n        } else {\n          _this2.height = height;\n        }\n      });\n    }\n  }, {\n    key: "shadowCache",\n    value: function shadowCache() {\n      var _this3 = this;\n      var scale = window.devicePixelRatio;\n      var w = this.width * scale;\n      var h = this.height * scale;\n      var i = this.indent * scale;\n      var size = parseInt(this.fontSize) * scale;\n      this._shadowCache = new shadow_cache({\n        width: w,\n        height: h,\n        cache: function cache(ctx) {\n          // const [cx, cy] = this.anchor;\n          // ctx.scale(4, 4)\n          ctx.translate(w / 2, h / 2);\n          var font = "".concat(_this3.fontWeight, " ").concat(size, "px ").concat(_this3.fontFamily);\n          ctx.font = font;\n          ctx.textAlign = _this3.textAlign;\n          ctx.textBaseline = _this3.textBaseline;\n          ctx.fillStyle = _this3.isEmpty ? _this3.placeholderColor : _this3.textColor;\n          var content = _this3.currentContent;\n          if (_this3.spacePlaceholder) {\n            if (_this3.textAlign === TEXT_ALIGN.LEFT) {\n              var hw = w / 2;\n              var _w = -hw + i / 2;\n              _this3._spacedContentSegmnent.forEach(function (seg) {\n                ctx.fillStyle = seg[2];\n                ctx.fillText(seg[0], _w, 0);\n                _w += seg[1] * scale;\n              });\n            }\n          } else {\n            if (_this3.ellipsisContent) {\n              content = _this3.ellipsisContent;\n            }\n            if (content) {\n              if (_this3.textAlign === TEXT_ALIGN.LEFT) {\n                var _hw = w / 2;\n                ctx.fillText(content, -_hw + i / 2, 0);\n              } else if (_this3.textAlign === TEXT_ALIGN.RIGHT) {\n                var _hw2 = w / 2;\n                ctx.fillText(content, _hw2, 0);\n              } else {\n                ctx.fillText(content, i / 2, 0);\n              }\n            }\n          }\n        }\n      });\n    }\n  }, {\n    key: "setConfig",\n    value: function setConfig(configs) {\n      var _this4 = this;\n      Object.keys(configs).forEach(function (k) {\n        if (configs[k] !== undefined && configs[k] !== null) {\n          _this4[k] = configs[k];\n          _this4._rawConfigs[k] = configs[k];\n        }\n      });\n      this.preCalculateText();\n      this.shadowCache();\n    }\n  }, {\n    key: "click",\n    value: function click() {\n      var _this5 = this;\n      if (!this._status.editing) {\n        var flag = true;\n        this.dispatchEvent(new events(\'edit\', {\n          target: this,\n          preventDefault: function preventDefault() {\n            flag = false;\n          }\n        }));\n        if (!flag) {\n          return;\n        }\n        var point = this._belongs._currentp;\n        var jflow = this._jflow;\n        if (point) {\n          this._cursorOffset = this._positionToCursorOffset(point);\n        } else {\n          this._cursorOffset = 0;\n        }\n        var inputElement = createInputElement(this._controlCallback.bind(this), this._defaultCallback.bind(this));\n        var wrapper = jflow.DOMwrapper;\n        wrapper.append(inputElement);\n        inputElement.focus({\n          preventScroll: true\n        });\n        jflow.setFocusInstance(this);\n        Object.assign(this._status, {\n          editing: true,\n          oldVal: this.content,\n          inputElement: inputElement,\n          cursoranime: jflow.requestJFlowAnime(function (elapsed) {\n            var lastElapsed = _this5._status.lastElapsed;\n            if (_this5._status.refreshElapsed) {\n              _this5._status.lastElapsed = elapsed;\n              _this5._status.refreshElapsed = false;\n            }\n            if (elapsed - lastElapsed > 500) {\n              _this5._status.cursorshow = !_this5._status.cursorshow;\n              _this5._status.lastElapsed = elapsed;\n            }\n          })\n        });\n        if (this.emptyWhenInput) {\n          this.content = \'\';\n        }\n        this.syncShadowInputPosition();\n      }\n    }\n  }, {\n    key: "_makeFunctional",\n    value: function _makeFunctional() {\n      var _this6 = this;\n      var blurHandler = function blurHandler(event) {\n        _this6._status.editing = false;\n        if (_this6._status.inputElement) {\n          _this6._status.inputElement.remove();\n        }\n        if (_this6._belongs) {\n          _this6._jflow.scheduleRender();\n        }\n      };\n      this.addEventListener(\'dblclick\', function (event) {\n        if (event.currentTarget !== _this6) {\n          return;\n        }\n        if (_this6._status.editing) {\n          _this6._selectFullRange();\n        }\n      });\n      this.addEventListener(\'click\', function (event) {\n        if (event.currentTarget !== _this6) {\n          return;\n        }\n        // event.detail.bubbles = false;\n        if (_this6._status.editing) {\n          var point = _this6._belongs._currentp;\n          var offset = _this6._positionToCursorOffset(point);\n          if (_this6._status.shiftOn) {\n            var initialRange = _this6._textRange.initialRange;\n            Object.assign(_this6._textRange, {\n              rangefrom: Math.min(offset, initialRange),\n              rangeTo: Math.max(offset, initialRange),\n              enable: true\n            });\n            _this6._cursorOffset = _this6._textRange.rangeTo;\n            _this6._status.inputElement.focus({\n              preventScroll: true\n            });\n            // this._refreshCursor();  \n          } else {\n            _this6._cursorOffset = offset;\n            _this6._status.inputElement.focus({\n              preventScroll: true\n            });\n            _this6._refreshCursor();\n            _this6.syncShadowInputPosition();\n          }\n        }\n        _this6.click();\n      });\n      this.addEventListener(\'blur\', function (event) {\n        var _this6$_status$cursor;\n        blurHandler(event);\n        _this6.dispatchEvent(new events(\'change\', {\n          target: _this6,\n          oldVal: _this6._status.oldVal,\n          val: _this6.content\n        }));\n        _this6._textRange.enable = false;\n        (_this6$_status$cursor = _this6._status.cursoranime) === null || _this6$_status$cursor === void 0 ? void 0 : _this6$_status$cursor.cancel();\n        Object.assign(_this6._status, {\n          editing: false,\n          cursorshow: true,\n          cursoranime: null,\n          lastElapsed: 0,\n          refreshElapsed: false,\n          cursorDragging: false,\n          shiftOn: false,\n          oldVal: \'\',\n          inputElement: null\n        });\n      });\n      this.addEventListener(\'instancePressStart\', function (event) {\n        if (_this6._status.editing && !_this6._status.shiftOn) {\n          event.detail.bubbles = false;\n          event.detail.preventDefault();\n          var point = _this6._belongs._currentp;\n          var c = _this6._positionToCursorOffset(point);\n          _this6._textRange.initialRange = c;\n          var jflow = event.detail.jflow;\n          var moved = false;\n          var t = function (e) {\n            moved = true;\n            var offsetX = e.offsetX,\n              offsetY = e.offsetY;\n            var p = jflow._calculatePointBack([offsetX, offsetY]);\n            jflow._stack.checkHit(p);\n            var point = _this6._belongs._currentp;\n            var c = _this6._positionToCursorOffset(point);\n            var initialRange = _this6._textRange.initialRange;\n            _this6._status.editing = false;\n            Object.assign(_this6._textRange, {\n              rangefrom: Math.min(c, initialRange),\n              rangeTo: Math.max(c, initialRange),\n              enable: true\n            });\n          }.bind(_this6);\n          document.addEventListener(\'pointermove\', t);\n          document.addEventListener(\'pointerup\', function (e) {\n            document.removeEventListener(\'pointermove\', t);\n            if (!moved) {\n              _this6._textRange.initialRange = null;\n              return;\n            }\n            var rangeTo = _this6._textRange.rangeTo;\n            _this6._cursorOffset = rangeTo;\n            _this6._status.editing = true;\n            _this6._status.inputElement.focus({\n              preventScroll: true\n            });\n            _this6._textRange.initialRange = null;\n          }, {\n            once: true\n          });\n        }\n      });\n    }\n  }, {\n    key: "_positionToCursorOffset",\n    value: function _positionToCursorOffset(point) {\n      var _point = text_slicedToArray(point, 1),\n        x = _point[0];\n      var w = this.width / 2;\n      var _this$anchor = text_slicedToArray(this.anchor, 1),\n        ox = _this$anchor[0];\n      var offsetX = x - (ox - w);\n      var cursorOffset = 0;\n      if (offsetX >= this._textWidth) {\n        cursorOffset = this.content.length;\n      } else {\n        cursorOffset = this._calculateOffset(offsetX);\n      }\n      return cursorOffset;\n    }\n  }, {\n    key: "_calculateOffset",\n    value: function _calculateOffset(offx) {\n      var _this7 = this;\n      var content = this.content;\n      if (this.spacePlaceholder) {\n        content = this.replaceSpaceHolder(content, true);\n      }\n      var maxL = content.length - 1;\n      var contentWidth = this._textWidth;\n      if (contentWidth === 0) {\n        return 0;\n      }\n      var allwidth = contentWidth;\n      var idx = Math.floor(offx / allwidth * maxL);\n      requestCacheCanvas(function (ctx) {\n        ctx.font = "".concat(_this7.fontSize, " ").concat(_this7.fontFamily);\n        var g1, g2;\n        var lastidx;\n        var c = content.substring(0, idx);\n        var c1 = content.substring(idx - 1, idx);\n        var c2 = content.substring(idx, idx + 1);\n        var w = ctx.measureText(c).width;\n        var w1 = ctx.measureText(c1).width;\n        var w2 = ctx.measureText(c2).width;\n        g1 = w - w1 / 2;\n        g2 = w + w2 / 2;\n        do {\n          if (g1 <= offx && g2 >= offx) {\n            break;\n          }\n          if (g1 > offx) {\n            // 左侧少了\n            var spanw = g2 - offx;\n            lastidx = idx;\n            if (spanw < 100) {\n              idx -= 1;\n            } else {\n              idx -= Math.floor(spanw / g2 * lastidx);\n            }\n            c = content.substring(idx, lastidx);\n            w -= ctx.measureText(c).width;\n          } else if (g2 < offx) {\n            // 右侧少了\n            var _spanw = offx - g1;\n            lastidx = idx;\n            if (_spanw < 100) {\n              idx += 1;\n            } else {\n              idx += Math.floor(_spanw / (allwidth - g1) * (maxL - lastidx));\n            }\n            c = content.substring(lastidx, idx);\n            w += ctx.measureText(c).width;\n          }\n          c1 = content.substring(idx - 1, idx);\n          c2 = content.substring(idx, idx + 1);\n          w1 = ctx.measureText(c1).width;\n          w2 = ctx.measureText(c2).width;\n          g1 = w - w1 / 2;\n          g2 = w + w2 / 2;\n        } while (idx >= 0 && idx <= maxL);\n      });\n      return idx;\n    }\n  }, {\n    key: "_refreshCursor",\n    value: function _refreshCursor() {\n      if (this._status.editing) {\n        Object.assign(this._status, {\n          cursorshow: true,\n          refreshElapsed: true\n        });\n      }\n      if (this._textRange.enable) {\n        this._textRange.enable = false;\n      }\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      if (!ctx.disableCache && !this._status.editing && this._jflow.scale * parseInt(this.fontSize) < 8) {\n        var _this$anchor2 = text_slicedToArray(this.anchor, 2),\n          cx = _this$anchor2[0],\n          cy = _this$anchor2[1];\n        // this._shadowCache.render(ctx);\n        ctx.save();\n        ctx.translate(cx, cy);\n        ctx.beginPath();\n        ctx.drawImage(this._shadowCache.imageBuffer, -this.width / 2, -this.height / 2, this.width, this.height);\n        ctx.translate(-cx, -cy);\n        ctx.restore();\n        return;\n      }\n      var font = "".concat(this.fontWeight, " ").concat(this.fontSize, " ").concat(this.fontFamily);\n      if (ctx.font !== font) {\n        ctx.font = font;\n      }\n      if (ctx.textAlign !== this.textAlign) {\n        ctx.textAlign = this.textAlign;\n      }\n      if (ctx.textBaseline !== this.textBaseline) {\n        ctx.textBaseline = this.textBaseline;\n      }\n      ctx.fillStyle = this.isEmpty ? this.placeholderColor : this.textColor;\n      var content = this.currentContent;\n      if (this.spacePlaceholder) {\n        if (this.textAlign === TEXT_ALIGN.LEFT) {\n          var _hw3 = this.width / 2;\n          var w = this.anchor[0] - _hw3 + this.indent / 2;\n          var _y = this.anchor[1];\n          this._spacedContentSegmnent.forEach(function (seg) {\n            ctx.fillStyle = seg[2];\n            ctx.fillText(seg[0], w, _y);\n            w += seg[1];\n          });\n        }\n      } else {\n        if (this.ellipsisContent) {\n          content = this.ellipsisContent;\n        }\n        if (content) {\n          if (this.textAlign === TEXT_ALIGN.LEFT) {\n            var _hw4 = this.width / 2;\n            ctx.fillText(content, this.anchor[0] - _hw4 + this.indent / 2, this.anchor[1]);\n          } else if (this.textAlign === TEXT_ALIGN.RIGHT) {\n            var _hw5 = this.width / 2;\n            ctx.fillText(content, this.anchor[0] + _hw5, this.anchor[1]);\n          } else {\n            ctx.fillText(content, this.anchor[0] + this.indent / 2, this.anchor[1]);\n          }\n        }\n      }\n      var hw = this.width / 2;\n      var textheight = this._textHeight;\n      var _this$anchor3 = text_slicedToArray(this.anchor, 2),\n        x = _this$anchor3[0],\n        y = _this$anchor3[1];\n      var lx = x - hw;\n      var ly = y - textheight / 2;\n      if (this._status.cursorshow && this._status.editing) {\n        var offset = this._cursorOffset;\n        var c = content.substring(0, offset);\n        if (this.spacePlaceholder) {\n          c = this.replaceSpaceHolder(c, true);\n        }\n        var cw = lx + ctx.measureText(c).width;\n        var c_len = this._textHeight / 2;\n        ctx.beginPath();\n        ctx.moveTo(cw, y - c_len);\n        ctx.lineTo(cw, y + c_len);\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = this.cursorColor;\n        ctx.stroke();\n      }\n      if (this._textRange.enable) {\n        var _this$_textRange = this._textRange,\n          rangefrom = _this$_textRange.rangefrom,\n          rangeTo = _this$_textRange.rangeTo;\n        var _c = this.content.substring(0, rangefrom);\n        var range = this.content.substring(rangefrom, rangeTo);\n        var _x2 = lx + ctx.measureText(_c).width;\n        var _w2 = ctx.measureText(range).width;\n        ctx.beginPath();\n        ctx.rect(_x2, ly, _w2, textheight);\n        ctx.fillStyle = this.textRangeColor;\n        ctx.fill();\n      }\n    }\n  }, {\n    key: "_inputControl",\n    value: function _inputControl(op, data) {\n      if (this._textRange.enable) {\n        this._clearTextRange();\n        if (op === \'Backspace\') {\n          this.dispatchEvent(new events(\'input\', {\n            target: this,\n            oldVal: this._status.oldVal,\n            val: this.content\n          }));\n          this.refresh();\n          this.syncShadowInputPosition();\n          return;\n        }\n      }\n      var offset = this._cursorOffset;\n      var content = this.content;\n      var preContent = content.substring(0, offset);\n      var afterContent;\n      if (this.cacheIdx) {\n        afterContent = content.substring(this.cacheIdx[1]);\n      } else {\n        afterContent = content.substring(offset);\n      }\n      var stopInputEvent = false;\n      switch (op) {\n        case "Input":\n          preContent += data;\n          this._cursorOffset += data.length;\n          this.content = preContent + afterContent;\n          break;\n        case "compositionstart":\n          this.cacheIdx = [preContent.length, preContent.length];\n          break;\n        case "compositionupdate":\n          preContent = preContent.substring(0, this.cacheIdx[0]);\n          preContent += data;\n          this.content = preContent + afterContent;\n          this._cursorOffset = this.cacheIdx[0] + data.length;\n          this.cacheIdx[1] = this.cacheIdx[0] + data.length;\n          break;\n        case "compositionend":\n          preContent = preContent.substring(0, this.cacheIdx[0]);\n          this._cursorOffset = this.cacheIdx[0] + data.length;\n          this.cacheIdx = null;\n          preContent += data;\n          this.content = preContent + afterContent;\n          break;\n        case "Enter":\n          if (this.cacheIdx) {\n            return;\n          }\n          var defaultAct = true;\n          this.dispatchEvent(new events(\'enterkeypressed\', {\n            target: this,\n            handler: function handler(val) {\n              defaultAct = val;\n            },\n            stopInput: function stopInput() {\n              stopInputEvent = true;\n            }\n          }));\n          if (defaultAct) {\n            this._jflow.blur();\n          }\n          break;\n        case "Backspace":\n          if (this.cacheIdx) {\n            return;\n          }\n          preContent = preContent.substring(0, preContent.length - 1);\n          this._cursorOffset = Math.max(0, this._cursorOffset - 1);\n          this.content = preContent + afterContent;\n          break;\n      }\n      if (!stopInputEvent) {\n        this.dispatchEvent(new events(\'input\', {\n          target: this,\n          oldVal: this._status.oldVal,\n          val: this.content\n        }));\n      }\n      this.refresh();\n      this.syncShadowInputPosition();\n    }\n  }, {\n    key: "refresh",\n    value: function refresh() {\n      this.preCalculateText();\n      this._belongs.recalculateUp();\n      this._jflow.scheduleRender();\n    }\n  }, {\n    key: "syncShadowInputPosition",\n    value: function syncShadowInputPosition() {\n      var _this8 = this;\n      if (this._status.editing) {\n        var hw = this.width / 2;\n        var hh = this.height / 2;\n        var lx = this.anchor[0] - hw;\n        var offset = this._cursorOffset;\n        requestCacheCanvas(function (ctx) {\n          ctx.beginPath();\n          ctx.font = "".concat(_this8.fontSize, " ").concat(_this8.fontFamily);\n          var c = _this8.content.substring(0, offset);\n          lx += ctx.measureText(c).width;\n        });\n        var point = this.calculateToRealWorld([lx, hh]);\n        var canvasMeta = this._jflow.canvasMeta;\n        var px = Math.min(canvasMeta.actual_width - 120, point[0]);\n        this._status.inputElement.style.transform = "translate(".concat(px, "px, ").concat(point[1], "px)");\n      }\n    }\n  }, {\n    key: "_controlCallback",\n    value: function _controlCallback(op, data, e) {\n      if (this._status.editing) {\n        Object.assign(this._status, {\n          cursorshow: true,\n          refreshElapsed: true\n        });\n      }\n      switch (op) {\n        case "Input":\n        case "compositionstart":\n        case "compositionupdate":\n        case "compositionend":\n        case "Enter":\n        case "Backspace":\n          this._inputControl(op, data);\n          break;\n        case "ArrowLeft":\n          if (this._textRange.enable) {\n            this._textRange.enable = false;\n          }\n          this._onArrowLeft();\n          break;\n        case "ArrowRight":\n          if (this._textRange.enable) {\n            this._textRange.enable = false;\n          }\n          this._onArrowRight();\n          break;\n        case "Shift":\n          this._onShiftToggle(data);\n          break;\n        case "CtrlA":\n          this._selectFullRange();\n          break;\n        case "COPY":\n          this._copy(e);\n          break;\n        case "CUT":\n          this._cut(e);\n          break;\n        case "PASTE":\n          this._paste(e);\n          break;\n      }\n    }\n  }, {\n    key: "_onArrowLeft",\n    value: function _onArrowLeft() {\n      this._cursorOffset = Math.max(0, this._cursorOffset - 1);\n      this._jflow.scheduleRender();\n      this.syncShadowInputPosition();\n    }\n  }, {\n    key: "_onArrowRight",\n    value: function _onArrowRight() {\n      this._cursorOffset = Math.min(this.content.length, this._cursorOffset + 1);\n      this._jflow.scheduleRender();\n      this.syncShadowInputPosition();\n    }\n  }, {\n    key: "_onShiftToggle",\n    value: function _onShiftToggle(val) {\n      this._status.shiftOn = val;\n      if (val) {\n        this._textRange.initialRange = this._cursorOffset;\n      } else {\n        this._textRange.initialRange = null;\n      }\n    }\n  }, {\n    key: "_selectFullRange",\n    value: function _selectFullRange() {\n      this._textRange = {\n        enable: true,\n        rangefrom: 0,\n        rangeTo: this.content.length\n      };\n      this._cursorOffset = this.content.length;\n    }\n  }, {\n    key: "_clearTextRange",\n    value: function _clearTextRange() {\n      if (this._textRange.enable) {\n        var _this$_textRange2 = this._textRange,\n          rangefrom = _this$_textRange2.rangefrom,\n          rangeTo = _this$_textRange2.rangeTo;\n        var content = this.content;\n        var preContent = content.substring(0, rangefrom);\n        var afterContent = content.substring(rangeTo);\n        this.content = preContent + afterContent;\n        this._cursorOffset = preContent.length;\n        this._textRange.enable = false;\n      }\n    }\n  }, {\n    key: "_getSelection",\n    value: function _getSelection() {\n      if (this._textRange.enable) {\n        var _this$_textRange3 = this._textRange,\n          rangefrom = _this$_textRange3.rangefrom,\n          rangeTo = _this$_textRange3.rangeTo;\n        var content = this.content;\n        return content.substring(rangefrom, rangeTo);\n      }\n      return null;\n    }\n  }, {\n    key: "_copy",\n    value: function _copy(event) {\n      var selection = this._getSelection();\n      if (selection) {\n        event.clipboardData.setData("text/plain", selection);\n      }\n    }\n  }, {\n    key: "_cut",\n    value: function _cut(event) {\n      var selection = this._getSelection();\n      if (selection) {\n        event.clipboardData.setData("text/plain", selection);\n        this._clearTextRange();\n        this.refresh();\n      }\n    }\n  }, {\n    key: "_paste",\n    value: function _paste(event) {\n      var pasteContent = (event.clipboardData || window.clipboardData).getData("text");\n      var flag = false;\n      this.dispatchEvent(new events(\'paste\', {\n        target: this,\n        content: pasteContent,\n        preventDefault: function preventDefault() {\n          flag = true;\n        },\n        resolvePasteContent: function resolvePasteContent(callback) {\n          pasteContent = callback(pasteContent);\n        }\n      }));\n      if (flag) {\n        return;\n      }\n      this._clearTextRange();\n      var offset = this._cursorOffset;\n      var content = this.content;\n      var preContent = content.substring(0, offset);\n      var afterContent = content.substring(offset);\n      this.content = preContent + pasteContent + afterContent;\n      this._cursorOffset = (preContent + pasteContent).length;\n      this.refresh();\n    }\n  }, {\n    key: "_defaultCallback",\n    value: function _defaultCallback(op, e) {\n      switch (op) {\n        case \'KeyDown\':\n          this.dispatchEvent(new events(\'keydown\', {\n            target: this,\n            key: e.key,\n            code: e.code,\n            rawEvent: e\n          }));\n          break;\n        case \'KeyUp\':\n          this.dispatchEvent(new events(\'keyup\', {\n            target: this,\n            key: e.key,\n            code: e.code,\n            rawEvent: e\n          }));\n          break;\n      }\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      if (this._jflow._focus.instance === this) {\n        this._jflow.blur();\n      }\n    }\n  }]);\n  return Text;\n}(rectangle);\n/* harmony default export */ const elements_text = (Text);\nfunction createInputElement(controlCallback, defaultCallback) {\n  var input = document.createElement(\'input\');\n  input.setAttribute(\'style\', "\\n        width: 100px;\\n        position: absolute;\\n        left: 0;\\n        top: 0;\\n        border:none;\\n        opacity: 0;\\n        z-index: -1;\\n        contain: strict;");\n  input.setAttribute(\'tabindex\', -1);\n  input.setAttribute(\'spellcheck\', false);\n  input.setAttribute(\'autocorrect\', \'off\');\n\n  // let content = configs.content;\n  // let startidx = 0;\n\n  // function renderContent() {\n  //     configs.callback(content)\n  // }\n  var stopInput = false;\n  var status = {\n    ctrlOn: false\n  };\n  input.addEventListener(\'beforeinput\', function (e) {\n    e.preventDefault();\n    if (e.data) {\n      // content += e.data;\n      // renderContent();\n      if (!stopInput) {\n        controlCallback(\'Input\', e.data);\n      }\n    }\n  });\n  input.addEventListener(\'compositionstart\', function (e) {\n    // cache composition start offset\n    // startidx = content.length;\n    controlCallback(\'compositionstart\');\n    stopInput = true;\n  });\n  input.addEventListener(\'compositionupdate\', function (e) {\n    // update content\n    // content = content.substring(0, startidx);\n    // content += e.data;\n    // renderContent();\n    controlCallback(\'compositionupdate\', e.data);\n  });\n  input.addEventListener(\'compositionend\', function (e) {\n    // replace text at start offset\n    // content = content.substring(0, startidx);\n    // startidx = 0;\n    // content += e.data;\n    // renderContent();\n    controlCallback(\'compositionend\', e.data);\n    input.value = \'\';\n    stopInput = false;\n  });\n  input.addEventListener(\'keyup\', function (event) {\n    switch (event.key) {\n      case "Shift":\n        controlCallback("Shift", false);\n        break;\n      case "Meta":\n      case "Control":\n        status.ctrlOn = false;\n        break;\n    }\n  });\n  input.addEventListener(\'keydown\', function (event) {\n    switch (event.code) {\n      case "Enter":\n        // content = content + \'\\n\';\n        // renderContent();\n        controlCallback(\'Enter\');\n        break;\n      case "Backspace":\n        // content = content.substring(0, content.length - 1);\n        // renderContent();\n        controlCallback(\'Backspace\');\n        break;\n      case "ArrowLeft":\n        controlCallback("ArrowLeft");\n        break;\n      case "ArrowRight":\n        controlCallback("ArrowRight");\n        break;\n      case "ArrowDown":\n        controlCallback("ArrowDown");\n        break;\n      case "ArrowUp":\n        controlCallback("ArrowUp");\n        break;\n    }\n    switch (event.key) {\n      case "Shift":\n        controlCallback("Shift", true);\n        break;\n      case "Meta":\n      case "Control":\n        status.ctrlOn = true;\n        break;\n      case \'a\':\n        if (status.ctrlOn) {\n          controlCallback(\'CtrlA\');\n        }\n        break;\n    }\n  });\n  input.addEventListener(\'keyup\', function (event) {\n    defaultCallback(\'KeyUp\', event);\n  });\n  input.addEventListener(\'keydown\', function (event) {\n    defaultCallback(\'KeyDown\', event);\n  });\n  input.addEventListener(\'copy\', function (event) {\n    event.preventDefault();\n    event.stopPropagation();\n    controlCallback(\'COPY\', null, event);\n  });\n  input.addEventListener(\'cut\', function (event) {\n    event.preventDefault();\n    event.stopPropagation();\n    controlCallback(\'CUT\', null, event);\n  });\n  input.addEventListener(\'paste\', function (event) {\n    event.preventDefault();\n    event.stopPropagation();\n    controlCallback(\'PASTE\', null, event);\n  });\n  return input;\n}\n;// CONCATENATED MODULE: ./src/core/instance/image.js\nfunction image_typeof(obj) { "@babel/helpers - typeof"; return image_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, image_typeof(obj); }\nfunction image_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction image_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, image_toPropertyKey(descriptor.key), descriptor); } }\nfunction image_createClass(Constructor, protoProps, staticProps) { if (protoProps) image_defineProperties(Constructor.prototype, protoProps); if (staticProps) image_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction image_toPropertyKey(arg) { var key = image_toPrimitive(arg, "string"); return image_typeof(key) === "symbol" ? key : String(key); }\nfunction image_toPrimitive(input, hint) { if (image_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (image_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction image_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) image_setPrototypeOf(subClass, superClass); }\nfunction image_setPrototypeOf(o, p) { image_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return image_setPrototypeOf(o, p); }\nfunction image_createSuper(Derived) { var hasNativeReflectConstruct = image_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = image_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = image_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return image_possibleConstructorReturn(this, result); }; }\nfunction image_possibleConstructorReturn(self, call) { if (call && (image_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return image_assertThisInitialized(self); }\nfunction image_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction image_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction image_getPrototypeOf(o) { image_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return image_getPrototypeOf(o); }\n\n\n\n\n\n\n/**\n * @typedef {Object} Icon~ImageBounding\n * @property {number} width   - 图片宽度\n * @property {number} height   - 图片高度 \n */\n/**\n * 图片单元 配置\n * @typedef {Rectangle~RectangleConfigs} Icon~IconConfigs\n * @property {number} image   - 图片地址\n * @property {number} imageWidth   - 图片宽度\n * @property {number} imageHeight   - 图片高度\n */\n\n/**\n * 图片单元\n * @description 图片单元可以绘制图片，图片加载后会自动重新绘制\n * @constructor Icon\n * @extends Rectangle\n * @param {Icon~IconConfigs} configs - 配置\n */\nvar Icon = /*#__PURE__*/function (_Rectangle) {\n  image_inherits(Icon, _Rectangle);\n  var _super = image_createSuper(Icon);\n  function Icon(configs) {\n    var _this;\n    image_classCallCheck(this, Icon);\n    _this = _super.call(this, configs);\n    /** @member {CanvasImageSource}      - 图片 */\n    _this.image = configs.image;\n    _this.image.onload = function () {\n      _this._jflow._render();\n      // requestAnimationFrame(() => {\n\n      // })\n    };\n    /** @member {Icon~ImageBounding}      - 图片维度 */\n    _this.imageBounding = {\n      width: configs.imageWidth || configs.width,\n      height: configs.imageHeight || configs.height\n    };\n    return _this;\n  }\n  image_createClass(Icon, [{\n    key: "setConfig",\n    value: function setConfig(configs) {\n      var _this2 = this;\n      Object.keys(configs).forEach(function (k) {\n        if (configs[k] !== undefined && configs[k] !== null) {\n          _this2[k] = configs[k];\n          _this2._rawConfigs[k] = configs[k];\n        }\n      });\n      if (configs.image && !configs.image.complete) {\n        this.image.onload = function () {\n          _this2._jflow._render();\n          // requestAnimationFrame(() => {\n          //     this._jflow._render();\n          // })\n        };\n      }\n\n      this.imageBounding = {\n        width: configs.imageWidth || configs.width || this.imageBounding.width,\n        height: configs.imageHeight || configs.height || this.imageBounding.height\n      };\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      rectangle.prototype.render.call(this, ctx);\n      var x = this.anchor[0] - this.width / 2;\n      var y = this.anchor[1] - this.height / 2;\n      if (this.opacity < 1) {\n        ctx.globalAlpha = this.opacity;\n      }\n      if (this.image.complete) {\n        ctx.drawImage(this.image, x, y, this.imageBounding.width, this.imageBounding.height);\n      }\n      ctx.restore();\n    }\n  }]);\n  return Icon;\n}(rectangle);\n/* harmony default export */ const instance_image = (Icon);\n;// CONCATENATED MODULE: ./src/core/instance/shadowDom.js\nfunction shadowDom_typeof(obj) { "@babel/helpers - typeof"; return shadowDom_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, shadowDom_typeof(obj); }\nfunction shadowDom_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction shadowDom_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, shadowDom_toPropertyKey(descriptor.key), descriptor); } }\nfunction shadowDom_createClass(Constructor, protoProps, staticProps) { if (protoProps) shadowDom_defineProperties(Constructor.prototype, protoProps); if (staticProps) shadowDom_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction shadowDom_toPropertyKey(arg) { var key = shadowDom_toPrimitive(arg, "string"); return shadowDom_typeof(key) === "symbol" ? key : String(key); }\nfunction shadowDom_toPrimitive(input, hint) { if (shadowDom_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (shadowDom_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction shadowDom_get() { if (typeof Reflect !== "undefined" && Reflect.get) { shadowDom_get = Reflect.get.bind(); } else { shadowDom_get = function _get(target, property, receiver) { var base = shadowDom_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return shadowDom_get.apply(this, arguments); }\nfunction shadowDom_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = shadowDom_getPrototypeOf(object); if (object === null) break; } return object; }\nfunction shadowDom_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) shadowDom_setPrototypeOf(subClass, superClass); }\nfunction shadowDom_setPrototypeOf(o, p) { shadowDom_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return shadowDom_setPrototypeOf(o, p); }\nfunction shadowDom_createSuper(Derived) { var hasNativeReflectConstruct = shadowDom_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = shadowDom_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = shadowDom_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return shadowDom_possibleConstructorReturn(this, result); }; }\nfunction shadowDom_possibleConstructorReturn(self, call) { if (call && (shadowDom_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return shadowDom_assertThisInitialized(self); }\nfunction shadowDom_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction shadowDom_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction shadowDom_getPrototypeOf(o) { shadowDom_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return shadowDom_getPrototypeOf(o); }\n\n/**\n * @funtion domFactory\n * @param {Element} container - DOM容器\n */\n/**\n * DOM元素容器 配置\n * @typedef {Rectangle~Configs} ShadowDom~RectangleConfigs\n * @property {domFactory} createDocument - 宽\n */\n/**\n * DOM元素容器 内容可贴 DOM 元素，支持缩放平移\n * @constructor ShadowDom\n * @extends Rectangle\n * @param {ShadowDom~RectangleConfigs} configs\n */\nvar ShadowDom = /*#__PURE__*/function (_Rectangle) {\n  shadowDom_inherits(ShadowDom, _Rectangle);\n  var _super = shadowDom_createSuper(ShadowDom);\n  function ShadowDom(configs) {\n    var _this;\n    shadowDom_classCallCheck(this, ShadowDom);\n    _this = _super.call(this, configs);\n    _this.domFactory = configs.createDocument;\n    _this._dom = null;\n    return _this;\n  }\n  shadowDom_createClass(ShadowDom, [{\n    key: "getRealWorldPosition",\n    value: function getRealWorldPosition() {\n      var b = this.getBoundingRect();\n      return this.calculateToRealWorld(b.slice(0, 2));\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      var _this2 = this;\n      if (!this._dom && this.domFactory) {\n        requestAnimationFrame(function () {\n          if (!_this2._dom) {\n            var container = document.createElement(\'div\');\n            var pos = _this2.getRealWorldPosition();\n            var scale = _this2._jflow.scale;\n            container.setAttribute(\'style\', "\\n                        position: absolute;\\n                        width: ".concat(_this2.width, "px;\\n                        height: ").concat(_this2.height, "px;\\n                        transform-origin: left top;\\n                        top: 0;\\n                        left: 0;\\n                        transform: translate(").concat(pos[0], "px, ").concat(pos[1], "px) scale(").concat(scale, ");"));\n            _this2._dom = container;\n            _this2._jflow.DOMwrapper.appendChild(container);\n            _this2.domFactory(container);\n          }\n        });\n      } else {\n        var pos = this.getRealWorldPosition();\n        var scale = this._jflow.scale;\n        this._dom.style.transform = "translate(".concat(pos[0], "px, ").concat(pos[1], "px) scale(").concat(scale, ")");\n      }\n      shadowDom_get(shadowDom_getPrototypeOf(ShadowDom.prototype), "render", this).call(this, ctx);\n    }\n  }, {\n    key: "onEnterViewbox",\n    value: function onEnterViewbox() {\n      if (this._dom) {\n        this._dom.style.display = \'block\';\n      }\n    }\n  }, {\n    key: "onLeaveViewbox",\n    value: function onLeaveViewbox() {\n      if (this._dom) {\n        this._dom.style.display = \'none\';\n      }\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      if (this._dom) {\n        this._jflow.DOMwrapper.removeChild(this._dom);\n      }\n      shadowDom_get(shadowDom_getPrototypeOf(ShadowDom.prototype), "destroy", this).call(this);\n    }\n  }]);\n  return ShadowDom;\n}(rectangle);\n/* harmony default export */ const shadowDom = (ShadowDom);\n;// CONCATENATED MODULE: ./src/core/instance/link.js\nfunction link_typeof(obj) { "@babel/helpers - typeof"; return link_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, link_typeof(obj); }\nfunction link_slicedToArray(arr, i) { return link_arrayWithHoles(arr) || link_iterableToArrayLimit(arr, i) || link_unsupportedIterableToArray(arr, i) || link_nonIterableRest(); }\nfunction link_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction link_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return link_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return link_arrayLikeToArray(o, minLen); }\nfunction link_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction link_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction link_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction link_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction link_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, link_toPropertyKey(descriptor.key), descriptor); } }\nfunction link_createClass(Constructor, protoProps, staticProps) { if (protoProps) link_defineProperties(Constructor.prototype, protoProps); if (staticProps) link_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction link_toPropertyKey(arg) { var key = link_toPrimitive(arg, "string"); return link_typeof(key) === "symbol" ? key : String(key); }\nfunction link_toPrimitive(input, hint) { if (link_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (link_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction link_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) link_setPrototypeOf(subClass, superClass); }\nfunction link_setPrototypeOf(o, p) { link_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return link_setPrototypeOf(o, p); }\nfunction link_createSuper(Derived) { var hasNativeReflectConstruct = link_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = link_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = link_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return link_possibleConstructorReturn(this, result); }; }\nfunction link_possibleConstructorReturn(self, call) { if (call && (link_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return link_assertThisInitialized(self); }\nfunction link_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction link_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction link_getPrototypeOf(o) { link_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return link_getPrototypeOf(o); }\n\n\n\n/**\n * @typedef {BaseLink~Configs} Link~Configs\n * @property {Number} approximate   - 点击响应范围\n * @property {Number[]} lineDash    - 虚线数组\n * @property {Boolean} doubleLink   - 双向箭头\n * @property {String} fontFamily    - 连线上的文字字体\n * @property {Number} fontSize      - 连线上的文字大小\n * @property {String} content       - 连线上的文字\n */\n/**\n * 直线\n * @constructor Link\n * @extends BaseLink\n * @param {Link~Configs} configs - 配置\n */\nvar Link = /*#__PURE__*/function (_BaseLink) {\n  link_inherits(Link, _BaseLink);\n  var _super = link_createSuper(Link);\n  function Link(configs) {\n    var _this;\n    link_classCallCheck(this, Link);\n    _this = _super.call(this, configs);\n    _this.fontFamily = configs.fontFamily = \'-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Tahoma,Arial,Noto Sans,PingFang SC,Microsoft YaHei,Hiragino Sans GB,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji\';\n    _this.fontSize = configs.fontSize || \'12px\';\n    _this.content = configs.content || \'\';\n    _this.lineDash = configs.lineDash;\n    _this.approximate = configs.approximate || APPROXIMATE;\n    _this._cacheAngle = undefined;\n    _this._cachePoints = [];\n    _this._cacheBoundingbox = {\n      from: [],\n      to: []\n    };\n    return _this;\n  }\n  link_createClass(Link, [{\n    key: "_calculateAnchorPoints",\n    value: function _calculateAnchorPoints() {\n      var p0 = this.from.calculateIntersection(this.to.getCenter());\n      var p1 = this.to.calculateIntersection(this.from.getCenter());\n      this._cachePoints[0] = p0;\n      this._cachePoints[1] = p1;\n      var dx = p1[0] - p0[0];\n      var dy = p1[1] - p0[1];\n      var angle = Math.atan2(dy, dx);\n      this._cacheAngle = angle;\n    }\n  }, {\n    key: "isInViewBox",\n    value: function isInViewBox(br) {\n      var frombox = this.from.getBoundingRect();\n      var tobox = this.to.getBoundingRect();\n      var _box = this._cacheBoundingbox;\n      if (!compareBoundingbox(_box.from, frombox) || compareBoundingbox(_box.to, tobox)) {\n        copyBoundingbox(_box.from, frombox);\n        copyBoundingbox(_box.to, tobox);\n        this._calculateAnchorPoints();\n      }\n      return true;\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      var _this$_cachePoints = link_slicedToArray(this._cachePoints, 2),\n        p0 = _this$_cachePoints[0],\n        p1 = _this$_cachePoints[1];\n      var angle = this._cacheAngle;\n      var dx = p1[0] - p0[0];\n      var dy = p1[1] - p0[1];\n      ctx.fillStyle = ctx.strokeStyle = this.backgroundColor;\n      ctx.beginPath();\n      if (this.content) {\n        ctx.textAlign = \'center\';\n        ctx.font = "".concat(this.fontSize, " ").concat(this.fontFamily);\n        ctx.textBaseline = \'middle\';\n        var _ctx$measureText = ctx.measureText(this.content),\n          actualBoundingBoxLeft = _ctx$measureText.actualBoundingBoxLeft,\n          actualBoundingBoxRight = _ctx$measureText.actualBoundingBoxRight,\n          fontBoundingBoxAscent = _ctx$measureText.fontBoundingBoxAscent,\n          fontBoundingBoxDescent = _ctx$measureText.fontBoundingBoxDescent;\n        var x = dx / 2 + p0[0];\n        var y = dy / 2 + p0[1];\n        ctx.fillText(this.content, x, y);\n        var width = Math.abs(actualBoundingBoxLeft) + Math.abs(actualBoundingBoxRight) + 20;\n        var height = (Math.abs(fontBoundingBoxAscent) + Math.abs(fontBoundingBoxDescent)) * 1.5;\n        ctx.beginPath();\n        var region = new Path2D();\n        region.rect(x - width / 2, y - height / 2, width, height);\n        var rx = Math.min(p1[0], p0[0]) - 10;\n        var ry = Math.min(p1[1], p0[1]) - 10;\n        var rw = Math.abs(dx) + 20;\n        var rh = Math.abs(dy) + 20;\n        region.rect(rx, ry, rw, rh);\n        ctx.clip(region, "evenodd");\n      }\n      ctx.moveTo(p0[0], p0[1]);\n      ctx.lineTo(p1[0], p1[1]);\n      if (this.lineDash) {\n        ctx.save();\n        ctx.setLineDash(this.lineDash);\n      }\n      ctx.stroke();\n      if (this.lineDash) {\n        ctx.restore();\n      }\n      ctx.translate(p1[0], p1[1]);\n      ctx.rotate(angle);\n      ctx.moveTo(0, 0);\n      ctx.lineTo(-5, -4);\n      ctx.lineTo(-5, 4);\n      ctx.lineTo(0, 0);\n      ctx.fill();\n      ctx.rotate(-angle);\n      ctx.translate(-p1[0], -p1[1]);\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      if (!this._cachePoints) return false;\n      var _this$_cachePoints2 = link_slicedToArray(this._cachePoints, 2),\n        start = _this$_cachePoints2[0],\n        end = _this$_cachePoints2[1];\n      var dist = distToSegmentSquared(point, start, end);\n      return dist < this.approximate;\n    }\n  }]);\n  return Link;\n}(base_link);\n/* harmony default export */ const instance_link = (Link);\n;// CONCATENATED MODULE: ./src/core/instance/poly-link.js\nfunction poly_link_typeof(obj) { "@babel/helpers - typeof"; return poly_link_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, poly_link_typeof(obj); }\nfunction poly_link_defineProperty(obj, key, value) { key = poly_link_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction poly_link_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction poly_link_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, poly_link_toPropertyKey(descriptor.key), descriptor); } }\nfunction poly_link_createClass(Constructor, protoProps, staticProps) { if (protoProps) poly_link_defineProperties(Constructor.prototype, protoProps); if (staticProps) poly_link_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction poly_link_toPropertyKey(arg) { var key = poly_link_toPrimitive(arg, "string"); return poly_link_typeof(key) === "symbol" ? key : String(key); }\nfunction poly_link_toPrimitive(input, hint) { if (poly_link_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (poly_link_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction poly_link_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) poly_link_setPrototypeOf(subClass, superClass); }\nfunction poly_link_setPrototypeOf(o, p) { poly_link_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return poly_link_setPrototypeOf(o, p); }\nfunction poly_link_createSuper(Derived) { var hasNativeReflectConstruct = poly_link_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = poly_link_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = poly_link_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return poly_link_possibleConstructorReturn(this, result); }; }\nfunction poly_link_possibleConstructorReturn(self, call) { if (call && (poly_link_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return poly_link_assertThisInitialized(self); }\nfunction poly_link_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction poly_link_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction poly_link_getPrototypeOf(o) { poly_link_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return poly_link_getPrototypeOf(o); }\n\n\n\n// import { dist2, bezierPoint } from \'../utils/functions\';\nvar PIINRATIO = Math.PI / 180;\n/**\n * @typedef {BaseLink~Configs} PolyLink~Configs\n * @property {Number} approximate   - 点击响应范围\n * @property {Number} radius        - 拐角弧度\n * @property {Number} minSpanX      - 起点终点在 x 方向最小的跨度\n * @property {Number} minSpanY      - 起点终点在 y 方向最小的跨度\n * @property {number[]} lineDash    - 虚线数组\n * @property {Boolean} doubleLink   - 双向箭头\n * @property {String} fontFamily    - 连线上的文字字体\n * @property {Number} fontSize      - 连线上的文字大小\n * @property {String} content       - 连线上的文字\n * @property {String} isSelf        - 是否为自连接\n */\n/**\n * 方形折线\n * @constructor PolyLink\n * @extends BaseLink\n * @param {PolyLink~Configs} configs - 配置\n */\nvar PolyLink = /*#__PURE__*/function (_BaseLink) {\n  poly_link_inherits(PolyLink, _BaseLink);\n  var _super = poly_link_createSuper(PolyLink);\n  /**\n  * 创建方形折线\n  * @param {PolyLink~Configs} configs - 配置\n  **/\n  function PolyLink(configs) {\n    var _this;\n    poly_link_classCallCheck(this, PolyLink);\n    _this = _super.call(this, configs);\n    /** @member {Number}   - 点击响应范围 */\n    _this.approximate = configs.approximate || APPROXIMATE;\n    /** @member {Number}   - 拐角弧度 */\n    _this.radius = configs.radius || 0;\n    /** @member {Number}   - 起点终点在 x 方向最小的跨度 */\n    _this.minSpanX = configs.minSpanX || 10;\n    /** @member {Number}   - 起点终点在 y 方向最小的跨度 */\n    _this.minSpanY = configs.minSpanY || 10;\n    /** @member {Number}    - 虚线数组 */\n    _this.lineDash = configs.lineDash;\n    /** @member {Number}    - 双向箭头 */\n    _this.doubleLink = configs.doubleLink;\n    /** @member {Number}    - 连线上的文字字体 */\n    _this.fontFamily = configs.fontFamily = \'-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Tahoma,Arial,Noto Sans,PingFang SC,Microsoft YaHei,Hiragino Sans GB,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji\';\n    /** @member {Number}    - 连线上的文字大小 */\n    _this.fontSize = configs.fontSize || \'12px\';\n    /** @member {Number}    - 连线上的文字 */\n    _this.content = configs.content || \'\';\n    /** @member {Number}    - 是否为自连接 */\n    _this.isSelf = !!configs.isSelf;\n    _this.noArrow = !!configs.noArrow;\n    _this._cacheAngle = [];\n    _this._cachePoints = [];\n    _this._cacheBoundingbox = {\n      from: [],\n      to: []\n    };\n    return _this;\n  }\n  poly_link_createClass(PolyLink, [{\n    key: "_calculateAnchorPoints",\n    value: function _calculateAnchorPoints() {\n      var dmsfrom = this.from.getIntersectionsInFourDimension();\n      var dmsto = this.to.getIntersectionsInFourDimension();\n      var _cacheAngle = this._cacheAngle;\n      if (this.isSelf) {\n        polylinePoints(this._cachePoints, dmsfrom[this.fromDir], dmsto[DIRECTION.SELF], this.fromDir, this.toDir, this.minSpanX, this.minSpanY, true);\n        _cacheAngle[0] = this.fromDir;\n        _cacheAngle[1] = this.toDir;\n      } else if (this.fromDir !== undefined && this.toDir !== undefined) {\n        polylinePoints(this._cachePoints, dmsfrom[this.fromDir], dmsto[this.toDir], this.fromDir, this.toDir, this.minSpanX, this.minSpanY);\n        _cacheAngle[0] = this.fromDir;\n        _cacheAngle[1] = this.toDir;\n      } else {\n        var meta = minIntersectionBetweenNodes(dmsfrom, dmsto);\n        polylinePoints(this._cachePoints, meta.fromP, meta.toP, meta.fromDir, meta.toDir, this.minSpanX, this.minSpanY);\n        _cacheAngle[0] = meta.fromDir;\n        _cacheAngle[1] = meta.toDir;\n      }\n    }\n  }, {\n    key: "isInViewBox",\n    value: function isInViewBox(br) {\n      if (this._static) {\n        return true;\n      }\n      this._calculateAnchorPoints();\n      return isPolyLineIntersectionRectange(this._cachePoints, br);\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      var _this2 = this;\n      // this._calculateAnchorPoints();\n      var radius = this.radius;\n      var points = this._cachePoints;\n      var p = points[0];\n      var pEnd = points[points.length - 1];\n      var angleEnd = (this._cacheAngle[1] + 2) % 4 * 90 * PIINRATIO;\n      ctx.fillStyle = ctx.strokeStyle = this.backgroundColor;\n      if (this.doubleLink) {\n        var beginAngle = (this._cacheAngle[0] + 2) % 4 * 90 * PIINRATIO;\n        ctx.beginPath();\n        ctx.translate(p[0], p[1]);\n        ctx.rotate(beginAngle);\n        ctx.moveTo(5, 0);\n        ctx.lineTo(0, -4);\n        ctx.lineTo(0, 4);\n        ctx.lineTo(5, 0);\n        ctx.fill();\n        ctx.rotate(-beginAngle);\n        ctx.translate(-p[0], -p[1]);\n      }\n      ctx.beginPath();\n      ctx.moveTo(p[0], p[1]);\n      points.slice(1, points.length - 1).forEach(function (p, idx) {\n        if (_this2.radius) {\n          var pLast = points[idx];\n          var pNext = points[idx + 2];\n          var _makeRadiusFromVector = makeRadiusFromVector(pLast, p, pNext, radius),\n            p1 = _makeRadiusFromVector.p1,\n            p2 = _makeRadiusFromVector.p2;\n          if (p1 && p2) {\n            ctx.lineTo(p1[0], p1[1]);\n            ctx.quadraticCurveTo(p[0], p[1], p2[0], p2[1]);\n          } else {\n            ctx.lineTo(p[0], p[1]);\n          }\n        } else {\n          ctx.lineTo(p[0], p[1]);\n        }\n      });\n      ctx.lineTo(pEnd[0], pEnd[1]);\n      if (this.lineDash) {\n        ctx.save();\n        ctx.setLineDash(this.lineDash);\n      }\n      ctx.stroke();\n      if (this.lineDash) {\n        ctx.restore();\n      }\n      if (!this.noArrow) {\n        ctx.beginPath();\n        ctx.translate(pEnd[0], pEnd[1]);\n        ctx.rotate(angleEnd);\n        ctx.moveTo(0, 0);\n        ctx.lineTo(-5, -4);\n        ctx.lineTo(-5, 4);\n        ctx.lineTo(0, 0);\n        ctx.fill();\n        ctx.rotate(-angleEnd);\n        ctx.translate(-pEnd[0], -pEnd[1]);\n      }\n      if (this.content) {\n        ctx.beginPath();\n        ctx.font = "".concat(this.fontSize, " ").concat(this.fontFamily);\n        switch (this.fromDir) {\n          case DIRECTION.BOTTOM:\n            ctx.textAlign = \'left\';\n            ctx.fillText(this.content, p[0] + 2, p[1] + 10);\n            break;\n          case DIRECTION.RIGHT:\n            ctx.textAlign = \'left\';\n            ctx.fillText(this.content, p[0] + 10, p[1] - 2);\n            break;\n          default:\n            break;\n        }\n      }\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      if (this._static) {\n        return false;\n      }\n      if (!this._cachePoints) {\n        return false;\n      }\n      var points = this._cachePoints;\n      var lastP = points[0];\n      var remainPoints = points.slice(1);\n      do {\n        var currentP = remainPoints.shift();\n        if (currentP) {\n          var dist = distToSegmentSquared(point, lastP, currentP);\n          if (dist < this.approximate) {\n            return true;\n          }\n        }\n        lastP = currentP;\n      } while (lastP);\n      return false;\n    }\n  }, {\n    key: "cloneStatic",\n    value: function cloneStatic() {\n      var _Object$assign;\n      var t = new PolyLink({});\n      Object.assign(t, (_Object$assign = {\n        radius: this.radius,\n        _cachePoints: this._cachePoints,\n        _cacheAngle: this._cacheAngle,\n        backgroundColor: this.backgroundColor,\n        doubleLink: this.doubleLink\n      }, poly_link_defineProperty(_Object$assign, "radius", this.radius), poly_link_defineProperty(_Object$assign, "lineDash", this.lineDash), poly_link_defineProperty(_Object$assign, "noArrow", this.noArrow), poly_link_defineProperty(_Object$assign, "content", this.content), poly_link_defineProperty(_Object$assign, "fontSize", this.fontSize), poly_link_defineProperty(_Object$assign, "fontFamily", this.fontFamily), poly_link_defineProperty(_Object$assign, "fromDir", this.fromDir), poly_link_defineProperty(_Object$assign, "_static", true), _Object$assign));\n      return t;\n    }\n  }]);\n  return PolyLink;\n}(base_link);\n/* harmony default export */ const poly_link = (PolyLink);\n;// CONCATENATED MODULE: ./src/core/instance/bezier-link.js\nfunction bezier_link_typeof(obj) { "@babel/helpers - typeof"; return bezier_link_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, bezier_link_typeof(obj); }\nfunction bezier_link_slicedToArray(arr, i) { return bezier_link_arrayWithHoles(arr) || bezier_link_iterableToArrayLimit(arr, i) || bezier_link_unsupportedIterableToArray(arr, i) || bezier_link_nonIterableRest(); }\nfunction bezier_link_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction bezier_link_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction bezier_link_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction bezier_link_toConsumableArray(arr) { return bezier_link_arrayWithoutHoles(arr) || bezier_link_iterableToArray(arr) || bezier_link_unsupportedIterableToArray(arr) || bezier_link_nonIterableSpread(); }\nfunction bezier_link_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction bezier_link_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return bezier_link_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return bezier_link_arrayLikeToArray(o, minLen); }\nfunction bezier_link_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\nfunction bezier_link_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return bezier_link_arrayLikeToArray(arr); }\nfunction bezier_link_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction bezier_link_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction bezier_link_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, bezier_link_toPropertyKey(descriptor.key), descriptor); } }\nfunction bezier_link_createClass(Constructor, protoProps, staticProps) { if (protoProps) bezier_link_defineProperties(Constructor.prototype, protoProps); if (staticProps) bezier_link_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction bezier_link_toPropertyKey(arg) { var key = bezier_link_toPrimitive(arg, "string"); return bezier_link_typeof(key) === "symbol" ? key : String(key); }\nfunction bezier_link_toPrimitive(input, hint) { if (bezier_link_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (bezier_link_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction bezier_link_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) bezier_link_setPrototypeOf(subClass, superClass); }\nfunction bezier_link_setPrototypeOf(o, p) { bezier_link_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return bezier_link_setPrototypeOf(o, p); }\nfunction bezier_link_createSuper(Derived) { var hasNativeReflectConstruct = bezier_link_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = bezier_link_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = bezier_link_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return bezier_link_possibleConstructorReturn(this, result); }; }\nfunction bezier_link_possibleConstructorReturn(self, call) { if (call && (bezier_link_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return bezier_link_assertThisInitialized(self); }\nfunction bezier_link_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction bezier_link_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction bezier_link_getPrototypeOf(o) { bezier_link_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return bezier_link_getPrototypeOf(o); }\n\n\n\n\nvar bezier_link_PIINRATIO = Math.PI / 180;\n/**\n * @typedef {BaseLink~Configs} BezierLink~Configs\n * @property {Number} approximate   - 点击响应范围\n * @property {Number} minSpanX      - 起点终点在 x 方向最小的跨度\n * @property {Number} minSpanY      - 起点终点在 y 方向最小的跨度\n * @property {Number[]} lineDash    - 虚线数组\n * @property {Boolean} doubleLink   - 双向箭头\n * @property {String} fontFamily    - 连线上的文字字体\n * @property {Number} fontSize      - 连线上的文字大小\n * @property {String} content       - 连线上的文字\n * @property {Boolean} isSelf        - 是否为自连接\n */\n/**\n * 贝塞尔曲线\n * @constructor BezierLink\n * @extends BaseLink\n * @param {BezierLink~Configs} configs - 配置\n */\nvar BezierLink = /*#__PURE__*/function (_BaseLink) {\n  bezier_link_inherits(BezierLink, _BaseLink);\n  var _super = bezier_link_createSuper(BezierLink);\n  /**\n  * 创建贝塞尔曲线.\n  * @param {BezierLink~Configs} configs - 配置\n  **/\n  function BezierLink(configs) {\n    var _this;\n    bezier_link_classCallCheck(this, BezierLink);\n    _this = _super.call(this, configs);\n    /** @member {Number}      - 点击响应范围 */\n    _this.approximate = configs.approximate || APPROXIMATE;\n    /** @member {Number}      - 起点终点在 x 方向最小的跨度 */\n    _this.minSpanX = configs.minSpanX || 0;\n    /** @member {Number}      - 起点终点在 y 方向最小的跨度 */\n    _this.minSpanY = configs.minSpanY || 0;\n    /** @member {Number[]}      - 虚线数组 */\n    _this.lineDash = configs.lineDash;\n    _this.lineWidth = configs.lineWidth || 1;\n    /** @member {Boolean}      - 双向箭头 */\n    _this.doubleLink = configs.doubleLink;\n    /** @member {String}      - 连线上的文字字体 */\n    _this.fontFamily = configs.fontFamily = \'-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Tahoma,Arial,Noto Sans,PingFang SC,Microsoft YaHei,Hiragino Sans GB,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji\';\n    /** @member {Number}      - 连线上的文字大小 */\n    _this.fontSize = configs.fontSize || \'12px\';\n    /** @member {String}      - 连线上的文字 */\n    _this.content = configs.content || \'\';\n    /** @member {Boolean}      - 是否为自连接 */\n    _this.isSelf = !!configs.isSelf;\n    return _this;\n  }\n\n  // getColor() {\n  //     if(this._isTargeting) {\n  //         return this.hoverStyle;\n  //     }\n  //     return this.defaultStyle;\n  // }\n\n  // _calculateAnchorPoints() {\n  //     let start;\n  //     let end;\n  //     if(this.fromDir !== undefined) {\n  //         start = {\n  //             dir: this.fromDir,\n  //             p: this.from.getIntersectionsInFourDimension()[this.fromDir],\n  //         }\n  //     } else {\n  //         start = this.from.calculateIntersectionInFourDimension(this.to.getCenter(), \'from\');\n  //     }\n  //     if(this.toDir !== undefined) {\n  //         end = {\n  //             dir: this.toDir,\n  //             p: this.to.getIntersectionsInFourDimension()[this.toDir],\n  //         }\n  //     } else {\n  //         end = this.to.calculateIntersectionInFourDimension(this.from.getCenter(), \'to\');\n  //     }\n\n  //     // const start = this.from.calculateIntersectionInFourDimension(this.to.getCenter(), \'from\');\n  //     // const end = this.to.calculateIntersectionInFourDimension(this.from.getCenter(), \'to\');\n  //     const p1 = start.p;\n  //     const p2 = end.p;\n  //     const points = bezierPoints(p1, p2, start.dir, end.dir, this.anticlock);\n\n  //     this._cachePoints = [...p1, ...points]\n  // }\n  bezier_link_createClass(BezierLink, [{\n    key: "_calculateAnchorPoints",\n    value: function _calculateAnchorPoints() {\n      var dmsfrom = this.from.getIntersectionsInFourDimension();\n      var dmsto = this.to.getIntersectionsInFourDimension();\n      if (this.isSelf) {\n        var points = bezierPoints(dmsfrom[this.fromDir], dmsto[DIRECTION.SELF], this.fromDir, DIRECTION.BOTTOM, this.minSpanX, this.minSpanY);\n        this._cachePoints = [].concat(bezier_link_toConsumableArray(dmsfrom[this.fromDir]), bezier_link_toConsumableArray(points));\n        this._cacheAngle = [this.fromDir, DIRECTION.BOTTOM];\n      } else if (this.fromDir !== undefined && this.toDir !== undefined) {\n        var _points = bezierPoints(dmsfrom[this.fromDir], dmsto[this.toDir], this.fromDir, this.toDir, this.minSpanX, this.minSpanY);\n        this._cachePoints = [].concat(bezier_link_toConsumableArray(dmsfrom[this.fromDir]), bezier_link_toConsumableArray(_points));\n        this._cacheAngle = [this.fromDir, this.toDir];\n      } else {\n        var meta = minIntersectionBetweenNodes(dmsfrom, dmsto);\n        var _points2 = bezierPoints(meta.fromP, meta.toP, meta.fromDir, meta.toDir);\n        this._cachePoints = [].concat(bezier_link_toConsumableArray(meta.fromP), bezier_link_toConsumableArray(_points2));\n        this._cacheAngle = [meta.fromDir, meta.toDir];\n      }\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      this._calculateAnchorPoints();\n      var points = this._cachePoints;\n      var angle = getBezierAngle.apply(null, [1].concat(bezier_link_toConsumableArray(points)));\n      ctx.fillStyle = ctx.strokeStyle = this.backgroundColor;\n      ctx.lineWidth = this.lineWidth;\n      if (this.doubleLink) {\n        var beginAngle = (this._cacheAngle[0] + 2) % 4 * 90 * bezier_link_PIINRATIO;\n        ctx.beginPath();\n        ctx.translate(points[0], points[1]);\n        ctx.rotate(beginAngle);\n        ctx.moveTo(5, 0);\n        ctx.lineTo(0, -4);\n        ctx.lineTo(0, 4);\n        ctx.lineTo(5, 0);\n        ctx.fill();\n        ctx.rotate(-beginAngle);\n        ctx.translate(-points[0], -points[1]);\n      }\n      ctx.beginPath();\n      ctx.moveTo(points[0], points[1]);\n      ctx.bezierCurveTo.apply(ctx, bezier_link_toConsumableArray(points.slice(2)));\n      if (this.lineDash) {\n        ctx.save();\n        ctx.setLineDash(this.lineDash);\n      }\n      ctx.stroke();\n      if (this.lineDash) {\n        ctx.restore();\n      }\n      ctx.beginPath();\n      ctx.translate(points[6], points[7]);\n      ctx.rotate(angle);\n      ctx.moveTo(5, 0);\n      ctx.lineTo(0, -4);\n      ctx.lineTo(0, 4);\n      ctx.lineTo(5, 0);\n      ctx.fill();\n      ctx.rotate(-angle);\n      ctx.translate(-points[6], -points[7]);\n      if (this.content) {\n        ctx.beginPath();\n        var hasFlip = points[0] > points[6];\n        var _bezierPoint = bezierPoint(0.5, points),\n          _bezierPoint2 = bezier_link_slicedToArray(_bezierPoint, 3),\n          x = _bezierPoint2[0],\n          y = _bezierPoint2[1],\n          _angle = _bezierPoint2[2];\n        ctx.translate(x, y);\n        ctx.rotate(_angle);\n        if (hasFlip) {\n          ctx.rotate(Math.PI);\n        }\n        ctx.font = "".concat(this.fontSize, " ").concat(this.fontFamily);\n        ctx.textAlign = \'center\';\n        ctx.fillText(this.content, 0, -(parseInt(this.fontSize) || 12) / 4);\n        if (hasFlip) {\n          ctx.rotate(Math.PI);\n        }\n        ctx.rotate(-_angle);\n        ctx.translate(-x, -y);\n      }\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      if (!this._cachePoints) return false;\n      var points = this._cachePoints;\n      var dist = distToBezierSegmentSquared(point, points);\n      return dist < this.approximate;\n    }\n  }]);\n  return BezierLink;\n}(base_link);\n/* harmony default export */ const bezier_link = (BezierLink);\n;// CONCATENATED MODULE: ./src/core/layout/linear-layout.js\nfunction linear_layout_typeof(obj) { "@babel/helpers - typeof"; return linear_layout_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, linear_layout_typeof(obj); }\nfunction linear_layout_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction linear_layout_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, linear_layout_toPropertyKey(descriptor.key), descriptor); } }\nfunction linear_layout_createClass(Constructor, protoProps, staticProps) { if (protoProps) linear_layout_defineProperties(Constructor.prototype, protoProps); if (staticProps) linear_layout_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction linear_layout_toPropertyKey(arg) { var key = linear_layout_toPrimitive(arg, "string"); return linear_layout_typeof(key) === "symbol" ? key : String(key); }\nfunction linear_layout_toPrimitive(input, hint) { if (linear_layout_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (linear_layout_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n/**\n * 线性布局配置\n * @typedef {Object} LinearLayout~Configs\n * @property {string} direction     - 排列方向 默认 vertical\n * @property {number} gap           - 边距, 默认是 5\n * @property {string} alignment     - 垂直排列方向对齐方式 默认 center\n * @property {string} justify       - 排列方向对齐方式 默认 center\n */\n/**\n    线性布局\n\n    排列方向\n    direction:\n        + vertical 从上至下排布\n        + horizontal 从左至右排布\n    \n    不重叠，中线对齐\n    只针对当前的 group\n\n    对齐方式\n    alignment: \n        + start 主轴左侧对齐\n        + center 主轴对齐\n        + end   主轴右侧对齐\n    justify: \n        + start 开始时对齐\n        + center 居中对齐\n        + end   末尾对齐\n        + space-between 平均分配空间对齐\n\n * @constructor LinearLayout\n * @implements {Layout}\n * @param {LinearLayout~Configs} configs - 配置\n */\nvar LinearLayout = /*#__PURE__*/function () {\n  function LinearLayout() {\n    var _configs$gap;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    linear_layout_classCallCheck(this, LinearLayout);\n    /** @member {string}  - 排列方向 默认 vertical */\n    this.direction = configs.direction || \'vertical\';\n    /** @member {number}  - 边距, 默认是 5 */\n    this.gap = (_configs$gap = configs.gap) !== null && _configs$gap !== void 0 ? _configs$gap : 5;\n    /** @member {string}  - 垂直排列方向对齐方式 默认 center */\n    this.alignment = configs.alignment || \'center\';\n    /** @member {string}  - 排列方向对齐方式 默认 center */\n    this.justify = configs.justify || \'center\';\n    // this.widthSetByParent =  configs.width === \'100%\'\n    this._rawConfigs = configs;\n  }\n  linear_layout_createClass(LinearLayout, [{\n    key: "reflow",\n    value: function reflow(group) {\n      var _this = this;\n      var stack = group._stack.filter(function (instance) {\n        return instance.visible && !instance.absolutePosition;\n      });\n      var absoluteStack = group._stack.filter(function (instance) {\n        return instance.visible && instance.absolutePosition;\n      });\n      var groupWidth = group.width - group.padding.left - group.padding.right;\n      if (this.direction === \'vertical\') {\n        var reduceHeight = 0;\n        var lastInstanceHeight = 0;\n        var maxWidth = 0;\n        var allHeight = 0;\n        var childAll = stack.concat(absoluteStack);\n        childAll.forEach(function (instance, idx) {\n          if (instance.display === \'block\') {\n            instance.width = 0;\n            // instance.definedWidth = maxWidth;\n            instance.resetChildrenPosition();\n            instance.reflow();\n            instance._getBoundingGroupRect();\n          }\n        });\n        stack.forEach(function (instance, idx) {\n          var _instance$getBounding = instance.getBoundingDimension(),\n            width = _instance$getBounding.width,\n            height = _instance$getBounding.height;\n          // console.log(height, instance.type);\n          var gap = idx > 0 ? _this.gap : 0;\n          if (instance.display !== \'outstretch\') {\n            maxWidth = Math.max(width, maxWidth);\n          }\n          allHeight += height + gap;\n          reduceHeight += height / 2 + gap + lastInstanceHeight;\n          lastInstanceHeight = height / 2;\n          instance.anchor = [0, reduceHeight];\n        });\n        childAll.forEach(function (instance, idx) {\n          if (instance.display === \'block\') {\n            // instance.definedWidth = maxWidth;\n            instance.resetChildrenPosition();\n            instance.width = maxWidth;\n            instance.reflow();\n            // instance._getBoundingGroupRect();\n          } else if (instance.display === \'outstretch\') {\n            var w = group._belongs.width - group._belongs.padding.left - group._belongs.padding.right;\n            instance.resetChildrenPosition();\n            instance.width = Math.max(w, maxWidth);\n            instance.reflow();\n          }\n        });\n        maxWidth = Math.max(groupWidth, maxWidth);\n        allHeight = allHeight / 2;\n        if (this.alignment === \'start\') {\n          stack.forEach(function (instance, idx) {\n            var _instance$getBounding2 = instance.getBoundingDimension(),\n              width = _instance$getBounding2.width;\n            instance.anchor[0] = -(maxWidth - width) / 2;\n            instance.anchor[1] -= allHeight;\n            // console.log(maxWidth, width, instance.anchor[0])\n          });\n        }\n\n        if (this.alignment === \'end\') {\n          stack.forEach(function (instance, idx) {\n            var _instance$getBounding3 = instance.getBoundingDimension(),\n              width = _instance$getBounding3.width;\n            instance.anchor[0] = (maxWidth - width) / 2;\n            instance.anchor[1] -= allHeight;\n          });\n        }\n        if (this.alignment === \'center\') {\n          stack.forEach(function (instance, idx) {\n            var _instance$getBounding4 = instance.getBoundingDimension(),\n              width = _instance$getBounding4.width;\n            instance.anchor[1] -= allHeight;\n          });\n        }\n      }\n      if (this.direction === \'horizontal\') {\n        var reduceWidth = 0;\n        var lastInstanceWidth = 0;\n        var maxHeight = 0;\n        var allWidth = 0;\n        var allPureWidth = 0;\n        stack.forEach(function (instance, idx) {\n          var _instance$getBounding5 = instance.getBoundingDimension(),\n            width = _instance$getBounding5.width,\n            height = _instance$getBounding5.height;\n          var gap = idx > 0 ? _this.gap : 0;\n          maxHeight = Math.max(height, maxHeight);\n          allWidth += width + gap;\n          allPureWidth += width;\n          reduceWidth += width / 2 + gap + lastInstanceWidth;\n          lastInstanceWidth = width / 2;\n          instance.anchor = [reduceWidth, 0];\n        });\n        if (this.justify === \'start\') {\n          var withdraw = groupWidth / 2;\n          stack.forEach(function (instance, idx) {\n            instance.anchor[0] -= withdraw;\n          });\n        }\n        if (this.justify === \'end\') {\n          var _withdraw = groupWidth / 2 - allWidth;\n          stack.forEach(function (instance, idx) {\n            instance.anchor[0] += _withdraw;\n          });\n        }\n        if (this.justify === \'center\') {\n          var _withdraw2 = allWidth / 2;\n          stack.forEach(function (instance, idx) {\n            instance.anchor[0] -= _withdraw2;\n          });\n        }\n        if (this.justify === \'space-between\' && stack.length > 1) {\n          var width = Math.max(groupWidth, allWidth);\n          var gapAverage = (width - allWidth) / (stack.length - 1);\n          var _withdraw3 = width / 2;\n          stack.forEach(function (instance, idx) {\n            instance.anchor[0] += gapAverage * idx - _withdraw3;\n          });\n        }\n        if (this.alignment === \'start\') {\n          stack.forEach(function (instance, idx) {\n            var _instance$getBounding6 = instance.getBoundingDimension(),\n              height = _instance$getBounding6.height;\n            instance.anchor[1] = -(maxHeight - height) / 2;\n          });\n        }\n        if (this.alignment === \'end\') {\n          stack.forEach(function (instance, idx) {\n            var _instance$getBounding7 = instance.getBoundingDimension(),\n              height = _instance$getBounding7.height;\n            instance.anchor[1] = (maxHeight - height) / 2;\n          });\n        }\n      }\n      if (absoluteStack.length) {\n        if (group.display === \'block\') {\n          group.getBoundingDimension();\n        } else {\n          group._getBoundingGroupRect();\n        }\n        var WIDTH = group.width / 2;\n        var HEIGHT = group.height / 2;\n        var shifty = (group.padding.top - group.padding.bottom) / 2;\n        var shiftx = (group.padding.left - group.padding.right) / 2;\n        absoluteStack.forEach(function (instance) {\n          instance.anchor = _this._resolveAbsoluteAnchor(instance.absolutePosition, instance, WIDTH, HEIGHT, shiftx, shifty);\n        });\n      }\n    }\n  }, {\n    key: "_resolveAbsoluteAnchor",\n    value: function _resolveAbsoluteAnchor(config, instance, w, h, shiftx, shifty) {\n      var top = config.top,\n        right = config.right,\n        bottom = config.bottom,\n        left = config.left,\n        centerX = config.centerX,\n        centerY = config.centerY;\n      var _instance$getBounding8 = instance.getBoundingDimension(),\n        width = _instance$getBounding8.width,\n        height = _instance$getBounding8.height;\n      var hw = width / 2;\n      var hh = height / 2;\n      var y = 0;\n      var x = 0;\n      if (typeof top === \'number\') {\n        y = top + hh - h - shifty;\n      }\n      if (typeof right === \'number\') {\n        x = w - right - hw - shiftx;\n      }\n      if (typeof bottom === \'number\') {\n        y = h - bottom - hh - shifty;\n      }\n      if (typeof left === \'number\') {\n        x = left + hw - w - shiftx;\n      }\n      if (typeof centerX === \'number\') {\n        x = centerX;\n      }\n      if (typeof centerY === \'number\') {\n        y = centerY;\n      }\n      return [x, y];\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new LinearLayout(this._rawConfigs);\n    }\n  }]);\n  return LinearLayout;\n}();\n/* harmony default export */ const linear_layout = (LinearLayout);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/base/constants.js\nvar EDITOR_EVENTS = {\n  INPUT: \'input\',\n  CONTROL_CMD: \'control\'\n};\nvar KEYBOARD_INPUT = {\n  INPUT: \'input\',\n  COMPOSITION_START: \'compositionstart\',\n  COMPOSITION_UPDATE: \'compositionupdate\',\n  COMPOSITION_END: \'compositionend\',\n  ENTER: \'enter\',\n  DELETE: \'delete\',\n  BACKSPACE: \'backspace\'\n};\nvar KEYBOARD_COMMANDS = {\n  ARROW_LEFT: \'arrowLeft\',\n  ARROW_RIGHT: \'arrowRight\',\n  ARROW_UP: \'arrowUp\',\n  ARROW_DOWN: \'arrowDown\',\n  UNDO: \'undo\',\n  REDO: \'redo\',\n  SHIFT_DOWN: \'shift_down\',\n  SHIFT_UP: \'shift_up\',\n  CTRLA: \'ctrla\',\n  COPY: \'copy\',\n  CUT: \'cut\',\n  PASTE: \'paste\'\n};\nvar MOUSE_COMMANDS = {\n  START_EDIT: \'startedit\',\n  EDIT_CLICK: \'editclick\',\n  SHIFT_ON_CLICK: \'shiftonclick\',\n  DOUBLE_CLICK: \'doubleclick\'\n};\nvar OPERRATION = {\n  PLAININPUT: \'plaininput\',\n  SPACEINPUT: \'spaceinput\',\n  RETURNINPUT: \'returninput\',\n  CARETMOVEMENT: \'caretmovement\',\n  DELETE_IN_LINE: \'deleteinline\',\n  DELETE_IN_EDITAREA: \'deleteineditarea\',\n  ENSURE_DELETE: \'ensuredelete\',\n  SELECTION_DELETE: \'selectiondelete\',\n  SELECTION_INPUT: \'selectioninput\',\n  COMPOSITE_INSERT: \'compositeinsert\'\n};\n;// CONCATENATED MODULE: ./src/core/instance/text-group/base/shadow-input.js\nfunction shadow_input_typeof(obj) { "@babel/helpers - typeof"; return shadow_input_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, shadow_input_typeof(obj); }\nfunction shadow_input_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction shadow_input_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, shadow_input_toPropertyKey(descriptor.key), descriptor); } }\nfunction shadow_input_createClass(Constructor, protoProps, staticProps) { if (protoProps) shadow_input_defineProperties(Constructor.prototype, protoProps); if (staticProps) shadow_input_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction shadow_input_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) shadow_input_setPrototypeOf(subClass, superClass); }\nfunction shadow_input_createSuper(Derived) { var hasNativeReflectConstruct = shadow_input_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = shadow_input_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = shadow_input_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return shadow_input_possibleConstructorReturn(this, result); }; }\nfunction shadow_input_possibleConstructorReturn(self, call) { if (call && (shadow_input_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return shadow_input_assertThisInitialized(self); }\nfunction shadow_input_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction shadow_input_wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; shadow_input_wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !shadow_input_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return shadow_input_construct(Class, arguments, shadow_input_getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return shadow_input_setPrototypeOf(Wrapper, Class); }; return shadow_input_wrapNativeSuper(Class); }\nfunction shadow_input_construct(Parent, args, Class) { if (shadow_input_isNativeReflectConstruct()) { shadow_input_construct = Reflect.construct.bind(); } else { shadow_input_construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) shadow_input_setPrototypeOf(instance, Class.prototype); return instance; }; } return shadow_input_construct.apply(null, arguments); }\nfunction shadow_input_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction shadow_input_isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }\nfunction shadow_input_setPrototypeOf(o, p) { shadow_input_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return shadow_input_setPrototypeOf(o, p); }\nfunction shadow_input_getPrototypeOf(o) { shadow_input_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return shadow_input_getPrototypeOf(o); }\nfunction shadow_input_defineProperty(obj, key, value) { key = shadow_input_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction shadow_input_toPropertyKey(arg) { var key = shadow_input_toPrimitive(arg, "string"); return shadow_input_typeof(key) === "symbol" ? key : String(key); }\nfunction shadow_input_toPrimitive(input, hint) { if (shadow_input_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (shadow_input_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\nvar ShadowInput = /*#__PURE__*/function (_EventTarget) {\n  shadow_input_inherits(ShadowInput, _EventTarget);\n  var _super = shadow_input_createSuper(ShadowInput);\n  function ShadowInput(wrapper) {\n    var _this;\n    shadow_input_classCallCheck(this, ShadowInput);\n    _this = _super.call(this);\n    shadow_input_defineProperty(shadow_input_assertThisInitialized(_this), "_inputElement", null);\n    _this._inputElement = shadow_input_createInputElement(_this.controlCallback.bind(shadow_input_assertThisInitialized(_this)));\n    wrapper.append(_this._inputElement);\n    _this._inputElement.focus();\n    return _this;\n  }\n  shadow_input_createClass(ShadowInput, [{\n    key: "controlCallback",\n    value: function controlCallback(kind, data) {\n      switch (kind) {\n        case KEYBOARD_INPUT.INPUT:\n        case KEYBOARD_INPUT.COMPOSITION_START:\n        case KEYBOARD_INPUT.COMPOSITION_UPDATE:\n        case KEYBOARD_INPUT.COMPOSITION_END:\n        case KEYBOARD_INPUT.ENTER:\n        case KEYBOARD_INPUT.BACKSPACE:\n        case KEYBOARD_INPUT.DELETE:\n          this.dispatchEvent(new CustomEvent(EDITOR_EVENTS.INPUT, {\n            detail: {\n              kind: kind,\n              data: data\n            }\n          }));\n          break;\n        case KEYBOARD_COMMANDS.ARROW_LEFT:\n        case KEYBOARD_COMMANDS.ARROW_RIGHT:\n        case KEYBOARD_COMMANDS.ARROW_UP:\n        case KEYBOARD_COMMANDS.ARROW_DOWN:\n        case KEYBOARD_COMMANDS.CTRLA:\n        case KEYBOARD_COMMANDS.SHIFT_DOWN:\n        case KEYBOARD_COMMANDS.SHIFT_UP:\n        case KEYBOARD_COMMANDS.UNDO:\n        case KEYBOARD_COMMANDS.REDO:\n        case KEYBOARD_COMMANDS.COPY:\n        case KEYBOARD_COMMANDS.CUT:\n        case KEYBOARD_COMMANDS.PASTE:\n          this.dispatchEvent(new CustomEvent(EDITOR_EVENTS.CONTROL_CMD, {\n            detail: {\n              kind: kind,\n              data: data\n            }\n          }));\n          break;\n      }\n    }\n  }, {\n    key: "focus",\n    value: function focus() {\n      this._inputElement.focus({\n        preventScroll: true\n      });\n    }\n  }, {\n    key: "syncPosition",\n    value: function syncPosition(x, y) {\n      this._inputElement.style.transform = "translate(".concat(x, "px, ").concat(y, "px)");\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      if (this.removeLisenter) {\n        this.removeLisenter();\n      }\n      this._inputElement.remove();\n    }\n  }]);\n  return ShadowInput;\n}( /*#__PURE__*/shadow_input_wrapNativeSuper(EventTarget));\n/* harmony default export */ const shadow_input = (ShadowInput);\nfunction shadow_input_createInputElement(controlCallback) {\n  var input = document.createElement(\'input\');\n  input.setAttribute(\'style\', "\\n        width: 100px;\\n        position: absolute;\\n        left: 0;\\n        top: 0;\\n        border:none;\\n        opacity: 0;\\n        z-index: -1;\\n        contain: strict;");\n  input.setAttribute(\'tabindex\', -1);\n  input.setAttribute(\'spellcheck\', false);\n  input.setAttribute(\'autocorrect\', \'off\');\n  var stopInput = false;\n  var status = {\n    ctrlOn: false,\n    shiftOn: false\n  };\n  input.addEventListener(\'beforeinput\', function (e) {\n    e.preventDefault();\n    if (e.data) {\n      // content += e.data;\n      // renderContent();\n      if (!stopInput) {\n        controlCallback(KEYBOARD_INPUT.INPUT, e.data);\n      }\n    }\n  });\n  input.addEventListener(\'paste\', function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    var pasteContent = (e.clipboardData || window.clipboardData).getData("text");\n    controlCallback(KEYBOARD_COMMANDS.PASTE, pasteContent);\n  });\n  input.addEventListener(\'copy\', function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    controlCallback(KEYBOARD_COMMANDS.COPY, e);\n  });\n  input.addEventListener(\'cut\', function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    controlCallback(KEYBOARD_COMMANDS.CUT, e);\n  });\n  input.addEventListener(\'compositionstart\', function (e) {\n    controlCallback(KEYBOARD_INPUT.COMPOSITION_START);\n    stopInput = true;\n  });\n  input.addEventListener(\'compositionupdate\', function (e) {\n    controlCallback(KEYBOARD_INPUT.COMPOSITION_UPDATE, e.data);\n  });\n  input.addEventListener(\'compositionend\', function (e) {\n    controlCallback(KEYBOARD_INPUT.COMPOSITION_END, e.data);\n    input.value = \'\';\n    stopInput = false;\n  });\n  input.addEventListener(\'keyup\', function (event) {\n    if (stopInput) {\n      return;\n    }\n    switch (event.key) {\n      case "Shift":\n        controlCallback(KEYBOARD_COMMANDS.SHIFT_UP);\n        status.shiftOn = false;\n        break;\n      case "Meta":\n      case "Control":\n        status.ctrlOn = false;\n        break;\n    }\n  });\n  input.addEventListener(\'keydown\', function (event) {\n    if (stopInput) {\n      return;\n    }\n    switch (event.code) {\n      case "Enter":\n        controlCallback(KEYBOARD_INPUT.ENTER);\n        break;\n      case "Backspace":\n        controlCallback(KEYBOARD_INPUT.BACKSPACE);\n        break;\n      case "Delete":\n        controlCallback(KEYBOARD_INPUT.DELETE);\n        break;\n      case "ArrowLeft":\n        controlCallback(KEYBOARD_COMMANDS.ARROW_LEFT);\n        break;\n      case "ArrowRight":\n        controlCallback(KEYBOARD_COMMANDS.ARROW_RIGHT);\n        break;\n      case "ArrowDown":\n        controlCallback(KEYBOARD_COMMANDS.ARROW_DOWN);\n        break;\n      case "ArrowUp":\n        controlCallback(KEYBOARD_COMMANDS.ARROW_UP);\n        break;\n    }\n    switch (event.key) {\n      case "Shift":\n        controlCallback(KEYBOARD_COMMANDS.SHIFT_DOWN);\n        status.shiftOn = true;\n        break;\n      case "Meta":\n      case "Control":\n        status.ctrlOn = true;\n        break;\n      case \'a\':\n        if (status.ctrlOn) {\n          controlCallback(KEYBOARD_COMMANDS.CTRLA);\n        }\n        break;\n      // case \'c\':\n      //     if(status.ctrlOn) {\n      //         controlCallback(KEYBOARD_COMMANDS.CTRLC);\n      //     }\n      //     break; \n      // case \'v\':\n      //     if(status.ctrlOn) {\n      //         controlCallback(KEYBOARD_COMMANDS.CTRLV);\n      //     }\n      //     break;   \n      // case \'x\':\n      //     if(status.ctrlOn) {\n      //         controlCallback(KEYBOARD_COMMANDS.CTRLX);\n      //     }\n      //     break;\n      case \'y\':\n        if (status.ctrlOn) {\n          event.preventDefault();\n          controlCallback(KEYBOARD_COMMANDS.REDO);\n        }\n        break;\n      case \'z\':\n        if (status.ctrlOn && status.shiftOn) {\n          controlCallback(KEYBOARD_COMMANDS.REDO);\n        } else if (status.ctrlOn) {\n          controlCallback(KEYBOARD_COMMANDS.UNDO);\n        }\n        break;\n    }\n  });\n  return input;\n}\n;// CONCATENATED MODULE: ./src/core/instance/text-group/base/caret.js\nfunction caret_typeof(obj) { "@babel/helpers - typeof"; return caret_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, caret_typeof(obj); }\nfunction caret_toConsumableArray(arr) { return caret_arrayWithoutHoles(arr) || caret_iterableToArray(arr) || caret_unsupportedIterableToArray(arr) || caret_nonIterableSpread(); }\nfunction caret_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction caret_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return caret_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return caret_arrayLikeToArray(o, minLen); }\nfunction caret_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\nfunction caret_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return caret_arrayLikeToArray(arr); }\nfunction caret_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction caret_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction caret_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, caret_toPropertyKey(descriptor.key), descriptor); } }\nfunction caret_createClass(Constructor, protoProps, staticProps) { if (protoProps) caret_defineProperties(Constructor.prototype, protoProps); if (staticProps) caret_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction caret_defineProperty(obj, key, value) { key = caret_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction caret_toPropertyKey(arg) { var key = caret_toPrimitive(arg, "string"); return caret_typeof(key) === "symbol" ? key : String(key); }\nfunction caret_toPrimitive(input, hint) { if (caret_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (caret_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nvar Caret = /*#__PURE__*/function () {\n  function Caret() {\n    caret_classCallCheck(this, Caret);\n    caret_defineProperty(this, "_row", 0);\n    caret_defineProperty(this, "_column", [0, 0]);\n    caret_defineProperty(this, "_status", {\n      show: true,\n      anime: null,\n      lastElapsed: 0,\n      refreshElapsed: false\n    });\n  }\n  caret_createClass(Caret, [{\n    key: "setRow",\n    value: function setRow(row) {\n      this._row = row;\n    }\n  }, {\n    key: "setColumn",\n    value: function setColumn(columnoridx, column) {\n      if (column !== undefined) {\n        this._column[columnoridx] = column;\n      } else {\n        this._column = columnoridx;\n      }\n    }\n  }, {\n    key: "getRow",\n    value: function getRow() {\n      return this._row;\n    }\n  }, {\n    key: "getColumn",\n    value: function getColumn(idx) {\n      if (idx !== undefined) {\n        return this._column[idx];\n      }\n      return this._column;\n    }\n  }, {\n    key: "animate",\n    value: function animate(jflow) {\n      var _this = this;\n      this._status.anime = jflow.requestJFlowAnime(function (elapsed) {\n        var lastElapsed = _this._status.lastElapsed;\n        if (_this._status.refreshElapsed) {\n          _this._status.lastElapsed = elapsed;\n          _this._status.refreshElapsed = false;\n        }\n        if (elapsed - lastElapsed > 500) {\n          _this._status.show = !_this._status.show;\n          _this._status.lastElapsed = elapsed;\n        }\n      });\n    }\n  }, {\n    key: "cancelAnimate",\n    value: function cancelAnimate() {\n      this._status.anime.cancel();\n      Object.assign(this._status, {\n        show: true,\n        anime: null,\n        lastElapsed: 0\n      });\n    }\n  }, {\n    key: "isShow",\n    value: function isShow() {\n      return this._status.show;\n    }\n  }, {\n    key: "refresh",\n    value: function refresh() {\n      Object.assign(this._status, {\n        show: true,\n        refreshElapsed: true\n      });\n    }\n  }, {\n    key: "toRange",\n    value: function toRange() {\n      return [this._row].concat(caret_toConsumableArray(this._column));\n    }\n  }, {\n    key: "fromRange",\n    value: function fromRange(range) {\n      this._row = range[0];\n      this._column = range.slice(1);\n    }\n  }]);\n  return Caret;\n}();\n/* harmony default export */ const caret = (Caret);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/utils.js\n\nfunction calculateOffsetByWidth(offx, textmeta, fontSize, fontFamily, spaceHolder) {\n  var content = textmeta.getRenderSource(spaceHolder);\n  var maxL = content.length - 1;\n  if (textmeta.width === 0) {\n    return 0;\n  }\n  var allwidth = textmeta.width;\n  var idx = Math.floor(offx / allwidth * maxL);\n  requestCacheCanvas(function (ctx) {\n    ctx.font = "".concat(fontSize, " ").concat(fontFamily);\n    var g1, g2;\n    var lastidx;\n    var c = content.substring(0, idx);\n    var c1 = content.substring(idx - 1, idx);\n    var c2 = content.substring(idx, idx + 1);\n    var w = ctx.measureText(c).width;\n    var w1 = ctx.measureText(c1).width;\n    var w2 = ctx.measureText(c2).width;\n    g1 = w - w1 / 2;\n    g2 = w + w2 / 2;\n    do {\n      if (g1 <= offx && g2 >= offx) {\n        break;\n      }\n      if (g1 > offx) {\n        // 左侧少了\n        var spanw = g2 - offx;\n        lastidx = idx;\n        if (spanw < 100) {\n          idx -= 1;\n        } else {\n          idx -= Math.floor(spanw / g2 * lastidx);\n        }\n        c = content.substring(idx, lastidx);\n        w -= ctx.measureText(c).width;\n      } else if (g2 < offx) {\n        // 右侧少了\n        var _spanw = offx - g1;\n        lastidx = idx;\n        if (_spanw < 100) {\n          idx += 1;\n        } else {\n          idx += Math.floor(_spanw / (allwidth - g1) * (maxL - lastidx));\n        }\n        c = content.substring(lastidx, idx);\n        w += ctx.measureText(c).width;\n      }\n      c1 = content.substring(idx - 1, idx);\n      c2 = content.substring(idx, idx + 1);\n      w1 = ctx.measureText(c1).width;\n      w2 = ctx.measureText(c2).width;\n      g1 = w - w1 / 2;\n      g2 = w + w2 / 2;\n    } while (idx >= 0 && idx <= maxL);\n  });\n  return idx;\n}\n;// CONCATENATED MODULE: ./src/core/instance/text-group/storage/index.js\nfunction storage_typeof(obj) { "@babel/helpers - typeof"; return storage_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, storage_typeof(obj); }\nfunction storage_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction storage_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, storage_toPropertyKey(descriptor.key), descriptor); } }\nfunction storage_createClass(Constructor, protoProps, staticProps) { if (protoProps) storage_defineProperties(Constructor.prototype, protoProps); if (staticProps) storage_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction storage_defineProperty(obj, key, value) { key = storage_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction storage_toPropertyKey(arg) { var key = storage_toPrimitive(arg, "string"); return storage_typeof(key) === "symbol" ? key : String(key); }\nfunction storage_toPrimitive(input, hint) { if (storage_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (storage_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\nvar Area = /*#__PURE__*/function () {\n  function Area() {\n    storage_classCallCheck(this, Area);\n    storage_defineProperty(this, "_lines", []);\n  }\n  storage_createClass(Area, [{\n    key: "get",\n    value: function get(idx) {\n      return this._lines[idx];\n    }\n  }, {\n    key: "getLineAbove",\n    value: function getLineAbove(offsetY) {\n      var row = 0;\n      var lines = this._lines;\n      while (row < lines.length) {\n        if (lines[row].reduceHeight > offsetY) {\n          break;\n        }\n        row++;\n      }\n      return Math.min(row, lines.length - 1);\n    }\n  }, {\n    key: "truncate",\n    value: function truncate(configs) {\n      var l = Line.create(configs);\n      this._lines = [l];\n      return l;\n    }\n  }, {\n    key: "push",\n    value: function push(line) {\n      this._lines.push(line);\n    }\n  }, {\n    key: "forEach",\n    value: function forEach(callback) {\n      this._lines.forEach(callback);\n    }\n  }, {\n    key: "length",\n    value: function length() {\n      return this._lines.length;\n    }\n  }]);\n  return Area;\n}();\nvar Line = /*#__PURE__*/function () {\n  function Line() {\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    storage_classCallCheck(this, Line);\n    storage_defineProperty(this, "width", 0);\n    storage_defineProperty(this, "anchorY", 0);\n    storage_defineProperty(this, "height", 0);\n    storage_defineProperty(this, "reduceHeight", 0);\n    storage_defineProperty(this, "_elements", []);\n    storage_defineProperty(this, "_elements", []);\n    Object.assign(this, configs);\n  }\n  storage_createClass(Line, [{\n    key: "get",\n    value: function get(idx) {\n      return this._elements[idx];\n    }\n  }, {\n    key: "length",\n    value: function length() {\n      return this._elements.length;\n    }\n  }, {\n    key: "insert",\n    value: function insert(idx, elem) {\n      this._elements.splice(idx, 0, elem);\n    }\n  }, {\n    key: "push",\n    value: function push(elem) {\n      this._elements.push(elem);\n    }\n  }, {\n    key: "tail",\n    value: function tail() {\n      return this._elements[this._elements.length - 1];\n    }\n  }, {\n    key: "copy",\n    value: function copy() {\n      return this._elements.slice();\n    }\n  }, {\n    key: "getColumnNearest",\n    value: function getColumnNearest(offsetX, elementSpace, fontSize, fontFamily, editor) {\n      var elements = this._elements;\n      if (offsetX >= this.width) {\n        var c = elements.length - 1;\n        var elem = elements[c];\n        var q = 0;\n        if (elem.type === \'text\') {\n          q = elem.source.length;\n        }\n        return [c, q];\n      } else {\n        var elem_idx = 0;\n        var last_c = 0;\n        var _c = 0;\n        var lastel = null;\n        while (elem_idx < elements.length - 1) {\n          last_c = _c;\n          var el = elements[elem_idx];\n          if (el.type !== \'text\') {\n            var doubleMargin = lastel && lastel.type === \'text\';\n            var margin = doubleMargin ? elementSpace * 2 : elementSpace;\n            _c += el.width + margin;\n          } else {\n            _c += el.width;\n          }\n          if (_c > offsetX) {\n            lastel = el;\n            break;\n          }\n          lastel = el;\n          elem_idx++;\n        }\n        if (_c <= offsetX) {\n          last_c = _c;\n        }\n        var textmeta = elements[elem_idx];\n        if (textmeta.type === \'text\') {\n          var offx = offsetX - last_c;\n          var idx = calculateOffsetByWidth(offx, textmeta, fontSize, fontFamily, editor.spaceHolder);\n          return [elem_idx, idx];\n        } else {\n          var _offx = offsetX - last_c;\n          if (_offx > lastel.width / 2) {\n            return [elem_idx + 1, 0];\n          } else {\n            return [elem_idx, 0];\n          }\n        }\n      }\n    }\n  }, {\n    key: "forEach",\n    value: function forEach(callback) {\n      this._elements.forEach(callback);\n    }\n  }], [{\n    key: "create",\n    value: function create(configs) {\n      var l = new Line(configs);\n      return l;\n    }\n  }]);\n  return Line;\n}();\nvar FlattenTextElements = /*#__PURE__*/function () {\n  function FlattenTextElements() {\n    storage_classCallCheck(this, FlattenTextElements);\n    storage_defineProperty(this, "_textElements", []);\n    storage_defineProperty(this, "_records", []);\n    storage_defineProperty(this, "_caretRecord", null);\n  }\n  storage_createClass(FlattenTextElements, [{\n    key: "insertBefore",\n    value: function insertBefore(anchor, elem) {\n      var idx = this.findIndex(anchor);\n      this.inersetAt(idx, elem);\n    }\n  }, {\n    key: "insertAfter",\n    value: function insertAfter(anchor, elem, needWrap) {\n      var idx = this.findIndex(anchor);\n      // const next = this.get(idx+1);\n      if (needWrap) {\n        elem.setNeedWrap(true);\n      }\n      this.inersetAt(idx + 1, elem);\n    }\n  }, {\n    key: "findIndex",\n    value: function findIndex(elem) {\n      return this._textElements.findIndex(function (el) {\n        return el === elem;\n      });\n    }\n  }, {\n    key: "get",\n    value: function get(idx) {\n      return this._textElements[idx];\n    }\n  }, {\n    key: "from",\n    value: function from(elements) {\n      this._textElements = elements;\n    }\n  }, {\n    key: "inersetAt",\n    value: function inersetAt(idx, elem) {\n      this.splice(idx, 0, elem);\n    }\n  }, {\n    key: "push",\n    value: function push(elem) {\n      this.splice(this.length(), 0, elem);\n    }\n  }, {\n    key: "remove",\n    value: function remove(idx) {\n      this.splice(idx, 1);\n    }\n  }, {\n    key: "splice",\n    value: function splice() {\n      var _this$_textElements;\n      var removed = (_this$_textElements = this._textElements).splice.apply(_this$_textElements, arguments);\n      this._records.push({\n        op: \'splice\',\n        args: arguments,\n        removed: removed\n      });\n    }\n  }, {\n    key: "slice",\n    value: function slice() {\n      var _this$_textElements2;\n      return (_this$_textElements2 = this._textElements).slice.apply(_this$_textElements2, arguments);\n    }\n  }, {\n    key: "copy",\n    value: function copy() {\n      return this._textElements.slice();\n    }\n  }, {\n    key: "isEmpty",\n    value: function isEmpty() {\n      return this._textElements.length === 1 && this._textElements[0].source === \'\';\n    }\n  }, {\n    key: "forEach",\n    value: function forEach(callback) {\n      this._textElements.forEach(callback);\n    }\n  }, {\n    key: "tail",\n    value: function tail() {\n      return this._textElements[this._textElements.length - 1];\n    }\n  }, {\n    key: "filter",\n    value: function filter(callback) {\n      return this._textElements.filter(callback);\n    }\n  }, {\n    key: "length",\n    value: function length() {\n      return this._textElements.length;\n    }\n  }, {\n    key: "startRecord",\n    value: function startRecord() {\n      this._caretRecord = {\n        before: null,\n        after: null\n      };\n      this._records = [];\n      return this._records;\n    }\n  }, {\n    key: "getRecord",\n    value: function getRecord() {\n      return this._records;\n    }\n  }, {\n    key: "recordBeforeCaret",\n    value: function recordBeforeCaret(caret) {\n      this._caretRecord.before = caret.toRange();\n    }\n  }, {\n    key: "recordAfterCaret",\n    value: function recordAfterCaret(caret) {\n      this._caretRecord.after = caret.toRange();\n    }\n  }, {\n    key: "getCaretRecord",\n    value: function getCaretRecord() {\n      return this._caretRecord;\n    }\n  }, {\n    key: "collectRecords",\n    value: function collectRecords() {\n      return this._records;\n    }\n  }], [{\n    key: "create",\n    value: function create(elements) {\n      var _e = new FlattenTextElements();\n      _e.from(elements);\n      return _e;\n    }\n  }]);\n  return FlattenTextElements;\n}();\nvar TextElement = /*#__PURE__*/function () {\n  function TextElement(type, source) {\n    storage_classCallCheck(this, TextElement);\n    storage_defineProperty(this, "needWrap", false);\n    storage_defineProperty(this, "width", 0);\n    storage_defineProperty(this, "reduceWidth", 0);\n    storage_defineProperty(this, "height", 0);\n    storage_defineProperty(this, "anchorX", 0);\n    storage_defineProperty(this, "anchorY", 0);\n    storage_defineProperty(this, "dirty", true);\n    storage_defineProperty(this, "isTail", false);\n    storage_defineProperty(this, "_spaceRecords", []);\n    storage_defineProperty(this, "_spacedContentSegmnent", []);\n    storage_defineProperty(this, "_returnSymbol", {\n      symbol: \'↲\',\n      width: 0\n    });\n    this.type = type;\n    this.source = source;\n  }\n  storage_createClass(TextElement, [{\n    key: "getRenderSource",\n    value: function getRenderSource(spaceHolder) {\n      var content = this.source;\n      if (spaceHolder.enable) {\n        return content.replace(/\\s/g, spaceHolder.spacePlaceholder);\n      }\n      return content;\n    }\n  }, {\n    key: "setSourceWithRecord",\n    value: function setSourceWithRecord(source, spaceHolder, records) {\n      var lastSource = this.source;\n      this.setSource(source, spaceHolder);\n      if (records) {\n        records.push({\n          op: \'setSource\',\n          args: [this, source, lastSource]\n        });\n      }\n    }\n  }, {\n    key: "setSource",\n    value: function setSource(source, spaceHolder) {\n      this.source = source;\n      this.dirty = true;\n      if (spaceHolder.enable) {\n        var r = this._spaceRecords;\n        var p = spaceHolder.spacePlaceholder;\n        r.length = 0;\n        var lastOffset;\n        source.replace(/\\s/g, function (_, offset) {\n          if (lastOffset === undefined) {\n            lastOffset = offset;\n            r.push(offset);\n          }\n          if (offset - lastOffset > 1) {\n            r.push(lastOffset);\n            r.push(offset);\n          }\n          lastOffset = offset;\n          return p;\n        });\n        if (lastOffset !== undefined) {\n          r.push(lastOffset);\n        }\n      }\n    }\n  }, {\n    key: "setNeedWrap",\n    value: function setNeedWrap(needWrap, records) {\n      var lastWrap = this.needWrap;\n      this.needWrap = needWrap;\n      if (lastWrap !== needWrap && records) {\n        records.push({\n          op: \'setNeedWrap\',\n          args: [this, needWrap, lastWrap]\n        });\n      }\n    }\n  }, {\n    key: "shift",\n    value: function shift(offset, step) {\n      if (this.type === \'text\') {\n        var content = this.source;\n        var l = content.length;\n        var nextOffset = offset + step;\n        if (nextOffset < 0) {\n          return \'prev\';\n        }\n        if (nextOffset > l) {\n          //- ((isTail || this.needWrap) ? 0 : 1)) {\n          return \'next\';\n        }\n        return \'self\';\n      } else {\n        if (step > 0) {\n          return \'next\';\n        }\n        if (step < 0) {\n          return \'prev\';\n        }\n      }\n    }\n  }, {\n    key: "tailOffset",\n    value: function tailOffset() {\n      if (this.type === \'text\') {\n        if (this.needWrap || this.isTail) {\n          return this.source.length;\n        } else {\n          return Math.max(0, this.source.length - 1);\n        }\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: "headOffset",\n    value: function headOffset() {\n      return 0;\n    }\n  }, {\n    key: "preCalculateText",\n    value: function preCalculateText(ctx, spaceHolder) {\n      var content = this.getRenderSource(spaceHolder);\n      this.width = ctx.measureText(content).width;\n      this.dirty = false;\n      if (spaceHolder.enable) {\n        var s_width = ctx.measureText(spaceHolder.spacePlaceholder).width;\n        this._returnSymbol.width = ctx.measureText(this._returnSymbol.symbol).width;\n        var r2 = this._spacedContentSegmnent;\n        var lastOffset = 0;\n        r2.length = 0;\n        if (this._spaceRecords.length) {\n          var r = this._spaceRecords;\n          var l = r.length;\n          var i = 0;\n          while (i < l) {\n            var f = r[i++];\n            var t = r[i++];\n            var q = content.substring(lastOffset, f);\n            r2.push([q, ctx.measureText(q).width, \'text\']);\n            r2.push([content.substring(f, t + 1), (t - f + 1) * s_width, \'placeholder\']);\n            lastOffset = t + 1;\n          }\n        }\n        if (lastOffset < content.length) {\n          var _q = content.substring(lastOffset);\n          r2.push([_q, ctx.measureText(_q).width, \'text\']);\n        }\n        if (this.needWrap) {\n          this.width += this._returnSymbol.width;\n        }\n      }\n    }\n  }, {\n    key: "render",\n    value: function render(ctx, spaceHolder, textColor) {\n      var _this = this;\n      if (spaceHolder.enable) {\n        var hw = this.width / 2;\n        var _w = -hw + this.anchorX;\n        var spacePlaceholderColor = spaceHolder.spacePlaceholderColor;\n        this._spacedContentSegmnent.forEach(function (seg) {\n          ctx.fillStyle = seg[2] === \'text\' ? textColor : spacePlaceholderColor;\n          var t = seg[1] / 2;\n          _w += t;\n          ctx.fillText(seg[0], _w, _this.anchorY);\n          _w += t;\n        });\n        if (this.needWrap) {\n          ctx.save();\n          ctx.font = spaceHolder.returnFont;\n          ctx.fillStyle = spacePlaceholderColor;\n          ctx.fillText(this._returnSymbol.symbol, _w + this._returnSymbol.width / 2, this.anchorY);\n          ctx.restore();\n        }\n        return;\n      }\n      ctx.fillText(this.source, this.anchorX, this.anchorY);\n    }\n  }]);\n  return TextElement;\n}();\n;// CONCATENATED MODULE: ./src/core/instance/text-group/base/range.js\nfunction range_typeof(obj) { "@babel/helpers - typeof"; return range_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, range_typeof(obj); }\nfunction range_slicedToArray(arr, i) { return range_arrayWithHoles(arr) || range_iterableToArrayLimit(arr, i) || range_unsupportedIterableToArray(arr, i) || range_nonIterableRest(); }\nfunction range_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction range_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return range_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return range_arrayLikeToArray(o, minLen); }\nfunction range_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction range_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction range_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction range_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction range_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, range_toPropertyKey(descriptor.key), descriptor); } }\nfunction range_createClass(Constructor, protoProps, staticProps) { if (protoProps) range_defineProperties(Constructor.prototype, protoProps); if (staticProps) range_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction range_defineProperty(obj, key, value) { key = range_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction range_toPropertyKey(arg) { var key = range_toPrimitive(arg, "string"); return range_typeof(key) === "symbol" ? key : String(key); }\nfunction range_toPrimitive(input, hint) { if (range_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (range_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\nvar Range = /*#__PURE__*/function () {\n  function Range() {\n    range_classCallCheck(this, Range);\n    range_defineProperty(this, "_enable", false);\n    range_defineProperty(this, "_rangeFrom", null);\n    // [row, elem_idx, offset]\n    range_defineProperty(this, "_rangeTo", null);\n    // [row, elem_idx, offset]\n    range_defineProperty(this, "_initialRange", null);\n  }\n  range_createClass(Range, [{\n    key: "setInitialRange",\n    value: function setInitialRange(initialRange) {\n      this._initialRange = initialRange;\n    }\n  }, {\n    key: "getRangeFrom",\n    value: function getRangeFrom() {\n      return this._rangeFrom;\n    }\n  }, {\n    key: "getRangeTo",\n    value: function getRangeTo() {\n      return this._rangeTo;\n    }\n  }, {\n    key: "isEnable",\n    value: function isEnable() {\n      return this._enable;\n    }\n  }, {\n    key: "enable",\n    value: function enable() {\n      this._enable = true;\n    }\n  }, {\n    key: "disable",\n    value: function disable() {\n      this._enable = false;\n    }\n  }, {\n    key: "handleCaret",\n    value: function handleCaret(caret) {\n      var _this$_rangeTo = range_slicedToArray(this._rangeTo, 3),\n        a = _this$_rangeTo[0],\n        b = _this$_rangeTo[1],\n        c = _this$_rangeTo[2];\n      caret.setRow(a);\n      caret.setColumn([b, c]);\n    }\n  }, {\n    key: "setRange",\n    value: function setRange(another) {\n      var a = this._initialRange;\n      if (this._compareRange(a, another)) {\n        this._rangeFrom = a;\n        this._rangeTo = another;\n      } else {\n        this._rangeFrom = another;\n        this._rangeTo = a;\n      }\n    }\n  }, {\n    key: "_compareRange",\n    value: function _compareRange(r1, r2) {\n      if (r1[0] > r2[0]) {\n        return false;\n      }\n      if (r1[0] === r2[0] && r1[1] > r2[1]) {\n        return false;\n      }\n      if (r1[0] === r2[0] && r1[1] === r2[1] && r1[2] > r2[2]) {\n        return false;\n      }\n      return true;\n    }\n\n    // TODO \n  }, {\n    key: "getRangeCopy",\n    value: function getRangeCopy(editor) {\n      if (this._enable) {\n        var area = editor._area;\n        var caret = editor._caret;\n        var rangeFrom = this._rangeFrom;\n        var rangeTo = this._rangeTo;\n        var elemFrom = area.get(rangeFrom[0]).get(rangeFrom[1]);\n        var elemTo = area.get(rangeTo[0]).get(rangeTo[1]);\n        if (elemFrom === elemTo) {\n          var c = elemFrom.source;\n          return c.substring(rangeFrom[2], rangeTo[2]);\n        }\n        var flattenTxtElem = editor._flattenTxtElem;\n        var preContent = \'\';\n        var afterContent = \'\';\n        var fromIdx = flattenTxtElem.findIndex(elemFrom);\n        var toIdx = flattenTxtElem.findIndex(elemTo);\n        var elems = flattenTxtElem.slice(fromIdx, toIdx + 1);\n        var elements = elems.slice(1, elems.length - 1).filter(function (el) {\n          return el.type === \'text\';\n        });\n        preContent = elemFrom.source.substring(rangeFrom[2]);\n        afterContent = elemTo.source.substring(0, rangeTo[2]);\n        var content = preContent;\n        if (elemFrom.needWrap) {\n          content += \'\\n\';\n        }\n        elements.forEach(function (el) {\n          content += el.source;\n          if (el.needWrap) {\n            content += \'\\n\';\n          }\n        });\n        return content + afterContent;\n      }\n    }\n  }, {\n    key: "delete",\n    value: function _delete(editor, records) {\n      if (this._enable) {\n        var area = editor._area;\n        var caret = editor._caret;\n        var rangeFrom = this._rangeFrom;\n        var rangeTo = this._rangeTo;\n        var elemFrom = area.get(rangeFrom[0]).get(rangeFrom[1]);\n        var elemTo = area.get(rangeTo[0]).get(rangeTo[1]);\n        var _rangeFrom = range_slicedToArray(rangeFrom, 3),\n          row = _rangeFrom[0],\n          elem_idx = _rangeFrom[1],\n          offset = _rangeFrom[2];\n        records.push({\n          op: \'range\',\n          args: [rangeFrom.slice(), rangeTo.slice()]\n        });\n        if (elemFrom === elemTo) {\n          var c = elemFrom.source;\n          elemFrom.setSourceWithRecord(c.substring(0, rangeFrom[2]) + c.substring(rangeTo[2]), editor.spaceHolder, records);\n        } else {\n          var flattenTxtElem = editor._flattenTxtElem;\n          var preContent = \'\';\n          var afterContent = \'\';\n          var preElement;\n          var afterElement;\n          var fromIdx = flattenTxtElem.findIndex(elemFrom);\n          var toIdx = flattenTxtElem.findIndex(elemTo);\n          var endTextNeedWrap = false;\n          if (elemFrom.type === \'text\') {\n            preContent = elemFrom.source.substring(0, rangeFrom[2]);\n          } else {\n            preElement = flattenTxtElem.get(fromIdx - 1);\n          }\n          if (elemTo.type === \'text\') {\n            afterContent = elemTo.source.substring(rangeTo[2]);\n            endTextNeedWrap = elemTo.needWrap;\n          } else {\n            afterElement = flattenTxtElem.get(toIdx - 1);\n          }\n          if (preElement) {\n            flattenTxtElem.splice(fromIdx, toIdx - fromIdx + 1);\n            if (preElement.type === \'text\') {\n              if (preElement.needWrap) {\n                row -= 1;\n              } else {\n                elem_idx -= 1;\n              }\n              offset = preElement.source.length;\n              preElement.setSourceWithRecord(preElement.source + afterContent, editor.spaceHolder, records);\n              preElement.setNeedWrap(endTextNeedWrap, records);\n            } else {\n              var t = new TextElement(\'text\', preContent + afterContent);\n              t.setNeedWrap(endTextNeedWrap, records);\n              flattenTxtElem.splice(fromIdx, 0, t);\n            }\n          } else {\n            flattenTxtElem.splice(fromIdx, toIdx - fromIdx);\n            if (afterElement) {\n              var _t = new TextElement(\'text\', preContent);\n              flattenTxtElem.splice(fromIdx, 0, _t);\n            } else {\n              elemTo.setSourceWithRecord(preContent + afterContent, editor.spaceHolder, records);\n            }\n          }\n          if (flattenTxtElem.length() === 0) {\n            // elem_idx = 0;\n            flattenTxtElem.push(new TextElement(\'text\', \'\'));\n          }\n        }\n        this.disable();\n        caret.setRow(row);\n        caret.setColumn([elem_idx, offset]);\n      }\n    }\n  }]);\n  return Range;\n}();\n/* harmony default export */ const range = (Range);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/undoredo.js\nfunction undoredo_toConsumableArray(arr) { return undoredo_arrayWithoutHoles(arr) || undoredo_iterableToArray(arr) || undoredo_unsupportedIterableToArray(arr) || undoredo_nonIterableSpread(); }\nfunction undoredo_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction undoredo_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return undoredo_arrayLikeToArray(arr); }\nfunction _toArray(arr) { return undoredo_arrayWithHoles(arr) || undoredo_iterableToArray(arr) || undoredo_unsupportedIterableToArray(arr) || undoredo_nonIterableRest(); }\nfunction undoredo_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\nfunction undoredo_slicedToArray(arr, i) { return undoredo_arrayWithHoles(arr) || undoredo_iterableToArrayLimit(arr, i) || undoredo_unsupportedIterableToArray(arr, i) || undoredo_nonIterableRest(); }\nfunction undoredo_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction undoredo_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return undoredo_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return undoredo_arrayLikeToArray(o, minLen); }\nfunction undoredo_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction undoredo_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction undoredo_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction undoredo_typeof(obj) { "@babel/helpers - typeof"; return undoredo_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, undoredo_typeof(obj); }\nfunction undoredo_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction undoredo_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, undoredo_toPropertyKey(descriptor.key), descriptor); } }\nfunction undoredo_createClass(Constructor, protoProps, staticProps) { if (protoProps) undoredo_defineProperties(Constructor.prototype, protoProps); if (staticProps) undoredo_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction undoredo_defineProperty(obj, key, value) { key = undoredo_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction undoredo_toPropertyKey(arg) { var key = undoredo_toPrimitive(arg, "string"); return undoredo_typeof(key) === "symbol" ? key : String(key); }\nfunction undoredo_toPrimitive(input, hint) { if (undoredo_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (undoredo_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction isSetSourceBatch(x) {\n  return x.length === 1 && x[0].op === \'setSource\';\n}\nvar UndoRedo = /*#__PURE__*/function () {\n  function UndoRedo() {\n    undoredo_classCallCheck(this, UndoRedo);\n    undoredo_defineProperty(this, "_undo", []);\n    undoredo_defineProperty(this, "_redo", []);\n    undoredo_defineProperty(this, "_editor", null);\n  }\n  undoredo_createClass(UndoRedo, [{\n    key: "write",\n    value: function write(x, caretRecord) {\n      if (x.length === 0) {\n        return;\n      }\n      if (isSetSourceBatch(x)) {\n        var t = x[0];\n        var lastUndo = this.getLastUndo();\n        if (lastUndo && isSetSourceBatch(lastUndo._batch)) {\n          var q = lastUndo._batch[0];\n          if (q.args[0] === t.args[0]) {\n            q.args[1] = t.args[1];\n            lastUndo._caretMetaTo = caretRecord.after;\n            return;\n          }\n        }\n      }\n      var r = new BatchAction(x);\n      r._caretMetaFrom = caretRecord.before;\n      r._caretMetaTo = caretRecord.after;\n      this._undo.push(r);\n      if (this._undo.length > UndoRedo._length) {\n        this._undo.splice(0, 1);\n      }\n      if (this._redo.length) {\n        this._redo = [];\n      }\n    }\n  }, {\n    key: "getLastUndo",\n    value: function getLastUndo() {\n      return this._undo[this._undo.length - 1];\n    }\n  }, {\n    key: "undo",\n    value: function undo() {\n      var x = this._undo.pop();\n      if (x) {\n        x.undo(this._editor);\n        this._redo.push(x);\n      }\n      return x;\n    }\n  }, {\n    key: "redo",\n    value: function redo() {\n      var x = this._redo.pop();\n      while (x && x.SKIP_REDO) {\n        x = this._redo.pop();\n      }\n      if (x) {\n        x.redo(this._editor);\n        this._undo.push(x);\n      }\n      return x;\n    }\n  }]);\n  return UndoRedo;\n}();\nundoredo_defineProperty(UndoRedo, "_length", 50);\n\nvar BatchAction = /*#__PURE__*/function () {\n  function BatchAction(batch) {\n    undoredo_classCallCheck(this, BatchAction);\n    undoredo_defineProperty(this, "_batch", []);\n    undoredo_defineProperty(this, "_caretMetaFrom", null);\n    undoredo_defineProperty(this, "_caretMetaTo", null);\n    this._batch = batch;\n  }\n  undoredo_createClass(BatchAction, [{\n    key: "updateCaretMetaTo",\n    value: function updateCaretMetaTo(meta) {\n      this._caretMetaTo = meta;\n    }\n  }, {\n    key: "undo",\n    value: function undo(editor) {\n      this._batch.slice().reverse().forEach(function (action) {\n        switch (action.op) {\n          case \'range\':\n            var _action$args = undoredo_slicedToArray(action.args, 2),\n              rangeFrom = _action$args[0],\n              rangeTo = _action$args[1];\n            var range = editor._range;\n            range.setInitialRange(rangeFrom);\n            range.setRange(rangeTo);\n            range.enable();\n            break;\n          case \'setSource\':\n            var _action$args2 = undoredo_slicedToArray(action.args, 3),\n              elem = _action$args2[0],\n              s = _action$args2[1],\n              ls = _action$args2[2];\n            elem.setSource(ls, editor.spaceHolder);\n            break;\n          case \'setNeedWrap\':\n            var _action$args3 = undoredo_slicedToArray(action.args, 3),\n              o = _action$args3[0],\n              p = _action$args3[1],\n              q = _action$args3[2];\n            o.needWrap = q;\n            o.dirty = true;\n            break;\n          case \'splice\':\n            var flattenTxtElem = editor._flattenTxtElem;\n            var _action$args4 = _toArray(action.args),\n              a = _action$args4[0],\n              b = _action$args4[1],\n              c = _action$args4.slice(2);\n            var removed = action.removed;\n            var i = 0;\n            if (c) {\n              i = c.length;\n            }\n            flattenTxtElem.splice.apply(flattenTxtElem, [a, i].concat(undoredo_toConsumableArray(removed)));\n            break;\n        }\n      });\n      editor._caret.fromRange(this._caretMetaFrom);\n    }\n  }, {\n    key: "redo",\n    value: function redo(editor) {\n      this._batch.forEach(function (action) {\n        switch (action.op) {\n          case \'setSource\':\n            var _action$args5 = undoredo_slicedToArray(action.args, 3),\n              elem = _action$args5[0],\n              s = _action$args5[1],\n              ls = _action$args5[2];\n            elem.setSource(s, editor.spaceHolder);\n            break;\n          case \'setNeedWrap\':\n            var _action$args6 = undoredo_slicedToArray(action.args, 3),\n              o = _action$args6[0],\n              p = _action$args6[1],\n              q = _action$args6[2];\n            o.needWrap = p;\n            o.dirty = true;\n            break;\n          case \'splice\':\n            var flattenTxtElem = editor._flattenTxtElem;\n            flattenTxtElem.splice.apply(flattenTxtElem, undoredo_toConsumableArray(action.args));\n            break;\n        }\n      });\n      editor._caret.fromRange(this._caretMetaTo);\n    }\n  }]);\n  return BatchAction;\n}();\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/base.js\nfunction base_typeof(obj) { "@babel/helpers - typeof"; return base_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, base_typeof(obj); }\nfunction base_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction base_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, base_toPropertyKey(descriptor.key), descriptor); } }\nfunction base_createClass(Constructor, protoProps, staticProps) { if (protoProps) base_defineProperties(Constructor.prototype, protoProps); if (staticProps) base_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction base_toPropertyKey(arg) { var key = base_toPrimitive(arg, "string"); return base_typeof(key) === "symbol" ? key : String(key); }\nfunction base_toPrimitive(input, hint) { if (base_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (base_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nvar Command = /*#__PURE__*/function () {\n  function Command(editor) {\n    base_classCallCheck(this, Command);\n    this._editor = editor;\n  }\n  base_createClass(Command, [{\n    key: "exec",\n    value: function exec() {}\n  }], [{\n    key: "create",\n    value: function create(editor) {\n      return new this(editor);\n    }\n  }]);\n  return Command;\n}();\n/* harmony default export */ const base = (Command);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/movement.js\nfunction movement_typeof(obj) { "@babel/helpers - typeof"; return movement_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, movement_typeof(obj); }\nfunction movement_slicedToArray(arr, i) { return movement_arrayWithHoles(arr) || movement_iterableToArrayLimit(arr, i) || movement_unsupportedIterableToArray(arr, i) || movement_nonIterableRest(); }\nfunction movement_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction movement_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return movement_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return movement_arrayLikeToArray(o, minLen); }\nfunction movement_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction movement_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction movement_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction movement_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction movement_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, movement_toPropertyKey(descriptor.key), descriptor); } }\nfunction movement_createClass(Constructor, protoProps, staticProps) { if (protoProps) movement_defineProperties(Constructor.prototype, protoProps); if (staticProps) movement_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction movement_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) movement_setPrototypeOf(subClass, superClass); }\nfunction movement_setPrototypeOf(o, p) { movement_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return movement_setPrototypeOf(o, p); }\nfunction movement_createSuper(Derived) { var hasNativeReflectConstruct = movement_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = movement_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = movement_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return movement_possibleConstructorReturn(this, result); }; }\nfunction movement_possibleConstructorReturn(self, call) { if (call && (movement_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return movement_assertThisInitialized(self); }\nfunction movement_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction movement_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction movement_getPrototypeOf(o) { movement_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return movement_getPrototypeOf(o); }\nfunction movement_defineProperty(obj, key, value) { key = movement_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction movement_toPropertyKey(arg) { var key = movement_toPrimitive(arg, "string"); return movement_typeof(key) === "symbol" ? key : String(key); }\nfunction movement_toPrimitive(input, hint) { if (movement_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (movement_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\nvar ArrowLeftCommand = /*#__PURE__*/function (_Command) {\n  movement_inherits(ArrowLeftCommand, _Command);\n  var _super = movement_createSuper(ArrowLeftCommand);\n  function ArrowLeftCommand() {\n    movement_classCallCheck(this, ArrowLeftCommand);\n    return _super.apply(this, arguments);\n  }\n  movement_createClass(ArrowLeftCommand, [{\n    key: "exec",\n    value: function exec() {\n      var editor = this._editor;\n      editor._range.disable();\n      var flattenTxtElem = editor._flattenTxtElem;\n      var caret = editor._caret;\n      var row = caret.getRow();\n      var column = caret.getColumn();\n      var _column = movement_slicedToArray(column, 2),\n        elemidx = _column[0],\n        offset = _column[1];\n      var line = editor._area.get(row);\n      var element = line.get(elemidx);\n      var idx = flattenTxtElem.findIndex(element);\n      var result = element.shift(offset, -1);\n      switch (result) {\n        case \'prev\':\n          if (elemidx > 0) {\n            var el = line.get(elemidx - 1);\n            caret.setColumn([elemidx - 1, el.tailOffset()]);\n          } else if (idx > 0) {\n            var preRow = row - 1;\n            var preElemidx = editor._area.get(preRow).length() - 1;\n            var _offset = flattenTxtElem.get(idx - 1).tailOffset();\n            caret.setRow(preRow);\n            caret.setColumn([preElemidx, _offset]);\n          }\n          break;\n        case \'self\':\n          caret.setColumn(1, offset - 1);\n          break;\n      }\n      caret.refresh();\n      editor.syncShadowInputPosition();\n      editor._jflow._render();\n    }\n  }]);\n  return ArrowLeftCommand;\n}(base);\nmovement_defineProperty(ArrowLeftCommand, "_name", KEYBOARD_COMMANDS.ARROW_LEFT);\nvar ArrowRightCommand = /*#__PURE__*/function (_Command2) {\n  movement_inherits(ArrowRightCommand, _Command2);\n  var _super2 = movement_createSuper(ArrowRightCommand);\n  function ArrowRightCommand() {\n    movement_classCallCheck(this, ArrowRightCommand);\n    return _super2.apply(this, arguments);\n  }\n  movement_createClass(ArrowRightCommand, [{\n    key: "exec",\n    value: function exec() {\n      var editor = this._editor;\n      editor._range.disable();\n      var flattenTxtElem = editor._flattenTxtElem;\n      var caret = editor._caret;\n      var row = caret.getRow();\n      var column = caret.getColumn();\n      var _column2 = movement_slicedToArray(column, 2),\n        elemidx = _column2[0],\n        offset = _column2[1];\n      var line = editor._area.get(row);\n      var element = line.get(elemidx);\n      var idx = flattenTxtElem.findIndex(element);\n      var result = element.shift(offset, 1, idx === flattenTxtElem.length() - 1);\n      switch (result) {\n        case \'next\':\n          if (elemidx < line.length() - 1) {\n            var el = line.get(elemidx + 1);\n            if (element.type === \'text\' && el.type !== \'text\') {\n              caret.setColumn([elemidx + 2, el.headOffset()]);\n            } else {\n              caret.setColumn([elemidx + 1, el.headOffset()]);\n            }\n          } else if (idx < flattenTxtElem.length() - 1) {\n            var afterRow = row + 1;\n            var _offset2 = flattenTxtElem.get(idx + 1).headOffset();\n            caret.setRow(afterRow);\n            caret.setColumn([0, _offset2]);\n          }\n          break;\n        case \'self\':\n          caret.setColumn(1, offset + 1);\n          break;\n      }\n      caret.refresh();\n      editor.syncShadowInputPosition();\n      editor._jflow._render();\n    }\n  }]);\n  return ArrowRightCommand;\n}(base);\nmovement_defineProperty(ArrowRightCommand, "_name", KEYBOARD_COMMANDS.ARROW_RIGHT);\nvar ArrowUpCommand = /*#__PURE__*/function (_Command3) {\n  movement_inherits(ArrowUpCommand, _Command3);\n  var _super3 = movement_createSuper(ArrowUpCommand);\n  function ArrowUpCommand() {\n    movement_classCallCheck(this, ArrowUpCommand);\n    return _super3.apply(this, arguments);\n  }\n  movement_createClass(ArrowUpCommand, [{\n    key: "exec",\n    value: function exec() {\n      this._editor._range.disable();\n      var nextRow = this._editor._caret.getRow() - 1;\n      if (nextRow > -1) {\n        this._handler(nextRow);\n      }\n    }\n  }]);\n  return ArrowUpCommand;\n}(base);\nmovement_defineProperty(ArrowUpCommand, "_name", KEYBOARD_COMMANDS.ARROW_UP);\nvar ArrowDownCommand = /*#__PURE__*/function (_Command4) {\n  movement_inherits(ArrowDownCommand, _Command4);\n  var _super4 = movement_createSuper(ArrowDownCommand);\n  function ArrowDownCommand() {\n    movement_classCallCheck(this, ArrowDownCommand);\n    return _super4.apply(this, arguments);\n  }\n  movement_createClass(ArrowDownCommand, [{\n    key: "exec",\n    value: function exec() {\n      this._editor._range.disable();\n      var nextRow = this._editor._caret.getRow() + 1;\n      if (nextRow < this._editor._area.length()) {\n        this._handler(nextRow);\n      }\n    }\n  }]);\n  return ArrowDownCommand;\n}(base);\nmovement_defineProperty(ArrowDownCommand, "_name", KEYBOARD_COMMANDS.ARROW_DOWN);\nvar _mixin = {\n  _handler: function _handler(nextRow) {\n    var editor = this._editor;\n    var caret = editor._caret;\n    var row = caret.getRow();\n    var column = caret.getColumn();\n    var _column3 = movement_slicedToArray(column, 2),\n      elemidx = _column3[0],\n      offset = _column3[1];\n    var area = editor._area;\n    var line = area.get(row);\n    var currElem = line.get(elemidx);\n    var currElemReduceWidth = currElem.reduceWidth;\n    if (offset > 0) {\n      currElemReduceWidth += editor.measureTextWidth(currElem.getRenderSource(editor.spaceHolder).substring(0, offset));\n    }\n    var nextLine = area.get(nextRow);\n    var nextColumn = nextLine.getColumnNearest(currElemReduceWidth, editor.elementSpace, editor.fontSize, editor.fontFamily, editor);\n    caret.setRow(nextRow);\n    caret.setColumn(nextColumn);\n    caret.refresh();\n    editor.syncShadowInputPosition();\n    editor._jflow._render();\n  }\n};\nObject.assign(ArrowUpCommand.prototype, _mixin);\nObject.assign(ArrowDownCommand.prototype, _mixin);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/input.js\nfunction input_typeof(obj) { "@babel/helpers - typeof"; return input_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, input_typeof(obj); }\nfunction input_slicedToArray(arr, i) { return input_arrayWithHoles(arr) || input_iterableToArrayLimit(arr, i) || input_unsupportedIterableToArray(arr, i) || input_nonIterableRest(); }\nfunction input_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction input_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return input_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return input_arrayLikeToArray(o, minLen); }\nfunction input_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction input_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction input_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction input_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction input_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, input_toPropertyKey(descriptor.key), descriptor); } }\nfunction input_createClass(Constructor, protoProps, staticProps) { if (protoProps) input_defineProperties(Constructor.prototype, protoProps); if (staticProps) input_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction input_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) input_setPrototypeOf(subClass, superClass); }\nfunction input_setPrototypeOf(o, p) { input_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return input_setPrototypeOf(o, p); }\nfunction input_createSuper(Derived) { var hasNativeReflectConstruct = input_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = input_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = input_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return input_possibleConstructorReturn(this, result); }; }\nfunction input_possibleConstructorReturn(self, call) { if (call && (input_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return input_assertThisInitialized(self); }\nfunction input_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction input_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction input_getPrototypeOf(o) { input_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return input_getPrototypeOf(o); }\nfunction input_defineProperty(obj, key, value) { key = input_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction input_toPropertyKey(arg) { var key = input_toPrimitive(arg, "string"); return input_typeof(key) === "symbol" ? key : String(key); }\nfunction input_toPrimitive(input, hint) { if (input_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (input_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n\nfunction _blandAdjacentElement(editor, elem1, elem2, defaultOffset, records) {\n  if (!elem1) {\n    return [defaultOffset, false];\n  }\n  if (elem1.type === \'text\' && elem2.type === \'text\') {\n    var offset = elem1.source.length;\n    elem1.setSourceWithRecord(elem1.source + elem2.source, editor.spaceHolder, records);\n    elem1.setNeedWrap(elem2.needWrap, records);\n    return [offset, true];\n  }\n  return [defaultOffset, false];\n}\nvar Input = /*#__PURE__*/function (_Command) {\n  input_inherits(Input, _Command);\n  var _super = input_createSuper(Input);\n  function Input() {\n    var _this;\n    input_classCallCheck(this, Input);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    input_defineProperty(input_assertThisInitialized(_this), "cacheIdx", null);\n    return _this;\n  }\n  input_createClass(Input, [{\n    key: "exec",\n    value: function exec(kind, data) {\n      var editor = this._editor;\n      var range = editor._range;\n      var caret = editor._caret;\n      var flattenTxtElem = editor._flattenTxtElem;\n      var undoredo = editor._undoredo;\n      var records = flattenTxtElem.startRecord();\n      flattenTxtElem.recordBeforeCaret(caret);\n      // let _afterRangeDelete = false;\n      if (range.isEnable()) {\n        range["delete"](editor, records);\n        if (kind === KEYBOARD_INPUT.BACKSPACE || kind === KEYBOARD_INPUT.DELETE) {\n          flattenTxtElem.collectRecords();\n          flattenTxtElem.recordAfterCaret(caret);\n          this._editor.refresh();\n          undoredo.write(records, flattenTxtElem.getCaretRecord());\n          return;\n        } else {\n          this._editor.refresh();\n          // _afterRangeDelete = true;\n        }\n      }\n\n      var row = caret.getRow();\n      var _caret$getColumn = caret.getColumn(),\n        _caret$getColumn2 = input_slicedToArray(_caret$getColumn, 2),\n        elem_idx = _caret$getColumn2[0],\n        offset = _caret$getColumn2[1];\n      var area = editor._area;\n      var line = area.get(row);\n      var element = line.get(elem_idx);\n      var preElem = line.get(elem_idx - 1);\n      var content = \'\';\n      if (element.type === \'text\') {\n        content = element.source;\n      } else if ((preElem === null || preElem === void 0 ? void 0 : preElem.type) === \'text\') {\n        content = preElem.source;\n        element = preElem;\n        offset = content.length;\n        elem_idx -= 1;\n        caret.setColumn([elem_idx, content.length]);\n      } else {\n        var newElement = new TextElement(\'text\', \'\');\n        flattenTxtElem.insertBefore(element, newElement);\n        element = newElement;\n      }\n      var preContent = content.substring(0, offset);\n      var afterContent;\n      if (this.cacheIdx) {\n        afterContent = content.substring(this.cacheIdx[1]);\n      } else {\n        afterContent = content.substring(offset);\n      }\n      switch (kind) {\n        case KEYBOARD_INPUT.INPUT:\n          // if(_afterRangeDelete) {\n          //     element = flattenTxtElem.get(0);\n          //     afterContent = \'\';\n          //     preContent = \'\';\n          // }\n          if (/\\r?[\\n\\t]/.test(data)) {\n            var rows = data.split(/\\r?[\\n\\t]/) || \'\';\n            // source = source.replace(/\\t/, \'\');\n            var idx = flattenTxtElem.findIndex(element);\n            var _lastNeedWrap = element.needWrap;\n            element.setSourceWithRecord(preContent + rows.shift(), editor.spaceHolder, records);\n            element.setNeedWrap(true, records);\n            var temp = [];\n            var tn;\n            var _row = row;\n            var col;\n            while (rows.length) {\n              tn = new TextElement(\'text\', rows.shift());\n              tn.needWrap = true;\n              temp.push(tn);\n              _row++;\n            }\n            col = tn.source.length;\n            tn.source += afterContent;\n            tn.needWrap = _lastNeedWrap;\n            temp.forEach(function (t, i) {\n              flattenTxtElem.inersetAt(idx + 1 + i, t);\n            });\n            caret.setRow(_row);\n            caret.setColumn([0, col]);\n          } else {\n            preContent += data;\n            caret.setColumn(1, caret.getColumn(1) + data.length);\n            element.setSourceWithRecord(preContent + afterContent, editor.spaceHolder, records);\n          }\n          break;\n        case KEYBOARD_INPUT.COMPOSITION_START:\n          this.cacheIdx = [preContent.length, preContent.length];\n          break;\n        case KEYBOARD_INPUT.COMPOSITION_UPDATE:\n          preContent = preContent.substring(0, this.cacheIdx[0]);\n          preContent += data;\n          element.setSourceWithRecord(preContent + afterContent, editor.spaceHolder, records);\n          var _t = this.cacheIdx[0] + data.length;\n          caret.setColumn(1, _t);\n          this.cacheIdx[1] = _t;\n          break;\n        case KEYBOARD_INPUT.COMPOSITION_END:\n          preContent = preContent.substring(0, this.cacheIdx[0]);\n          caret.setColumn(1, this.cacheIdx[0] + data.length);\n          this.cacheIdx = null;\n          preContent += data;\n          element.setSourceWithRecord(preContent + afterContent, editor.spaceHolder, records);\n          break;\n        case KEYBOARD_INPUT.ENTER:\n          var lastNeedWrap = element.needWrap;\n          element.setSourceWithRecord(preContent, editor.spaceHolder, records);\n          element.setNeedWrap(true, records);\n          var t = new TextElement(\'text\', afterContent);\n          flattenTxtElem.insertAfter(element, t, lastNeedWrap);\n          caret.setRow(row + 1);\n          caret.setColumn([0, 0]);\n          break;\n        case KEYBOARD_INPUT.BACKSPACE:\n          var result = element.shift(offset, -1);\n          switch (result) {\n            case \'prev\':\n              var _idx = flattenTxtElem.findIndex(element);\n              if (elem_idx > 0) {\n                // 行内\n                flattenTxtElem.splice(_idx - 1, 1);\n                _idx -= 1;\n                // element.setSource(afterContent, records);\n                // element.dirty = true;\n                var _blandAdjacentElement2 = _blandAdjacentElement(editor, flattenTxtElem.get(_idx - 1), element, 0, records),\n                  _blandAdjacentElement3 = input_slicedToArray(_blandAdjacentElement2, 2),\n                  _offset = _blandAdjacentElement3[0],\n                  deleteop = _blandAdjacentElement3[1];\n                if (deleteop) {\n                  flattenTxtElem.remove(_idx);\n                }\n                caret.setColumn([elem_idx - (_offset > 0 || deleteop ? 2 : 1), _offset]);\n              } else if (_idx > 0) {\n                // 换行了\n                var preRow = row - 1;\n                var preElemidx = area.get(preRow).length() - 1;\n                var _blandAdjacentElement4 = _blandAdjacentElement(editor, flattenTxtElem.get(_idx - 1), element, 0, records),\n                  _blandAdjacentElement5 = input_slicedToArray(_blandAdjacentElement4, 2),\n                  _offset2 = _blandAdjacentElement5[0],\n                  _deleteop = _blandAdjacentElement5[1];\n                if (_deleteop) {\n                  flattenTxtElem.remove(_idx);\n                }\n                caret.setRow(preRow);\n                caret.setColumn([preElemidx, _offset2]);\n              }\n              break;\n            case \'self\':\n              preContent = preContent.substring(0, preContent.length - 1);\n              caret.setColumn(1, caret.getColumn(1) - 1);\n              element.setSourceWithRecord(preContent + afterContent, editor.spaceHolder, records);\n              break;\n          }\n          break;\n        case KEYBOARD_INPUT.DELETE:\n          var shiftresult = element.shift(offset, 1);\n          switch (shiftresult) {\n            case \'next\':\n              var _idx2 = flattenTxtElem.findIndex(element);\n              if (elem_idx < line.length() - 1) {\n                // 行内\n                flattenTxtElem.splice(_idx2 + 1, 1);\n                var nextElem = flattenTxtElem.get(_idx2 + 1);\n                var _blandAdjacentElement6 = _blandAdjacentElement(element, nextElem, element.source.length, records),\n                  _blandAdjacentElement7 = input_slicedToArray(_blandAdjacentElement6, 2),\n                  _offset3 = _blandAdjacentElement7[0],\n                  _deleteop2 = _blandAdjacentElement7[1];\n                if (_deleteop2) {\n                  flattenTxtElem.remove(_idx2 + 1);\n                }\n                caret.setColumn([elem_idx, _offset3]);\n              } else if (_idx2 < flattenTxtElem.length() - 1) {\n                // 换行了\n                var _nextElem = flattenTxtElem.get(_idx2 + 1);\n                var _blandAdjacentElement8 = _blandAdjacentElement(element, _nextElem, element.source.length, records),\n                  _blandAdjacentElement9 = input_slicedToArray(_blandAdjacentElement8, 2),\n                  _offset4 = _blandAdjacentElement9[0],\n                  _deleteop3 = _blandAdjacentElement9[1];\n                if (_deleteop3) {\n                  flattenTxtElem.remove(_idx2 + 1);\n                }\n                caret.setColumn([elem_idx, _offset4]);\n              }\n              break;\n            case \'self\':\n              afterContent = afterContent.substring(1);\n              element.setSourceWithRecord(preContent + afterContent, editor.spaceHolder, records);\n              break;\n          }\n          break;\n      }\n      flattenTxtElem.collectRecords();\n      flattenTxtElem.recordAfterCaret(caret);\n      undoredo.write(records, flattenTxtElem.getCaretRecord());\n      this._editor.refresh();\n    }\n  }]);\n  return Input;\n}(base);\ninput_defineProperty(Input, "_name", EDITOR_EVENTS.INPUT);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/mouse.js\nfunction mouse_typeof(obj) { "@babel/helpers - typeof"; return mouse_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, mouse_typeof(obj); }\nfunction mouse_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction mouse_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, mouse_toPropertyKey(descriptor.key), descriptor); } }\nfunction mouse_createClass(Constructor, protoProps, staticProps) { if (protoProps) mouse_defineProperties(Constructor.prototype, protoProps); if (staticProps) mouse_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction mouse_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) mouse_setPrototypeOf(subClass, superClass); }\nfunction mouse_setPrototypeOf(o, p) { mouse_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return mouse_setPrototypeOf(o, p); }\nfunction mouse_createSuper(Derived) { var hasNativeReflectConstruct = mouse_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = mouse_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = mouse_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return mouse_possibleConstructorReturn(this, result); }; }\nfunction mouse_possibleConstructorReturn(self, call) { if (call && (mouse_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return mouse_assertThisInitialized(self); }\nfunction mouse_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction mouse_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction mouse_getPrototypeOf(o) { mouse_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return mouse_getPrototypeOf(o); }\nfunction mouse_defineProperty(obj, key, value) { key = mouse_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction mouse_toPropertyKey(arg) { var key = mouse_toPrimitive(arg, "string"); return mouse_typeof(key) === "symbol" ? key : String(key); }\nfunction mouse_toPrimitive(input, hint) { if (mouse_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (mouse_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n\nvar StartEditCommand = /*#__PURE__*/function (_Command) {\n  mouse_inherits(StartEditCommand, _Command);\n  var _super = mouse_createSuper(StartEditCommand);\n  function StartEditCommand() {\n    mouse_classCallCheck(this, StartEditCommand);\n    return _super.apply(this, arguments);\n  }\n  mouse_createClass(StartEditCommand, [{\n    key: "exec",\n    value: function exec() {\n      var editor = this._editor;\n      if (!this._startEdit()) {\n        return;\n      }\n      var jflow = editor._jflow;\n      editor.moveCaretByHitPoint();\n      editor.createShadowInput();\n      editor._caret.animate(jflow);\n      editor.syncShadowInputPosition();\n    }\n  }, {\n    key: "_startEdit",\n    value: function _startEdit() {\n      var flag = true;\n      var editor = this._editor;\n      editor.dispatchEvent(new events(\'edit\', {\n        target: editor,\n        preventDefault: function preventDefault() {\n          flag = false;\n        }\n      }));\n      return flag;\n    }\n  }]);\n  return StartEditCommand;\n}(base);\nmouse_defineProperty(StartEditCommand, "_name", MOUSE_COMMANDS.START_EDIT);\nvar EditClickCommand = /*#__PURE__*/function (_Command2) {\n  mouse_inherits(EditClickCommand, _Command2);\n  var _super2 = mouse_createSuper(EditClickCommand);\n  function EditClickCommand() {\n    mouse_classCallCheck(this, EditClickCommand);\n    return _super2.apply(this, arguments);\n  }\n  mouse_createClass(EditClickCommand, [{\n    key: "exec",\n    value: function exec() {\n      var editor = this._editor;\n      editor.moveCaretByHitPoint();\n      editor._caret.refresh();\n      editor.syncShadowInputPosition();\n      editor._range.disable();\n    }\n  }]);\n  return EditClickCommand;\n}(base);\nmouse_defineProperty(EditClickCommand, "_name", MOUSE_COMMANDS.EDIT_CLICK);\nvar DoubleClickCommand = /*#__PURE__*/function (_Command3) {\n  mouse_inherits(DoubleClickCommand, _Command3);\n  var _super3 = mouse_createSuper(DoubleClickCommand);\n  function DoubleClickCommand() {\n    mouse_classCallCheck(this, DoubleClickCommand);\n    return _super3.apply(this, arguments);\n  }\n  mouse_createClass(DoubleClickCommand, [{\n    key: "exec",\n    value: function exec() {\n      var editor = this._editor;\n      editor.moveCaretByHitPoint();\n      var caret = editor._caret;\n      var range = editor._range;\n      var area = editor._area;\n      var row = caret.getRow();\n      var line = area.get(row);\n      var elem_idx = line.length() - 1;\n      range.setInitialRange([row, 0, 0]);\n      range.setRange([row, elem_idx, line.tail().tailOffset()]);\n      range.handleCaret(caret);\n      range.enable();\n      editor.syncShadowInputPosition();\n    }\n  }]);\n  return DoubleClickCommand;\n}(base);\nmouse_defineProperty(DoubleClickCommand, "_name", MOUSE_COMMANDS.DOUBLE_CLICK);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/shift.js\nfunction shift_typeof(obj) { "@babel/helpers - typeof"; return shift_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, shift_typeof(obj); }\nfunction shift_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction shift_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, shift_toPropertyKey(descriptor.key), descriptor); } }\nfunction shift_createClass(Constructor, protoProps, staticProps) { if (protoProps) shift_defineProperties(Constructor.prototype, protoProps); if (staticProps) shift_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction shift_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) shift_setPrototypeOf(subClass, superClass); }\nfunction shift_setPrototypeOf(o, p) { shift_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return shift_setPrototypeOf(o, p); }\nfunction shift_createSuper(Derived) { var hasNativeReflectConstruct = shift_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = shift_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = shift_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return shift_possibleConstructorReturn(this, result); }; }\nfunction shift_possibleConstructorReturn(self, call) { if (call && (shift_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return shift_assertThisInitialized(self); }\nfunction shift_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction shift_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction shift_getPrototypeOf(o) { shift_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return shift_getPrototypeOf(o); }\nfunction shift_defineProperty(obj, key, value) { key = shift_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction shift_toPropertyKey(arg) { var key = shift_toPrimitive(arg, "string"); return shift_typeof(key) === "symbol" ? key : String(key); }\nfunction shift_toPrimitive(input, hint) { if (shift_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (shift_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\nvar ShiftUpCommand = /*#__PURE__*/function (_Command) {\n  shift_inherits(ShiftUpCommand, _Command);\n  var _super = shift_createSuper(ShiftUpCommand);\n  function ShiftUpCommand() {\n    shift_classCallCheck(this, ShiftUpCommand);\n    return _super.apply(this, arguments);\n  }\n  shift_createClass(ShiftUpCommand, [{\n    key: "exec",\n    value: function exec() {\n      var range = this._editor._range;\n      range.setInitialRange(null);\n      this._editor.toggleShift(false);\n    }\n  }]);\n  return ShiftUpCommand;\n}(base);\nshift_defineProperty(ShiftUpCommand, "_name", KEYBOARD_COMMANDS.SHIFT_UP);\nvar ShiftDownCommand = /*#__PURE__*/function (_Command2) {\n  shift_inherits(ShiftDownCommand, _Command2);\n  var _super2 = shift_createSuper(ShiftDownCommand);\n  function ShiftDownCommand() {\n    shift_classCallCheck(this, ShiftDownCommand);\n    return _super2.apply(this, arguments);\n  }\n  shift_createClass(ShiftDownCommand, [{\n    key: "exec",\n    value: function exec() {\n      var range = this._editor._range;\n      var caret = this._editor._caret;\n      range.setInitialRange(caret.toRange());\n      this._editor.toggleShift(true);\n    }\n  }]);\n  return ShiftDownCommand;\n}(base);\nshift_defineProperty(ShiftDownCommand, "_name", KEYBOARD_COMMANDS.SHIFT_DOWN);\nvar ShiftOnClickCommand = /*#__PURE__*/function (_Command3) {\n  shift_inherits(ShiftOnClickCommand, _Command3);\n  var _super3 = shift_createSuper(ShiftOnClickCommand);\n  function ShiftOnClickCommand() {\n    shift_classCallCheck(this, ShiftOnClickCommand);\n    return _super3.apply(this, arguments);\n  }\n  shift_createClass(ShiftOnClickCommand, [{\n    key: "exec",\n    value: function exec() {\n      var editor = this._editor;\n      editor.moveCaretByHitPoint();\n      var caret = this._editor._caret;\n      var range = this._editor._range;\n      range.setRange(caret.toRange());\n      range.enable();\n      range.handleCaret(caret);\n      caret.refresh();\n      editor.syncShadowInputPosition();\n    }\n  }]);\n  return ShiftOnClickCommand;\n}(base);\nshift_defineProperty(ShiftOnClickCommand, "_name", MOUSE_COMMANDS.SHIFT_ON_CLICK);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/ctrl.js\nfunction ctrl_typeof(obj) { "@babel/helpers - typeof"; return ctrl_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, ctrl_typeof(obj); }\nfunction ctrl_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction ctrl_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, ctrl_toPropertyKey(descriptor.key), descriptor); } }\nfunction ctrl_createClass(Constructor, protoProps, staticProps) { if (protoProps) ctrl_defineProperties(Constructor.prototype, protoProps); if (staticProps) ctrl_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction ctrl_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) ctrl_setPrototypeOf(subClass, superClass); }\nfunction ctrl_setPrototypeOf(o, p) { ctrl_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return ctrl_setPrototypeOf(o, p); }\nfunction ctrl_createSuper(Derived) { var hasNativeReflectConstruct = ctrl_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = ctrl_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = ctrl_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return ctrl_possibleConstructorReturn(this, result); }; }\nfunction ctrl_possibleConstructorReturn(self, call) { if (call && (ctrl_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return ctrl_assertThisInitialized(self); }\nfunction ctrl_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction ctrl_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction ctrl_getPrototypeOf(o) { ctrl_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return ctrl_getPrototypeOf(o); }\nfunction ctrl_defineProperty(obj, key, value) { key = ctrl_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction ctrl_toPropertyKey(arg) { var key = ctrl_toPrimitive(arg, "string"); return ctrl_typeof(key) === "symbol" ? key : String(key); }\nfunction ctrl_toPrimitive(input, hint) { if (ctrl_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (ctrl_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\nvar CtrlACommand = /*#__PURE__*/function (_Command) {\n  ctrl_inherits(CtrlACommand, _Command);\n  var _super = ctrl_createSuper(CtrlACommand);\n  function CtrlACommand() {\n    ctrl_classCallCheck(this, CtrlACommand);\n    return _super.apply(this, arguments);\n  }\n  ctrl_createClass(CtrlACommand, [{\n    key: "exec",\n    value: function exec() {\n      var editor = this._editor;\n      var caret = editor._caret;\n      var range = editor._range;\n      var area = editor._area;\n      var row = area.length() - 1;\n      var line = area.get(row);\n      var elem_idx = line.length() - 1;\n      range.setInitialRange([0, 0, 0]);\n      range.setRange([row, elem_idx, line.tail().tailOffset()]);\n      range.handleCaret(caret);\n      range.enable();\n      editor.syncShadowInputPosition();\n    }\n  }]);\n  return CtrlACommand;\n}(base);\nctrl_defineProperty(CtrlACommand, "_name", KEYBOARD_COMMANDS.CTRLA);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/undoredo.js\nfunction command_undoredo_typeof(obj) { "@babel/helpers - typeof"; return command_undoredo_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, command_undoredo_typeof(obj); }\nfunction command_undoredo_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction command_undoredo_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, command_undoredo_toPropertyKey(descriptor.key), descriptor); } }\nfunction command_undoredo_createClass(Constructor, protoProps, staticProps) { if (protoProps) command_undoredo_defineProperties(Constructor.prototype, protoProps); if (staticProps) command_undoredo_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction undoredo_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) undoredo_setPrototypeOf(subClass, superClass); }\nfunction undoredo_setPrototypeOf(o, p) { undoredo_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return undoredo_setPrototypeOf(o, p); }\nfunction undoredo_createSuper(Derived) { var hasNativeReflectConstruct = undoredo_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = undoredo_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = undoredo_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return undoredo_possibleConstructorReturn(this, result); }; }\nfunction undoredo_possibleConstructorReturn(self, call) { if (call && (command_undoredo_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return undoredo_assertThisInitialized(self); }\nfunction undoredo_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction undoredo_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction undoredo_getPrototypeOf(o) { undoredo_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return undoredo_getPrototypeOf(o); }\nfunction command_undoredo_defineProperty(obj, key, value) { key = command_undoredo_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction command_undoredo_toPropertyKey(arg) { var key = command_undoredo_toPrimitive(arg, "string"); return command_undoredo_typeof(key) === "symbol" ? key : String(key); }\nfunction command_undoredo_toPrimitive(input, hint) { if (command_undoredo_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (command_undoredo_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\nvar UndoCommand = /*#__PURE__*/function (_Command) {\n  undoredo_inherits(UndoCommand, _Command);\n  var _super = undoredo_createSuper(UndoCommand);\n  function UndoCommand() {\n    command_undoredo_classCallCheck(this, UndoCommand);\n    return _super.apply(this, arguments);\n  }\n  command_undoredo_createClass(UndoCommand, [{\n    key: "exec",\n    value: function exec() {\n      this._editor._range.disable();\n      this._editor._undoredo.undo();\n      this._editor.refresh();\n    }\n  }]);\n  return UndoCommand;\n}(base);\ncommand_undoredo_defineProperty(UndoCommand, "_name", KEYBOARD_COMMANDS.UNDO);\nvar RedoCommand = /*#__PURE__*/function (_Command2) {\n  undoredo_inherits(RedoCommand, _Command2);\n  var _super2 = undoredo_createSuper(RedoCommand);\n  function RedoCommand() {\n    command_undoredo_classCallCheck(this, RedoCommand);\n    return _super2.apply(this, arguments);\n  }\n  command_undoredo_createClass(RedoCommand, [{\n    key: "exec",\n    value: function exec() {\n      this._editor._range.disable();\n      this._editor._undoredo.redo();\n      this._editor.refresh();\n    }\n  }]);\n  return RedoCommand;\n}(base);\ncommand_undoredo_defineProperty(RedoCommand, "_name", KEYBOARD_COMMANDS.REDO);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/clipboard.js\nfunction clipboard_typeof(obj) { "@babel/helpers - typeof"; return clipboard_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, clipboard_typeof(obj); }\nfunction clipboard_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction clipboard_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, clipboard_toPropertyKey(descriptor.key), descriptor); } }\nfunction clipboard_createClass(Constructor, protoProps, staticProps) { if (protoProps) clipboard_defineProperties(Constructor.prototype, protoProps); if (staticProps) clipboard_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction clipboard_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) clipboard_setPrototypeOf(subClass, superClass); }\nfunction clipboard_setPrototypeOf(o, p) { clipboard_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return clipboard_setPrototypeOf(o, p); }\nfunction clipboard_createSuper(Derived) { var hasNativeReflectConstruct = clipboard_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = clipboard_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = clipboard_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return clipboard_possibleConstructorReturn(this, result); }; }\nfunction clipboard_possibleConstructorReturn(self, call) { if (call && (clipboard_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return clipboard_assertThisInitialized(self); }\nfunction clipboard_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction clipboard_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction clipboard_getPrototypeOf(o) { clipboard_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return clipboard_getPrototypeOf(o); }\nfunction clipboard_defineProperty(obj, key, value) { key = clipboard_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction clipboard_toPropertyKey(arg) { var key = clipboard_toPrimitive(arg, "string"); return clipboard_typeof(key) === "symbol" ? key : String(key); }\nfunction clipboard_toPrimitive(input, hint) { if (clipboard_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (clipboard_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n\nvar CopyCommand = /*#__PURE__*/function (_Command) {\n  clipboard_inherits(CopyCommand, _Command);\n  var _super = clipboard_createSuper(CopyCommand);\n  function CopyCommand() {\n    clipboard_classCallCheck(this, CopyCommand);\n    return _super.apply(this, arguments);\n  }\n  clipboard_createClass(CopyCommand, [{\n    key: "exec",\n    value: function exec(event) {\n      var editor = this._editor;\n      var range = editor._range;\n      var content = range.getRangeCopy(editor);\n      if (content) {\n        event.clipboardData.setData("text/plain", content);\n      }\n    }\n  }]);\n  return CopyCommand;\n}(base);\nclipboard_defineProperty(CopyCommand, "_name", KEYBOARD_COMMANDS.COPY);\nvar CutCommand = /*#__PURE__*/function (_Command2) {\n  clipboard_inherits(CutCommand, _Command2);\n  var _super2 = clipboard_createSuper(CutCommand);\n  function CutCommand() {\n    clipboard_classCallCheck(this, CutCommand);\n    return _super2.apply(this, arguments);\n  }\n  clipboard_createClass(CutCommand, [{\n    key: "exec",\n    value: function exec(event) {\n      var editor = this._editor;\n      var range = editor._range;\n      var content = range.getRangeCopy(editor);\n      if (content) {\n        event.clipboardData.setData("text/plain", content);\n      }\n      if (range.isEnable()) {\n        var cmd = editor.commands.get(EDITOR_EVENTS.INPUT);\n        cmd.exec(KEYBOARD_INPUT.BACKSPACE);\n      }\n    }\n  }]);\n  return CutCommand;\n}(base);\nclipboard_defineProperty(CutCommand, "_name", KEYBOARD_COMMANDS.CUT);\nvar PasteCommand = /*#__PURE__*/function (_Command3) {\n  clipboard_inherits(PasteCommand, _Command3);\n  var _super3 = clipboard_createSuper(PasteCommand);\n  function PasteCommand() {\n    clipboard_classCallCheck(this, PasteCommand);\n    return _super3.apply(this, arguments);\n  }\n  clipboard_createClass(PasteCommand, [{\n    key: "exec",\n    value: function exec(pasteContent) {\n      var editor = this._editor;\n      if (pasteContent) {\n        var _preventDefault = false;\n        editor.dispatchEvent(new events(\'paste\', {\n          content: pasteContent,\n          preventDefault: function preventDefault() {\n            _preventDefault = true;\n          }\n        }));\n        if (!_preventDefault) {\n          var cmd = editor.commands.get(EDITOR_EVENTS.INPUT);\n          cmd.exec(KEYBOARD_INPUT.INPUT, pasteContent);\n        }\n      }\n    }\n  }]);\n  return PasteCommand;\n}(base);\nclipboard_defineProperty(PasteCommand, "_name", KEYBOARD_COMMANDS.PASTE);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/index.js\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./src/core/instance/text-group/text-group.js\nfunction text_group_typeof(obj) { "@babel/helpers - typeof"; return text_group_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, text_group_typeof(obj); }\nfunction text_group_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction text_group_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? text_group_ownKeys(Object(source), !0).forEach(function (key) { text_group_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : text_group_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction text_group_defineProperty(obj, key, value) { key = text_group_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction text_group_slicedToArray(arr, i) { return text_group_arrayWithHoles(arr) || text_group_iterableToArrayLimit(arr, i) || text_group_unsupportedIterableToArray(arr, i) || text_group_nonIterableRest(); }\nfunction text_group_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction text_group_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction text_group_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction text_group_toConsumableArray(arr) { return text_group_arrayWithoutHoles(arr) || text_group_iterableToArray(arr) || text_group_unsupportedIterableToArray(arr) || text_group_nonIterableSpread(); }\nfunction text_group_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction text_group_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return text_group_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return text_group_arrayLikeToArray(o, minLen); }\nfunction text_group_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\nfunction text_group_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return text_group_arrayLikeToArray(arr); }\nfunction text_group_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction text_group_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction text_group_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, text_group_toPropertyKey(descriptor.key), descriptor); } }\nfunction text_group_createClass(Constructor, protoProps, staticProps) { if (protoProps) text_group_defineProperties(Constructor.prototype, protoProps); if (staticProps) text_group_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction text_group_toPropertyKey(arg) { var key = text_group_toPrimitive(arg, "string"); return text_group_typeof(key) === "symbol" ? key : String(key); }\nfunction text_group_toPrimitive(input, hint) { if (text_group_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (text_group_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction text_group_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) text_group_setPrototypeOf(subClass, superClass); }\nfunction text_group_setPrototypeOf(o, p) { text_group_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return text_group_setPrototypeOf(o, p); }\nfunction text_group_createSuper(Derived) { var hasNativeReflectConstruct = text_group_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = text_group_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = text_group_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return text_group_possibleConstructorReturn(this, result); }; }\nfunction text_group_possibleConstructorReturn(self, call) { if (call && (text_group_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return text_group_assertThisInitialized(self); }\nfunction text_group_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction text_group_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction text_group_getPrototypeOf(o) { text_group_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return text_group_getPrototypeOf(o); }\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar TextGroup = /*#__PURE__*/function (_Node) {\n  text_group_inherits(TextGroup, _Node);\n  var _super = text_group_createSuper(TextGroup);\n  function TextGroup(configs) {\n    var _this;\n    text_group_classCallCheck(this, TextGroup);\n    _this = _super.call(this, configs);\n    _this.type = \'TextGroup\';\n    _this.initStack(configs);\n    _this.initLayout(configs);\n    _this._undoredo = new UndoRedo();\n    _this._undoredo._editor = text_group_assertThisInitialized(_this);\n    _this._caret = new caret();\n    _this._range = new range();\n    _this._shadowInput = undefined;\n    _this.textColor = configs.textColor || \'transparent\';\n    _this.fontFamily = configs.fontFamily || \'-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Tahoma,Arial,Noto Sans,PingFang SC,Microsoft YaHei,Hiragino Sans GB,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji\';\n    _this.fontSize = configs.fontSize || \'28px\';\n    _this.fontWeight = configs.fontWeight || \'\';\n    _this.elementSpace = configs.elementSpace || 5;\n    _this.lineSpace = configs.lineSpace || 5;\n    _this.placeholder = configs.placeholder || \'请输入\';\n    _this.placeholderColor = configs.placeholderColor || \'#eee\';\n    _this.cursorColor = configs.cursorColor || \'#60CFC4\';\n    _this.textRangeColor = configs.textRangeColor || \'#4E75EC1A\';\n    _this.minWidth = configs.minWidth || 0;\n    _this.spaceHolder = {\n      enable: false\n    };\n    if (configs.spacePlaceholder) {\n      Object.assign(_this.spaceHolder, {\n        enable: true,\n        spacePlaceholder: configs.spacePlaceholder,\n        spacePlaceholderColor: configs.spacePlaceholderColor,\n        returnFont: configs.returnFont\n      });\n    }\n    _this.resolver = function () {\n      var elements = configs.resolver();\n      if (elements.length === 0 || elements[elements.length - 1].type !== \'text\') {\n        elements.push(new TextElement(\'text\', \'\'));\n      }\n      elements.forEach(function (el) {\n        if (el.type === \'text\') {\n          el.setSource(el.source, _this.spaceHolder);\n        }\n      });\n      return elements;\n    };\n\n    // this._lines = [];\n    _this._area = new Area();\n    _this._flattenTxtElem = FlattenTextElements.create(_this.resolver());\n    _this._status = {\n      editing: false,\n      dragover: false\n    };\n    _this.commands = new Map();\n    _this.registCommand(StartEditCommand);\n    _this.registCommand(EditClickCommand);\n    _this.registCommand(ShiftUpCommand);\n    _this.registCommand(ShiftDownCommand);\n    _this.registCommand(ShiftOnClickCommand);\n    _this.registCommand(Input);\n    _this.registCommand(ArrowLeftCommand);\n    _this.registCommand(ArrowRightCommand);\n    _this.registCommand(ArrowUpCommand);\n    _this.registCommand(ArrowDownCommand);\n    _this.registCommand(CtrlACommand);\n    _this.registCommand(DoubleClickCommand);\n    // this.registCommand(ReturnCommand);\n    // this.registCommand(DeleteCommand);\n    _this.registCommand(UndoCommand);\n    _this.registCommand(RedoCommand);\n    _this.registCommand(CopyCommand);\n    _this.registCommand(CutCommand);\n    _this.registCommand(PasteCommand);\n    _this._makeFunctional();\n    _this._cacheViewBox = [];\n    return _this;\n  }\n  text_group_createClass(TextGroup, [{\n    key: "currentLineHeight",\n    get: function get() {\n      return this.lineHeight || parseInt(this.fontSize);\n    }\n  }, {\n    key: "registCommand",\n    value: function registCommand(cmd) {\n      if (!this.commands.has(cmd._name)) {\n        this.commands.set(cmd._name, cmd.create(this));\n      }\n    }\n  }, {\n    key: "_makeFunctional",\n    value: function _makeFunctional() {\n      var _this2 = this;\n      this.addEventListener(\'dblclick\', function (event) {\n        if (event.currentTarget !== _this2) {\n          return;\n        }\n        event.detail.bubbles = false;\n        if (_this2._status.editing) {\n          _this2.execCommand(MOUSE_COMMANDS.DOUBLE_CLICK);\n        }\n      });\n      this.addEventListener(\'click\', function (event) {\n        if (event.currentTarget !== _this2) {\n          return;\n        }\n        event.detail.bubbles = false;\n        var commnd;\n        if (_this2._status.editing) {\n          if (_this2._status.shiftOn) {\n            commnd = MOUSE_COMMANDS.SHIFT_ON_CLICK;\n          } else {\n            commnd = MOUSE_COMMANDS.EDIT_CLICK;\n          }\n        } else {\n          commnd = MOUSE_COMMANDS.START_EDIT;\n        }\n        _this2.execCommand(commnd);\n      });\n      this.addEventListener(\'blur\', function (event) {\n        _this2._status.editing = false;\n        if (_this2._shadowInput) {\n          // this._shadowInput.releaseEventListenr();\n          _this2._shadowInput.destroy();\n          _this2._shadowInput = undefined;\n        }\n        if (_this2._belongs) {\n          _this2._jflow._render();\n        }\n        _this2.dispatchEvent(new events(\'change\', {\n          target: _this2,\n          textElements: _this2._flattenTxtElem.copy()\n        }));\n        _this2._range.disable();\n        _this2._caret.cancelAnimate();\n      });\n      this.addEventListener(\'instancePressStart\', function (event) {\n        if (_this2._status.editing && !_this2._status.shiftOn) {\n          event.detail.bubbles = false;\n          event.detail.preventDefault();\n          // event.detail.jflow.setMovingTargets(null);\n          var point = _this2._currentp;\n          var c = _this2._positionToCursorOffset(point);\n          // this._cursor = c;\n          var range = _this2._range;\n          range.setInitialRange([c.row].concat(text_group_toConsumableArray(c.column)));\n          var jflow = event.detail.jflow;\n          var moved = false;\n          var t = function (e) {\n            _this2._status.editing = false;\n            moved = true;\n            var offsetX = e.offsetX,\n              offsetY = e.offsetY;\n            var p = jflow._calculatePointBack([offsetX, offsetY]);\n            jflow._stack.checkHit(p);\n            var point = _this2._currentp;\n            var c = _this2._positionToCursorOffset(point);\n            // this._cursor = c;\n            range.setRange([c.row].concat(text_group_toConsumableArray(c.column)));\n            range.enable();\n          }.bind(_this2);\n          document.addEventListener(\'pointermove\', t);\n          document.addEventListener(\'pointerup\', function (e) {\n            document.removeEventListener(\'pointermove\', t);\n            range.setInitialRange(null);\n            if (!moved) {\n              return;\n            }\n            range.handleCaret(_this2._caret);\n            _this2._status.editing = true;\n            _this2._shadowInput.focus();\n          }, {\n            once: true\n          });\n        }\n      });\n      this.addEventListener(\'dragenter\', function () {\n        _this2.moveCaretByHitPoint();\n        _this2._status.dragover = true;\n      });\n      this.addEventListener(\'dragover\', function () {\n        _this2.moveCaretByHitPoint();\n      });\n      this.addEventListener(\'dragleave\', function () {\n        _this2._status.dragover = false;\n      });\n      var onDrop = function (event) {\n        if (!_this2._status.dragover) {\n          return;\n        }\n        event.detail.bubbles = false;\n        _this2._status.dragover = false;\n        var caret = _this2._caret;\n        var row = caret.getRow();\n        var column = caret.getColumn();\n        var line = _this2._area.get(row);\n        var _column = text_group_slicedToArray(column, 2),\n          elemidx = _column[0],\n          offset = _column[1];\n        var element = line.get(elemidx);\n        var preElem = line.get(elemidx - 1);\n        var flattenTxtElem = _this2._flattenTxtElem;\n        var idx = flattenTxtElem.findIndex(element);\n        if (element.type !== \'text\' && (preElem === null || preElem === void 0 ? void 0 : preElem.type) === \'text\') {\n          offset = preElem.source.length;\n          idx = flattenTxtElem.findIndex(preElem);\n        }\n        var lastLength = flattenTxtElem.length();\n        _this2.dispatchEvent(new events(\'insert\', text_group_objectSpread(text_group_objectSpread({}, event.detail), {}, {\n          type: event.type,\n          textElements: flattenTxtElem.copy(),\n          idx: idx,\n          offset: offset\n        })));\n        // after insert\n        flattenTxtElem = _this2._flattenTxtElem;\n        if (_this2._status.editing) {\n          if (flattenTxtElem.length() > lastLength) {\n            caret.setColumn([elemidx + flattenTxtElem.length() - lastLength, 0]);\n          }\n          _this2._shadowInput.focus();\n        }\n        if (_this2._status.editing) {\n          _this2._caret.refresh();\n        }\n        _this2.syncShadowInputPosition();\n        _this2._range.disable();\n      }.bind(this);\n      this.addEventListener(\'pressEnd\', onDrop);\n      this.addEventListener(\'drop\', onDrop);\n    }\n  }, {\n    key: "toggleShift",\n    value: function toggleShift(val) {\n      this._status.shiftOn = val;\n    }\n  }, {\n    key: "execCommand",\n    value: function execCommand(kind, data) {\n      var cmd = this.commands.get(kind);\n      cmd.exec(data);\n    }\n  }, {\n    key: "createShadowInput",\n    value: function createShadowInput() {\n      var _this3 = this;\n      var jflow = this._jflow;\n      var shadowInput = new shadow_input(jflow.DOMwrapper);\n      var _a = function _a(e) {\n        var kind = e.detail.kind;\n        var data = e.detail.data;\n        _this3.execCommand(kind, data);\n      };\n      var _b = function _b(e) {\n        var kind = e.detail.kind;\n        var data = e.detail.data;\n        var cmd = _this3.commands.get(EDITOR_EVENTS.INPUT);\n        cmd.exec(kind, data);\n      };\n      shadowInput.addEventListener(EDITOR_EVENTS.CONTROL_CMD, _a);\n      shadowInput.addEventListener(EDITOR_EVENTS.INPUT, _b);\n      shadowInput.removeLisenter = function () {\n        shadowInput.removeEventListener(EDITOR_EVENTS.CONTROL_CMD, _a);\n        shadowInput.removeEventListener(EDITOR_EVENTS.INPUT, _b);\n        shadowInput.removeLisenter = null;\n      };\n      this._shadowInput = shadowInput;\n      this._status.editing = true;\n      jflow.setFocusInstance(this);\n    }\n  }, {\n    key: "moveCaretByHitPoint",\n    value: function moveCaretByHitPoint() {\n      var point = this._currentp;\n      var caret = this._caret;\n      var _this$_positionToCurs = this._positionToCursorOffset(point),\n        row = _this$_positionToCurs.row,\n        column = _this$_positionToCurs.column;\n      caret.setRow(row);\n      caret.setColumn(column);\n    }\n  }, {\n    key: "refresh",\n    value: function refresh() {\n      this.recalculateUp();\n      this.syncShadowInputPosition();\n      this._jflow._render();\n    }\n  }, {\n    key: "refreshTextElements",\n    value: function refreshTextElements() {\n      this._flattenTxtElem = FlattenTextElements.create(this.resolver());\n    }\n  }, {\n    key: "_positionToCursorOffset",\n    value: function _positionToCursorOffset(point) {\n      var _point = text_group_slicedToArray(point, 2),\n        x = _point[0],\n        y = _point[1];\n      // const [x0, y0] = this.anchor;\n      var area = this._area;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var offsetX = x + w;\n      var offsetY = y + h;\n      var row = area.getLineAbove(offsetY);\n      var currLine = area.get(row);\n      var column = currLine.getColumnNearest(offsetX, this.elementSpace, this.fontSize, this.fontFamily, this);\n      return {\n        row: row,\n        column: column\n      };\n    }\n  }, {\n    key: "_caretToPosition",\n    value: function _caretToPosition() {\n      var _this4 = this;\n      var row = this._caret.getRow();\n      var column = this._caret.getColumn();\n      var line = this._area.get(row);\n      var _column2 = text_group_slicedToArray(column, 2),\n        elemidx = _column2[0],\n        offset = _column2[1];\n      var meta = line.get(elemidx);\n      var idx = this._flattenTxtElem.findIndex(meta);\n      var preElem = this._flattenTxtElem.get(idx - 1);\n      var cw;\n      var c_len = this.currentLineHeight / 2;\n      if (meta.type === \'text\') {\n        var c = meta.getRenderSource(this.spaceHolder).substring(0, offset);\n        requestCacheCanvas(function (ctx) {\n          ctx.beginPath();\n          ctx.font = "".concat(_this4.fontSize, " ").concat(_this4.fontFamily);\n          cw = meta.anchorX - meta.width / 2 + ctx.measureText(c).width;\n        });\n      } else {\n        cw = meta.anchorX - meta.width / 2;\n        c_len = Math.max(c_len, meta.height / 2);\n      }\n      if (offset === 0 && preElem && preElem.type !== \'text\') {\n        c_len = Math.max(c_len, preElem.height / 2);\n      }\n      return [cw, c_len, line.anchorY, preElem, meta];\n    }\n  }, {\n    key: "syncShadowInputPosition",\n    value: function syncShadowInputPosition() {\n      if (this._status.editing) {\n        var _this$_caretToPositio = this._caretToPosition(),\n          _this$_caretToPositio2 = text_group_slicedToArray(_this$_caretToPositio, 3),\n          cw = _this$_caretToPositio2[0],\n          c_len = _this$_caretToPositio2[1],\n          anchorY = _this$_caretToPositio2[2];\n        var point = this.calculateToRealWorld([cw, anchorY + c_len]);\n        var canvasMeta = this._jflow.canvasMeta;\n        var px = Math.min(canvasMeta.actual_width - 120, point[0]);\n        // return [px, point[1]];\n        this._shadowInput.syncPosition(px, point[1]);\n        this._shadowInput.focus();\n      }\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      var _this5 = this;\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      } else if (this.opacity !== 1) {\n        ctx.globalAlpha = this.opacity;\n      }\n      var _this$anchor = text_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor[0],\n        cy = _this$anchor[1];\n      var jflow = this._jflow;\n      var area = this._area;\n      ctx.translate(cx, cy);\n      // ctx.beginPath();\n      // ctx.rect(-width/2, -height/2, width, height);\n      // ctx.stroke();\n      var flattenTxtElem = this._flattenTxtElem;\n      if (flattenTxtElem.isEmpty()) {\n        ctx.beginPath();\n        ctx.font = "".concat(this.fontWeight, " ").concat(this.fontSize, " ").concat(this.fontFamily);\n        ctx.textAlign = \'center\';\n        ctx.textBaseline = \'middle\';\n        ctx.fillStyle = this.placeholderColor;\n        ctx.fillText(this.placeholder, 0, 0);\n        this._randerCursor(ctx);\n        ctx.translate(-cx, -cy);\n        ctx.restore();\n        return;\n      }\n      ctx.beginPath();\n      ctx.font = "".concat(this.fontWeight, " ").concat(this.fontSize, " ").concat(this.fontFamily);\n      ctx.textAlign = \'center\';\n      ctx.textBaseline = \'middle\';\n      ctx.fillStyle = this.textColor;\n      area.forEach(function (line) {\n        line.forEach(function (el) {\n          if (el.type === \'text\') {\n            el.render(ctx, _this5.spaceHolder, _this5.textColor);\n            // ctx.fillText(el.source, el.anchorX, el.anchorY)\n          }\n        });\n      });\n\n      flattenTxtElem.forEach(function (elem) {\n        if (elem.type !== \'text\') {\n          var instance = jflow.getRenderNodeBySource(elem.source);\n          if (instance && instance.visible) {\n            ctx.save();\n            instance.render(ctx);\n            ctx.restore();\n          }\n        }\n      });\n      this._randerCursor(ctx);\n      this._renderRange(ctx);\n      ctx.translate(-cx, -cy);\n      ctx.restore();\n    }\n  }, {\n    key: "_randerCursor",\n    value: function _randerCursor(ctx) {\n      if (this._caret.isShow() && (this._status.editing || this._status.dragover)) {\n        var _this$_caretToPositio3 = this._caretToPosition(),\n          _this$_caretToPositio4 = text_group_slicedToArray(_this$_caretToPositio3, 3),\n          cw = _this$_caretToPositio4[0],\n          c_len = _this$_caretToPositio4[1],\n          anchorY = _this$_caretToPositio4[2];\n        ctx.beginPath();\n        ctx.moveTo(cw, anchorY - c_len);\n        ctx.lineTo(cw, anchorY + c_len);\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = this.cursorColor;\n        ctx.stroke();\n      }\n    }\n  }, {\n    key: "_renderRange",\n    value: function _renderRange(ctx) {\n      var range = this._range;\n      if (range.isEnable()) {\n        var area = this._area;\n        var textRangeColor = this.textRangeColor;\n        var blockheight = this.height;\n        var blockwidth = this.width;\n        var lineSpace = this.lineSpace;\n        var _range$getRangeFrom = range.getRangeFrom(),\n          _range$getRangeFrom2 = text_group_slicedToArray(_range$getRangeFrom, 3),\n          r_f = _range$getRangeFrom2[0],\n          idx_f = _range$getRangeFrom2[1],\n          offset_f = _range$getRangeFrom2[2];\n        var _range$getRangeTo = range.getRangeTo(),\n          _range$getRangeTo2 = text_group_slicedToArray(_range$getRangeTo, 3),\n          r_t = _range$getRangeTo2[0],\n          idx_t = _range$getRangeTo2[1],\n          offset_t = _range$getRangeTo2[2];\n        if (r_f === r_t) {\n          if (idx_f === idx_t && offset_f == offset_t) {\n            return;\n          }\n          var line = area.get(r_f);\n          var space = r_f === area.length() - 1 ? 0 : lineSpace;\n          var lty = line.reduceHeight - space - line.height - blockheight / 2;\n          var height = line.height;\n          var x1 = this._measureElementOffsetX(line.get(idx_f), offset_f, ctx);\n          var x2 = this._measureElementOffsetX(line.get(idx_t), offset_t, ctx);\n          ctx.beginPath();\n          ctx.rect(x1, lty, x2 - x1, height);\n          ctx.fillStyle = textRangeColor;\n          ctx.fill();\n        } else {\n          var _r = r_f;\n          var beginning = true;\n          while (_r <= r_t) {\n            var _line = area.get(_r);\n            var _space = _r === area.length() - 1 ? 0 : lineSpace;\n            var _lty = _line.reduceHeight - _space - _line.height - blockheight / 2;\n            var _height = _line.height;\n            if (beginning) {\n              var elem = _line.get(idx_f);\n              var x = this._measureElementOffsetX(elem, offset_f, ctx);\n              var lastElem = _line.tail();\n              var t = lastElem.anchorX + lastElem.width / 2;\n              ctx.beginPath();\n              ctx.rect(x, _lty, t - x, _height);\n              ctx.fillStyle = textRangeColor;\n              ctx.fill();\n            } else if (_r === r_t) {\n              var _elem = _line.get(idx_t);\n              var _x2 = this._measureElementOffsetX(_elem, offset_t, ctx);\n              ctx.beginPath();\n              ctx.rect(-blockwidth / 2, _lty, _elem.reduceWidth + (_x2 - _elem.anchorX + _elem.width / 2), _height);\n              ctx.fillStyle = textRangeColor;\n              ctx.fill();\n            } else {\n              ctx.beginPath();\n              ctx.rect(-blockwidth / 2, _lty, _line.width, _height);\n              ctx.fillStyle = textRangeColor;\n              ctx.fill();\n            }\n            beginning = false;\n            _r++;\n          }\n        }\n      }\n    }\n  }, {\n    key: "_measureElementOffsetX",\n    value: function _measureElementOffsetX(element, offset, ctx) {\n      if (element.type !== \'text\' || offset === 0) {\n        return element.anchorX - element.width / 2;\n      }\n      return element.anchorX - element.width / 2 + ctx.measureText(element.getRenderSource(this.spaceHolder).substring(0, offset)).width;\n    }\n  }, {\n    key: "measureTextWidth",\n    value: function measureTextWidth(content) {\n      var _this6 = this;\n      var t;\n      requestCacheCanvas(function (ctx) {\n        ctx.font = "".concat(_this6.fontSize, " ").concat(_this6.fontFamily);\n        t = ctx.measureText(content).width;\n      });\n      return t;\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        width: this.width,\n        height: this.height\n      };\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var ltx = anchor[0] - w;\n      var lty = anchor[1] - h;\n      var rbx = anchor[0] + w;\n      var rby = anchor[1] + h;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }, {\n    key: "_getViewBox",\n    value: function _getViewBox() {\n      var belongs_vbox = this._belongs.getCacheViewBox();\n      var cacheViewBox = this._cacheViewBox;\n      this._calculatePointBackWithPoint(belongs_vbox[0], belongs_vbox[1], cacheViewBox, 0, 1);\n      this._calculatePointBackWithPoint(belongs_vbox[2], belongs_vbox[3], cacheViewBox, 2, 3);\n      return this._cacheViewBox;\n    }\n  }, {\n    key: "getCacheViewBox",\n    value: function getCacheViewBox() {\n      return this._cacheViewBox;\n    }\n  }, {\n    key: "calculateToCoordination",\n    value: function calculateToCoordination(point) {\n      var _point2 = text_group_slicedToArray(point, 2),\n        gx = _point2[0],\n        gy = _point2[1];\n      var _this$anchor2 = text_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor2[0],\n        cy = _this$anchor2[1];\n      // const p = [cx + anchor[0] - spanH, cy + anchor[1] - spanV];\n      var p = [gx + cx, gy + cy];\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        return this._belongs.calculateToCoordination(p);\n      } else {\n        return p;\n      }\n    }\n  }, {\n    key: "calculateToRealWorld",\n    value: function calculateToRealWorld(point) {\n      var _point3 = text_group_slicedToArray(point, 2),\n        gx = _point3[0],\n        gy = _point3[1];\n      var _this$anchor3 = text_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor3[0],\n        cy = _this$anchor3[1];\n      var p = [gx + cx, gy + cy];\n      if (this._belongs && this._belongs.calculateToRealWorld) {\n        return this._belongs.calculateToRealWorld(p);\n      }\n    }\n  }, {\n    key: "calculateToRealWorldWithPointer",\n    value: function calculateToRealWorldWithPointer(outpoint, inpoint) {\n      outpoint[0] = inpoint[0] + this.anchor[0];\n      outpoint[1] = inpoint[1] + this.anchor[1];\n      if (this._belongs && this._belongs.calculateToRealWorldWithPointer) {\n        return this._belongs.calculateToRealWorldWithPointer(outpoint, outpoint);\n      }\n    }\n  }, {\n    key: "_calculatePointBack",\n    value: function _calculatePointBack(point) {\n      var _point4 = text_group_slicedToArray(point, 2),\n        gx = _point4[0],\n        gy = _point4[1];\n      var _this$anchor4 = text_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor4[0],\n        cy = _this$anchor4[1];\n      var p = [gx - cx, gy - cy];\n      return p;\n    }\n  }, {\n    key: "_calculatePointBackWithPoint",\n    value: function _calculatePointBackWithPoint(a, b, arr, idx1, idx2) {\n      arr[idx1] = a - this.anchor[0];\n      arr[idx2] = b - this.anchor[1];\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point, condition) {\n      var p = this._calculatePointBack(point);\n      var jflow = this._jflow;\n      this._currentp = p; // 暂存，为了后续计算别的位置\n      var validInstance = [];\n      var flattenTxtElem = this._flattenTxtElem;\n      flattenTxtElem.forEach(function (elem) {\n        if (elem.type !== \'text\') {\n          var instance = jflow.getRenderNodeBySource(elem.source);\n          if (instance.visible) {\n            validInstance.push(instance);\n          }\n        }\n      });\n      var target = this._stack.checkHit(p, condition, function (i) {\n        return validInstance.includes(i);\n      });\n      if (target) return target;\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      return point[0] > anchor[0] - w && point[0] < anchor[0] + w && point[1] > anchor[1] - h && point[1] < anchor[1] + h;\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      var _this7 = this;\n      var t = new shadow_cache({\n        width: this.width,\n        height: this.height,\n        cache: function cache(ctx) {\n          var _this7$anchor = text_group_slicedToArray(_this7.anchor, 2),\n            cx = _this7$anchor[0],\n            cy = _this7$anchor[1];\n          ctx.translate(-cx + _this7.width / 2, -cy + _this7.height / 2);\n          _this7.render(ctx);\n        }\n      });\n      return t;\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      if (this._jflow._focus.instance === this) {\n        this._jflow.blur();\n      }\n    }\n  }]);\n  return TextGroup;\n}(node);\nObject.assign(TextGroup.prototype, stackMixin);\nObject.assign(TextGroup.prototype, layoutMixin);\nObject.assign(TextGroup.prototype, {\n  // 屏蔽这两个方法，只根据reflow重算\n  _getBoundingGroupRect: function _getBoundingGroupRect() {},\n  resetChildrenPosition: function resetChildrenPosition() {},\n  reflow: function reflow() {\n    var _this8 = this;\n    var lineHeight = this.currentLineHeight;\n    var flattenTxtElem = this._flattenTxtElem;\n    var area = this._area;\n    if (flattenTxtElem.isEmpty()) {\n      var width = 0;\n      var t = flattenTxtElem.get(0);\n      requestCacheCanvas(function (ctx) {\n        ctx.font = "".concat(_this8.fontSize, " ").concat(_this8.fontFamily);\n        width = ctx.measureText(_this8.placeholder).width;\n      });\n      var _line2 = area.truncate({\n        height: lineHeight,\n        reduceHeight: lineHeight\n      });\n      _line2.insert(0, t);\n      Object.assign(t, {\n        anchorX: -width / 2,\n        height: lineHeight,\n        isTail: true\n      });\n      this.width = width;\n      this.height = lineHeight;\n      return;\n    }\n    var jflow = this._jflow;\n    var spaceHolder = this.spaceHolder;\n    requestCacheCanvas(function (ctx) {\n      ctx.font = "".concat(_this8.fontSize, " ").concat(_this8.fontFamily);\n      flattenTxtElem.forEach(function (element) {\n        if (element.type === \'text\' && element.dirty) {\n          element.preCalculateText(ctx, spaceHolder);\n        }\n      });\n    });\n    var nextArea = new Area();\n    nextArea.truncate({\n      height: lineHeight\n    });\n    var line = nextArea.get(0);\n    var allHeight = 0;\n    var allWidth = 0;\n    var lastElem = null;\n    var lineSpace = this.lineSpace;\n    var elementSpace = this.elementSpace;\n    flattenTxtElem.forEach(function (element) {\n      line.push(element);\n      element.reduceWidth = line.width;\n      if (element.type === \'text\') {\n        element.height = lineHeight;\n        line.width += element.width;\n        if (element.needWrap) {\n          allHeight += line.height + lineSpace;\n          line.reduceHeight = allHeight;\n          allWidth = Math.max(line.width, allWidth);\n          line = Line.create({\n            height: lineHeight\n          });\n          nextArea.push(line);\n        }\n      } else {\n        var node = jflow.getRenderNodeBySource(element.source);\n        element.height = node.height;\n        line.height = Math.max(line.height, node.height);\n        var margin = !lastElem || lastElem.type === \'text\' ? elementSpace * 2 : elementSpace;\n        line.width += node.width + margin;\n      }\n      lastElem = element;\n    });\n    flattenTxtElem.tail().isTail = true;\n    allHeight += line.height;\n    line.reduceHeight = allHeight;\n    allWidth = Math.max(this.minWidth, Math.max(line.width, allWidth));\n    var hh = allHeight / 2;\n    var hw = allWidth / 2;\n    var ty = -hh;\n    var lastReduceY = 0;\n    nextArea.forEach(function (l) {\n      var height = l.height,\n        reduceHeight = l.reduceHeight;\n      var anchorY = ty + lastReduceY + height / 2;\n      l.anchorY = anchorY;\n      var reduceX = -hw;\n      var lastel = null;\n      l.forEach(function (el) {\n        if (el.type === \'text\') {\n          el.anchorY = anchorY;\n          el.anchorX = reduceX + el.width / 2;\n          reduceX += el.width;\n        } else {\n          var renderNode = jflow.getRenderNodeBySource(el.source);\n          var doubleMargin = !lastel || lastel.type === \'text\';\n          var margin = doubleMargin ? elementSpace * 2 : elementSpace;\n          el.width = renderNode.width;\n          el.anchorY = anchorY;\n          el.anchorX = reduceX + el.width / 2 + (doubleMargin ? margin / 2 : 0);\n          renderNode.anchor = [el.anchorX, el.anchorY];\n          reduceX += el.width + margin;\n        }\n        lastel = el;\n      });\n      lastReduceY = reduceHeight;\n    });\n    this._area = nextArea;\n    this.width = allWidth;\n    this.height = allHeight;\n  },\n  doRecalculate: function doRecalculate() {\n    if (this.__mounted__) {\n      this.recalculateUp();\n    } else {\n      this.recalculate();\n      this.__mounted__ = true;\n    }\n  }\n});\n/* harmony default export */ const text_group = (TextGroup);\n;// CONCATENATED MODULE: ./src/core/instance/node-placeholder.js\nfunction node_placeholder_typeof(obj) { "@babel/helpers - typeof"; return node_placeholder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, node_placeholder_typeof(obj); }\nfunction node_placeholder_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, node_placeholder_toPropertyKey(descriptor.key), descriptor); } }\nfunction node_placeholder_createClass(Constructor, protoProps, staticProps) { if (protoProps) node_placeholder_defineProperties(Constructor.prototype, protoProps); if (staticProps) node_placeholder_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction node_placeholder_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction node_placeholder_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) node_placeholder_setPrototypeOf(subClass, superClass); }\nfunction node_placeholder_setPrototypeOf(o, p) { node_placeholder_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return node_placeholder_setPrototypeOf(o, p); }\nfunction node_placeholder_createSuper(Derived) { var hasNativeReflectConstruct = node_placeholder_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = node_placeholder_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = node_placeholder_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return node_placeholder_possibleConstructorReturn(this, result); }; }\nfunction node_placeholder_possibleConstructorReturn(self, call) { if (call && (node_placeholder_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return node_placeholder_assertThisInitialized(self); }\nfunction node_placeholder_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction node_placeholder_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction node_placeholder_getPrototypeOf(o) { node_placeholder_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return node_placeholder_getPrototypeOf(o); }\nfunction node_placeholder_defineProperty(obj, key, value) { key = node_placeholder_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction node_placeholder_toPropertyKey(arg) { var key = node_placeholder_toPrimitive(arg, "string"); return node_placeholder_typeof(key) === "symbol" ? key : String(key); }\nfunction node_placeholder_toPrimitive(input, hint) { if (node_placeholder_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (node_placeholder_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n// export const PLACEHOLDER_SYMBOL = Symbol(\'PLACEHOLDER_SYMBOL\');\n\nvar NodePlaceholder = /*#__PURE__*/function (_Node) {\n  node_placeholder_inherits(NodePlaceholder, _Node);\n  var _super = node_placeholder_createSuper(NodePlaceholder);\n  function NodePlaceholder() {\n    var _this;\n    node_placeholder_classCallCheck(this, NodePlaceholder);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    node_placeholder_defineProperty(node_placeholder_assertThisInitialized(_this), "type", \'NODE_PLACEHOLDER\');\n    return _this;\n  }\n  return node_placeholder_createClass(NodePlaceholder);\n}(node);\n;// CONCATENATED MODULE: ./src/core/flow/index.js\nfunction flow_typeof(obj) { "@babel/helpers - typeof"; return flow_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, flow_typeof(obj); }\nfunction flow_slicedToArray(arr, i) { return flow_arrayWithHoles(arr) || flow_iterableToArrayLimit(arr, i) || flow_unsupportedIterableToArray(arr, i) || flow_nonIterableRest(); }\nfunction flow_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction flow_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return flow_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return flow_arrayLikeToArray(o, minLen); }\nfunction flow_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction flow_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction flow_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction flow_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction flow_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, flow_toPropertyKey(descriptor.key), descriptor); } }\nfunction flow_createClass(Constructor, protoProps, staticProps) { if (protoProps) flow_defineProperties(Constructor.prototype, protoProps); if (staticProps) flow_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction flow_toPropertyKey(arg) { var key = flow_toPrimitive(arg, "string"); return flow_typeof(key) === "symbol" ? key : String(key); }\nfunction flow_toPrimitive(input, hint) { if (flow_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (flow_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction flow_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) flow_setPrototypeOf(subClass, superClass); }\nfunction flow_createSuper(Derived) { var hasNativeReflectConstruct = flow_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = flow_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = flow_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return flow_possibleConstructorReturn(this, result); }; }\nfunction flow_possibleConstructorReturn(self, call) { if (call && (flow_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return flow_assertThisInitialized(self); }\nfunction flow_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction flow_wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; flow_wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !flow_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return flow_construct(Class, arguments, flow_getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return flow_setPrototypeOf(Wrapper, Class); }; return flow_wrapNativeSuper(Class); }\nfunction flow_construct(Parent, args, Class) { if (flow_isNativeReflectConstruct()) { flow_construct = Reflect.construct.bind(); } else { flow_construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) flow_setPrototypeOf(instance, Class.prototype); return instance; }; } return flow_construct.apply(null, arguments); }\nfunction flow_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction flow_isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }\nfunction flow_setPrototypeOf(o, p) { flow_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return flow_setPrototypeOf(o, p); }\nfunction flow_getPrototypeOf(o) { flow_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return flow_getPrototypeOf(o); }\n\n\n\n\n\n\n\n\n\n\n\n\n// import { setUniqueId, getUniqueId } from \'../utils/functions\';\n\n\n\n\n\n\n\n\n\n\n// import { createInputTextStyle } from \'../instance/text\';\n// createInputTextStyle();\n/**\n * @funtion setInitialPosition\n * @param {Number} RealboxX - 内容映射到canvas上的 X\n * @param {Number} RealboxY - 内容映射到canvas上的 Y \n * @param {Number} RealboxW - 内容映射到canvas上的宽度\n * @param {Number} RealboxH - 内容映射到canvas上的高度 \n * @param {Number} CanvasWidth  - 视窗宽度\n * @param {Number} CanvasHeight  - 视窗高度\n * @return {Object} - 初始位置 { x, y }\n */\n\n/**\n * @funtion linkGen\n * @param {Node} from - 出发绘图节点\n * @param {Node} to - 临时节点，当前鼠标指的地方\n * @return {BaseeLink} - 连线对象\n */\n\n/** \n * @class Group\n * @classdesc 矩形组单元 由 {@link GroupFactory} 通过 {@link Rectangle} 生成\n * @groupfrom Rectangle\n * @augments GroupTemplate\n * @augments Rectangle\n * @param {(Rectangle~RectangleConfigs|GroupTemplate~GroupConfigs)} configs - 配置\n */\nvar Group = groupFactory(rectangle);\n/** \n * @class CapsuleGroup\n * @classdesc 胶囊组单元 由 {@link GroupFactory} 通过 {@link Capsule} 生成\n * @groupfrom Capsule\n * @augments GroupTemplate\n * @augments Capsule\n * @param {(Capsule~CapsuleConfigs|GroupTemplate~GroupConfigs)} configs - 配置\n */\nvar CapsuleGroup = groupFactory(capsule);\n/** \n * @class RhombusGroup\n * @classdesc 菱形组单元 由 {@link GroupFactory} 通过 {@link Rhombus} 生成\n * @augments GroupTemplate\n * @augments Rhombus\n * @groupfrom Rhombus\n * @param {(Rhombus~RhombusConfigs|GroupTemplate~GroupConfigs)} configs - 配置\n */\nvar RhombusGroup = groupFactory(rhombus);\n/** \n * @class DiamondGroup\n * @classdesc 钻石形组单元 由 {@link GroupFactory} 通过 {@link Diamond} 生成\n * @groupfrom Diamond\n * @augments GroupTemplate\n * @augments Diamond\n * @param {(Diamond~DiamondConfigs|GroupTemplate~GroupConfigs)} configs - 配置\n */\nvar DiamondGroup = groupFactory(diamond, {\n  shapeShift: function shapeShift(width, height) {\n    return [width + height * 0.28865, height];\n  }\n});\n/** \n * @class DiamondVerticalGroup\n * @classdesc 垂直钻石形组单元 由 {@link GroupFactory} 通过 {@link DiamondVertical} 生成\n * @groupfrom DiamondVertical\n * @augments GroupTemplate\n * @augments DiamondVertical\n * @param {(Diamond~DiamondConfigs|GroupTemplate~GroupConfigs)} configs - 配置\n */\nvar DiamondVerticalGroup = groupFactory(diamond_vertical, {\n  shapeShift: function shapeShift(width, height) {\n    return [width, height + width * 0.5773];\n  }\n});\n/** \n * @class CapsuleVerticalGroup\n * @classdesc 垂直钻石形组单元 由 {@link GroupFactory} 通过 {@link CapsuleVertical} 生成\n * @groupfrom CapsuleVertical\n * @augments GroupTemplate\n * @augments CapsuleVertical\n * @param {(Capsule~CapsuleConfigs|GroupTemplate~GroupConfigs)} configs - 配置\n */\nvar CapsuleVerticalGroup = groupFactory(capsule_vertical);\nvar PointGroup = groupFactory(point, {\n  shapeShift: function shapeShift(width, height, p) {\n    var r = Math.ceil(Math.sqrt(width * width + height * height) / 2);\n    p.radius = r;\n    var w = r * 2;\n    return [w, w];\n  }\n});\n\n/**\n * @typedef JFlow~JFlowConfigs\n * @type {object}\n * @property {Boolean} allowDrop      - 是否允许 dragdrop\n * @property {Number} maxZoom         - 最大缩放\n * @property {Number} minZoom         - 最小缩放\n * @property {number} initialZoom     - 初始缩放比\n * @property {EventAdapter~pluginDef} eventAdapter\n */\n\n/**\n * @typedef {JFlow~JFlowConfigs | LayoutMixin~LayoutConfigs} JFlow~JFlowLayoutConfigs\n */\n/** \n * JFlow 对象\n * JFlow 是 canvas 上面封装的一个顶层对象，具有处理事件和绘制的功能\n * @constructor JFlow\n * @param {JFlow~JFlowLayoutConfigs} configs - 配置项\n * @mixes LayoutMixin\n * @mixes StackMixin\n * @mixes MessageMixin\n */\nvar JFlow = /*#__PURE__*/function (_EventTarget) {\n  flow_inherits(JFlow, _EventTarget);\n  var _super = flow_createSuper(JFlow);\n  function JFlow(configs) {\n    var _this;\n    flow_classCallCheck(this, JFlow);\n    _this = _super.call(this);\n    _this.uniqueName = \'jflow\';\n    /**\n     * @member {EventAdapter} eventAdapter    - eventAdapter 对象\n     **/\n    _this.eventAdapter = new adapter(configs.eventAdapter);\n    _this.initNodeWeakMap();\n    _this.initAnime();\n    _this.initStack(configs);\n    _this.initLayout(configs);\n    /** @member {Context2d}     - Context2d 对象 */\n    _this.ctx = null;\n    /** @member {Element}       - canvas 元素 */\n    _this.canvas = null;\n    /** @member {number}       - 设备DPR */\n    _this.dpr = 1;\n    /** @member {number}       - 内边距 */\n    _this.padding = 20;\n    _this.position = null;\n    /** @member {number}     - 缩放 */\n    _this.scale = null;\n    /** @member {number}     - 初始缩放 */\n    _this.initialZoom = configs.initialZoom;\n    /** @member {setInitialPosition} - 初始位置计算 */\n    _this.initialPosition = configs.setInitialPosition;\n    /** @member {number}     - 最大缩放 */\n    _this.maxZoom = configs.maxZoom || 3;\n    /** @member {number}     - 最小缩放 */\n    _this.minZoom = configs.minZoom || .5;\n    _this.NodeRenderTop = !!configs.NodeRenderTop;\n    _this.worldMargin = configs.worldMargin;\n    _this.draggingbehavior = Object.assign({\n      panInBorder: {\n        enable: true,\n        padding: 20,\n        deltamovement: 8,\n        allowMovingTargetInPan: true\n      }\n    }, configs.draggingbehavior || {});\n    _this.scrollBarBehavior = Object.assign({\n      enable: true\n    }, configs.scrollBarBehavior || {});\n    // this.initScale = 1;\n    // this.initPosition = null\n    _this.offeset = null;\n    _this._lastState = {\n      x: null,\n      y: null,\n      dragging: false,\n      processing: false\n    };\n    _this._lastDragState = {\n      target: null,\n      targetLink: null,\n      processing: false\n    };\n    _this._target = {\n      instance: null,\n      link: null,\n      moving: null,\n      isInstanceDirty: false,\n      isLinkDirty: false,\n      // isMovingDirty: false, \n      cache: {\n        stack: null,\n        belongs: null,\n        point: null\n      },\n      meta: {\n        x: undefined,\n        y: undefined,\n        initialX: undefined,\n        initialY: undefined\n      },\n      status: {\n        dragovering: false,\n        dragging: false,\n        processing: false,\n        movingState: false\n      }\n    };\n    _this._focus = {\n      instance: null\n    };\n    _this._dragOverTarget = null;\n    // this.lock = configs.lock;\n\n    _this.allowDrop = configs.allowDrop;\n    // 临时绘制的对象\n    _this._tempNode = null;\n    _this._tempLink = null;\n    _this.mode = JFLOW_MODE.DEFAULT;\n    _this._allowMovingTarget = true;\n    _this.canvasMeta = {};\n    _this._cacheViewBox = [];\n    _this.__mounted__ = false;\n\n    // this._allowZoom = true;\n    return _this;\n  }\n\n  // allowZoom() {\n  //     this._allowZoom = true;\n  // }\n\n  // abandonZoom() {\n  //     this._allowZoom = false;\n  // }\n  /**\n   * 设置当前拖动的 JFlow 对象\n   * @param {Object[]} targets - 具有 anchor 属性的对象\n   */\n  flow_createClass(JFlow, [{\n    key: "setMovingTargets",\n    value: function setMovingTargets(targets) {\n      Object.assign(this._target, {\n        moving: targets\n      });\n    }\n\n    /**\n     * 设置当前拖动的 JFlow 对象\n     * @param {Instance} instance - JFlow 对象\n     */\n  }, {\n    key: "setTempDraggingInstance",\n    value: function setTempDraggingInstance(instance) {\n      instance._belongs = this;\n      this._tempNode = instance;\n      Object.assign(this._target, {\n        moving: [this._tempNode],\n        dragging: true\n      });\n    }\n\n    /**\n     * 取消当前拖动的 JFlow 对象\n     * @return {number[]} point - JFlow 坐标\n     */\n  }, {\n    key: "removeTempDraggingInstance",\n    value: function removeTempDraggingInstance() {\n      if (this._tempNode) {\n        // this.removeFromStack(this._tempNode);\n        var anchor = this._tempNode.anchor;\n        this._tempNode = null;\n        return anchor;\n      }\n    }\n    /**\n     * 关闭默认对象拖动效果\n     */\n  }, {\n    key: "preventDefaultDragging",\n    value: function preventDefaultDragging() {\n      this._allowMovingTarget = false;\n    }\n    /**\n     * 开启默认对象拖动效果\n     */\n  }, {\n    key: "allowDefaultDragging",\n    value: function allowDefaultDragging() {\n      this._allowMovingTarget = true;\n    }\n    /**\n     * 在 Document 元素上初始化实例\n     * @param {Element} dom \n     */\n  }, {\n    key: "$mount",\n    value: function $mount(dom) {\n      var _this2 = this;\n      var _createCanvas = createCanvas(dom),\n        canvas = _createCanvas.canvas,\n        ctx = _createCanvas.ctx,\n        dpr = _createCanvas.scale,\n        c_width = _createCanvas.width,\n        c_height = _createCanvas.height,\n        raw_width = _createCanvas.raw_width,\n        raw_height = _createCanvas.raw_height,\n        left = _createCanvas.left,\n        top = _createCanvas.top;\n      this.reflow();\n      this.ctx = ctx; //new CanvasContext2d(ctx, dpr);\n      this.DOMwrapper = dom;\n      this.canvas = canvas;\n      this.canvas.setAttribute(\'data-jflow\', true);\n      this.canvas.$jflow = this;\n      this.canvasMeta = {\n        width: raw_width,\n        height: raw_height,\n        actual_width: c_width,\n        actual_height: c_height\n      };\n      this.dpr = dpr;\n      this._getBoundingGroupRect();\n      var padding = this.padding;\n      var _this$bounding_box = this.bounding_box,\n        p_width = _this$bounding_box.width,\n        p_height = _this$bounding_box.height,\n        p_x = _this$bounding_box.x,\n        p_y = _this$bounding_box.y;\n      var contentBox = {\n        x: padding,\n        y: padding,\n        width: c_width - padding * 2,\n        height: c_height - padding * 2\n      };\n      var position = {\n        x: 0,\n        y: 0,\n        offsetX: 0,\n        offsetY: 0\n      };\n      var w_ratio = contentBox.width / p_width;\n      var h_ratio = contentBox.height / p_height;\n      var align = w_ratio <= h_ratio ? \'x\' : \'y\';\n      var scaleRatio;\n      if (this.initialZoom) {\n        scaleRatio = this.initialZoom;\n      } else {\n        scaleRatio = Math.min(w_ratio, h_ratio);\n      }\n      this.scale = scaleRatio;\n      if (scaleRatio > this.maxZoom) {\n        this.maxZoom = scaleRatio;\n      }\n      if (scaleRatio < this.minZoom) {\n        this.minZoom = scaleRatio;\n      }\n      var realboxX = p_x * scaleRatio;\n      var realboxY = p_y * scaleRatio;\n      var realboxW = contentBox.width;\n      var realboxH = contentBox.height;\n      if (this.initialPosition) {\n        var _this$initialPosition = this.initialPosition(realboxX, realboxY, realboxW, realboxH, contentBox.x, contentBox.y, c_width, c_height, p_x, p_y, p_width, p_height),\n          x = _this$initialPosition.x,\n          y = _this$initialPosition.y;\n        position.x = x;\n        position.y = y;\n      } else {\n        position.x = align === \'x\' ? contentBox.x : (realboxW - p_width * scaleRatio) / 2 + padding;\n        position.y = align === \'y\' ? contentBox.y : (realboxH - p_height * scaleRatio) / 2 + padding;\n      }\n      position.offsetX = position.x - realboxX;\n      position.offsetY = position.y - realboxY;\n      this.position = position;\n      this._readyToRender = true;\n      if (this.scrollBarBehavior.enable) {\n        this.initScrollBar(this.scrollBarBehavior);\n      }\n      // this.initSchedule();\n      // this.scheduleRender(() => {\n      //     this._createEventHandler();\n      // });\n      this.__render();\n      this._createEventHandler();\n      listenOnDevicePixelRatio(function (dpr) {\n        _this2.dpr = dpr;\n        // this.ctx.setDPR(dpr)\n        _this2.resizeCanvas();\n        _this2.scheduleRender();\n      }, function (handler) {\n        _this2.destroyDprListener = handler;\n      });\n      this.__mounted__ = true;\n    }\n\n    /**\n     * 设置Jflow进入连线模式\n     * @param {Object} source - 当前连线的出发原始数据\n     * @param {linkGen} linkGen - 生成连线单元的方法\n     */\n  }, {\n    key: "setLinkingMode",\n    value: function setLinkingMode(source, linkGen, isTail) {\n      var renderNode = this.getRenderNodeBySource(source);\n      this._tempNode = new ghostNode();\n      if (isTail) {\n        this._tempLink = linkGen({\n          from: this._tempNode,\n          to: renderNode\n        });\n      } else {\n        this._tempLink = linkGen({\n          from: renderNode,\n          to: this._tempNode\n        });\n      }\n      this.sendMessage({\n        instance: source\n      });\n      this.mode = JFLOW_MODE.LINKING;\n    }\n  }, {\n    key: "isInLinkingMode",\n    value: function isInLinkingMode() {\n      return this.mode === JFLOW_MODE.LINKING;\n    }\n\n    /**\n     * 连线模式下，设置当前临时连线的属性\n     * @param {BaseLink~Configs} configs - 当前连线的出发原始数据\n     */\n  }, {\n    key: "setLinkingLink",\n    value: function setLinkingLink(configs) {\n      if (this.mode === JFLOW_MODE.LINKING) {\n        this._tempLink.setConfig(configs);\n      }\n    }\n    /**\n     * 连线模式下，重连回临时鼠标节点\n     */\n  }, {\n    key: "resetLinkingLink",\n    value: function resetLinkingLink() {\n      if (this.mode === JFLOW_MODE.LINKING) {\n        this._tempLink.setConfig({\n          to: this._tempNode\n        });\n      }\n    }\n  }, {\n    key: "clearTemp",\n    value: function clearTemp() {\n      if (this._tempNode) {\n        this._tempNode.destroy();\n        this._tempNode = null;\n      }\n      if (this._tempLink) {\n        this._tempLink.destroy();\n        this._tempLink = null;\n      }\n      this._render();\n    }\n  }, {\n    key: "preventClearTemp",\n    value: function preventClearTemp() {\n      this._preventClearTemp = true;\n    }\n\n    /**\n     * 外层容器大小变化后，调用此方法可以改变当前canvas的状态\n     */\n  }, {\n    key: "resizeCanvas",\n    value: function resizeCanvas() {\n      if (this.canvas && this.DOMwrapper) {\n        var _resizeCanvas2 = canvas_resizeCanvas(this.canvas, this.DOMwrapper),\n          c_width = _resizeCanvas2.width,\n          c_height = _resizeCanvas2.height,\n          raw_width = _resizeCanvas2.raw_width,\n          raw_height = _resizeCanvas2.raw_height;\n        this.canvasMeta = {\n          width: raw_width,\n          height: raw_height,\n          actual_width: c_width,\n          actual_height: c_height\n        };\n      }\n    }\n  }, {\n    key: "setFocusInstance",\n    value: function setFocusInstance(node) {\n      this._focus.instance = node;\n    }\n\n    /**\n     * 移动画布到以目标绘图节点为中心的位置上\n     * @param {Node} node - 绘图节点\n     */\n  }, {\n    key: "focusOn",\n    value: function focusOn(node) {\n      var center = this._calculatePointBack([this.canvasMeta.actual_width / 2, this.canvasMeta.actual_height / 2]);\n      var offset = node.anchor;\n      if (node._belongs.calculateToCoordination) {\n        offset = node._belongs.calculateToCoordination(offset);\n      }\n      var deltaX = (center[0] - offset[0]) * this.scale;\n      var deltaY = (center[1] - offset[1]) * this.scale;\n      this._recalculatePosition(deltaX, deltaY);\n      this._render();\n    }\n  }, {\n    key: "_getBoundingGroupRect",\n    value: function _getBoundingGroupRect() {\n      var points = this._stack.getBoundingRectPoints();\n      if (this.bounding_box) {\n        this.bounding_box = bounding_box(points);\n        var _this$bounding_box2 = this.bounding_box,\n          nowx = _this$bounding_box2.x,\n          nowy = _this$bounding_box2.y;\n        var scale = this.scale;\n        this.position.x = this.position.offsetX + nowx * scale;\n        this.position.y = this.position.offsetY + nowy * scale;\n      } else {\n        this.bounding_box = bounding_box(points);\n      }\n    }\n  }, {\n    key: "_createEventHandler",\n    value: function _createEventHandler() {\n      var _this3 = this;\n      var canvas = this.canvas;\n      var destroyListener;\n      this.eventAdapter.apply(this);\n      var destroyPlainEventListener = function destroyPlainEventListener() {\n        _this3.eventAdapter.unload(_this3);\n        _this3.destroyDprListener();\n      };\n      destroyListener = destroyPlainEventListener;\n      if (this.allowDrop) {\n        var dragoverHandler = this._onDragover.bind(this);\n        var dropHandler = this._onDrop.bind(this);\n        var dragleaveHanlder = this._onDragLeave.bind(this);\n        canvas.addEventListener(\'dragstart\', function (e) {\n          e.preventDefault();\n        });\n        canvas.addEventListener(\'dragover\', dragoverHandler);\n        canvas.addEventListener(\'drop\', dropHandler);\n        canvas.addEventListener(\'dragleave\', dragleaveHanlder);\n        destroyListener = function destroyListener() {\n          destroyPlainEventListener();\n          canvas.removeEventListener(\'dragover\', dragoverHandler);\n          canvas.removeEventListener(\'drop\', dropHandler);\n          canvas.removeEventListener(\'dragleave\', dragleaveHanlder);\n        };\n      }\n      this.destroy = destroyListener;\n    }\n  }, {\n    key: "_targetLockOn",\n    value: function _targetLockOn(offsetPoint, event) {\n      var _this4 = this;\n      var point = this._calculatePointBack(offsetPoint);\n      var topLayerPoint = point;\n      this._currentp = point;\n      var stack = this._stack;\n      var br = this._getViewBox();\n      var target = stack.checkHit(point,\n      // 应用于所有\n      function (instance) {\n        return _this4._target.status.dragging && instance === _this4._getMovingTarget();\n      },\n      // 仅对于本层过滤\n      function (instance) {\n        return doOverlap(br, instance.getBoundingRect());\n      });\n      var linkStack = this._linkStack;\n      var belongs = this;\n      /*\n      if(target) {\n          linkStack = target._belongs._linkStack;\n          point = target._belongs._currentp;\n          stack = target._belongs._stack;\n          belongs = target._belongs\n      }*/\n      // 暂时设定只有顶层有连线\n      var targetLink;\n      if (!target || target._belongs === this) {\n        targetLink = linkStack.checkHit(point, function (link) {\n          if (!_this4._target.status.dragging) {\n            return false;\n          }\n          var movingtarget = _this4._getMovingTarget();\n          return link.from === movingtarget || link.to === movingtarget;\n        });\n      }\n      if (!targetLink) {\n        targetLink = linkStack.checkHit(point, function (link) {\n          return !link.ON_TOP;\n        });\n      }\n      Object.assign(this._target, {\n        instance: target,\n        link: targetLink,\n        isInstanceDirty: target === this._target.instance,\n        isLinkDirty: targetLink === this._target.link\n      });\n      Object.assign(this._target.cache, {\n        stack: stack,\n        belongs: belongs,\n        point: point,\n        topLayerPoint: topLayerPoint\n      });\n      Object.assign(this._target.meta, {\n        x: offsetPoint[0],\n        y: offsetPoint[1]\n      });\n      if (event === \'pressStart\' && !this._target.status.dragging && !this._target.status.dragovering) {\n        var movingtarget = target;\n        while (movingtarget && movingtarget._belongs.lock && movingtarget !== this) {\n          movingtarget = movingtarget._belongs;\n        }\n        this.setMovingTargets(movingtarget && [movingtarget]);\n        if (movingtarget) {\n          /**\n           * \n           * 开始拖拽时，拖拽对象设置之前\n           * @event Node#afterResolveMovingTarget\n           * @type {object}\n           * @property {Event} event           - 原始事件 \n           * @property {JFlow} jflow           - 当前JFlow对象 \n           * @property {Node} target           - 目标节点\n           */\n          target.bubbleEvent(new events(\'afterResolveMovingTarget\', {\n            event: event,\n            target: movingtarget,\n            jflow: this,\n            bubbles: true\n          }));\n        }\n      }\n      if ([\'pressStart\', \'click\', \'dblclick\', \'contextclick\'].includes(event)) {\n        if (this._focus.instance && this._focus.instance !== target) {\n          this._focus.instance.dispatchEvent(new events(\'blur\', {\n            relatedTarget: target\n          }));\n          this._focus.instance = null;\n        }\n      }\n      return this._target;\n    }\n  }, {\n    key: "blur",\n    value: function blur() {\n      if (this._focus.instance) {\n        this._focus.instance.dispatchEvent(new events(\'blur\', {\n          relatedTarget: null\n        }));\n        this._focus.instance = null;\n      }\n    }\n  }, {\n    key: "_getMovingTarget",\n    value: function _getMovingTarget() {\n      return this._target.moving && this._target.moving[0];\n    }\n  }, {\n    key: "_processDragOver",\n    value: function _processDragOver(instance, event) {\n      if (this._dragOverTarget !== instance) {\n        var _this$readMessage;\n        var target = (_this$readMessage = this.readMessage()) === null || _this$readMessage === void 0 ? void 0 : _this$readMessage.instance;\n        this._dragCurrentData = target;\n        var point = this._target.cache.point;\n        // console.log(\'_processDragOver\', this._dragOverTarget)\n        if (this._dragOverTarget) {\n          var oldIns = this._dragOverTarget;\n          /**\n          * dragleave 退出事件\n          * @event Instance#dragleave\n          * @type {object}\n          * @property {Event} event           - 原始事件 \n          * @property {Object} instance       - dragleave的对象 \n          * @property {target} target         - drag 携带的对象（特指从外面拖进canvas的对象） \n          */\n          oldIns.dispatchEvent(new events(\'dragleave\', {\n            event: event,\n            instance: oldIns,\n            target: target,\n            jflow: this,\n            point: point\n          }));\n        }\n        if (instance) {\n          /**\n          * dragenter 进入事件\n          * @event Instance#dragenter\n          * @type {object}\n          * @property {Event} event           - 原始事件 \n          * @property {Object} instance       - dragenter的对象 \n          * @property {target} target         - drag 携带的对象（特指从外面拖进canvas的对象） \n          */\n          instance.dispatchEvent(new events(\'dragenter\', {\n            event: event,\n            instance: instance,\n            target: target,\n            jflow: this,\n            point: point\n          }));\n        }\n        this._dragOverTarget = instance;\n      } else if (this._dragOverTarget) {\n        /**\n        * dragover 进入事件\n        * @event Instance#dragover\n        * @type {object}\n        * @property {Event} event           - 原始事件 \n        * @property {Object} instance       - dragover的对象 \n        * @property {target} target         - drag 携带的对象（特指从外面拖进canvas的对象） \n        */\n        this._dragOverTarget.dispatchEvent(new events(\'dragover\', {\n          event: event,\n          instance: instance,\n          jflow: this,\n          target: this._dragCurrentData\n        }));\n      }\n      this._processPanInBorder();\n    }\n  }, {\n    key: "_processPanInBorder",\n    value: function _processPanInBorder() {\n      var _this$draggingbehavio,\n        _this5 = this;\n      if ((_this$draggingbehavio = this.draggingbehavior) !== null && _this$draggingbehavio !== void 0 && (_this$draggingbehavio = _this$draggingbehavio.panInBorder) !== null && _this$draggingbehavio !== void 0 && _this$draggingbehavio.enable) {\n        if (!this.draggingbehavior.panInBorder.timer) {\n          this.draggingbehavior.panInBorder.timer = Date.now();\n        }\n        if (Date.now() - this.draggingbehavior.panInBorder.timer > 500) {\n          var _this$_cacheViewBox = flow_slicedToArray(this._cacheViewBox, 4),\n            x = _this$_cacheViewBox[0],\n            y = _this$_cacheViewBox[1],\n            w = _this$_cacheViewBox[2],\n            h = _this$_cacheViewBox[3];\n          var _this$_currentp = flow_slicedToArray(this._currentp, 2),\n            px = _this$_currentp[0],\n            py = _this$_currentp[1];\n          var _this$draggingbehavio2 = this.draggingbehavior.panInBorder,\n            padding = _this$draggingbehavio2.padding,\n            deltamovement = _this$draggingbehavio2.deltamovement;\n          var deltaX = 0;\n          var deltaY = 0;\n          if (px < x + padding) {\n            deltaX = deltamovement;\n          }\n          if (px > w - padding) {\n            deltaX = -deltamovement;\n          }\n          if (py < y + padding) {\n            deltaY = deltamovement;\n          }\n          if (py > h - padding) {\n            deltaY = -deltamovement;\n          }\n          if (this.__processOverAnime) {\n            this.__processOverAnime.cancel();\n          }\n          if (deltaX || deltaY) {\n            this.__processOverAnime = this.requestJFlowAnime(function () {\n              _this5.panHandler(deltaX, deltaY);\n            });\n          } else {\n            this.draggingbehavior.panInBorder.timer = null;\n          }\n        }\n      }\n    }\n  }, {\n    key: "_onDragover",\n    value: function _onDragover(event) {\n      var _this6 = this;\n      event.preventDefault();\n      event.stopPropagation();\n      if (this._lastDragState.processing) return;\n      this._lastDragState.processing = true;\n      var offsetX = event.offsetX,\n        offsetY = event.offsetY;\n      Object.assign(this._target.status, {\n        dragovering: true\n      });\n      this._targetLockOn([offsetX, offsetY]);\n      var instance = this._target.instance || this._target.link;\n      this._processDragOver(instance, event);\n      if (this._target.isLinkDirty || this._target.isInstanceDirty) {\n        Promise.resolve().then(function () {\n          // this._render();    \n          _this6._target.isLinkDirty = false;\n          _this6._target.isInstanceDirty = false;\n          _this6._lastDragState.processing = false;\n        });\n      } else {\n        this._lastDragState.processing = false;\n      }\n    }\n  }, {\n    key: "_cancelPanInBorder",\n    value: function _cancelPanInBorder() {\n      var _this$draggingbehavio3;\n      if (this.__processOverAnime) {\n        this.__processOverAnime.cancel();\n      }\n      if ((_this$draggingbehavio3 = this.draggingbehavior) !== null && _this$draggingbehavio3 !== void 0 && _this$draggingbehavio3.panInBorder) {\n        this.draggingbehavior.panInBorder.timer = null;\n      }\n    }\n  }, {\n    key: "_onDragLeave",\n    value: function _onDragLeave() {\n      this._cancelPanInBorder();\n    }\n  }, {\n    key: "_onDrop",\n    value: function _onDrop(event) {\n      var _this7 = this;\n      this._cancelPanInBorder();\n      var payload = this.consumeMessage();\n      var instance = payload === null || payload === void 0 ? void 0 : payload.instance;\n      if (this._dragOverTarget) {\n        var oldIns = this._dragOverTarget;\n        oldIns.dispatchEvent(new events(\'dragoverend\', {\n          event: event,\n          instance: oldIns\n        }));\n        this._dragOverTarget = null;\n      }\n      var _this$_target = this._target,\n        link = _this$_target.link,\n        target = _this$_target.instance;\n      var _this$_target$cache = this._target.cache,\n        point = _this$_target$cache.point,\n        belongs = _this$_target$cache.belongs;\n      if (link) {\n        /**\n         * 丢在线上事件\n         *\n         * @event BaseLink#drop\n         * @type {object}\n         * @property {Event} event           - 原始事件 \n         * @property {Object} instance       - 拖动的对象 \n         * @property {BaseLink} link         - 目标连线 \n         * @property {JFlow} jflow           - 当前JFlow对象 \n         * @property {Group|JFlow} belongs   - 连线所在的绘图栈的对象\n         * @property {number[]} point        - 已经计算到绘图栈对应坐标系下的坐标\n         */\n        // instance.anchor = point;\n        link.dispatchEvent(new events(\'drop\', {\n          event: event,\n          instance: instance,\n          link: link,\n          jflow: this,\n          belongs: belongs,\n          point: point\n        }));\n      } else if (target) {\n        /**\n         * 丢在节点上事件\n         *\n         * @event Node#drop\n         * @type {object}\n         * @property {Event} event           - 原始事件 \n         * @property {Object} instance       - 拖动的对象 \n         * @property {JFlow} jflow           - 当前JFlow对象 \n         * @property {Node} target           - 目标节点\n         * @property {number[]} point        - 已经计算到绘图栈对应坐标系下的坐标\n         */\n        target.bubbleEvent(new events(\'drop\', {\n          event: event,\n          instance: instance,\n          jflow: this,\n          target: target,\n          point: point,\n          bubbles: true\n        }));\n      } else {\n        /**\n        * 丢在主图上事件\n        *\n        * @event JFlow#drop\n        * @type {object}\n        * @property {Event} event           - 原始事件 \n        * @property {Object} instance       - 拖动的对象 \n        * @property {JFlow} jflow           - 当前JFlow对象 \n        * @property {number[]} point        - 已经计算到绘图栈对应坐标系下的坐标\n        */\n        this.dispatchEvent(new events(\'drop\', {\n          event: event,\n          instance: instance,\n          jflow: this,\n          target: target,\n          point: point\n        }));\n      }\n      requestAnimationFrame(function () {\n        _this7.cancelDrop();\n      });\n    }\n  }, {\n    key: "cancelDrop",\n    value: function cancelDrop() {\n      this._target.instance = null;\n      this._target.link = null;\n      Object.assign(this._target.status, {\n        dragovering: false\n      });\n    }\n\n    /**\n     * 缩放操作处理函数\n     * @param {Number} offsetX - 事件对象与canvas的内填充边（padding edge）在 X 轴方向上的偏移量。\n     * @param {Number} offsetY - 事件对象与canvas的内填充边（padding edge）在 Y 轴方向上的偏移量。 \n     * @param {Number} deltaX  - 水平滚动量\n     * @param {Number} deltaY  - 垂直滚动量\n     * @param {Number} event - 原生事件\n     */\n  }, {\n    key: "zoomHandler",\n    value: function zoomHandler(offsetX, offsetY, deltaX, deltaY, event) {\n      var _this8 = this;\n      // if(!this._allowZoom) return;\n      if (this._zooming) return;\n      this._zooming = true;\n      var _this$bounding_box3 = this.bounding_box,\n        p_width = _this$bounding_box3.width,\n        p_height = _this$bounding_box3.height,\n        x = _this$bounding_box3.x,\n        y = _this$bounding_box3.y;\n      var _this$canvasMeta = this.canvasMeta,\n        cw = _this$canvasMeta.actual_width,\n        ch = _this$canvasMeta.actual_height;\n      var minZoom = this.minZoom;\n      if (this.worldMargin) {\n        var m = this.worldMargin;\n        var maxWidth = p_width + m * 2;\n        var maxHeight = p_height + m * 2;\n        minZoom = Math.max(minZoom, Math.max(cw / maxWidth, ch / maxHeight));\n      }\n      var newScale = this.scale;\n      var amount = deltaY > 0 ? 1.05 : 1 / 1.05;\n      newScale *= amount;\n      newScale = Math.min(this.maxZoom, Math.max(minZoom, newScale));\n      // console.log(newScale);\n      // if (this.maxZoom && newScale > this.maxZoom){\n      //     // could just return but then won\'t stop exactly at maxZoom\n      //     newScale = this.maxZoom;\n      // }\n\n      // if(this.minZoom && newScale < this.minZoom) {\n      //     newScale = this.minZoom;\n      // }\n\n      var deltaScale = newScale - this.scale;\n      var currentWidth = p_width * this.scale;\n      var currentHeight = p_height * this.scale;\n      var deltaWidth = p_width * deltaScale;\n      var deltaHeight = p_height * deltaScale;\n      var tX = offsetX - this.position.x;\n      var tY = offsetY - this.position.y;\n      var pX = -tX / currentWidth;\n      var pY = -tY / currentHeight;\n      this.scale = newScale;\n      this._recalculatePosition(pX * deltaWidth, pY * deltaHeight);\n\n      // this.position.x += pX * deltaWidth;\n      // this.position.y += pY * deltaHeight;\n      // this.position.offsetX = this.position.x - x * newScale;\n      // this.position.offsetY = this.position.y - y * newScale;\n      this.dispatchEvent(new events(\'zoompan\', {\n        deltaX: 0,\n        deltaY: 0\n      }));\n      // this.setAnimeClock()\n      this.scheduleRender(function () {\n        _this8._zooming = false;\n      });\n      // requestAnimationFrame((timestamp) => {\n      //     this.setAnimeClock(timestamp);\n      //     this._render();\n      //     this._zooming = false;\n      // })\n    }\n    /**\n     * 平移画布操作处理函数\n     * @param {Number} deltaX  - 水平滚动量\n     * @param {Number} deltaY  - 垂直滚动量\n     * @param {Number} event - 原生事件\n     */\n  }, {\n    key: "panHandler",\n    value: function panHandler(deltaX, deltaY, event) {\n      var _this9 = this;\n      if (this._panning) return;\n      this._panning = true;\n      var dragging = this._target.status.dragging;\n      if (dragging) {\n        var movingtarget = this._target.moving;\n        if (movingtarget) {\n          if (this.draggingbehavior.panInBorder.allowMovingTargetInPan) {\n            movingtarget.forEach(function (t) {\n              t.anchor[0] += -deltaX / _this9.scale;\n              t.anchor[1] += -deltaY / _this9.scale;\n            });\n          }\n        }\n      }\n      this._recalculatePosition(deltaX, deltaY);\n      /**\n       * 缩放平移事件\n       *\n       * @event JFlow#zoompan\n      */\n      this.dispatchEvent(new events(\'zoompan\', {\n        deltaX: deltaX,\n        deltaY: deltaY\n      }));\n      this.scheduleRender(function () {\n        _this9._panning = false;\n      });\n      // requestAnimationFrame((timestamp) => {\n      //     this.setAnimeClock(timestamp);\n      //     this._render();\n      //     this._panning = false;\n      // })\n    }\n    /**\n     * 开始按压处理函数\n     * @param {Number} offsetX - 事件对象与canvas的内填充边（padding edge）在 X 轴方向上的偏移量。\n     * @param {Number} offsetY - 事件对象与canvas的内填充边（padding edge）在 Y 轴方向上的偏移量。 \n     * @param {Number} event - 原生事件\n     */\n  }, {\n    key: "pressStartHandler",\n    value: function pressStartHandler(offsetX, offsetY, event) {\n      var _this10 = this;\n      if (this.checkScrollDragging()) {\n        return;\n      }\n      Object.assign(this._target.meta, {\n        initialX: offsetX,\n        initialY: offsetY\n      });\n      var _this$_targetLockOn = this._targetLockOn([offsetX, offsetY], \'pressStart\'),\n        link = _this$_targetLockOn.link,\n        instance = _this$_targetLockOn.instance;\n      // 后续只支持 click 动作\n      if (this.mode === JFLOW_MODE.LINKING) return;\n      Object.assign(this._target.status, {\n        dragging: true,\n        processing: false\n      });\n      if (this._target.moving) {\n        var moving = this._getMovingTarget();\n        /**\n         * 开始拖动组的事件（特指lock的顶层组）\n         *\n         * @event Node#pressStart\n         * @type {object}\n         * @property {Event} event           - 原始事件 \n         * @property {Node} instance       - 拖动的对象 \n         * @property {JFlow} jflow           - 当前JFlow对象 \n         */\n        moving.dispatchEvent(new events(\'pressStart\', {\n          event: event,\n          instance: moving,\n          jflow: this\n        }));\n      }\n      var t = this._resolveLockOnTarget(link, instance);\n      if (t) {\n        /**\n         * 开始拖动对象事件（就是目标对象的拖动事件，事件支持冒泡）\n         *\n         * @event Node#instancePressStart\n         * @type {object}\n         * @property {Event} event           - 原始事件 \n         * @property {Node} instance     - 拖动的对象 \n         * @property {JFlow} jflow           - 当前JFlow对象 \n         * @property {Boolean} bubbles       - 冒泡\n         */\n        // const t = this._target.instance;\n        t.bubbleEvent(new events(\'instancePressStart\', {\n          event: event,\n          target: t,\n          jflow: this,\n          bubbles: true,\n          preventDefault: function preventDefault() {\n            _this10._preventPressSequeence = true;\n            _this10._clearTarget();\n            document.addEventListener(\'pointerup\', function (e) {\n              e.preventDefault();\n              e.stopPropagation();\n              _this10._preventPressSequeence = false;\n            }, {\n              once: true\n            });\n          }\n        }));\n      }\n      if (!this._preventPressSequeence) {\n        this.dispatchEvent(new events(\'jflowPressStart\', {\n          event: event,\n          jflow: this\n        }));\n      }\n    }\n    /**\n     * 按压中处理函数\n     * @param {Number} offsetX - 事件对象与canvas的内填充边（padding edge）在 X 轴方向上的偏移量。\n     * @param {Number} offsetY - 事件对象与canvas的内填充边（padding edge）在 Y 轴方向上的偏移量。 \n     * @param {Number} event - 原生事件\n     */\n  }, {\n    key: "pressMoveHandler",\n    value: function pressMoveHandler(offsetX, offsetY, event) {\n      var _this11 = this;\n      if (this._preventPressSequeence) {\n        return;\n      }\n      if (this.checkScrollDragging()) {\n        return;\n      }\n      var _this$_target$status = this._target.status,\n        dragging = _this$_target$status.dragging,\n        processing = _this$_target$status.processing;\n      var _this$_target$meta = this._target.meta,\n        x = _this$_target$meta.x,\n        y = _this$_target$meta.y;\n      // this.canvas.style.cursor = \'default\';\n      if (!dragging) {\n        if (this.checkScrollBarHover(offsetX, offsetY)) {\n          return;\n        } else {\n          this.resetScrollBarHover();\n        }\n      }\n      if (!dragging && !processing) {\n        var _this$_targetLockOn2 = this._targetLockOn([offsetX, offsetY]),\n          _link = _this$_targetLockOn2.link,\n          _instance = _this$_targetLockOn2.instance;\n        var t = this._resolveLockOnTarget(_link, _instance);\n        if (t) {\n          /**\n          * instance mousemove 原生事件，仅在无拖拽时触发\n          *\n          * @event Node#instancemousemove\n          * @type {object}\n          * @property {Event} event           - 原始事件\n          * @property {Node} instance           - 原始事件\n          * @property {JFlow} jflow           - 当前JFlow对象 \n          */\n          // instance.dispatchEvent(new JFlowEvent(\'instancemousemove\', {\n          //     event,\n          //     instance,\n          //     jflow: this,\n          // }))\n          t.bubbleEvent(new events(\'instancemousemove\', {\n            event: event,\n            instance: t,\n            jflow: this,\n            bubbles: true\n          }));\n        } else {\n          this.dispatchEvent(new events(\'instancemousemove\', {\n            event: event,\n            instance: null,\n            jflow: this\n          }));\n        }\n        if (this.mode === JFLOW_MODE.LINKING) {\n          // if(instance) {\n          //     instance.bubbleEvent(new JFlowEvent(\'linking\', {\n          //         event,\n          //         target: instance,\n          //         jflow: this,\n          //         bubbles: true,\n          //         callback: (p) => {\n          //             this._currentp = p;\n          //         }\n          //     }))\n          // }\n\n          this._tempNode.anchor = this._currentp;\n          this.scheduleRender(function () {\n            _this11._target.isLinkDirty = false;\n            _this11._target.isInstanceDirty = false;\n            _this11._target.status.processing = false;\n          });\n          this._processPanInBorder();\n          // requestAnimationFrame((timestamp) => {\n          //     this.setAnimeClock(timestamp);\n          //     this._render();\n          //     this._target.isLinkDirty = false; \n          //     this._target.isInstanceDirty = false;\n          //     this._target.status.processing = false;\n          // })\n          return;\n        }\n      }\n\n      /**\n       * canvas mousemove 原生事件\n       *\n       * @event JFlow#canvasmousemove\n       * @type {object}\n       * @property {Event} event           - 原始事件\n       * @property {JFlow} jflow           - 当前JFlow对象 \n       */\n      this.dispatchEvent(new events(\'canvasmousemove\', {\n        event: event,\n        jflow: this\n      }));\n      if (!dragging) return;\n      // this.canvas.style.cursor = \'grabbing\';\n      if (processing) return;\n      var movingtarget = this._target.moving; // this._tempNode ? [this._tempNode] : this._target.moving;\n      this._target.status.movingState = true;\n      this._target.status.processing = true;\n      var deltaX = offsetX - x;\n      var deltaY = offsetY - y;\n      if (movingtarget) {\n        if (this._allowMovingTarget) {\n          movingtarget.forEach(function (t) {\n            t.anchor[0] += deltaX / _this11.scale;\n            t.anchor[1] += deltaY / _this11.scale;\n          });\n        }\n      } else {\n        this._recalculatePosition(deltaX, deltaY);\n        this.dispatchEvent(new events(\'zoompan\', {\n          deltaX: deltaX,\n          deltaY: deltaY\n        }));\n      }\n      var _this$_targetLockOn3 = this._targetLockOn([offsetX, offsetY]),\n        instance = _this$_targetLockOn3.instance,\n        link = _this$_targetLockOn3.link;\n      this._processDragOver(instance || link, event);\n      this.scheduleRender(function () {\n        _this11._target.isLinkDirty = false;\n        _this11._target.isInstanceDirty = false;\n        _this11._target.status.processing = false;\n      });\n      // requestAnimationFrame((timestamp) => {\n      //     this._render();\n      //     this._target.isLinkDirty = false; \n      //     this._target.isInstanceDirty = false;\n      //     this._target.status.processing = false;\n      // })\n    }\n    /**\n     * 按压结束处理函数\n     * @param {Boolean} isDocument - 是否为 document 触发\n     * @param {Number} event - 原生事件\n     */\n  }, {\n    key: "pressUpHanlder",\n    value: function pressUpHanlder(isDocument, event) {\n      if (this._preventPressSequeence) {\n        return;\n      }\n      if (this.__processOverAnime) {\n        this.__processOverAnime.cancel();\n      }\n      this._dragOverTarget = null;\n      this._cancelPanInBorder();\n      // this.resetScollBarStatus();\n      var meta = this._target.meta;\n      if (this.mode === JFLOW_MODE.LINKING) {\n        var t = this._target.instance;\n        var payload = this.consumeMessage();\n        // console.log(payload)\n        var _preventDefault = false;\n        var preventDefault = function preventDefault() {\n          _preventDefault = true;\n        };\n        if (t) {\n          /**\n           * canvas mousemove 原生事件\n           *\n           * @event Node#link\n           * @type {object}\n           * @property {Event} event           - 原始事件\n           * @property {Node} target           - 原始事件\n           * @property {object} payload        - 传入的消息\n           * @property {JFlow} jflow           - 当前JFlow对象       - 当前JFlow对象 \n           */\n          t.bubbleEvent(new events(\'link\', {\n            event: event,\n            target: t,\n            jflow: this,\n            payload: payload,\n            bubbles: true,\n            link: this._tempLink,\n            preventDefault: preventDefault\n          }));\n        } else {\n          var offsetX = event.offsetX,\n            offsetY = event.offsetY;\n          this.dispatchEvent(new events(\'link\', {\n            event: event,\n            jflow: this,\n            payload: payload,\n            anchor: this._calculatePointBack([offsetX, offsetY]),\n            link: this._tempLink,\n            preventDefault: preventDefault\n          }));\n        }\n        if (_preventDefault) {\n          return;\n        }\n        this._clearTarget();\n        if (!this._preventClearTemp) {\n          if (this._tempNode) {\n            this._tempNode.destroy();\n            this._tempNode = null;\n          }\n          if (this._tempLink) {\n            this._tempLink.destroy();\n            this._tempLink = null;\n          }\n        }\n        this._preventClearTemp = false;\n        this.mode = JFLOW_MODE.DEFAULT;\n        this._render();\n        return;\n      }\n      if (this._target.moving) {\n        var checkresult = false;\n        if (this._layout["static"]) {\n          checkresult = this.staticCheck(this._getMovingTarget());\n        }\n        if (!checkresult && this._target.link) {\n          var _this$_target$cache2 = this._target.cache,\n            point = _this$_target$cache2.point,\n            belongs = _this$_target$cache2.belongs;\n          var link = this._target.link;\n          var instance = this._getMovingTarget();\n          /**\n           * 拖动到线上事件\n           *\n           * @event BaseLink#drop\n           * @type {object}\n           * @property {Event} event           - 原始事件 \n           * @property {Object} instance     - 拖动的对象 \n           * @property {BaseLink} link         - 目标连线 \n           * @property {JFlow} jflow           - 当前JFlow对象 \n           * @property {Group|JFlow} belongs   - 连线所在的绘图栈的对象\n           */\n          link.dispatchEvent(new events(\'drop\', {\n            event: event,\n            instance: instance,\n            link: link,\n            jflow: this,\n            belongs: belongs\n          }));\n          this._target.link = null;\n          this._target.instance = null;\n        } else if (this._target.moving) {\n          if (this._target.instance) {\n            /**\n             * 拖动后放置到 Instance 上的事件，由被拖动到的对象触发\n             *\n             * @event Node#pressEnd\n             * @type {object}\n             * @property {Event} event           - 原始事件 \n             * @property {Node} instance         - 拖动的对象 \n             * @property {JFlow} jflow           - 当前JFlow对象 \n             * @property {Instance} target       - 拖动到的对象\n             * @property {boolean} bubbles       - 冒泡\n             */\n            //  console.log(\'pressEnd\', this._target.instance)\n            this._target.instance.bubbleEvent(new events(\'pressEnd\', {\n              event: event,\n              instance: this._getMovingTarget(),\n              jflow: this,\n              target: this._target.instance,\n              bubbles: true\n            }));\n          } else {\n            /**\n             * 拖动后放置到主图上的事件\n             *\n             * @event JFlow#pressEnd\n             * @type {object}\n             * @property {Event} event           - 原始事件 \n             * @property {Instance} instance       - 拖动的对象 \n             * @property {JFlow} jflow           - 当前JFlow对象 \n             */\n            this.dispatchEvent(new events(\'pressEnd\', {\n              event: event,\n              instance: this._getMovingTarget(),\n              jflow: this\n            }));\n          }\n        }\n        this._target.moving = null;\n        this.removeTempDraggingInstance();\n        // this._target.isMovingDirty = false;\n        this._render();\n      }\n      this._clearTarget();\n    }\n    /**\n    * 菜单弹出处理函数\n    * @param {Number} offsetX - 事件对象与canvas的内填充边（padding edge）在 X 轴方向上的偏移量。\n    * @param {Number} offsetY - 事件对象与canvas的内填充边（padding edge）在 Y 轴方向上的偏移量。 \n    * @param {Number} event - 原生事件\n    */\n  }, {\n    key: "clickHanlder",\n    value: function clickHanlder(offsetX, offsetY, event) {\n      var _this$_targetLockOn4 = this._targetLockOn([offsetX, offsetY], \'click\'),\n        link = _this$_targetLockOn4.link,\n        instance = _this$_targetLockOn4.instance,\n        meta = _this$_targetLockOn4.meta;\n      if (Math.abs(meta.initialX - meta.x) < 1 && Math.abs(meta.initialY - meta.y) < 1) {\n        if (event.target !== this.canvas) {\n          this._clearTarget();\n          Object.assign(this._target.meta, {\n            initialX: undefined,\n            initialY: undefined\n          });\n          return;\n        }\n        var topLayerPoint = this._target.cache.topLayerPoint;\n        var t = this._resolveLockOnTarget(link, instance);\n        if (t) {\n          var target = t;\n          /**\n           * 点击事件（冒泡）\n           *\n           * @event Instance#contextclick\n           * @type {object}\n           * @property {Event} event           - 原始事件 \n           * @property {Instance} target       - 右键对象 \n           * @property {JFlow} jflow           - 当前JFlow对象\n           * @property {number[]} topLayerPoint  - jflow坐标系上的位置\n           * @property {Boolean} bubbles       - 冒泡\n           */\n          target.bubbleEvent(new events(\'click\', {\n            event: event,\n            jflow: this,\n            target: target,\n            topLayerPoint: topLayerPoint,\n            bubbles: true\n          }));\n        } else {\n          /**\n           * 点击事件\n           *\n           * @event JFlow#contextclick\n           * @type {object}\n           * @property {Event} event           - 原始事件 \n           * @property {JFlow} jflow           - 当前JFlow对象\n           * @property {number[]} topLayerPoint  - jflow坐标系上的位置\n           */\n          this.dispatchEvent(new events(\'click\', {\n            event: event,\n            jflow: this,\n            topLayerPoint: topLayerPoint\n          }));\n        }\n        this._clearTarget();\n        Object.assign(this._target.meta, {\n          initialX: undefined,\n          initialY: undefined\n        });\n      }\n    }\n    /**\n     * 菜单弹出处理函数\n     * @param {Number} offsetX - 事件对象与canvas的内填充边（padding edge）在 X 轴方向上的偏移量。\n     * @param {Number} offsetY - 事件对象与canvas的内填充边（padding edge）在 Y 轴方向上的偏移量。 \n     * @param {Number} event - 原生事件\n     */\n  }, {\n    key: "contextMenuHanlder",\n    value: function contextMenuHanlder(offsetX, offsetY, event) {\n      var _this$_targetLockOn5 = this._targetLockOn([offsetX, offsetY], \'contextclick\'),\n        link = _this$_targetLockOn5.link,\n        instance = _this$_targetLockOn5.instance;\n      var topLayerPoint = this._target.cache.topLayerPoint;\n      var t = this._resolveLockOnTarget(link, instance);\n      if (t) {\n        var target = t;\n        /**\n         * 右键事件（冒泡）\n         *\n         * @event Instance#contextclick\n         * @type {object}\n         * @property {Event} event           - 原始事件 \n         * @property {Instance} target       - 右键对象 \n         * @property {JFlow} jflow           - 当前JFlow对象\n         * @property {number[]} topLayerPoint  - jflow坐标系上的位置\n         * @property {Boolean} bubbles       - 冒泡\n         */\n        target.bubbleEvent(new events(\'contextclick\', {\n          event: event,\n          jflow: this,\n          target: target,\n          topLayerPoint: topLayerPoint,\n          bubbles: true\n        }));\n      } else {\n        /**\n         * 右键事件\n         *\n         * @event JFlow#contextclick\n         * @type {object}\n         * @property {Event} event           - 原始事件 \n         * @property {JFlow} jflow           - 当前JFlow对象\n         * @property {number[]} topLayerPoint  - jflow坐标系上的位置\n         */\n        this.dispatchEvent(new events(\'contextclick\', {\n          event: event,\n          jflow: this,\n          topLayerPoint: topLayerPoint\n        }));\n      }\n    }\n  }, {\n    key: "dblclickHandler",\n    value: function dblclickHandler(offsetX, offsetY, event) {\n      var _this$_targetLockOn6 = this._targetLockOn([offsetX, offsetY], \'dblclick\'),\n        link = _this$_targetLockOn6.link,\n        instance = _this$_targetLockOn6.instance;\n      var topLayerPoint = this._target.cache.topLayerPoint;\n      var t = this._resolveLockOnTarget(link, instance);\n      if (t) {\n        var target = t;\n        /**\n         * 右键事件\n         *\n         * @event Instance#dblclick\n         * @type {object}\n         * @property {Event} event           - 原始事件 \n         * @property {Instance} target       - 右键对象 \n         * @property {JFlow} jflow           - 当前JFlow对象\n         * @property {number[]} topLayerPoint  - jflow坐标系上的位置\n         * @property {Boolean} bubbles       - 冒泡\n         */\n        target.bubbleEvent(new events(\'dblclick\', {\n          event: event,\n          jflow: this,\n          target: target,\n          topLayerPoint: topLayerPoint,\n          bubbles: true\n        }));\n      } else {\n        this.dispatchEvent(new events(\'dblclick\', {\n          event: event,\n          jflow: this,\n          topLayerPoint: topLayerPoint\n        }));\n      }\n    }\n\n    /*_onZoom(event) {\n        event.preventDefault();\n        let { offsetX, offsetY, deltaX, deltaY } = event\n        if(event.ctrlKey) { \n            deltaY = -deltaY;\n            this.zoomHandler(offsetX, offsetY, deltaX, deltaY);\n        } else {\n            this.panHandler(-deltaX, -deltaY);\n        }\n    }\n     _onPressStart(event) { \n        const { offsetX, offsetY, deltaY, button } = event\n        if(button !== 0) return;\n        this.pressStartHandler(offsetX, offsetY);\n    }\n     _onPressMove(event) {\n        const { offsetX, offsetY } = event\n        this.pressMoveHandler(offsetX, offsetY);\n    }\n     _onPressUp(event, isDocument) {\n        event.preventDefault();\n        event.stopPropagation();\n        const { button } = event\n        if(button !== 0) return;\n        this.pressUpHanlder(isDocument)\n    }\n     _onPressUpDocument(event) {\n        this._onPressUp(event, true);\n    }\n     _onContextMenu(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        const { offsetX, offsetY } = event;\n        this.contextMenuHanlder(offsetX, offsetY);\n    }*/\n  }, {\n    key: "_resolveLockOnTarget",\n    value: function _resolveLockOnTarget(link, instance) {\n      return link !== null && link !== void 0 && link.ON_TOP ? link : instance || link;\n    }\n  }, {\n    key: "_clearTarget",\n    value: function _clearTarget() {\n      Object.assign(this._target.meta, {\n        x: undefined,\n        y: undefined\n        // initialX: undefined,\n        // initialY: undefined, \n      });\n\n      Object.assign(this._target.status, {\n        dragging: false,\n        processing: false,\n        movingState: false\n      });\n      Object.assign(this._target, {\n        instance: null,\n        link: null,\n        moving: null\n      });\n    }\n  }, {\n    key: "_recalculatePosition",\n    value: function _recalculatePosition(deltaX, deltaY, scale) {\n      var _this$bounding_box4 = this.bounding_box,\n        x = _this$bounding_box4.x,\n        y = _this$bounding_box4.y,\n        width = _this$bounding_box4.width,\n        height = _this$bounding_box4.height;\n      var _this$canvasMeta2 = this.canvasMeta,\n        cw = _this$canvasMeta2.actual_width,\n        ch = _this$canvasMeta2.actual_height;\n      if (scale === undefined) {\n        scale = this.scale;\n      }\n      if (this.worldMargin) {\n        // console.log(scale)\n        var m = this.worldMargin;\n        var bx1 = (x + width + m) * scale - cw;\n        var bx2 = (x - m) * scale;\n        // console.log(bx1, bx2)\n        var sx = x * scale;\n        var px = this.position.x + deltaX;\n        var cx = px - sx;\n        this.position.offsetX = Math.min(Math.max(-bx1, cx), -bx2);\n        // console.log(this.position.offsetX)\n        // this.position.offsetX = Math.max(Math.min(-bx2, cx), -bx1);\n        this.position.x = this.position.offsetX + sx;\n        // console.log(this.position.x, deltaX)\n        // console.log(this.position.offsetX)\n\n        var by1 = (y + height + m) * scale - ch;\n        var by2 = (y - m) * scale;\n        // console.log(by1, by2)\n        var sy = y * scale;\n        var py = this.position.y + deltaY;\n        var cy = py - sy;\n        this.position.offsetY = Math.min(Math.max(-by1, cy), -by2);\n        // this.position.offsetY = Math.max(Math.min(-by2, cy), -by1);\n        this.position.y = this.position.offsetY + sy;\n      } else {\n        this.position.x += deltaX;\n        this.position.y += deltaY;\n        this.position.offsetX = this.position.x - x * scale;\n        this.position.offsetY = this.position.y - y * scale;\n      }\n    }\n  }, {\n    key: "calculateToRealWorld",\n    value: function calculateToRealWorld(p) {\n      var scale = this.scale;\n      var position = this.position;\n      return [p[0] * scale + position.offsetX, p[1] * scale + position.offsetY];\n    }\n  }, {\n    key: "_calculatePointBack",\n    value: function _calculatePointBack(p) {\n      var scale = this.scale;\n      var position = this.position;\n      return [(p[0] - position.offsetX) / scale, (p[1] - position.offsetY) / scale];\n    }\n  }, {\n    key: "_calculatePointBackWithPoint",\n    value: function _calculatePointBackWithPoint(a, b, arr, idx1, idx2) {\n      var scale = this.scale;\n      var position = this.position;\n      arr[idx1] = (a - position.offsetX) / scale;\n      arr[idx2] = (b - position.offsetY) / scale;\n    }\n  }, {\n    key: "_calculateDistance",\n    value: function _calculateDistance(l) {\n      return this.scale * l;\n    }\n  }, {\n    key: "_resetTransform",\n    value: function _resetTransform() {\n      var _this$canvasMeta3 = this.canvasMeta,\n        c_width = _this$canvasMeta3.width,\n        c_height = _this$canvasMeta3.height;\n      var position = this.position;\n      var scale = this.scale;\n      var ctx = this.ctx;\n      ctx.setTransform();\n      ctx.clearRect(0, 0, c_width, c_height);\n      ctx.scale(this.dpr, this.dpr);\n      ctx.transform(scale, 0, 0, scale, position.offsetX, position.offsetY);\n      // ctx._ctx.setTransform();\n      // ctx._ctx.clearRect(0, 0, c_width, c_height);\n      // ctx._ctx.scale(this.dpr, this.dpr);\n      // ctx.transform(scale, position.offsetX, position.offsetY);\n    }\n  }, {\n    key: "resetTransform",\n    value: function resetTransform(ctx) {\n      var position = this.position;\n      var scale = this.scale;\n      ctx.setTransform();\n      ctx.scale(this.dpr, this.dpr);\n      ctx.transform(scale, 0, 0, scale, position.offsetX, position.offsetY);\n    }\n  }, {\n    key: "_getViewBox",\n    value: function _getViewBox() {\n      // const cacheViewBox = [\n      //     ...this._calculatePointBack([0,0]),\n      //     ...this._calculatePointBack([this.canvasMeta.actual_width,this.canvasMeta.actual_height]),\n      // ];\n      var cacheViewBox = this._cacheViewBox;\n      this._calculatePointBackWithPoint(0, 0, cacheViewBox, 0, 1);\n      this._calculatePointBackWithPoint(this.canvasMeta.actual_width, this.canvasMeta.actual_height, cacheViewBox, 2, 3);\n      return cacheViewBox;\n    }\n  }, {\n    key: "setNodeToTopLayer",\n    value: function setNodeToTopLayer(node) {\n      var index = this._stack.findIndex(function (n) {\n        return n === node;\n      });\n      if (index !== -1) {\n        var _this$_stack$splice = this._stack.splice(index, 1),\n          _this$_stack$splice2 = flow_slicedToArray(_this$_stack$splice, 1),\n          renderNode = _this$_stack$splice2[0];\n        this._stack.push(renderNode);\n      }\n    }\n  }, {\n    key: "getCacheViewBox",\n    value: function getCacheViewBox() {\n      return this._cacheViewBox;\n    }\n  }, {\n    key: "_render",\n    value: function _render() {\n      this.scheduleRender();\n    }\n\n    /**\n    * 绘制画布\n    */\n  }, {\n    key: "__render",\n    value: function __render() {\n      if (!this._readyToRender) return;\n      // if(this.hasAnimeAndFrameRendered()) return;\n      this.runAnimeFrame();\n      this._resetTransform();\n      var ctx = this.ctx;\n      this.dispatchEvent(new events(\'beforeJflowRender\', {\n        ctx: ctx\n      }));\n      var br = this._getViewBox();\n      if (this.NodeRenderTop) {\n        this._linkStack.render(ctx, function (link) {\n          return !link.ON_TOP && link.isInViewBox(br);\n        });\n        this._stack.render(ctx, function (instance) {\n          var result = doOverlap(br, instance.getBoundingRect());\n          instance._isInViewBox = result;\n          return result;\n        });\n        this._linkStack.render(ctx, function (link) {\n          return link.ON_TOP && link.isInViewBox(br);\n        });\n      } else {\n        this._stack.render(ctx, function (instance) {\n          var result = doOverlap(br, instance.getBoundingRect());\n          // console.log(instance._layoutNode.type, result)\n          instance._isInViewBox = result;\n          return result;\n        });\n        this._linkStack.render(ctx, function (link) {\n          return link.isInViewBox(br);\n        });\n      }\n      // ctx.save();\n      // for(let i =0;i<2000;i++) {\n      //     ctx.beginPath();\n      //     ctx.fillStyle = `rgb(${parseInt(Math.random()*255)},${parseInt(Math.random()*255)},${parseInt(Math.random()*255)})`\n      //     ctx.fillRect(\n      //         Math.random()*250, \n      //         Math.random()*240, \n      //         Math.random()*200, \n      //         Math.random()*300)\n      // }\n\n      // ctx.restore();\n\n      if (this._tempNode) {\n        ctx.save();\n        this._tempNode.render(ctx);\n        ctx.restore();\n      }\n      if (this._tempLink) {\n        ctx.save();\n        this._tempLink.isInViewBox(br);\n        this._tempLink.render(ctx);\n        ctx.restore();\n      }\n      this.dispatchEvent(new events(\'afterJflowRender\', {\n        ctx: ctx\n      }));\n      this.renderScrollBar(ctx);\n      // this.setFrameRendered();\n    }\n  }]);\n  return JFlow;\n}( /*#__PURE__*/flow_wrapNativeSuper(EventTarget));\nObject.assign(JFlow.prototype, messageMixin);\nObject.assign(JFlow.prototype, stackMixin);\nObject.assign(JFlow.prototype, layoutMixin);\nObject.assign(JFlow.prototype, {\n  recalculateUp: function recalculateUp() {\n    if (this.__mounted__) {\n      this.reflow();\n    }\n  }\n});\nObject.assign(JFlow.prototype, NodeWeakMapMixin);\nObject.assign(JFlow.prototype, animeMixin);\nObject.assign(JFlow.prototype, minimap_mixin);\nObject.assign(JFlow.prototype, schedule);\nObject.assign(JFlow.prototype, scrollbarMixin);\n/* harmony default export */ const flow = (JFlow);\n\n\n\n\n\n\n\n\n// export { default as Group } from \'../instance/shapes/rectangle-group\';\n\n\n// export { default as CapsuleGroup } from \'../instance/shapes/capsule-group\';\n// export { default as CapsuleVerticalGroup } from \'../instance/shapes/capsule-vertical-group\';\n\n// export { default as DiamondGroup } from \'../instance/shapes/diamond-group\';\n// export { default as DiamondVerticalGroup } from \'../instance/shapes/diamond-vertical-group\';\n\n// export { default as RhombusGroup } from \'../instance/shapes/rhombus-group\';\n\n\n\n\n\n\n\n\n// export { default as TreeLayout } from \'../ler-layouta;yout/tree-layout\';\n// export { default as Lowcodelayout } from \'../layout/low-code-layout\';\n// export { default as ERLayout } from \'../layout/er-layout/er-layout\';\n// export { default as Orange } from \'../instance/nodeWrapper/orange/orange\'\n// export { default as TextEditor } from \'../instance/text-editor\';\n// export { default as TextGroup} from \'../instance/text-group\';\n\n\n// export { JFlowPath2D } from \'../utils/path-2d\';\n\n\n\n;// CONCATENATED MODULE: ./src/index.js\n\n\n/* harmony default export */ const src = (flow);\n\n// export { default as JFlowVuePlugin, JFlowLinkGroup } from \'./vue-plugin/JFlowPlugin.js\';\nflow.$jflow_version = package_namespaceObject.i8;\n// console.log(`jflow version@${packageJson.version}`)//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU0EsWUFBWUEsQ0FBQ0MsT0FBTyxFQUFFO0VBQ2xDLElBQU1DLE1BQU0sR0FBR0MsUUFBUSxDQUFDQyxhQUFhLENBQUMsUUFBUSxDQUFDO0VBQy9DLElBQU1DLEdBQUcsR0FBR0gsTUFBTSxDQUFDSSxVQUFVLENBQUMsSUFBSSxDQUFDO0VBQ25DLElBQUFDLHFCQUFBLEdBQXFDTixPQUFPLENBQUNPLHFCQUFxQixDQUFDLENBQUM7SUFBNURDLEtBQUssR0FBQUYscUJBQUEsQ0FBTEUsS0FBSztJQUFFQyxNQUFNLEdBQUFILHFCQUFBLENBQU5HLE1BQU07SUFBRUMsSUFBSSxHQUFBSixxQkFBQSxDQUFKSSxJQUFJO0lBQUVDLEdBQUcsR0FBQUwscUJBQUEsQ0FBSEssR0FBRztFQUNoQ1YsTUFBTSxDQUFDVyxLQUFLLENBQUNKLEtBQUssR0FBR0EsS0FBSyxHQUFHLElBQUk7RUFDakNQLE1BQU0sQ0FBQ1csS0FBSyxDQUFDSCxNQUFNLEdBQUdBLE1BQU0sR0FBRyxJQUFJO0VBQ25DUixNQUFNLENBQUNXLEtBQUssQ0FBQ0MsVUFBVSxHQUFHLE1BQU07RUFDaEMsSUFBTUMsS0FBSyxHQUFHQyxNQUFNLENBQUNDLGdCQUFnQjtFQUNyQ2YsTUFBTSxDQUFDTyxLQUFLLEdBQUdTLElBQUksQ0FBQ0MsS0FBSyxDQUFDVixLQUFLLEdBQUdNLEtBQUssQ0FBQztFQUN4Q2IsTUFBTSxDQUFDUSxNQUFNLEdBQUdRLElBQUksQ0FBQ0MsS0FBSyxDQUFDVCxNQUFNLEdBQUdLLEtBQUssQ0FBQztFQUUxQyxJQUFHZCxPQUFPLEVBQUU7SUFDUkEsT0FBTyxDQUFDWSxLQUFLLENBQUNPLFFBQVEsR0FBRyxVQUFVO0lBQ25DbkIsT0FBTyxDQUFDWSxLQUFLLENBQUNRLFFBQVEsR0FBRyxRQUFRO0lBQ2pDcEIsT0FBTyxDQUFDcUIsTUFBTSxDQUFDcEIsTUFBTSxDQUFDO0VBQzFCO0VBQ0EsT0FBTztJQUNIQSxNQUFNLEVBQU5BLE1BQU07SUFDTk8sS0FBSyxFQUFMQSxLQUFLO0lBQ0xDLE1BQU0sRUFBTkEsTUFBTTtJQUNOYSxTQUFTLEVBQUVyQixNQUFNLENBQUNPLEtBQUs7SUFDdkJlLFVBQVUsRUFBRXRCLE1BQU0sQ0FBQ1EsTUFBTTtJQUN6QkMsSUFBSSxFQUFKQSxJQUFJO0lBQ0pDLEdBQUcsRUFBSEEsR0FBRztJQUNIUCxHQUFHLEVBQUhBLEdBQUc7SUFDSFUsS0FBSyxFQUFMQTtFQUNKLENBQUM7QUFDTDtBQUVPLFNBQVNVLG1CQUFZQSxDQUFDdkIsTUFBTSxFQUFFRCxPQUFPLEVBQUU7RUFDMUMsSUFBQXlCLHNCQUFBLEdBQXFDekIsT0FBTyxDQUFDTyxxQkFBcUIsQ0FBQyxDQUFDO0lBQTVEQyxLQUFLLEdBQUFpQixzQkFBQSxDQUFMakIsS0FBSztJQUFFQyxNQUFNLEdBQUFnQixzQkFBQSxDQUFOaEIsTUFBTTtJQUFFQyxJQUFJLEdBQUFlLHNCQUFBLENBQUpmLElBQUk7SUFBRUMsR0FBRyxHQUFBYyxzQkFBQSxDQUFIZCxHQUFHO0VBQ2hDVixNQUFNLENBQUNXLEtBQUssQ0FBQ0osS0FBSyxHQUFHQSxLQUFLLEdBQUcsSUFBSTtFQUNqQ1AsTUFBTSxDQUFDVyxLQUFLLENBQUNILE1BQU0sR0FBR0EsTUFBTSxHQUFHLElBQUk7RUFDbkMsSUFBTUssS0FBSyxHQUFHQyxNQUFNLENBQUNDLGdCQUFnQjtFQUNyQ2YsTUFBTSxDQUFDTyxLQUFLLEdBQUdTLElBQUksQ0FBQ0MsS0FBSyxDQUFDVixLQUFLLEdBQUdNLEtBQUssQ0FBQztFQUN4Q2IsTUFBTSxDQUFDUSxNQUFNLEdBQUdRLElBQUksQ0FBQ0MsS0FBSyxDQUFDVCxNQUFNLEdBQUdLLEtBQUssQ0FBQztFQUMxQyxPQUFPO0lBQ0hOLEtBQUssRUFBTEEsS0FBSztJQUNMQyxNQUFNLEVBQU5BLE1BQU07SUFDTmEsU0FBUyxFQUFFckIsTUFBTSxDQUFDTyxLQUFLO0lBQ3ZCZSxVQUFVLEVBQUV0QixNQUFNLENBQUNRO0VBQ3ZCLENBQUM7QUFDTDtBQUVBLElBQU1pQixVQUFVLEdBQUd4QixRQUFRLENBQUNDLGFBQWEsQ0FBQyxRQUFRLENBQUM7QUFDbkR1QixVQUFVLENBQUNsQixLQUFLLEdBQUcsQ0FBQztBQUNwQmtCLFVBQVUsQ0FBQ2pCLE1BQU0sR0FBRyxDQUFDO0FBQ3JCLElBQU1rQixhQUFhLEdBQUdELFVBQVUsQ0FBQ3JCLFVBQVUsQ0FBQyxJQUFJLENBQUM7QUFDakQsSUFBTVMsS0FBSyxHQUFHQyxNQUFNLENBQUNDLGdCQUFnQjtBQUNyQ1csYUFBYSxDQUFDYixLQUFLLENBQUNBLEtBQUssRUFBRUEsS0FBSyxDQUFDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNjLGtCQUFrQkEsQ0FBQ0MsTUFBTSxFQUFFO0VBQ3ZDRixhQUFhLENBQUNHLFNBQVMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUM7RUFDaENILGFBQWEsQ0FBQ0ksSUFBSSxDQUFDLENBQUM7RUFDcEJGLE1BQU0sQ0FBQ0YsYUFBYSxDQUFDO0VBQ3JCQSxhQUFhLENBQUNLLE9BQU8sQ0FBQyxDQUFDO0VBQ3ZCTCxhQUFhLENBQUNHLFNBQVMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUM7QUFDcEM7QUFFTyxTQUFTRyx3QkFBd0JBLENBQUNDLFFBQVEsRUFBRUMsY0FBYyxFQUFFO0VBQy9ELElBQU1DLE1BQU0sR0FBR0MsVUFBVSxpQkFBQUMsTUFBQSxDQUNMdkIsTUFBTSxDQUFDQyxnQkFBZ0IsVUFDM0MsQ0FBQztFQUNELFNBQVN1QixRQUFRQSxDQUFBLEVBQUc7SUFDbEJDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLDRCQUE0QixHQUFHMUIsTUFBTSxDQUFDQyxnQkFBZ0IsQ0FBQztJQUNuRWtCLFFBQVEsQ0FBQ25CLE1BQU0sQ0FBQ0MsZ0JBQWdCLENBQUM7SUFDakNpQix3QkFBd0IsQ0FBQ0MsUUFBUSxFQUFFQyxjQUFjLENBQUM7RUFDcEQ7RUFDQUEsY0FBYyxDQUFDLFlBQU07SUFDakJLLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLHVDQUF1QyxDQUFDO0lBQ3BETCxNQUFNLENBQUNNLG1CQUFtQixDQUFDLFFBQVEsRUFBRUgsUUFBUSxFQUFFO01BQUVJLElBQUksRUFBRTtJQUFLLENBQUMsQ0FBQztFQUNsRSxDQUFDLENBQUM7RUFDRlAsTUFBTSxDQUFDUSxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUVMLFFBQVEsRUFBRTtJQUFFSSxJQUFJLEVBQUU7RUFBSyxDQUFDLENBQUM7QUFDL0QsQzs7QUMvRnFDOztBQUVyQztBQUNBLFFBQVEsd0NBQXdDOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGFBQWE7QUFDYixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsV0FBVyxxREFBcUQ7QUFDaEUsV0FBVyxxREFBcUQ7QUFDaEU7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHFCQUFxQixNQUFNLFlBQVksUUFBUTs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FB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LENBQUMsR0FBRyxDQUFDLEdBQUNDLENBQUMsR0FBQ0EsQ0FBQyxHQUFDNUMsQ0FBQyxHQUFDMkMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBQ0MsQ0FBQyxHQUFDNUMsQ0FBQyxHQUFDQSxDQUFDLEdBQUMyQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUczQyxDQUFDLEdBQUNBLENBQUMsR0FBQ0EsQ0FBQyxHQUFDMkMsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUMvRCxJQUFNRSxDQUFDLEdBQUdELENBQUMsR0FBQ0EsQ0FBQyxJQUFFRCxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUNBLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBQzNDLENBQUMsR0FBQzRDLENBQUMsSUFBRUQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFDQSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRzNDLENBQUMsR0FBQ0EsQ0FBQyxJQUFFMkMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFDQSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDL0QsSUFBTWhELENBQUMsR0FBR2lELENBQUMsR0FBQ0EsQ0FBQyxJQUFFRCxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUNBLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBQzNDLENBQUMsR0FBQzRDLENBQUMsSUFBRUQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFDQSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRzNDLENBQUMsR0FBQ0EsQ0FBQyxJQUFFMkMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFDQSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDL0QsSUFBSUcsS0FBSyxHQUFHakgsSUFBSSxDQUFDa0gsS0FBSyxDQUFDcEQsQ0FBQyxFQUFFa0QsQ0FBQyxDQUFDO0VBQzVCO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsT0FBTyxDQUFDOUQsQ0FBQyxFQUFFQyxDQUFDLEVBQUU4RCxLQUFLLENBQUM7QUFDeEI7O0FBRUE7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O0lBQ1osSUFBRyxJQUFJLENBQUM2WixXQUFXLEVBQUU7TUFDakIsSUFBSSxDQUFDalEsTUFBTSxDQUFDLENBQUM7SUFDakI7RUFDSjtBQUNKLENBQUMsQ0FBQztBQUVGdFUsTUFBTSxDQUFDUSxNQUFNLENBQUMyd0MsS0FBSyxDQUFDNy9CLFNBQVMsRUFBRTNCLGdCQUFnQixDQUFDO0FBQ2hEM1AsTUFBTSxDQUFDUSxNQUFNLENBQUMyd0MsS0FBSyxDQUFDNy9CLFNBQVMsRUFBRWkvQixVQUFVLENBQUM7QUFDMUN2d0MsTUFBTSxDQUFDUSxNQUFNLENBQUMyd0MsS0FBSyxDQUFDNy9CLFNBQVMsRUFBRWsvQixhQUFZLENBQUM7QUFDNUN4d0MsTUFBTSxDQUFDUSxNQUFNLENBQUMyd0MsS0FBSyxDQUFDNy9CLFNBQVMsRUFBRW8vQixRQUFhLENBQUM7QUFDN0Mxd0MsTUFBTSxDQUFDUSxNQUFNLENBQUMyd0MsS0FBSyxDQUFDNy9CLFNBQVMsRUFBRW0vQixjQUFjLENBQUM7QUFFOUMsMkNBQWVVLEtBQUssRUFBQztBQUMyQjtBQUNFO0FBQ3NCO0FBQ2I7QUFDUjtBQUNTO0FBQ0E7QUFDUTtBQUNwRTtBQUNnRTtBQUNpQjtBQUNqRjtBQUNBO0FBQ2dFO0FBQ2hFO0FBQ0E7QUFDZ0U7QUFDaEU7QUFDNEQ7QUFDUjtBQUNTO0FBQ007QUFDaEI7QUFDUztBQUNJO0FBQ0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3dFO0FBQ1g7QUFDN0Q7O0FBRStEOzs7QUN0ekRyQjtBQUNLO0FBQy9DLDBDQUFlQSxJQUFLLEVBQUM7QUFDTztBQUM1QjtBQUNBQSxtQkFBb0IsR0FBR21KLDBCQUFtQjtBQUMxQyIsInNvdXJjZXMiOlsid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS91dGlscy9jYW52YXMuanM/Y2ZhMSIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vbm9kZV9tb2R1bGVzL2Jlemllci1qcy9zcmMvdXRpbHMuanM/MDBmYSIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vbm9kZV9tb2R1bGVzL2Jlemllci1qcy9zcmMvcG9seS1iZXppZXIuanM/ZDgxOCIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vbm9kZV9tb2R1bGVzL2Jlemllci1qcy9zcmMvYmV6aWVyLmpzPzM1ZDEiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL3V0aWxzL2NvbnN0YW5jZS5qcz9lMjdkIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS91dGlscy9mdW5jdGlvbnMuanM/Y2U1ZiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvaW5zdGFuY2UuanM/YWQ2MCIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvZGlydHktd29yay9kaXJ0eS13b3JrLmpzPzQxMDYiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL25vZGUuanM/MmJhOSIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvZ2hvc3ROb2RlLmpzPzcwNjAiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL25vZGVXZWFrTWFwLmpzPzQ0YjEiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3N0YWNrLmpzP2I0YjUiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3N0YWNrTWl4aW4uanM/ODAxNiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvbGF5b3V0TWl4aW4uanM/N2ZkNyIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvbWVzc2FnZU1peGluLmpzP2Q2YmMiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2FuaW1lL2FuaW1lTWl4aW4uanM/NzA1YyIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvbWluaU1hcC9taW5pbWFwLW1peGluLmpzPzBlZTYiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2V2ZW50cy9pbmRleC5qcz9mM2NmIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9zY3JvbGxiYXIvc2Nyb2xsYmFyTWl4aW4uanM/ZDQ1ZSIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvZmxvdy9zY2hlZHVsZS5qcz9lNzFmIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9ldmVudHMvYWRhcHRlci5qcz82YjQzIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS9ncm91cEZhY3RvcnkuanM/MTdkNiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2Uvc2hhcGVzL3BvaW50LmpzPzE3MTYiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3NoYXBlcy9yZWN0YW5nbGUuanM/YWM1ZSIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2Uvc2hhcGVzL2NhcHN1bGUuanM/Y2Q3MCIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2Uvc2hhcGVzL2NhcHN1bGUtdmVydGljYWwuanM/M2EyMCIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2Uvc2hhcGVzL3Job21idXMuanM/Yzg0YiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2Uvc2hhcGVzL2RpYW1vbmQuanM/YzU1ZiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2Uvc2hhcGVzL2RpYW1vbmQtdmVydGljYWwuanM/MzNlZiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvZ3JvdXBzL3Njcm9sbC1ncm91cC5qcz8zNGJlIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9ldmVudHMvY29tbW9uQWRhcHRlci5qcz9mODUxIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS9iYXNlLWxpbmsuanM/OGY4MiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2Uvc2hhcGVzL3NoYWRvdy1jYWNoZS5qcz8yNzhmIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS9lbGVtZW50cy90ZXh0LmpzPzdjODIiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL2ltYWdlLmpzPzc4YjYiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3NoYWRvd0RvbS5qcz9hZmE5Iiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS9saW5rLmpzPzMxZDMiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3BvbHktbGluay5qcz9mMWQzIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS9iZXppZXItbGluay5qcz9kOGVmIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9sYXlvdXQvbGluZWFyLWxheW91dC5qcz85YzhhIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS90ZXh0LWdyb3VwL2Jhc2UvY29uc3RhbnRzLmpzP2ZjYjkiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3RleHQtZ3JvdXAvYmFzZS9zaGFkb3ctaW5wdXQuanM/ODAwNiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvdGV4dC1ncm91cC9iYXNlL2NhcmV0LmpzPzFjOWMiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3RleHQtZ3JvdXAvdXRpbHMuanM/MWI1NiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvdGV4dC1ncm91cC9zdG9yYWdlL2luZGV4LmpzPzRhNGIiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3RleHQtZ3JvdXAvYmFzZS9yYW5nZS5qcz9kZDFhIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS90ZXh0LWdyb3VwL3VuZG9yZWRvLmpzP2YzZGQiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3RleHQtZ3JvdXAvY29tbWFuZC9iYXNlLmpzP2JiYmIiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3RleHQtZ3JvdXAvY29tbWFuZC9tb3ZlbWVudC5qcz81YTZmIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS90ZXh0LWdyb3VwL2NvbW1hbmQvaW5wdXQuanM/ZmExMSIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvdGV4dC1ncm91cC9jb21tYW5kL21vdXNlLmpzPzg3OGIiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3RleHQtZ3JvdXAvY29tbWFuZC9zaGlmdC5qcz8zMTA2Iiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS90ZXh0LWdyb3VwL2NvbW1hbmQvY3RybC5qcz8yMDZiIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS90ZXh0LWdyb3VwL2NvbW1hbmQvdW5kb3JlZG8uanM/OWU5MiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvdGV4dC1ncm91cC9jb21tYW5kL2NsaXBib2FyZC5qcz85ZTZiIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS90ZXh0LWdyb3VwL2NvbW1hbmQvaW5kZXguanM/NzgwZSIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvdGV4dC1ncm91cC90ZXh0LWdyb3VwLmpzPzRmYzEiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL25vZGUtcGxhY2Vob2xkZXIuanM/ODgyYSIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvZmxvdy9pbmRleC5qcz85MzA3Iiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ2FudmFzTWV0YVxuICogQHByb3BlcnR5IHtFbGVtZW50fSBjYW52YXMgLSBjYW52YXMg5YWD57SgXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggLSDnlLvluIPlrr3luqZcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSDnlLvluIPpq5jluqZcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByYXdfd2lkdGggLSDnlLvluIPlhYPntKDlrr3luqZcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByYXdfaGVpZ2h0IC0g55S75biD5YWD57Sg6auY5bqmXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGVmdCAtIOeUu+W4g+i3neemu+W3puerr+i3neemu1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHRvcCAtIOeUu+W4g+i3neemu+mhtuerr+i3neemu1xuICogQHByb3BlcnR5IHtDb250ZXh0MmR9IGN0eCAtIENvbnRleHQyZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNjYWxlIC0g5b2T5YmN55qE5YOP57Sg6K6+5aSH5q+UXG4gKi9cbi8qKlxuICog5Yib5bu65LiA5LiqIGNhbnZhcyDlhYPntKBcbiAqIEBwYXJhbSAge0VsZW1lbnR9IHdyYXBwZXIgLSBkb23lhYPntKBcbiAqIEByZXR1cm4ge0NhbnZhc01ldGF9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDYW52YXMod3JhcHBlcikge1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgbGVmdCwgdG9wIH0gPSB3cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gICAgY2FudmFzLnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgY29uc3Qgc2NhbGUgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICBjYW52YXMud2lkdGggPSBNYXRoLmZsb29yKHdpZHRoICogc2NhbGUpO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBNYXRoLmZsb29yKGhlaWdodCAqIHNjYWxlKTtcblxuICAgIGlmKHdyYXBwZXIpIHtcbiAgICAgICAgd3JhcHBlci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgIHdyYXBwZXIuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgd3JhcHBlci5hcHBlbmQoY2FudmFzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2FudmFzLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICByYXdfd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgICAgcmF3X2hlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgICAgbGVmdCxcbiAgICAgICAgdG9wLFxuICAgICAgICBjdHgsXG4gICAgICAgIHNjYWxlLFxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc2l6ZUNhbnZhcyhjYW52YXMsIHdyYXBwZXIpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIGxlZnQsIHRvcCB9ID0gd3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgIGNvbnN0IHNjYWxlID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgY2FudmFzLndpZHRoID0gTWF0aC5mbG9vcih3aWR0aCAqIHNjYWxlKTtcbiAgICBjYW52YXMuaGVpZ2h0ID0gTWF0aC5mbG9vcihoZWlnaHQgKiBzY2FsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgcmF3X3dpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICAgIHJhd19oZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgfVxufVxuXG5jb25zdCBjYWhlQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5jYWhlQ2FudmFzLndpZHRoID0gMTtcbmNhaGVDYW52YXMuaGVpZ2h0ID0gMTtcbmNvbnN0IGNhaGVDYW52YXNjdHggPSBjYWhlQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5jb25zdCBzY2FsZSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuY2FoZUNhbnZhc2N0eC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuXG4vKipcbiAqIOWcqOemu+e6v2NhbnZhc+S4iue7mOWItuWFg+e0oFxuICogQHBhcmFtICB7cmVuZGVyfSByZW5kZXIgLSDnu5jlm77lh73mlbBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcXVlc3RDYWNoZUNhbnZhcyhyZW5kZXIpIHtcbiAgICBjYWhlQ2FudmFzY3R4LmNsZWFyUmVjdCgwLDAsNSw1KTtcbiAgICBjYWhlQ2FudmFzY3R4LnNhdmUoKTtcbiAgICByZW5kZXIoY2FoZUNhbnZhc2N0eCk7XG4gICAgY2FoZUNhbnZhc2N0eC5yZXN0b3JlKCk7XG4gICAgY2FoZUNhbnZhc2N0eC5jbGVhclJlY3QoMCwwLDUsNSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5PbkRldmljZVBpeGVsUmF0aW8oY2FsbGJhY2ssIGRlc3Ryb3lIYW5kbGVyKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gbWF0Y2hNZWRpYShcbiAgICAgICAgYChyZXNvbHV0aW9uOiAke3dpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfWRwcHgpYFxuICAgICk7XG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImRldmljZVBpeGVsUmF0aW8gY2hhbmdlZDogXCIgKyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgICBjYWxsYmFjayh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgICBsaXN0ZW5PbkRldmljZVBpeGVsUmF0aW8oY2FsbGJhY2ssIGRlc3Ryb3lIYW5kbGVyKTtcbiAgICB9XG4gICAgZGVzdHJveUhhbmRsZXIoKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygncmVtb3ZlIGRldmljZVBpeGVsUmF0aW8gZXZlbnQgaGFuZGxlcicpXG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIG9uQ2hhbmdlLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfSlcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBvbkNoYW5nZSwgeyBvbmNlOiB0cnVlIH0pO1xufSIsImltcG9ydCB7IEJlemllciB9IGZyb20gXCIuL2Jlemllci5qc1wiO1xuXG4vLyBtYXRoLWlubGluaW5nLlxuY29uc3QgeyBhYnMsIGNvcywgc2luLCBhY29zLCBhdGFuMiwgc3FydCwgcG93IH0gPSBNYXRoO1xuXG4vLyBjdWJlIHJvb3QgZnVuY3Rpb24geWllbGRpbmcgcmVhbCByb290c1xuZnVuY3Rpb24gY3J0KHYpIHtcbiAgcmV0dXJuIHYgPCAwID8gLXBvdygtdiwgMSAvIDMpIDogcG93KHYsIDEgLyAzKTtcbn1cblxuLy8gdHJpZyBjb25zdGFudHNcbmNvbnN0IHBpID0gTWF0aC5QSSxcbiAgdGF1ID0gMiAqIHBpLFxuICBxdWFydCA9IHBpIC8gMixcbiAgLy8gZmxvYXQgcHJlY2lzaW9uIHNpZ25pZmljYW50IGRlY2ltYWxcbiAgZXBzaWxvbiA9IDAuMDAwMDAxLFxuICAvLyBleHRyZW1hcyB1c2VkIGluIGJib3ggY2FsY3VsYXRpb24gYW5kIHNpbWlsYXIgYWxnb3JpdGhtc1xuICBuTWF4ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MSxcbiAgbk1pbiA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSIHx8IC05MDA3MTk5MjU0NzQwOTkxLFxuICAvLyBhIHplcm8gY29vcmRpbmF0ZSwgd2hpY2ggaXMgc3VycHJpc2luZ2x5IHVzZWZ1bFxuICBaRVJPID0geyB4OiAwLCB5OiAwLCB6OiAwIH07XG5cbi8vIEJlemllciB1dGlsaXR5IGZ1bmN0aW9uc1xuY29uc3QgdXRpbHMgPSB7XG4gIC8vIExlZ2VuZHJlLUdhdXNzIGFic2Npc3NhZSB3aXRoIG49MjQgKHhfaSB2YWx1ZXMsIGRlZmluZWQgYXQgaT1uIGFzIHRoZSByb290cyBvZiB0aGUgbnRoIG9yZGVyIExlZ2VuZHJlIHBvbHlub21pYWwgUG4oeCkpXG4gIFR2YWx1ZXM6IFtcbiAgICAtMC4wNjQwNTY4OTI4NjI2MDU2MjYwODUwNDMwODI2MjQ3NDUwMzg1OTA5LFxuICAgIDAuMDY0MDU2ODkyODYyNjA1NjI2MDg1MDQzMDgyNjI0NzQ1MDM4NTkwOSxcbiAgICAtMC4xOTExMTg4Njc0NzM2MTYzMDkxNTg2Mzk4MjA3NTcwNjk2MzE4NDA0LFxuICAgIDAuMTkxMTE4ODY3NDczNjE2MzA5MTU4NjM5ODIwNzU3MDY5NjMxODQwNCxcbiAgICAtMC4zMTUwNDI2Nzk2OTYxNjMzNzQzODY3OTMyOTEzMTk4MTAyNDA3ODY0LFxuICAgIDAuMzE1MDQyNjc5Njk2MTYzMzc0Mzg2NzkzMjkxMzE5ODEwMjQwNzg2NCxcbiAgICAtMC40MzM3OTM1MDc2MjYwNDUxMzg0ODcwODQyMzE5MTMzNDk3MTI0NTI0LFxuICAgIDAuNDMzNzkzNTA3NjI2MDQ1MTM4NDg3MDg0MjMxOTEzMzQ5NzEyNDUyNCxcbiAgICAtMC41NDU0MjE0NzEzODg4Mzk1MzU2NTgzNzU2MTcyMTgzNzIzNzAwMTA3LFxuICAgIDAuNTQ1NDIxNDcxMzg4ODM5NTM1NjU4Mzc1NjE3MjE4MzcyMzcwMDEwNyxcbiAgICAtMC42NDgwOTM2NTE5MzY5NzU1NjkyNTI0OTU3ODY5MTA3NDc2MjY2Njk2LFxuICAgIDAuNjQ4MDkzNjUxOTM2OTc1NTY5MjUyNDk1Nzg2OTEwNzQ3NjI2NjY5NixcbiAgICAtMC43NDAxMjQxOTE1Nzg1NTQzNjQyNDM4MjgxMDMwOTk5Nzg0MjU1MjMyLFxuICAgIDAuNzQwMTI0MTkxNTc4NTU0MzY0MjQzODI4MTAzMDk5OTc4NDI1NTIzMixcbiAgICAtMC44MjAwMDE5ODU5NzM5MDI5MjE5NTM5NDk4NzI2Njk3NDUyMDgwNzYxLFxuICAgIDAuODIwMDAxOTg1OTczOTAyOTIxOTUzOTQ5ODcyNjY5NzQ1MjA4MDc2MSxcbiAgICAtMC44ODY0MTU1MjcwMDQ0MDEwMzQyMTMxNTQzNDE5ODIxOTY3NTUwODczLFxuICAgIDAuODg2NDE1NTI3MDA0NDAxMDM0MjEzMTU0MzQxOTgyMTk2NzU1MDg3MyxcbiAgICAtMC45MzgyNzQ1NTIwMDI3MzI3NTg1MjM2NDkwMDE3MDg3MjE0NDk2NTQ4LFxuICAgIDAuOTM4Mjc0NTUyMDAyNzMyNzU4NTIzNjQ5MDAxNzA4NzIxNDQ5NjU0OCxcbiAgICAtMC45NzQ3Mjg1NTU5NzEzMDk0OTgxOTgzOTE5OTMwMDgxNjkwNjE3NDExLFxuICAgIDAuOTc0NzI4NTU1OTcxMzA5NDk4MTk4MzkxOTkzMDA4MTY5MDYxNzQxMSxcbiAgICAtMC45OTUxODcyMTk5OTcwMjEzNjAxNzk5OTc0MDk3MDA3MzY4MTE4NzQ1LFxuICAgIDAuOTk1MTg3MjE5OTk3MDIxMzYwMTc5OTk3NDA5NzAwNzM2ODExODc0NSxcbiAgXSxcblxuICAvLyBMZWdlbmRyZS1HYXVzcyB3ZWlnaHRzIHdpdGggbj0yNCAod19pIHZhbHVlcywgZGVmaW5lZCBieSBhIGZ1bmN0aW9uIGxpbmtlZCB0byBpbiB0aGUgQmV6aWVyIHByaW1lciBhcnRpY2xlKVxuICBDdmFsdWVzOiBbXG4gICAgMC4xMjc5MzgxOTUzNDY3NTIxNTY5NzQwNTYxNjUyMjQ2OTUzNzE4NTE3LFxuICAgIDAuMTI3OTM4MTk1MzQ2NzUyMTU2OTc0MDU2MTY1MjI0Njk1MzcxODUxNyxcbiAgICAwLjEyNTgzNzQ1NjM0NjgyODI5NjEyMTM3NTM4MjUxMTE4MzY4ODcyNjQsXG4gICAgMC4xMjU4Mzc0NTYzNDY4MjgyOTYxMjEzNzUzODI1MTExODM2ODg3MjY0LFxuICAgIDAuMTIxNjcwNDcyOTI3ODAzMzkxMjA0NDYzMTUzNDc2MjYyNDI1NjA3LFxuICAgIDAuMTIxNjcwNDcyOTI3ODAzMzkxMjA0NDYzMTUzNDc2MjYyNDI1NjA3LFxuICAgIDAuMTE1NTA1NjY4MDUzNzI1NjAxMzUzMzQ0NDgzOTA2NzgzNTU5ODYyMixcbiAgICAwLjExNTUwNTY2ODA1MzcyNTYwMTM1MzM0NDQ4MzkwNjc4MzU1OTg2MjIsXG4gICAgMC4xMDc0NDQyNzAxMTU5NjU2MzQ3ODI1NzczNDI0NDY2MDYyMjI3OTQ2LFxuICAgIDAuMTA3NDQ0MjcwMTE1OTY1NjM0NzgyNTc3MzQyNDQ2NjA2MjIyNzk0NixcbiAgICAwLjA5NzYxODY1MjEwNDExMzg4ODI2OTg4MDY2NDQ2NDI0NzE1NDQyNzksXG4gICAgMC4wOTc2MTg2NTIxMDQxMTM4ODgyNjk4ODA2NjQ0NjQyNDcxNTQ0Mjc5LFxuICAgIDAuMDg2MTkwMTYxNTMxOTUzMjc1OTE3MTg1MjAyOTgzNzQyNjY3MTg1LFxuICAgIDAuMDg2MTkwMTYxNTMxOTUzMjc1OTE3MTg1MjAyOTgzNzQyNjY3MTg1LFxuICAgIDAuMDczMzQ2NDgxNDExMDgwMzA1NzM0MDMzNjE1MjUzMTE2NTE4MTE5MyxcbiAgICAwLjA3MzM0NjQ4MTQxMTA4MDMwNTczNDAzMzYxNTI1MzExNjUxODExOTMsXG4gICAgMC4wNTkyOTg1ODQ5MTU0MzY3ODA3NDYzNjc3NTg1MDAxMDg1ODQ1NDEyLFxuICAgIDAuMDU5Mjk4NTg0OTE1NDM2NzgwNzQ2MzY3NzU4NTAwMTA4NTg0NTQxMixcbiAgICAwLjA0NDI3NzQzODgxNzQxOTgwNjE2ODYwMjc0ODIxMTMzODIyODg1OTMsXG4gICAgMC4wNDQyNzc0Mzg4MTc0MTk4MDYxNjg2MDI3NDgyMTEzMzgyMjg4NTkzLFxuICAgIDAuMDI4NTMxMzg4NjI4OTMzNjYzMTgxMzA3ODE1OTUxODc4Mjg2NDQ5MSxcbiAgICAwLjAyODUzMTM4ODYyODkzMzY2MzE4MTMwNzgxNTk1MTg3ODI4NjQ0OTEsXG4gICAgMC4wMTIzNDEyMjk3OTk5ODcxOTk1NDY4MDU2NjcwNzAwMzcyOTE1NzU5LFxuICAgIDAuMDEyMzQxMjI5Nzk5OTg3MTk5NTQ2ODA1NjY3MDcwMDM3MjkxNTc1OSxcbiAgXSxcblxuICBhcmNmbjogZnVuY3Rpb24gKHQsIGRlcml2YXRpdmVGbikge1xuICAgIGNvbnN0IGQgPSBkZXJpdmF0aXZlRm4odCk7XG4gICAgbGV0IGwgPSBkLnggKiBkLnggKyBkLnkgKiBkLnk7XG4gICAgaWYgKHR5cGVvZiBkLnogIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGwgKz0gZC56ICogZC56O1xuICAgIH1cbiAgICByZXR1cm4gc3FydChsKTtcbiAgfSxcblxuICBjb21wdXRlOiBmdW5jdGlvbiAodCwgcG9pbnRzLCBfM2QpIHtcbiAgICAvLyBzaG9ydGN1dHNcbiAgICBpZiAodCA9PT0gMCkge1xuICAgICAgcG9pbnRzWzBdLnQgPSAwO1xuICAgICAgcmV0dXJuIHBvaW50c1swXTtcbiAgICB9XG5cbiAgICBjb25zdCBvcmRlciA9IHBvaW50cy5sZW5ndGggLSAxO1xuXG4gICAgaWYgKHQgPT09IDEpIHtcbiAgICAgIHBvaW50c1tvcmRlcl0udCA9IDE7XG4gICAgICByZXR1cm4gcG9pbnRzW29yZGVyXTtcbiAgICB9XG5cbiAgICBjb25zdCBtdCA9IDEgLSB0O1xuICAgIGxldCBwID0gcG9pbnRzO1xuXG4gICAgLy8gY29uc3RhbnQ/XG4gICAgaWYgKG9yZGVyID09PSAwKSB7XG4gICAgICBwb2ludHNbMF0udCA9IHQ7XG4gICAgICByZXR1cm4gcG9pbnRzWzBdO1xuICAgIH1cblxuICAgIC8vIGxpbmVhcj9cbiAgICBpZiAob3JkZXIgPT09IDEpIHtcbiAgICAgIGNvbnN0IHJldCA9IHtcbiAgICAgICAgeDogbXQgKiBwWzBdLnggKyB0ICogcFsxXS54LFxuICAgICAgICB5OiBtdCAqIHBbMF0ueSArIHQgKiBwWzFdLnksXG4gICAgICAgIHQ6IHQsXG4gICAgICB9O1xuICAgICAgaWYgKF8zZCkge1xuICAgICAgICByZXQueiA9IG10ICogcFswXS56ICsgdCAqIHBbMV0uejtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLy8gcXVhZHJhdGljL2N1YmljIGN1cnZlP1xuICAgIGlmIChvcmRlciA8IDQpIHtcbiAgICAgIGxldCBtdDIgPSBtdCAqIG10LFxuICAgICAgICB0MiA9IHQgKiB0LFxuICAgICAgICBhLFxuICAgICAgICBiLFxuICAgICAgICBjLFxuICAgICAgICBkID0gMDtcbiAgICAgIGlmIChvcmRlciA9PT0gMikge1xuICAgICAgICBwID0gW3BbMF0sIHBbMV0sIHBbMl0sIFpFUk9dO1xuICAgICAgICBhID0gbXQyO1xuICAgICAgICBiID0gbXQgKiB0ICogMjtcbiAgICAgICAgYyA9IHQyO1xuICAgICAgfSBlbHNlIGlmIChvcmRlciA9PT0gMykge1xuICAgICAgICBhID0gbXQyICogbXQ7XG4gICAgICAgIGIgPSBtdDIgKiB0ICogMztcbiAgICAgICAgYyA9IG10ICogdDIgKiAzO1xuICAgICAgICBkID0gdCAqIHQyO1xuICAgICAgfVxuICAgICAgY29uc3QgcmV0ID0ge1xuICAgICAgICB4OiBhICogcFswXS54ICsgYiAqIHBbMV0ueCArIGMgKiBwWzJdLnggKyBkICogcFszXS54LFxuICAgICAgICB5OiBhICogcFswXS55ICsgYiAqIHBbMV0ueSArIGMgKiBwWzJdLnkgKyBkICogcFszXS55LFxuICAgICAgICB0OiB0LFxuICAgICAgfTtcbiAgICAgIGlmIChfM2QpIHtcbiAgICAgICAgcmV0LnogPSBhICogcFswXS56ICsgYiAqIHBbMV0ueiArIGMgKiBwWzJdLnogKyBkICogcFszXS56O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvLyBoaWdoZXIgb3JkZXIgY3VydmVzOiB1c2UgZGUgQ2FzdGVsamF1J3MgY29tcHV0YXRpb25cbiAgICBjb25zdCBkQ3B0cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocG9pbnRzKSk7XG4gICAgd2hpbGUgKGRDcHRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZENwdHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGRDcHRzW2ldID0ge1xuICAgICAgICAgIHg6IGRDcHRzW2ldLnggKyAoZENwdHNbaSArIDFdLnggLSBkQ3B0c1tpXS54KSAqIHQsXG4gICAgICAgICAgeTogZENwdHNbaV0ueSArIChkQ3B0c1tpICsgMV0ueSAtIGRDcHRzW2ldLnkpICogdCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBkQ3B0c1tpXS56ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgZENwdHNbaV0gPSBkQ3B0c1tpXS56ICsgKGRDcHRzW2kgKyAxXS56IC0gZENwdHNbaV0ueikgKiB0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkQ3B0cy5zcGxpY2UoZENwdHMubGVuZ3RoIC0gMSwgMSk7XG4gICAgfVxuICAgIGRDcHRzWzBdLnQgPSB0O1xuICAgIHJldHVybiBkQ3B0c1swXTtcbiAgfSxcblxuICBjb21wdXRlV2l0aFJhdGlvczogZnVuY3Rpb24gKHQsIHBvaW50cywgcmF0aW9zLCBfM2QpIHtcbiAgICBjb25zdCBtdCA9IDEgLSB0LFxuICAgICAgciA9IHJhdGlvcyxcbiAgICAgIHAgPSBwb2ludHM7XG5cbiAgICBsZXQgZjEgPSByWzBdLFxuICAgICAgZjIgPSByWzFdLFxuICAgICAgZjMgPSByWzJdLFxuICAgICAgZjQgPSByWzNdLFxuICAgICAgZDtcblxuICAgIC8vIHNwZWMgZm9yIGxpbmVhclxuICAgIGYxICo9IG10O1xuICAgIGYyICo9IHQ7XG5cbiAgICBpZiAocC5sZW5ndGggPT09IDIpIHtcbiAgICAgIGQgPSBmMSArIGYyO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogKGYxICogcFswXS54ICsgZjIgKiBwWzFdLngpIC8gZCxcbiAgICAgICAgeTogKGYxICogcFswXS55ICsgZjIgKiBwWzFdLnkpIC8gZCxcbiAgICAgICAgejogIV8zZCA/IGZhbHNlIDogKGYxICogcFswXS56ICsgZjIgKiBwWzFdLnopIC8gZCxcbiAgICAgICAgdDogdCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gdXBncmFkZSB0byBxdWFkcmF0aWNcbiAgICBmMSAqPSBtdDtcbiAgICBmMiAqPSAyICogbXQ7XG4gICAgZjMgKj0gdCAqIHQ7XG5cbiAgICBpZiAocC5sZW5ndGggPT09IDMpIHtcbiAgICAgIGQgPSBmMSArIGYyICsgZjM7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAoZjEgKiBwWzBdLnggKyBmMiAqIHBbMV0ueCArIGYzICogcFsyXS54KSAvIGQsXG4gICAgICAgIHk6IChmMSAqIHBbMF0ueSArIGYyICogcFsxXS55ICsgZjMgKiBwWzJdLnkpIC8gZCxcbiAgICAgICAgejogIV8zZCA/IGZhbHNlIDogKGYxICogcFswXS56ICsgZjIgKiBwWzFdLnogKyBmMyAqIHBbMl0ueikgLyBkLFxuICAgICAgICB0OiB0LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB1cGdyYWRlIHRvIGN1YmljXG4gICAgZjEgKj0gbXQ7XG4gICAgZjIgKj0gMS41ICogbXQ7XG4gICAgZjMgKj0gMyAqIG10O1xuICAgIGY0ICo9IHQgKiB0ICogdDtcblxuICAgIGlmIChwLmxlbmd0aCA9PT0gNCkge1xuICAgICAgZCA9IGYxICsgZjIgKyBmMyArIGY0O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogKGYxICogcFswXS54ICsgZjIgKiBwWzFdLnggKyBmMyAqIHBbMl0ueCArIGY0ICogcFszXS54KSAvIGQsXG4gICAgICAgIHk6IChmMSAqIHBbMF0ueSArIGYyICogcFsxXS55ICsgZjMgKiBwWzJdLnkgKyBmNCAqIHBbM10ueSkgLyBkLFxuICAgICAgICB6OiAhXzNkXG4gICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgIDogKGYxICogcFswXS56ICsgZjIgKiBwWzFdLnogKyBmMyAqIHBbMl0ueiArIGY0ICogcFszXS56KSAvIGQsXG4gICAgICAgIHQ6IHQsXG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICBkZXJpdmU6IGZ1bmN0aW9uIChwb2ludHMsIF8zZCkge1xuICAgIGNvbnN0IGRwb2ludHMgPSBbXTtcbiAgICBmb3IgKGxldCBwID0gcG9pbnRzLCBkID0gcC5sZW5ndGgsIGMgPSBkIC0gMTsgZCA+IDE7IGQtLSwgYy0tKSB7XG4gICAgICBjb25zdCBsaXN0ID0gW107XG4gICAgICBmb3IgKGxldCBqID0gMCwgZHB0OyBqIDwgYzsgaisrKSB7XG4gICAgICAgIGRwdCA9IHtcbiAgICAgICAgICB4OiBjICogKHBbaiArIDFdLnggLSBwW2pdLngpLFxuICAgICAgICAgIHk6IGMgKiAocFtqICsgMV0ueSAtIHBbal0ueSksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChfM2QpIHtcbiAgICAgICAgICBkcHQueiA9IGMgKiAocFtqICsgMV0ueiAtIHBbal0ueik7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdC5wdXNoKGRwdCk7XG4gICAgICB9XG4gICAgICBkcG9pbnRzLnB1c2gobGlzdCk7XG4gICAgICBwID0gbGlzdDtcbiAgICB9XG4gICAgcmV0dXJuIGRwb2ludHM7XG4gIH0sXG5cbiAgYmV0d2VlbjogZnVuY3Rpb24gKHYsIG0sIE0pIHtcbiAgICByZXR1cm4gKFxuICAgICAgKG0gPD0gdiAmJiB2IDw9IE0pIHx8XG4gICAgICB1dGlscy5hcHByb3hpbWF0ZWx5KHYsIG0pIHx8XG4gICAgICB1dGlscy5hcHByb3hpbWF0ZWx5KHYsIE0pXG4gICAgKTtcbiAgfSxcblxuICBhcHByb3hpbWF0ZWx5OiBmdW5jdGlvbiAoYSwgYiwgcHJlY2lzaW9uKSB7XG4gICAgcmV0dXJuIGFicyhhIC0gYikgPD0gKHByZWNpc2lvbiB8fCBlcHNpbG9uKTtcbiAgfSxcblxuICBsZW5ndGg6IGZ1bmN0aW9uIChkZXJpdmF0aXZlRm4pIHtcbiAgICBjb25zdCB6ID0gMC41LFxuICAgICAgbGVuID0gdXRpbHMuVHZhbHVlcy5sZW5ndGg7XG5cbiAgICBsZXQgc3VtID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwLCB0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHQgPSB6ICogdXRpbHMuVHZhbHVlc1tpXSArIHo7XG4gICAgICBzdW0gKz0gdXRpbHMuQ3ZhbHVlc1tpXSAqIHV0aWxzLmFyY2ZuKHQsIGRlcml2YXRpdmVGbik7XG4gICAgfVxuICAgIHJldHVybiB6ICogc3VtO1xuICB9LFxuXG4gIG1hcDogZnVuY3Rpb24gKHYsIGRzLCBkZSwgdHMsIHRlKSB7XG4gICAgY29uc3QgZDEgPSBkZSAtIGRzLFxuICAgICAgZDIgPSB0ZSAtIHRzLFxuICAgICAgdjIgPSB2IC0gZHMsXG4gICAgICByID0gdjIgLyBkMTtcbiAgICByZXR1cm4gdHMgKyBkMiAqIHI7XG4gIH0sXG5cbiAgbGVycDogZnVuY3Rpb24gKHIsIHYxLCB2Mikge1xuICAgIGNvbnN0IHJldCA9IHtcbiAgICAgIHg6IHYxLnggKyByICogKHYyLnggLSB2MS54KSxcbiAgICAgIHk6IHYxLnkgKyByICogKHYyLnkgLSB2MS55KSxcbiAgICB9O1xuICAgIGlmICh2MS56ICE9PSB1bmRlZmluZWQgJiYgdjIueiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXQueiA9IHYxLnogKyByICogKHYyLnogLSB2MS56KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICBwb2ludFRvU3RyaW5nOiBmdW5jdGlvbiAocCkge1xuICAgIGxldCBzID0gcC54ICsgXCIvXCIgKyBwLnk7XG4gICAgaWYgKHR5cGVvZiBwLnogIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHMgKz0gXCIvXCIgKyBwLno7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9LFxuXG4gIHBvaW50c1RvU3RyaW5nOiBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgcmV0dXJuIFwiW1wiICsgcG9pbnRzLm1hcCh1dGlscy5wb2ludFRvU3RyaW5nKS5qb2luKFwiLCBcIikgKyBcIl1cIjtcbiAgfSxcblxuICBjb3B5OiBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gIH0sXG5cbiAgYW5nbGU6IGZ1bmN0aW9uIChvLCB2MSwgdjIpIHtcbiAgICBjb25zdCBkeDEgPSB2MS54IC0gby54LFxuICAgICAgZHkxID0gdjEueSAtIG8ueSxcbiAgICAgIGR4MiA9IHYyLnggLSBvLngsXG4gICAgICBkeTIgPSB2Mi55IC0gby55LFxuICAgICAgY3Jvc3MgPSBkeDEgKiBkeTIgLSBkeTEgKiBkeDIsXG4gICAgICBkb3QgPSBkeDEgKiBkeDIgKyBkeTEgKiBkeTI7XG4gICAgcmV0dXJuIGF0YW4yKGNyb3NzLCBkb3QpO1xuICB9LFxuXG4gIC8vIHJvdW5kIGFzIHN0cmluZywgdG8gYXZvaWQgcm91bmRpbmcgZXJyb3JzXG4gIHJvdW5kOiBmdW5jdGlvbiAodiwgZCkge1xuICAgIGNvbnN0IHMgPSBcIlwiICsgdjtcbiAgICBjb25zdCBwb3MgPSBzLmluZGV4T2YoXCIuXCIpO1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHMuc3Vic3RyaW5nKDAsIHBvcyArIDEgKyBkKSk7XG4gIH0sXG5cbiAgZGlzdDogZnVuY3Rpb24gKHAxLCBwMikge1xuICAgIGNvbnN0IGR4ID0gcDEueCAtIHAyLngsXG4gICAgICBkeSA9IHAxLnkgLSBwMi55O1xuICAgIHJldHVybiBzcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgfSxcblxuICBjbG9zZXN0OiBmdW5jdGlvbiAoTFVULCBwb2ludCkge1xuICAgIGxldCBtZGlzdCA9IHBvdygyLCA2MyksXG4gICAgICBtcG9zLFxuICAgICAgZDtcbiAgICBMVVQuZm9yRWFjaChmdW5jdGlvbiAocCwgaWR4KSB7XG4gICAgICBkID0gdXRpbHMuZGlzdChwb2ludCwgcCk7XG4gICAgICBpZiAoZCA8IG1kaXN0KSB7XG4gICAgICAgIG1kaXN0ID0gZDtcbiAgICAgICAgbXBvcyA9IGlkeDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4geyBtZGlzdDogbWRpc3QsIG1wb3M6IG1wb3MgfTtcbiAgfSxcblxuICBhYmNyYXRpbzogZnVuY3Rpb24gKHQsIG4pIHtcbiAgICAvLyBzZWUgcmF0aW8odCkgbm90ZSBvbiBodHRwOi8vcG9tYXguZ2l0aHViLmlvL2JlemllcmluZm8vI2FiY1xuICAgIGlmIChuICE9PSAyICYmIG4gIT09IDMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0ID0gMC41O1xuICAgIH0gZWxzZSBpZiAodCA9PT0gMCB8fCB0ID09PSAxKSB7XG4gICAgICByZXR1cm4gdDtcbiAgICB9XG4gICAgY29uc3QgYm90dG9tID0gcG93KHQsIG4pICsgcG93KDEgLSB0LCBuKSxcbiAgICAgIHRvcCA9IGJvdHRvbSAtIDE7XG4gICAgcmV0dXJuIGFicyh0b3AgLyBib3R0b20pO1xuICB9LFxuXG4gIHByb2plY3Rpb25yYXRpbzogZnVuY3Rpb24gKHQsIG4pIHtcbiAgICAvLyBzZWUgdSh0KSBub3RlIG9uIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby8jYWJjXG4gICAgaWYgKG4gIT09IDIgJiYgbiAhPT0gMykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHQgPSAwLjU7XG4gICAgfSBlbHNlIGlmICh0ID09PSAwIHx8IHQgPT09IDEpIHtcbiAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgICBjb25zdCB0b3AgPSBwb3coMSAtIHQsIG4pLFxuICAgICAgYm90dG9tID0gcG93KHQsIG4pICsgdG9wO1xuICAgIHJldHVybiB0b3AgLyBib3R0b207XG4gIH0sXG5cbiAgbGxpODogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCkge1xuICAgIGNvbnN0IG54ID1cbiAgICAgICAgKHgxICogeTIgLSB5MSAqIHgyKSAqICh4MyAtIHg0KSAtICh4MSAtIHgyKSAqICh4MyAqIHk0IC0geTMgKiB4NCksXG4gICAgICBueSA9ICh4MSAqIHkyIC0geTEgKiB4MikgKiAoeTMgLSB5NCkgLSAoeTEgLSB5MikgKiAoeDMgKiB5NCAtIHkzICogeDQpLFxuICAgICAgZCA9ICh4MSAtIHgyKSAqICh5MyAtIHk0KSAtICh5MSAtIHkyKSAqICh4MyAtIHg0KTtcbiAgICBpZiAoZCA9PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB7IHg6IG54IC8gZCwgeTogbnkgLyBkIH07XG4gIH0sXG5cbiAgbGxpNDogZnVuY3Rpb24gKHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgY29uc3QgeDEgPSBwMS54LFxuICAgICAgeTEgPSBwMS55LFxuICAgICAgeDIgPSBwMi54LFxuICAgICAgeTIgPSBwMi55LFxuICAgICAgeDMgPSBwMy54LFxuICAgICAgeTMgPSBwMy55LFxuICAgICAgeDQgPSBwNC54LFxuICAgICAgeTQgPSBwNC55O1xuICAgIHJldHVybiB1dGlscy5sbGk4KHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCk7XG4gIH0sXG5cbiAgbGxpOiBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxsaTQodjEsIHYxLmMsIHYyLCB2Mi5jKTtcbiAgfSxcblxuICBtYWtlbGluZTogZnVuY3Rpb24gKHAxLCBwMikge1xuICAgIGNvbnN0IHgxID0gcDEueCxcbiAgICAgIHkxID0gcDEueSxcbiAgICAgIHgyID0gcDIueCxcbiAgICAgIHkyID0gcDIueSxcbiAgICAgIGR4ID0gKHgyIC0geDEpIC8gMyxcbiAgICAgIGR5ID0gKHkyIC0geTEpIC8gMztcbiAgICByZXR1cm4gbmV3IEJlemllcihcbiAgICAgIHgxLFxuICAgICAgeTEsXG4gICAgICB4MSArIGR4LFxuICAgICAgeTEgKyBkeSxcbiAgICAgIHgxICsgMiAqIGR4LFxuICAgICAgeTEgKyAyICogZHksXG4gICAgICB4MixcbiAgICAgIHkyXG4gICAgKTtcbiAgfSxcblxuICBmaW5kYmJveDogZnVuY3Rpb24gKHNlY3Rpb25zKSB7XG4gICAgbGV0IG14ID0gbk1heCxcbiAgICAgIG15ID0gbk1heCxcbiAgICAgIE1YID0gbk1pbixcbiAgICAgIE1ZID0gbk1pbjtcbiAgICBzZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICBjb25zdCBiYm94ID0gcy5iYm94KCk7XG4gICAgICBpZiAobXggPiBiYm94LngubWluKSBteCA9IGJib3gueC5taW47XG4gICAgICBpZiAobXkgPiBiYm94LnkubWluKSBteSA9IGJib3gueS5taW47XG4gICAgICBpZiAoTVggPCBiYm94LngubWF4KSBNWCA9IGJib3gueC5tYXg7XG4gICAgICBpZiAoTVkgPCBiYm94LnkubWF4KSBNWSA9IGJib3gueS5tYXg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHsgbWluOiBteCwgbWlkOiAobXggKyBNWCkgLyAyLCBtYXg6IE1YLCBzaXplOiBNWCAtIG14IH0sXG4gICAgICB5OiB7IG1pbjogbXksIG1pZDogKG15ICsgTVkpIC8gMiwgbWF4OiBNWSwgc2l6ZTogTVkgLSBteSB9LFxuICAgIH07XG4gIH0sXG5cbiAgc2hhcGVpbnRlcnNlY3Rpb25zOiBmdW5jdGlvbiAoXG4gICAgczEsXG4gICAgYmJveDEsXG4gICAgczIsXG4gICAgYmJveDIsXG4gICAgY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGRcbiAgKSB7XG4gICAgaWYgKCF1dGlscy5iYm94b3ZlcmxhcChiYm94MSwgYmJveDIpKSByZXR1cm4gW107XG4gICAgY29uc3QgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICAgIGNvbnN0IGExID0gW3MxLnN0YXJ0Y2FwLCBzMS5mb3J3YXJkLCBzMS5iYWNrLCBzMS5lbmRjYXBdO1xuICAgIGNvbnN0IGEyID0gW3MyLnN0YXJ0Y2FwLCBzMi5mb3J3YXJkLCBzMi5iYWNrLCBzMi5lbmRjYXBdO1xuICAgIGExLmZvckVhY2goZnVuY3Rpb24gKGwxKSB7XG4gICAgICBpZiAobDEudmlydHVhbCkgcmV0dXJuO1xuICAgICAgYTIuZm9yRWFjaChmdW5jdGlvbiAobDIpIHtcbiAgICAgICAgaWYgKGwyLnZpcnR1YWwpIHJldHVybjtcbiAgICAgICAgY29uc3QgaXNzID0gbDEuaW50ZXJzZWN0cyhsMiwgY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGQpO1xuICAgICAgICBpZiAoaXNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpc3MuYzEgPSBsMTtcbiAgICAgICAgICBpc3MuYzIgPSBsMjtcbiAgICAgICAgICBpc3MuczEgPSBzMTtcbiAgICAgICAgICBpc3MuczIgPSBzMjtcbiAgICAgICAgICBpbnRlcnNlY3Rpb25zLnB1c2goaXNzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH0sXG5cbiAgbWFrZXNoYXBlOiBmdW5jdGlvbiAoZm9yd2FyZCwgYmFjaywgY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGQpIHtcbiAgICBjb25zdCBicGwgPSBiYWNrLnBvaW50cy5sZW5ndGg7XG4gICAgY29uc3QgZnBsID0gZm9yd2FyZC5wb2ludHMubGVuZ3RoO1xuICAgIGNvbnN0IHN0YXJ0ID0gdXRpbHMubWFrZWxpbmUoYmFjay5wb2ludHNbYnBsIC0gMV0sIGZvcndhcmQucG9pbnRzWzBdKTtcbiAgICBjb25zdCBlbmQgPSB1dGlscy5tYWtlbGluZShmb3J3YXJkLnBvaW50c1tmcGwgLSAxXSwgYmFjay5wb2ludHNbMF0pO1xuICAgIGNvbnN0IHNoYXBlID0ge1xuICAgICAgc3RhcnRjYXA6IHN0YXJ0LFxuICAgICAgZm9yd2FyZDogZm9yd2FyZCxcbiAgICAgIGJhY2s6IGJhY2ssXG4gICAgICBlbmRjYXA6IGVuZCxcbiAgICAgIGJib3g6IHV0aWxzLmZpbmRiYm94KFtzdGFydCwgZm9yd2FyZCwgYmFjaywgZW5kXSksXG4gICAgfTtcbiAgICBzaGFwZS5pbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gKHMyKSB7XG4gICAgICByZXR1cm4gdXRpbHMuc2hhcGVpbnRlcnNlY3Rpb25zKFxuICAgICAgICBzaGFwZSxcbiAgICAgICAgc2hhcGUuYmJveCxcbiAgICAgICAgczIsXG4gICAgICAgIHMyLmJib3gsXG4gICAgICAgIGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkXG4gICAgICApO1xuICAgIH07XG4gICAgcmV0dXJuIHNoYXBlO1xuICB9LFxuXG4gIGdldG1pbm1heDogZnVuY3Rpb24gKGN1cnZlLCBkLCBsaXN0KSB7XG4gICAgaWYgKCFsaXN0KSByZXR1cm4geyBtaW46IDAsIG1heDogMCB9O1xuICAgIGxldCBtaW4gPSBuTWF4LFxuICAgICAgbWF4ID0gbk1pbixcbiAgICAgIHQsXG4gICAgICBjO1xuICAgIGlmIChsaXN0LmluZGV4T2YoMCkgPT09IC0xKSB7XG4gICAgICBsaXN0ID0gWzBdLmNvbmNhdChsaXN0KTtcbiAgICB9XG4gICAgaWYgKGxpc3QuaW5kZXhPZigxKSA9PT0gLTEpIHtcbiAgICAgIGxpc3QucHVzaCgxKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHQgPSBsaXN0W2ldO1xuICAgICAgYyA9IGN1cnZlLmdldCh0KTtcbiAgICAgIGlmIChjW2RdIDwgbWluKSB7XG4gICAgICAgIG1pbiA9IGNbZF07XG4gICAgICB9XG4gICAgICBpZiAoY1tkXSA+IG1heCkge1xuICAgICAgICBtYXggPSBjW2RdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBtaW46IG1pbiwgbWlkOiAobWluICsgbWF4KSAvIDIsIG1heDogbWF4LCBzaXplOiBtYXggLSBtaW4gfTtcbiAgfSxcblxuICBhbGlnbjogZnVuY3Rpb24gKHBvaW50cywgbGluZSkge1xuICAgIGNvbnN0IHR4ID0gbGluZS5wMS54LFxuICAgICAgdHkgPSBsaW5lLnAxLnksXG4gICAgICBhID0gLWF0YW4yKGxpbmUucDIueSAtIHR5LCBsaW5lLnAyLnggLSB0eCksXG4gICAgICBkID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiAodi54IC0gdHgpICogY29zKGEpIC0gKHYueSAtIHR5KSAqIHNpbihhKSxcbiAgICAgICAgICB5OiAodi54IC0gdHgpICogc2luKGEpICsgKHYueSAtIHR5KSAqIGNvcyhhKSxcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgcmV0dXJuIHBvaW50cy5tYXAoZCk7XG4gIH0sXG5cbiAgcm9vdHM6IGZ1bmN0aW9uIChwb2ludHMsIGxpbmUpIHtcbiAgICBsaW5lID0gbGluZSB8fCB7IHAxOiB7IHg6IDAsIHk6IDAgfSwgcDI6IHsgeDogMSwgeTogMCB9IH07XG5cbiAgICBjb25zdCBvcmRlciA9IHBvaW50cy5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGFsaWduZWQgPSB1dGlscy5hbGlnbihwb2ludHMsIGxpbmUpO1xuICAgIGNvbnN0IHJlZHVjZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gMCA8PSB0ICYmIHQgPD0gMTtcbiAgICB9O1xuXG4gICAgaWYgKG9yZGVyID09PSAyKSB7XG4gICAgICBjb25zdCBhID0gYWxpZ25lZFswXS55LFxuICAgICAgICBiID0gYWxpZ25lZFsxXS55LFxuICAgICAgICBjID0gYWxpZ25lZFsyXS55LFxuICAgICAgICBkID0gYSAtIDIgKiBiICsgYztcbiAgICAgIGlmIChkICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IG0xID0gLXNxcnQoYiAqIGIgLSBhICogYyksXG4gICAgICAgICAgbTIgPSAtYSArIGIsXG4gICAgICAgICAgdjEgPSAtKG0xICsgbTIpIC8gZCxcbiAgICAgICAgICB2MiA9IC0oLW0xICsgbTIpIC8gZDtcbiAgICAgICAgcmV0dXJuIFt2MSwgdjJdLmZpbHRlcihyZWR1Y2UpO1xuICAgICAgfSBlbHNlIGlmIChiICE9PSBjICYmIGQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFsoMiAqIGIgLSBjKSAvICgyICogYiAtIDIgKiBjKV0uZmlsdGVyKHJlZHVjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gc2VlIGh0dHA6Ly93d3cudHJhbnM0bWluZC5jb20vcGVyc29uYWxfZGV2ZWxvcG1lbnQvbWF0aGVtYXRpY3MvcG9seW5vbWlhbHMvY3ViaWNBbGdlYnJhLmh0bVxuICAgIGNvbnN0IHBhID0gYWxpZ25lZFswXS55LFxuICAgICAgcGIgPSBhbGlnbmVkWzFdLnksXG4gICAgICBwYyA9IGFsaWduZWRbMl0ueSxcbiAgICAgIHBkID0gYWxpZ25lZFszXS55O1xuXG4gICAgbGV0IGQgPSAtcGEgKyAzICogcGIgLSAzICogcGMgKyBwZCxcbiAgICAgIGEgPSAzICogcGEgLSA2ICogcGIgKyAzICogcGMsXG4gICAgICBiID0gLTMgKiBwYSArIDMgKiBwYixcbiAgICAgIGMgPSBwYTtcblxuICAgIGlmICh1dGlscy5hcHByb3hpbWF0ZWx5KGQsIDApKSB7XG4gICAgICAvLyB0aGlzIGlzIG5vdCBhIGN1YmljIGN1cnZlLlxuICAgICAgaWYgKHV0aWxzLmFwcHJveGltYXRlbHkoYSwgMCkpIHtcbiAgICAgICAgLy8gaW4gZmFjdCwgdGhpcyBpcyBub3QgYSBxdWFkcmF0aWMgY3VydmUgZWl0aGVyLlxuICAgICAgICBpZiAodXRpbHMuYXBwcm94aW1hdGVseShiLCAwKSkge1xuICAgICAgICAgIC8vIGluIGZhY3QgaW4gZmFjdCwgdGhlcmUgYXJlIG5vIHNvbHV0aW9ucy5cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGluZWFyIHNvbHV0aW9uOlxuICAgICAgICByZXR1cm4gWy1jIC8gYl0uZmlsdGVyKHJlZHVjZSk7XG4gICAgICB9XG4gICAgICAvLyBxdWFkcmF0aWMgc29sdXRpb246XG4gICAgICBjb25zdCBxID0gc3FydChiICogYiAtIDQgKiBhICogYyksXG4gICAgICAgIGEyID0gMiAqIGE7XG4gICAgICByZXR1cm4gWyhxIC0gYikgLyBhMiwgKC1iIC0gcSkgLyBhMl0uZmlsdGVyKHJlZHVjZSk7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgd2Uga25vdyB3ZSBuZWVkIGEgY3ViaWMgc29sdXRpb246XG5cbiAgICBhIC89IGQ7XG4gICAgYiAvPSBkO1xuICAgIGMgLz0gZDtcblxuICAgIGNvbnN0IHAgPSAoMyAqIGIgLSBhICogYSkgLyAzLFxuICAgICAgcDMgPSBwIC8gMyxcbiAgICAgIHEgPSAoMiAqIGEgKiBhICogYSAtIDkgKiBhICogYiArIDI3ICogYykgLyAyNyxcbiAgICAgIHEyID0gcSAvIDIsXG4gICAgICBkaXNjcmltaW5hbnQgPSBxMiAqIHEyICsgcDMgKiBwMyAqIHAzO1xuXG4gICAgbGV0IHUxLCB2MSwgeDEsIHgyLCB4MztcbiAgICBpZiAoZGlzY3JpbWluYW50IDwgMCkge1xuICAgICAgY29uc3QgbXAzID0gLXAgLyAzLFxuICAgICAgICBtcDMzID0gbXAzICogbXAzICogbXAzLFxuICAgICAgICByID0gc3FydChtcDMzKSxcbiAgICAgICAgdCA9IC1xIC8gKDIgKiByKSxcbiAgICAgICAgY29zcGhpID0gdCA8IC0xID8gLTEgOiB0ID4gMSA/IDEgOiB0LFxuICAgICAgICBwaGkgPSBhY29zKGNvc3BoaSksXG4gICAgICAgIGNydHIgPSBjcnQociksXG4gICAgICAgIHQxID0gMiAqIGNydHI7XG4gICAgICB4MSA9IHQxICogY29zKHBoaSAvIDMpIC0gYSAvIDM7XG4gICAgICB4MiA9IHQxICogY29zKChwaGkgKyB0YXUpIC8gMykgLSBhIC8gMztcbiAgICAgIHgzID0gdDEgKiBjb3MoKHBoaSArIDIgKiB0YXUpIC8gMykgLSBhIC8gMztcbiAgICAgIHJldHVybiBbeDEsIHgyLCB4M10uZmlsdGVyKHJlZHVjZSk7XG4gICAgfSBlbHNlIGlmIChkaXNjcmltaW5hbnQgPT09IDApIHtcbiAgICAgIHUxID0gcTIgPCAwID8gY3J0KC1xMikgOiAtY3J0KHEyKTtcbiAgICAgIHgxID0gMiAqIHUxIC0gYSAvIDM7XG4gICAgICB4MiA9IC11MSAtIGEgLyAzO1xuICAgICAgcmV0dXJuIFt4MSwgeDJdLmZpbHRlcihyZWR1Y2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzZCA9IHNxcnQoZGlzY3JpbWluYW50KTtcbiAgICAgIHUxID0gY3J0KC1xMiArIHNkKTtcbiAgICAgIHYxID0gY3J0KHEyICsgc2QpO1xuICAgICAgcmV0dXJuIFt1MSAtIHYxIC0gYSAvIDNdLmZpbHRlcihyZWR1Y2UpO1xuICAgIH1cbiAgfSxcblxuICBkcm9vdHM6IGZ1bmN0aW9uIChwKSB7XG4gICAgLy8gcXVhZHJhdGljIHJvb3RzIGFyZSBlYXN5XG4gICAgaWYgKHAubGVuZ3RoID09PSAzKSB7XG4gICAgICBjb25zdCBhID0gcFswXSxcbiAgICAgICAgYiA9IHBbMV0sXG4gICAgICAgIGMgPSBwWzJdLFxuICAgICAgICBkID0gYSAtIDIgKiBiICsgYztcbiAgICAgIGlmIChkICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IG0xID0gLXNxcnQoYiAqIGIgLSBhICogYyksXG4gICAgICAgICAgbTIgPSAtYSArIGIsXG4gICAgICAgICAgdjEgPSAtKG0xICsgbTIpIC8gZCxcbiAgICAgICAgICB2MiA9IC0oLW0xICsgbTIpIC8gZDtcbiAgICAgICAgcmV0dXJuIFt2MSwgdjJdO1xuICAgICAgfSBlbHNlIGlmIChiICE9PSBjICYmIGQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFsoMiAqIGIgLSBjKSAvICgyICogKGIgLSBjKSldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8vIGxpbmVhciByb290cyBhcmUgZXZlbiBlYXNpZXJcbiAgICBpZiAocC5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IGEgPSBwWzBdLFxuICAgICAgICBiID0gcFsxXTtcbiAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgIHJldHVybiBbYSAvIChhIC0gYildO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbiAgfSxcblxuICBjdXJ2YXR1cmU6IGZ1bmN0aW9uICh0LCBkMSwgZDIsIF8zZCwga09ubHkpIHtcbiAgICBsZXQgbnVtLFxuICAgICAgZG5tLFxuICAgICAgYWRrLFxuICAgICAgZGssXG4gICAgICBrID0gMCxcbiAgICAgIHIgPSAwO1xuXG4gICAgLy9cbiAgICAvLyBXZSdyZSB1c2luZyB0aGUgZm9sbG93aW5nIGZvcm11bGEgZm9yIGN1cnZhdHVyZTpcbiAgICAvL1xuICAgIC8vICAgICAgICAgICAgICB4J3lcIiAtIHkneFwiXG4gICAgLy8gICBrKHQpID0gLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gICAgICAgICAgICh4J8KyICsgeSfCsileKDMvMilcbiAgICAvL1xuICAgIC8vIGZyb20gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFkaXVzX29mX2N1cnZhdHVyZSNEZWZpbml0aW9uXG4gICAgLy9cbiAgICAvLyBXaXRoIGl0IGNvcnJlc3BvbmRpbmcgM0QgY291bnRlcnBhcnQ6XG4gICAgLy9cbiAgICAvLyAgICAgICAgICBzcXJ0KCAoeSd6XCIgLSB5XCJ6JynCsiArICh6J3hcIiAtIHpcIngnKcKyICsgKHgneVwiIC0geFwieScpwrIpXG4gICAgLy8gICBrKHQpID0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgKHgnwrIgKyB5J8KyICsgeifCsileKDMvMilcbiAgICAvL1xuXG4gICAgY29uc3QgZCA9IHV0aWxzLmNvbXB1dGUodCwgZDEpO1xuICAgIGNvbnN0IGRkID0gdXRpbHMuY29tcHV0ZSh0LCBkMik7XG4gICAgY29uc3QgcWRzdW0gPSBkLnggKiBkLnggKyBkLnkgKiBkLnk7XG5cbiAgICBpZiAoXzNkKSB7XG4gICAgICBudW0gPSBzcXJ0KFxuICAgICAgICBwb3coZC55ICogZGQueiAtIGRkLnkgKiBkLnosIDIpICtcbiAgICAgICAgICBwb3coZC56ICogZGQueCAtIGRkLnogKiBkLngsIDIpICtcbiAgICAgICAgICBwb3coZC54ICogZGQueSAtIGRkLnggKiBkLnksIDIpXG4gICAgICApO1xuICAgICAgZG5tID0gcG93KHFkc3VtICsgZC56ICogZC56LCAzIC8gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bSA9IGQueCAqIGRkLnkgLSBkLnkgKiBkZC54O1xuICAgICAgZG5tID0gcG93KHFkc3VtLCAzIC8gMik7XG4gICAgfVxuXG4gICAgaWYgKG51bSA9PT0gMCB8fCBkbm0gPT09IDApIHtcbiAgICAgIHJldHVybiB7IGs6IDAsIHI6IDAgfTtcbiAgICB9XG5cbiAgICBrID0gbnVtIC8gZG5tO1xuICAgIHIgPSBkbm0gLyBudW07XG5cbiAgICAvLyBXZSdyZSBhbHNvIGNvbXB1dGluZyB0aGUgZGVyaXZhdGl2ZSBvZiBrYXBwYSwgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIHZhbHVlIGluIGtub3dpbmcgdGhlIHJhdGUgb2YgY2hhbmdlIGZvciB0aGVcbiAgICAvLyBjdXJ2YXR1cmUgYWxvbmcgdGhlIGN1cnZlLiBBbmQgd2UncmUganVzdCBnb2luZyB0b1xuICAgIC8vIGJhbGxwYXJrIGl0IGJhc2VkIG9uIGFuIGVwc2lsb24uXG4gICAgaWYgKCFrT25seSkge1xuICAgICAgLy8gY29tcHV0ZSBrJyh0KSBiYXNlZCBvbiB0aGUgaW50ZXJ2YWwgYmVmb3JlLCBhbmQgYWZ0ZXIgaXQsXG4gICAgICAvLyB0byBhdCBsZWFzdCB0cnkgdG8gbm90IGludHJvZHVjZSBmb3J3YXJkL2JhY2t3YXJkIHBhc3MgYmlhcy5cbiAgICAgIGNvbnN0IHBrID0gdXRpbHMuY3VydmF0dXJlKHQgLSAwLjAwMSwgZDEsIGQyLCBfM2QsIHRydWUpLms7XG4gICAgICBjb25zdCBuayA9IHV0aWxzLmN1cnZhdHVyZSh0ICsgMC4wMDEsIGQxLCBkMiwgXzNkLCB0cnVlKS5rO1xuICAgICAgZGsgPSAobmsgLSBrICsgKGsgLSBwaykpIC8gMjtcbiAgICAgIGFkayA9IChhYnMobmsgLSBrKSArIGFicyhrIC0gcGspKSAvIDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgazogaywgcjogciwgZGs6IGRrLCBhZGs6IGFkayB9O1xuICB9LFxuXG4gIGluZmxlY3Rpb25zOiBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPCA0KSByZXR1cm4gW107XG5cbiAgICAvLyBGSVhNRTogVE9ETzogYWRkIGluIGluZmxlY3Rpb24gYWJzdHJhY3Rpb24gZm9yIHF1YXJ0aWMrIGN1cnZlcz9cblxuICAgIGNvbnN0IHAgPSB1dGlscy5hbGlnbihwb2ludHMsIHsgcDE6IHBvaW50c1swXSwgcDI6IHBvaW50cy5zbGljZSgtMSlbMF0gfSksXG4gICAgICBhID0gcFsyXS54ICogcFsxXS55LFxuICAgICAgYiA9IHBbM10ueCAqIHBbMV0ueSxcbiAgICAgIGMgPSBwWzFdLnggKiBwWzJdLnksXG4gICAgICBkID0gcFszXS54ICogcFsyXS55LFxuICAgICAgdjEgPSAxOCAqICgtMyAqIGEgKyAyICogYiArIDMgKiBjIC0gZCksXG4gICAgICB2MiA9IDE4ICogKDMgKiBhIC0gYiAtIDMgKiBjKSxcbiAgICAgIHYzID0gMTggKiAoYyAtIGEpO1xuXG4gICAgaWYgKHV0aWxzLmFwcHJveGltYXRlbHkodjEsIDApKSB7XG4gICAgICBpZiAoIXV0aWxzLmFwcHJveGltYXRlbHkodjIsIDApKSB7XG4gICAgICAgIGxldCB0ID0gLXYzIC8gdjI7XG4gICAgICAgIGlmICgwIDw9IHQgJiYgdCA8PSAxKSByZXR1cm4gW3RdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IHRybSA9IHYyICogdjIgLSA0ICogdjEgKiB2MyxcbiAgICAgIHNxID0gTWF0aC5zcXJ0KHRybSksXG4gICAgICBkMiA9IDIgKiB2MTtcblxuICAgIGlmICh1dGlscy5hcHByb3hpbWF0ZWx5KGQyLCAwKSkgcmV0dXJuIFtdO1xuXG4gICAgcmV0dXJuIFsoc3EgLSB2MikgLyBkMiwgLSh2MiArIHNxKSAvIGQyXS5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiAwIDw9IHIgJiYgciA8PSAxO1xuICAgIH0pO1xuICB9LFxuXG4gIGJib3hvdmVybGFwOiBmdW5jdGlvbiAoYjEsIGIyKSB7XG4gICAgY29uc3QgZGltcyA9IFtcInhcIiwgXCJ5XCJdLFxuICAgICAgbGVuID0gZGltcy5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgZGltLCBsLCB0LCBkOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRpbSA9IGRpbXNbaV07XG4gICAgICBsID0gYjFbZGltXS5taWQ7XG4gICAgICB0ID0gYjJbZGltXS5taWQ7XG4gICAgICBkID0gKGIxW2RpbV0uc2l6ZSArIGIyW2RpbV0uc2l6ZSkgLyAyO1xuICAgICAgaWYgKGFicyhsIC0gdCkgPj0gZCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBleHBhbmRib3g6IGZ1bmN0aW9uIChiYm94LCBfYmJveCkge1xuICAgIGlmIChfYmJveC54Lm1pbiA8IGJib3gueC5taW4pIHtcbiAgICAgIGJib3gueC5taW4gPSBfYmJveC54Lm1pbjtcbiAgICB9XG4gICAgaWYgKF9iYm94LnkubWluIDwgYmJveC55Lm1pbikge1xuICAgICAgYmJveC55Lm1pbiA9IF9iYm94LnkubWluO1xuICAgIH1cbiAgICBpZiAoX2Jib3gueiAmJiBfYmJveC56Lm1pbiA8IGJib3guei5taW4pIHtcbiAgICAgIGJib3guei5taW4gPSBfYmJveC56Lm1pbjtcbiAgICB9XG4gICAgaWYgKF9iYm94LngubWF4ID4gYmJveC54Lm1heCkge1xuICAgICAgYmJveC54Lm1heCA9IF9iYm94LngubWF4O1xuICAgIH1cbiAgICBpZiAoX2Jib3gueS5tYXggPiBiYm94LnkubWF4KSB7XG4gICAgICBiYm94LnkubWF4ID0gX2Jib3gueS5tYXg7XG4gICAgfVxuICAgIGlmIChfYmJveC56ICYmIF9iYm94LnoubWF4ID4gYmJveC56Lm1heCkge1xuICAgICAgYmJveC56Lm1heCA9IF9iYm94LnoubWF4O1xuICAgIH1cbiAgICBiYm94LngubWlkID0gKGJib3gueC5taW4gKyBiYm94LngubWF4KSAvIDI7XG4gICAgYmJveC55Lm1pZCA9IChiYm94LnkubWluICsgYmJveC55Lm1heCkgLyAyO1xuICAgIGlmIChiYm94LnopIHtcbiAgICAgIGJib3guei5taWQgPSAoYmJveC56Lm1pbiArIGJib3guei5tYXgpIC8gMjtcbiAgICB9XG4gICAgYmJveC54LnNpemUgPSBiYm94LngubWF4IC0gYmJveC54Lm1pbjtcbiAgICBiYm94Lnkuc2l6ZSA9IGJib3gueS5tYXggLSBiYm94LnkubWluO1xuICAgIGlmIChiYm94LnopIHtcbiAgICAgIGJib3guei5zaXplID0gYmJveC56Lm1heCAtIGJib3guei5taW47XG4gICAgfVxuICB9LFxuXG4gIHBhaXJpdGVyYXRpb246IGZ1bmN0aW9uIChjMSwgYzIsIGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkKSB7XG4gICAgY29uc3QgYzFiID0gYzEuYmJveCgpLFxuICAgICAgYzJiID0gYzIuYmJveCgpLFxuICAgICAgciA9IDEwMDAwMCxcbiAgICAgIHRocmVzaG9sZCA9IGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkIHx8IDAuNTtcblxuICAgIGlmIChcbiAgICAgIGMxYi54LnNpemUgKyBjMWIueS5zaXplIDwgdGhyZXNob2xkICYmXG4gICAgICBjMmIueC5zaXplICsgYzJiLnkuc2l6ZSA8IHRocmVzaG9sZFxuICAgICkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgKCgociAqIChjMS5fdDEgKyBjMS5fdDIpKSAvIDIpIHwgMCkgLyByICtcbiAgICAgICAgICBcIi9cIiArXG4gICAgICAgICAgKCgociAqIChjMi5fdDEgKyBjMi5fdDIpKSAvIDIpIHwgMCkgLyByLFxuICAgICAgXTtcbiAgICB9XG5cbiAgICBsZXQgY2MxID0gYzEuc3BsaXQoMC41KSxcbiAgICAgIGNjMiA9IGMyLnNwbGl0KDAuNSksXG4gICAgICBwYWlycyA9IFtcbiAgICAgICAgeyBsZWZ0OiBjYzEubGVmdCwgcmlnaHQ6IGNjMi5sZWZ0IH0sXG4gICAgICAgIHsgbGVmdDogY2MxLmxlZnQsIHJpZ2h0OiBjYzIucmlnaHQgfSxcbiAgICAgICAgeyBsZWZ0OiBjYzEucmlnaHQsIHJpZ2h0OiBjYzIucmlnaHQgfSxcbiAgICAgICAgeyBsZWZ0OiBjYzEucmlnaHQsIHJpZ2h0OiBjYzIubGVmdCB9LFxuICAgICAgXTtcblxuICAgIHBhaXJzID0gcGFpcnMuZmlsdGVyKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICByZXR1cm4gdXRpbHMuYmJveG92ZXJsYXAocGFpci5sZWZ0LmJib3goKSwgcGFpci5yaWdodC5iYm94KCkpO1xuICAgIH0pO1xuXG4gICAgbGV0IHJlc3VsdHMgPSBbXTtcblxuICAgIGlmIChwYWlycy5sZW5ndGggPT09IDApIHJldHVybiByZXN1bHRzO1xuXG4gICAgcGFpcnMuZm9yRWFjaChmdW5jdGlvbiAocGFpcikge1xuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KFxuICAgICAgICB1dGlscy5wYWlyaXRlcmF0aW9uKHBhaXIubGVmdCwgcGFpci5yaWdodCwgdGhyZXNob2xkKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHJlc3VsdHMgPSByZXN1bHRzLmZpbHRlcihmdW5jdGlvbiAodiwgaSkge1xuICAgICAgcmV0dXJuIHJlc3VsdHMuaW5kZXhPZih2KSA9PT0gaTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9LFxuXG4gIGdldGNjZW50ZXI6IGZ1bmN0aW9uIChwMSwgcDIsIHAzKSB7XG4gICAgY29uc3QgZHgxID0gcDIueCAtIHAxLngsXG4gICAgICBkeTEgPSBwMi55IC0gcDEueSxcbiAgICAgIGR4MiA9IHAzLnggLSBwMi54LFxuICAgICAgZHkyID0gcDMueSAtIHAyLnksXG4gICAgICBkeDFwID0gZHgxICogY29zKHF1YXJ0KSAtIGR5MSAqIHNpbihxdWFydCksXG4gICAgICBkeTFwID0gZHgxICogc2luKHF1YXJ0KSArIGR5MSAqIGNvcyhxdWFydCksXG4gICAgICBkeDJwID0gZHgyICogY29zKHF1YXJ0KSAtIGR5MiAqIHNpbihxdWFydCksXG4gICAgICBkeTJwID0gZHgyICogc2luKHF1YXJ0KSArIGR5MiAqIGNvcyhxdWFydCksXG4gICAgICAvLyBjaG9yZCBtaWRwb2ludHNcbiAgICAgIG14MSA9IChwMS54ICsgcDIueCkgLyAyLFxuICAgICAgbXkxID0gKHAxLnkgKyBwMi55KSAvIDIsXG4gICAgICBteDIgPSAocDIueCArIHAzLngpIC8gMixcbiAgICAgIG15MiA9IChwMi55ICsgcDMueSkgLyAyLFxuICAgICAgLy8gbWlkcG9pbnQgb2Zmc2V0c1xuICAgICAgbXgxbiA9IG14MSArIGR4MXAsXG4gICAgICBteTFuID0gbXkxICsgZHkxcCxcbiAgICAgIG14Mm4gPSBteDIgKyBkeDJwLFxuICAgICAgbXkybiA9IG15MiArIGR5MnAsXG4gICAgICAvLyBpbnRlcnNlY3Rpb24gb2YgdGhlc2UgbGluZXM6XG4gICAgICBhcmMgPSB1dGlscy5sbGk4KG14MSwgbXkxLCBteDFuLCBteTFuLCBteDIsIG15MiwgbXgybiwgbXkybiksXG4gICAgICByID0gdXRpbHMuZGlzdChhcmMsIHAxKTtcblxuICAgIC8vIGFyYyBzdGFydC9lbmQgdmFsdWVzLCBvdmVyIG1pZCBwb2ludDpcbiAgICBsZXQgcyA9IGF0YW4yKHAxLnkgLSBhcmMueSwgcDEueCAtIGFyYy54KSxcbiAgICAgIG0gPSBhdGFuMihwMi55IC0gYXJjLnksIHAyLnggLSBhcmMueCksXG4gICAgICBlID0gYXRhbjIocDMueSAtIGFyYy55LCBwMy54IC0gYXJjLngpLFxuICAgICAgXztcblxuICAgIC8vIGRldGVybWluZSBhcmMgZGlyZWN0aW9uIChjdy9jY3cgY29ycmVjdGlvbilcbiAgICBpZiAocyA8IGUpIHtcbiAgICAgIC8vIGlmIHM8bTxlLCBhcmMocywgZSlcbiAgICAgIC8vIGlmIG08czxlLCBhcmMoZSwgcyArIHRhdSlcbiAgICAgIC8vIGlmIHM8ZTxtLCBhcmMoZSwgcyArIHRhdSlcbiAgICAgIGlmIChzID4gbSB8fCBtID4gZSkge1xuICAgICAgICBzICs9IHRhdTtcbiAgICAgIH1cbiAgICAgIGlmIChzID4gZSkge1xuICAgICAgICBfID0gZTtcbiAgICAgICAgZSA9IHM7XG4gICAgICAgIHMgPSBfO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBlPG08cywgYXJjKGUsIHMpXG4gICAgICAvLyBpZiBtPGU8cywgYXJjKHMsIGUgKyB0YXUpXG4gICAgICAvLyBpZiBlPHM8bSwgYXJjKHMsIGUgKyB0YXUpXG4gICAgICBpZiAoZSA8IG0gJiYgbSA8IHMpIHtcbiAgICAgICAgXyA9IGU7XG4gICAgICAgIGUgPSBzO1xuICAgICAgICBzID0gXztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGUgKz0gdGF1O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBhc3NpZ24gYW5kIGRvbmUuXG4gICAgYXJjLnMgPSBzO1xuICAgIGFyYy5lID0gZTtcbiAgICBhcmMuciA9IHI7XG4gICAgcmV0dXJuIGFyYztcbiAgfSxcblxuICBudW1iZXJTb3J0OiBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhIC0gYjtcbiAgfSxcbn07XG5cbmV4cG9ydCB7IHV0aWxzIH07XG4iLCJpbXBvcnQgeyB1dGlscyB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5cbi8qKlxuICogUG9seSBCZXppZXJcbiAqIEBwYXJhbSB7W3R5cGVdfSBjdXJ2ZXMgW2Rlc2NyaXB0aW9uXVxuICovXG5jbGFzcyBQb2x5QmV6aWVyIHtcbiAgY29uc3RydWN0b3IoY3VydmVzKSB7XG4gICAgdGhpcy5jdXJ2ZXMgPSBbXTtcbiAgICB0aGlzLl8zZCA9IGZhbHNlO1xuICAgIGlmICghIWN1cnZlcykge1xuICAgICAgdGhpcy5jdXJ2ZXMgPSBjdXJ2ZXM7XG4gICAgICB0aGlzLl8zZCA9IHRoaXMuY3VydmVzWzBdLl8zZDtcbiAgICB9XG4gIH1cblxuICB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gKFxuICAgICAgXCJbXCIgK1xuICAgICAgdGhpcy5jdXJ2ZXNcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoY3VydmUpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbHMucG9pbnRzVG9TdHJpbmcoY3VydmUucG9pbnRzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oXCIsIFwiKSArXG4gICAgICBcIl1cIlxuICAgICk7XG4gIH1cblxuICBhZGRDdXJ2ZShjdXJ2ZSkge1xuICAgIHRoaXMuY3VydmVzLnB1c2goY3VydmUpO1xuICAgIHRoaXMuXzNkID0gdGhpcy5fM2QgfHwgY3VydmUuXzNkO1xuICB9XG5cbiAgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnZlc1xuICAgICAgLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdi5sZW5ndGgoKTtcbiAgICAgIH0pXG4gICAgICAucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhICsgYjtcbiAgICAgIH0pO1xuICB9XG5cbiAgY3VydmUoaWR4KSB7XG4gICAgcmV0dXJuIHRoaXMuY3VydmVzW2lkeF07XG4gIH1cblxuICBiYm94KCkge1xuICAgIGNvbnN0IGMgPSB0aGlzLmN1cnZlcztcbiAgICB2YXIgYmJveCA9IGNbMF0uYmJveCgpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYy5sZW5ndGg7IGkrKykge1xuICAgICAgdXRpbHMuZXhwYW5kYm94KGJib3gsIGNbaV0uYmJveCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJib3g7XG4gIH1cblxuICBvZmZzZXQoZCkge1xuICAgIGNvbnN0IG9mZnNldCA9IFtdO1xuICAgIHRoaXMuY3VydmVzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgIG9mZnNldC5wdXNoKC4uLnYub2Zmc2V0KGQpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFBvbHlCZXppZXIob2Zmc2V0KTtcbiAgfVxufVxuXG5leHBvcnQgeyBQb2x5QmV6aWVyIH07XG4iLCIvKipcbiAgQSBqYXZhc2NyaXB0IEJlemllciBjdXJ2ZSBsaWJyYXJ5IGJ5IFBvbWF4LlxuXG4gIEJhc2VkIG9uIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mb1xuXG4gIFRoaXMgY29kZSBpcyBNSVQgbGljZW5zZWQuXG4qKi9cblxuaW1wb3J0IHsgdXRpbHMgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgUG9seUJlemllciB9IGZyb20gXCIuL3BvbHktYmV6aWVyLmpzXCI7XG5cbi8vIG1hdGgtaW5saW5pbmcuXG5jb25zdCB7IGFicywgbWluLCBtYXgsIGNvcywgc2luLCBhY29zLCBzcXJ0IH0gPSBNYXRoO1xuY29uc3QgcGkgPSBNYXRoLlBJO1xuLy8gYSB6ZXJvIGNvb3JkaW5hdGUsIHdoaWNoIGlzIHN1cnByaXNpbmdseSB1c2VmdWxcbmNvbnN0IFpFUk8gPSB7IHg6IDAsIHk6IDAsIHo6IDAgfTtcblxuLyoqXG4gKiBCZXppZXIgY3VydmUgY29uc3RydWN0b3IuXG4gKlxuICogLi4uZG9jcyBwZW5kaW5nLi4uXG4gKi9cbmNsYXNzIEJlemllciB7XG4gIGNvbnN0cnVjdG9yKGNvb3Jkcykge1xuICAgIGxldCBhcmdzID1cbiAgICAgIGNvb3JkcyAmJiBjb29yZHMuZm9yRWFjaCA/IGNvb3JkcyA6IEFycmF5LmZyb20oYXJndW1lbnRzKS5zbGljZSgpO1xuICAgIGxldCBjb29yZGxlbiA9IGZhbHNlO1xuXG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb29yZGxlbiA9IGFyZ3MubGVuZ3RoO1xuICAgICAgY29uc3QgbmV3YXJncyA9IFtdO1xuICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICBbXCJ4XCIsIFwieVwiLCBcInpcIl0uZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnRbZF0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG5ld2FyZ3MucHVzaChwb2ludFtkXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgYXJncyA9IG5ld2FyZ3M7XG4gICAgfVxuXG4gICAgbGV0IGhpZ2hlciA9IGZhbHNlO1xuICAgIGNvbnN0IGxlbiA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgaWYgKGNvb3JkbGVuKSB7XG4gICAgICBpZiAoY29vcmRsZW4gPiA0KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJPbmx5IG5ldyBCZXppZXIocG9pbnRbXSkgaXMgYWNjZXB0ZWQgZm9yIDR0aCBhbmQgaGlnaGVyIG9yZGVyIGN1cnZlc1wiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBoaWdoZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobGVuICE9PSA2ICYmIGxlbiAhPT0gOCAmJiBsZW4gIT09IDkgJiYgbGVuICE9PSAxMikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiT25seSBuZXcgQmV6aWVyKHBvaW50W10pIGlzIGFjY2VwdGVkIGZvciA0dGggYW5kIGhpZ2hlciBvcmRlciBjdXJ2ZXNcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBfM2QgPSAodGhpcy5fM2QgPVxuICAgICAgKCFoaWdoZXIgJiYgKGxlbiA9PT0gOSB8fCBsZW4gPT09IDEyKSkgfHxcbiAgICAgIChjb29yZHMgJiYgY29vcmRzWzBdICYmIHR5cGVvZiBjb29yZHNbMF0ueiAhPT0gXCJ1bmRlZmluZWRcIikpO1xuXG4gICAgY29uc3QgcG9pbnRzID0gKHRoaXMucG9pbnRzID0gW10pO1xuICAgIGZvciAobGV0IGlkeCA9IDAsIHN0ZXAgPSBfM2QgPyAzIDogMjsgaWR4IDwgbGVuOyBpZHggKz0gc3RlcCkge1xuICAgICAgdmFyIHBvaW50ID0ge1xuICAgICAgICB4OiBhcmdzW2lkeF0sXG4gICAgICAgIHk6IGFyZ3NbaWR4ICsgMV0sXG4gICAgICB9O1xuICAgICAgaWYgKF8zZCkge1xuICAgICAgICBwb2ludC56ID0gYXJnc1tpZHggKyAyXTtcbiAgICAgIH1cbiAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICB9XG4gICAgY29uc3Qgb3JkZXIgPSAodGhpcy5vcmRlciA9IHBvaW50cy5sZW5ndGggLSAxKTtcblxuICAgIGNvbnN0IGRpbXMgPSAodGhpcy5kaW1zID0gW1wieFwiLCBcInlcIl0pO1xuICAgIGlmIChfM2QpIGRpbXMucHVzaChcInpcIik7XG4gICAgdGhpcy5kaW1sZW4gPSBkaW1zLmxlbmd0aDtcblxuICAgIGNvbnN0IGFsaWduZWQgPSB1dGlscy5hbGlnbihwb2ludHMsIHsgcDE6IHBvaW50c1swXSwgcDI6IHBvaW50c1tvcmRlcl0gfSk7XG4gICAgdGhpcy5fbGluZWFyID0gIWFsaWduZWQuc29tZSgocCkgPT4gYWJzKHAueSkgPiAwLjAwMDEpO1xuXG4gICAgdGhpcy5fbHV0ID0gW107XG5cbiAgICB0aGlzLl90MSA9IDA7XG4gICAgdGhpcy5fdDIgPSAxO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBzdGF0aWMgcXVhZHJhdGljRnJvbVBvaW50cyhwMSwgcDIsIHAzLCB0KSB7XG4gICAgaWYgKHR5cGVvZiB0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0ID0gMC41O1xuICAgIH1cbiAgICAvLyBzaG9ydGN1dHMsIGFsdGhvdWdoIHRoZXkncmUgcmVhbGx5IGR1bWJcbiAgICBpZiAodCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBCZXppZXIocDIsIHAyLCBwMyk7XG4gICAgfVxuICAgIGlmICh0ID09PSAxKSB7XG4gICAgICByZXR1cm4gbmV3IEJlemllcihwMSwgcDIsIHAyKTtcbiAgICB9XG4gICAgLy8gcmVhbCBmaXR0aW5nLlxuICAgIGNvbnN0IGFiYyA9IEJlemllci5nZXRBQkMoMiwgcDEsIHAyLCBwMywgdCk7XG4gICAgcmV0dXJuIG5ldyBCZXppZXIocDEsIGFiYy5BLCBwMyk7XG4gIH1cblxuICBzdGF0aWMgY3ViaWNGcm9tUG9pbnRzKFMsIEIsIEUsIHQsIGQxKSB7XG4gICAgaWYgKHR5cGVvZiB0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0ID0gMC41O1xuICAgIH1cbiAgICBjb25zdCBhYmMgPSBCZXppZXIuZ2V0QUJDKDMsIFMsIEIsIEUsIHQpO1xuICAgIGlmICh0eXBlb2YgZDEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGQxID0gdXRpbHMuZGlzdChCLCBhYmMuQyk7XG4gICAgfVxuICAgIGNvbnN0IGQyID0gKGQxICogKDEgLSB0KSkgLyB0O1xuXG4gICAgY29uc3Qgc2VsZW4gPSB1dGlscy5kaXN0KFMsIEUpLFxuICAgICAgbHggPSAoRS54IC0gUy54KSAvIHNlbGVuLFxuICAgICAgbHkgPSAoRS55IC0gUy55KSAvIHNlbGVuLFxuICAgICAgYngxID0gZDEgKiBseCxcbiAgICAgIGJ5MSA9IGQxICogbHksXG4gICAgICBieDIgPSBkMiAqIGx4LFxuICAgICAgYnkyID0gZDIgKiBseTtcbiAgICAvLyBkZXJpdmF0aW9uIG9mIG5ldyBodWxsIGNvb3JkaW5hdGVzXG4gICAgY29uc3QgZTEgPSB7IHg6IEIueCAtIGJ4MSwgeTogQi55IC0gYnkxIH0sXG4gICAgICBlMiA9IHsgeDogQi54ICsgYngyLCB5OiBCLnkgKyBieTIgfSxcbiAgICAgIEEgPSBhYmMuQSxcbiAgICAgIHYxID0geyB4OiBBLnggKyAoZTEueCAtIEEueCkgLyAoMSAtIHQpLCB5OiBBLnkgKyAoZTEueSAtIEEueSkgLyAoMSAtIHQpIH0sXG4gICAgICB2MiA9IHsgeDogQS54ICsgKGUyLnggLSBBLngpIC8gdCwgeTogQS55ICsgKGUyLnkgLSBBLnkpIC8gdCB9LFxuICAgICAgbmMxID0geyB4OiBTLnggKyAodjEueCAtIFMueCkgLyB0LCB5OiBTLnkgKyAodjEueSAtIFMueSkgLyB0IH0sXG4gICAgICBuYzIgPSB7XG4gICAgICAgIHg6IEUueCArICh2Mi54IC0gRS54KSAvICgxIC0gdCksXG4gICAgICAgIHk6IEUueSArICh2Mi55IC0gRS55KSAvICgxIC0gdCksXG4gICAgICB9O1xuICAgIC8vIC4uLmRvbmVcbiAgICByZXR1cm4gbmV3IEJlemllcihTLCBuYzEsIG5jMiwgRSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0VXRpbHMoKSB7XG4gICAgcmV0dXJuIHV0aWxzO1xuICB9XG5cbiAgZ2V0VXRpbHMoKSB7XG4gICAgcmV0dXJuIEJlemllci5nZXRVdGlscygpO1xuICB9XG5cbiAgc3RhdGljIGdldCBQb2x5QmV6aWVyKCkge1xuICAgIHJldHVybiBQb2x5QmV6aWVyO1xuICB9XG5cbiAgdmFsdWVPZigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHV0aWxzLnBvaW50c1RvU3RyaW5nKHRoaXMucG9pbnRzKTtcbiAgfVxuXG4gIHRvU1ZHKCkge1xuICAgIGlmICh0aGlzLl8zZCkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHAgPSB0aGlzLnBvaW50cyxcbiAgICAgIHggPSBwWzBdLngsXG4gICAgICB5ID0gcFswXS55LFxuICAgICAgcyA9IFtcIk1cIiwgeCwgeSwgdGhpcy5vcmRlciA9PT0gMiA/IFwiUVwiIDogXCJDXCJdO1xuICAgIGZvciAobGV0IGkgPSAxLCBsYXN0ID0gcC5sZW5ndGg7IGkgPCBsYXN0OyBpKyspIHtcbiAgICAgIHMucHVzaChwW2ldLngpO1xuICAgICAgcy5wdXNoKHBbaV0ueSk7XG4gICAgfVxuICAgIHJldHVybiBzLmpvaW4oXCIgXCIpO1xuICB9XG5cbiAgc2V0UmF0aW9zKHJhdGlvcykge1xuICAgIGlmIChyYXRpb3MubGVuZ3RoICE9PSB0aGlzLnBvaW50cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImluY29ycmVjdCBudW1iZXIgb2YgcmF0aW8gdmFsdWVzXCIpO1xuICAgIH1cbiAgICB0aGlzLnJhdGlvcyA9IHJhdGlvcztcbiAgICB0aGlzLl9sdXQgPSBbXTsgLy8gIGludmFsaWRhdGUgYW55IHByZWNvbXB1dGVkIExVVFxuICB9XG5cbiAgdmVyaWZ5KCkge1xuICAgIGNvbnN0IHByaW50ID0gdGhpcy5jb29yZERpZ2VzdCgpO1xuICAgIGlmIChwcmludCAhPT0gdGhpcy5fcHJpbnQpIHtcbiAgICAgIHRoaXMuX3ByaW50ID0gcHJpbnQ7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGNvb3JkRGlnZXN0KCkge1xuICAgIHJldHVybiB0aGlzLnBvaW50c1xuICAgICAgLm1hcChmdW5jdGlvbiAoYywgcG9zKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgcG9zICsgYy54ICsgYy55ICsgKGMueiA/IGMueiA6IDApO1xuICAgICAgfSlcbiAgICAgIC5qb2luKFwiXCIpO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIC8vIGludmFsaWRhdGUgYW55IHByZWNvbXB1dGVkIExVVFxuICAgIHRoaXMuX2x1dCA9IFtdO1xuICAgIHRoaXMuZHBvaW50cyA9IHV0aWxzLmRlcml2ZSh0aGlzLnBvaW50cywgdGhpcy5fM2QpO1xuICAgIHRoaXMuY29tcHV0ZWRpcmVjdGlvbigpO1xuICB9XG5cbiAgY29tcHV0ZWRpcmVjdGlvbigpIHtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCBhbmdsZSA9IHV0aWxzLmFuZ2xlKHBvaW50c1swXSwgcG9pbnRzW3RoaXMub3JkZXJdLCBwb2ludHNbMV0pO1xuICAgIHRoaXMuY2xvY2t3aXNlID0gYW5nbGUgPiAwO1xuICB9XG5cbiAgbGVuZ3RoKCkge1xuICAgIHJldHVybiB1dGlscy5sZW5ndGgodGhpcy5kZXJpdmF0aXZlLmJpbmQodGhpcykpO1xuICB9XG5cbiAgc3RhdGljIGdldEFCQyhvcmRlciA9IDIsIFMsIEIsIEUsIHQgPSAwLjUpIHtcbiAgICBjb25zdCB1ID0gdXRpbHMucHJvamVjdGlvbnJhdGlvKHQsIG9yZGVyKSxcbiAgICAgIHVtID0gMSAtIHUsXG4gICAgICBDID0ge1xuICAgICAgICB4OiB1ICogUy54ICsgdW0gKiBFLngsXG4gICAgICAgIHk6IHUgKiBTLnkgKyB1bSAqIEUueSxcbiAgICAgIH0sXG4gICAgICBzID0gdXRpbHMuYWJjcmF0aW8odCwgb3JkZXIpLFxuICAgICAgQSA9IHtcbiAgICAgICAgeDogQi54ICsgKEIueCAtIEMueCkgLyBzLFxuICAgICAgICB5OiBCLnkgKyAoQi55IC0gQy55KSAvIHMsXG4gICAgICB9O1xuICAgIHJldHVybiB7IEEsIEIsIEMsIFMsIEUgfTtcbiAgfVxuXG4gIGdldEFCQyh0LCBCKSB7XG4gICAgQiA9IEIgfHwgdGhpcy5nZXQodCk7XG4gICAgbGV0IFMgPSB0aGlzLnBvaW50c1swXTtcbiAgICBsZXQgRSA9IHRoaXMucG9pbnRzW3RoaXMub3JkZXJdO1xuICAgIHJldHVybiBCZXppZXIuZ2V0QUJDKHRoaXMub3JkZXIsIFMsIEIsIEUsIHQpO1xuICB9XG5cbiAgZ2V0TFVUKHN0ZXBzKSB7XG4gICAgdGhpcy52ZXJpZnkoKTtcbiAgICBzdGVwcyA9IHN0ZXBzIHx8IDEwMDtcbiAgICBpZiAodGhpcy5fbHV0Lmxlbmd0aCA9PT0gc3RlcHMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sdXQ7XG4gICAgfVxuICAgIHRoaXMuX2x1dCA9IFtdO1xuICAgIC8vIFdlIHdhbnQgYSByYW5nZSBmcm9tIDAgdG8gMSBpbmNsdXNpdmUsIHNvXG4gICAgLy8gd2UgZGVjcmVtZW50IGFuZCB0aGVuIHVzZSA8PSByYXRoZXIgdGhhbiA8OlxuICAgIHN0ZXBzLS07XG4gICAgZm9yIChsZXQgaSA9IDAsIHAsIHQ7IGkgPCBzdGVwczsgaSsrKSB7XG4gICAgICB0ID0gaSAvIChzdGVwcyAtIDEpO1xuICAgICAgcCA9IHRoaXMuY29tcHV0ZSh0KTtcbiAgICAgIHAudCA9IHQ7XG4gICAgICB0aGlzLl9sdXQucHVzaChwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2x1dDtcbiAgfVxuXG4gIG9uKHBvaW50LCBlcnJvcikge1xuICAgIGVycm9yID0gZXJyb3IgfHwgNTtcbiAgICBjb25zdCBsdXQgPSB0aGlzLmdldExVVCgpLFxuICAgICAgaGl0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBjLCB0ID0gMDsgaSA8IGx1dC5sZW5ndGg7IGkrKykge1xuICAgICAgYyA9IGx1dFtpXTtcbiAgICAgIGlmICh1dGlscy5kaXN0KGMsIHBvaW50KSA8IGVycm9yKSB7XG4gICAgICAgIGhpdHMucHVzaChjKTtcbiAgICAgICAgdCArPSBpIC8gbHV0Lmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFoaXRzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAodCAvPSBoaXRzLmxlbmd0aCk7XG4gIH1cblxuICBwcm9qZWN0KHBvaW50KSB7XG4gICAgLy8gc3RlcCAxOiBjb2Fyc2UgY2hlY2tcbiAgICBjb25zdCBMVVQgPSB0aGlzLmdldExVVCgpLFxuICAgICAgbCA9IExVVC5sZW5ndGggLSAxLFxuICAgICAgY2xvc2VzdCA9IHV0aWxzLmNsb3Nlc3QoTFVULCBwb2ludCksXG4gICAgICBtcG9zID0gY2xvc2VzdC5tcG9zLFxuICAgICAgdDEgPSAobXBvcyAtIDEpIC8gbCxcbiAgICAgIHQyID0gKG1wb3MgKyAxKSAvIGwsXG4gICAgICBzdGVwID0gMC4xIC8gbDtcblxuICAgIC8vIHN0ZXAgMjogZmluZSBjaGVja1xuICAgIGxldCBtZGlzdCA9IGNsb3Nlc3QubWRpc3QsXG4gICAgICB0ID0gdDEsXG4gICAgICBmdCA9IHQsXG4gICAgICBwO1xuICAgIG1kaXN0ICs9IDE7XG4gICAgZm9yIChsZXQgZDsgdCA8IHQyICsgc3RlcDsgdCArPSBzdGVwKSB7XG4gICAgICBwID0gdGhpcy5jb21wdXRlKHQpO1xuICAgICAgZCA9IHV0aWxzLmRpc3QocG9pbnQsIHApO1xuICAgICAgaWYgKGQgPCBtZGlzdCkge1xuICAgICAgICBtZGlzdCA9IGQ7XG4gICAgICAgIGZ0ID0gdDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnQgPSBmdCA8IDAgPyAwIDogZnQgPiAxID8gMSA6IGZ0O1xuICAgIHAgPSB0aGlzLmNvbXB1dGUoZnQpO1xuICAgIHAudCA9IGZ0O1xuICAgIHAuZCA9IG1kaXN0O1xuICAgIHJldHVybiBwO1xuICB9XG5cbiAgZ2V0KHQpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wdXRlKHQpO1xuICB9XG5cbiAgcG9pbnQoaWR4KSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRzW2lkeF07XG4gIH1cblxuICBjb21wdXRlKHQpIHtcbiAgICBpZiAodGhpcy5yYXRpb3MpIHtcbiAgICAgIHJldHVybiB1dGlscy5jb21wdXRlV2l0aFJhdGlvcyh0LCB0aGlzLnBvaW50cywgdGhpcy5yYXRpb3MsIHRoaXMuXzNkKTtcbiAgICB9XG4gICAgcmV0dXJuIHV0aWxzLmNvbXB1dGUodCwgdGhpcy5wb2ludHMsIHRoaXMuXzNkLCB0aGlzLnJhdGlvcyk7XG4gIH1cblxuICByYWlzZSgpIHtcbiAgICBjb25zdCBwID0gdGhpcy5wb2ludHMsXG4gICAgICBucCA9IFtwWzBdXSxcbiAgICAgIGsgPSBwLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMSwgcGksIHBpbTsgaSA8IGs7IGkrKykge1xuICAgICAgcGkgPSBwW2ldO1xuICAgICAgcGltID0gcFtpIC0gMV07XG4gICAgICBucFtpXSA9IHtcbiAgICAgICAgeDogKChrIC0gaSkgLyBrKSAqIHBpLnggKyAoaSAvIGspICogcGltLngsXG4gICAgICAgIHk6ICgoayAtIGkpIC8gaykgKiBwaS55ICsgKGkgLyBrKSAqIHBpbS55LFxuICAgICAgfTtcbiAgICB9XG4gICAgbnBba10gPSBwW2sgLSAxXTtcbiAgICByZXR1cm4gbmV3IEJlemllcihucCk7XG4gIH1cblxuICBkZXJpdmF0aXZlKHQpIHtcbiAgICByZXR1cm4gdXRpbHMuY29tcHV0ZSh0LCB0aGlzLmRwb2ludHNbMF0sIHRoaXMuXzNkKTtcbiAgfVxuXG4gIGRkZXJpdmF0aXZlKHQpIHtcbiAgICByZXR1cm4gdXRpbHMuY29tcHV0ZSh0LCB0aGlzLmRwb2ludHNbMV0sIHRoaXMuXzNkKTtcbiAgfVxuXG4gIGFsaWduKCkge1xuICAgIGxldCBwID0gdGhpcy5wb2ludHM7XG4gICAgcmV0dXJuIG5ldyBCZXppZXIodXRpbHMuYWxpZ24ocCwgeyBwMTogcFswXSwgcDI6IHBbcC5sZW5ndGggLSAxXSB9KSk7XG4gIH1cblxuICBjdXJ2YXR1cmUodCkge1xuICAgIHJldHVybiB1dGlscy5jdXJ2YXR1cmUodCwgdGhpcy5kcG9pbnRzWzBdLCB0aGlzLmRwb2ludHNbMV0sIHRoaXMuXzNkKTtcbiAgfVxuXG4gIGluZmxlY3Rpb25zKCkge1xuICAgIHJldHVybiB1dGlscy5pbmZsZWN0aW9ucyh0aGlzLnBvaW50cyk7XG4gIH1cblxuICBub3JtYWwodCkge1xuICAgIHJldHVybiB0aGlzLl8zZCA/IHRoaXMuX19ub3JtYWwzKHQpIDogdGhpcy5fX25vcm1hbDIodCk7XG4gIH1cblxuICBfX25vcm1hbDIodCkge1xuICAgIGNvbnN0IGQgPSB0aGlzLmRlcml2YXRpdmUodCk7XG4gICAgY29uc3QgcSA9IHNxcnQoZC54ICogZC54ICsgZC55ICogZC55KTtcbiAgICByZXR1cm4geyB4OiAtZC55IC8gcSwgeTogZC54IC8gcSB9O1xuICB9XG5cbiAgX19ub3JtYWwzKHQpIHtcbiAgICAvLyBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNTQ1MzE1OVxuICAgIGNvbnN0IHIxID0gdGhpcy5kZXJpdmF0aXZlKHQpLFxuICAgICAgcjIgPSB0aGlzLmRlcml2YXRpdmUodCArIDAuMDEpLFxuICAgICAgcTEgPSBzcXJ0KHIxLnggKiByMS54ICsgcjEueSAqIHIxLnkgKyByMS56ICogcjEueiksXG4gICAgICBxMiA9IHNxcnQocjIueCAqIHIyLnggKyByMi55ICogcjIueSArIHIyLnogKiByMi56KTtcbiAgICByMS54IC89IHExO1xuICAgIHIxLnkgLz0gcTE7XG4gICAgcjEueiAvPSBxMTtcbiAgICByMi54IC89IHEyO1xuICAgIHIyLnkgLz0gcTI7XG4gICAgcjIueiAvPSBxMjtcbiAgICAvLyBjcm9zcyBwcm9kdWN0XG4gICAgY29uc3QgYyA9IHtcbiAgICAgIHg6IHIyLnkgKiByMS56IC0gcjIueiAqIHIxLnksXG4gICAgICB5OiByMi56ICogcjEueCAtIHIyLnggKiByMS56LFxuICAgICAgejogcjIueCAqIHIxLnkgLSByMi55ICogcjEueCxcbiAgICB9O1xuICAgIGNvbnN0IG0gPSBzcXJ0KGMueCAqIGMueCArIGMueSAqIGMueSArIGMueiAqIGMueik7XG4gICAgYy54IC89IG07XG4gICAgYy55IC89IG07XG4gICAgYy56IC89IG07XG4gICAgLy8gcm90YXRpb24gbWF0cml4XG4gICAgY29uc3QgUiA9IFtcbiAgICAgIGMueCAqIGMueCxcbiAgICAgIGMueCAqIGMueSAtIGMueixcbiAgICAgIGMueCAqIGMueiArIGMueSxcbiAgICAgIGMueCAqIGMueSArIGMueixcbiAgICAgIGMueSAqIGMueSxcbiAgICAgIGMueSAqIGMueiAtIGMueCxcbiAgICAgIGMueCAqIGMueiAtIGMueSxcbiAgICAgIGMueSAqIGMueiArIGMueCxcbiAgICAgIGMueiAqIGMueixcbiAgICBdO1xuICAgIC8vIG5vcm1hbCB2ZWN0b3I6XG4gICAgY29uc3QgbiA9IHtcbiAgICAgIHg6IFJbMF0gKiByMS54ICsgUlsxXSAqIHIxLnkgKyBSWzJdICogcjEueixcbiAgICAgIHk6IFJbM10gKiByMS54ICsgUls0XSAqIHIxLnkgKyBSWzVdICogcjEueixcbiAgICAgIHo6IFJbNl0gKiByMS54ICsgUls3XSAqIHIxLnkgKyBSWzhdICogcjEueixcbiAgICB9O1xuICAgIHJldHVybiBuO1xuICB9XG5cbiAgaHVsbCh0KSB7XG4gICAgbGV0IHAgPSB0aGlzLnBvaW50cyxcbiAgICAgIF9wID0gW10sXG4gICAgICBxID0gW10sXG4gICAgICBpZHggPSAwO1xuICAgIHFbaWR4KytdID0gcFswXTtcbiAgICBxW2lkeCsrXSA9IHBbMV07XG4gICAgcVtpZHgrK10gPSBwWzJdO1xuICAgIGlmICh0aGlzLm9yZGVyID09PSAzKSB7XG4gICAgICBxW2lkeCsrXSA9IHBbM107XG4gICAgfVxuICAgIC8vIHdlIGxlcnAgYmV0d2VlbiBhbGwgcG9pbnRzIGF0IGVhY2ggaXRlcmF0aW9uLCB1bnRpbCB3ZSBoYXZlIDEgcG9pbnQgbGVmdC5cbiAgICB3aGlsZSAocC5sZW5ndGggPiAxKSB7XG4gICAgICBfcCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIHB0LCBsID0gcC5sZW5ndGggLSAxOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHB0ID0gdXRpbHMubGVycCh0LCBwW2ldLCBwW2kgKyAxXSk7XG4gICAgICAgIHFbaWR4KytdID0gcHQ7XG4gICAgICAgIF9wLnB1c2gocHQpO1xuICAgICAgfVxuICAgICAgcCA9IF9wO1xuICAgIH1cbiAgICByZXR1cm4gcTtcbiAgfVxuXG4gIHNwbGl0KHQxLCB0Mikge1xuICAgIC8vIHNob3J0Y3V0c1xuICAgIGlmICh0MSA9PT0gMCAmJiAhIXQyKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGxpdCh0MikubGVmdDtcbiAgICB9XG4gICAgaWYgKHQyID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGxpdCh0MSkucmlnaHQ7XG4gICAgfVxuXG4gICAgLy8gbm8gc2hvcnRjdXQ6IHVzZSBcImRlIENhc3RlbGphdVwiIGl0ZXJhdGlvbi5cbiAgICBjb25zdCBxID0gdGhpcy5odWxsKHQxKTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBsZWZ0OlxuICAgICAgICB0aGlzLm9yZGVyID09PSAyXG4gICAgICAgICAgPyBuZXcgQmV6aWVyKFtxWzBdLCBxWzNdLCBxWzVdXSlcbiAgICAgICAgICA6IG5ldyBCZXppZXIoW3FbMF0sIHFbNF0sIHFbN10sIHFbOV1dKSxcbiAgICAgIHJpZ2h0OlxuICAgICAgICB0aGlzLm9yZGVyID09PSAyXG4gICAgICAgICAgPyBuZXcgQmV6aWVyKFtxWzVdLCBxWzRdLCBxWzJdXSlcbiAgICAgICAgICA6IG5ldyBCZXppZXIoW3FbOV0sIHFbOF0sIHFbNl0sIHFbM11dKSxcbiAgICAgIHNwYW46IHEsXG4gICAgfTtcblxuICAgIC8vIG1ha2Ugc3VyZSB3ZSBiaW5kIF90MS9fdDIgaW5mb3JtYXRpb24hXG4gICAgcmVzdWx0LmxlZnQuX3QxID0gdXRpbHMubWFwKDAsIDAsIDEsIHRoaXMuX3QxLCB0aGlzLl90Mik7XG4gICAgcmVzdWx0LmxlZnQuX3QyID0gdXRpbHMubWFwKHQxLCAwLCAxLCB0aGlzLl90MSwgdGhpcy5fdDIpO1xuICAgIHJlc3VsdC5yaWdodC5fdDEgPSB1dGlscy5tYXAodDEsIDAsIDEsIHRoaXMuX3QxLCB0aGlzLl90Mik7XG4gICAgcmVzdWx0LnJpZ2h0Ll90MiA9IHV0aWxzLm1hcCgxLCAwLCAxLCB0aGlzLl90MSwgdGhpcy5fdDIpO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBubyB0Miwgd2UncmUgZG9uZVxuICAgIGlmICghdDIpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBhIHQyLCBzcGxpdCBhZ2FpbjpcbiAgICB0MiA9IHV0aWxzLm1hcCh0MiwgdDEsIDEsIDAsIDEpO1xuICAgIHJldHVybiByZXN1bHQucmlnaHQuc3BsaXQodDIpLmxlZnQ7XG4gIH1cblxuICBleHRyZW1hKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGxldCByb290cyA9IFtdO1xuXG4gICAgdGhpcy5kaW1zLmZvckVhY2goXG4gICAgICBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgIGxldCBtZm4gPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgIHJldHVybiB2W2RpbV07XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwID0gdGhpcy5kcG9pbnRzWzBdLm1hcChtZm4pO1xuICAgICAgICByZXN1bHRbZGltXSA9IHV0aWxzLmRyb290cyhwKTtcbiAgICAgICAgaWYgKHRoaXMub3JkZXIgPT09IDMpIHtcbiAgICAgICAgICBwID0gdGhpcy5kcG9pbnRzWzFdLm1hcChtZm4pO1xuICAgICAgICAgIHJlc3VsdFtkaW1dID0gcmVzdWx0W2RpbV0uY29uY2F0KHV0aWxzLmRyb290cyhwKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2RpbV0gPSByZXN1bHRbZGltXS5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdCA+PSAwICYmIHQgPD0gMTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJvb3RzID0gcm9vdHMuY29uY2F0KHJlc3VsdFtkaW1dLnNvcnQodXRpbHMubnVtYmVyU29ydCkpO1xuICAgICAgfS5iaW5kKHRoaXMpXG4gICAgKTtcblxuICAgIHJlc3VsdC52YWx1ZXMgPSByb290cy5zb3J0KHV0aWxzLm51bWJlclNvcnQpLmZpbHRlcihmdW5jdGlvbiAodiwgaWR4KSB7XG4gICAgICByZXR1cm4gcm9vdHMuaW5kZXhPZih2KSA9PT0gaWR4O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGJib3goKSB7XG4gICAgY29uc3QgZXh0cmVtYSA9IHRoaXMuZXh0cmVtYSgpLFxuICAgICAgcmVzdWx0ID0ge307XG4gICAgdGhpcy5kaW1zLmZvckVhY2goXG4gICAgICBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXN1bHRbZF0gPSB1dGlscy5nZXRtaW5tYXgodGhpcywgZCwgZXh0cmVtYVtkXSk7XG4gICAgICB9LmJpbmQodGhpcylcbiAgICApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBvdmVybGFwcyhjdXJ2ZSkge1xuICAgIGNvbnN0IGxiYm94ID0gdGhpcy5iYm94KCksXG4gICAgICB0YmJveCA9IGN1cnZlLmJib3goKTtcbiAgICByZXR1cm4gdXRpbHMuYmJveG92ZXJsYXAobGJib3gsIHRiYm94KTtcbiAgfVxuXG4gIG9mZnNldCh0LCBkKSB7XG4gICAgaWYgKHR5cGVvZiBkICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjb25zdCBjID0gdGhpcy5nZXQodCksXG4gICAgICAgIG4gPSB0aGlzLm5vcm1hbCh0KTtcbiAgICAgIGNvbnN0IHJldCA9IHtcbiAgICAgICAgYzogYyxcbiAgICAgICAgbjogbixcbiAgICAgICAgeDogYy54ICsgbi54ICogZCxcbiAgICAgICAgeTogYy55ICsgbi55ICogZCxcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5fM2QpIHtcbiAgICAgICAgcmV0LnogPSBjLnogKyBuLnogKiBkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpbmVhcikge1xuICAgICAgY29uc3QgbnYgPSB0aGlzLm5vcm1hbCgwKSxcbiAgICAgICAgY29vcmRzID0gdGhpcy5wb2ludHMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgY29uc3QgcmV0ID0ge1xuICAgICAgICAgICAgeDogcC54ICsgdCAqIG52LngsXG4gICAgICAgICAgICB5OiBwLnkgKyB0ICogbnYueSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChwLnogJiYgbnYueikge1xuICAgICAgICAgICAgcmV0LnogPSBwLnogKyB0ICogbnYuejtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSk7XG4gICAgICByZXR1cm4gW25ldyBCZXppZXIoY29vcmRzKV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlZHVjZSgpLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgaWYgKHMuX2xpbmVhcikge1xuICAgICAgICByZXR1cm4gcy5vZmZzZXQodClbMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcy5zY2FsZSh0KTtcbiAgICB9KTtcbiAgfVxuXG4gIHNpbXBsZSgpIHtcbiAgICBpZiAodGhpcy5vcmRlciA9PT0gMykge1xuICAgICAgY29uc3QgYTEgPSB1dGlscy5hbmdsZSh0aGlzLnBvaW50c1swXSwgdGhpcy5wb2ludHNbM10sIHRoaXMucG9pbnRzWzFdKTtcbiAgICAgIGNvbnN0IGEyID0gdXRpbHMuYW5nbGUodGhpcy5wb2ludHNbMF0sIHRoaXMucG9pbnRzWzNdLCB0aGlzLnBvaW50c1syXSk7XG4gICAgICBpZiAoKGExID4gMCAmJiBhMiA8IDApIHx8IChhMSA8IDAgJiYgYTIgPiAwKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBuMSA9IHRoaXMubm9ybWFsKDApO1xuICAgIGNvbnN0IG4yID0gdGhpcy5ub3JtYWwoMSk7XG4gICAgbGV0IHMgPSBuMS54ICogbjIueCArIG4xLnkgKiBuMi55O1xuICAgIGlmICh0aGlzLl8zZCkge1xuICAgICAgcyArPSBuMS56ICogbjIuejtcbiAgICB9XG4gICAgcmV0dXJuIGFicyhhY29zKHMpKSA8IHBpIC8gMztcbiAgfVxuXG4gIHJlZHVjZSgpIHtcbiAgICAvLyBUT0RPOiBleGFtaW5lIHRoZXNlIHZhciB0eXBlcyBpbiBtb3JlIGRldGFpbC4uLlxuICAgIGxldCBpLFxuICAgICAgdDEgPSAwLFxuICAgICAgdDIgPSAwLFxuICAgICAgc3RlcCA9IDAuMDEsXG4gICAgICBzZWdtZW50LFxuICAgICAgcGFzczEgPSBbXSxcbiAgICAgIHBhc3MyID0gW107XG4gICAgLy8gZmlyc3QgcGFzczogc3BsaXQgb24gZXh0cmVtYVxuICAgIGxldCBleHRyZW1hID0gdGhpcy5leHRyZW1hKCkudmFsdWVzO1xuICAgIGlmIChleHRyZW1hLmluZGV4T2YoMCkgPT09IC0xKSB7XG4gICAgICBleHRyZW1hID0gWzBdLmNvbmNhdChleHRyZW1hKTtcbiAgICB9XG4gICAgaWYgKGV4dHJlbWEuaW5kZXhPZigxKSA9PT0gLTEpIHtcbiAgICAgIGV4dHJlbWEucHVzaCgxKTtcbiAgICB9XG5cbiAgICBmb3IgKHQxID0gZXh0cmVtYVswXSwgaSA9IDE7IGkgPCBleHRyZW1hLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0MiA9IGV4dHJlbWFbaV07XG4gICAgICBzZWdtZW50ID0gdGhpcy5zcGxpdCh0MSwgdDIpO1xuICAgICAgc2VnbWVudC5fdDEgPSB0MTtcbiAgICAgIHNlZ21lbnQuX3QyID0gdDI7XG4gICAgICBwYXNzMS5wdXNoKHNlZ21lbnQpO1xuICAgICAgdDEgPSB0MjtcbiAgICB9XG5cbiAgICAvLyBzZWNvbmQgcGFzczogZnVydGhlciByZWR1Y2UgdGhlc2Ugc2VnbWVudHMgdG8gc2ltcGxlIHNlZ21lbnRzXG4gICAgcGFzczEuZm9yRWFjaChmdW5jdGlvbiAocDEpIHtcbiAgICAgIHQxID0gMDtcbiAgICAgIHQyID0gMDtcbiAgICAgIHdoaWxlICh0MiA8PSAxKSB7XG4gICAgICAgIGZvciAodDIgPSB0MSArIHN0ZXA7IHQyIDw9IDEgKyBzdGVwOyB0MiArPSBzdGVwKSB7XG4gICAgICAgICAgc2VnbWVudCA9IHAxLnNwbGl0KHQxLCB0Mik7XG4gICAgICAgICAgaWYgKCFzZWdtZW50LnNpbXBsZSgpKSB7XG4gICAgICAgICAgICB0MiAtPSBzdGVwO1xuICAgICAgICAgICAgaWYgKGFicyh0MSAtIHQyKSA8IHN0ZXApIHtcbiAgICAgICAgICAgICAgLy8gd2UgY2FuIG5ldmVyIGZvcm0gYSByZWR1Y3Rpb25cbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VnbWVudCA9IHAxLnNwbGl0KHQxLCB0Mik7XG4gICAgICAgICAgICBzZWdtZW50Ll90MSA9IHV0aWxzLm1hcCh0MSwgMCwgMSwgcDEuX3QxLCBwMS5fdDIpO1xuICAgICAgICAgICAgc2VnbWVudC5fdDIgPSB1dGlscy5tYXAodDIsIDAsIDEsIHAxLl90MSwgcDEuX3QyKTtcbiAgICAgICAgICAgIHBhc3MyLnB1c2goc2VnbWVudCk7XG4gICAgICAgICAgICB0MSA9IHQyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodDEgPCAxKSB7XG4gICAgICAgIHNlZ21lbnQgPSBwMS5zcGxpdCh0MSwgMSk7XG4gICAgICAgIHNlZ21lbnQuX3QxID0gdXRpbHMubWFwKHQxLCAwLCAxLCBwMS5fdDEsIHAxLl90Mik7XG4gICAgICAgIHNlZ21lbnQuX3QyID0gcDEuX3QyO1xuICAgICAgICBwYXNzMi5wdXNoKHNlZ21lbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwYXNzMjtcbiAgfVxuXG4gIHNjYWxlKGQpIHtcbiAgICBjb25zdCBvcmRlciA9IHRoaXMub3JkZXI7XG4gICAgbGV0IGRpc3RhbmNlRm4gPSBmYWxzZTtcbiAgICBpZiAodHlwZW9mIGQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZGlzdGFuY2VGbiA9IGQ7XG4gICAgfVxuICAgIGlmIChkaXN0YW5jZUZuICYmIG9yZGVyID09PSAyKSB7XG4gICAgICByZXR1cm4gdGhpcy5yYWlzZSgpLnNjYWxlKGRpc3RhbmNlRm4pO1xuICAgIH1cblxuICAgIC8vIFRPRE86IGFkZCBzcGVjaWFsIGhhbmRsaW5nIGZvciBkZWdlbmVyYXRlICg9bGluZWFyKSBjdXJ2ZXMuXG4gICAgY29uc3QgY2xvY2t3aXNlID0gdGhpcy5jbG9ja3dpc2U7XG4gICAgY29uc3QgcjEgPSBkaXN0YW5jZUZuID8gZGlzdGFuY2VGbigwKSA6IGQ7XG4gICAgY29uc3QgcjIgPSBkaXN0YW5jZUZuID8gZGlzdGFuY2VGbigxKSA6IGQ7XG4gICAgY29uc3QgdiA9IFt0aGlzLm9mZnNldCgwLCAxMCksIHRoaXMub2Zmc2V0KDEsIDEwKV07XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgY29uc3QgbnAgPSBbXTtcbiAgICBjb25zdCBvID0gdXRpbHMubGxpNCh2WzBdLCB2WzBdLmMsIHZbMV0sIHZbMV0uYyk7XG5cbiAgICBpZiAoIW8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBzY2FsZSB0aGlzIGN1cnZlLiBUcnkgcmVkdWNpbmcgaXQgZmlyc3QuXCIpO1xuICAgIH1cbiAgICAvLyBtb3ZlIGFsbCBwb2ludHMgYnkgZGlzdGFuY2UgJ2QnIHdydCB0aGUgb3JpZ2luICdvJ1xuXG4gICAgLy8gbW92ZSBlbmQgcG9pbnRzIGJ5IGZpeGVkIGRpc3RhbmNlIGFsb25nIG5vcm1hbC5cbiAgICBbMCwgMV0uZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgY29uc3QgcCA9IChucFt0ICogb3JkZXJdID0gdXRpbHMuY29weShwb2ludHNbdCAqIG9yZGVyXSkpO1xuICAgICAgcC54ICs9ICh0ID8gcjIgOiByMSkgKiB2W3RdLm4ueDtcbiAgICAgIHAueSArPSAodCA/IHIyIDogcjEpICogdlt0XS5uLnk7XG4gICAgfSk7XG5cbiAgICBpZiAoIWRpc3RhbmNlRm4pIHtcbiAgICAgIC8vIG1vdmUgY29udHJvbCBwb2ludHMgdG8gbGllIG9uIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIG9mZnNldFxuICAgICAgLy8gZGVyaXZhdGl2ZSB2ZWN0b3IsIGFuZCB0aGUgb3JpZ2luLXRocm91Z2gtY29udHJvbCB2ZWN0b3JcbiAgICAgIFswLCAxXS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgIGlmIChvcmRlciA9PT0gMiAmJiAhIXQpIHJldHVybjtcbiAgICAgICAgY29uc3QgcCA9IG5wW3QgKiBvcmRlcl07XG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmRlcml2YXRpdmUodCk7XG4gICAgICAgIGNvbnN0IHAyID0geyB4OiBwLnggKyBkLngsIHk6IHAueSArIGQueSB9O1xuICAgICAgICBucFt0ICsgMV0gPSB1dGlscy5sbGk0KHAsIHAyLCBvLCBwb2ludHNbdCArIDFdKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBCZXppZXIobnApO1xuICAgIH1cblxuICAgIC8vIG1vdmUgY29udHJvbCBwb2ludHMgYnkgXCJob3dldmVyIG11Y2ggbmVjZXNzYXJ5IHRvXG4gICAgLy8gZW5zdXJlIHRoZSBjb3JyZWN0IHRhbmdlbnQgdG8gZW5kcG9pbnRcIi5cbiAgICBbMCwgMV0uZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKG9yZGVyID09PSAyICYmICEhdCkgcmV0dXJuO1xuICAgICAgdmFyIHAgPSBwb2ludHNbdCArIDFdO1xuICAgICAgdmFyIG92ID0ge1xuICAgICAgICB4OiBwLnggLSBvLngsXG4gICAgICAgIHk6IHAueSAtIG8ueSxcbiAgICAgIH07XG4gICAgICB2YXIgcmMgPSBkaXN0YW5jZUZuID8gZGlzdGFuY2VGbigodCArIDEpIC8gb3JkZXIpIDogZDtcbiAgICAgIGlmIChkaXN0YW5jZUZuICYmICFjbG9ja3dpc2UpIHJjID0gLXJjO1xuICAgICAgdmFyIG0gPSBzcXJ0KG92LnggKiBvdi54ICsgb3YueSAqIG92LnkpO1xuICAgICAgb3YueCAvPSBtO1xuICAgICAgb3YueSAvPSBtO1xuICAgICAgbnBbdCArIDFdID0ge1xuICAgICAgICB4OiBwLnggKyByYyAqIG92LngsXG4gICAgICAgIHk6IHAueSArIHJjICogb3YueSxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBCZXppZXIobnApO1xuICB9XG5cbiAgb3V0bGluZShkMSwgZDIsIGQzLCBkNCkge1xuICAgIGQyID0gdHlwZW9mIGQyID09PSBcInVuZGVmaW5lZFwiID8gZDEgOiBkMjtcbiAgICBjb25zdCByZWR1Y2VkID0gdGhpcy5yZWR1Y2UoKSxcbiAgICAgIGxlbiA9IHJlZHVjZWQubGVuZ3RoLFxuICAgICAgZmN1cnZlcyA9IFtdO1xuXG4gICAgbGV0IGJjdXJ2ZXMgPSBbXSxcbiAgICAgIHAsXG4gICAgICBhbGVuID0gMCxcbiAgICAgIHRsZW4gPSB0aGlzLmxlbmd0aCgpO1xuXG4gICAgY29uc3QgZ3JhZHVhdGVkID0gdHlwZW9mIGQzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBkNCAhPT0gXCJ1bmRlZmluZWRcIjtcblxuICAgIGZ1bmN0aW9uIGxpbmVhckRpc3RhbmNlRnVuY3Rpb24ocywgZSwgdGxlbiwgYWxlbiwgc2xlbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGNvbnN0IGYxID0gYWxlbiAvIHRsZW4sXG4gICAgICAgICAgZjIgPSAoYWxlbiArIHNsZW4pIC8gdGxlbixcbiAgICAgICAgICBkID0gZSAtIHM7XG4gICAgICAgIHJldHVybiB1dGlscy5tYXAodiwgMCwgMSwgcyArIGYxICogZCwgcyArIGYyICogZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGZvcm0gY3VydmUgb3VsaW5lc1xuICAgIHJlZHVjZWQuZm9yRWFjaChmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgICAgY29uc3Qgc2xlbiA9IHNlZ21lbnQubGVuZ3RoKCk7XG4gICAgICBpZiAoZ3JhZHVhdGVkKSB7XG4gICAgICAgIGZjdXJ2ZXMucHVzaChcbiAgICAgICAgICBzZWdtZW50LnNjYWxlKGxpbmVhckRpc3RhbmNlRnVuY3Rpb24oZDEsIGQzLCB0bGVuLCBhbGVuLCBzbGVuKSlcbiAgICAgICAgKTtcbiAgICAgICAgYmN1cnZlcy5wdXNoKFxuICAgICAgICAgIHNlZ21lbnQuc2NhbGUobGluZWFyRGlzdGFuY2VGdW5jdGlvbigtZDIsIC1kNCwgdGxlbiwgYWxlbiwgc2xlbikpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmY3VydmVzLnB1c2goc2VnbWVudC5zY2FsZShkMSkpO1xuICAgICAgICBiY3VydmVzLnB1c2goc2VnbWVudC5zY2FsZSgtZDIpKTtcbiAgICAgIH1cbiAgICAgIGFsZW4gKz0gc2xlbjtcbiAgICB9KTtcblxuICAgIC8vIHJldmVyc2UgdGhlIFwicmV0dXJuXCIgb3V0bGluZVxuICAgIGJjdXJ2ZXMgPSBiY3VydmVzXG4gICAgICAubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHAgPSBzLnBvaW50cztcbiAgICAgICAgaWYgKHBbM10pIHtcbiAgICAgICAgICBzLnBvaW50cyA9IFtwWzNdLCBwWzJdLCBwWzFdLCBwWzBdXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzLnBvaW50cyA9IFtwWzJdLCBwWzFdLCBwWzBdXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICAgIH0pXG4gICAgICAucmV2ZXJzZSgpO1xuXG4gICAgLy8gZm9ybSB0aGUgZW5kY2FwcyBhcyBsaW5lc1xuICAgIGNvbnN0IGZzID0gZmN1cnZlc1swXS5wb2ludHNbMF0sXG4gICAgICBmZSA9IGZjdXJ2ZXNbbGVuIC0gMV0ucG9pbnRzW2ZjdXJ2ZXNbbGVuIC0gMV0ucG9pbnRzLmxlbmd0aCAtIDFdLFxuICAgICAgYnMgPSBiY3VydmVzW2xlbiAtIDFdLnBvaW50c1tiY3VydmVzW2xlbiAtIDFdLnBvaW50cy5sZW5ndGggLSAxXSxcbiAgICAgIGJlID0gYmN1cnZlc1swXS5wb2ludHNbMF0sXG4gICAgICBscyA9IHV0aWxzLm1ha2VsaW5lKGJzLCBmcyksXG4gICAgICBsZSA9IHV0aWxzLm1ha2VsaW5lKGZlLCBiZSksXG4gICAgICBzZWdtZW50cyA9IFtsc10uY29uY2F0KGZjdXJ2ZXMpLmNvbmNhdChbbGVdKS5jb25jYXQoYmN1cnZlcyksXG4gICAgICBzbGVuID0gc2VnbWVudHMubGVuZ3RoO1xuXG4gICAgcmV0dXJuIG5ldyBQb2x5QmV6aWVyKHNlZ21lbnRzKTtcbiAgfVxuXG4gIG91dGxpbmVzaGFwZXMoZDEsIGQyLCBjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZCkge1xuICAgIGQyID0gZDIgfHwgZDE7XG4gICAgY29uc3Qgb3V0bGluZSA9IHRoaXMub3V0bGluZShkMSwgZDIpLmN1cnZlcztcbiAgICBjb25zdCBzaGFwZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMSwgbGVuID0gb3V0bGluZS5sZW5ndGg7IGkgPCBsZW4gLyAyOyBpKyspIHtcbiAgICAgIGNvbnN0IHNoYXBlID0gdXRpbHMubWFrZXNoYXBlKFxuICAgICAgICBvdXRsaW5lW2ldLFxuICAgICAgICBvdXRsaW5lW2xlbiAtIGldLFxuICAgICAgICBjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZFxuICAgICAgKTtcbiAgICAgIHNoYXBlLnN0YXJ0Y2FwLnZpcnR1YWwgPSBpID4gMTtcbiAgICAgIHNoYXBlLmVuZGNhcC52aXJ0dWFsID0gaSA8IGxlbiAvIDIgLSAxO1xuICAgICAgc2hhcGVzLnB1c2goc2hhcGUpO1xuICAgIH1cbiAgICByZXR1cm4gc2hhcGVzO1xuICB9XG5cbiAgaW50ZXJzZWN0cyhjdXJ2ZSwgY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGQpIHtcbiAgICBpZiAoIWN1cnZlKSByZXR1cm4gdGhpcy5zZWxmaW50ZXJzZWN0cyhjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZCk7XG4gICAgaWYgKGN1cnZlLnAxICYmIGN1cnZlLnAyKSB7XG4gICAgICByZXR1cm4gdGhpcy5saW5lSW50ZXJzZWN0cyhjdXJ2ZSk7XG4gICAgfVxuICAgIGlmIChjdXJ2ZSBpbnN0YW5jZW9mIEJlemllcikge1xuICAgICAgY3VydmUgPSBjdXJ2ZS5yZWR1Y2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3VydmVpbnRlcnNlY3RzKFxuICAgICAgdGhpcy5yZWR1Y2UoKSxcbiAgICAgIGN1cnZlLFxuICAgICAgY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGRcbiAgICApO1xuICB9XG5cbiAgbGluZUludGVyc2VjdHMobGluZSkge1xuICAgIGNvbnN0IG14ID0gbWluKGxpbmUucDEueCwgbGluZS5wMi54KSxcbiAgICAgIG15ID0gbWluKGxpbmUucDEueSwgbGluZS5wMi55KSxcbiAgICAgIE1YID0gbWF4KGxpbmUucDEueCwgbGluZS5wMi54KSxcbiAgICAgIE1ZID0gbWF4KGxpbmUucDEueSwgbGluZS5wMi55KTtcbiAgICByZXR1cm4gdXRpbHMucm9vdHModGhpcy5wb2ludHMsIGxpbmUpLmZpbHRlcigodCkgPT4ge1xuICAgICAgdmFyIHAgPSB0aGlzLmdldCh0KTtcbiAgICAgIHJldHVybiB1dGlscy5iZXR3ZWVuKHAueCwgbXgsIE1YKSAmJiB1dGlscy5iZXR3ZWVuKHAueSwgbXksIE1ZKTtcbiAgICB9KTtcbiAgfVxuXG4gIHNlbGZpbnRlcnNlY3RzKGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkKSB7XG4gICAgLy8gXCJzaW1wbGVcIiBjdXJ2ZXMgY2Fubm90IGludGVyc2VjdCB3aXRoIHRoZWlyIGRpcmVjdFxuICAgIC8vIG5laWdoYm91ciwgc28gZm9yIGVhY2ggc2VnbWVudCBYIHdlIGNoZWNrIHdoZXRoZXJcbiAgICAvLyBpdCBpbnRlcnNlY3RzIFswOngtMl1beCsyOmxhc3RdLlxuXG4gICAgY29uc3QgcmVkdWNlZCA9IHRoaXMucmVkdWNlKCksXG4gICAgICBsZW4gPSByZWR1Y2VkLmxlbmd0aCAtIDIsXG4gICAgICByZXN1bHRzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMCwgcmVzdWx0LCBsZWZ0LCByaWdodDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBsZWZ0ID0gcmVkdWNlZC5zbGljZShpLCBpICsgMSk7XG4gICAgICByaWdodCA9IHJlZHVjZWQuc2xpY2UoaSArIDIpO1xuICAgICAgcmVzdWx0ID0gdGhpcy5jdXJ2ZWludGVyc2VjdHMobGVmdCwgcmlnaHQsIGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkKTtcbiAgICAgIHJlc3VsdHMucHVzaCguLi5yZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIGN1cnZlaW50ZXJzZWN0cyhjMSwgYzIsIGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkKSB7XG4gICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICAvLyBzdGVwIDE6IHBhaXIgb2ZmIGFueSBvdmVybGFwcGluZyBzZWdtZW50c1xuICAgIGMxLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcbiAgICAgIGMyLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgaWYgKGwub3ZlcmxhcHMocikpIHtcbiAgICAgICAgICBwYWlycy5wdXNoKHsgbGVmdDogbCwgcmlnaHQ6IHIgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIHN0ZXAgMjogZm9yIGVhY2ggcGFpcmluZywgcnVuIHRocm91Z2ggdGhlIGNvbnZlcmdlbmNlIGFsZ29yaXRobS5cbiAgICBsZXQgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICAgIHBhaXJzLmZvckVhY2goZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHV0aWxzLnBhaXJpdGVyYXRpb24oXG4gICAgICAgIHBhaXIubGVmdCxcbiAgICAgICAgcGFpci5yaWdodCxcbiAgICAgICAgY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGRcbiAgICAgICk7XG4gICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgaW50ZXJzZWN0aW9ucyA9IGludGVyc2VjdGlvbnMuY29uY2F0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH1cblxuICBhcmNzKGVycm9yVGhyZXNob2xkKSB7XG4gICAgZXJyb3JUaHJlc2hvbGQgPSBlcnJvclRocmVzaG9sZCB8fCAwLjU7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZXJhdGUoZXJyb3JUaHJlc2hvbGQsIFtdKTtcbiAgfVxuXG4gIF9lcnJvcihwYywgbnAxLCBzLCBlKSB7XG4gICAgY29uc3QgcSA9IChlIC0gcykgLyA0LFxuICAgICAgYzEgPSB0aGlzLmdldChzICsgcSksXG4gICAgICBjMiA9IHRoaXMuZ2V0KGUgLSBxKSxcbiAgICAgIHJlZiA9IHV0aWxzLmRpc3QocGMsIG5wMSksXG4gICAgICBkMSA9IHV0aWxzLmRpc3QocGMsIGMxKSxcbiAgICAgIGQyID0gdXRpbHMuZGlzdChwYywgYzIpO1xuICAgIHJldHVybiBhYnMoZDEgLSByZWYpICsgYWJzKGQyIC0gcmVmKTtcbiAgfVxuXG4gIF9pdGVyYXRlKGVycm9yVGhyZXNob2xkLCBjaXJjbGVzKSB7XG4gICAgbGV0IHRfcyA9IDAsXG4gICAgICB0X2UgPSAxLFxuICAgICAgc2FmZXR5O1xuICAgIC8vIHdlIGRvIGEgYmluYXJ5IHNlYXJjaCB0byBmaW5kIHRoZSBcImdvb2QgYHRgIGNsb3Nlc3QgdG8gbm8tbG9uZ2VyLWdvb2RcIlxuICAgIGRvIHtcbiAgICAgIHNhZmV0eSA9IDA7XG5cbiAgICAgIC8vIHN0ZXAgMTogc3RhcnQgd2l0aCB0aGUgbWF4aW11bSBwb3NzaWJsZSBhcmNcbiAgICAgIHRfZSA9IDE7XG5cbiAgICAgIC8vIHBvaW50czpcbiAgICAgIGxldCBucDEgPSB0aGlzLmdldCh0X3MpLFxuICAgICAgICBucDIsXG4gICAgICAgIG5wMyxcbiAgICAgICAgYXJjLFxuICAgICAgICBwcmV2X2FyYztcblxuICAgICAgLy8gYm9vbGVhbnM6XG4gICAgICBsZXQgY3Vycl9nb29kID0gZmFsc2UsXG4gICAgICAgIHByZXZfZ29vZCA9IGZhbHNlLFxuICAgICAgICBkb25lO1xuXG4gICAgICAvLyBudW1iZXJzOlxuICAgICAgbGV0IHRfbSA9IHRfZSxcbiAgICAgICAgcHJldl9lID0gMSxcbiAgICAgICAgc3RlcCA9IDA7XG5cbiAgICAgIC8vIHN0ZXAgMjogZmluZCB0aGUgYmVzdCBwb3NzaWJsZSBhcmNcbiAgICAgIGRvIHtcbiAgICAgICAgcHJldl9nb29kID0gY3Vycl9nb29kO1xuICAgICAgICBwcmV2X2FyYyA9IGFyYztcbiAgICAgICAgdF9tID0gKHRfcyArIHRfZSkgLyAyO1xuICAgICAgICBzdGVwKys7XG5cbiAgICAgICAgbnAyID0gdGhpcy5nZXQodF9tKTtcbiAgICAgICAgbnAzID0gdGhpcy5nZXQodF9lKTtcblxuICAgICAgICBhcmMgPSB1dGlscy5nZXRjY2VudGVyKG5wMSwgbnAyLCBucDMpO1xuXG4gICAgICAgIC8vYWxzbyBzYXZlIHRoZSB0IHZhbHVlc1xuICAgICAgICBhcmMuaW50ZXJ2YWwgPSB7XG4gICAgICAgICAgc3RhcnQ6IHRfcyxcbiAgICAgICAgICBlbmQ6IHRfZSxcbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgZXJyb3IgPSB0aGlzLl9lcnJvcihhcmMsIG5wMSwgdF9zLCB0X2UpO1xuICAgICAgICBjdXJyX2dvb2QgPSBlcnJvciA8PSBlcnJvclRocmVzaG9sZDtcblxuICAgICAgICBkb25lID0gcHJldl9nb29kICYmICFjdXJyX2dvb2Q7XG4gICAgICAgIGlmICghZG9uZSkgcHJldl9lID0gdF9lO1xuXG4gICAgICAgIC8vIHRoaXMgYXJjIGlzIGZpbmU6IHdlIGNhbiBtb3ZlICdlJyB1cCB0byBzZWUgaWYgd2UgY2FuIGZpbmQgYSB3aWRlciBhcmNcbiAgICAgICAgaWYgKGN1cnJfZ29vZCkge1xuICAgICAgICAgIC8vIGlmIGUgaXMgYWxyZWFkeSBhdCBtYXgsIHRoZW4gd2UncmUgZG9uZSBmb3IgdGhpcyBhcmMuXG4gICAgICAgICAgaWYgKHRfZSA+PSAxKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgY2FwIGF0IHQ9MVxuICAgICAgICAgICAgYXJjLmludGVydmFsLmVuZCA9IHByZXZfZSA9IDE7XG4gICAgICAgICAgICBwcmV2X2FyYyA9IGFyYztcbiAgICAgICAgICAgIC8vIGlmIHdlIGNhcHBlZCB0aGUgYXJjIHNlZ21lbnQgdG8gdD0xIHdlIGFsc28gbmVlZCB0byBtYWtlIHN1cmUgdGhhdFxuICAgICAgICAgICAgLy8gdGhlIGFyYydzIGVuZCBhbmdsZSBpcyBjb3JyZWN0IHdpdGggcmVzcGVjdCB0byB0aGUgYmV6aWVyIGVuZCBwb2ludC5cbiAgICAgICAgICAgIGlmICh0X2UgPiAxKSB7XG4gICAgICAgICAgICAgIGxldCBkID0ge1xuICAgICAgICAgICAgICAgIHg6IGFyYy54ICsgYXJjLnIgKiBjb3MoYXJjLmUpLFxuICAgICAgICAgICAgICAgIHk6IGFyYy55ICsgYXJjLnIgKiBzaW4oYXJjLmUpLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBhcmMuZSArPSB1dGlscy5hbmdsZSh7IHg6IGFyYy54LCB5OiBhcmMueSB9LCBkLCB0aGlzLmdldCgxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaWYgbm90LCBtb3ZlIGl0IHVwIGJ5IGhhbGYgdGhlIGl0ZXJhdGlvbiBkaXN0YW5jZVxuICAgICAgICAgIHRfZSA9IHRfZSArICh0X2UgLSB0X3MpIC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0aGlzIGlzIGEgYmFkIGFyYzogd2UgbmVlZCB0byBtb3ZlICdlJyBkb3duIHRvIGZpbmQgYSBnb29kIGFyY1xuICAgICAgICAgIHRfZSA9IHRfbTtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoIWRvbmUgJiYgc2FmZXR5KysgPCAxMDApO1xuXG4gICAgICBpZiAoc2FmZXR5ID49IDEwMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gY29uc29sZS5sb2coXCJMODM1OiBbRl0gYXJjIGZvdW5kXCIsIHRfcywgcHJldl9lLCBwcmV2X2FyYy54LCBwcmV2X2FyYy55LCBwcmV2X2FyYy5zLCBwcmV2X2FyYy5lKTtcblxuICAgICAgcHJldl9hcmMgPSBwcmV2X2FyYyA/IHByZXZfYXJjIDogYXJjO1xuICAgICAgY2lyY2xlcy5wdXNoKHByZXZfYXJjKTtcbiAgICAgIHRfcyA9IHByZXZfZTtcbiAgICB9IHdoaWxlICh0X2UgPCAxKTtcbiAgICByZXR1cm4gY2lyY2xlcztcbiAgfVxufVxuXG5leHBvcnQgeyBCZXppZXIgfTtcbiIsIi8qKlxuICog5pa55ZCRXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBESVJFQ1RJT04gPSB7XG4gICAgLyoqIFJJR0hUICovXG4gICAgUklHSFQ6IDAsXG4gICAgLyoqIEJPVFRPTSAqL1xuICAgIEJPVFRPTTogMSxcbiAgICAvKiogTEVGVCAqL1xuICAgIExFRlQ6IDIsXG4gICAgLyoqIFRPUCAqL1xuICAgIFRPUDogMyxcbiAgICAvKiogU0VMRiAqL1xuICAgIFNFTEY6IDEwMCxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5leHREaXJlY3Rpb24oZGlyZWN0aW9uLCBjbG9ja3dpc2UpIHtcbiAgICBjb25zdCBuZXh0RGlyID0gKGRpcmVjdGlvbiArIChjbG9ja3dpc2UgPyAxIDogLTEpKSAlIDQ7XG4gICAgcmV0dXJuIG5leHREaXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvcHBvc2l0ZURpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gKGRpcmVjdGlvbiArIDIpICUgNFxufVxuXG5leHBvcnQgY29uc3QgQVBQUk9YSU1BVEUgPSA2O1xuXG5leHBvcnQgY29uc3QgSkZMT1dfTU9ERSA9IHtcbiAgICBERUZBVUxUOiAnREVGQVVMVCcsXG4gICAgTElOS0lORzogJ0xJTktJTkcnLFxufVxuXG5leHBvcnQgY29uc3QgTElORV9ESVIgPSB7XG4gICAgRlJPTTogJ2Zyb20nLFxuICAgIFRPOiAndG8nLFxufSIsImltcG9ydCB7XG4gICAgQmV6aWVyLFxufSBmcm9tICdiZXppZXItanMnO1xuaW1wb3J0IHsgRElSRUNUSU9OIH0gZnJvbSAnLi9jb25zdGFuY2UnO1xuXG4vKipcbiAqIOagueaNrueCueiuoeeul+acgOWwj+WkluaOpeefqeW9olxuICogQHBhcmFtIHtudW1iZXJbXVtdfSBwb2ludHMgLSDngrnpm4blkIhcbiAqIEByZXR1cm4ge09iamVjdH0gZGVtZW5zaW9uIOWuvemrmO+8jOWdkOagh1xuICovXG5leHBvcnQgZnVuY3Rpb24gYm91bmRpbmdfYm94KHBvaW50cykge1xuICAgIGlmKHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG1pbl94ID0gSW5maW5pdHk7IFxuICAgIGxldCBtaW5feSA9IEluZmluaXR5OyBcbiAgICBsZXQgbWF4X3ggPSAtSW5maW5pdHk7IFxuICAgIGxldCBtYXhfeSA9IC1JbmZpbml0eTsgXG4gICAgZm9yKGxldCBpZHggaW4gcG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBwb2ludHNbaWR4XTtcbiAgICAgICAgaWYoaXRlbVswXSA8IG1pbl94KXtcbiAgICAgICAgICAgIG1pbl94ID0gaXRlbVswXVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW1bMF0gPiBtYXhfeCkge1xuICAgICAgICAgICAgbWF4X3ggPSBpdGVtWzBdXG4gICAgICAgIH0gXG5cbiAgICAgICAgaWYgKGl0ZW1bMV0gPCBtaW5feSkge1xuICAgICAgICAgICAgbWluX3kgPSBpdGVtWzFdXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbVsxXSA+IG1heF95KSB7XG4gICAgICAgICAgICBtYXhfeSA9IGl0ZW1bMV1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBwb2ludHM6IFsobWluX3gsbWluX3kpLChtYXhfeCxtaW5feSksKG1heF94LG1heF95KSwobWluX3gsbWF4X3kpXSxcbiAgICAgICAgd2lkdGg6IE1hdGgubWF4KG1heF94IC0gbWluX3gsIDEwKSxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLm1heChtYXhfeSAtIG1pbl95LCAxMCksXG4gICAgICAgIHg6IG1pbl94LFxuICAgICAgICB5OiBtaW5feSxcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNxcih4KSB7XG4gICAgcmV0dXJuIHggKiB4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRpc3QyKHYsIHcpIHtcbiAgICByZXR1cm4gc3FyKHZbMF0gLSB3WzBdKSArIHNxcih2WzFdIC0gd1sxXSk7XG59XG5cbi8vIHAgLSBwb2ludFxuLy8gdiAtIHN0YXJ0IHBvaW50IG9mIHNlZ21lbnRcbi8vIHcgLSBlbmQgcG9pbnQgb2Ygc2VnbWVudFxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RUb1NlZ21lbnRTcXVhcmVkKHAsIHYsIHcpIHtcbiAgICBjb25zdCBsMiA9IGRpc3QyKHYsIHcpO1xuICAgIGlmIChsMiA9PT0gMCkgcmV0dXJuIGRpc3QyKHAsIHYpO1xuICAgIGxldCB0ID0gKChwWzBdIC0gdlswXSkgKiAod1swXSAtIHZbMF0pICsgKHBbMV0gLSB2WzFdKSAqICh3WzFdIC0gdlsxXSkpIC8gbDI7XG4gICAgdCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHQpKTtcbiAgICByZXR1cm4gZGlzdDIocCwgWyB2WzBdICsgdCAqICh3WzBdIC0gdlswXSksIHZbMV0gKyB0ICogKHdbMV0gLSB2WzFdKSBdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1pbkludGVyc2VjdGlvbkJldHdlZW5Ob2RlcyhkbXNmcm9tLCBkbXN0bykge1xuICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgIGZyb21EaXI6IG51bGwsXG4gICAgICAgIGZyb21QOiBudWxsLFxuICAgICAgICB0b0RpcjogbnVsbCxcbiAgICAgICAgdG9QOiBudWxsLFxuICAgICAgICBkaXN0TWluOiBJbmZpbml0eVxuICAgIH1cbiAgICBPYmplY3Qua2V5cyhkbXNmcm9tKS5mb3JFYWNoKGRmID0+IHtcbiAgICAgICAgaWYoKCtkZikgPT09IERJUkVDVElPTi5TRUxGKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBmID0gZG1zZnJvbVtkZl07XG4gICAgICAgIE9iamVjdC5rZXlzKGRtc3RvKS5mb3JFYWNoKGR0ID0+IHtcbiAgICAgICAgICAgIGlmKCgrZHQpID09PSBESVJFQ1RJT04uU0VMRikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwdCA9IGRtc3RvW2R0XTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBkaXN0MihwZiwgcHQpO1xuICAgICAgICAgICAgaWYoZGlzdCA8IG1ldGEuZGlzdE1pbikge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWV0YSwge1xuICAgICAgICAgICAgICAgICAgICBkaXN0TWluOiBkaXN0LFxuICAgICAgICAgICAgICAgICAgICBmcm9tRGlyOiArZGYsXG4gICAgICAgICAgICAgICAgICAgIGZyb21QOiBwZixcbiAgICAgICAgICAgICAgICAgICAgdG9EaXI6ICtkdCxcbiAgICAgICAgICAgICAgICAgICAgdG9QOiBwdCxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH0pO1xuICAgIHJldHVybiBtZXRhO1xufVxuXG4vLyBleHBvcnQgZnVuY3Rpb24gYmV6aWVyUG9pbnRzKHAxLCBwMiwgc3RhcnRfZGlyID0gRElSRUNUSU9OLlRPUCwgZW5kX2RpciA9IERJUkVDVElPTi5UT1AsIGFudGljbG9jayA9IGZhbHNlKSB7XG4vLyAgICAgY29uc3QgaXNTYW1lRGlyZWN0aW9uID0gc3RhcnRfZGlyID09PSBlbmRfZGlyO1xuLy8gICAgIGNvbnN0IGlzVmVydGljYWxTdGFydCA9IFtESVJFQ1RJT04uVE9QLCBESVJFQ1RJT04uQk9UVE9NXS5pbmNsdWRlcyhzdGFydF9kaXIpOyAgIFxuLy8gICAgIGNvbnN0IGlzVmVydGljYWxFbmQgPSBbRElSRUNUSU9OLlRPUCwgRElSRUNUSU9OLkJPVFRPTV0uaW5jbHVkZXMoZW5kX2Rpcik7XG4vLyAgICAgY29uc3QgYXJyb3dzcGFuID0gW0RJUkVDVElPTi5UT1AsIERJUkVDVElPTi5MRUZUXS5pbmNsdWRlcyhlbmRfZGlyKSA/IC01IDogNTtcbi8vICAgICBjb25zdCBlbmRYID0gaXNWZXJ0aWNhbEVuZCA/IHAyWzBdIDogcDJbMF0gKyBhcnJvd3NwYW47XG4vLyAgICAgY29uc3QgZW5kWSA9IGlzVmVydGljYWxFbmQgPyBwMlsxXSArIGFycm93c3BhbiA6IHAyWzFdO1xuLy8gICAgIGlmKGlzU2FtZURpcmVjdGlvbikge1xuLy8gICAgICAgICBsZXQgc3BhbiA9IE1hdGguYWJzKGlzVmVydGljYWxTdGFydCA/IChlbmRZIC0gcDFbMV0pIDogKGVuZFggLSBwMVswXSkpXG4vLyAgICAgICAgIHNwYW4gPSBNYXRoLm1pbihzcGFuLCA1MCk7XG4vLyAgICAgICAgIGNvbnN0IHN5bWIgPSBbRElSRUNUSU9OLlJJR0hULCBESVJFQ1RJT04uQk9UVE9NXS5pbmNsdWRlcyhlbmRfZGlyKVxuLy8gICAgICAgICBzcGFuID0gc3ltYiA/IHNwYW4gOiAtIHNwYW47XG4vLyAgICAgICAgIGNvbnN0IGNwMSA9IGlzVmVydGljYWxTdGFydCA/IFtwMVswXSwgcDFbMV0gKyBzcGFuXSA6IFtwMVswXSArIHNwYW4sIHAxWzFdXTtcbi8vICAgICAgICAgY29uc3QgY3AyID0gaXNWZXJ0aWNhbEVuZCA/IFtlbmRYLCBlbmRZICsgc3Bhbl0gOiBbZW5kWCArIHNwYW4sIGVuZFldO1xuLy8gICAgICAgICByZXR1cm4gWyBcbi8vICAgICAgICAgICAgIC4uLmNwMSxcbi8vICAgICAgICAgICAgIC4uLmNwMixcbi8vICAgICAgICAgICAgIGVuZFgsIGVuZFkgXTtcbi8vICAgICB9XG4vLyAgICAgbGV0IHNwYW5TdGFydCA9IChhbnRpY2xvY2sgPyAtNSA6IDEpICogKGlzVmVydGljYWxTdGFydCA/IChlbmRZIC0gcDFbMV0pIC8gMiA6IChlbmRYIC0gcDFbMF0pIC8gMilcbi8vICAgICBsZXQgc3BhbkVuZCA9IChhbnRpY2xvY2sgPyAtNCA6IDEpICogKGlzVmVydGljYWxFbmQgPyAocDFbMV0gLSBlbmRZKSAvIDIgOiAocDFbMF0gLSBlbmRYKSAvIDIpXG4vLyAgICAgbGV0IHUxID0gc3BhblN0YXJ0IC8gTWF0aC5hYnMoc3BhblN0YXJ0KTtcbi8vICAgICBzcGFuU3RhcnQgPSB1MSAqIE1hdGgubWluKE1hdGguYWJzKHNwYW5TdGFydCksIDUwKTtcbi8vICAgICBsZXQgdTIgPSBzcGFuRW5kIC8gTWF0aC5hYnMoc3BhbkVuZCk7XG4vLyAgICAgc3BhbkVuZCA9IHUyICogTWF0aC5taW4oTWF0aC5hYnMoc3BhbkVuZCksIDUwKTtcbi8vICAgICBjb25zdCBjcDEgPSBpc1ZlcnRpY2FsU3RhcnQgPyBbcDFbMF0sIHAxWzFdICsgc3BhblN0YXJ0XSA6IFtwMVswXSArIHNwYW5TdGFydCwgcDFbMV1dO1xuLy8gICAgIGNvbnN0IGNwMiA9IGlzVmVydGljYWxFbmQgPyBbZW5kWCwgZW5kWSArIHNwYW5FbmRdIDogW2VuZFggKyBzcGFuRW5kLCBlbmRZXTtcbi8vICAgICByZXR1cm4gWyBcbi8vICAgICAgICAgLi4uY3AxLFxuLy8gICAgICAgICAuLi5jcDIsXG4vLyAgICAgICAgIGVuZFgsIGVuZFkgXTtcbi8vIH1cbmZ1bmN0aW9uIF9yZXNvbHZlQ29udHJvbFBvaW50KHAsIGRpciwgc3BhbngsIHNwYW55KXtcbiAgICBpZihkaXIgPT09IERJUkVDVElPTi5UT1Ape1xuICAgICAgICByZXR1cm4gW3BbMF0sIHBbMV0tc3BhbnldXG4gICAgfVxuICAgIGlmKGRpciA9PT0gRElSRUNUSU9OLkJPVFRPTSl7XG4gICAgICAgIHJldHVybiBbcFswXSwgcFsxXStzcGFueV1cbiAgICB9XG4gICAgaWYoZGlyID09PSBESVJFQ1RJT04uTEVGVCl7XG4gICAgICAgIHJldHVybiBbcFswXS1zcGFueCwgcFsxXV1cbiAgICB9XG4gICAgaWYoZGlyID09PSBESVJFQ1RJT04uUklHSFQpe1xuICAgICAgICByZXR1cm4gW3BbMF0rc3BhbngsIHBbMV1dXG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYmV6aWVyUG9pbnRzKHAxLCBwMiwgc3RhcnRfZGlyID0gRElSRUNUSU9OLlRPUCwgZW5kX2RpciA9IERJUkVDVElPTi5UT1AsIG1pblNwYW5YID0gMCwgbWluU3BhblkgPSAwKSB7XG4gICAgY29uc3Qgc3BhbnggPSBNYXRoLm1heChNYXRoLmFicygocDFbMF0gLSBwMlswXSkvMiksIG1pblNwYW5YKTtcbiAgICBjb25zdCBzcGFueSA9IE1hdGgubWF4KE1hdGguYWJzKChwMVsxXSAtIHAyWzFdKS8yKSwgbWluU3BhblkpO1xuICAgIGNvbnN0IGNwMSA9IF9yZXNvbHZlQ29udHJvbFBvaW50KHAxLCBzdGFydF9kaXIsIHNwYW54LCBzcGFueSk7XG4gICAgY29uc3QgY3AyID0gX3Jlc29sdmVDb250cm9sUG9pbnQocDIsIGVuZF9kaXIsIHNwYW54LCBzcGFueSk7XG4gICAgY29uc3QgYXJyb3dzcGFuID0gW0RJUkVDVElPTi5UT1AsIERJUkVDVElPTi5MRUZUXS5pbmNsdWRlcyhlbmRfZGlyKSA/IC01IDogNTtcbiAgICBjb25zdCBpc1ZlcnRpY2FsRW5kID0gW0RJUkVDVElPTi5UT1AsIERJUkVDVElPTi5CT1RUT01dLmluY2x1ZGVzKGVuZF9kaXIpO1xuICAgIGNvbnN0IGVuZFggPSBpc1ZlcnRpY2FsRW5kID8gcDJbMF0gOiBwMlswXSArIGFycm93c3BhbjtcbiAgICBjb25zdCBlbmRZID0gaXNWZXJ0aWNhbEVuZCA/IHAyWzFdICsgYXJyb3dzcGFuIDogcDJbMV07XG4gICAgcmV0dXJuIFsgXG4gICAgICAgIC4uLmNwMSxcbiAgICAgICAgLi4uY3AyLFxuICAgICAgICBlbmRYLCBlbmRZXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJlemllclBvaW50KHQsIFApIHtcbiAgICBjb25zdCBxID0gMS10O1xuICAgIGNvbnN0IHggPSBxKnEqcSpQWzBdICsgMypxKnEqdCpQWzJdICsgMypxKnQqdCpQWzRdICsgdCp0KnQqUFs2XTtcbiAgICBjb25zdCB5ID0gcSpxKnEqUFsxXSArIDMqcSpxKnQqUFszXSArIDMqcSp0KnQqUFs1XSArIHQqdCp0KlBbN107XG4gICAgY29uc3QgdSA9IHEqcSooUFsyXS1QWzBdKSArIDIqdCpxKihQWzRdLVBbMl0pICsgdCp0KihQWzZdLVBbNF0pO1xuICAgIGNvbnN0IHYgPSBxKnEqKFBbM10tUFsxXSkgKyAyKnQqcSooUFs1XS1QWzNdKSArIHQqdCooUFs3XS1QWzVdKTtcbiAgICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKHYsIHUpO1xuICAgIC8vIGNvbnNvbGUubG9nKGFuZ2xlICogMTgwKVxuICAgIC8vIGlmKGFuZ2xlIDwgMCkge1xuICAgIC8vICAgICBhbmdsZSA9IE1hdGguUEkgKyBhbmdsZTtcbiAgICAvLyB9XG4gICAgcmV0dXJuIFt4LCB5LCBhbmdsZV07XG59XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBiZXppZXJQb2ludHMocDEsIHAyLCBzdGFydF92ZWMsIGVuZF92ZWMpIHtcblxuLy8gfVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzdFRvQmV6aWVyU2VnbWVudFNxdWFyZWQocCwgcG9pbnRzKSB7XG4gICAgY29uc3QgYiA9IG5ldyBCZXppZXIoLi4ucG9pbnRzKTtcblxuICAgIGNvbnN0IHBvaW50ID0gYi5wcm9qZWN0KHsgeDogcFswXSwgeTogcFsxXSB9KTtcbiAgICBjb25zdCBkID0gZGlzdDIocCwgWyBwb2ludC54LCBwb2ludC55IF0pO1xuICAgIHJldHVybiBkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmV6aWVyQW5nbGUodCwgc3gsIHN5LCBjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCBleCwgZXkpIHtcbiAgdmFyIGR4ID0gTWF0aC5wb3coMS10LCAyKSooY3AxeC1zeCkgKyAyKnQqKDEtdCkqKGNwMngtY3AxeCkgKyB0ICogdCAqIChleCAtIGNwMngpO1xuICB2YXIgZHkgPSBNYXRoLnBvdygxLXQsIDIpKihjcDF5LXN5KSArIDIqdCooMS10KSooY3AyeS1jcDF5KSArIHQgKiB0ICogKGV5IC0gY3AyeSk7XG4gIHJldHVybiAtTWF0aC5hdGFuMihkeCwgZHkpICsgMC41Kk1hdGguUEk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEluc3RhbmNlSGVpZ2h0KGluc3RhbmNlKSB7XG4gICAgY29uc3QgcmVjdCA9IGluc3RhbmNlLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIC8vIGxldCBtaW5feSA9IEluZmluaXR5O1xuICAgIC8vIGxldCBtYXhfeSA9IC1JbmZpbml0eTtcbiAgICAvLyBsZXQgbWluX3ggPSBJbmZpbml0eTtcbiAgICAvLyBsZXQgbWF4X3ggPSAtSW5maW5pdHk7XG4gICAgLy8gcmVjdC5mb3JFYWNoKHBvaW50ID0+IHtcbiAgICAvLyAgICAgbWF4X3kgPSBNYXRoLm1heChtYXhfeSwgcG9pbnRbMV0pO1xuICAgIC8vICAgICBtaW5feSA9IE1hdGgubWluKG1pbl95LCBwb2ludFsxXSk7XG4gICAgLy8gICAgIG1heF94ID0gTWF0aC5tYXgobWF4X3gsIHBvaW50WzBdKTtcbiAgICAvLyAgICAgbWluX3ggPSBNYXRoLm1pbihtaW5feCwgcG9pbnRbMF0pO1xuICAgIC8vIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGhlaWdodDogcmVjdFszXSAtIHJlY3RbMV0sXG4gICAgICAgIHdpZHRoOiByZWN0WzJdIC0gcmVjdFswXSxcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2x5bGluZVBvaW50cyhwb2ludHMsIHAxLCBwMiwgc3RhcnRfZGlyID0gRElSRUNUSU9OLlRPUCwgZW5kX2RpciA9IERJUkVDVElPTi5UT1AsIG1pblNwYW5YID0gMTAsIG1pblNwYW5ZID0gMTAsIGlzU2VsZikge1xuICAgIGNvbnN0IGRpclNwYW4gPSBNYXRoLmFicyhzdGFydF9kaXIgLSBlbmRfZGlyKTtcbiAgICAvLyBjb25zdCBzcGFueCA9IE1hdGgubWF4KE1hdGguYWJzKChwMVswXSAtIHAyWzBdKS8yKSwgbWluU3BhblgpO1xuICAgIC8vIGNvbnN0IHNwYW55ID0gTWF0aC5tYXgoTWF0aC5hYnMoKHAxWzFdIC0gcDJbMV0pLzIpLCBtaW5TcGFuWSk7XG4gICAgY29uc3QgaXNWZXJ0aWNhbFN0YXJ0ID0gKHN0YXJ0X2RpciA9PT0gRElSRUNUSU9OLlRPUCB8fCBzdGFydF9kaXIgPT09IERJUkVDVElPTi5CT1RUT00pO1xuICAgIHBvaW50cy5sZW5ndGggPSAwO1xuICAgIHN3aXRjaCAoZGlyU3Bhbikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAvLyDpg73mjInlkJHlj7Plpb3kuoZcbiAgICAgICAgICAgIGlmKHN0YXJ0X2RpciA9PT0gRElSRUNUSU9OLlRPUCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLm1pbihwMVsxXSwgcDJbMV0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHlwID0geSAtIG1pblNwYW5ZO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFtwMVswXSwgeXBdKTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChbcDJbMF0sIHlwXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihzdGFydF9kaXIgPT09IERJUkVDVElPTi5CT1RUT00pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5tYXgocDFbMV0sIHAyWzFdKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5cCA9IHkgKyBtaW5TcGFuWTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChbcDFbMF0sIHlwXSk7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goW3AyWzBdLCB5cF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoc3RhcnRfZGlyID09PSBESVJFQ1RJT04uTEVGVCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLm1pbihwMVswXSwgcDJbMF0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHhwID0geCAtIG1pblNwYW5YO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFt4cCwgcDFbMV1dKTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChbeHAsIHAyWzFdXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihzdGFydF9kaXIgPT09IERJUkVDVElPTi5SSUdIVCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLm1heChwMVswXSwgcDJbMF0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHhwID0geCArIG1pblNwYW5YO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFt4cCwgcDFbMV1dKTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChbeHAsIHAyWzFdXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIDM6ICBcbiAgICAgICAgICAgIGlmKGlzU2VsZikge1xuICAgICAgICAgICAgICAgIGlmKCFpc1ZlcnRpY2FsU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goW3AxWzBdICsgbWluU3BhblgsIHAxWzFdXSk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFtwMVswXSArIG1pblNwYW5YLCBwMlsxXSArIG1pblNwYW5ZXSk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFtwMlswXSwgcDJbMV0gKyBtaW5TcGFuWV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFtwMVswXSwgcDFbMV0gKyBtaW5TcGFuWV0pO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChbcDJbMF0gKyBtaW5TcGFuWCwgcDFbMV0gKyBtaW5TcGFuWV0pO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChbcDJbMF0gKyBtaW5TcGFuWCwgcDJbMV1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gaXNWZXJ0aWNhbFN0YXJ0ID8gW3AxWzBdLCBwMlsxXV06IFtwMlswXSwgcDFbMV1dXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNvbnN0IHBtaWRkbGUgPSBbXG4gICAgICAgICAgICAgICAgKHAxWzBdIC0gcDJbMF0pLzIgKyBwMlswXSxcbiAgICAgICAgICAgICAgICAocDFbMV0gLSBwMlsxXSkvMiArIHAyWzFdXG4gICAgICAgICAgICBdOyBcbiAgICAgICAgICAgIGlmKGlzVmVydGljYWxTdGFydCkge1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFtwMVswXSwgcG1pZGRsZVsxXV0pXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goW3AyWzBdLCBwbWlkZGxlWzFdXSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goW3BtaWRkbGVbMF0sIHAxWzFdXSlcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChbcG1pZGRsZVswXSwgcDJbMV1dKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcG9pbnRzLnVuc2hpZnQocDEpO1xuICAgIHBvaW50cy5wdXNoKHAyKTtcbn1cblxuZnVuY3Rpb24gbWludXNWZWMocDEsIHAyKSB7XG4gICAgcmV0dXJuIFtwMVswXSAtIHAyWzBdLCBwMVsxXSAtIHAyWzFdXVxufVxuXG5mdW5jdGlvbiBhYnNWZWModmVjKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh2ZWNbMF0gKiB2ZWNbMF0gKyB2ZWNbMV0gKiB2ZWNbMV0pO1xufVxuXG5mdW5jdGlvbiBzY2FsZVZlYyh2ZWMsIHNjYWxlKSB7XG4gICAgcmV0dXJuIFt2ZWNbMF0gKiBzY2FsZSwgdmVjWzFdICogc2NhbGVdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZVJhZGl1c0Zyb21WZWN0b3IocGJlZm9yZSwgcCwgcG5leHQsIHJhZGl1cykge1xuICAgIGNvbnN0IHZlYzEgPSBtaW51c1ZlYyhwLCBwYmVmb3JlKTtcbiAgICBjb25zdCB2ZWMyID0gbWludXNWZWMocCwgcG5leHQpO1xuICAgIGNvbnN0IGFic1ZlYzEgPSBhYnNWZWModmVjMSk7XG4gICAgY29uc3QgYWJzVmVjMiA9IGFic1ZlYyh2ZWMyKTtcbiAgICBpZighYWJzVmVjMSB8fCAhYWJzVmVjMikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcDE6IG51bGwsXG4gICAgICAgICAgICBwMjogbnVsbCxcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByMSA9IHNjYWxlVmVjKHZlYzEsIHJhZGl1cy9hYnNWZWMxKTtcbiAgICBjb25zdCByMiA9IHNjYWxlVmVjKHZlYzIsIHJhZGl1cy9hYnNWZWMyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwMTogbWludXNWZWMocCwgcjEpLFxuICAgICAgICBwMjogbWludXNWZWMocCwgcjIpLFxuICAgIH1cbn1cbi8vIOefqeW9oumHjeWPoOiuoeeul1xuZXhwb3J0IGZ1bmN0aW9uIGRvT3ZlcmxhcChyZWMxLCByZWMyKSB7XG4gICAgaWYgKHJlYzFbMF0gPT0gcmVjMVsyXSB8fCByZWMxWzFdID09IHJlYzFbM10gfHxcbiAgICAgICAgcmVjMlswXSA9PSByZWMyWzJdIHx8IHJlYzJbMV0gPT0gcmVjMlszXSkge1xuICAgICAgICAvLyB0aGUgbGluZSBjYW5ub3QgaGF2ZSBwb3NpdGl2ZSBvdmVybGFwXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gIShyZWMxWzJdIDw9IHJlYzJbMF0gfHwgICAvLyBsZWZ0XG4gICAgICAgICAgICAgICAgcmVjMVszXSA8PSByZWMyWzFdIHx8ICAgLy8gYm90dG9tXG4gICAgICAgICAgICAgICAgcmVjMVswXSA+PSByZWMyWzJdIHx8ICAgLy8gcmlnaHRcbiAgICAgICAgICAgICAgICByZWMxWzFdID49IHJlYzJbM10pOyAgICAvLyB0b3Bcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUG9seUxpbmVJbnRlcnNlY3Rpb25SZWN0YW5nZShwb2x5bGluZSwgcmVjdCkge1xuICAgIGxldCBwID0gcG9seWxpbmVbMF07XG4gICAgbGV0IGwgPSBwb2x5bGluZS5sZW5ndGg7XG4gICAgbGV0IGkgPSAxO1xuICAgIGNvbnN0IFtsMCwgbDEsIHIwLCByMV0gPSByZWN0O1xuICAgIHdoaWxlIChpIDwgbCkge1xuICAgICAgICBjb25zdCBjcCA9IHBvbHlsaW5lW2ldO1xuICAgICAgICBpZihwWzBdID09PSBjcFswXSkge1xuICAgICAgICAgICAgLy8gdmVydGljYWxcbiAgICAgICAgICAgIGlmKHBbMF0gPCByMCAmJiBwWzBdID4gbDAgXG4gICAgICAgICAgICAgICAgJiYgISgocFsxXSA+IHIxICYmIGNwWzFdID4gcjEpIHx8IChwWzFdIDwgbDEgJiYgY3BbMV0gPCBsMSkpKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhvcml6b250YWxcbiAgICAgICAgICAgIGlmKHBbMV0gPCByMSAmJiBwWzFdID4gbDFcbiAgICAgICAgICAgICAgICAmJiAhKChwWzBdID4gcjAgJiYgY3BbMF0gPiByMCkgfHwgKHBbMF0gPCBsMCAmJiBjcFswXSA8IGwwKSkpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICB9XG4gICAgICAgIHAgPSBjcDtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB0aW1lb3V0ID0gMzAwKXtcbiAgICBsZXQgdGltZXI7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4geyBmdW5jLmNhbGwodGhpcyk7IH0sIHRpbWVvdXQpO1xuICAgIH07XG4gIH1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVCb3VuZGluZ2JveChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM107XG59XG5leHBvcnQgZnVuY3Rpb24gY29weUJvdW5kaW5nYm94KGEsIGIpIHtcbiAgICBhWzBdID0gYlswXTtcbiAgICBhWzFdID0gYlsxXTtcbiAgICBhWzJdID0gYlsyXTtcbiAgICBhWzNdID0gYlszXTtcbn0iLCIvLyBpbXBvcnQgeyBzZXRVbmlxdWVJZCwgZ2V0VW5pcXVlSWQgfSBmcm9tICcuLi91dGlscy9mdW5jdGlvbnMnO1xuLy8gaW1wb3J0IHsgbmV4dERpcmVjdGlvbiB9IGZyb20gJy4uL3V0aWxzL2NvbnN0YW5jZSc7XG4vLyBjb25zdCBtYXJnaW4gPSA1O1xuY29uc3QgaXNoaXRLZXkgPSBTeW1ib2woJ2lzaGl0Jyk7XG5jb25zdCBpc0luVmlld0JveCA9IFN5bWJvbCgnaXNJblZpZXdCb3gnKTtcbi8qKlxuICogQHR5cGVkZWYgSW5zdGFuY2V+Q29uZmlnc1xuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBib3JkZXJXaWR0aCAgICAgIC0g6L6555qE5a695bqmIOm7mOiupOaYryAyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYm9yZGVyQ29sb3IgICAgICAtIOi+ueahhuminOiJsiDpu5jorqQgYmxhY2tcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2xvciAgICAgICAgICAgIC0g5aGr5YWF6aKc6ImyIOm7mOiupCB3aGl0ZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNoYWRvd0NvbG9yICAgICAgLSDpmLTlvbHpopzoibJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzaGFkb3dCbHVyICAgICAgIC0g6Zi05b2x5omp5pWj6IyD5Zu0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gc2hhZG93T2Zmc2V0WCAgICAtIOmYtOW9seWBj+enuyBYXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc2hhZG93T2Zmc2V0WCAgICAtIOmYtOW9seWBj+enuyBZXG4gKi9cblxuLyoqIFxuICog5Zu+5Lit55qE5pyA5bCP5Y2V5YWDXG4gKiBAY29uc3RydWN0b3IgSW5zdGFuY2VcbiAqIEBleHRlbmRzIEV2ZW50VGFyZ2V0XG4gKiBAcGFyYW0ge0luc3RhbmNlfkNvbmZpZ3N9IGNvbmZpZ3MgLSDmnIDlsI/ljZXlhYPnmoTkuIDkupvpgJrnlKjlsZ7mgKfphY3nva5cbiAqL1xuY2xhc3MgSW5zdGFuY2UgZXh0ZW5kcyBFdmVudFRhcmdldHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjb25maWdzKTtcbiAgICAgICAgLy8gdGhpcy5hbmNob3IgPSBjb25maWdzLmFuY2hvciB8fCBbMCwgMF07XG4gICAgICAgIC8vIHRoaXMuYmVsb25ncyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqIEBtZW1iZXIge2Jvb2xlYW59ICAgICAgLSDlhYPntKDlj6/op4Eg6buY6K6kIHRydWUgKi9cbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgLy8gdGhpcy5famZsb3cgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2JlbG9uZ3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXNbaXNoaXRLZXldID0gZmFsc2U7IFxuXG4gICAgICAgIC8qKiBAbWVtYmVyIHtudW1iZXJ9ICAgICAgLSDovrnnmoTlrr3luqYg6buY6K6k5pivIDAgKi9cbiAgICAgICAgdGhpcy5ib3JkZXJXaWR0aCA9ICAgICAgY29uZmlncy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgICAgICAvKiogQG1lbWJlciB7c3RyaW5nfSAgICAgLSDovrnmoYbpopzoibIg6buY6K6kIHRyYW5zcGFyZW50ICovXG4gICAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSAgICAgIGNvbmZpZ3MuYm9yZGVyQ29sb3IgfHwgJ3RyYW5zcGFyZW50JztcbiAgICAgICAgLyoqIEBtZW1iZXIge3N0cmluZ30gICAgIC0g5aGr5YWF6aKc6ImyIOm7mOiupCB0cmFuc3BhcmVudCAqL1xuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9ICBjb25maWdzLmJhY2tncm91bmRDb2xvciB8fCAndHJhbnNwYXJlbnQnO1xuICAgICAgICAvKiogQG1lbWJlciB7c3RyaW5nfSAgICAgLSDpmLTlvbHpopzoibIg56m65bCx5LiN5pi+56S66Zi05b2xICovXG4gICAgICAgIHRoaXMuc2hhZG93Q29sb3IgPSAgICAgIGNvbmZpZ3Muc2hhZG93Q29sb3I7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtzdHJpbmd9ICAgICAtIOmYtOW9seaJqeaVo+iMg+WbtCDpu5jorqQgNSAqL1xuICAgICAgICB0aGlzLnNoYWRvd0JsdXIgID0gICAgICBjb25maWdzLnNoYWRvd0JsdXIgfHwgNTtcbiAgICAgICAgLyoqIEBtZW1iZXIge3N0cmluZ30gICAgIC0g6Zi05b2x5YGP56e7IFggKi9cbiAgICAgICAgdGhpcy5zaGFkb3dPZmZzZXRYID0gICAgY29uZmlncy5zaGFkb3dPZmZzZXRYIHx8IDA7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtzdHJpbmd9ICAgICAtIOmYtOW9seWBj+enuyBZICovXG4gICAgICAgIHRoaXMuc2hhZG93T2Zmc2V0WSA9ICAgIGNvbmZpZ3Muc2hhZG93T2Zmc2V0WSB8fCAwO1xuICAgICAgICAvKiogQG1lbWJlciB7bnVtYmVyfSAgICAgLSDpgI/mmI7luqYgKi9cbiAgICAgICAgdGhpcy5vcGFjaXR5ICA9ICAgICAgICAgY29uZmlncy5vcGFjaXR5IHx8IDFcblxuICAgICAgICB0aGlzLl9ib3VuZGluZ3JlY3QgPSBbMCwwLDAsMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IC0g5b2T5YmN5Y2V5YWD6YCJ5Lit54q25oCBXG4gICAgICovXG4gICAgZ2V0IF9pc1RhcmdldGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT09ICh0aGlzLl9qZmxvdy5fdGFyZ2V0Lmluc3RhbmNlIHx8IHRoaXMuX2pmbG93Ll90YXJnZXQubGluayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IC0g5b2T5YmN5Y2V5YWD56e75Yqo54q25oCBXG4gICAgICovXG4gICAgZ2V0IF9pc01vdmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT09IHRoaXMuX2pmbG93Ll9nZXRNb3ZpbmdUYXJnZXQoKSAmJiB0aGlzLl9qZmxvdy5fdGFyZ2V0LnN0YXR1cy5tb3ZpbmdTdGF0ZTsgLy8g56e75Yqo5LqG5LmL5ZCO5omN6IO96KKr5b2T5YGa56e75Yqo54q25oCBXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59ICAtIOW9k+WJjeWNleWFg+eisOaSnuajgOa1i+eKtuaAgVxuICAgICAqL1xuICAgIGdldCBfaXNIaXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2lzaGl0S2V5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7SkZsb3d9ICAtIGNhbnZhc+S4iiBqZmxvdyDlrp7kvZNcbiAgICAgKi9cbiAgICBnZXQgX2pmbG93KCkge1xuICAgICAgICBpZih0aGlzLl9qZmxvd1Jvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9qZmxvd1Jvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIXRoaXMuX2JlbG9uZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYmVsb25ncy51bmlxdWVOYW1lID09PSAnamZsb3cnID8gdGhpcy5fYmVsb25ncyA6IHRoaXMuX2JlbG9uZ3MuX2pmbG93O1xuICAgIH1cblxuICAgIHNldCBfaXNIaXQoaXNoaXQpIHtcbiAgICAgICAgaWYodGhpc1tpc2hpdEtleV0gIT09IGlzaGl0KSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOm8oOagh+enu+WFpeS6i+S7tlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBldmVudCBJbnN0YW5jZSNtb3VzZWVudGVyXG4gICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtJbnN0YW5jZX0gaW5zdGFuY2UgICAgICAtIOenu+WFpeeahOWvueixoSBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDpvKDmoIfnp7vlh7rkuovku7ZcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXZlbnQgSW5zdGFuY2UjbW91c2VsZWF2ZVxuICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SW5zdGFuY2V9IGluc3RhbmNlICAgICAgLSDnp7vlhaXnmoTlr7nosaEgXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoaXNoaXQgPyAnbW91c2VlbnRlcic6ICdtb3VzZWxlYXZlJyAsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLl9qZmxvd1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW2lzaGl0S2V5XSA9IGlzaGl0OyAvLyB2YWxpZGF0aW9uIGNvdWxkIGJlIGNoZWNrZWQgaGVyZSBzdWNoIGFzIG9ubHkgYWxsb3dpbmcgbm9uIG51bWVyaWNhbCB2YWx1ZXNcbiAgICB9XG5cbiAgICBnZXQgaXNJblZpZXdCb3goKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2lzSW5WaWV3Qm94XTtcbiAgICB9XG5cbiAgICBzZXQgX2lzSW5WaWV3Qm94KHZhbCkge1xuICAgICAgICBjb25zdCBvbGR2YWwgPSB0aGlzW2lzSW5WaWV3Qm94XTtcbiAgICAgICAgaWYodmFsICE9PSBvbGR2YWwpIHtcbiAgICAgICAgICAgIGlmKHZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25FbnRlclZpZXdib3goKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkxlYXZlVmlld2JveCgpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgfSAgICBcbiAgICAgICAgdGhpc1tpc0luVmlld0JveF0gPSB2YWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5b2T6IqC54K556a75byA5Y+v6KeG5Yy65Z+f55qE5Zue6LCDXG4gICAgICovXG4gICAgb25FbnRlclZpZXdib3goKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlvZPoioLngrnnprvlvIDlj6/op4bljLrln5/nmoTlm57osINcbiAgICAgKi9cbiAgICBvbkxlYXZlVmlld2JveCgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaUueWPmOW9k+WJjemFjee9rlxuICAgICAqIEBwYXJhbSB7Q29uZmlnc30gY29uZmlncyAtIFRoZSBzdHJpbmcgY29udGFpbmluZyB0d28gY29tbWEtc2VwYXJhdGVkIG51bWJlcnMuXG4gICAgICovXG4gICAgc2V0Q29uZmlnKGNvbmZpZ3MpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoY29uZmlncykuZm9yRWFjaChrID0+IHtcbiAgICAgICAgICAgIGlmKGNvbmZpZ3Nba10gIT09IHVuZGVmaW5lZCAmJiBjb25maWdzW2tdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trXSA9IGNvbmZpZ3Nba11cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG4gICAgLyoqXG4gICAgICog57uY5Yi25Y2V5YWDXG4gICAgICogQHBhcmFtIHtDb250ZXh0MmR9IGN0eCBcbiAgICAgKi9cbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIHRocm93ICdyZXF1aXJlIHJlbmRlciBpbXBsZW1lbnQnXG4gICAgfVxuICAgIC8qKlxuICAgICAqIOWIpOaWreW9k+WJjeWNleWFg+aYr+WQpuiiq+WRveS4rVxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHBvaW50IFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNIaXQocG9pbnQpIHtcbiAgICAgICAgdGhyb3cgJ3JlcXVpcmUgaXNIaXQgaW1wbGVtZW50J1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDorqHnrpflvZPliY3nmoTmnIDlpKflpJbmjqXnn6nlvaLnmoRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJbXX0gW2xlZnR4LCBsZWZ0eSwgcmlnaHR4LCByaWdodHldXG4gICAgICovXG4gICAgZ2V0Qm91bmRpbmdSZWN0KCkge1xuICAgICAgICB0aHJvdyAncmVxdWlyZSBnZXRCb3VuZGluZ1JlY3QgaW1wbGVtZW50J1xuICAgIH1cbiAgICBjYWxjdWxhdGVJbnRlcnNlY3Rpb24oKSB7XG4gICAgICAgIHRocm93ICdyZXF1aXJlIGNhbGN1bGF0ZUludGVyc2VjdGlvbiBpbXBsZW1lbnQnXG4gICAgfVxuICAgIC8qKlxuICAgICAqIOiuoeeul+W9k+WJjei/nue6v+aOpeWFpeeCueeahOS9jee9rlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gaW50ZXJzZWN0aW9uIOS6pOWPieeCuVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gaW50ZXJzZWN0aW9uW0RJUkVDVElPTi5UT1BdIOS4ilxuICAgICAqIEByZXR1cm4ge251bWJlcn0gaW50ZXJzZWN0aW9uW0RJUkVDVElPTi5CT1RUT01dIOS4i1xuICAgICAqIEByZXR1cm4ge251bWJlcn0gaW50ZXJzZWN0aW9uW0RJUkVDVElPTi5MRUZUXSDkuIpcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IGludGVyc2VjdGlvbltESVJFQ1RJT04uUklHSFRdIOWPs1xuICAgICAqL1xuICAgIGdldEludGVyc2VjdGlvbnNJbkZvdXJEaW1lbnNpb24oKSB7XG4gICAgICAgIHRocm93ICdyZXF1aXJlIGdldEludGVyc2VjdGlvbnNJbkZvdXJEaW1lbnNpb24gaW1wbGVtZW50J1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICog6I635Y+W5b2T5YmN5omA5Zyo5bGC57qn55qE5Z2Q5qCHXG4gICAgICogQHJldHVybiB7TnVtYmVyW119IOWdkOagh1xuICAgICAqL1xuICAgIGdldENlbnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5jaG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDojrflj5blrr3pq5hcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGRlbWVuc2lvbiDlrr3pq5hcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IGRlbWVuc2lvbi53aWR0aCDlrr1cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IGRlbWVuc2lvbi5oZWlnaHQg6auYXG4gICAgICovXG4gICAgZ2V0Qm91bmRpbmdEaW1lbnNpb24oKSB7XG4gICAgICAgIGNvbnN0IHJlY3QgPSBpbnN0YW5jZS5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgbGV0IG1pbl95ID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBtYXhfeSA9IC1JbmZpbml0eTtcbiAgICAgICAgbGV0IG1pbl94ID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBtYXhfeCA9IC1JbmZpbml0eTtcbiAgICAgICAgcmVjdC5mb3JFYWNoKHBvaW50ID0+IHtcbiAgICAgICAgICAgIG1heF95ID0gTWF0aC5tYXgobWF4X3ksIHBvaW50WzFdKTtcbiAgICAgICAgICAgIG1pbl95ID0gTWF0aC5taW4obWluX3ksIHBvaW50WzFdKTtcbiAgICAgICAgICAgIG1heF94ID0gTWF0aC5tYXgobWF4X3gsIHBvaW50WzBdKTtcbiAgICAgICAgICAgIG1pbl94ID0gTWF0aC5taW4obWluX3gsIHBvaW50WzBdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWlnaHQ6IG1heF95IC0gbWluX3ksXG4gICAgICAgICAgICB3aWR0aDogbWF4X3ggLSBtaW5feCxcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiDlhpLms6Hkuovku7ZcbiAgICAgKiBAcGFyYW0ge0pGbG93RXZlbnR9IGN1c3RvbUV2ZW50IOiHquWumuS5ieS6i+S7tlxuICAgICAqL1xuICAgIGJ1YmJsZUV2ZW50KGN1c3RvbUV2ZW50KXtcbiAgICAgICAgY3VzdG9tRXZlbnQuZGV0YWlsLmN1cnJlbnRUYXJnZXQgPSB0aGlzO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoY3VzdG9tRXZlbnQpO1xuICAgICAgICBpZihjdXN0b21FdmVudC5kZXRhaWwuYnViYmxlcyl7XG4gICAgICAgICAgICBpZih0aGlzLl9iZWxvbmdzLmJ1YmJsZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmVsb25ncy5idWJibGVFdmVudChjdXN0b21FdmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JlbG9uZ3MuZGlzcGF0Y2hFdmVudChjdXN0b21FdmVudCk7IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICog5Y+N566X5Zue6aG16Z2i55qE5YOP57Sg5Z2Q5qCHXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJbXX0g5LiW55WM5Z2Q5qCHXG4gICAgICovXG4gICAgY2FsY3VsYXRlVG9SZWFsV29ybGQocG9pbnQpIHtcbiAgICAgICAgaWYodGhpcy5fYmVsb25ncyAmJiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvUmVhbFdvcmxkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb1JlYWxXb3JsZChwb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxjdWxhdGVUb1JlYWxXb3JsZFdpdGhQb2ludGVyKG91dHBvaW50LCBpbnBvaW50KSB7XG4gICAgICAgIGlmKHRoaXMuX2JlbG9uZ3MgJiYgdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb1JlYWxXb3JsZFdpdGhQb2ludGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvUmVhbFdvcmxkV2l0aFBvaW50ZXIob3V0cG9pbnQsIGlucG9pbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlVG9SZWFsV29ybGRXaXRoU2NhbGFyKGxlbmd0aCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9qZmxvdy5zY2FsZSAqIGxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDku47lvZPliY3luIPlsYDkuK3liKDpmaTomZrmi5/luIPlsYDoioLngrlcbiAgICAgKi9cbiAgICAvLyByZW1vdmVGcm9tTGF5b3V0U291cmNlKCkge1xuICAgIC8vICAgICBpZih0aGlzLl9sYXlvdXROb2RlKSB7XG4gICAgLy8gICAgICAgICB0aGlzLl9sYXlvdXROb2RlLnJlbW92ZSgpO1xuICAgIC8vICAgICB9XG4gICAgLy8gfVxuXG4gICAgcmVjYWxjdWxhdGVVcCgpIHtcbiAgICAgICAgaWYodGhpcy5fYmVsb25ncykge1xuICAgICAgICAgICAgdGhpcy5fYmVsb25ncy5yZWNhbGN1bGF0ZVVwKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICAvLyB0aGlzLl9iZWxvbmdzID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEluc3RhbmNlOyIsImNvbnN0IHF1ZXVlID0gW107XG5jb25zdCBjbGVhclF1ZXVlID0gW107XG5sZXQgcXVldWVTZXQgPSBuZXcgV2Vha1NldCgpO1xuXG5jb25zdCBjaGVja1dvcmsgPSAodGFyZ2V0KSA9PiB7XG4gICAgcmV0dXJuIHF1ZXVlU2V0Lmhhcyh0YXJnZXQpO1xufSAgXG5cbmNvbnN0IGdldFN0YWNrUGF0aCA9IChub2RlKSA9PiB7XG4gICAgbGV0IHQgPSBub2RlO1xuICAgIGxldCBleHAgPSAxO1xuICAgIGxldCBwID0gJyc7XG4gICAgd2hpbGUodCAmJiB0Ll9iZWxvbmdzKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHQuX2JlbG9uZ3MuX3N0YWNrLmZpbmRJbmRleChuID0+IG4gPT09IHQpO1xuICAgICAgICBwID0gaWR4ICsgKHAgJiYgKCcuJyArIHApKVxuICAgICAgICB0ID0gdC5fYmVsb25ncztcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5cbmNvbnN0IHNvcnRCeVBhdGggPSAoKSA9PiB7XG4gICAgY29uc3QgbWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICBxdWV1ZS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIGxldCBhcGF0aCA9IG1hcC5nZXQoYSk7XG4gICAgICAgIGlmKGFwYXRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFwYXRoID0gZ2V0U3RhY2tQYXRoKGEpO1xuICAgICAgICAgICAgbWFwLnNldChhLCBhcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJwYXRoID0gbWFwLmdldChiKTtcbiAgICAgICAgaWYoYnBhdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYnBhdGggPSBnZXRTdGFja1BhdGgoYik7XG4gICAgICAgICAgICBtYXAuc2V0KGIsIGJwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBfYSA9IGFwYXRoLnNwbGl0KCcuJylcbiAgICAgICAgY29uc3QgX2IgPSBicGF0aC5zcGxpdCgnLicpXG4gICAgICAgIGlmKF9hLmxlbmd0aCA8IF9iLmxlbmd0aCkgeyBcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IFxuICAgICAgICBpZihfYS5sZW5ndGggPiBfYi5sZW5ndGgpIHsgXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gXG4gICAgICAgIGZvcihsZXQgaT0wO2k8X2EubGVuZ3RoO2krKykge1xuICAgICAgICAgICAgY29uc3QgX3AgPSArX2FbaV07XG4gICAgICAgICAgICBjb25zdCBfcSA9ICtfYltpXTtcbiAgICAgICAgICAgIGlmKF9wIDwgX3EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKF9wID4gX3EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSlcbn1cblxuXG5leHBvcnQgY29uc3QgYWRkQ2xlYXJTb3VyY2VXb3JrID0gKGpmbG93LCBzb3VyY2UpID0+IHtcbiAgICBjbGVhclF1ZXVlLnB1c2goW2pmbG93LCBzb3VyY2VdKTtcbn1cblxuLy8gd29yayBpcyBzeW5jIGZ1bmN0aW9uISFcbmV4cG9ydCBjb25zdCBhZGRSZWZsb3dXb3JrID0gKHRhcmdldCwgcGFyZW50KSA9PiB7XG4gICAgXG4gICAgaWYodGFyZ2V0LmRvUmVjYWxjdWxhdGUpIHtcbiAgICAgICAgaWYoIXF1ZXVlU2V0Lmhhcyh0YXJnZXQpKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKHRhcmdldCk7XG4gICAgICAgICAgICBxdWV1ZVNldC5hZGQodGFyZ2V0KVxuICAgICAgICB9XG4gICAgfSBcbiAgICBpZihwYXJlbnQgJiYgcGFyZW50LmRvUmVjYWxjdWxhdGUgJiYgIXF1ZXVlU2V0LmhhcyhwYXJlbnQpKSB7XG4gICAgICAgIHF1ZXVlLnB1c2gocGFyZW50KTtcbiAgICAgICAgcXVldWVTZXQuYWRkKHBhcmVudClcbiAgICB9XG4gICBcbiAgICAvLyBpZih0YXJnZXQuZG9SZWNhbGN1bGF0ZSkge1xuICAgIC8vICAgICBpZighY2hlY2tXb3JrKHRhcmdldCkpIHtcbiAgICAvLyAgICAgICAgIHF1ZXVlLnB1c2godGFyZ2V0KTtcbiAgICAvLyAgICAgICAgIHF1ZXVlU2V0LmFkZCh0YXJnZXQpO1xuICAgIC8vICAgICB9XG4gICAgLy8gfSAgXG4gICAgLy8gaWYocGFyZW50KSB7XG4gICAgLy8gICAgIGlmKGNoZWNrV29yayhwYXJlbnQpKSB7XG4gICAgLy8gICAgICAgICBjb25zdCBpZHggPSBxdWV1ZS5maW5kSW5kZXgocCA9PiBwID09PSBwYXJlbnQpO1xuICAgIC8vICAgICAgICAgcXVldWUuc3BsaWNlKGlkeCwgMSk7XG4gICAgLy8gICAgICAgICBxdWV1ZS5wdXNoKHBhcmVudCk7XG4gICAgLy8gICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgICBxdWV1ZS5wdXNoKHBhcmVudCk7XG4gICAgLy8gICAgICAgICBxdWV1ZVNldC5hZGQocGFyZW50KTtcbiAgICAvLyAgICAgfVxuXG4gICAgLy8gfVxuICAgIGZsdXNoKCk7XG59XG5sZXQgaW5GbHVzaCA9IGZhbHNlO1xuY29uc3QgZmx1c2ggPSAoKSA9PiB7XG4gICAgaWYoaW5GbHVzaCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGluRmx1c2ggPSB0cnVlO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJvb3RzID0gbmV3IFNldCgpO1xuICAgICAgICBzb3J0QnlQYXRoKCk7XG4gICAgICAgIHdoaWxlKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmKHRhcmdldC5kb1JlY2FsY3VsYXRlKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmRvUmVjYWxjdWxhdGUoKTtcbiAgICAgICAgICAgICAgICByb290cy5hZGQodGFyZ2V0Ll9qZmxvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0YXJnZXQud2lkdGgsIHRhcmdldC5oZWlnaHQpXG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUoY2xlYXJRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IFtqZmxvdywgc291cmNlXSA9IGNsZWFyUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmKCFqZmxvdy5nZXRSZW5kZXJOb2RlQnlTb3VyY2Uoc291cmNlKSl7XG4gICAgICAgICAgICAgICAgamZsb3cuY2xlYXJTb3VyY2Uoc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLS1kaXJ0eS0tLWZsdXNoLS0tLS0nKVxuICAgICAgICBxdWV1ZVNldCA9IG5ldyBXZWFrU2V0KCk7XG4gICAgICAgIGluRmx1c2ggPSBmYWxzZVxuICAgICAgICBBcnJheS5mcm9tKHJvb3RzKS5mb3JFYWNoKGpmbG93ID0+IHtcbiAgICAgICAgICAgIGpmbG93Ll9yZW5kZXIoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59IiwiaW1wb3J0IEluc3RhbmNlIGZyb20gJy4vaW5zdGFuY2UnO1xuaW1wb3J0IHsgZG9PdmVybGFwIH0gZnJvbSAnLi4vdXRpbHMvZnVuY3Rpb25zJztcbmltcG9ydCB7IGFkZFJlZmxvd1dvcmsgfSBmcm9tICcuLi9kaXJ0eS13b3JrL2RpcnR5LXdvcmsnXG5cbi8qKlxuICog57ud5a+55a6a5L2NIOmFjee9ru+8jCDnu53lr7nlrprkvY3kuI3lj5fluIPlsYDlvbHlk43vvIznm7jlr7nkuo7lvZPliY3nu4TmnaXlrprkvY1cbiAqIEB0eXBlZGVmIHtvYmplY3R9IE5vZGV+QWJzb2x1dGVQb3NpdGlvbiBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0b3AgICAgICAgLSDkuIrot53nprtcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBib3R0b20gICAgLSDkuIvot53nprtcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByaWdodCAgICAgLSDlj7Pot53nprtcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZWZ0ICAgICAgLSDlt6bot53nprtcbiAqL1xuLyoqXG4gKiBOb2RlIOmFjee9rlxuICogQHR5cGVkZWYge0luc3RhbmNlfkNvbmZpZ3N9IE5vZGV+Q29uZmlncyBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IGFuY2hvciAtIOWdkOagh1xuICogQHByb3BlcnR5IHtOb2RlfkFic29sdXRlUG9zaXRpb259IGFic29sdXRlUG9zaXRpb24gLSDnu53lr7nlrprkvY3kvY3nva5cbiAqL1xuLyoqXG4gKiDoioLngrnln7rnsbtcbiAqIEBjb25zdHJ1Y3RvciBOb2RlXG4gKiBAZXh0ZW5kcyBJbnN0YW5jZVxuICogQHBhcmFtIHtOb2RlfkNvbmZpZ3N9IGNvbmZpZ3MgLSDoioLngrnphY3nva5cbiAqL1xuY2xhc3MgTm9kZSBleHRlbmRzIEluc3RhbmNlIHtcbiAgICBJTlNUQU5DRV9UWVBFID0gJ05PREUnXG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICBpZighdGhpcy5fYmVsb25ncykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhY2sgPSB0aGlzLl9iZWxvbmdzLl9zdGFja1xuICAgICAgICBjb25zdCBpZHggPSBzdGFjay5maW5kSW5kZXgocyA9PiBzID09PSB0aGlzKTtcbiAgICAgICAgaWYoaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrW2lkeCsxXTtcbiAgICAgICAgfSBcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoY29uZmlncyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3MpO1xuICAgICAgICB0aGlzLl9yYXdDb25maWdzID0gY29uZmlncztcbiAgICAgICAgLy8gZm9yIGxheW91dFxuICAgICAgICAvKiogQG1lbWJlciB7bnVtYmVyW119ICovXG4gICAgICAgIHRoaXMuYW5jaG9yID0gICAgICAgICAgIGNvbmZpZ3MuYW5jaG9yIHx8IFswLCAwXTtcbiAgICAgICAgLyoqIEBtZW1iZXIge05vZGV+QWJzb2x1dGVQb3NpdGlvbn0gKi9cbiAgICAgICAgdGhpcy5hYnNvbHV0ZVBvc2l0aW9uID0gY29uZmlncy5hYnNvbHV0ZVBvc2l0aW9uO1xuICAgIH1cblxuICAgIHNldENvbmZpZyhjb25maWdzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGNvbmZpZ3MpLmZvckVhY2goayA9PiB7XG4gICAgICAgICAgICBpZihjb25maWdzW2tdICE9PSB1bmRlZmluZWQgJiYgY29uZmlnc1trXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXNba10gPSBjb25maWdzW2tdXG4gICAgICAgICAgICAgICAgdGhpcy5fcmF3Q29uZmlnc1trXSA9IGNvbmZpZ3Nba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRBbmNob3JYKHgpIHtcbiAgICAgICAgdGhpcy5hbmNob3JbMF0gPSB4O1xuICAgIH1cbiAgICBzZXRBbmNob3JZKHkpIHtcbiAgICAgICAgdGhpcy5hbmNob3JbMV0gPSB5O1xuICAgIH1cbiAgICBzZXRBbmNob3IoeCwgeSkge1xuICAgICAgICB0aGlzLmFuY2hvclswXSA9IHg7XG4gICAgICAgIHRoaXMuYW5jaG9yWzFdID0geTtcbiAgICB9XG5cbiAgICBiZWZvcmVSZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBkb092ZXJsYXAodGhpcy5fYmVsb25ncy5fZ2V0Vmlld0JveCgpLCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKVxuICAgIH1cblxuICAgIGFkZFJlZmxvd1dvcmsoKSB7XG4gICAgICAgIGFkZFJlZmxvd1dvcmsodGhpcywgdGhpcy5fYmVsb25ncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5YWL6ZqG5b2T5YmN6IqC54K5LlxuICAgICAqIEByZXR1cm4ge05vZGV9IOW9k+WJjeiKgueCueeahOWJr+acrFxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBDID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgY29uc3QgdCA9IG5ldyBDKHRoaXMuX3Jhd0NvbmZpZ3MpO1xuICAgICAgICB0LnZpc2libGUgPSB0aGlzLnZpc2libGU7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTm9kZTsiLCJpbXBvcnQgTm9kZSBmcm9tICcuL25vZGUnO1xuaW1wb3J0IHsgRElSRUNUSU9OIH0gZnJvbSAnLi4vdXRpbHMvY29uc3RhbmNlJztcblxuY2xhc3MgR2hvc3ROb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlncykge1xuICAgICAgICBzdXBlcihjb25maWdzKTtcbiAgICB9XG5cbiAgICByZW5kZXIoY3R4KSB7fVxuXG4gICAgaXNIaXQocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjYWxjdWxhdGVJbnRlcnNlY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5jaG9yO1xuICAgIH1cblxuICAgIGdldEJvdW5kaW5nUmVjdCgpIHtcbiAgICAgICAgY29uc3QgW3gyLCB5Ml0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgcmV0dXJuIFt4MiwgeTIsIHgyLCB5Ml1cbiAgICB9XG5cbiAgICBnZXRCb3VuZGluZ0RpbWVuc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiAwLCBoZWlnaHQ6IDBcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEludGVyc2VjdGlvbnNJbkZvdXJEaW1lbnNpb24oKSB7XG4gICAgICAgIGNvbnN0IFt4MiwgeTJdID0gdGhpcy5hbmNob3I7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbRElSRUNUSU9OLlJJR0hUXTogIFt4MisxLCB5Ml0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLkxFRlRdOiAgIFt4Mi0xLCB5Ml0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLkJPVFRPTV06IFt4MiwgeTIrMV0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLlRPUF06ICAgIFt4MiwgeTItMV0sXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEdob3N0Tm9kZTsiLCJmdW5jdGlvbiBnZXRNYXBPYmplY3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGF5b3V0Tm9kZTogdW5kZWZpbmVkLFxuICAgICAgICBqZmxvd05vZGU6IHVuZGVmaW5lZCxcbiAgICAgICAgamZsb3dsaW5rczogW10sXG4gICAgICAgIGpmbG93RnJvbUxpbmtzOiBuZXcgU2V0KCksXG4gICAgICAgIGpmbG93VG9MaW5rczogbmV3IFNldCgpLFxuICAgIH1cbn1cbmNsYXNzIE5vZGVXZWFrTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIGdldChzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5nZXQoc291cmNlKTtcbiAgICB9XG5cbiAgICBzZXQoc291cmNlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGdldE1hcE9iamVjdCgpO1xuICAgICAgICB0aGlzLl9tYXAuc2V0KHNvdXJjZSwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBoYXMoc291cmNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKHNvdXJjZSk7XG4gICAgfVxuXG4gICAgZGVsZXRlKHNvdXJjZSkge1xuICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKHNvdXJjZSk7XG4gICAgfVxuXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX21hcC5jbGVhcigpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IE5vZGVXZWFrTWFwTWl4aW4gPSB7XG4gICAgaW5pdE5vZGVXZWFrTWFwKCkge1xuICAgICAgICB0aGlzLnNvdXJjZV9MYXlvdXRfUmVuZGVyX05vZGVNYXAgPSBuZXcgTm9kZVdlYWtNYXAoKTtcbiAgICB9LFxuICAgIGdldFJlbmRlck5vZGVCeVNvdXJjZShzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgbWFwcGluZyA9IHRoaXMuc291cmNlX0xheW91dF9SZW5kZXJfTm9kZU1hcC5nZXQoc291cmNlKTtcbiAgICAgICAgaWYobWFwcGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG1hcHBpbmcuamZsb3dOb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSwgXG4gICAgcmVtb3ZlUmVuZGVyTm9kZUJ5U291cmNlKHNvdXJjZSkge1xuICAgICAgICBjb25zdCBtYXAgPSB0aGlzLnNvdXJjZV9MYXlvdXRfUmVuZGVyX05vZGVNYXA7XG4gICAgICAgIGxldCBvYmogPSBtYXAuZ2V0KHNvdXJjZSk7XG4gICAgICAgIGlmKG9iaikge1xuICAgICAgICAgICAgb2JqLmpmbG93Tm9kZSA9IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICAgIGlmKG9iai5qZmxvd0Zyb21MaW5rcy5zaXplID09PSAwICYmIG9iai5qZmxvd1RvTGlua3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VfTGF5b3V0X1JlbmRlcl9Ob2RlTWFwLmRlbGV0ZShzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXRMYXlvdXROb2RlQnlTb3VyY2Uoc291cmNlKSB7XG4gICAgICAgIGNvbnN0IG1hcHBpbmcgPSB0aGlzLnNvdXJjZV9MYXlvdXRfUmVuZGVyX05vZGVNYXAuZ2V0KHNvdXJjZSk7XG4gICAgICAgIGlmKG1hcHBpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXBwaW5nLmxheW91dE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIGdldFNvdXJjZVJlbmRlck1ldGEoc291cmNlKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IHRoaXMuc291cmNlX0xheW91dF9SZW5kZXJfTm9kZU1hcDtcbiAgICAgICAgY29uc3QgX21ldGEgPSBtYXAuZ2V0KHNvdXJjZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5fbWV0YSxcbiAgICAgICAgICAgIGpmbG93RnJvbUxpbmtzOiBBcnJheS5mcm9tKF9tZXRhLmpmbG93RnJvbUxpbmtzKSxcbiAgICAgICAgICAgIGpmbG93VG9MaW5rczogQXJyYXkuZnJvbShfbWV0YS5qZmxvd1RvTGlua3MpLFxuICAgICAgICB9XG4gICAgfSxcbiAgICBfZ2V0TWFwKHNvdXJjZSkge1xuICAgICAgICBpZighc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXAgPSB0aGlzLnNvdXJjZV9MYXlvdXRfUmVuZGVyX05vZGVNYXA7XG4gICAgICAgIGxldCBvYmo7XG4gICAgICAgIGlmKG1hcC5oYXMoc291cmNlKSkge1xuICAgICAgICAgICAgb2JqID0gbWFwLmdldChzb3VyY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqID0gbWFwLnNldChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmpcbiAgICB9LFxuICAgIHNldExheW91dE5vZGVCeVNvdXJjZShzb3VyY2UsIGxheW91dE5vZGUpIHtcbiAgICAgICAgbGV0IG9iaiA9IHRoaXMuX2dldE1hcChzb3VyY2UpO1xuICAgICAgICBvYmoubGF5b3V0Tm9kZSA9IGxheW91dE5vZGU7XG4gICAgfSxcbiAgICBzZXRSZW5kZXJOb2RlQnlTb3VyY2Uoc291cmNlLCBpbnN0YW5jZSkge1xuICAgICAgICBsZXQgb2JqID0gdGhpcy5fZ2V0TWFwKHNvdXJjZSk7XG4gICAgICAgIG9iai5qZmxvd05vZGUgPSBpbnN0YW5jZTtcblxuICAgICAgICBpZihvYmouamZsb3dGcm9tTGlua3Muc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIG9iai5qZmxvd0Zyb21MaW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xuICAgICAgICAgICAgICAgIGxpbmsuZnJvbSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYob2JqLmpmbG93VG9MaW5rcy5zaXplID4gMCkge1xuICAgICAgICAgICAgb2JqLmpmbG93VG9MaW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xuICAgICAgICAgICAgICAgIGxpbmsudG89IGluc3RhbmNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGFkZExpbmtOb2RlQnlTb3VyY2Uoc291cmNlRnJvbSwgc291cmNlVG8sIGxpbmspIHtcbiAgICAgICAgbGV0IG9iaiA9IHRoaXMuX2dldE1hcChzb3VyY2VGcm9tKTtcbiAgICAgICAgb2JqLmpmbG93RnJvbUxpbmtzLmFkZChsaW5rKTtcblxuICAgICAgICBvYmogPSB0aGlzLl9nZXRNYXAoc291cmNlVG8pO1xuICAgICAgICBvYmouamZsb3dUb0xpbmtzLmFkZChsaW5rKTtcbiAgICB9LFxuICAgIHJlbW92ZUxpbmtOb2RlQnlTb3VyY2Uoc291cmNlRnJvbSwgc291cmNlVG8sIGxpbmspIHtcbiAgICAgICAgY29uc3QgbWFwID0gdGhpcy5zb3VyY2VfTGF5b3V0X1JlbmRlcl9Ob2RlTWFwO1xuICAgICAgICBsZXQgb2JqID0gbWFwLmdldChzb3VyY2VGcm9tKTtcbiAgICAgICAgaWYob2JqKSB7XG4gICAgICAgICAgICBvYmouamZsb3dGcm9tTGlua3MuZGVsZXRlKGxpbmspO1xuICAgICAgICAgICAgaWYob2JqLmpmbG93RnJvbUxpbmtzLnNpemUgPT09IDAgJiYgb2JqLmpmbG93VG9MaW5rcy5zaXplID09PSAwICYmICFvYmouamZsb3dOb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VfTGF5b3V0X1JlbmRlcl9Ob2RlTWFwLmRlbGV0ZShzb3VyY2VGcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvYmogPSBtYXAuZ2V0KHNvdXJjZVRvKTtcbiAgICAgICAgaWYob2JqKSB7XG4gICAgICAgICAgICBvYmouamZsb3dUb0xpbmtzLmRlbGV0ZShsaW5rKTtcbiAgICAgICAgICAgIGlmKG9iai5qZmxvd0Zyb21MaW5rcy5zaXplID09PSAwICYmIG9iai5qZmxvd1RvTGlua3Muc2l6ZSA9PT0gMCAmJiAhb2JqLmpmbG93Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlX0xheW91dF9SZW5kZXJfTm9kZU1hcC5kZWxldGUoc291cmNlVG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjaGFuZ2VMaW5rTm9kZUJ5U291cmNlKHByZXZTb3VyY2UsIG5leHRTb3VyY2UsIGxpbmssIGRpcikge1xuICAgICAgICBsZXQgb2JqID0gdGhpcy5fZ2V0TWFwKHByZXZTb3VyY2UpO1xuICAgICAgICBpZihvYmopIHtcbiAgICAgICAgICAgIGlmKGRpciA9PT0gJ2Zyb20nKSB7XG4gICAgICAgICAgICAgICAgb2JqLmpmbG93RnJvbUxpbmtzLmRlbGV0ZShsaW5rKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZGlyID09PSAndG8nKSB7XG4gICAgICAgICAgICAgICAgb2JqLmpmbG93VG9MaW5rcy5kZWxldGUobGluaylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvYmogPSB0aGlzLl9nZXRNYXAobmV4dFNvdXJjZSk7XG4gICAgICAgIGlmKG9iaikge1xuICAgICAgICAgICAgaWYoZGlyID09PSAnZnJvbScpIHtcbiAgICAgICAgICAgICAgICBvYmouamZsb3dGcm9tTGlua3MuYWRkKGxpbmspO1xuICAgICAgICAgICAgICAgIGlmKG9iai5qZmxvd05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluay5mcm9tID0gb2JqLmpmbG93Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkaXIgPT09ICd0bycpIHtcbiAgICAgICAgICAgICAgICBvYmouamZsb3dUb0xpbmtzLmFkZChsaW5rKTtcbiAgICAgICAgICAgICAgICBpZihvYmouamZsb3dOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmsudG8gPSBvYmouamZsb3dOb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTm9kZVdlYWtNYXA7XG5cbiIsIi8vIGltcG9ydCB7IE5vZGVQbGFjZWhvbGRlciB9IGZyb20gJy4vbm9kZS1wbGFjZWhvbGRlcic7XG4vKipcbiAqIOe7mOWbvuagiFxuICogQGV4dGVuZHMgQXJyYXlcbiAqL1xuY2xhc3MgSW5zdGFuY2VTdGFjayBleHRlbmRzIEFycmF5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fY3VycmVudEhpdCA9IG51bGw7XG4gICAgfVxuXG4gICAgZm9yRWFjaChjYikge1xuICAgICAgICByZXR1cm4gc3VwZXIuZm9yRWFjaCgoaSwgaWR4KSA9PiB7XG4gICAgICAgICAgICBpZihpLnR5cGUgPT09ICdOT0RFX1BMQUNFSE9MREVSJykgeyBcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYihpLCBpZHgpO1xuICAgICAgICB9KVxuICAgIH1cbiAgICBmaWx0ZXIoY2IpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oc3VwZXIuZmlsdGVyKChpLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGlmKGkudHlwZSA9PT0gJ05PREVfUExBQ0VIT0xERVInKSB7IFxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYihpLCBpZHgpO1xuICAgICAgICB9KSlcbiAgICB9XG4gICAgc2xpY2UoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHN1cGVyLmZpbHRlcigoaSwgaWR4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaS50eXBlICE9PSAnTk9ERV9QTEFDRUhPTERFUidcbiAgICAgICAgfSkpXG4gICAgfVxuICAgIHN1cGVyZmlsdGVyKGNiKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5maWx0ZXIoKGksIGlkeCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNiKGksIGlkeCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDnu5jliLblvZPliY3moIhcbiAgICAgKiBAcGFyYW0ge0NvbnRleHQyZH0gY3R4IC0gY2FudmFzIGNvbnRleHQyZFxuICAgICAqL1xuICAgIHJlbmRlcihjdHgsIGNvbmRpdGlvbikge1xuICAgICAgICBsZXQgbW92aW5nVGFyZ2V0O1xuICAgICAgICB0aGlzLmZvckVhY2goaW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgaWYoaW5zdGFuY2UuX2lzTW92aW5nKSB7XG4gICAgICAgICAgICAgICAgbW92aW5nVGFyZ2V0ID0gaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoaW5zdGFuY2UudmlzaWJsZSAmJiAoIWNvbmRpdGlvbiB8fCBjb25kaXRpb24oaW5zdGFuY2UpKSkge1xuICAgICAgICAgICAgICAgIGlmKGluc3RhbmNlLmJlZm9yZVJlbmRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZighaW5zdGFuY2UuYmVmb3JlUmVuZGVyKGN0eCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UucmVuZGVyKGN0eCk7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmKG1vdmluZ1RhcmdldCkge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIC8vIGlmKG1vdmluZ1RhcmdldC5yZWZsb3cgJiYgIW1vdmluZ1RhcmdldC5fcmVmbG93ZWQpIHtcbiAgICAgICAgICAgIC8vICAgICBtb3ZpbmdUYXJnZXQucmVmbG93KCk7XG4gICAgICAgICAgICAvLyAgICAgbW92aW5nVGFyZ2V0Ll9yZWZsb3dlZCA9IHRydWU7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBtb3ZpbmdUYXJnZXQucmVuZGVyKGN0eCk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzZXRIaXRTdGF0dXMoKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRIaXQgPSBudWxsO1xuICAgICAgICB0aGlzLmZvckVhY2goaSA9PiB7XG4gICAgICAgICAgICBpZihpLl9zdGFjaykge1xuICAgICAgICAgICAgICAgIGkuX3N0YWNrLnJlc2V0SGl0U3RhdHVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpLl9pc0hpdCA9IGZhbHNlO1xuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOeisOaSnuWvueixoei/h+a7pOadoeS7tlxuICAgICAqIEBuYW1lIEluc3RhbmNlU3RhY2t+SW5zdGFuY2VGaWx0ZXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0luc3RhbmNlfSBpbnN0YW5jZSAtIOW9k+WJjeWvueixoVxuICAgICovXG4gICAgLyoqXG4gICAgICog56Kw5pKe5qOA5rWLXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcG9pbnQgLSDnorDmkp7ngrlcbiAgICAgKiBAcGFyYW0ge0luc3RhbmNlU3RhY2t+SW5zdGFuY2VGaWx0ZXJ9IGNvbmRpdGlvbiAtIOeisOaSnuWvueixoei/h+a7pOadoeS7tlxuICAgICAqIEByZXR1cm4ge0luc3RhbmNlfVxuICAgICAqL1xuICAgIGNoZWNrSGl0KHBvaW50LCBjb25kaXRpb24sIGN1cnJlbnRDb25zdHJhaW50KXtcbiAgICAgICAgbGV0IGkgPSB0aGlzLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlKGkgPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzW2ldO1xuICAgICAgICAgICAgaWYoaW5zdGFuY2UudHlwZSA9PT0gJ05PREVfUExBQ0VIT0xERVInKSB7IFxuICAgICAgICAgICAgICAgIGktLVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoaW5zdGFuY2UudmlzaWJsZSAmJiAhaW5zdGFuY2UuaWdub3JlSGl0KSB7XG4gICAgICAgICAgICAgICAgaWYoY29uZGl0aW9uICYmIGNvbmRpdGlvbihpbnN0YW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaS0tXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihjdXJyZW50Q29uc3RyYWludCAmJiAhY3VycmVudENvbnN0cmFpbnQoaW5zdGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGktLVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpc2hpdCA9IGluc3RhbmNlLmlzSGl0KHBvaW50LCBjb25kaXRpb24pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKGlzaGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuX2N1cnJlbnRIaXQgIT09IGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLl9jdXJyZW50SGl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpdC5faXNIaXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLl9pc0hpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50SGl0ID0gaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGlzaGl0ICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc2hpdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuX2lzSGl0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaS0tXG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5fY3VycmVudEhpdCkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpdC5faXNIaXQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyZW50SGl0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOiOt+WPluW9k+WJjeWxguagiOeahOacgOWwj+WkluaOpeefqeW9olxuICAgICAqIEByZXR1cm4ge251bWJlcltdW119IC0g5aSW5o6l55+p5b2i5Z2Q5qCHXG4gICAgICovXG4gICAgZ2V0Qm91bmRpbmdSZWN0UG9pbnRzKCkge1xuICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGluc3RhbmNlID0+IHtcbiAgICAgICAgICAgIGlmKGluc3RhbmNlLnZpc2libGUgJiYgIWluc3RhbmNlLmFic29sdXRlUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWN0ID0gaW5zdGFuY2UuZ2V0Qm91bmRpbmdSZWN0KClcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChbcmVjdFswXSwgcmVjdFsxXV0pO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFtyZWN0WzJdLCByZWN0WzNdXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiOt+WPluW9k+WJjeWxguagiOeahOmUmueCueefqeW9olxuICAgICAqIEByZXR1cm4ge251bWJlcltdW119IC0g6ZSa54K555+p5b2i5Z2Q5qCHXG4gICAgICovXG4gICAgZ2V0QW5jaG9yUmVjdFBvaW50cygpIHtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaChpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICBpZihpbnN0YW5jZS52aXNpYmxlICYmICFpbnN0YW5jZS5hYnNvbHV0ZVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goaW5zdGFuY2UuYW5jaG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnN0YW5jZVN0YWNrO1xuIiwiaW1wb3J0IEluc3RhbmNlU3RhY2sgZnJvbSAnLi9zdGFjayc7XG5pbXBvcnQgeyBhZGRSZWZsb3dXb3JrIH0gZnJvbSAnLi4vZGlydHktd29yay9kaXJ0eS13b3JrJztcblxuLy8gaW1wb3J0IHsgc2V0VW5pcXVlSWQsIGdldFVuaXF1ZUlkIH0gZnJvbSAnLi4vdXRpbHMvZnVuY3Rpb25zJztcbi8qKlxuICog5a+56LGh5qCIIG1peGluIOeUqOS6juaWueS+v+aOp+WItuiKgueCueagiOWSjOi/nue6v+agiFxuICpcbiAqIEBtaXhpblxuICovXG5jb25zdCBTdGFja01peGluID0ge1xuICAgIC8qKiBAcHJvcGVydHkge05vZGVbXX0gICAgICAgICAgLSDlr7nosaHmlbDnu4QgKi9cbiAgICBpbnN0YW5jZXM6IFtdLFxuICAgIC8qKiBAcHJvcGVydHkge0Jhc2VMaW5rW119ICAgICAgLSDov57nur/mlbDnu4QgKi9cbiAgICBsaW5rczogW10sXG4gICAgLyoqIEBwcm9wZXJ0eSB7SW5zdGFuY2VTdGFja30gICAgICAgLSDlr7nosaHmoIggKi9cbiAgICBfc3RhY2s6IG51bGwsXG4gICAgLyoqIEBwcm9wZXJ0eSB7SW5zdGFuY2VTdGFja30gICAgICAgLSDov57nur/moIggKi9cbiAgICBfbGlua1N0YWNrOiBudWxsLFxuICAgIC8qKlxuICAgICAqIOWIneWni+WMluWvueixoeagiFxuICAgICAqIEBwYXJhbSB7SmZsb3dDb25maWdzfSBjb25maWdzIC0g6YWN572uXG4gICAgICovXG4gICAgaW5pdFN0YWNrKHsgZGF0YSB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5fc3RhY2sgPSBuZXcgSW5zdGFuY2VTdGFjaygpO1xuICAgICAgICB0aGlzLl9saW5rU3RhY2sgPSBuZXcgSW5zdGFuY2VTdGFjaygpO1xuICAgICAgICBpZighZGF0YSkgcmV0dXJuO1xuICAgICAgICB0aGlzLmluc3RhbmNlcyA9IGRhdGEuaW5zdGFuY2VzO1xuICAgICAgICB0aGlzLmxpbmtzID0gZGF0YS5saW5rcztcbiAgICAgICAgdGhpcy5pbnN0YW5jZXMuZm9yRWFjaChpID0+IHsgXG4gICAgICAgICAgICB0aGlzLl9zdGFjay5wdXNoKGkpO1xuICAgICAgICAgICAgaS5fYmVsb25ncyA9IHRoaXM7XG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMubGlua3MuZm9yRWFjaCgobGluaykgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbGlua1N0YWNrLnB1c2gobGluayk7XG4gICAgICAgICAgICBsaW5rLl9iZWxvbmdzID0gdGhpcztcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiDliqDlhaXoioLngrnlr7nosaFcbiAgICAgKiBAcGFyYW0ge05vZGV9IGluc3RhbmNlIC0g6IqC54K55a+56LGhXG4gICAgICovXG4gICAgYWRkVG9TdGFjayhpbnN0YW5jZSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLS1hZGRUb1N0YWNrLS0tLScsIGluc3RhbmNlKVxuICAgICAgICBpbnN0YW5jZS5fYmVsb25ncyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3N0YWNrLnB1c2goaW5zdGFuY2UpO1xuICAgICAgICBhZGRSZWZsb3dXb3JrKGluc3RhbmNlLCB0aGlzKTtcbiAgICAgICAgLy8gdGhpcy5yZWNhbGN1bGF0ZSgpXG4gICAgfSxcblxuICAgIGluc2VydFRvU3RhY2tCZWZvcmUoaW5zdGFuY2UsIGFuY2hvck5vZGUpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0taW5zZXJ0VG9TdGFja0JlZm9yZS0tLS0nKVxuICAgICAgICBpZihpbnN0YW5jZS5fYmVsb25ncykge1xuICAgICAgICAgICAgaW5zdGFuY2UuX2JlbG9uZ3MucmVtb3ZlRnJvbVN0YWNrKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5fYmVsb25ncyA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX3N0YWNrLmZpbmRJbmRleChzID0+IHMgPT09IGFuY2hvck5vZGUpO1xuICAgICAgICBpZihpZHggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFjay5zcGxpY2UoaWR4LCAwLCBpbnN0YW5jZSlcbiAgICAgICAgICAgIGFkZFJlZmxvd1dvcmsoaW5zdGFuY2UsIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRUb1N0YWNrKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICog5pu/5o2i5a+56LGhXG4gICAgICogQHBhcmFtIHtJbnN0YW5jZX0gdGFyZ2V0IC0g6KKr5pu/5o2i55qE5a+56LGhXG4gICAgICogQHBhcmFtIHtJbnN0YW5jZX0gaW5zdGFuY2UgLSDmm7/mjaLlr7nosaFcbiAgICAgKi9cbiAgICByZXBsYWNlRnJvbVN0YWNrKHRhcmdldCwgaW5zdGFuY2UpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9zdGFjay5maW5kSW5kZXgoaSA9PiBpID09PSB0YXJnZXQpO1xuICAgICAgICB0aGlzLl9zdGFjay5zcGxpY2UoaW5kZXgsIDEsIGluc3RhbmNlKTtcbiAgICAgICAgdGFyZ2V0Ll9iZWxvbmdzID0gbnVsbDtcbiAgICAgICAgaW5zdGFuY2UuX2JlbG9uZ3MgPSB0aGlzO1xuICAgICAgICAvLyB0aGlzLnJlY2FsY3VsYXRlKClcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIOWKoOWFpei/nue6v+WvueixoVxuICAgICAqIEBwYXJhbSB7QmFzZUxpbmt9IGluc3RhbmNlIC0g6L+e57q/5a+56LGhXG4gICAgICovXG4gICAgYWRkVG9MaW5rU3RhY2sobGluaykge1xuICAgICAgICBpZih0aGlzLl9saW5rU3RhY2suZmluZChsID0+IGwgPT09IGxpbmspKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGluay5fYmVsb25ncyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2xpbmtTdGFjay5wdXNoKGxpbmspO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICog5Yig6Zmk6IqC54K55a+56LGhXG4gICAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXQgLSDoioLngrnlr7nosaFcbiAgICAgKi9cbiAgICByZW1vdmVGcm9tU3RhY2sodGFyZ2V0KSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLXJlbW92ZUZyb21TdGFjay0tLS0nKVxuICAgICAgICAvLyB0aGlzLnJlbW92ZUxpbmtPbkluc3RhbmNlKHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fc3RhY2suZmluZEluZGV4KGkgPT4gaSA9PT0gdGFyZ2V0KTtcbiAgICAgICAgaWYoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFjay5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgYWRkUmVmbG93V29yayh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzLnJlY2FsY3VsYXRlKClcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIOWIoOmZpOi/nue6v+WvueixoVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0IC0g6L+e57q/5a+56LGhXG4gICAgICovXG4gICAgcmVtb3ZlRnJvbUxpbmtTdGFjayh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9saW5rU3RhY2suZmluZEluZGV4KGkgPT4gaSA9PT0gdGFyZ2V0KTtcbiAgICAgICAgaWYoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5rU3RhY2suc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICBcbiAgICBlbXB0eUxpbmsoKSB7XG4gICAgICAgIHRoaXMuX2xpbmtTdGFjayA9IG5ldyBJbnN0YW5jZVN0YWNrKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiDph43nva7lvZPliY3moIjkuK3lr7nosaHnmoTkvY3nva5cbiAgICAgKi9cbiAgICByZXNldENoaWxkcmVuUG9zaXRpb24oKSB7XG4gICAgICAgIHRoaXMuX3N0YWNrLmZvckVhY2goaSA9PiB7XG4gICAgICAgICAgICBpLmFuY2hvciA9IFswLDBdXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBhZGRJbnN0YW5jZVRvTGluayh0YXJnZXRMaW5rLCBpbnN0YW5jZSkge1xuICAgICAgICB0aGlzLmFkZFRvU3RhY2soaW5zdGFuY2UpO1xuICAgICAgICBjb25zdCB7IGZyb20sIHRvIH0gPSB0YXJnZXRMaW5rO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2xpbmtTdGFjay5maW5kSW5kZXgobCA9PiBsID09PSB0YXJnZXRMaW5rKTtcbiAgICAgICAgY29uc3QgX2NvbnN0dWN0b3IgPSB0YXJnZXRMaW5rLl9fcHJvdG9fXy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgY29uc3QgbDEgPSBuZXcgX2NvbnN0dWN0b3Ioe1xuICAgICAgICAgICAgZnJvbSwgXG4gICAgICAgICAgICB0bzogaW5zdGFuY2UsXG4gICAgICAgIH0pO1xuICAgICAgICBsMS5fYmVsb25ncyA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGwyID0gbmV3IF9jb25zdHVjdG9yKHtcbiAgICAgICAgICAgIGZyb206IGluc3RhbmNlLCBcbiAgICAgICAgICAgIHRvLFxuICAgICAgICB9KTtcbiAgICAgICAgbDIuX2JlbG9uZ3MgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX2xpbmtTdGFjay5zcGxpY2UoaW5kZXgsIDEsIGwxLCBsMik7XG4gICAgfSxcbiAgICBcbiAgICAvKipcbiAgICAgKiDlvqrnjq/lvZPliY3moIjkuK3oioLngrlcbiAgICAgKiBAcHJvcGVydHkge3N0YWNrSXRlcmF0b3JDYWxsYmFja30g5b6q546v6K6/6Zeu5qCI5Lit5q+P5Liq6IqC54K5XG4gICAgICovXG4gICAgaW50ZXJhdGVOb2RlU3RhY2soY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fc3RhY2suZm9yRWFjaChpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjayhpbnN0YW5jZSk7XG4gICAgICAgIH0pXG4gICAgfSAgIFxuICAgIC8qKlxuICAgICog5b6q546v6K6/6Zeu5qCI5Lit5q+P5Liq6IqC54K5XG4gICAgKiBAY2FsbGJhY2sgc3RhY2tJdGVyYXRvckNhbGxiYWNrXG4gICAgKiBAcGFyYW0ge05vZGV9IGluc3RhbmNlIOagiOS4reiKgueCuVxuICAgICovXG59XG5cbmV4cG9ydCBkZWZhdWx0IFN0YWNrTWl4aW47IiwiLyoqXG4gKiBMYXlvdXQgbWl4aW4g6YWN572uXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBMYXlvdXRNaXhpbn5MYXlvdXRDb25maWdzXG4gKiBAcHJvcGVydHkge0xheW91dH0gbGF5b3V0ICAgICAgICAgICAgIC0g5biD5bGA5a+56LGhIFxuICovXG4vKipcbiAqIOW4g+WxgCBtaXhpbiDnlKjkuo7ms6jlhozlkozmlrnkvr/mjqfliLbluIPlsYBcbiAqXG4gKiBAbWl4aW5cbiAqL1xuY29uc3QgTGF5b3V0TWl4aW4gPSB7XG4gICAgLyoqIEBwcm9wZXJ0eSB7TGF5b3V0fSAgICAgIC0g5biD5bGA5a+56LGhICovXG4gICAgX2xheW91dDogbnVsbCxcbiAgICAvKipcbiAgICAgKiDliJ3lp4vljJbluIPlsYBcbiAgICAgKiBAcGFyYW0ge0xheW91dE1peGlufkxheW91dENvbmZpZ3N9IGNvbmZpZ3MgLSDphY3nva5cbiAgICAgKi9cbiAgICBpbml0TGF5b3V0KGNvbmZpZ3MgPSB7fSkge1xuICAgICAgICB0aGlzLl9sYXlvdXQgPSBjb25maWdzLmxheW91dDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIOS7juW9k+WJjeWxguWHuuWPke+8jOWQkeS4iuWxgumAkuW9kumHjeaOklxuICAgICAqL1xuICAgIHJlY2FsY3VsYXRlVXAoKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tcmVjYWxjdWxhdGVVcC0tLS0nKVxuICAgICAgICBsZXQgZGlydHkgPSB0cnVlO1xuICAgICAgICBpZih0aGlzLmdldEJvdW5kaW5nRGltZW5zaW9uKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdpZHRoOiB3b2xkLCBoZWlnaHQ6IGhvbGQgfSA9IHRoaXMuZ2V0Qm91bmRpbmdEaW1lbnNpb24oKTtcbiAgICAgICAgICAgIGlmKHRoaXMucmVzZXRDaGlsZHJlblBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldENoaWxkcmVuUG9zaXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMuX2dldEJvdW5kaW5nR3JvdXBSZWN0KXtcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXRCb3VuZGluZ0dyb3VwUmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWZsb3coKTtcbiAgICAgICAgICAgIGlmKHRoaXMuX2dldEJvdW5kaW5nR3JvdXBSZWN0KXtcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXRCb3VuZGluZ0dyb3VwUmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB3aWR0aDogd25vdywgaGVpZ2h0OiBobm93IH0gPSB0aGlzLmdldEJvdW5kaW5nRGltZW5zaW9uKCk7XG4gICAgICAgICAgICBkaXJ0eSA9ICh3b2xkICE9PSB3bm93IHx8IGhvbGQgIT09IGhub3cpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlZmxvdygpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuX2JlbG9uZ3MgJiYgZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuX2JlbG9uZ3MucmVjYWxjdWxhdGVVcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmKCFkaXJ0eSB8fCB0aGlzLl9iZWxvbmdzPy51bmlxdWVOYW1lID09PSAnamZsb3cnKSB7XG4gICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlRG93bigpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZWNhbGN1bGF0ZURvd24oKSB7XG4gICAgICAgIGlmKHRoaXMuX2xheW91dCAmJiB0aGlzLl9sYXlvdXQucmVmbG93QWZ0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheW91dC5yZWZsb3dBZnRlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGFjay5mb3JFYWNoKGluc3RhbmNlID0+IHtcbiAgICAgICAgICAgIGlmKGluc3RhbmNlLnJlY2FsY3VsYXRlRG93bikge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLnJlY2FsY3VsYXRlRG93bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH0sXG4gICAgLyoqXG4gICAgICog6YeN5paw6K6h566X5biD5bGA77yM55u45b2T5LqO5rWP6KeI5Zmo6YeM6Z2i6YeN5o6S77yM5bm26YeN566X5b2T5YmN5biD5bGA5LiL55qE5pyA5bCP5aSW5o6l55+p5b2iXG4gICAgICovXG4gICAgcmVjYWxjdWxhdGUoKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tcmVjYWxjdWxhdGUtLS0tJylcbiAgICAgICAgdGhpcy5yZWZsb3coKTtcbiAgICAgICAgaWYodGhpcy5fZ2V0Qm91bmRpbmdHcm91cFJlY3Qpe1xuICAgICAgICAgICAgdGhpcy5fZ2V0Qm91bmRpbmdHcm91cFJlY3QoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICog5biD5bGA6Z2Z5oCB5qOA5p+lXG4gICAgICogQHBhcmFtIHtJbnN0YW5jZX0gaW5zdGFuY2UgLSDmo4Dmn6XljZXlhYNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAtIOajgOafpee7k+aenCBcbiAgICAgKi9cbiAgICBzdGF0aWNDaGVjayhpbnN0YW5jZSkge1xuICAgICAgICBpZih0aGlzLl9sYXlvdXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXQuc3RhdGljQ2hlY2soaW5zdGFuY2UsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIOmHjeaWsOiuoeeul+W4g+WxgO+8jOebuOW9k+S6jua1j+iniOWZqOmHjOmdoumHjeaOklxuICAgICAqL1xuICAgIHJlZmxvdygpIHtcbiAgICAgICAgaWYodGhpcy5fbGF5b3V0KSB7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXQucmVmbG93KHRoaXMpO1xuICAgICAgICB9XG4gICAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgTGF5b3V0TWl4aW47IiwiLyoqXG4gKiDmtojmga8gbWl4aW4g55So5LqO57uZSmZsb3fkvKDpgJLmtojmga9cbiAqXG4gKiBAbWl4aW5cbiAqL1xuY29uc3QgTWVzc2FnZU1peGluID0ge1xuICAgIF9tZXNzYWdlOiBudWxsLFxuICAgIC8qKlxuICAgICAqIOWPkemAgea2iOaBr1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2cgLSDmtojmga/kvZNcbiAgICAgKi9cbiAgICBzZW5kTWVzc2FnZShtc2cpIHtcbiAgICAgICAgdGhpcy5fbWVzc2FnZSA9IG1zZztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIOaOpeaUtua2iOaBr1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gbXNnIC0g5raI5oGv5L2TXG4gICAgICovXG4gICAgY29uc3VtZU1lc3NhZ2UoKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IHRoaXMuX21lc3NhZ2U7XG4gICAgICAgIHRoaXMuX21lc3NhZ2UgPSBudWxsO1xuICAgICAgICByZXR1cm4gbXNnO1xuICAgIH0sXG4gICAgcmVhZE1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWVzc2FnZU1peGluOyIsIlxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGluaXRBbmltZSgpIHtcbiAgICAgICAgdGhpcy5hbmltZV9xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLl9fYW5pbWVDbG9ja19fID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyB0aGlzLmFuaW1lY2xvY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIHRoaXMuZnJhbWVSZW5kZXJlZCA9IGZhbHNlO1xuICAgIH0sXG4gICAgLy8gc2V0QW5pbWVDbG9jayh0aW1lKSB7XG4gICAgLy8gICAgIGlmKHRpbWUgIT09IHRoaXMuYW5pbWVjbG9jaykge1xuICAgIC8vICAgICAgICAgdGhpcy5mcmFtZVJlbmRlcmVkID0gZmFsc2U7XG4gICAgLy8gICAgICAgICB0aGlzLmFuaW1lY2xvY2sgPSB0aW1lO1xuICAgIC8vICAgICB9XG4gICAgLy8gfSxcblxuICAgIC8vIGhhc0FuaW1lQW5kRnJhbWVSZW5kZXJlZCgpIHtcbiAgICAvLyAgICAgcmV0dXJuIHRoaXMuYW5pbWVfcXVldWUubGVuZ3RoICYmIHRoaXMuZnJhbWVSZW5kZXJlZDtcbiAgICAvLyB9LFxuXG4gICAgLy8gc2V0RnJhbWVSZW5kZXJlZCgpIHtcbiAgICAvLyAgICAgaWYodGhpcy5hbmltZV9xdWV1ZS5sZW5ndGgpIHtcbiAgICAvLyAgICAgICAgIHRoaXMuZnJhbWVSZW5kZXJlZCA9IHRydWU7XG4gICAgLy8gICAgIH1cbiAgICAvLyB9LFxuXG4gICAgcmVxdWVzdEpGbG93QW5pbWUoZnJhbWVDYWxsQmFjaykge1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5lbnF1ZXVlQW5pbWUoZnJhbWVDYWxsQmFjayk7XG4gICAgICAgIHRoaXMuX3J1bkFuaW1lKCk7XG4gICAgICAgIHJldHVybiBtZXRhO1xuICAgIH0sXG5cbiAgICBlbnF1ZXVlQW5pbWUoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgYW5pbWVNZXRhID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgY2FuY2VsOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsQW5pbWUoYW5pbWVNZXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFuaW1lX3F1ZXVlLnB1c2goYW5pbWVNZXRhKTtcbiAgICAgICAgcmV0dXJuIGFuaW1lTWV0YTtcbiAgICB9LFxuXG4gICAgX2NhbmNlbEFuaW1lKG1ldGEpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5hbmltZV9xdWV1ZS5maW5kSW5kZXgobSA9PiBtID09PSBtZXRhKTtcbiAgICAgICAgfmlkeCAmJiB0aGlzLmFuaW1lX3F1ZXVlLnNwbGljZShpZHgsIDEpO1xuICAgICAgICBcbiAgICB9LFxuXG4gICAgcnVuQW5pbWUoKSB7XG4gICAgICAgIHRoaXMuX3J1bkFuaW1lKCk7XG4gICAgICAgIC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9ydW5BbmltZS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuICAgIF9ydW5BbmltZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYW5pbWVfcXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ydW5BbmltZSgpO1xuICAgICAgICAgICAgfSkgIFxuICAgICAgICAgICAgLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3J1bkFuaW1lLmJpbmQodGhpcykpXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcnVuQW5pbWVGcmFtZSgpIHtcbiAgICAgICAgdGhpcy5hbmltZV9xdWV1ZS5mb3JFYWNoKG1ldGEgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGlmKCFtZXRhLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgbWV0YS5zdGFydCA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVsYXBzZWQgPSB0aW1lc3RhbXAgLSBtZXRhLnN0YXJ0O1xuICAgICAgICAgICAgbWV0YS5jYWxsYmFjayhlbGFwc2VkKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSIsImltcG9ydCB7IGNyZWF0ZUNhbnZhcyB9IGZyb20gJy4uL3V0aWxzL2NhbnZhcyc7XG5leHBvcnQgZGVmYXVsdCB7XG4gICAgLy8g5Lyg5YWl5LiA5Liq5Yir55qEIGNvbnRleHQyZCDmnaXnu5jliLZcbiAgICBjYXB0dXJlTWFwKHdyYXBwZXIsIHtcbiAgICAgICAgcGFkZGluZyA9IDAsXG4gICAgICAgIHBsYWNlbWVudCA9ICdub3JtYWwnLFxuICAgIH0pIHtcblxuICAgICAgICB0aGlzLl9nZXRCb3VuZGluZ0dyb3VwUmVjdCgpO1xuICAgICAgICBjb25zdCB7IFxuICAgICAgICAgICAgd2lkdGg6IHBfd2lkdGgsIFxuICAgICAgICAgICAgaGVpZ2h0OiBwX2hlaWdodCwgXG4gICAgICAgICAgICB4OiBwX3gsIFxuICAgICAgICAgICAgeTogcF95IFxuICAgICAgICB9ID0gdGhpcy5ib3VuZGluZ19ib3g7XG4gICAgICAgIGxldCBtaW5pTWFwID0gdGhpcy5taW5pTWFwO1xuICAgICAgICBpZighbWluaU1hcCkge1xuICAgICAgICAgICAgdGhpcy5taW5pTWFwID0gY3JlYXRlQ2FudmFzKHdyYXBwZXIpO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgICAgICAgcmF3X3dpZHRoLFxuICAgICAgICAgICAgICAgIHJhd19oZWlnaHQsXG4gICAgICAgICAgICB9ID0gdGhpcy5taW5pTWFwO1xuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd6b29tcGFuJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlck1hcCAmJiB0aGlzLl9yZW5kZXJNYXAoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBsZXQgcHJlc3NEb3duID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm1pbmlNYXAuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHsgb2Zmc2V0WCwgb2Zmc2V0WSwgZGVsdGFYLCBkZWx0YVkgfSA9IGV2ZW50XG4gICAgICAgICAgICAgICAgcHJlc3NEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbk1vdmVNYXAgJiYgdGhpcy5fb25Nb3ZlTWFwKG9mZnNldFgsIG9mZnNldFkpICBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB0aGlzLm1pbmlNYXAuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHsgb2Zmc2V0WCwgb2Zmc2V0WSwgZGVsdGFYLCBkZWx0YVkgfSA9IGV2ZW50XG4gICAgICAgICAgICAgICAgaWYocHJlc3NEb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uTW92ZU1hcCAmJiB0aGlzLl9vbk1vdmVNYXAob2Zmc2V0WCwgb2Zmc2V0WSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYob2Zmc2V0WSA8IDUgfHwgb2Zmc2V0WCA8IDUgfHwgb2Zmc2V0WCA+IHdpZHRoLTUgfHwgb2Zmc2V0WSA+IGhlaWdodC01KSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNzRG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB0aGlzLm1pbmlNYXAuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBwcmVzc0Rvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIGNvbnN0IGNhaGVDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGNhaGVDYW52YXMud2lkdGggPSByYXdfd2lkdGg7XG4gICAgICAgICAgICBjYWhlQ2FudmFzLmhlaWdodCA9IHJhd19oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmNhY2hlTWluaW1hcEN0eCA9IGNhaGVDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICByYXdfd2lkdGgsXG4gICAgICAgICAgICByYXdfaGVpZ2h0LFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIHNjYWxlLFxuICAgICAgICAgICAgY3R4XG4gICAgICAgIH0gPSB0aGlzLm1pbmlNYXBcbiAgICAgICAgY29uc3QgcGFkMiA9IHBhZGRpbmcgKiAyO1xuICAgICAgICBjb25zdCBwYWQgPSBwYWRkaW5nO1xuICAgICAgICBjb25zdCByMSA9ICh3aWR0aCAtIHBhZDIpIC8gcF93aWR0aDtcbiAgICAgICAgY29uc3QgcjIgPSAoaGVpZ2h0IC0gcGFkMikgLyBwX2hlaWdodDtcbiAgICAgICAgY29uc3QgciA9IE1hdGgubWluKHIxLCByMik7XG4gICAgICAgIFxuICAgICAgICBsZXQgbV94ID0gMDtcbiAgICAgICAgbGV0IG1feSA9IDA7XG5cbiAgICAgICAgaWYocGxhY2VtZW50ID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgbV95ID0gKGhlaWdodCAtIHBfaGVpZ2h0ICogcikgLyAyIC0gcF95ICogcjtcbiAgICAgICAgICAgIG1feCA9ICh3aWR0aCAtIHBfd2lkdGggKiByKSAvIDIgLSBwX3ggKiByO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYocjEgPCByMikge1xuICAgICAgICAgICAgICAgIG1feSA9IChoZWlnaHQgLSBwX2hlaWdodCAqIHIpIC8gMiAtIHBfeSAqIHI7XG4gICAgICAgICAgICAgICAgbV94ID0gcGFkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtX3ggPSAod2lkdGggLSBwX3dpZHRoICogcikgLyAyIC0gcF94ICogcjtcbiAgICAgICAgICAgICAgICBtX3kgPSBwYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FjaGVjdHggPSB0aGlzLmNhY2hlTWluaW1hcEN0eDtcbiAgICAgICAgY2FjaGVjdHguc2V0VHJhbnNmb3JtKCk7XG4gICAgICAgIGNhY2hlY3R4LmNsZWFyUmVjdCgwLCAwLCByYXdfd2lkdGgsIHJhd19oZWlnaHQpO1xuICAgICAgICBjYWNoZWN0eC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgICAgICBjYWNoZWN0eC50cmFuc2Zvcm0ociwgMCwgMCwgciwgbV94LCBtX3kpO1xuICAgICAgICAvLyBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XG4gICAgICAgIC8vIGN0eC5hcmMoIDMwLCAzMCwgMTAwLCAwLCAyKk1hdGguUEkpO1xuICAgICAgICAvLyBjdHguZmlsbCgpXG4gICAgICAgIC8vIGRlYnVnZ2VyXG4gICAgICAgIGNvbnN0IGJyID0gWzAsMCwwLDBdXG4gICAgICAgIGlmKHRoaXMuTm9kZVJlbmRlclRvcCkge1xuICAgICAgICAgICAgdGhpcy5fbGlua1N0YWNrLnJlbmRlcihjYWNoZWN0eCwgKGxpbmspID0+IHsgbGluay5pc0luVmlld0JveChicik7IHJldHVybiB0cnVlOyB9KTtcbiAgICAgICAgICAgIC8vIHRoaXMuX2xpbmtTdGFjay5yZW5kZXIoY2FjaGVjdHgpO1xuICAgICAgICAgICAgdGhpcy5fc3RhY2sucmVuZGVyKGNhY2hlY3R4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YWNrLnJlbmRlcihjYWNoZWN0eCk7XG4gICAgICAgICAgICB0aGlzLl9saW5rU3RhY2sucmVuZGVyKGNhY2hlY3R4LCAobGluaykgPT4geyBsaW5rLmlzSW5WaWV3Qm94KGJyKTsgcmV0dXJuIHRydWU7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF9jYWNoZU1hcEltYWdlRGF0YSA9IGNhY2hlY3R4LmdldEltYWdlRGF0YSgwLCAwLHJhd193aWR0aCwgcmF3X2hlaWdodCk7XG4gICAgICAgIHRoaXMuX3JlbmRlck1hcCA9ICgpID0+IHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKCk7XG4gICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHJhd193aWR0aCwgcmF3X2hlaWdodCk7XG4gICAgICAgICAgICAvLyBpZighaSkge1xuICAgICAgICAgICAgY3R4LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKF9jYWNoZU1hcEltYWdlRGF0YSwgMCwgMCk7XG4gICAgICAgICAgICBjdHgudHJhbnNmb3JtKHIsIDAsIDAsIHIsIG1feCwgbV95KTtcbiAgICAgICAgICAgIGNvbnN0IFt4LCB5LCB0LCBkXSA9IHRoaXMuX2dldFZpZXdCb3goKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5yZWN0KHgsIHksICB0LXgsIGQteSk7XG4gICAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKCk7XG4gICAgICAgICAgICBjdHgucmVjdCgwLCAwLCByYXdfd2lkdGgsIHJhd19oZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmNsaXAoXCJldmVub2RkXCIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMC40KSc7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgcmF3X3dpZHRoLCByYXdfaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVuZGVyTWFwKCk7XG5cbiAgICAgICAgdGhpcy5fb25Nb3ZlTWFwID0gKG9mZnNldFgsIG9mZnNldFkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFt4LCB5LCB0LCBkXSA9IHRoaXMuX2dldFZpZXdCb3goKTtcbiAgICAgICAgICAgIC8vIGNvbnN0IHcgPSB0LXg7XG4gICAgICAgICAgICBjb25zdCBhID0gKHQteCkvMiArIHg7XG4gICAgICAgICAgICBjb25zdCBiID0gKGQteSkvMiArIHk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHAgPSBbYSAqIHIgKyBtX3gsIGIgKiByICsgbV95XVxuICAgICAgICAgICAgdGhpcy5fcmVjYWxjdWxhdGVQb3NpdGlvbigocFswXSAtIG9mZnNldFgpLyByICogdGhpcy5zY2FsZSwgKHBbMV0gLSBvZmZzZXRZKS8gciAqIHRoaXMuc2NhbGUpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzLl9yZW5kZXIoY3R4KTtcbiAgICB9XG5cblxufSIsIi8qKlxuICogSkZsb3cg5oqb5Ye65LqL5Lu2XG4gKiBAZXh0ZW5kcyBDdXN0b21FdmVudFxuICogQHByb3BlcnR5IHtFdmVudH0gIG9yaWdpbkV2ZW50ICAgICAgLSDljp/lp4vkuovku7ZcbiAqIEBwcm9wZXJ0eSB7SW5zdGFuY2V9IHRhcmdldCAgICAgICAgIC0g5LqL5Lu26Kem5Y+R5a+56LGhXG4gKiBAcHJvcGVydHkge0pGbG93fSBqZmxvdyAgICAgICAgICAgICAtIEpGbG93IOWvueixoVxuICogQHByb3BlcnR5IHtib29sZWFufSBidWJibGVzICAgICAgICAgLSDlhpLms6HmoIfor4ZcbiAqL1xuY2xhc3MgSkZsb3dFdmVudCBleHRlbmRzIEN1c3RvbUV2ZW50e1xuICAgIGNvbnN0cnVjdG9yKGV2ZW50LCBjb25maWdzID0ge30pIHtcbiAgICAgICAgY29uc3QgZGV0YWlsID0ge1xuICAgICAgICAgICAgLi4uY29uZmlncyxcbiAgICAgICAgICAgIG9yaWdpbkV2ZW50OiBjb25maWdzLmV2ZW50LFxuICAgICAgICAgICAgdGFyZ2V0OiBjb25maWdzLnRhcmdldCxcbiAgICAgICAgICAgIGpmbG93OiBjb25maWdzLmpmbG93LFxuICAgICAgICAgICAgYnViYmxlczogY29uZmlncy5idWJibGVzIHx8IGZhbHNlLCAgICBcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihldmVudCwge1xuICAgICAgICAgICAgZGV0YWlsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSkZsb3dFdmVudDsiLCJpbXBvcnQgSkZsb3dFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuZXhwb3J0IGNsYXNzIFNjcm9sbEJhciB7XG4gICAgY29uc3RydWN0b3IoZGlyLCBjb25maWdzID0ge30pIHtcbiAgICAgICAgdGhpcy5hbmNob3IgPSBbMCwwXTtcbiAgICAgICAgdGhpcy53aWR0aCA9IGNvbmZpZ3MuYmFyV2lkdGggfHwgNDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBjb25maWdzLmJhcldpZHRoIHx8IDQ7ICBcbiAgICAgICAgdGhpcy5iYXJNYXJnaW5YID0gMDtcbiAgICAgICAgdGhpcy5iYXJNYXJnaW5ZID0gMFxuICAgICAgICB0aGlzLmRpciA9IGRpcjtcbiAgICAgICAgdGhpcy5wbGFpbkNvbG9yID0gY29uZmlncy5wbGFpbkNvbG9yIHx8ICdyZ2JhKDAsIDAsIDAsIDAuMTUpJztcbiAgICAgICAgdGhpcy5mb2N1c0NvbG9yID0gY29uZmlncy5mb2N1c0NvbG9yIHx8ICdyZ2JhKDAsIDAsIDAsIDAuMjUpJztcbiAgICAgICAgdGhpcy5pc0ZvY3VzID0gZmFsc2U7XG4gICAgfVxuICAgIHJlbmRlcihjdHgpIHtcbiAgICAgICAgY29uc3QgW3gsIHldID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgaWYodGhpcy5kaXIgPT09ICd4Jykge1xuICAgICAgICAgICAgY29uc3QgcmFkaXVzID0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgY29uc3QgY3kgPSB5ICsgcmFkaXVzO1xuICAgICAgICAgICAgY29uc3QgYnkgPSB5ICsgdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCByYyA9IHggKyB0aGlzLndpZHRoIC0gdGhpcy5iYXJNYXJnaW5YKjIgLSByYWRpdXM7XG4gICAgICAgICAgICBjb25zdCBsYyA9IHggKyB0aGlzLmJhck1hcmdpblggKyByYWRpdXNcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8obGMsIGJ5KTtcbiAgICAgICAgICAgIGN0eC5hcmMobGMsIGN5LCByYWRpdXMsIE1hdGguUEkvMiwgTWF0aC5QSS8yKjMpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhyYywgeSk7XG4gICAgICAgICAgICBjdHguYXJjKHJjLCBjeSwgcmFkaXVzLCAgLU1hdGguUEkvMiwgTWF0aC5QSS8yKTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByYWRpdXMgPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgICAgIGNvbnN0IHRjID0geSArIHRoaXMuYmFyTWFyZ2luWSArIHJhZGl1cztcbiAgICAgICAgICAgIGNvbnN0IGJjID0geSArIHRoaXMuaGVpZ2h0IC0gdGhpcy5iYXJNYXJnaW5ZKjIgLSByYWRpdXNcbiAgICAgICAgICAgIGNvbnN0IGN4ID0geCArIHJhZGl1cztcbiAgICAgICAgICAgIGNvbnN0IHJ4ID0geCArIHRoaXMud2lkdGg7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIHRjKTtcbiAgICAgICAgICAgIGN0eC5hcmMoY3gsIHRjLCByYWRpdXMsIC1NYXRoLlBJLCAwKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocngsIGJjKTtcbiAgICAgICAgICAgIGN0eC5hcmMoY3gsIGJjLCByYWRpdXMsIDAsIE1hdGguUEkpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgIGN0eC5yZWN0KFxuICAgICAgICAgICAgICAgIC8vIHggKyB0aGlzLmJhck1hcmdpblgsXG4gICAgICAgICAgICAgICAgLy8geSArIHRoaXMuYmFyTWFyZ2luWSxcbiAgICAgICAgICAgICAgICAvLyB0aGlzLndpZHRoIC0gdGhpcy5iYXJNYXJnaW5YKjIsXG4gICAgICAgICAgICAgICAgLy8gdGhpcy5oZWlnaHQgLSB0aGlzLmJhck1hcmdpblkqMik7XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuaXNGb2N1cyA/IHRoaXMuZm9jdXNDb2xvciA6IHRoaXMucGxhaW5Db2xvcjtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgaXNIaXQocG9pbnQpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIHJldHVybiBwb2ludFswXSA+IGFuY2hvclswXSAtIDVcbiAgICAgICAgICAgICYmIHBvaW50WzBdIDwgYW5jaG9yWzBdICsgdyArIDVcbiAgICAgICAgICAgICYmIHBvaW50WzFdID4gYW5jaG9yWzFdIC0gNVxuICAgICAgICAgICAgJiYgcG9pbnRbMV0gPCBhbmNob3JbMV0gKyBoICsgNTtcbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCB7XG4gICAgaW5pdFNjcm9sbEJhcihjb25maWdzID0ge30pIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgYmFyQ29sb3IsXG4gICAgICAgICAgICBiYXJGb2N1c0NvbG9yLFxuICAgICAgICAgICAgYmFyTWFyZ2luWCxcbiAgICAgICAgICAgIGJhck1hcmdpblksXG4gICAgICAgICAgICBiYXJXaWR0aCxcbiAgICAgICAgfSA9IGNvbmZpZ3M7XG4gICAgICAgIHRoaXMuX3Njcm9sbGJhckVuYWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3Njcm9sbGJhclggPSBuZXcgU2Nyb2xsQmFyKCd4Jywge1xuICAgICAgICAgICAgcGxhaW5Db2xvcjogYmFyQ29sb3IsXG4gICAgICAgICAgICBmb2N1c0NvbG9yOiBiYXJGb2N1c0NvbG9yLFxuICAgICAgICAgICAgYmFyV2lkdGgsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zY3JvbGxiYXJYLmJhck1hcmdpblggPSBiYXJNYXJnaW5YIHx8IDU7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9zY3JvbGxiYXJZID0gbmV3IFNjcm9sbEJhcigneScsIHtcbiAgICAgICAgICAgIHBsYWluQ29sb3I6IGJhckNvbG9yLFxuICAgICAgICAgICAgZm9jdXNDb2xvcjogYmFyRm9jdXNDb2xvcixcbiAgICAgICAgICAgIGJhcldpZHRoXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zY3JvbGxiYXJZLmJhck1hcmdpblkgPSBiYXJNYXJnaW5ZIHx8IDU7XG5cbiAgICAgICAgdGhpcy5fc2Nyb2xsQmFyU3RhdHVzID0ge1xuICAgICAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICAgICAgeHNjYWxlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB5c2NhbGU6IHVuZGVmaW5lZCxcblxuICAgICAgICAgICAgYmFySW5pdFg6IDAsXG4gICAgICAgICAgICBiYXJJbml0WTogMCxcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3Bab29tcGFuV2F0Y2ggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd6b29tcGFuJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYoIXRoaXMuc3RvcFpvb21wYW5XYXRjaCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQmFyT25QYW5BbmRab29tKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICB0aGlzLnNjcm9sbEJhck9uUGFuQW5kWm9vbSgpO1xuXG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgZSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFksIGNsaWVudFgsIGNsaWVudFkgfSA9IGU7XG4gICAgICAgICAgICB0aGlzLm9uU2Nyb2xsYmFyUHJlc3NTdGFydChvZmZzZXRYLCBvZmZzZXRZLCBjbGllbnRYLCBjbGllbnRZKVxuICAgICAgICB9KVxuICAgIH0sXG4gICAgY2hlY2tTY3JvbGxEcmFnZ2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njcm9sbEJhclN0YXR1cyAmJiB0aGlzLl9zY3JvbGxCYXJTdGF0dXMuZHJhZ2dpbmc7XG4gICAgfSxcbiAgICBvblNjcm9sbGJhclByZXNzU3RhcnQob2Zmc2V0WCwgb2Zmc2V0WSwgY2xpZW50WCwgY2xpZW50WSkge1xuICAgICAgICB0aGlzLnN0b3Bab29tcGFuV2F0Y2ggPSB0cnVlO1xuICAgICAgICBjb25zdCB4aGl0ID0gdGhpcy5fc2Nyb2xsYmFyWC5pc0hpdChbb2Zmc2V0WCwgb2Zmc2V0WV0pO1xuICAgICAgICBpZih4aGl0KSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3Njcm9sbEJhclN0YXR1cywge1xuICAgICAgICAgICAgICAgIGRyYWdnaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy5fc2Nyb2xsYmFyWCxcbiAgICAgICAgICAgICAgICBiYXJTdGFydFg6IHRoaXMuX3Njcm9sbGJhclguYW5jaG9yWzBdLFxuICAgICAgICAgICAgICAgIGJhckluaXRYOiBjbGllbnRYLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeWhpdCA9IHRoaXMuX3Njcm9sbGJhclkuaXNIaXQoW29mZnNldFgsIG9mZnNldFldKTtcbiAgICAgICAgaWYoeWhpdCkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9zY3JvbGxCYXJTdGF0dXMsIHtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMuX3Njcm9sbGJhclksXG4gICAgICAgICAgICAgICAgYmFyU3RhcnRZOiB0aGlzLl9zY3JvbGxiYXJZLmFuY2hvclsxXSxcbiAgICAgICAgICAgICAgICBiYXJJbml0WTogY2xpZW50WSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGYgPSAoZSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFksIGNsaWVudFgsIGNsaWVudFkgfSA9IGU7XG4gICAgICAgICAgICB0aGlzLm9uRHJhZ2dpbmdTY3JvbGxiYXIob2Zmc2V0WCwgb2Zmc2V0WSwgY2xpZW50WCwgY2xpZW50WSlcbiAgICAgICAgICAgIFxuICAgICAgICB9KS5iaW5kKHRoaXMpO1xuICAgICAgICBcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBmKTtcbiAgICAgICAgY29uc3QgdCA9IChlID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fc2Nyb2xsQmFyU3RhdHVzLCB7XG4gICAgICAgICAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICAgICAgICAgICB4OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgeTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIGYpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdCk7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCB0KTtcbiAgICAgICAgICAgIHRoaXMuc3RvcFpvb21wYW5XYXRjaCA9IGZhbHNlO1xuICAgICAgICB9KS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCB0LCB7XG4gICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHQsIHtcbiAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSlcbiAgICB9LFxuICAgIG9uRHJhZ2dpbmdTY3JvbGxiYXIob2Zmc2V0WCwgb2Zmc2V0WSwgY2xpZW50WCwgY2xpZW50WSkge1xuICAgICAgICBpZih0aGlzLl9zY3JvbGxiYXJFbmFibGUgJiYgdGhpcy5fc2Nyb2xsQmFyU3RhdHVzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIGJhckluaXRYLFxuICAgICAgICAgICAgICAgIGJhclN0YXJ0WCxcbiAgICAgICAgICAgICAgICBiYXJJbml0WSxcbiAgICAgICAgICAgICAgICBiYXJTdGFydFksXG4gICAgICAgICAgICAgICAgeHNjYWxlLFxuICAgICAgICAgICAgICAgIHlzY2FsZSxcbiAgICAgICAgICAgICAgICBzY29sbGJhckhlaWdodCxcbiAgICAgICAgICAgICAgICBzY29sbGJhcldpZHRoLFxuICAgICAgICAgICAgICAgIHJlYWxSLFxuICAgICAgICAgICAgICAgIHJlYWxMLFxuICAgICAgICAgICAgICAgIHJlYWxULFxuICAgICAgICAgICAgICAgIHJlYWxCLFxuICAgICAgICAgICAgfSA9IHRoaXMuX3Njcm9sbEJhclN0YXR1cztcbiAgICAgICAgICAgIGNvbnN0IHsgYWN0dWFsX3dpZHRoLCBhY3R1YWxfaGVpZ2h0IH0gPSB0aGlzLmNhbnZhc01ldGE7XG4gICAgICAgICAgICBjb25zdCB7IFxuICAgICAgICAgICAgICAgIHg6IHBfeCwgXG4gICAgICAgICAgICAgICAgeTogcF95IFxuICAgICAgICAgICAgfSA9IHRoaXMuYm91bmRpbmdfYm94O1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGFyZ2V0LmRpciwgcmVhbFQsIHJlYWxCKVxuICAgICAgICAgICAgbGV0IGRlbHRhWCA9IDAsIGRlbHRhWSA9IDA7XG4gICAgICAgICAgICBpZih0YXJnZXQuZGlyID09PSAneCcpIHtcbiAgICAgICAgICAgICAgICBkZWx0YVggPSBjbGllbnRYIC0gYmFySW5pdFg7XG4gICAgICAgICAgICAgICAgY29uc3QgeG5ldyA9IGJhclN0YXJ0WCArIGRlbHRhWDtcbiAgICAgICAgICAgICAgICBjb25zdCBxID0gdGFyZ2V0LmFuY2hvclswXSA9IE1hdGgubWF4KE1hdGgubWluKHhuZXcsIGFjdHVhbF93aWR0aCAtIHNjb2xsYmFyV2lkdGgpLCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCByYXRpb0luWCA9IHEgLyBhY3R1YWxfd2lkdGg7XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgeSA9IChyZWFsQiAtIChyZWFsQiAtIHJlYWxUKSAqIHJhdGlvSW5ZKSAqIHRoaXMuc2NhbGVcbiAgICAgICAgICAgICAgICBjb25zdCByYXRpb1ggPSAocmVhbFIgLSByZWFsTCkgKiByYXRpb0luWCArIHJlYWxMXG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IChwX3ggLSByYXRpb1gpICogdGhpcy5zY2FsZVxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5wb3NpdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRYOiB4IC0gcF94ICogdGhpcy5zY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodGFyZ2V0LmRpciA9PT0gJ3knKSB7ICAgICAgXG4gICAgICAgICAgICAgICAgZGVsdGFZID0gY2xpZW50WSAtIGJhckluaXRZO1xuICAgICAgICAgICAgICAgIGNvbnN0IHluZXcgPSBiYXJTdGFydFkgKyBkZWx0YVk7XG4gICAgICAgICAgICAgICAgY29uc3QgcSA9IHRhcmdldC5hbmNob3JbMV0gPSBNYXRoLm1heChNYXRoLm1pbih5bmV3LCBhY3R1YWxfaGVpZ2h0IC0gc2NvbGxiYXJIZWlnaHQpLCAwKTs7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF0aW9JblkgPSBxIC8gYWN0dWFsX2hlaWdodDtcbiAgICAgICAgICAgICAgICAvLyBjb25zdCB5ID0gKHJlYWxCIC0gKHJlYWxCIC0gcmVhbFQpICogcmF0aW9JblkpICogdGhpcy5zY2FsZVxuICAgICAgICAgICAgICAgIGNvbnN0IHJhdGlvWSA9IChyZWFsQiAtIHJlYWxUKSAqIHJhdGlvSW5ZICsgcmVhbFRcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gKHBfeSAtIHJhdGlvWSkgKiB0aGlzLnNjYWxlXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnBvc2l0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFk6IHkgLSBwX3kgKiB0aGlzLnNjYWxlLFxuICAgICAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCd6b29tcGFuJywge1xuICAgICAgICAgICAgICAgIGRlbHRhWCxcbiAgICAgICAgICAgICAgICBkZWx0YVlcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgY2hlY2tTY3JvbGxCYXJIb3ZlcihvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgICAgIGlmKHRoaXMuX3Njcm9sbGJhckVuYWJsZSkge1xuICAgICAgICAgICAgY29uc3QgeGhpdCA9IHRoaXMuX3Njcm9sbGJhclguaXNIaXQoW29mZnNldFgsIG9mZnNldFldKTtcbiAgICAgICAgICAgIGlmKHhoaXQpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9zY3JvbGxCYXJTdGF0dXMuaG92ZXJUYXJnZXQgPSB0aGlzLl9zY3JvbGxiYXJYO1xuICAgICAgICAgICAgICAgIGlmKCF0aGlzLl9zY3JvbGxiYXJYLmlzRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWC5pc0ZvY3VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB5aGl0ID0gdGhpcy5fc2Nyb2xsYmFyWS5pc0hpdChbb2Zmc2V0WCwgb2Zmc2V0WV0pO1xuICAgICAgICAgICAgaWYoeWhpdCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuX3Njcm9sbEJhclN0YXR1cy5ob3ZlclRhcmdldCA9IHRoaXMuX3Njcm9sbGJhclk7XG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuX3Njcm9sbGJhclkuaXNGb2N1cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxiYXJZLmlzRm9jdXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICByZXNldFNjcm9sbEJhckhvdmVyKCkge1xuICAgICAgICBpZih0aGlzLl9zY3JvbGxiYXJFbmFibGUpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuX3Njcm9sbGJhclkuaXNGb2N1cyB8fCB0aGlzLl9zY3JvbGxiYXJYLmlzRm9jdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxiYXJZLmlzRm9jdXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxiYXJYLmlzRm9jdXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9nZXRTY3JvbGxWaWV3Qm91bmRpbmdib3goKSB7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSAxMjA7XG4gICAgICAgIGNvbnN0IHsgXG4gICAgICAgICAgICB3aWR0aDogcF93aWR0aCwgXG4gICAgICAgICAgICBoZWlnaHQ6IHBfaGVpZ2h0LCBcbiAgICAgICAgICAgIHg6IHBfeCwgXG4gICAgICAgICAgICB5OiBwX3kgXG4gICAgICAgIH0gPSB0aGlzLmJvdW5kaW5nX2JveDtcbiAgICAgICAgY29uc3QgcCA9IHBhZGRpbmc7XG4gICAgICAgIGNvbnN0IHAyID0gcGFkZGluZyAqIDI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogcF93aWR0aCArIHAyLFxuICAgICAgICAgICAgaGVpZ2h0OiBwX2hlaWdodCArIHAyLFxuICAgICAgICAgICAgeDogcF94IC0gcCxcbiAgICAgICAgICAgIHk6IHBfeSAtIHBcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2Nyb2xsQmFyT25QYW5BbmRab29tKCkge1xuICAgICAgICBpZighdGhpcy5fc2Nyb2xsYmFyRW5hYmxlIHx8IHRoaXMuX3Njcm9sbEJhclN0YXR1cy5kcmFnZ2luZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgXG4gICAgICAgICAgICB3aWR0aDogcF93aWR0aCwgXG4gICAgICAgICAgICBoZWlnaHQ6IHBfaGVpZ2h0LCBcbiAgICAgICAgICAgIHg6IHBfeCwgXG4gICAgICAgICAgICB5OiBwX3kgXG4gICAgICAgIH0gPSB0aGlzLl9nZXRTY3JvbGxWaWV3Qm91bmRpbmdib3goKTtcbiAgICAgICAgXG4gICAgICAgIGxldCBbeCwgeSwgciwgYl0gPSB0aGlzLl9nZXRWaWV3Qm94KCk7XG4gICAgICAgIGNvbnN0IHJlYWxSID0gTWF0aC5tYXgociwgcF94ICsgcF93aWR0aCk7XG4gICAgICAgIGNvbnN0IHJlYWxMID0gTWF0aC5taW4oeCwgcF94KTtcbiAgICAgICAgY29uc3QgcmVhbFQgPSBNYXRoLm1pbih5LCBwX3kpO1xuICAgICAgICBjb25zdCByZWFsQiA9IE1hdGgubWF4KGIsIHBfeSArIHBfaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgdncgPSByIC0geDtcbiAgICAgICAgY29uc3QgdmggPSBiIC0geTtcbiAgICAgICAgY29uc3QgeyBhY3R1YWxfd2lkdGgsIGFjdHVhbF9oZWlnaHQgfSA9IHRoaXMuY2FudmFzTWV0YTtcbiAgICAgICAgY29uc3QgeHNjYWxlID0gdncgLyAocmVhbFIgLSByZWFsTClcbiAgICAgICAgaWYoeHNjYWxlIDwgMSkgIHtcbiAgICAgICAgICAgIGNvbnN0IHNjb2xsYmFyV2lkdGggPSBhY3R1YWxfd2lkdGggKiB4c2NhbGU7XG4gICAgICAgICAgICBjb25zdCBhbmNob3JYID0gKHggLSByZWFsTCkgKiB4c2NhbGUgKiB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWC5hbmNob3IgPSBbYW5jaG9yWCwgYWN0dWFsX2hlaWdodCAtIDEwXTtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbGJhclgud2lkdGggPSBzY29sbGJhcldpZHRoO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsQmFyU3RhdHVzLnNjb2xsYmFyV2lkdGggPSBzY29sbGJhcldpZHRoO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCB5c2NhbGUgPSB2aCAvIChyZWFsQiAtIHJlYWxUKTtcbiAgICAgICAgaWYoeXNjYWxlIDwgMSkgIHtcbiAgICAgICAgICAgIGNvbnN0IHNjb2xsYmFySGVpZ2h0ID0gYWN0dWFsX2hlaWdodCAqIHlzY2FsZTtcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvclkgPSAoeSAtIHJlYWxUKSAqIHlzY2FsZSAqIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxiYXJZLmFuY2hvciA9IFthY3R1YWxfd2lkdGggLSAxMCwgYW5jaG9yWV07XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxiYXJZLmhlaWdodCA9IHNjb2xsYmFySGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsQmFyU3RhdHVzLnNjb2xsYmFySGVpZ2h0ID0gc2NvbGxiYXJIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3Njcm9sbEJhclN0YXR1cywge1xuICAgICAgICAgICAgeXNjYWxlLFxuICAgICAgICAgICAgeHNjYWxlLFxuICAgICAgICAgICAgcmVhbFIsXG4gICAgICAgICAgICByZWFsTCxcbiAgICAgICAgICAgIHJlYWxULFxuICAgICAgICAgICAgcmVhbEIsXG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgIH0sXG4gICAgcmVzZXRTY29sbEJhclN0YXR1cygpIHtcbiAgICAgICAgaWYodGhpcy5fc2Nyb2xsYmFyRW5hYmxlKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3Njcm9sbEJhclN0YXR1cywge1xuICAgICAgICAgICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgICAgICAgICAgeDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXJTY3JvbGxCYXIoY3R4KSB7XG4gICAgICAgIGlmKHRoaXMuX3Njcm9sbGJhckVuYWJsZSkge1xuICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgY3R4LnNjYWxlKHRoaXMuZHByLCB0aGlzLmRwcik7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgeHNjYWxlLFxuICAgICAgICAgICAgICAgIHlzY2FsZVxuICAgICAgICAgICAgfSA9IHRoaXMuX3Njcm9sbEJhclN0YXR1cztcbiAgICAgICAgICAgIGlmKHhzY2FsZSA8IDEpICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWC5yZW5kZXIoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHlzY2FsZSA8IDEpICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWS5yZW5kZXIoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0iLCJcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIHRvZ2dsZVJlbmRlcih2YWwpIHtcbiAgICAgICAgdGhpcy5fX3JlbmRlcnN0b3BfXyA9ICF2YWw7XG4gICAgfSxcbiAgICBpbml0U2NoZWR1bGUoKSB7XG4gICAgICAgIHRoaXMuX19jbG9ja19fID0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgc2NoZWR1bGVSZW5kZXIoY2FsbGJhY2spIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCh0aW1lc3RhbXApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzRmlyc3RUaW1lID0gdGhpcy5fX2Nsb2NrX18gIT09IHRpbWVzdGFtcFxuICAgICAgICAgICAgaWYoIXRoaXMuX19yZW5kZXJzdG9wX18gJiYgaXNGaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fcmVuZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRpbWVzdGFtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9fY2xvY2tfXyA9IHRpbWVzdGFtcDtcbiAgICAgICAgfSlcbiAgICB9XG59IiwiLyoqXG4gKiDkuovku7blpITnkIblh73mlbBcbiAqIEBuYW1lIEV2ZW50QWRhcHRlcn5IYW5kbGVyXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0g5Y6f55Sf5LqL5Lu2XG4gKiBAcGFyYW0ge0pGbG93fSBqZmxvdyAtIOW9k+WJjWpmbG93IOWvueixoVxuICovXG5cbi8qKlxuICogRXZlbnRBZGFwdGVyIOWvueixoSBwbHVnaW4g6YWN572uXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBFdmVudEFkYXB0ZXJ+cGx1Z2luRGVmXG4gKiBAcHJvcGVydHkge09iamVjdH0gY2FudmFzIC0gY2FudmFzIOebuOWFs+eahOS6i+S7tlxuICogQHByb3BlcnR5IHtFdmVudEFkYXB0ZXJ+SGFuZGxlcn0gY2FudmFzLmV2ZW50TmFtZSAtIOazqOWGjCBjYW52YXMg5LiK55qE5LqL5Lu25aSE55CGXG4gKiBAcHJvcGVydHkge09iamVjdH0gZG9jdW1lbnQgLSBkb2N1bWVudCDnm7jlhbPnmoTkuovku7ZcbiAqIEBwcm9wZXJ0eSB7RXZlbnRBZGFwdGVyfkhhbmRsZXJ9IGRvY3VtZW50LmV2ZW50TmFtZSAtIOazqOWGjCBkb2N1bWVudCDkuIrnmoTkuovku7blpITnkIZcbiAqL1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0UGx1Z2luKCkge1xuICAgIGxldCBfbW91c2VTdGF0dXMgPSB7XG4gICAgICAgIC8vIHg6IHVuZGVmaW5lZCxcbiAgICAgICAgLy8geTogdW5kZWZpbmVkLFxuICAgICAgICAvLyBlbmFibGVDbGljazogZmFsc2UsXG4gICAgICAgIHBvaW50ZXJEb3duOiBmYWxzZSxcbiAgICAgICAgZGlydHk6IGZhbHNlLFxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjYW52YXM6IHtcbiAgICAgICAgICAgIHdoZWVsOiBmdW5jdGlvbiAoZXZlbnQsIGpmbG93KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBvZmZzZXRYLCBvZmZzZXRZLCBkZWx0YVgsIGRlbHRhWSB9ID0gZXZlbnRcbiAgICAgICAgICAgICAgICBpZihldmVudC5jdHJsS2V5KSB7IFxuICAgICAgICAgICAgICAgICAgICBkZWx0YVkgPSAtZGVsdGFZO1xuICAgICAgICAgICAgICAgICAgICBqZmxvdy56b29tSGFuZGxlcihvZmZzZXRYLCBvZmZzZXRZLCBkZWx0YVgsIGRlbHRhWSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGpmbG93LnBhbkhhbmRsZXIoLWRlbHRhWCwgLWRlbHRhWSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb2ludGVyZG93bjogZnVuY3Rpb24gKGV2ZW50LCBqZmxvdykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSwgZGVsdGFZLCBidXR0b24gfSA9IGV2ZW50XG4gICAgICAgICAgICAgICAgaWYoYnV0dG9uICE9PSAwKSByZXR1cm47XG4gICAgICAgICAgICAgICAgX21vdXNlU3RhdHVzLnBvaW50ZXJEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBqZmxvdy5wcmVzc1N0YXJ0SGFuZGxlcihvZmZzZXRYLCBvZmZzZXRZLCBldmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9pbnRlcm1vdmU6IGZ1bmN0aW9uIChldmVudCwgamZsb3cpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGV2ZW50XG4gICAgICAgICAgICAgICAgaWYoX21vdXNlU3RhdHVzLnBvaW50ZXJEb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIF9tb3VzZVN0YXR1cy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGpmbG93LnByZXNzTW92ZUhhbmRsZXIob2Zmc2V0WCwgb2Zmc2V0WSwgZXZlbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvaW50ZXJ1cDogZnVuY3Rpb24gKGV2ZW50LCBqZmxvdykge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgLy8gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IEFMV0FZUyBFTkFCTEUgUFJPUEFHQVRJT04gXG4gICAgICAgICAgICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZLCBidXR0b24gfSA9IGV2ZW50XG4gICAgICAgICAgICAgICAgaWYoYnV0dG9uICE9PSAwKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYoX21vdXNlU3RhdHVzLnBvaW50ZXJEb3duICYmIF9tb3VzZVN0YXR1cy5kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBfbW91c2VTdGF0dXMucG9pbnRlckRvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX21vdXNlU3RhdHVzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGpmbG93LnByZXNzVXBIYW5sZGVyKGZhbHNlLCBldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRleHRtZW51OiBmdW5jdGlvbiAoZXZlbnQsIGpmbG93KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgIGpmbG93LmNvbnRleHRNZW51SGFubGRlcihvZmZzZXRYLCBvZmZzZXRZLCBldmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGJsY2xpY2s6IGZ1bmN0aW9uIChldmVudCwgamZsb3cpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgamZsb3cuZGJsY2xpY2tIYW5kbGVyKG9mZnNldFgsIG9mZnNldFksIGV2ZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGljazogZnVuY3Rpb24oZXZlbnQsIGpmbG93KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgIGlmKCFfbW91c2VTdGF0dXMuZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgX21vdXNlU3RhdHVzLnBvaW50ZXJEb3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIF9tb3VzZVN0YXR1cy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBqZmxvdy5jbGlja0hhbmxkZXIob2Zmc2V0WCwgb2Zmc2V0WSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZG9jdW1lbnQ6IHtcbiAgICAgICAgICAgIHBvaW50ZXJ1cDogZnVuY3Rpb24oZXZlbnQsIGpmbG93KSB7XG4gICAgICAgICAgICAgICAgamZsb3cucHJlc3NVcEhhbmxkZXIodHJ1ZSwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKiogXG4gKiBFdmVudEFkYXB0ZXIg5a+56LGhXG4gKiBFdmVudEFkYXB0ZXIg6YCa6L+HIHBsdWdpbiDnmoTlvaLlvI/lrp7njrDlpJrnp43kuqTkupLmlrnlvI/nmoTmmKDlsIRcbiAqIEBjb25zdHJ1Y3RvciBFdmVudEFkYXB0ZXJcbiAqL1xuY2xhc3MgRXZlbnRBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwbHVnaW4gPSB7fSkge1xuICAgICAgICB0aGlzLnBsdWdpbiA9IGdldERlZmF1bHRQbHVnaW4oKTtcbiAgICAgICAgdGhpcy51c2UocGx1Z2luKTtcbiAgICAgICAgdGhpcy5jYW52YXNIYW5kbGVycyA9IFtdO1xuICAgICAgICB0aGlzLmRvY3VtZW50SGFuZGxlcnMgPSBbXTtcbiAgICB9XG4gICAgdXNlKHBsdWdpbiA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgY2FudmFzOiBjYSwgZG9jdW1lbnQ6IGRvY09iaiB9ID0gcGx1Z2luO1xuICAgICAgICBpZihjYSkge1xuICAgICAgICAgICAgZm9yKGxldCBldmVudE5hbWUgaW4gY2Epe1xuICAgICAgICAgICAgICAgIGlmIChjYS5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLmNhbnZhc1tldmVudE5hbWVdID0gY2FbZXZlbnROYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoZG9jT2JqKSB7XG4gICAgICAgICAgICBmb3IobGV0IGV2ZW50TmFtZSBpbiBkb2NPYmope1xuICAgICAgICAgICAgICAgIGlmIChkb2NPYmouaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5kb2N1bWVudFtldmVudE5hbWVdID0gZG9jT2JqW2V2ZW50TmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXBwbHkoamZsb3cpIHtcbiAgICAgICAgY29uc3QgeyBjYW52YXM6IGNhLCBkb2N1bWVudDogZG9jT2JqIH0gPSB0aGlzLnBsdWdpbjtcbiAgICAgICAgY29uc3QgY2FudmFzID0gamZsb3cuY2FudmFzO1xuICAgICAgICBmb3IobGV0IGV2ZW50TmFtZSBpbiBjYSl7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gY2FbZXZlbnROYW1lXTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZXJXcmFwcGVyZCAoZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoZSwgamZsb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyV3JhcHBlcmQpXG4gICAgICAgICAgICB0aGlzLmNhbnZhc0hhbmRsZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgICBoYW5kbGVyV3JhcHBlcmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvcihsZXQgZXZlbnROYW1lIGluIGRvY09iail7XG4gICAgICAgICAgICBsZXQgaGFuZGxlcjtcbiAgICAgICAgICAgIGxldCBvcHRpb25zID0ge31cbiAgICAgICAgICAgIGlmKHR5cGVvZiBkb2NPYmpbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBkb2NPYmpbZXZlbnROYW1lXVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gZG9jT2JqW2V2ZW50TmFtZV0uaGFuZGxlcjtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIGRvY09ialtldmVudE5hbWVdLm9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgZnVuY3Rpb24gaGFuZGxlcldyYXBwZXJkIChlKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcihlLCBqZmxvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcldyYXBwZXJkLCBvcHRpb25zKVxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudEhhbmRsZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgICBoYW5kbGVyV3JhcHBlcmQsXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxvYWQoamZsb3cpIHtcbiAgICAgICAgY29uc3QgY2FudmFzID0gamZsb3cuY2FudmFzO1xuICAgICAgICB0aGlzLmNhbnZhc0hhbmRsZXJzLmZvckVhY2goKHsgZXZlbnROYW1lLCBoYW5kbGVyV3JhcHBlcmQgfSkgPT4ge1xuICAgICAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyV3JhcHBlcmQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kb2N1bWVudEhhbmRsZXJzLmZvckVhY2goKHsgZXZlbnROYW1lLCBoYW5kbGVyV3JhcHBlcmQsIG9wdGlvbnMgfSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3VubG9hZCcsIGV2ZW50TmFtZSlcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyV3JhcHBlcmQsIG9wdGlvbnMpO1xuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRBZGFwdGVyO1xuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi9ub2RlJztcbmltcG9ydCBTdGFja01peGluIGZyb20gJy4vc3RhY2tNaXhpbic7XG5pbXBvcnQgTGF5b3V0TWl4aW4gZnJvbSAnLi9sYXlvdXRNaXhpbic7XG5pbXBvcnQgeyBib3VuZGluZ19ib3ggfSBmcm9tICcuLi91dGlscy9mdW5jdGlvbnMnO1xuaW1wb3J0IHsgRElSRUNUSU9OIH0gZnJvbSAnLi4vdXRpbHMvY29uc3RhbmNlJztcbmNvbnN0IEdyb3VwTWl4aW4gPSB7XG4gICAgLi4uU3RhY2tNaXhpbixcbiAgICAuLi5MYXlvdXRNaXhpbixcbiAgICBfc2V0UGFkZGluZyhjb25maWdzKSB7XG4gICAgICAgIHRoaXMucGFkZGluZyA9IHtcbiAgICAgICAgICAgIHRvcDogY29uZmlncy5wYWRkaW5nVG9wIHx8IGNvbmZpZ3MucGFkZGluZyB8fCAwLFxuICAgICAgICAgICAgcmlnaHQ6IGNvbmZpZ3MucGFkZGluZ1JpZ2h0IHx8IGNvbmZpZ3MucGFkZGluZyB8fCAwLFxuICAgICAgICAgICAgYm90dG9tOiBjb25maWdzLnBhZGRpbmdCb3R0b20gfHwgY29uZmlncy5wYWRkaW5nIHx8IDAsXG4gICAgICAgICAgICBsZWZ0OiBjb25maWdzLnBhZGRpbmdMZWZ0IHx8IGNvbmZpZ3MucGFkZGluZyB8fCAwLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgX3NldE1hcmdpbihjb25maWdzKSAge1xuICAgICAgICB0aGlzLm1hcmdpbiA9IHtcbiAgICAgICAgICAgIHRvcDogY29uZmlncy5tYXJnaW5Ub3AgfHwgY29uZmlncy5tYXJnaW4gfHwgMCxcbiAgICAgICAgICAgIHJpZ2h0OiBjb25maWdzLm1hcmdpblJpZ2h0IHx8IGNvbmZpZ3MubWFyZ2luIHx8IDAsXG4gICAgICAgICAgICBib3R0b206IGNvbmZpZ3MubWFyZ2luQm90dG9tIHx8IGNvbmZpZ3MubWFyZ2luIHx8IDAsXG4gICAgICAgICAgICBsZWZ0OiBjb25maWdzLm1hcmdpbkxlZnQgfHwgY29uZmlncy5tYXJnaW4gfHwgMCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIF9nZXRDZW50ZXIoKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5wYWRkaW5nO1xuICAgICAgICBjb25zdCBtYXJnaW4gPSB0aGlzLm1hcmdpbjtcbiAgICAgICAgY29uc3QgbXggPSAobWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQpLzI7XG4gICAgICAgIGNvbnN0IG15ID0gKG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tKS8yO1xuICAgICAgICBjb25zdCBjZW50ZXJYID0gKHBhZGRpbmcubGVmdCAtIHBhZGRpbmcucmlnaHQpLzIgKyBteDtcbiAgICAgICAgY29uc3QgY2VudGVyWSA9IChwYWRkaW5nLnRvcCAtIHBhZGRpbmcuYm90dG9tKS8yICsgbXk7XG4gICAgICAgIHRoaXMuX3NoYXBlLmFuY2hvciA9IFthbmNob3JbMF0gKyBteCwgYW5jaG9yWzFdICsgbXldO1xuICAgICAgICB0aGlzLl9jZW50ZXJbMF0gPSBhbmNob3JbMF0gKyBjZW50ZXJYO1xuICAgICAgICB0aGlzLl9jZW50ZXJbMV0gPSBhbmNob3JbMV0gKyBjZW50ZXJZO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2VudGVyO1xuICAgIH0sXG4gICAgc2V0QW5jaG9yWCh4KSB7XG4gICAgICAgIHRoaXMuYW5jaG9yWzBdID0geDtcbiAgICAgICAgdGhpcy5fZ2V0Q2VudGVyKCk7IFxuICAgIH0sXG4gICAgc2V0QW5jaG9yWSh5KSB7XG4gICAgICAgIHRoaXMuYW5jaG9yWzFdID0geTtcbiAgICAgICAgdGhpcy5fZ2V0Q2VudGVyKCk7IFxuICAgIH0sXG4gICAgc2V0QW5jaG9yKHgsIHkpIHtcbiAgICAgICAgdGhpcy5hbmNob3JbMF0gPSB4O1xuICAgICAgICB0aGlzLmFuY2hvclsxXSA9IHk7XG4gICAgICAgIHRoaXMuX2dldENlbnRlcigpOyBcbiAgICB9LFxuICAgIF9jYWxjdWxhdGVQb2ludEJhY2socG9pbnQpIHtcbiAgICAgICAgY29uc3QgW2d4LCBneV0gPSBwb2ludDtcbiAgICAgICAgY29uc3QgW2N4LCBjeV0gPSB0aGlzLl9nZXRDZW50ZXIoKTsgXG4gICAgICAgIGNvbnN0IHAgPSBbZ3ggLSBjeCwgZ3kgLSBjeV1cbiAgICAgICAgcmV0dXJuIHBcbiAgICB9LFxuICAgIF9jYWxjdWxhdGVQb2ludEJhY2tXaXRoUG9pbnQoYSwgYiwgYXJyLCBpZHgxLCBpZHgyKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5wYWRkaW5nO1xuICAgICAgICBjb25zdCBtYXJnaW4gPSB0aGlzLm1hcmdpbjtcbiAgICAgICAgYXJyW2lkeDFdID0gYSAtICggYW5jaG9yWzBdICsgKHBhZGRpbmcubGVmdCAtIHBhZGRpbmcucmlnaHQpLzIgKyAobWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQpLzIgKTtcbiAgICAgICAgYXJyW2lkeDJdID0gYiAtICggYW5jaG9yWzFdICsgKHBhZGRpbmcudG9wIC0gcGFkZGluZy5ib3R0b20pLzIgKyAobWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20pLzIgKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIOWPjeeul+WbniBjYW52YXMg6aG25bGC5Z2Q5qCHXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJbXX0g5LiW55WM5Z2Q5qCHXG4gICAgICovXG4gICAgY2FsY3VsYXRlVG9Db29yZGluYXRpb24ocG9pbnQpIHtcbiAgICAgICAgY29uc3QgW2d4LCBneV0gPSBwb2ludDtcbiAgICAgICAgY29uc3QgW2N4LCBjeV0gPSB0aGlzLl9nZXRDZW50ZXIoKTsgXG4gICAgICAgIC8vIGNvbnN0IHAgPSBbY3ggKyBhbmNob3JbMF0gLSBzcGFuSCwgY3kgKyBhbmNob3JbMV0gLSBzcGFuVl07XG4gICAgICAgIGNvbnN0IHAgPSBbZ3ggKyBjeCwgZ3kgKyBjeV1cbiAgICAgICAgaWYodGhpcy5fYmVsb25ncyAmJiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbihwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiDlj43nrpflm57pobXpnaLnmoTlg4/ntKDlnZDmoIfvvIzph43ovb0ge0BsaW5rIEluc3RhbmNlI2NhbGN1bGF0ZVRvUmVhbFdvcmxkfVxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IHBvaW50XG4gICAgICogQHJldHVybiB7TnVtYmVyW119IOS4lueVjOWdkOagh1xuICAgICAqL1xuICAgIGNhbGN1bGF0ZVRvUmVhbFdvcmxkKHBvaW50KSB7XG4gICAgICAgIGNvbnN0IFtneCwgZ3ldID0gcG9pbnQ7XG4gICAgICAgIGNvbnN0IFtjeCwgY3ldID0gdGhpcy5fZ2V0Q2VudGVyKCk7IFxuICAgICAgICBjb25zdCBwID0gW2d4ICsgY3gsIGd5ICsgY3ldXG4gICAgICAgIGlmKHRoaXMuX2JlbG9uZ3MgJiYgdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb1JlYWxXb3JsZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9SZWFsV29ybGQocCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2FsY3VsYXRlVG9SZWFsV29ybGRXaXRoUG9pbnRlcihvdXRwb2ludCwgaW5wb2ludCkge1xuICAgICAgICBvdXRwb2ludFswXSA9IGlucG9pbnRbMF0gKyB0aGlzLl9jZW50ZXJbMF07XG4gICAgICAgIG91dHBvaW50WzFdID0gaW5wb2ludFsxXSArIHRoaXMuX2NlbnRlclsxXTtcbiAgICAgICAgaWYodGhpcy5fYmVsb25ncyAmJiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvUmVhbFdvcmxkV2l0aFBvaW50ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvUmVhbFdvcmxkV2l0aFBvaW50ZXIob3V0cG9pbnQsIG91dHBvaW50KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IEMgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICBjb25zdCBjb25maWdzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fcmF3Q29uZmlncywge1xuICAgICAgICAgICAgbGF5b3V0OiB0aGlzLl9sYXlvdXQgJiYgdGhpcy5fbGF5b3V0LmNsb25lKCksXG4gICAgICAgIH0pXG4gICAgICAgIGNvbnN0IHQgPSBuZXcgQyhjb25maWdzKTtcbiAgICAgICAgdGhpcy5pbnRlcmF0ZU5vZGVTdGFjaygoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICAgIHQuYWRkVG9TdGFjayhpbnN0YW5jZS5jbG9uZSgpKTtcbiAgICAgICAgfSlcbiAgICAgICAgdC5yZWNhbGN1bGF0ZSgpO1xuICAgICAgICB0LnZpc2libGUgPSB0aGlzLnZpc2libGU7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH0sXG4gICAgZ2V0Qm91bmRpbmdEaW1lbnNpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldEJvdW5kaW5nUmVjdCgpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoIC8yO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgY29uc3QgbHR4ID0gYW5jaG9yWzBdIC0gdztcbiAgICAgICAgY29uc3QgbHR5ID0gYW5jaG9yWzFdIC0gaDtcbiAgICAgICAgY29uc3QgcmJ4ID0gYW5jaG9yWzBdICsgdztcbiAgICAgICAgY29uc3QgcmJ5ID0gYW5jaG9yWzFdICsgaDtcbiAgICAgICAgY29uc3QgYnIgPSB0aGlzLl9ib3VuZGluZ3JlY3Q7XG4gICAgICAgIGJyWzBdID0gbHR4O1xuICAgICAgICBiclsxXSA9IGx0eTtcbiAgICAgICAgYnJbMl0gPSByYng7XG4gICAgICAgIGJyWzNdID0gcmJ5O1xuICAgICAgICByZXR1cm4gYnJcbiAgICB9LFxuICAgIGdldEludGVyc2VjdGlvbnNJbkZvdXJEaW1lbnNpb24oKSB7XG4gICAgICAgIGxldCBwMiA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBpZih0aGlzLl9iZWxvbmdzICYmIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24pIHtcbiAgICAgICAgICAgIHAyID0gdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbihwMik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBbeDIsIHkyXSA9IHAyO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aC8yO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtESVJFQ1RJT04uUklHSFRdOiAgW3gyK3csIHkyXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uTEVGVF06ICAgW3gyLXcsIHkyXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uQk9UVE9NXTogW3gyLCB5MitoXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uVE9QXTogICAgW3gyLCB5Mi1oXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uU0VMRl06ICAgW3gyK3cqMC42MTgsIHkyK2gqMC42MThdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNhbGN1bGF0ZUludGVyc2VjdGlvbihwb2ludCkge1xuICAgICAgICBjb25zdCBbeDEsIHkxXSA9IHBvaW50O1xuICAgICAgICBjb25zdCBbeDIsIHkyXSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aC8yO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgY29uc3QgdmVjeCA9IHgyIC0geDE7XG4gICAgICAgIGNvbnN0IHZlY3kgPSB5MiAtIHkxO1xuICAgICAgICBjb25zdCB0aGV0YTEgPSBoL3c7XG4gICAgICAgIGNvbnN0IHRoZXRhMiA9IE1hdGguYWJzKHZlY3kvdmVjeCk7XG4gICAgICAgIGNvbnN0IGRpcnggPSB4MSA+IHgyO1xuICAgICAgICBjb25zdCBkaXJ5ID0geTEgPiB5MjtcbiAgICAgICAgbGV0IHgsIHk7XG4gICAgICAgIGlmKHRoZXRhMiA8IHRoZXRhMSkge1xuICAgICAgICAgICAgeCA9IHgyICsgKGRpcng/dzotdyk7XG4gICAgICAgICAgICB5ID0gdyAqIChkaXJ5P3RoZXRhMjotdGhldGEyKSArIHkyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeSA9IHkyICsgKGRpcnk/aDotaCk7XG4gICAgICAgICAgICB4ID0gaCAvIChkaXJ4P3RoZXRhMjotdGhldGEyKSArIHgyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfSxcbiAgICBvbkVudGVyVmlld2JveCgpIHtcbiAgICAgICAgdGhpcy5pbnRlcmF0ZU5vZGVTdGFjaygoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICAgIGluc3RhbmNlLm9uRW50ZXJWaWV3Ym94KCk7XG4gICAgICAgIH0pXG4gICAgfSxcbiAgICBvbkxlYXZlVmlld2JveCgpIHtcbiAgICAgICAgdGhpcy5pbnRlcmF0ZU5vZGVTdGFjaygoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICAgIGluc3RhbmNlLm9uTGVhdmVWaWV3Ym94KCk7XG4gICAgICAgIH0pXG4gICAgfSxcbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9zaGFwZS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaW50ZXJhdGVOb2RlU3RhY2soKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICBpbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICAgIH0pXG4gICAgfSxcbiAgICBcbiAgICBkb1JlY2FsY3VsYXRlKCkge1xuICAgICAgICBpZih0aGlzLl9fbW91bnRlZF9fKSB7XG4gICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlVXAoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5fX21vdW50ZWRfXyA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFNoaWZ0KHdpZHRoLCBoZWlnaHQpIHtcbiAgICByZXR1cm4gW3dpZHRoLCBoZWlnaHRdO1xufVxuXG4vKipcbiAqIOagueaNrnBhZGRpbmdib3jlrr3pq5jmnaXorqHnrpdzaGFwZXNoaWZ0Ym9455qE5a696auYXG4gKiBAZnVuY3Rpb24gc2hhcGVTaGlmdFxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoICAgICAgICAgICAgLSBwYWRkaW5nQm945a69XG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0ICAgICAgICAgICAtIHBhZGRpbmdCb3jpq5hcbiAqIEByZXR1cm4ge251bWJlcltdfVxuICovXG5cbi8qKlxuICog57uE5bel5Y6C5Ye95pWw77yM55So5LqO6YCa6L+HSkZsb3cg57uY5Zu+6IqC54K55p2l5Yib5bu65LiN5ZCM55qE57uEXG4gKiBAZ2xvYmFsIFxuICogQGZ1bmN0aW9uIEdyb3VwRmFjdG9yeVxuICogQHBhcmFtIHtOb2RlfSBqZmxvd05vZGVDb25zdHJ1Y3RvciAtIOe7mOWbvuiKgueCueaehOmAoOWZqFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgICAgICAgICAgICAtIOmFjee9rumhuVxuICogQHBhcmFtIHtzaGFwZVNoaWZ0fSBvcHRpb25zLnNoYXBlU2hpZnQgLSBzaGlmdOWxgumAgumFjeaWueazlVxuICogQHJldHVybiB7R3JvdXB9IC0g57uY5Zu+6IqC54K55p6E6YCg5ZmoXG4gKi9cbmZ1bmN0aW9uIEdyb3VwRmFjdG9yeShqZmxvd05vZGVDb25zdHJ1Y3Rvciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgc2hhcGVTaGlmdCA9IHR5cGVvZiBvcHRpb25zLnNoYXBlU2hpZnQgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnNoYXBlU2hpZnQgOiBkZWZhdWx0U2hpZnQ7XG5cbiAgICAvKipcbiAgICAgKiBHcm91cCDphY3nva5cbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBHcm91cFRlbXBsYXRlfkdyb3VwQ29uZmlnc1xuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aCAgICAgICAgICAgICAtIOiuvuWumuWuveW6plxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5XaWR0aCAgICAgICAgICAtIOacgOWwj+WuveW6plxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgICAgICAgICAgICAtIOiuvuWumumrmOW6plxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwYWRkaW5nICAgICAgICAgIC0g5YaF6L656LedXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHBhZGRpbmdUb3AgICAgICAgICAgLSDlhoXkuIrovrnot51cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcGFkZGluZ1JpZ2h0ICAgICAgICAgLSDlhoXlj7Povrnot51cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcGFkZGluZ0JvdHRvbSAgICAgICAgLSDlhoXkuIvovrnot51cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcGFkZGluZ0xlZnQgICAgICAgICAgLSDlhoXlt6bovrnot51cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWFyZ2luICAgICAgICAgICAgLSDlpJbovrnot51cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWFyZ2luVG9wICAgICAgICAgIC0g5aSW5LiK6L656LedXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1hcmdpblJpZ2h0ICAgICAgICAgLSDlpJblj7Povrnot51cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWFyZ2luQm90dG9tICAgICAgICAtIOWkluS4i+i+uei3nVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXJnaW5MZWZ0ICAgICAgICAgIC0g5aSW5bem6L656LedXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBsb2NrICAgICAgICAgICAgLSDluIPlsYDplIHlrprnirbmgIEg6buY6K6kIHRydWVcbiAgICAgKi9cbiAgICBjbGFzcyB0IGV4dGVuZHMgTm9kZSB7XG4gICAgICAgIC8qKlxuICAgICAgICAqIEBjb25zdHJ1Y3RzIEdyb3VwVGVtcGxhdGVcbiAgICAgICAgKiBAcGFyYW0ge0dyb3VwVGVtcGxhdGV+R3JvdXBDb25maWdzfSBjb25maWdzIC0g57uE6YWN572uXG4gICAgICAgICogQG1peGVzIExheW91dE1peGluXG4gICAgICAgICogQG1peGVzIFN0YWNrTWl4aW4gXG4gICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3MpIHtcbiAgICAgICAgICAgIHN1cGVyKGNvbmZpZ3MpO1xuICAgICAgICAgICAgdGhpcy5pbml0U3RhY2soY29uZmlncyk7XG4gICAgICAgICAgICB0aGlzLmluaXRMYXlvdXQoY29uZmlncyk7XG4gICAgICAgICAgICAvKiogQG1lbWJlciB7Tm9kZX0gICAgICAtIOWjs+e7mOWbvuWNleWFgyAqL1xuICAgICAgICAgICAgdGhpcy5fc2hhcGUgPSBuZXcgamZsb3dOb2RlQ29uc3RydWN0b3IoY29uZmlncyk7XG4gICAgICAgICAgICB0aGlzLl9zaGFwZS5hbmNob3IgPSBbMCwgMF07XG4gICAgICAgICAgICB0aGlzLl9zaGFwZS5fYmVsb25ncyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9jZW50ZXIgPSBbMCwwXTtcbiAgICAgICAgICAgIHRoaXMuX3NldFBhZGRpbmcoY29uZmlncyk7XG4gICAgICAgICAgICB0aGlzLl9zZXRNYXJnaW4oY29uZmlncyk7ICBcbiAgICAgICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgICAgLSDorr7lrprlrr3luqYgKi9cbiAgICAgICAgICAgIHRoaXMuZGVmaW5lZFdpZHRoID0gICAgIGNvbmZpZ3Mud2lkdGg7XG4gICAgICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAgIC0g5pyA5bCP5a695bqmICovXG4gICAgICAgICAgICB0aGlzLm1pbldpZHRoID0gICAgICAgICBjb25maWdzLm1pbldpZHRoO1xuICAgICAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgICAtIOiuvuWumueahOmrmOW6piAqL1xuICAgICAgICAgICAgdGhpcy5kZWZpbmVkSGVpZ2h0ID0gICAgY29uZmlncy5oZWlnaHQ7XG4gICAgICAgICAgICAvKiogQG1lbWJlciB7Qm9vbGVhbn0gICAgICAtIOe7hOWGheWFg+e0oOaYr+WQpumUgeWumu+8jCDpu5jorqR0cnVlICovXG4gICAgICAgICAgICB0aGlzLmxvY2sgPSAgICAgICAgICAgICBjb25maWdzLmxvY2sgPz8gdHJ1ZSA7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkgPSAgICAgICAgICBjb25maWdzLmRpc3BsYXkgfHwgJ2RlZmF1bHQnO1xuICAgICAgICAgICAgLyoqIEBtZW1iZXIge0Jvb2xlYW59ICAgICAgLSDnu4TmnKzouqvmmK/lkKbov5vlhaXlvaLnirbliKTlrprojIPlm7QgKi9cbiAgICAgICAgICAgIHRoaXMudHJhbnNwYXJlbnQgPSAgICAgIGNvbmZpZ3MudHJhbnNwYXJlbnQgPz8gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9nZXRCb3VuZGluZ0dyb3VwUmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5yZWZsb3coKTtcbiAgICAgICAgICAgIHRoaXMuX2dldEJvdW5kaW5nR3JvdXBSZWN0KCk7ICBcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlVmlld0JveCA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odC5wcm90b3R5cGUsIEdyb3VwTWl4aW4pO1xuICAgIE9iamVjdC5hc3NpZ24odC5wcm90b3R5cGUsIHsgXG4gICAgICAgIHJlZmxvdygpIHtcbiAgICAgICAgICAgIEdyb3VwTWl4aW4ucmVmbG93LmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjb25zdCBtYXJnaW4gPSB0aGlzLm1hcmdpbjtcbiAgICAgICAgICAgIGNvbnN0IFtzaGFwZVdpZHRoLCBzaGFwZUhlaWdodF0gPSBzaGFwZVNoaWZ0KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLndpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20sIHRoaXMuX3NoYXBlKTtcbiAgICAgICAgICAgIHRoaXMuX3NoYXBlLndpZHRoID0gc2hhcGVXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuX3NoYXBlLmhlaWdodCA9IHNoYXBlSGVpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBzZXRDb25maWcoY29uZmlncykge1xuICAgICAgICAgICAgdGhpcy5fc2hhcGUuc2V0Q29uZmlnKGNvbmZpZ3MpO1xuICAgICAgICAgICAgdGhpcy5fc2V0UGFkZGluZyhjb25maWdzKTtcbiAgICAgICAgICAgIHRoaXMuX3NldE1hcmdpbihjb25maWdzKTsgIFxuICAgICAgICAgICAgaWYoJ29wYWNpdHknIGluIGNvbmZpZ3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSBjb25maWdzLm9wYWNpdHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoY29uZmlncy5sYXlvdXQgJiYgdGhpcy5fbGF5b3V0ICE9PSBjb25maWdzLmxheW91dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dCA9IGNvbmZpZ3MubGF5b3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfZ2V0Qm91bmRpbmdHcm91cFJlY3QoKSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9zdGFjay5nZXRCb3VuZGluZ1JlY3RQb2ludHMoKTtcbiAgICAgICAgICAgIC8vIGNvbnRlbnQgYm94IFxuICAgICAgICAgICAgY29uc3QgYmJveCA9IGJvdW5kaW5nX2JveChwb2ludHMpO1xuXG4gICAgICAgICAgICAgLy8gcGFkZGluZyBib3ggXG4gICAgICAgICAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5wYWRkaW5nO1xuICAgICAgICAgICAgY29uc3QgbWluV2lkdGggPSB0aGlzLm1pbldpZHRoLy8gLSBwYWRkaW5nLmxlZnQgLSBwYWRkaW5nLnJpZ2h0O1xuICAgICAgICAgICAgY29uc3QgZGVmaW5lZFdpZHRoID0gdGhpcy5kZWZpbmVkV2lkdGgvLyAtIHBhZGRpbmcubGVmdCAtIHBhZGRpbmcucmlnaHQ7XG4gICAgICAgICAgICBjb25zdCB3ID0gYmJveC53aWR0aCArIHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQ7XG4gICAgICAgICAgICBjb25zdCBoID0gYmJveC5oZWlnaHQgKyBwYWRkaW5nLnRvcCArIHBhZGRpbmcuYm90dG9tO1xuICAgICAgICAgICAgY29uc3QgcGFkZGluZ1dpZHRoID0gbWluV2lkdGggPyBNYXRoLm1heChtaW5XaWR0aCwgdykgOiBkZWZpbmVkV2lkdGggfHwgdztcbiAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdIZWlnaHQgPSB0aGlzLmRlZmluZWRIZWlnaHQgfHwgaDtcbiAgICAgICAgICAgIHRoaXMuX3BhZGRpbmdXaWR0aCA9IHBhZGRpbmdXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuX3BhZGRpbmdIZWlnaHQgPSBwYWRkaW5nSGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBzaGFwZUJveFxuICAgICAgICAgICAgY29uc3QgW3NoYXBlV2lkdGgsIHNoYXBlSGVpZ2h0XSA9IHNoYXBlU2hpZnQocGFkZGluZ1dpZHRoLCBwYWRkaW5nSGVpZ2h0LCB0aGlzLl9zaGFwZSlcbiAgICAgICAgICAgIHRoaXMuX3NoYXBlLndpZHRoID0gc2hhcGVXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuX3NoYXBlLmhlaWdodCA9IHNoYXBlSGVpZ2h0O1xuICAgICAgICAgICAgLy8gbWFyZ2luQm94XG4gICAgICAgICAgICBjb25zdCBtYXJnaW4gPSB0aGlzLm1hcmdpbjtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBzaGFwZVdpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHNoYXBlSGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b207XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFZpZXdCb3goKSB7XG4gICAgICAgICAgICBjb25zdCBiZWxvbmdzX3Zib3ggPSB0aGlzLl9iZWxvbmdzLmdldENhY2hlVmlld0JveCgpO1xuICAgICAgICAgICAgY29uc3QgY2FjaGVWaWV3Qm94ID0gdGhpcy5fY2FjaGVWaWV3Qm94O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVQb2ludEJhY2tXaXRoUG9pbnQoYmVsb25nc192Ym94WzBdLCBiZWxvbmdzX3Zib3hbMV0sIGNhY2hlVmlld0JveCwgMCwgMSk7XG4gICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVQb2ludEJhY2tXaXRoUG9pbnQoYmVsb25nc192Ym94WzJdLCBiZWxvbmdzX3Zib3hbM10sIGNhY2hlVmlld0JveCwgMiwgMyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVWaWV3Qm94O1xuICAgICAgICB9LFxuICAgICAgICBnZXRDYWNoZVZpZXdCb3goKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVWaWV3Qm94O1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgcmVuZGVyKGN0eCkge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGlmKHRoaXMuX2lzTW92aW5nKXtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjZcbiAgICAgICAgICAgIH0gZWxzZSBpZih0aGlzLm9wYWNpdHkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLm9wYWNpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbY3gsIGN5XSA9IHRoaXMuX2dldENlbnRlcigpOyBcbiAgICAgICAgICAgIHRoaXMuX3NoYXBlLnJlbmRlcihjdHgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjeCwgY3kpO1xuICAgICAgICAgICAgdGhpcy5fc3RhY2sucmVuZGVyKGN0eCk7XG4gICAgICAgICAgICAvLyB0aGlzLl9saW5rU3RhY2sucmVuZGVyKGN0eCk7ICAgIFxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAgICAgICAvLyBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgLy8gY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgLy8gY3R4LmFyYyhjeCwgY3ksIDUsIDAsIE1hdGguUEkqMik7XG4gICAgICAgICAgICAvLyBjdHguZmlsbFN0eWxlID0gJ3JnYigwLDAsMCknXG4gICAgICAgICAgICAvLyBjdHguZmlsbCgpO1xuICAgICAgICAgICAgLy8gY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNIaXQocG9pbnQsIGNvbmRpdGlvbikge1xuICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuX2NhbGN1bGF0ZVBvaW50QmFjayhwb2ludCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50cCA9IHA7IC8vIOaaguWtmO+8jOS4uuS6huWQjue7reiuoeeul+WIq+eahOS9jee9rlxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fc3RhY2suY2hlY2tIaXQocCwgY29uZGl0aW9uKTtcbiAgICAgICAgICAgIGlmKHRhcmdldCkgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGlmKCF0aGlzLnRyYW5zcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NoYXBlLmlzSGl0KHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSwgICAgXG4gICAgfSk7XG4gICAgcmV0dXJuIHRcbn1cblxuZXhwb3J0IGRlZmF1bHQgR3JvdXBGYWN0b3J5O1xuXG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9ub2RlJztcbmltcG9ydCB7IERJUkVDVElPTiB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbnN0YW5jZSc7XG4vKipcbiAqIOWchuW9ouWNleWFgyDphY3nva5cbiAqIEB0eXBlZGVmIHtOb2RlfkNvbmZpZ3N9IFBvaW50flBvaW50Q29uZmlnc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHJhZGl1cyAgLSDljYrlvoRcbiAqL1xuLyoqXG4gKiDlnIblvaLoioLngrlcbiAqIEBjb25zdHJ1Y3RvciBQb2ludFxuICogQGV4dGVuZHMgTm9kZVxuICogQHBhcmFtIHtQb2ludH5Qb2ludENvbmZpZ3N9IGNvbmZpZ3MgLSDphY3nva5cbiAqL1xuY2xhc3MgUG9pbnQgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAgICAgICAgICAgICAnUG9pbnQnO1xuICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAgIC0g5Y2K5b6EICovXG4gICAgICAgIHRoaXMucmFkaXVzID0gICAgICAgICAgIGNvbmZpZ3MucmFkaXVzIHx8IDEwO1xuICAgICAgICB0aGlzLl9kb0NhY2hlKCk7XG4gICAgfVxuXG4gICAgc2V0Q29uZmlnKGNvbmZpZ3MpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoY29uZmlncykuZm9yRWFjaChrID0+IHtcbiAgICAgICAgICAgIGlmKGNvbmZpZ3Nba10gIT09IHVuZGVmaW5lZCAmJiBjb25maWdzW2tdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trXSA9IGNvbmZpZ3Nba107XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF3Q29uZmlnc1trXSA9IGNvbmZpZ3Nba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kb0NhY2hlKCk7XG4gICAgfVxuICAgIF9kb0NhY2hlKCkge1xuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5yYWRpdXMgKiAyO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMucmFkaXVzICogMjtcbiAgICB9XG5cbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGlmKHRoaXMuX2lzTW92aW5nKXtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNlxuICAgICAgICB9XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmFyYyh0aGlzLmFuY2hvclswXSwgdGhpcy5hbmNob3JbMV0sIHRoaXMucmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgaWYodGhpcy5ib3JkZXJXaWR0aCkge1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuYm9yZGVyV2lkdGg7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmJvcmRlckNvbG9yO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmKHRoaXMuX2lzVGFyZ2V0aW5nKSB7XG4gICAgICAgIC8vICAgICB0aGlzLnJlbmRlckZvY3VzKGN0eCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBpc0hpdChwb2ludCkge1xuICAgICAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KHBvaW50WzBdIC0gYW5jaG9yWzBdLCAyKSArIE1hdGgucG93KHBvaW50WzFdIC0gYW5jaG9yWzFdLCAyKSA8IHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXNcbiAgICB9XG5cbiAgICBnZXRCb3VuZGluZ1JlY3QoKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCByID0gdGhpcy5yYWRpdXM7XG4gICAgICAgIGNvbnN0IGx0eCA9IGFuY2hvclswXSAtIHI7XG4gICAgICAgIGNvbnN0IGx0eSA9IGFuY2hvclsxXSAtIHI7XG4gICAgICAgIGNvbnN0IHJieCA9IGFuY2hvclswXSArIHI7XG4gICAgICAgIGNvbnN0IHJieSA9IGFuY2hvclsxXSArIHI7XG4gICAgICAgIGNvbnN0IGJyID0gdGhpcy5fYm91bmRpbmdyZWN0O1xuICAgICAgICBiclswXSA9IGx0eDtcbiAgICAgICAgYnJbMV0gPSBsdHk7XG4gICAgICAgIGJyWzJdID0gcmJ4O1xuICAgICAgICBiclszXSA9IHJieTtcbiAgICAgICAgcmV0dXJuIGJyXG4gICAgfVxuXG4gICAgY2FsY3VsYXRlSW50ZXJzZWN0aW9uKHBvaW50KSB7XG4gICAgICAgIGNvbnN0IFt4MSwgeTFdID0gcG9pbnQ7XG4gICAgICAgIGNvbnN0IFt4MiwgeTJdID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IHZlY3ggPSB4MiAtIHgxO1xuICAgICAgICBjb25zdCB2ZWN5ID0geTIgLSB5MTtcbiAgICAgICAgY29uc3QgZGlzdCA9IE1hdGguc3FydCh2ZWN4ICogdmVjeCArIHZlY3kgKiB2ZWN5KTtcblxuICAgICAgICBjb25zdCByYXRpbyA9IHRoaXMucmFkaXVzIC8gZGlzdDtcbiAgICAgICAgcmV0dXJuIFt4MiAtIHJhdGlvICogdmVjeCwgeTIgLSByYXRpbyAqIHZlY3ldO1xuICAgIH1cblxuICAgIGdldEludGVyc2VjdGlvbnNJbkZvdXJEaW1lbnNpb24oKSB7XG4gICAgICAgIGNvbnN0IFt4MiwgeTJdID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLnJhZGl1cztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtESVJFQ1RJT04uUklHSFRdOiAgW3gyICsgciwgeTJdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5MRUZUXTogICBbeDIgLSByLCB5Ml0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLkJPVFRPTV06IFt4MiwgeTIrcl0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLlRPUF06ICAgIFt4MiwgeTItcl0sXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxjdWxhdGVJbnRlcnNlY3Rpb25JbkZvdXJEaW1lbnNpb24ocG9pbnQsIGVuZCkge1xuICAgICAgICBjb25zdCBbeDEsIHkxXSA9IHBvaW50O1xuICAgICAgICBjb25zdCBbeDIsIHkyXSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCByID0gdGhpcy5yYWRpdXM7XG4gICAgICAgIGNvbnN0IHZlY3ggPSB4MiAtIHgxO1xuICAgICAgICBjb25zdCB2ZWN5ID0geTIgLSB5MTtcbiAgICAgICAgY29uc3QgYWxsSW50ZXJzZWN0aW9ucyA9IHtcbiAgICAgICAgICAgIFtESVJFQ1RJT04uUklHSFRdOiAgW3gyICsgciwgeTJdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5MRUZUXTogICBbeDIgLSByLCB5Ml0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLkJPVFRPTV06IFt4MiwgeTIrcl0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLlRPUF06ICAgIFt4MiwgeTItcl0sXG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2coTWF0aC5hYnModmVjeCkgPiBNYXRoLmFicyh2ZWN5KSwgdmVjeCwgcilcbiAgICAgICAgLy8gaWYoKSB7XG4gICAgICAgIC8vICAgICByZXR1cm4ge1xuICAgICAgICAvLyAgICAgICAgIHA6IFt4MiArICh2ZWN4PDA/cjotciksIHkyXSxcbiAgICAgICAgLy8gICAgICAgICBkaXI6IHZlY3g8MCA/IERJUkVDVElPTi5SSUdIVCA6IERJUkVDVElPTi5MRUZULFxuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAvLyAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gICAgICAgICBwOiBbeDIsIHkyKyh2ZWN5PDA/cjotcildLFxuICAgICAgICAvLyAgICAgICAgIGRpcjogdmVjeTwwID8gRElSRUNUSU9OLkJPVFRPTSA6IERJUkVDVElPTi5UT1AsXG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cbiAgICAgICAgbGV0IGludGVyRGlyID0gKE1hdGguYWJzKHZlY3kpID4gTWF0aC5hYnModmVjeClcbiAgICAgICAgICAgID8gKHZlY3kgPCAwID8gRElSRUNUSU9OLkJPVFRPTSA6IERJUkVDVElPTi5UT1ApXG4gICAgICAgICAgICA6ICh2ZWN4IDwgMCA/IERJUkVDVElPTi5SSUdIVCA6IERJUkVDVElPTi5MRUZUKSk7XG5cbiAgICAgICAgLy8gaW50ZXJEaXIgPSB0aGlzLmNoZWNrTGlua2VkKGludGVyRGlyLCBlbmQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcDogYWxsSW50ZXJzZWN0aW9uc1tpbnRlckRpcl0sXG4gICAgICAgICAgICBkaXI6IGludGVyRGlyLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Qm91bmRpbmdEaW1lbnNpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBQb2ludDsiLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9ub2RlJztcbmltcG9ydCB7IERJUkVDVElPTiwgb3Bwb3NpdGVEaXJlY3Rpb24gfSBmcm9tICcuLi8uLi91dGlscy9jb25zdGFuY2UnO1xuLyoqXG4gKiBAdHlwZWRlZiBSZWN0YW5nbGV+Ym9yZGVyXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJvcmRlckNvbG9yICAgICAgLSDovrnmoYblrr3luqYsIOm7mOiupCAwXG4gKiBAcHJvcGVydHkge251bWJlcn0gYm9yZGVyV2lkdGggICAgICAtIOi+ueahhuminOiJsiwg6buY6K6kIHRyYW5zcGFyZW50XG4gKi9cbi8qKlxuICogQHR5cGVkZWYgUmVjdGFuZ2xlfmJvcmRlcnNcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvcGVydHkge1JlY3RhbmdsZX5ib3JkZXJ9IHRvcCAgICAgIC0g5LiK6L655qGGXG4gKiBAcHJvcGVydHkge1JlY3RhbmdsZX5ib3JkZXJ9IHJpZ2h0ICAgICAgLSDlj7PovrnmoYZcbiAqIEBwcm9wZXJ0eSB7UmVjdGFuZ2xlfmJvcmRlcn0gYm90dG9tICAgICAgLSDkuIvovrnmoYZcbiAqIEBwcm9wZXJ0eSB7UmVjdGFuZ2xlfmJvcmRlcn0gbGVmdCAgICAgIC0g5bem6L655qGGXG4gKi9cblxuLyoqXG4gKiDnn6nlvaLljZXlhYMg6YWN572uXG4gKiBAdHlwZWRlZiB7Tm9kZX5Db25maWdzfSBSZWN0YW5nbGV+UmVjdGFuZ2xlQ29uZmlnc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoIC0g5a69XG4gKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IC0g6auYXG4gKiBAcHJvcGVydHkge251bWJlcn0gYm9yZGVyUmFkaXVzIC0g5ZyG6KeS55+p5b2i5Y2K5b6EXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYm9yZGVyQ29sb3IgLSDovrnmoYbpopzoibIsIOm7mOiupCB0cmFuc3BhcmVudFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGJvcmRlcldpZHRoIC0g6L655qGG5a695bqmLCDpu5jorqQgMFxuICogQHByb3BlcnR5IHtSZWN0YW5nbGV+Ym9yZGVyc30gYm9yZGVyICAgICAgLSDovrnmoYborr7nva5cbiAqL1xuLyoqXG4gKiDnn6nlvaLljZXlhYNcbiAqIEBjb25zdHJ1Y3RvciBSZWN0YW5nbGVcbiAqIEBleHRlbmRzIE5vZGVcbiAqIEBwYXJhbSB7UmVjdGFuZ2xlflJlY3RhbmdsZUNvbmZpZ3N9IGNvbmZpZ3NcbiAqL1xuY2xhc3MgUmVjdGFuZ2xlIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlncyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAgICAgICAgICAgICAnUmVjdGFuZ2xlJztcbiAgICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgICAgLSDlrr0gKi9cbiAgICAgICAgdGhpcy53aWR0aCA9ICAgICAgICAgICAgY29uZmlncy53aWR0aCB8fCAxMDtcbiAgICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgICAgLSDpq5ggKi9cbiAgICAgICAgdGhpcy5oZWlnaHQgPSAgICAgICAgICAgY29uZmlncy5oZWlnaHQgfHwgMTA7XG4gICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAgIC0g5ZyG6KeS55+p5b2i5Y2K5b6EICovXG4gICAgICAgIHRoaXMuYm9yZGVyUmFkaXVzID0gICAgIGNvbmZpZ3MuYm9yZGVyUmFkaXVzIHx8IDA7XG4gICAgICAgIHRoaXMuX3NldEJvcmRlcihjb25maWdzKTtcbiAgICB9XG5cbiAgICBfc2V0Qm9yZGVyKGNvbmZpZ3Mpe1xuICAgICAgICAvKiogQG1lbWJlciB7UmVjdGFuZ2xlfmJvcmRlcnN9ICAgICAgLSDovrnmoYborr7nva7vvIzkvJjlhYjnuqfpq5jkuo4gYm9yZGVyV2lkdGjvvIxib3JkZXJDb2xvciAqL1xuICAgICAgICB0aGlzLmJvcmRlciA9IHtcbiAgICAgICAgICAgIHRvcDoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBjb25maWdzLmJvcmRlcj8udG9wPy5ib3JkZXJDb2xvciB8fCBjb25maWdzLmJvcmRlckNvbG9yIHx8ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGNvbmZpZ3MuYm9yZGVyPy50b3A/LmJvcmRlcldpZHRoIHx8IGNvbmZpZ3MuYm9yZGVyV2lkdGggfHwgMCxcbiAgICAgICAgICAgICAgICBlbmFibGU6IGNvbmZpZ3MuYm9yZGVyPy50b3A/LmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJpZ2h0OiB7XG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbmZpZ3MuYm9yZGVyPy5yaWdodD8uYm9yZGVyQ29sb3IgfHwgY29uZmlncy5ib3JkZXJDb2xvciB8fCAndHJhbnNwYXJlbnQnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBjb25maWdzLmJvcmRlcj8ucmlnaHQ/LmJvcmRlcldpZHRoIHx8IGNvbmZpZ3MuYm9yZGVyV2lkdGggfHwgMCxcbiAgICAgICAgICAgICAgICBlbmFibGU6IGNvbmZpZ3MuYm9yZGVyPy5yaWdodD8uYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm90dG9tOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbmZpZ3MuYm9yZGVyPy5ib3R0b20/LmJvcmRlckNvbG9yIHx8IGNvbmZpZ3MuYm9yZGVyQ29sb3IgfHwgJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgICB3aWR0aDogY29uZmlncy5ib3JkZXI/LmJvdHRvbT8uYm9yZGVyV2lkdGggfHwgY29uZmlncy5ib3JkZXJXaWR0aCB8fCAwLFxuICAgICAgICAgICAgICAgIGVuYWJsZTogY29uZmlncy5ib3JkZXI/LmJvdHRvbT8uYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVmdDoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBjb25maWdzLmJvcmRlcj8ubGVmdD8uYm9yZGVyQ29sb3IgfHwgY29uZmlncy5ib3JkZXJDb2xvciB8fCAndHJhbnNwYXJlbnQnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBjb25maWdzLmJvcmRlcj8ubGVmdD8uYm9yZGVyV2lkdGggfHwgY29uZmlncy5ib3JkZXJXaWR0aCB8fCAwLFxuICAgICAgICAgICAgICAgIGVuYWJsZTogY29uZmlncy5ib3JkZXI/LmxlZnQ/LmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJvcmRlckNvbG9yID0gY29uZmlncy5ib3JkZXJDb2xvciB8fCAndHJhbnNwYXJlbnQnO1xuICAgICAgICB0aGlzLmJvcmRlcldpZHRoID0gY29uZmlncy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIH1cblxuICAgIHNldENvbmZpZyhjb25maWdzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGNvbmZpZ3MpLmZvckVhY2goayA9PiB7XG4gICAgICAgICAgICBpZihjb25maWdzW2tdICE9PSB1bmRlZmluZWQgJiYgY29uZmlnc1trXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXNba10gPSBjb25maWdzW2tdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jhd0NvbmZpZ3Nba10gPSBjb25maWdzW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2V0Qm9yZGVyKGNvbmZpZ3MpO1xuICAgIH1cblxuICAgIHJlbmRlcihjdHgpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgaWYodGhpcy5faXNNb3Zpbmcpe1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC42XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IHJhZGl1cywgYW5jaG9yLCB3aWR0aCwgaGVpZ2h0XG4gICAgICAgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB4ID0gdGhpcy5hbmNob3JbMF0gLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMuYW5jaG9yWzFdIC0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgICBjb25zdCB4dCA9IHRoaXMuYW5jaG9yWzBdICsgdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIGNvbnN0IHl0ID0gdGhpcy5hbmNob3JbMV0gKyB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgIGlmKHRoaXMuYm9yZGVyUmFkaXVzKSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyByYWRpdXMsIHkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSByYWRpdXMsIHkpO1xuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByYWRpdXMpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgcmFkaXVzLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgcmFkaXVzKTtcbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByYWRpdXMsIHkpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpOyBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5yZWN0KHRoaXMuYW5jaG9yWzBdIC0gdGhpcy53aWR0aCAvIDIsIHRoaXMuYW5jaG9yWzFdIC0gdGhpcy5oZWlnaHQgLyAyLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5ib3JkZXJXaWR0aCkge1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuYm9yZGVyV2lkdGg7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmJvcmRlckNvbG9yO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLnNoYWRvd0NvbG9yICYmIHRoaXMuc2hhZG93Q29sb3IgIT09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHRoaXMuc2hhZG93Q29sb3I7XG4gICAgICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2pmbG93LnNjYWxlO1xuICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSB0aGlzLnNoYWRvd0JsdXIgKiBzY2FsZTtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gdGhpcy5zaGFkb3dPZmZzZXRYICogc2NhbGU7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHRoaXMuc2hhZG93T2Zmc2V0WSAqIHNjYWxlO1xuICAgICAgICAgICAgbGV0IHN3aXRjaFBhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgICAgICBpZih0aGlzLmJvcmRlclJhZGl1cykge1xuICAgICAgICAgICAgICAgIHN3aXRjaFBhdGgubW92ZVRvKHggKyByYWRpdXMsIHkpO1xuICAgICAgICAgICAgICAgIHN3aXRjaFBhdGgubGluZVRvKHggKyB3aWR0aCAtIHJhZGl1cywgeSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoUGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2hQYXRoLmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgICAgICAgICAgICAgIHN3aXRjaFBhdGgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoUGF0aC5saW5lVG8oeCArIHJhZGl1cywgeSArIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoUGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgICAgICAgICAgICAgIHN3aXRjaFBhdGgubGluZVRvKHgsIHkgKyByYWRpdXMpO1xuICAgICAgICAgICAgICAgIHN3aXRjaFBhdGgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcmFkaXVzLCB5KTtcbiAgICAgICAgICAgICAgICBzd2l0Y2hQYXRoLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2hQYXRoLnJlY3QodGhpcy5hbmNob3JbMF0gLSB0aGlzLndpZHRoIC8gMiwgdGhpcy5hbmNob3JbMV0gLSB0aGlzLmhlaWdodCAvIDIsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaFBhdGgucmVjdCh4IC0gMTAsIHkgLSAxMCwgdGhpcy53aWR0aCsgMjAsIHRoaXMuaGVpZ2h0KyAyMCk7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LmNsaXAoc3dpdGNoUGF0aCwgXCJldmVub2RkXCIpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfSAgXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgaWYodGhpcy5ib3JkZXJSYWRpdXMgJiYgdGhpcy5ib3JkZXJXaWR0aCkge1xuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gJ3RyYW5zcGFyZW50J1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLmJvcmRlclJhZGl1cykge1xuICAgICAgICAgICAgaWYodGhpcy5ib3JkZXIudG9wLmVuYWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5ID0geSAtIHRoaXMuYm9yZGVyLnRvcC53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5ib3JkZXIudG9wLndpZHRoKVxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBsZXQgdG9wUGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgICAgICAgICB0b3BQYXRoLm1vdmVUbyh4LCB0eSArIHJhZGl1cyk7XG4gICAgICAgICAgICAgICAgdG9wUGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHR5LCB4ICsgcmFkaXVzLCB0eSk7XG4gICAgICAgICAgICAgICAgdG9wUGF0aC5saW5lVG8oeCArIHdpZHRoIC0gcmFkaXVzLCB0eSk7XG4gICAgICAgICAgICAgICAgdG9wUGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgdHksIHggKyB3aWR0aCwgdHkgKyByYWRpdXMpO1xuICAgICAgICAgICAgICAgIHRvcFBhdGguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmNsaXAodG9wUGF0aCk7ICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gJ3RyYW5zcGFyZW50JztcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5ib3JkZXIudG9wLmNvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5yZWN0KHgsIHR5LCB0aGlzLndpZHRoLCB0aGlzLmJvcmRlci50b3Aud2lkdGgpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICAgICAgICAgIC8vIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAvLyBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIC8vIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAvLyBjdHgubW92ZVRvKHgsIHR5ICsgcmFkaXVzKTtcbiAgICAgICAgICAgICAgICAvLyBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB0eSwgeCArIHJhZGl1cywgdHkpO1xuICAgICAgICAgICAgICAgIC8vIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcmFkaXVzLCB0eSk7XG4gICAgICAgICAgICAgICAgLy8gY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB0eSwgeCArIHdpZHRoLCB0eSArIHJhZGl1cyk7XG4gICAgICAgICAgICAgICAgLy8gY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gLy8gY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAvLyBjdHguY2xpcCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIC8vIGN0eC5yZWN0KHgsIHR5LCB0aGlzLndpZHRoLCB0aGlzLmJvcmRlci50b3Aud2lkdGgpO1xuICAgICAgICAgICAgICAgIC8vIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJvcmRlci50b3AuY29sb3I7XG4gICAgICAgICAgICAgICAgLy8gY3R4LnNoYWRvd0NvbG9yID0gJ3RyYW5zcGFyZW50JztcbiAgICAgICAgICAgICAgICAvLyBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIC8vIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZih0aGlzLmJvcmRlci50b3Aud2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHh0LCB5KTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmJvcmRlci50b3AuY29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuYm9yZGVyLnRvcC53aWR0aDtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHRoaXMuYm9yZGVyLnJpZ2h0LndpZHRoKSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeHQsIHkpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeHQsIHl0KTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmJvcmRlci5yaWdodC5jb2xvcjtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5ib3JkZXIucmlnaHQud2lkdGg7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih0aGlzLmJvcmRlci5ib3R0b20ud2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4dCwgeXQpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeXQpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYm9yZGVyLmJvdHRvbS5jb2xvcjtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5ib3JkZXIuYm90dG9tLndpZHRoO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodGhpcy5ib3JkZXIubGVmdC53aWR0aCkge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHgsIHl0KTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYm9yZGVyLmxlZnQuY29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuYm9yZGVyLmxlZnQud2lkdGg7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgaXNIaXQocG9pbnQpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoIC8yO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgcmV0dXJuIHBvaW50WzBdID4gYW5jaG9yWzBdIC0gd1xuICAgICAgICAgICAgJiYgcG9pbnRbMF0gPCBhbmNob3JbMF0gKyB3XG4gICAgICAgICAgICAmJiBwb2ludFsxXSA+IGFuY2hvclsxXSAtIGhcbiAgICAgICAgICAgICYmIHBvaW50WzFdIDwgYW5jaG9yWzFdICsgaDtcbiAgICB9XG5cbiAgICBnZXRCb3VuZGluZ1JlY3QoKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aCAvMjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIGNvbnN0IGx0eCA9IGFuY2hvclswXSAtIHc7XG4gICAgICAgIGNvbnN0IGx0eSA9IGFuY2hvclsxXSAtIGg7XG4gICAgICAgIGNvbnN0IHJieCA9IGFuY2hvclswXSArIHc7XG4gICAgICAgIGNvbnN0IHJieSA9IGFuY2hvclsxXSArIGg7XG4gICAgICAgIGNvbnN0IGJyID0gdGhpcy5fYm91bmRpbmdyZWN0O1xuICAgICAgICBiclswXSA9IGx0eDtcbiAgICAgICAgYnJbMV0gPSBsdHk7XG4gICAgICAgIGJyWzJdID0gcmJ4O1xuICAgICAgICBiclszXSA9IHJieTtcbiAgICAgICAgcmV0dXJuIGJyXG4gICAgfVxuXG4gICAgZ2V0Qm91bmRpbmdEaW1lbnNpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxjdWxhdGVJbnRlcnNlY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgY29uc3QgW3gxLCB5MV0gPSBwb2ludDtcbiAgICAgICAgY29uc3QgW3gyLCB5Ml0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGgvMjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIGNvbnN0IHZlY3ggPSB4MiAtIHgxO1xuICAgICAgICBjb25zdCB2ZWN5ID0geTIgLSB5MTtcbiAgICAgICAgY29uc3QgdGhldGExID0gaC93O1xuICAgICAgICBjb25zdCB0aGV0YTIgPSBNYXRoLmFicyh2ZWN5L3ZlY3gpO1xuICAgICAgICBjb25zdCBkaXJ4ID0geDEgPiB4MjtcbiAgICAgICAgY29uc3QgZGlyeSA9IHkxID4geTI7XG4gICAgICAgIGxldCB4LCB5O1xuICAgICAgICBpZih0aGV0YTIgPCB0aGV0YTEpIHtcbiAgICAgICAgICAgIHggPSB4MiArIChkaXJ4P3c6LXcpO1xuICAgICAgICAgICAgeSA9IHcgKiAoZGlyeT90aGV0YTI6LXRoZXRhMikgKyB5MjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHkgPSB5MiArIChkaXJ5P2g6LWgpO1xuICAgICAgICAgICAgeCA9IGggLyAoZGlyeD90aGV0YTI6LXRoZXRhMikgKyB4MjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cblxuICAgIGdldEludGVyc2VjdGlvbnNJbkZvdXJEaW1lbnNpb24oKSB7XG4gICAgICAgIGxldCBwMiA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBpZih0aGlzLl9iZWxvbmdzICYmIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24pIHtcbiAgICAgICAgICAgIHAyID0gdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbihwMik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBbeDIsIHkyXSA9IHAyO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aC8yO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtESVJFQ1RJT04uUklHSFRdOiAgW3gyK3csIHkyXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uTEVGVF06ICAgW3gyLXcsIHkyXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uQk9UVE9NXTogW3gyLCB5MitoXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uVE9QXTogICAgW3gyLCB5Mi1oXSxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhbGN1bGF0ZUludGVyc2VjdGlvbkluRm91ckRpbWVuc2lvbihwb2ludCwgZW5kKSB7XG4gICAgICAgIGNvbnN0IFt4MSwgeTFdID0gcG9pbnQ7XG4gICAgICAgIGxldCBwMiA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBpZih0aGlzLl9iZWxvbmdzICYmIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24pIHtcbiAgICAgICAgICAgIHAyID0gdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbihwMik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBbeDIsIHkyXSA9IHAyO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aC8yO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgY29uc3QgYWxsSW50ZXJzZWN0aW9ucyA9IHtcbiAgICAgICAgICAgIFtESVJFQ1RJT04uUklHSFRdOiAgW3gyK3csIHkyXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uTEVGVF06ICAgW3gyLXcsIHkyXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uQk9UVE9NXTogW3gyLCB5MitoXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uVE9QXTogICAgW3gyLCB5Mi1oXSxcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZWN4ID0geDIgLSB4MTtcbiAgICAgICAgY29uc3QgdmVjeSA9IHkyIC0geTE7XG4gICAgICAgIGNvbnN0IHRoZXRhMSA9IGgvdztcbiAgICAgICAgY29uc3QgdGhldGEyID0gTWF0aC5hYnModmVjeS92ZWN4KTtcbiAgICAgICAgY29uc3QgZGlyeCA9IHgxID4geDI7XG4gICAgICAgIGNvbnN0IGRpcnkgPSB5MSA+IHkyO1xuICAgICAgICBsZXQgaW50ZXJEaXIgPSAodGhldGEyID4gdGhldGExXG4gICAgICAgICAgICA/IChkaXJ5ID8gRElSRUNUSU9OLkJPVFRPTSA6IERJUkVDVElPTi5UT1ApXG4gICAgICAgICAgICA6IChkaXJ4ID8gRElSRUNUSU9OLlJJR0hUIDogRElSRUNUSU9OLkxFRlQpKTtcblxuICAgICAgICAvLyBpZih0aGlzLl9iZWxvbmdzICYmIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24pIHtcbiAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHRoaXMuX2ludGVyc2VjdGlvbnMpKTtcbiAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKGludGVyRGlyKVxuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGludGVyRGlyID0gdGhpcy5jaGVja0xpbmtlZChpbnRlckRpciwgZW5kKTtcbiAgICAgICAgLy8gaWYodGhpcy5fYmVsb25ncyAmJiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKSB7XG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhpbnRlckRpcilcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGlmKCFpbnRlckRpcikge1xuICAgICAgICAvLyAgICAgZGVidWdnZXJcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBsZXQgZW5kRGlyID0gaW50ZXJEaXI7XG4gICAgICAgIC8vIGlmKGVuZCA9PT0gJ3RvJykge1xuICAgICAgICAvLyAgICAgZW5kRGlyID0gb3Bwb3NpdGVEaXJlY3Rpb24oZW5kRGlyKVxuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwOiBhbGxJbnRlcnNlY3Rpb25zW2ludGVyRGlyXSxcbiAgICAgICAgICAgIGRpcjogaW50ZXJEaXIsXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlY3RhbmdsZTsiLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9ub2RlJztcbmltcG9ydCB7IERJUkVDVElPTiwgb3Bwb3NpdGVEaXJlY3Rpb24gfSBmcm9tICcuLi8uLi91dGlscy9jb25zdGFuY2UnO1xuLyoqXG4gKiDog7blm4rljZXlhYMg6YWN572uXG4gKiBAdHlwZWRlZiB7Tm9kZX5Db25maWdzfSBDYXBzdWxlfkNhcHN1bGVDb25maWdzXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggIC0g5YaF6YOo55+p5b2i5a69XG4gKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IC0g5YaF6YOo55+p5b2i6auYXG4gKi9cbi8qKlxuICog6IO25ZuK5Y2V5YWDXG4gKiBAY29uc3RydWN0b3IgQ2Fwc3VsZVxuICogQGV4dGVuZHMgTm9kZVxuICogQHBhcmFtIHtDYXBzdWxlfkNhcHN1bGVDb25maWdzfSBjb25maWdzIC0g6YWN572uXG4gKi9cbmNsYXNzIENhcHN1bGUgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzID0ge30pIHtcbiAgICAgICAgc3VwZXIoY29uZmlncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICAgICAgICAgICAgICdDYXBzdWxlJztcbiAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgICAtIOWGhemDqOefqeW9ouWuvSAqL1xuICAgICAgICB0aGlzLndpZHRoID0gICAgICAgICAgICBjb25maWdzLndpZHRoIHx8IDIwO1xuICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAgIC0g5YaF6YOo55+p5b2i6auYICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gICAgICAgICAgIGNvbmZpZ3MuaGVpZ2h0IHx8IDEwO1xuICAgIH1cblxuICAgIHJlbmRlcihjdHgpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgaWYodGhpcy5faXNNb3Zpbmcpe1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC42XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb25zdCBbeCwgeV0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgaHcgPSB0aGlzLndpZHRoLzI7XG4gICAgICAgIGNvbnN0IGhoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgY29uc3QgbGVmdENlbnRlciA9IHggLSBodyArIGhoO1xuICAgICAgICBjb25zdCByaWdodENlbnRlciA9IHggKyBodyAtIGhoO1xuICAgICAgICBjb25zdCB0b3AgPSB5IC0gaGg7XG4gICAgICAgIGNvbnN0IGJvdHRvbSA9IHkgKyBoaDtcblxuICAgICAgICBjdHgubW92ZVRvKGxlZnRDZW50ZXIsIHRvcCk7XG4gICAgICAgIGN0eC5saW5lVG8ocmlnaHRDZW50ZXIsIHRvcCk7XG4gICAgICAgIGN0eC5hcmMocmlnaHRDZW50ZXIsIHksIGhoLCAtTWF0aC5QSS8yLCBNYXRoLlBJLzIpO1xuICAgICAgICBjdHgubGluZVRvKGxlZnRDZW50ZXIsIGJvdHRvbSk7XG4gICAgICAgIGN0eC5hcmMobGVmdENlbnRlciwgeSwgaGgsIE1hdGguUEkvMiwgTWF0aC5QSS8yKjMpO1xuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93Q29sb3IpIHtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHRoaXMuc2hhZG93Q29sb3I7XG4gICAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IHRoaXMuc2hhZG93Qmx1cjtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gdGhpcy5zaGFkb3dPZmZzZXRYO1xuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSB0aGlzLnNoYWRvd09mZnNldFk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgaWYodGhpcy5ib3JkZXJXaWR0aCkge1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuYm9yZGVyV2lkdGg7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmJvcmRlckNvbG9yO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwLjMpJztcbiAgICAgICAgLy8gY3R4LmZpbGxSZWN0KHgtaHcsIHktaGgsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KVxuXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgaXNIaXQocG9pbnQpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IGh3ID0gdGhpcy53aWR0aC8yO1xuICAgICAgICBjb25zdCBoaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIGNvbnN0IHd3ID0gIE1hdGguYWJzKGh3IC0gaGgpO1xuICAgICAgICBjb25zdCBsZWZ0Q2VudGVyID0gYW5jaG9yWzBdIC0gaHcgKyBoaDtcbiAgICAgICAgY29uc3QgcmlnaHRDZW50ZXIgPSBhbmNob3JbMF0gKyBodyAtIGhoO1xuICAgICAgICBjb25zdCByciA9IGhoICogaGg7XG4gICAgICAgIHJldHVybiAocG9pbnRbMF0gPiBhbmNob3JbMF0gLSB3d1xuICAgICAgICAgICAgJiYgcG9pbnRbMF0gPCBhbmNob3JbMF0gKyB3d1xuICAgICAgICAgICAgJiYgcG9pbnRbMV0gPiBhbmNob3JbMV0gLSBoaFxuICAgICAgICAgICAgJiYgcG9pbnRbMV0gPCBhbmNob3JbMV0gKyBoaClcbiAgICAgICAgICAgIHx8ICggTWF0aC5wb3cocG9pbnRbMF0gLSBsZWZ0Q2VudGVyLCAyKSArIE1hdGgucG93KHBvaW50WzFdIC0gYW5jaG9yWzFdLCAyKSA8IHJyKVxuICAgICAgICAgICAgfHwgKCBNYXRoLnBvdyhwb2ludFswXSAtIHJpZ2h0Q2VudGVyLCAyKSArIE1hdGgucG93KHBvaW50WzFdIC0gYW5jaG9yWzFdLCAyKSA8IHJyKVxuICAgIH1cblxuICAgIGdldEJvdW5kaW5nUmVjdCgpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoIC8yO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgY29uc3QgbHR4ID0gYW5jaG9yWzBdIC0gdztcbiAgICAgICAgY29uc3QgbHR5ID0gYW5jaG9yWzFdIC0gaDtcbiAgICAgICAgY29uc3QgcmJ4ID0gYW5jaG9yWzBdICsgdztcbiAgICAgICAgY29uc3QgcmJ5ID0gYW5jaG9yWzFdICsgaDtcbiAgICAgICAgY29uc3QgYnIgPSB0aGlzLl9ib3VuZGluZ3JlY3Q7XG4gICAgICAgIGJyWzBdID0gbHR4O1xuICAgICAgICBiclsxXSA9IGx0eTtcbiAgICAgICAgYnJbMl0gPSByYng7XG4gICAgICAgIGJyWzNdID0gcmJ5O1xuICAgICAgICByZXR1cm4gYnJcbiAgICB9XG5cbiAgICBnZXRCb3VuZGluZ0RpbWVuc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEludGVyc2VjdGlvbnNJbkZvdXJEaW1lbnNpb24oKSB7XG4gICAgICAgIGxldCBwMiA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBpZih0aGlzLl9iZWxvbmdzICYmIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24pIHtcbiAgICAgICAgICAgIHAyID0gdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbihwMik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBbeDIsIHkyXSA9IHAyO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aC8yO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtESVJFQ1RJT04uUklHSFRdOiAgW3gyK3csIHkyXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uTEVGVF06ICAgW3gyLXcsIHkyXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uQk9UVE9NXTogW3gyLCB5MitoXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uVE9QXTogICAgW3gyLCB5Mi1oXSxcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2Fwc3VsZTsiLCJpbXBvcnQgQ2Fwc3VsZSBmcm9tICcuL2NhcHN1bGUnO1xuLyoqXG4gKiDlnoLnm7Tog7blm4rljZXlhYNcbiAqIEBjb25zdHJ1Y3RvciBDYXBzdWxlVmVydGljYWxcbiAqIEBleHRlbmRzIENhcHN1bGVcbiAqIEBwYXJhbSB7Q2Fwc3VsZX5DYXBzdWxlQ29uZmlnc30gY29uZmlncyAtIOmFjee9rlxuICovXG5jbGFzcyBDYXBzdWxlVmVydGljYWwgZXh0ZW5kcyBDYXBzdWxlIHtcbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGlmKHRoaXMuX2lzTW92aW5nKXtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNlxuICAgICAgICB9XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29uc3QgW3gsIHldID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IGh3ID0gdGhpcy53aWR0aC8yO1xuICAgICAgICBjb25zdCBoaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIGNvbnN0IHRvcENlbnRlciA9IHkgLSBoaCArIGh3O1xuICAgICAgICBjb25zdCBib3R0b21DZW50ZXIgPSB5ICsgaGggLSBodztcbiAgICAgICAgY29uc3QgbGVmdCA9IHggLSBodztcbiAgICAgICAgY29uc3QgcmlnaHQgPSB4ICsgaHc7XG5cbiAgICAgICAgY3R4Lm1vdmVUbyhsZWZ0LCB0b3BDZW50ZXIpO1xuICAgICAgICBjdHguYXJjKHgsIHRvcENlbnRlciwgaHcsIC1NYXRoLlBJLCAwKTtcbiAgICAgICAgY3R4LmxpbmVUbyhyaWdodCwgYm90dG9tQ2VudGVyKTtcbiAgICAgICAgY3R4LmFyYyh4LCBib3R0b21DZW50ZXIsIGh3LCAwLCBNYXRoLlBJKTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93Q29sb3IpIHtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHRoaXMuc2hhZG93Q29sb3I7XG4gICAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IHRoaXMuc2hhZG93Qmx1cjtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gdGhpcy5zaGFkb3dPZmZzZXRYO1xuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSB0aGlzLnNoYWRvd09mZnNldFk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgaWYodGhpcy5ib3JkZXJXaWR0aCkge1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuYm9yZGVyV2lkdGg7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmJvcmRlckNvbG9yO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwLjMpJztcbiAgICAgICAgLy8gY3R4LmZpbGxSZWN0KHgtaHcsIHktaGgsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KVxuXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgaXNIaXQocG9pbnQsIGNvbmRpdGlvbikge1xuICAgICAgICBjb25zdCBbeCwgeV0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgaHcgPSB0aGlzLndpZHRoLzI7XG4gICAgICAgIGNvbnN0IGhoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgY29uc3QgeXkgPSAgTWF0aC5hYnMoaGggLSBodyk7XG4gICAgICAgIGNvbnN0IHRvcENlbnRlciA9IHkgLSBoaCArIGh3O1xuICAgICAgICBjb25zdCBib3R0b21DZW50ZXIgPSB5ICsgaGggLSBodztcbiAgICAgICAgY29uc3QgcnIgPSBodyAqIGh3O1xuICAgICAgICByZXR1cm4gKHBvaW50WzBdID4geCAtIGh3XG4gICAgICAgICAgICAmJiBwb2ludFswXSA8IHggKyBod1xuICAgICAgICAgICAgJiYgcG9pbnRbMV0gPiB5IC0geXlcbiAgICAgICAgICAgICYmIHBvaW50WzFdIDwgeSArIHl5KVxuICAgICAgICAgICAgfHwgKCBNYXRoLnBvdyhwb2ludFswXSAtIHgsIDIpICsgTWF0aC5wb3cocG9pbnRbMV0gLSB0b3BDZW50ZXIsIDIpIDwgcnIpXG4gICAgICAgICAgICB8fCAoIE1hdGgucG93KHBvaW50WzBdIC0geCwgMikgKyBNYXRoLnBvdyhwb2ludFsxXSAtIGJvdHRvbUNlbnRlciwgMikgPCBycilcbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBDYXBzdWxlVmVydGljYWw7IiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vbm9kZSc7XG5pbXBvcnQgeyBESVJFQ1RJT04gfSBmcm9tICcuLi8uLi91dGlscy9jb25zdGFuY2UnO1xuLyoqXG4gKiDoj7HlvaLljZXlhYMg6YWN572uXG4gKiBAdHlwZWRlZiB7Tm9kZX5Db25maWdzfSBSaG9tYnVzflJob21idXNDb25maWdzXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGlhZ29uYWxzViAgLSDlhoXljYHlrZfpq5jluqZcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkaWFnb25hbHNIICAtIOWGheWNgeWtl+WuveW6plxuICovXG4vKipcbiAqIOiPseW9ouWNleWFg1xuICogQGNvbnN0cnVjdG9yIFJob21idXNcbiAqIEBwYXJhbSB7UmhvbWJ1c35SaG9tYnVzQ29uZmlnc30gY29uZmlncyAtIOmFjee9rlxuICogQGV4dGVuZHMgTm9kZVxuICovXG5jbGFzcyBSaG9tYnVzIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlncyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAgICAgICAgICAgICAnUmhvbWJ1cyc7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgICAgLSDlhoXljYHlrZfpq5jluqYgKi9cbiAgICAgICAgdGhpcy5oZWlnaHQgPSAgICAgICAgICAgY29uZmlncy5kaWFnb25hbHNWIHx8IDEwO1xuICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAgIC0g5YaF5Y2B5a2X5a695bqmICovXG4gICAgICAgIHRoaXMud2lkdGggPSAgICAgICAgICAgIGNvbmZpZ3MuZGlhZ29uYWxzSCB8fCAyMDtcbiAgICB9XG5cbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGlmKHRoaXMuX2lzTW92aW5nKXtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNlxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgY29uc3QgY2VudGVyID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoY2VudGVyWzBdLCBjZW50ZXJbMV0pXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbygwLCAtaCk7XG4gICAgICAgIGN0eC5saW5lVG8odywgMCk7XG4gICAgICAgIGN0eC5saW5lVG8oMCwgaCk7XG4gICAgICAgIGN0eC5saW5lVG8oLXcsIDApO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGlmKHRoaXMuYm9yZGVyV2lkdGgpIHtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmJvcmRlcldpZHRoO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5ib3JkZXJDb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLnNoYWRvd0NvbG9yKSB7XG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSB0aGlzLnNoYWRvd0NvbG9yO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9qZmxvdy5zY2FsZTtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gdGhpcy5zaGFkb3dCbHVyICogc2NhbGU7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHRoaXMuc2hhZG93T2Zmc2V0WCAqIHNjYWxlO1xuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSB0aGlzLnNoYWRvd09mZnNldFkgKiBzY2FsZTtcbiAgICAgICAgICAgIGxldCBzd2l0Y2hQYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICAgICAgc3dpdGNoUGF0aC5tb3ZlVG8oMCwgLWgpO1xuICAgICAgICAgICAgc3dpdGNoUGF0aC5saW5lVG8odywgMCk7XG4gICAgICAgICAgICBzd2l0Y2hQYXRoLmxpbmVUbygwLCBoKTtcbiAgICAgICAgICAgIHN3aXRjaFBhdGgubGluZVRvKC13LCAwKTtcbiAgICAgICAgICAgIHN3aXRjaFBhdGguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBzd2l0Y2hQYXRoLnJlY3QoLXcgLSAxMCwgIC1oIC0gMTAsIHRoaXMud2lkdGggKyAyMCwgdGhpcy5oZWlnaHQrIDIwKTtcbiAgICAgICAgICAgIC8vIHN3aXRjaFBhdGgubW92ZVRvKHgsIHktaCk7XG4gICAgICAgICAgICAvLyBzd2l0Y2hQYXRoLmxpbmVUbyh4ICsgdywgeSk7XG4gICAgICAgICAgICAvLyBzd2l0Y2hQYXRoLmxpbmVUbyh4LCB5ICsgaCk7XG4gICAgICAgICAgICAvLyBzd2l0Y2hQYXRoLmxpbmVUbyh4LXcsIHkpO1xuICAgICAgICAgICAgLy8gc3dpdGNoUGF0aC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIC8vIHN3aXRjaFBhdGgucmVjdCh4IC0gdyAtIDEwLCB5IC0gaCAtIDEwLCB0aGlzLndpZHRoKyAyMCwgdGhpcy5oZWlnaHQrIDIwKTtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguY2xpcChzd2l0Y2hQYXRoLCBcImV2ZW5vZGRcIik7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgaWYgKHRoaXMuYm9yZGVyV2lkdGgpIHtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICd0cmFuc3BhcmVudCdcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgIFxuICAgICAgICBjdHgudHJhbnNsYXRlKC1jZW50ZXJbMF0sIC1jZW50ZXJbMV0pXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgaXNIaXQocG9pbnQpIHtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMud2lkdGggLyAyO1xuICAgICAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgeCA9IE1hdGguYWJzKHBvaW50WzBdIC0gYW5jaG9yWzBdKTtcbiAgICAgICAgY29uc3QgeSA9IE1hdGguYWJzKHBvaW50WzFdIC0gYW5jaG9yWzFdKTtcbiAgICAgICAgcmV0dXJuICh4IC8gaCArIHkgLyB2KSA8PSAxO1xuICAgIH1cblxuICAgIGdldEJvdW5kaW5nUmVjdCgpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoIC8yO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQgLzI7XG4gICAgICAgIGNvbnN0IGx0eCA9IGFuY2hvclswXSAtIHc7XG4gICAgICAgIGNvbnN0IGx0eSA9IGFuY2hvclsxXSAtIGg7XG4gICAgICAgIGNvbnN0IHJieCA9IGFuY2hvclswXSArIHc7XG4gICAgICAgIGNvbnN0IHJieSA9IGFuY2hvclsxXSArIGg7XG4gICAgICAgIGNvbnN0IGJyID0gdGhpcy5fYm91bmRpbmdyZWN0O1xuICAgICAgICBiclswXSA9IGx0eDtcbiAgICAgICAgYnJbMV0gPSBsdHk7XG4gICAgICAgIGJyWzJdID0gcmJ4O1xuICAgICAgICBiclszXSA9IHJieTtcbiAgICAgICAgcmV0dXJuIGJyXG4gICAgfVxuXG4gICAgZ2V0Qm91bmRpbmdEaW1lbnNpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRJbnRlcnNlY3Rpb25zSW5Gb3VyRGltZW5zaW9uKCkge1xuICAgICAgICBsZXQgcDIgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgaWYodGhpcy5fYmVsb25ncyAmJiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKSB7XG4gICAgICAgICAgICBwMiA9IHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24ocDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgW3gyLCB5Ml0gPSBwMjtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGgvMjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0LzI7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtESVJFQ1RJT04uUklHSFRdOiAgW3gyK3csIHkyXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uTEVGVF06ICAgW3gyLXcsIHkyXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uQk9UVE9NXTogW3gyLCB5MitoXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uVE9QXTogICAgW3gyLCB5Mi1oXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uU0VMRl06ICAgW3gyK3cqMC42MTgsIHkyK2gqMC42MThdXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJob21idXM7XG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9ub2RlJztcbmltcG9ydCB7IERJUkVDVElPTiwgb3Bwb3NpdGVEaXJlY3Rpb24gfSBmcm9tICcuLi8uLi91dGlscy9jb25zdGFuY2UnO1xuLy8gaW1wb3J0IHsgbWFrZUJlemllclBvaW50cyB9IGZyb20gJy4uLy4uL3V0aWxzL2Z1bmN0aW9ucyc7XG4vKipcbiAqIOmSu+efs+W9ouWNleWFgyDphY3nva5cbiAqIEB0eXBlZGVmIHtOb2RlfkNvbmZpZ3N9IERpYW1vbmR+RGlhbW9uZENvbmZpZ3NcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aCAgLSDlhoXpg6jnn6nlvaLlrr1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSDlhoXpg6jnn6nlvaLpq5hcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaWRlICAgLSDkuKTkvqfkuInop5LlvaLnmoTlrr1cbiAqL1xuLyoqXG4gKiDpkrvnn7PlvaLljZXlhYNcbiAqIEBjb25zdHJ1Y3RvciBEaWFtb25kXG4gKiBAcGFyYW0ge0RpYW1vbmR+RGlhbW9uZENvbmZpZ3N9IGNvbmZpZ3MgLSDphY3nva5cbiAqIEBleHRlbmRzIE5vZGVcbiAqL1xuXG5jbGFzcyBEaWFtb25kIGV4dGVuZHMgTm9kZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzID0ge30pIHtcbiAgICAgICAgc3VwZXIoY29uZmlncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICAgICAgICAgICAgICdEaWFtb25kJztcbiAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgICAtIOWGhemDqOefqeW9ouWuvSAqL1xuICAgICAgICB0aGlzLndpZHRoID0gICAgICAgICAgICBjb25maWdzLndpZHRoIHx8IDIwO1xuICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAgIC0g5YaF6YOo55+p5b2i6auYICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gICAgICAgICAgIGNvbmZpZ3MuaGVpZ2h0IHx8IDEwO1xuICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAgIC0g5Lik5L6n5LiJ6KeS5b2i55qE5a69ICovXG4gICAgICAgIHRoaXMuc2lkZSA9ICAgICAgICAgICAgIGNvbmZpZ3Muc2lkZSB8fCA2O1xuICAgICAgICB0aGlzLl9kb0NhY2hlKCk7XG4gICAgfVxuXG4gICAgc2V0Q29uZmlnKGNvbmZpZ3MpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoY29uZmlncykuZm9yRWFjaChrID0+IHtcbiAgICAgICAgICAgIGlmKGNvbmZpZ3Nba10gIT09IHVuZGVmaW5lZCAmJiBjb25maWdzW2tdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trXSA9IGNvbmZpZ3Nba107XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF3Q29uZmlnc1trXSA9IGNvbmZpZ3Nba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kb0NhY2hlKCk7XG4gICAgfVxuXG4gICAgX2RvQ2FjaGUoKSB7XG4gICAgICAgIHRoaXMuc2luU0lERSA9IE1hdGguc2luKE1hdGguUEkvMykgKiB0aGlzLnNpZGU7XG4gICAgICAgIHRoaXMuY29zU0lERSA9IE1hdGguY29zKE1hdGguUEkvMykgKiB0aGlzLnNpZGU7XG4gICAgfVxuXG4gICAgcmVuZGVyKGN0eCkge1xuICAgICAgICBjb25zdCBbeCwgeV0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgaHcgPSB0aGlzLndpZHRoLzI7XG4gICAgICAgIGNvbnN0IGhoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgY29uc3QgeHggPSBoaCAvIDEuNzMyXG4gICAgICAgIGNvbnN0IGxlZnRDZW50ZXIgPSB4IC0gaHcgKyB4eDtcbiAgICAgICAgY29uc3QgcmlnaHRDZW50ZXIgPSB4ICsgaHcgLSB4eDtcbiAgICAgICAgY29uc3QgcmlnaHQgPSB4ICsgaHc7XG4gICAgICAgIGNvbnN0IGxlZnQgPSB4IC0gaHc7XG4gICAgICAgIGNvbnN0IHRvcCA9IHkgLSBoaDtcbiAgICAgICAgY29uc3QgYm90dG9tID0geSArIGhoO1xuXG4gICAgICAgIHRoaXMuX2NhY2hlUG9pbnRzID0gW1xuICAgICAgICAgICAgW3JpZ2h0Q2VudGVyLCB0b3BdLFxuICAgICAgICAgICAgW3JpZ2h0LCB5XSxcbiAgICAgICAgICAgIFtyaWdodENlbnRlciwgYm90dG9tXSxcbiAgICAgICAgICAgIFtsZWZ0Q2VudGVyLCBib3R0b21dLFxuICAgICAgICAgICAgW2xlZnQsIHldLFxuICAgICAgICAgICAgW2xlZnRDZW50ZXIsIHRvcF1cbiAgICAgICAgXTtcblxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBpZih0aGlzLl9pc01vdmluZyl7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjZcbiAgICAgICAgfVxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHNpZGUsIHNpblNJREUsIGNvc1NJREVcbiAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgIGN0eC5tb3ZlVG8oeCwgdG9wKTtcbiAgICAgICAgY3R4LmxpbmVUbyhyaWdodENlbnRlciAtIHNpZGUsIHRvcCk7XG4gICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHJpZ2h0Q2VudGVyLCB0b3AsIHJpZ2h0Q2VudGVyICsgY29zU0lERSwgdG9wICsgc2luU0lERSk7XG4gICAgICAgIGN0eC5saW5lVG8ocmlnaHQgLSBjb3NTSURFLCB5IC0gc2luU0lERSk7XG4gICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHJpZ2h0LCB5LCByaWdodCAtIGNvc1NJREUsIHkgKyBzaW5TSURFKTtcbiAgICAgICAgY3R4LmxpbmVUbyhyaWdodENlbnRlciArIGNvc1NJREUsIGJvdHRvbSAtIHNpblNJREUpO1xuICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhyaWdodENlbnRlciwgYm90dG9tLCByaWdodENlbnRlciAtIHNpZGUsIGJvdHRvbSk7XG5cbiAgICAgICAgY3R4LmxpbmVUbyhsZWZ0Q2VudGVyICsgc2lkZSwgYm90dG9tKTtcbiAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8obGVmdENlbnRlciwgYm90dG9tLCBsZWZ0Q2VudGVyIC0gY29zU0lERSwgYm90dG9tIC0gc2luU0lERSk7XG4gICAgICAgIGN0eC5saW5lVG8obGVmdCArIGNvc1NJREUsIHkgKyBzaW5TSURFKTtcbiAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8obGVmdCwgeSwgbGVmdCArIGNvc1NJREUsIHkgLSBzaW5TSURFKTtcbiAgICAgICAgY3R4LmxpbmVUbyhsZWZ0Q2VudGVyIC0gY29zU0lERSwgdG9wICsgc2luU0lERSk7XG4gICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGxlZnRDZW50ZXIsIHRvcCwgbGVmdENlbnRlciArIHNpZGUsIHRvcCk7XG5cbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93Q29sb3IpIHtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHRoaXMuc2hhZG93Q29sb3I7XG4gICAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IHRoaXMuc2hhZG93Qmx1cjtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gdGhpcy5zaGFkb3dPZmZzZXRYO1xuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSB0aGlzLnNoYWRvd09mZnNldFk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgaWYodGhpcy5ib3JkZXJXaWR0aCkge1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuYm9yZGVyV2lkdGg7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmJvcmRlckNvbG9yO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYodGhpcy5faXNUYXJnZXRpbmcpIHtcbiAgICAgICAgLy8gICAgIHRoaXMucmVuZGVyRm9jdXMoY3R4KTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMC4zKSc7XG4gICAgICAgIC8vIGN0eC5maWxsUmVjdCh4LWh3LCB5LWhoLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodClcblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG5cbiAgICB9XG5cbiAgICBpc0hpdChwb2ludCkge1xuICAgICAgICBpZighdGhpcy5fY2FjaGVQb2ludHMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgcG9seWdvbiA9IHRoaXMuX2NhY2hlUG9pbnRzO1xuICAgICAgICBsZXQgb2RkID0gZmFsc2U7XG4gICAgICAgIC8vIEZvciBlYWNoIGVkZ2UgKEluIHRoaXMgY2FzZSBmb3IgZWFjaCBwb2ludCBvZiB0aGUgcG9seWdvbiBhbmQgdGhlIHByZXZpb3VzIG9uZSlcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSBwb2x5Z29uLmxlbmd0aCAtIDE7IGkgPCBwb2x5Z29uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBJZiBhIGxpbmUgZnJvbSB0aGUgcG9pbnQgaW50byBpbmZpbml0eSBjcm9zc2VzIHRoaXMgZWRnZVxuICAgICAgICAgICAgaWYgKCgocG9seWdvbltpXVsxXSA+IHBvaW50WzFdKSAhPT0gKHBvbHlnb25bal1bMV0gPiBwb2ludFsxXSkpIC8vIE9uZSBwb2ludCBuZWVkcyB0byBiZSBhYm92ZSwgb25lIGJlbG93IG91ciB5IGNvb3JkaW5hdGVcbiAgICAgICAgICAgICAgICAvLyAuLi5hbmQgdGhlIGVkZ2UgZG9lc24ndCBjcm9zcyBvdXIgWSBjb3JyZGluYXRlIGJlZm9yZSBvdXIgeCBjb29yZGluYXRlIChidXQgYmV0d2VlbiBvdXIgeCBjb29yZGluYXRlIGFuZCBpbmZpbml0eSlcbiAgICAgICAgICAgICAgICAmJiAocG9pbnRbMF0gPCAoKHBvbHlnb25bal1bMF0gLSBwb2x5Z29uW2ldWzBdKSAqIChwb2ludFsxXSAtIHBvbHlnb25baV1bMV0pIC8gKHBvbHlnb25bal1bMV0gLSBwb2x5Z29uW2ldWzFdKSArIHBvbHlnb25baV1bMF0pKSkge1xuICAgICAgICAgICAgICAgIC8vIEludmVydCBvZGRcbiAgICAgICAgICAgICAgICBvZGQgPSAhb2RkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaiA9IGk7XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2RkO1xuICAgIH1cblxuICAgIGdldEJvdW5kaW5nUmVjdCgpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoIC8yO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgY29uc3QgbHR4ID0gYW5jaG9yWzBdIC0gdztcbiAgICAgICAgY29uc3QgbHR5ID0gYW5jaG9yWzFdIC0gaDtcbiAgICAgICAgY29uc3QgcmJ4ID0gYW5jaG9yWzBdICsgdztcbiAgICAgICAgY29uc3QgcmJ5ID0gYW5jaG9yWzFdICsgaDtcbiAgICAgICAgY29uc3QgYnIgPSB0aGlzLl9ib3VuZGluZ3JlY3Q7XG4gICAgICAgIGJyWzBdID0gbHR4O1xuICAgICAgICBiclsxXSA9IGx0eTtcbiAgICAgICAgYnJbMl0gPSByYng7XG4gICAgICAgIGJyWzNdID0gcmJ5O1xuICAgICAgICByZXR1cm4gYnJcbiAgICB9XG5cbiAgICBnZXRCb3VuZGluZ0RpbWVuc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEludGVyc2VjdGlvbnNJbkZvdXJEaW1lbnNpb24oKSB7XG4gICAgICAgIGxldCBwMiA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBpZih0aGlzLl9iZWxvbmdzICYmIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24pIHtcbiAgICAgICAgICAgIHAyID0gdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbihwMik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBbeDIsIHkyXSA9IHAyO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aC8yO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtESVJFQ1RJT04uUklHSFRdOiAgW3gyK3csIHkyXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uTEVGVF06ICAgW3gyLXcsIHkyXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uQk9UVE9NXTogW3gyLCB5MitoXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uVE9QXTogICAgW3gyLCB5Mi1oXSxcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGlhbW9uZDsiLCJpbXBvcnQgRGlhbW9uZCBmcm9tICcuL2RpYW1vbmQnO1xuY29uc3QgYmFja3NxcnQzID0gMS9NYXRoLnNxcnQoMylcblxuLyoqXG4gKiDlnoLnm7Tpkrvnn7PlvaLljZXlhYNcbiAqIEBjb25zdHJ1Y3RvciBEaWFtb25kVmVydGljYWxcbiAqIEBwYXJhbSB7RGlhbW9uZH5EaWFtb25kQ29uZmlnc30gY29uZmlncyAtIOmFjee9rlxuICogQGV4dGVuZHMgRGlhbW9uZFxuICovXG5jbGFzcyBEaWFtb25kVmVydGljYWwgZXh0ZW5kcyBEaWFtb25kIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3MpXG4gICAgfVxuXG4gICAgcmVuZGVyKGN0eCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBpZih0aGlzLl9pc01vdmluZyl7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjZcbiAgICAgICAgfVxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnN0IFt4LCB5XSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCBodyA9IHRoaXMud2lkdGgvMjtcbiAgICAgICAgY29uc3QgaGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICBjb25zdCB5eSA9IGh3IC8gMS43MzJcblxuICAgICAgICBjb25zdCB0b3AgPSB5IC0gaGg7XG4gICAgICAgIGNvbnN0IGJvdHRvbSA9IHkgKyBoaDtcbiAgICAgICAgY29uc3QgdG9wbWlkZGxlID0geSAtIGhoICsgeXk7XG4gICAgICAgIGNvbnN0IGJvdHRvbW1pZGRsZSA9IHkgKyBoaCAtIHl5O1xuICAgICAgICBjb25zdCB4bGVmdCA9IHggLSBodztcbiAgICAgICAgY29uc3QgeHJpZ2h0ID0geCArIGh3O1xuXG4gICAgICAgIGN0eC5tb3ZlVG8oeCwgdG9wKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4cmlnaHQsIHRvcG1pZGRsZSk7XG4gICAgICAgIGN0eC5saW5lVG8oeHJpZ2h0LCBib3R0b21taWRkbGUpO1xuICAgICAgICBjdHgubGluZVRvKHgsIGJvdHRvbSk7XG4gICAgICAgIGN0eC5saW5lVG8oeGxlZnQsIGJvdHRvbW1pZGRsZSk7XG4gICAgICAgIGN0eC5saW5lVG8oeGxlZnQsIHRvcG1pZGRsZSk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBpZiAodGhpcy5zaGFkb3dDb2xvcikge1xuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gdGhpcy5zaGFkb3dDb2xvcjtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gdGhpcy5zaGFkb3dCbHVyO1xuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSB0aGlzLnNoYWRvd09mZnNldFg7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHRoaXMuc2hhZG93T2Zmc2V0WTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBpZih0aGlzLmJvcmRlcldpZHRoKSB7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5ib3JkZXJXaWR0aDtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB0aGlzLl9jYWNoZVBvaW50cyA9IFtcbiAgICAgICAgICAgIFt4LCB0b3BdLFxuICAgICAgICAgICAgW3hyaWdodCwgdG9wbWlkZGxlXSxcbiAgICAgICAgICAgIFt4cmlnaHQsIGJvdHRvbW1pZGRsZV0sXG4gICAgICAgICAgICBbeCwgYm90dG9tXSxcbiAgICAgICAgICAgIFt4bGVmdCwgYm90dG9tbWlkZGxlXSxcbiAgICAgICAgICAgIFt4bGVmdCwgdG9wbWlkZGxlXVxuICAgICAgICBdO1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IERpYW1vbmRWZXJ0aWNhbDsiLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9ub2RlJztcbmltcG9ydCBTdGFja01peGluIGZyb20gJy4uL3N0YWNrTWl4aW4nO1xuaW1wb3J0IExheW91dE1peGluIGZyb20gJy4uL2xheW91dE1peGluJztcbmltcG9ydCBSZWN0YW5nbGUgZnJvbSAnLi4vc2hhcGVzL3JlY3RhbmdsZSc7XG5pbXBvcnQgeyBib3VuZGluZ19ib3gsIGRvT3ZlcmxhcCB9IGZyb20gJy4uLy4uL3V0aWxzL2Z1bmN0aW9ucyc7XG5pbXBvcnQgeyBESVJFQ1RJT04gfSBmcm9tICcuLi8uLi91dGlscy9jb25zdGFuY2UnO1xuaW1wb3J0IHsgU2Nyb2xsQmFyIH0gZnJvbSAnLi4vLi4vc2Nyb2xsYmFyL3Njcm9sbGJhck1peGluJztcbmNvbnN0IGlzaGl0S2V5ID0gU3ltYm9sKCdpc2hpdCcpO1xuXG5jbGFzcyBJbm5lclNjcm9sbEJhciBleHRlbmRzIFNjcm9sbEJhciB7XG4gICAgY29uc3RydWN0b3IoZGlyLCBjb25maWdzID0ge30pIHtcbiAgICAgICAgc3VwZXIoZGlyLCBjb25maWdzKTtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIHJlbmRlcihjdHgpIHtcbiAgICAgICAgaWYodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICBzdXBlci5yZW5kZXIoY3R4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldEhpdChpc2hpdCkge1xuICAgICAgICBpZih0aGlzW2lzaGl0S2V5XSAhPT0gaXNoaXQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNGb2N1cyA9IGlzaGl0XG4gICAgICAgICAgICB0aGlzLm9uSGl0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tpc2hpdEtleV0gPSBpc2hpdDtcbiAgICB9XG59XG4gXG5jbGFzcyBTY3JvbGxHcm91cCBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3MpIHtcbiAgICAgICAgc3VwZXIoY29uZmlncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdTY3JvbGxHcm91cCc7XG4gICAgICAgIHRoaXMuaW5pdFN0YWNrKGNvbmZpZ3MpO1xuICAgICAgICB0aGlzLmluaXRMYXlvdXQoY29uZmlncyk7XG4gICAgICAgIHRoaXMuaW5pdFNjcm9sbEJhcihjb25maWdzKTtcbiAgICAgICAgdGhpcy5fc2hhcGUgPSBuZXcgUmVjdGFuZ2xlKGNvbmZpZ3MpO1xuICAgICAgICB0aGlzLl9zaGFwZS5hbmNob3IgPSBbMCwgMF07XG4gICAgICAgIHRoaXMuX3NoYXBlLl9iZWxvbmdzID0gdGhpcztcblxuICAgICAgICB0aGlzLm1heFdpZHRoID0gY29uZmlncy5tYXhXaWR0aCB8fCBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5kZWZpbmVkV2lkdGggPSBjb25maWdzLmRlZmluZWRXaWR0aDtcbiAgICAgICAgdGhpcy5tYXhIZWlnaHQgPSBjb25maWdzLm1heEhlaWdodCB8fCBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5kZWZpbmVkSGVpZ2h0ID0gY29uZmlncy5kZWZpbmVkSGVpZ2h0O1xuXG4gICAgICAgIHRoaXMubG9jayA9IGNvbmZpZ3MubG9jayA/PyB0cnVlIDtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gWzAsIDBdO1xuXG4gICAgICAgIHRoaXMuX2dldEJvdW5kaW5nR3JvdXBSZWN0KCk7XG4gICAgICAgIHRoaXMucmVmbG93KCk7XG4gICAgICAgIHRoaXMuX2dldEJvdW5kaW5nR3JvdXBSZWN0KCk7ICBcbiAgICAgICAgdGhpcy5fcmVzZXRPZmZzZXQoKTtcbiAgICAgICAgdGhpcy5fY2FjaGVWaWV3Qm94ID0gW11cblxuICAgIH1cblxuICAgIGluaXRTY3JvbGxCYXIoY29uZmlncykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBiYXJDb2xvcixcbiAgICAgICAgICAgIGJhckZvY3VzQ29sb3IsXG4gICAgICAgICAgICBiYXJNYXJnaW5YLFxuICAgICAgICAgICAgYmFyTWFyZ2luWSxcbiAgICAgICAgICAgIGJhcldpZHRoLFxuICAgICAgICB9ID0gY29uZmlncztcbiAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWCA9IG5ldyBJbm5lclNjcm9sbEJhcigneCcsIHtcbiAgICAgICAgICAgIHBsYWluQ29sb3I6IGJhckNvbG9yLFxuICAgICAgICAgICAgZm9jdXNDb2xvcjogYmFyRm9jdXNDb2xvcixcbiAgICAgICAgICAgIGJhcldpZHRoLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWSA9IG5ldyBJbm5lclNjcm9sbEJhcigneScsIHtcbiAgICAgICAgICAgIHBsYWluQ29sb3I6IGJhckNvbG9yLFxuICAgICAgICAgICAgZm9jdXNDb2xvcjogYmFyRm9jdXNDb2xvcixcbiAgICAgICAgICAgIGJhcldpZHRoXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zY3JvbGxiYXJYLmJhck1hcmdpblggPSBiYXJNYXJnaW5YIHx8IDE7XG4gICAgICAgIHRoaXMuX3Njcm9sbGJhclkuYmFyTWFyZ2luWSA9IGJhck1hcmdpblkgfHwgMTtcbiAgICAgICAgY29uc3QgX2YgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9qZmxvdy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Njcm9sbGJhclgub25IaXQgPSBfZjtcbiAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWS5vbkhpdCA9IF9mO1xuXG4gICAgICAgIHRoaXMuX3Njcm9sbEJhclN0YXR1cyA9IHtcbiAgICAgICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIHRhcmdldDogbnVsbCxcblxuICAgICAgICAgICAgYmFySW5pdFg6IDAsXG4gICAgICAgICAgICBiYXJJbml0WTogMCxcbiAgICAgICAgICAgIGJhclN0YXJ0WDogMCxcbiAgICAgICAgICAgIGJhclN0YXJ0WTogMCxcblxuICAgICAgICAgICAgaGl0U2Nyb2xsWDogZmFsc2UsXG4gICAgICAgICAgICBoaXRTY3JvbGxZOiBmYWxzZSxcbiAgICAgICAgfVxuICAgICAgICAvLyAvLyBjb25zdCBqZmxvd0luc3RhbmNlID0gdGhpcy5famZsb3c7XG4gICAgICAgIC8vIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignaW5zdGFuY2Vtb3VzZW1vdmUnLCBlID0+IHtcbiAgICAgICAgLy8gICAgIGlmKHRoaXMuX3Njcm9sbEJhclN0YXR1cy5oaXRTY3JvbGxYKSB7XG4gICAgICAgIC8vICAgICAgICAgaWYoIXRoaXMuX3Njcm9sbGJhclguaXNGb2N1cykge1xuICAgICAgICAvLyAgICAgICAgICAgICB0aGlzLl9zY3JvbGxiYXJYLmlzRm9jdXMgPSB0cnVlO1xuICAgICAgICAvLyAgICAgICAgICAgICBlLmRldGFpbC5qZmxvdy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAvLyAgICAgICAgIH1cbiAgICAgICAgLy8gICAgICAgICByZXR1cm47XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vICAgICBpZih0aGlzLl9zY3JvbGxiYXJYLmlzRm9jdXMpIHtcbiAgICAgICAgLy8gICAgICAgICB0aGlzLl9zY3JvbGxiYXJYLmlzRm9jdXMgPSBmYWxzZTtcbiAgICAgICAgLy8gICAgICAgICBlLmRldGFpbC5qZmxvdy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gfSlcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdpbnN0YW5jZVByZXNzU3RhcnQnLCBlID0+IHtcbiAgICAgICAgICAgIGlmKHRoaXMuX3Njcm9sbEJhclN0YXR1cy5oaXRTY3JvbGxYKSB7XG4gICAgICAgICAgICAgICAgZS5kZXRhaWwucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLmRldGFpbC5idWJibGVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xpZW50WCA9IGUuZGV0YWlsLmV2ZW50LmNsaWVudFg7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9zY3JvbGxCYXJTdGF0dXMsIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy5fc2Nyb2xsYmFyWCxcbiAgICAgICAgICAgICAgICAgICAgYmFyU3RhcnRYOiB0aGlzLl9zY3JvbGxiYXJYLmFuY2hvclswXSxcbiAgICAgICAgICAgICAgICAgICAgYmFySW5pdFg6IGNsaWVudFgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vblNjcm9sbGJhclByZXNzU3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMuX3Njcm9sbEJhclN0YXR1cy5oaXRTY3JvbGxZKSB7XG4gICAgICAgICAgICAgICAgZS5kZXRhaWwucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLmRldGFpbC5idWJibGVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xpZW50WSA9IGUuZGV0YWlsLmV2ZW50LmNsaWVudFk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9zY3JvbGxCYXJTdGF0dXMsIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy5fc2Nyb2xsYmFyWSxcbiAgICAgICAgICAgICAgICAgICAgYmFyU3RhcnRZOiB0aGlzLl9zY3JvbGxiYXJZLmFuY2hvclsxXSxcbiAgICAgICAgICAgICAgICAgICAgYmFySW5pdFk6IGNsaWVudFksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vblNjcm9sbGJhclByZXNzU3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBvblNjcm9sbGJhclByZXNzU3RhcnQoKSB7XG4gICAgICAgIGNvbnN0IGpmbG93SW5zdGFuY2UgPSB0aGlzLl9qZmxvdztcbiAgICAgICAgY29uc3QgY2FudmFzID0gamZsb3dJbnN0YW5jZS5jYW52YXM7XG4gICAgICAgIGNvbnN0IGYgPSAoZSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGU7XG4gICAgICAgICAgICB0aGlzLm9uRHJhZ2dpbmdTY3JvbGxiYXIoY2xpZW50WCwgY2xpZW50WSlcbiAgICAgICAgfSkuYmluZCh0aGlzKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBmKTtcbiAgICAgICAgY29uc3QgdCA9IChlID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fc2Nyb2xsQmFyU3RhdHVzLCB7XG4gICAgICAgICAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICAgICAgICAgICBiYXJJbml0WDogMCxcbiAgICAgICAgICAgICAgICBiYXJJbml0WTogMCxcbiAgICAgICAgICAgICAgICBiYXJTdGFydFg6IDAsXG4gICAgICAgICAgICAgICAgYmFyU3RhcnRZOiAwLFxuICAgICAgICAgICAgICAgIGhpdFNjcm9sbFg6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGhpdFNjcm9sbFk6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIGYpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdCk7XG4gICAgICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdCk7XG4gICAgICAgIH0pLmJpbmQodGhpcyk7XG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCB0LCB7XG4gICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHQsIHtcbiAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBvbkRyYWdnaW5nU2Nyb2xsYmFyKGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICAgICAgaWYodGhpcy5fc2Nyb2xsYmFyWC52aXNpYmxlICYmIHRoaXMuX3Njcm9sbEJhclN0YXR1cy5kcmFnZ2luZykge1xuICAgICAgICAgICAgY29uc3QgSkZMT1cgPSB0aGlzLl9qZmxvdztcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gSkZMT1cuc2NhbGU7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIGJhckluaXRYLFxuICAgICAgICAgICAgICAgIGJhclN0YXJ0WCxcbiAgICAgICAgICAgICAgICBiYXJJbml0WSxcbiAgICAgICAgICAgICAgICBiYXJTdGFydFlcbiAgICAgICAgICAgIH0gPSB0aGlzLl9zY3JvbGxCYXJTdGF0dXM7XG4gICAgICAgICAgICBpZih0YXJnZXQuZGlyID09PSAneCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBfc2Nyb2xsV2lkdGggPSB0aGlzLl9zY3JvbGxiYXJYLndpZHRoO1xuICAgICAgICAgICAgICAgIGNvbnN0IF9vdXRlcldpZHRoID0gdGhpcy5fb3V0ZXJXaWR0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YVggPSBjbGllbnRYIC0gYmFySW5pdFg7XG4gICAgICAgICAgICAgICAgY29uc3QgeG5ldyA9IGJhclN0YXJ0WCArIGRlbHRhWCAvIHNjYWxlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHEgPSB0YXJnZXQuYW5jaG9yWzBdID0gTWF0aC5tYXgoTWF0aC5taW4oeG5ldywgX291dGVyV2lkdGggLSBfc2Nyb2xsV2lkdGgpLCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCByYXRpb0luWCA9IHEgLyAoX291dGVyV2lkdGggLSBfc2Nyb2xsV2lkdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSAodGhpcy5faW5uZXJXaWR0aCAtIF9vdXRlcldpZHRoKS8yO1xuICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldFswXSA9IHMgLSAodGhpcy5faW5uZXJXaWR0aCAtIF9vdXRlcldpZHRoKSAqIHJhdGlvSW5YXG4gICAgICAgICAgICAgICAgSkZMT1cuc2NoZWR1bGVSZW5kZXIoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih0YXJnZXQuZGlyID09PSAneScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBfc2Nyb2xsSGVpZ2h0ID0gdGhpcy5fc2Nyb2xsYmFyWS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgX291dGVySGVpZ2h0ID0gdGhpcy5fb3V0ZXJIZWlnaHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGFZID0gY2xpZW50WSAtIGJhckluaXRZO1xuICAgICAgICAgICAgICAgIGNvbnN0IHluZXcgPSBiYXJTdGFydFkgKyBkZWx0YVkgLyBzY2FsZTtcbiAgICAgICAgICAgICAgICBjb25zdCBxID0gdGFyZ2V0LmFuY2hvclsxXSA9IE1hdGgubWF4KE1hdGgubWluKHluZXcsIF9vdXRlckhlaWdodCAtIF9zY3JvbGxIZWlnaHQpLCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCByYXRpbyA9IHEgLyAoX291dGVySGVpZ2h0IC0gX3Njcm9sbEhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9ICh0aGlzLl9pbm5lckhlaWdodCAtIF9vdXRlckhlaWdodCkvMjtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXRbMV0gPSBzIC0gKHRoaXMuX2lubmVySGVpZ2h0IC0gX291dGVySGVpZ2h0KSAqIHJhdGlvXG4gICAgICAgICAgICAgICAgSkZMT1cuc2NoZWR1bGVSZW5kZXIoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBzZXRDb25maWcoY29uZmlncykge1xuICAgICAgICB0aGlzLl9zaGFwZS5zZXRDb25maWcoY29uZmlncyk7XG4gICAgfVxuXG4gICAgX2dldEJvdW5kaW5nR3JvdXBSZWN0KCkge1xuICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9zdGFjay5nZXRCb3VuZGluZ1JlY3RQb2ludHMoKTtcbiAgICAgICAgLy8gY29udGVudCBib3ggXG4gICAgICAgIGNvbnN0IGJib3ggPSBib3VuZGluZ19ib3gocG9pbnRzKTtcbiAgICAgICAgY29uc3QgdyA9IGJib3gud2lkdGg7XG4gICAgICAgIGNvbnN0IGggPSBiYm94LmhlaWdodDtcbiAgICAgICAgY29uc3Qgb3V0ZXJXaWR0aCA9IHRoaXMuZGVmaW5lZFdpZHRoIHx8IE1hdGgubWluKHcsIHRoaXMubWF4V2lkdGgpO1xuICAgICAgICBjb25zdCBvdXRlckhlaWdodCA9IHRoaXMuZGVmaW5lZEhlaWdodCB8fCBNYXRoLm1pbihoLCB0aGlzLm1heEhlaWdodCk7XG4gICAgICAgIHRoaXMuX2lubmVyV2lkdGggPSB3O1xuICAgICAgICB0aGlzLl9vdXRlcldpZHRoID0gb3V0ZXJXaWR0aDtcbiAgICAgICAgdGhpcy5faW5uZXJIZWlnaHQgPSBoO1xuICAgICAgICB0aGlzLl9vdXRlckhlaWdodCA9IG91dGVySGVpZ2h0O1xuXG4gICAgICAgIHRoaXMuX3NoYXBlLndpZHRoID0gb3V0ZXJXaWR0aDtcbiAgICAgICAgdGhpcy5fc2hhcGUuaGVpZ2h0ID0gb3V0ZXJIZWlnaHQ7XG4gICAgICAgIHRoaXMud2lkdGggPSBvdXRlcldpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IG91dGVySGVpZ2h0O1xuICAgIH1cblxuICAgIF9jYWxjdWxhdGVQb2ludEJhY2socG9pbnQpIHtcbiAgICAgICAgY29uc3QgW2d4LCBneV0gPSBwb2ludDtcbiAgICAgICAgY29uc3QgW3R4LCB0eV0gPSB0aGlzLl9vZmZzZXQ7XG4gICAgICAgIGNvbnN0IFtjeCwgY3ldID0gdGhpcy5hbmNob3I7IFxuICAgICAgICBjb25zdCBwID0gW2d4IC0gY3ggLSB0eCwgZ3kgLSBjeSAtIHR5XVxuICAgICAgICByZXR1cm4gcFxuICAgIH1cblxuICAgIF9jYWxjdWxhdGVQb2ludEJhY2tXaXRoUG9pbnQoYSwgYiwgYXJyLCBpZHgxLCBpZHgyKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICAgIGFycltpZHgxXSA9IGEgLSBhbmNob3JbMF0gLSBvZmZzZXRbMF07XG4gICAgICAgIGFycltpZHgyXSA9IGIgLSBhbmNob3JbMV0gLSBvZmZzZXRbMV07XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlVG9Db29yZGluYXRpb24ocG9pbnQpIHtcbiAgICAgICAgY29uc3QgW2d4LCBneV0gPSBwb2ludDtcbiAgICAgICAgY29uc3QgW2N4LCBjeV0gPSB0aGlzLmFuY2hvcjsgIFxuICAgICAgICBjb25zdCBbdHgsIHR5XSA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgY29uc3QgcCA9IFtneCArIGN4IC0gdHgsIGd5ICsgY3kgLSB0eV1cbiAgICAgICAgaWYodGhpcy5fYmVsb25ncyAmJiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbihwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlVG9SZWFsV29ybGQocG9pbnQpIHtcbiAgICAgICAgY29uc3QgW2d4LCBneV0gPSBwb2ludDtcbiAgICAgICAgY29uc3QgW2N4LCBjeV0gPSB0aGlzLmFuY2hvcjsgIFxuICAgICAgICBjb25zdCBbdHgsIHR5XSA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgY29uc3QgcCA9IFtneCArIGN4IC0gdHgsIGd5ICsgY3kgLSB0eV1cbiAgICAgICAgaWYodGhpcy5fYmVsb25ncyAmJiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvUmVhbFdvcmxkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb1JlYWxXb3JsZChwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhbGN1bGF0ZVRvUmVhbFdvcmxkV2l0aFBvaW50ZXIob3V0cG9pbnQsIGlucG9pbnQpIHtcbiAgICAgICAgb3V0cG9pbnRbMF0gPSBpbnBvaW50WzBdICsgdGhpcy5hbmNob3JbMF0gLSB0aGlzLm9mZnNldFswXTtcbiAgICAgICAgb3V0cG9pbnRbMV0gPSBpbnBvaW50WzFdICsgdGhpcy5hbmNob3JbMV0gLSB0aGlzLm9mZnNldFsxXTtcbiAgICAgICAgaWYodGhpcy5fYmVsb25ncyAmJiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvUmVhbFdvcmxkV2l0aFBvaW50ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvUmVhbFdvcmxkV2l0aFBvaW50ZXIob3V0cG9pbnQsIG91dHBvaW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRWaWV3Qm94KCkge1xuICAgICAgICBjb25zdCBiZWxvbmdzX3Zib3ggPSB0aGlzLl9iZWxvbmdzLmdldENhY2hlVmlld0JveCgpO1xuICAgICAgICBjb25zdCBjYWNoZVZpZXdCb3ggPSB0aGlzLl9jYWNoZVZpZXdCb3g7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVQb2ludEJhY2tXaXRoUG9pbnQoYmVsb25nc192Ym94WzBdLCBiZWxvbmdzX3Zib3hbMV0sIGNhY2hlVmlld0JveCwgMCwgMSk7XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVBvaW50QmFja1dpdGhQb2ludChiZWxvbmdzX3Zib3hbMl0sIGJlbG9uZ3NfdmJveFszXSwgY2FjaGVWaWV3Qm94LCAyLCAzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlVmlld0JveDtcbiAgICB9XG5cbiAgICBnZXRDYWNoZVZpZXdCb3goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZVZpZXdCb3g7XG4gICAgfVxuXG4gICAgX3Jlc2V0T2Zmc2V0KCkge1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBbXG4gICAgICAgICAgICBNYXRoLm1heCgodGhpcy5faW5uZXJXaWR0aCAtIHRoaXMuX291dGVyV2lkdGgpLzIsIDApLFxuICAgICAgICAgICAgTWF0aC5tYXgoKHRoaXMuX2lubmVySGVpZ2h0IC0gdGhpcy5fb3V0ZXJIZWlnaHQpLzIsIDApLFxuICAgICAgICBdO1xuICAgICAgICBpZih0aGlzLl9pbm5lcldpZHRoID4gdGhpcy5fb3V0ZXJXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWC52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbGJhclgud2lkdGggPSB0aGlzLl9vdXRlcldpZHRoICogdGhpcy5fb3V0ZXJXaWR0aCAvIHRoaXMuX2lubmVyV2lkdGg7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxiYXJYLmFuY2hvciA9IFswLCB0aGlzLl9vdXRlckhlaWdodCAtIDRdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxiYXJYLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLl9pbm5lckhlaWdodCA+IHRoaXMuX291dGVySGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxiYXJZLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWS5oZWlnaHQgPSB0aGlzLl9vdXRlckhlaWdodCAqIHRoaXMuX291dGVySGVpZ2h0IC8gdGhpcy5faW5uZXJIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxiYXJZLmFuY2hvciA9IFt0aGlzLl9vdXRlcldpZHRoIC0gNCwgMF1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbGJhclkudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKGN0eCkge1xuICAgICAgICBpZih0aGlzLl9pc01vdmluZyl7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjZcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMub3BhY2l0eSAhPT0gMSkge1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5vcGFjaXR5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtjeCwgY3ldID0gdGhpcy5hbmNob3I7IFxuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aDtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICBjb25zdCB3MiA9IHcvMjtcbiAgICAgICAgY29uc3QgaDIgPSBoLzI7XG4gICAgICAgIC8vIGlmKCh0aGlzLndpZHRoICogdGhpcy5oZWlnaHQpICogdGhpcy5famZsb3cuc2NhbGUgPCAxNDQpIHtcbiAgICAgICAgLy8gICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIC8vICAgICByZXR1cm47XG4gICAgICAgIC8vIH1cbiAgICAgICAgY29uc3QgW3R4LCB0eV0gPSB0aGlzLl9vZmZzZXQ7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoY3gsIGN5KTtcbiAgICAgICAgdGhpcy5fc2hhcGUucmVuZGVyKGN0eCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoLXcyLCAtaDIpO1xuICAgICAgICBpZih0aGlzLl9zY3JvbGxiYXJYLnZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbGJhclgucmVuZGVyKGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5fc2Nyb2xsYmFyWS52aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxiYXJZLnJlbmRlcihjdHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh3MiwgaDIpO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5yZWN0KC13MiwgLWgyLCB3LCBoKTtcbiAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICB0aGlzLl9zdGFjay5yZW5kZXIoY3R4KTtcbiAgICAgICAgdGhpcy5fbGlua1N0YWNrLnJlbmRlcihjdHgpOyAgICBcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY3gtdHgsIC1jeS10eSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgaXNIaXQocG9pbnQsIGNvbmRpdGlvbikge1xuICAgICAgICBjb25zdCBbZ3gsIGd5XSA9IHBvaW50O1xuICAgICAgICBjb25zdCBbY3gsIGN5XSA9IHRoaXMuYW5jaG9yOyBcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGgvMjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIGNvbnN0IHNwID0gW2d4IC0gY3ggKyB3LCBneSAtIGN5ICsgaF1cbiAgICAgICAgdGhpcy5fc2Nyb2xsQmFyU3RhdHVzLmhpdFNjcm9sbFggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsQmFyU3RhdHVzLmhpdFNjcm9sbFkgPSBmYWxzZTtcbiAgICAgICAgaWYodGhpcy5fc2Nyb2xsYmFyWC52aXNpYmxlKSB7XG4gICAgICAgICAgICBjb25zdCB4aGl0ID0gdGhpcy5fc2Nyb2xsYmFyWC5pc0hpdChzcCk7XG4gICAgICAgICAgICBpZih4aGl0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsQmFyU3RhdHVzLmhpdFNjcm9sbFggPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbGJhclguc2V0SGl0KHRydWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWC5zZXRIaXQoZmFsc2UpXG5cbiAgICAgICAgaWYodGhpcy5fc2Nyb2xsYmFyWS52aXNpYmxlKSB7XG4gICAgICAgICAgICBjb25zdCB5aGl0ID0gdGhpcy5fc2Nyb2xsYmFyWS5pc0hpdChzcCk7XG4gICAgICAgICAgICBpZih5aGl0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsQmFyU3RhdHVzLmhpdFNjcm9sbFkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbGJhclkuc2V0SGl0KHRydWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWS5zZXRIaXQoZmFsc2UpXG4gICAgICAgXG4gICAgICAgIC8vIGNvbnN0IGJyID0gdGhpcy5fZ2V0Vmlld0JveCgpO1xuICAgICAgICBjb25zdCBpc0luQm91bmQgPSB0aGlzLl9zaGFwZS5pc0hpdChbZ3ggLSBjeCwgZ3kgLSBjeV0pO1xuICAgICAgICBpZihpc0luQm91bmQpIHtcbiAgICAgICAgICAgIGNvbnN0IFt0eCwgdHldID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgICAgICAgY29uc3QgcCA9IFtneCAtIGN4IC0gdHgsIGd5IC0gY3kgLSB0eV07XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50cCA9IHA7IC8vIOaaguWtmO+8jOS4uuS6huWQjue7reiuoeeul+WIq+eahOS9jee9rlxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fc3RhY2suY2hlY2tIaXQocCwgY29uZGl0aW9uKTsgXG4gICAgICAgICAgICBpZih0YXJnZXQpIHJldHVybiB0YXJnZXQ7IFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3RhY2sucmVzZXRIaXRTdGF0dXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0Qm91bmRpbmdEaW1lbnNpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRCb3VuZGluZ1JlY3QoKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aCAvMjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIGNvbnN0IGx0eCA9IGFuY2hvclswXSAtIHc7XG4gICAgICAgIGNvbnN0IGx0eSA9IGFuY2hvclsxXSAtIGg7XG4gICAgICAgIGNvbnN0IHJieCA9IGFuY2hvclswXSArIHc7XG4gICAgICAgIGNvbnN0IHJieSA9IGFuY2hvclsxXSArIGg7XG4gICAgICAgIGNvbnN0IGJyID0gdGhpcy5fYm91bmRpbmdyZWN0O1xuICAgICAgICBiclswXSA9IGx0eDtcbiAgICAgICAgYnJbMV0gPSBsdHk7XG4gICAgICAgIGJyWzJdID0gcmJ4O1xuICAgICAgICBiclszXSA9IHJieTtcbiAgICAgICAgcmV0dXJuIGJyXG4gICAgfVxuXG4gICAgZ2V0SW50ZXJzZWN0aW9uc0luRm91ckRpbWVuc2lvbigpIHtcbiAgICAgICAgbGV0IHAyID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGlmKHRoaXMuX2JlbG9uZ3MgJiYgdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbikge1xuICAgICAgICAgICAgcDIgPSB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKHAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IFt4MiwgeTJdID0gcDI7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoLzI7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW0RJUkVDVElPTi5SSUdIVF06ICBbeDIrdywgeTJdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5MRUZUXTogICBbeDItdywgeTJdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5CT1RUT01dOiBbeDIsIHkyK2hdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5UT1BdOiAgICBbeDIsIHkyLWhdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5TRUxGXTogICBbeDIrdyowLjYxOCwgeTIraCowLjYxOF1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uRW50ZXJWaWV3Ym94KCkge1xuICAgICAgICB0aGlzLmludGVyYXRlTm9kZVN0YWNrKChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgICAgaW5zdGFuY2Uub25FbnRlclZpZXdib3goKTtcbiAgICAgICAgfSlcbiAgICB9XG4gICAgb25MZWF2ZVZpZXdib3goKSB7XG4gICAgICAgIHRoaXMuaW50ZXJhdGVOb2RlU3RhY2soKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICBpbnN0YW5jZS5vbkxlYXZlVmlld2JveCgpO1xuICAgICAgICB9KVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9zaGFwZS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaW50ZXJhdGVOb2RlU3RhY2soKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICBpbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IEMgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICBjb25zdCBjb25maWdzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fcmF3Q29uZmlncywge1xuICAgICAgICAgICAgbGF5b3V0OiB0aGlzLl9sYXlvdXQgJiYgdGhpcy5fbGF5b3V0LmNsb25lKCksXG4gICAgICAgIH0pXG4gICAgICAgIGNvbnN0IHQgPSBuZXcgQyhjb25maWdzKTtcbiAgICAgICAgdGhpcy5pbnRlcmF0ZU5vZGVTdGFjaygoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICAgIHQuYWRkVG9TdGFjayhpbnN0YW5jZS5jbG9uZSgpKTtcbiAgICAgICAgfSlcbiAgICAgICAgdC5yZWNhbGN1bGF0ZSgpO1xuICAgICAgICB0LnZpc2libGUgPSB0aGlzLnZpc2libGU7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cbn1cblxuT2JqZWN0LmFzc2lnbihTY3JvbGxHcm91cC5wcm90b3R5cGUsIFN0YWNrTWl4aW4pO1xuT2JqZWN0LmFzc2lnbihTY3JvbGxHcm91cC5wcm90b3R5cGUsIExheW91dE1peGluKTtcbk9iamVjdC5hc3NpZ24oU2Nyb2xsR3JvdXAucHJvdG90eXBlLCB7XG4gICAgcmVjYWxjdWxhdGVVcCgpIHtcbiAgICAgICAgbGV0IGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIGlmKHRoaXMuZ2V0Qm91bmRpbmdEaW1lbnNpb24pIHtcbiAgICAgICAgICAgIC8vIGNvbnN0IHsgd2lkdGg6IHdvbGQsIGhlaWdodDogaG9sZCB9ID0gdGhpcy5nZXRCb3VuZGluZ0RpbWVuc2lvbigpO1xuICAgICAgICAgICAgY29uc3Qgd29sZCA9IHRoaXMuX2lubmVyV2lkdGg7XG4gICAgICAgICAgICBjb25zdCBob2xkID0gdGhpcy5faW5uZXJIZWlnaHQ7XG4gICAgICAgICAgICBpZih0aGlzLnJlc2V0Q2hpbGRyZW5Qb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRDaGlsZHJlblBvc2l0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLl9nZXRCb3VuZGluZ0dyb3VwUmVjdCl7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0Qm91bmRpbmdHcm91cFJlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVmbG93KCk7XG4gICAgICAgICAgICBpZih0aGlzLl9nZXRCb3VuZGluZ0dyb3VwUmVjdCl7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0Qm91bmRpbmdHcm91cFJlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdub3cgPSB0aGlzLl9pbm5lcldpZHRoO1xuICAgICAgICAgICAgY29uc3QgaG5vdyA9IHRoaXMuX2lubmVySGVpZ2h0O1xuICAgICAgICAgICAgLy8gY29uc3QgeyB3aWR0aDogd25vdywgaGVpZ2h0OiBobm93IH0gPSB0aGlzLmdldEJvdW5kaW5nRGltZW5zaW9uKCk7XG4gICAgICAgICAgICBkaXJ0eSA9ICh3b2xkICE9PSB3bm93IHx8IGhvbGQgIT09IGhub3cpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlZmxvdygpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuX2JlbG9uZ3MgJiYgZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0T2Zmc2V0KCk7XG4gICAgICAgICAgICB0aGlzLl9iZWxvbmdzLnJlY2FsY3VsYXRlVXAoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWNhbGN1bGF0ZSgpIHtcbiAgICAgICAgY29uc3QgeyB3aWR0aDogd29sZCwgaGVpZ2h0OiBob2xkIH0gPSB0aGlzLmdldEJvdW5kaW5nRGltZW5zaW9uKCk7XG4gICAgICAgIHRoaXMucmVmbG93KCk7XG4gICAgICAgIGlmKHRoaXMuX2dldEJvdW5kaW5nR3JvdXBSZWN0KXtcbiAgICAgICAgICAgIHRoaXMuX2dldEJvdW5kaW5nR3JvdXBSZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB3aWR0aDogd25vdywgaGVpZ2h0OiBobm93IH0gPSB0aGlzLmdldEJvdW5kaW5nRGltZW5zaW9uKCk7XG4gICAgICAgIGlmICh3b2xkICE9PSB3bm93IHx8IGhvbGQgIT09IGhub3cpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0T2Zmc2V0KCk7XG4gICAgICAgIH1cbiAgICB9LFxufSlcblxuXG5leHBvcnQgZGVmYXVsdCBTY3JvbGxHcm91cCIsImV4cG9ydCBkZWZhdWx0IHtcbiAgICBjYW52YXM6IHtcbiAgICAgICAgd2hlZWwgKGV2ZW50LCBqZmxvdykge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGxldCB7IG9mZnNldFgsIG9mZnNldFksIGRlbHRhWCwgZGVsdGFZIH0gPSBldmVudCBcbiAgICAgICAgICAgIGlmKGV2ZW50LmN0cmxLZXkpIHsgXG4gICAgICAgICAgICAgICAgZGVsdGFZID0gLWRlbHRhWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGpmbG93Lnpvb21IYW5kbGVyKG9mZnNldFgsIG9mZnNldFksIGRlbHRhWCwgZGVsdGFZLCBldmVudCk7XG4gICAgICAgIH0sXG4gICAgfVxufSIsImltcG9ydCBJbnN0YW5jZSBmcm9tICcuL2luc3RhbmNlJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7SW5zdGFuY2V+Q29uZmlnc30gQmFzZUxpbmt+Q29uZmlnc1xuICogQHByb3BlcnR5IHtJbnN0YW5jZX0gZnJvbSAgIC0g6LW35aeL5Y2V5YWDXG4gKiBAcHJvcGVydHkge0luc3RhbmNlfSB0byAgICAgLSDnu4jmraLljZXlhYNcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBmcm9tRGlyICAtIOi1t+Wni+aWueWQkSBcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0b0RpciAgICAtIOe7iOatouaWueWQkSBcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXkgICAgICAtIOi/nue6v+WUr+S4gOmUruWAvFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGJhY2tncm91bmRDb2xvciAgICAtIOe6v+adoeminOiJsiBcbiAqL1xuLyoqXG4gKiDov57nur/ln7rnsbtcbiAqIEBjb25zdHJ1Y3RvciBCYXNlTGlua1xuICogQGV4dGVuZHMgSW5zdGFuY2VcbiAqIEBwYXJhbSB7QmFzZUxpbmt+Q29uZmlnc30gY29uZmlncyAtIOmFjee9rlxuICovXG5jbGFzcyBCYXNlTGluayBleHRlbmRzIEluc3RhbmNle1xuICAgIElOU1RBTkNFX1RZUEUgPSAnTElOSydcbiAgICBnZXQgbmV4dFNpYmxpbmcoKSB7XG4gICAgICAgIGlmKCF0aGlzLl9iZWxvbmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFjayA9IHRoaXMuX2JlbG9uZ3MuX2xpbmtTdGFja1xuICAgICAgICBjb25zdCBpZHggPSBzdGFjay5maW5kSW5kZXgocyA9PiBzID09PSB0aGlzKTtcbiAgICAgICAgaWYoaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrW2lkeCsxXTtcbiAgICAgICAgfSBcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3MgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKiogQG1lbWJlciB7SW5zdGFuY2V9ICAgICAgLSDotbflp4vljZXlhYMgKi9cbiAgICAgICAgdGhpcy5mcm9tICAgICA9IGNvbmZpZ3MuZnJvbTtcbiAgICAgICAgLyoqIEBtZW1iZXIge0luc3RhbmNlfSAgICAgIC0g57uI5q2i5Y2V5YWDICovXG4gICAgICAgIHRoaXMudG8gICAgICAgPSBjb25maWdzLnRvO1xuICAgICAgICAvKiogQG1lbWJlciB7RElSRUNUSU9OfSAgICAgIC0g6LW35aeL5pa55ZCRICovXG4gICAgICAgIHRoaXMuZnJvbURpciAgPSBjb25maWdzLmZyb21EaXI7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtESVJFQ1RJT059ICAgICAgLSDnu4jmraLmlrnlkJEgKi9cbiAgICAgICAgdGhpcy50b0RpciAgICA9IGNvbmZpZ3MudG9EaXI7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtudW1iZXJbXVtdfSAgICAgLSDov57nur/mjqfliLbngrnnvJPlrZggKi9cbiAgICAgICAgdGhpcy5fY2FjaGVQb2ludHMgPSBudWxsO1xuICAgICAgICAvKiogQG1lbWJlciB7c3RyaW5nfSAgICAgLSDov57nur/popzoibLvvIzpu5jorqTkuLogIzAwMCAqL1xuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IGNvbmZpZ3MuYmFja2dyb3VuZENvbG9yIHx8ICcjMDAwJztcblxuICAgICAgICB0aGlzLmlzU2VsZiAgICAgICAgPSAhIWNvbmZpZ3MuaXNTZWxmXG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIOaYr+WQpuWHuueOsOWcqOW9k+WJjeinhueql+WGhVxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHZpZXdib3hcbiAgICAgKi9cbiAgICBpc0luVmlld0JveCh2aWV3Ym94KXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgYnJpbmdUb1RvcCgpIHtcbiAgICAgICAgY29uc3QgbGlua1N0YWNrID0gdGhpcy5famZsb3cuX2xpbmtTdGFjaztcbiAgICAgICAgY29uc3QgaW5kZXggPSBsaW5rU3RhY2suZmluZEluZGV4KGwgPT4gbCA9PT0gdGhpcyk7XG4gICAgICAgIGxpbmtTdGFjay5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBsaW5rU3RhY2sucHVzaCh0aGlzKTtcbiAgICAgICAgdGhpcy5famZsb3cuX3JlbmRlcigpO1xuICAgIH1cblxuICAgIFxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlTGluazsiLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9ub2RlJztcblxuY2xhc3MgU2hhZG93Q2FjaGUgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3MpO1xuICAgICAgICAvLyB0aGlzLmltYWdlRGF0YSA9IGNvbmZpZ3MuaW1hZ2VEYXRhO1xuICAgICAgICB0aGlzLndpZHRoID0gY29uZmlncy53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBjb25maWdzLmhlaWdodDtcbiAgICAgICAgdGhpcy5pbWFnZUJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB0aGlzLmltYWdlQnVmZmVyLndpZHRoID0gdGhpcy53aWR0aCArIDI7XG4gICAgICAgIHRoaXMuaW1hZ2VCdWZmZXIuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyAyO1xuICAgICAgICBjb25maWdzLmNhY2hlKHRoaXMuaW1hZ2VCdWZmZXIuZ2V0Q29udGV4dCgnMmQnKSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKGN0eCkge1xuICAgICAgICBjb25zdCBbY3gsIGN5XSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLmltYWdlQnVmZmVyLCAtdGhpcy53aWR0aC8yLCAtdGhpcy5oZWlnaHQvMik7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoLWN4LCAtY3kpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGdldEJvdW5kaW5nRGltZW5zaW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVjYWxjdWxhdGUoKXt9XG4gICAgZ2V0Qm91bmRpbmdSZWN0KCkge1xuICAgICAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGggLzI7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICBjb25zdCBsdHggPSBhbmNob3JbMF0gLSB3O1xuICAgICAgICBjb25zdCBsdHkgPSBhbmNob3JbMV0gLSBoO1xuICAgICAgICBjb25zdCByYnggPSBhbmNob3JbMF0gKyB3O1xuICAgICAgICBjb25zdCByYnkgPSBhbmNob3JbMV0gKyBoO1xuICAgICAgICBjb25zdCBiciA9IHRoaXMuX2JvdW5kaW5ncmVjdDtcbiAgICAgICAgYnJbMF0gPSBsdHg7XG4gICAgICAgIGJyWzFdID0gbHR5O1xuICAgICAgICBiclsyXSA9IHJieDtcbiAgICAgICAgYnJbM10gPSByYnk7XG4gICAgICAgIHJldHVybiBiclxuICAgIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBTaGFkb3dDYWNoZTsiLCJpbXBvcnQgUmVjdGFuZ2xlIGZyb20gXCIuLi9zaGFwZXMvcmVjdGFuZ2xlXCI7XG5pbXBvcnQgeyByZXF1ZXN0Q2FjaGVDYW52YXMgfSBmcm9tICcuLi8uLi91dGlscy9jYW52YXMnO1xuaW1wb3J0IEpGbG93RXZlbnQgZnJvbSAnLi4vLi4vZXZlbnRzJ1xuaW1wb3J0IFNoYWRvd0NhY2hlIGZyb20gJy4uL3NoYXBlcy9zaGFkb3ctY2FjaGUnO1xuXG5jb25zdCBURVhUX0FMSUdOID0ge1xuICAgIENFTlRFUjogJ2NlbnRlcicsXG4gICAgTEVGVDogJ2xlZnQnLFxuICAgIFJJR0hUOiAncmlnaHQnLFxufTtcbmNvbnN0IFNQQUNFX1JFRyA9IC9cXHMvZztcblxuY2xhc3MgVGV4dCBleHRlbmRzIFJlY3RhbmdsZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlncykge1xuICAgICAgICBzdXBlcihjb25maWdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gICAgICAgICAnVGV4dCc7XG4gICAgICAgIHRoaXMuY29udGVudCA9ICAgICAgY29uZmlncy5jb250ZW50IHx8ICcnO1xuICAgICAgICB0aGlzLmZvbnRGYW1pbHkgPSAgICAgICBjb25maWdzLmZvbnRGYW1pbHkgfHwgJy1hcHBsZS1zeXN0ZW0sQmxpbmtNYWNTeXN0ZW1Gb250LFNlZ29lIFVJLFJvYm90byxIZWx2ZXRpY2EgTmV1ZSxIZWx2ZXRpY2EsVGFob21hLEFyaWFsLE5vdG8gU2FucyxQaW5nRmFuZyBTQyxNaWNyb3NvZnQgWWFIZWksSGlyYWdpbm8gU2FucyBHQixzYW5zLXNlcmlmLEFwcGxlIENvbG9yIEVtb2ppLFNlZ29lIFVJIEVtb2ppLFNlZ29lIFVJIFN5bWJvbCxOb3RvIENvbG9yIEVtb2ppJ1xuICAgICAgICB0aGlzLmZvbnRTaXplID0gICAgICAgICBjb25maWdzLmZvbnRTaXplIHx8ICcxNHB4JztcbiAgICAgICAgdGhpcy5mb250V2VpZ2h0ID0gICAgICAgY29uZmlncy5mb250V2VpZ2h0IHx8ICcnO1xuICAgICAgICB0aGlzLnRleHRDb2xvciA9ICAgICAgICBjb25maWdzLnRleHRDb2xvciB8fCAnd2hpdGUnO1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyQ29sb3IgPSBjb25maWdzLnBsYWNlaG9sZGVyQ29sb3IgfHwgIGNvbmZpZ3MudGV4dENvbG9yIHx8ICd3aGl0ZSc7XG4gICAgICAgIHRoaXMudGV4dEFsaWduID0gICAgICAgIGNvbmZpZ3MudGV4dEFsaWduIHx8IFRFWFRfQUxJR04uQ0VOVEVSO1xuICAgICAgICB0aGlzLnRleHRCYXNlbGluZSA9ICAgICBjb25maWdzLnRleHRCYXNlbGluZSB8fCAnbWlkZGxlJztcbiAgICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gICAgICAgY29uZmlncy5saW5lSGVpZ2h0IDtcbiAgICAgICAgdGhpcy5pbmRlbnQgPSAgICAgICAgICAgY29uZmlncy5pbmRlbnQgfHwgMDtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSAgY29uZmlncy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIHRoaXMuZWRpdGFibGUgPSAgICAgICAgIGNvbmZpZ3MuZWRpdGFibGU7XG4gICAgICAgIHRoaXMuZGVmaW5lZFdpZHRoID0gICAgIGNvbmZpZ3MuZGVmaW5lZFdpZHRoO1xuICAgICAgICB0aGlzLm1pbldpZHRoID0gICAgICAgICBjb25maWdzLm1pbldpZHRoIHx8IDA7XG4gICAgICAgIHRoaXMubWF4V2lkdGggPSAgICAgICAgIGNvbmZpZ3MubWF4V2lkdGg7XG4gICAgICAgIHRoaXMuZWxsaXBzaXMgPSAgICAgICAgIGNvbmZpZ3MuZWxsaXBzaXM7XG5cbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9ICAgICAgY29uZmlncy5wbGFjZWhvbGRlciB8fCAnJztcbiAgICAgICAgdGhpcy5lbXB0eVdoZW5JbnB1dCA9ICAgY29uZmlncy5lbXB0eVdoZW5JbnB1dCB8fCBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZWRpdHRpbmcgPSAgICAgICAgIGZhbHNlO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gICAgICAgICBjb25maWdzLmRpc2FibGVkO1xuXG4gICAgICAgIHRoaXMuY3Vyc29yQ29sb3IgPSAgICAgIGNvbmZpZ3MuY3Vyc29yQ29sb3IgfHwgJyM2MENGQzQnO1xuICAgICAgICB0aGlzLnRleHRSYW5nZUNvbG9yID0gICBjb25maWdzLnRleHRSYW5nZUNvbG9yIHx8ICcjNEU3NUVDMUEnO1xuXG4gICAgICAgIHRoaXMuc3BhY2VQbGFjZWhvbGRlciA9IGNvbmZpZ3Muc3BhY2VQbGFjZWhvbGRlcjtcbiAgICAgICAgdGhpcy5zcGFjZVBsYWNlaG9sZGVyQ29sb3IgPSBjb25maWdzLnNwYWNlUGxhY2Vob2xkZXJDb2xvcjtcbiAgICAgICAgdGhpcy5zcGFjZVJlY29yZHMgPSBbXTtcbiAgICAgICAgdGhpcy5fc3BhY2VkQ29udGVudFNlZ21uZW50ID0gW107XG5cbiAgICAgICAgdGhpcy5fc3RhdHVzID0ge1xuICAgICAgICAgICAgZWRpdGluZzogZmFsc2UsXG4gICAgICAgICAgICBjdXJzb3JzaG93OiB0cnVlLFxuICAgICAgICAgICAgY3Vyc29yYW5pbWU6IG51bGwsXG4gICAgICAgICAgICBsYXN0RWxhcHNlZDogMCxcbiAgICAgICAgICAgIHJlZnJlc2hFbGFwc2VkOiBmYWxzZSxcblxuICAgICAgICAgICAgY3Vyc29yRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAgICAgc2hpZnRPbjogZmFsc2UsXG5cbiAgICAgICAgICAgIG9sZFZhbDogJycsXG4gICAgICAgICAgICBpbnB1dEVsZW1lbnQ6IG51bGwsXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jdXJzb3JPZmZzZXQgPSAwO1xuXG4gICAgICAgIHRoaXMuX3RleHRSYW5nZSA9IHtcbiAgICAgICAgICAgIGVuYWJsZTogZmFsc2UsXG4gICAgICAgICAgICByYW5nZWZyb206IG51bGwsIC8vIG9mZnNldGZyb21cbiAgICAgICAgICAgIHJhbmdlVG86IG51bGwsICAgLy8gb2Zmc2V0dG9cbiAgICAgICAgICAgIGluaXRpYWxSYW5nZTogbnVsbCAvLyBvZmZzZXRcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLmVkaXRhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9tYWtlRnVuY3Rpb25hbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcmVDYWxjdWxhdGVUZXh0KCk7XG4gICAgICAgIHRoaXMuc2hhZG93Q2FjaGUoKTtcbiAgICAgICAgXG4gICAgfVxuXG4gICAgcmVwbGFjZVNwYWNlSG9sZGVyKGNvbnRlbnQsIHVzZUNhY2hlID0gZmFsc2UpIHtcbiAgICAgICAgaWYodXNlQ2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50LnJlcGxhY2UoL1xccy9nLCB0aGlzLnNwYWNlUGxhY2Vob2xkZXIpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByID0gdGhpcy5zcGFjZVJlY29yZHM7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLnNwYWNlUGxhY2Vob2xkZXJcbiAgICAgICAgci5sZW5ndGggPSAwO1xuICAgICAgICBsZXQgbGFzdE9mZnNldDtcbiAgICAgICAgY29uc3QgYyA9IGNvbnRlbnQucmVwbGFjZSgvXFxzL2csIChfLCBvZmZzZXQpID0+IHtcbiAgICAgICAgICAgIGlmKGxhc3RPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgci5wdXNoKG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihvZmZzZXQgLSBsYXN0T2Zmc2V0ID4gMSkge1xuICAgICAgICAgICAgICAgIHIucHVzaChsYXN0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0pXG4gICAgICAgIGlmKGxhc3RPZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgci5wdXNoKGxhc3RPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIGdldCBjdXJyZW50Q29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudCB8fCB0aGlzLnBsYWNlaG9sZGVyIHx8ICcnO1xuICAgIH1cblxuICAgIGdldCBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29udGVudDtcbiAgICB9XG5cbiAgICBwcmVDYWxjdWxhdGVUZXh0KCkge1xuICAgICAgICByZXF1ZXN0Q2FjaGVDYW52YXMoKGN0eCkgPT4ge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBgJHt0aGlzLmZvbnRXZWlnaHR9ICR7dGhpcy5mb250U2l6ZX0gJHt0aGlzLmZvbnRGYW1pbHl9YDtcbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSB0aGlzLnRleHRBbGlnbjtcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSB0aGlzLnRleHRCYXNlbGluZTtcbiAgICAgICAgICAgIGNvbnN0IHRfaCA9IHBhcnNlSW50KHRoaXMuZm9udFNpemUpO1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLmN1cnJlbnRDb250ZW50O1xuICAgICAgICAgICAgaWYodGhpcy5zcGFjZVBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IHRoaXMucmVwbGFjZVNwYWNlSG9sZGVyKGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICAvLyBhY3R1YWxCb3VuZGluZ0JveExlZnQsXG4gICAgICAgICAgICAgICAgLy8gYWN0dWFsQm91bmRpbmdCb3hSaWdodCxcbiAgICAgICAgICAgICAgICBmb250Qm91bmRpbmdCb3hBc2NlbnQsXG4gICAgICAgICAgICAgICAgZm9udEJvdW5kaW5nQm94RGVzY2VudCxcbiAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIH0gPSBjdHgubWVhc3VyZVRleHQoY29udGVudCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3RleHRXaWR0aCA9IHRoaXMuaW5kZW50ICsgd2lkdGg7XG4gICAgICAgICAgICBpZih0aGlzLmRlZmluZWRXaWR0aCkge1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuZWxsaXBzaXMgJiYgKHRoaXMuX3RleHRXaWR0aCA+IHRoaXMuZGVmaW5lZFdpZHRoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9jYWxjdWxhdGVPZmZzZXQodGhpcy5kZWZpbmVkV2lkdGggLSAxMik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxsaXBzaXNDb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcoMCwgb2Zmc2V0KSArICcuLi4nOyBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsbGlwc2lzQ29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSB0aGlzLmRlZmluZWRXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSBpZih0aGlzLm1heFdpZHRoICYmIHRoaXMuZWxsaXBzaXMpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLl90ZXh0V2lkdGggPiB0aGlzLm1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhdGlvID10aGlzLm1heFdpZHRoIC8gdGhpcy5fdGV4dFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsID0gTWF0aC5mbG9vcihjb250ZW50Lmxlbmd0aCAqIHJhdGlvIC0gMyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxsaXBzaXNDb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcoMCwgbCkgKyAnLi4uJzsgXG4gICAgICAgICAgICAgICAgfSAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxsaXBzaXNDb250ZW50ID0gY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IE1hdGgubWluKHRoaXMubWF4V2lkdGgsIHRoaXMuX3RleHRXaWR0aCk7XG4gICAgICAgICAgICB9IGVsc2V7IFxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSBNYXRoLm1heCh0aGlzLm1pbldpZHRoLCB0aGlzLl90ZXh0V2lkdGgpO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGlmKHRoaXMuc3BhY2VQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHNfd2lkdGgsXG4gICAgICAgICAgICAgICAgfSA9IGN0eC5tZWFzdXJlVGV4dCh0aGlzLnNwYWNlUGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHIyID0gdGhpcy5fc3BhY2VkQ29udGVudFNlZ21uZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRDb2xvciA9IHRoaXMudGV4dENvbG9yO1xuICAgICAgICAgICAgICAgIGxldCBsYXN0T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICByMi5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuc3BhY2VSZWNvcmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gdGhpcy5zcGFjZVJlY29yZHM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBjb2xvciA9IHRoaXMuc3BhY2VQbGFjZWhvbGRlckNvbG9yO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbCA9IHIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGkgPCBsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmID0gcltpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IHJbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHEgPSBjb250ZW50LnN1YnN0cmluZyhsYXN0T2Zmc2V0LCBmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIyLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1lYXN1cmVUZXh0KHEpLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICByMi5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LnN1YnN0cmluZyhmLCB0KzEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0IC0gZiArIDEpICogc193aWR0aCwgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gdCsxXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYobGFzdE9mZnNldCA8IGNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHEgPSBjb250ZW50LnN1YnN0cmluZyhsYXN0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcjIucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBxLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1lYXN1cmVUZXh0KHEpLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dENvbG9yLFxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSAoTWF0aC5hYnMoZm9udEJvdW5kaW5nQm94QXNjZW50KSArIE1hdGguYWJzKGZvbnRCb3VuZGluZ0JveERlc2NlbnQpKSB8fCB0X2g7XG4gICAgICAgICAgICB0aGlzLl90ZXh0SGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgaWYodGhpcy5saW5lSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzaGFkb3dDYWNoZSgpIHtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGggKiBzY2FsZTtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0ICogc2NhbGU7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLmluZGVudCAqIHNjYWxlO1xuICAgICAgICBjb25zdCBzaXplID0gcGFyc2VJbnQodGhpcy5mb250U2l6ZSkgKiBzY2FsZTtcbiAgICAgICAgdGhpcy5fc2hhZG93Q2FjaGUgPSBuZXcgU2hhZG93Q2FjaGUoe1xuICAgICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgICBoZWlnaHQ6IGgsXG4gICAgICAgICAgICBjYWNoZTogKGN0eCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGNvbnN0IFtjeCwgY3ldID0gdGhpcy5hbmNob3I7XG4gICAgICAgICAgICAgICAgLy8gY3R4LnNjYWxlKDQsIDQpXG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh3LzIsIGgvMik7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9udCA9IGAke3RoaXMuZm9udFdlaWdodH0gJHtzaXplfXB4ICR7dGhpcy5mb250RmFtaWx5fWA7XG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSBmb250XG4gICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IHRoaXMudGV4dEFsaWduO1xuICAgICAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSB0aGlzLnRleHRCYXNlbGluZTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5pc0VtcHR5ID8gdGhpcy5wbGFjZWhvbGRlckNvbG9yIDogdGhpcy50ZXh0Q29sb3I7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLmN1cnJlbnRDb250ZW50O1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuc3BhY2VQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLnRleHRBbGlnbiA9PT0gVEVYVF9BTElHTi5MRUZUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBodyA9IHcvMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfdyA9ICAtaHcgKyBpLzI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zcGFjZWRDb250ZW50U2VnbW5lbnQuZm9yRWFjaChzZWcgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBzZWdbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHNlZ1swXSwgX3csIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF93ICs9IHNlZ1sxXSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmVsbGlwc2lzQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IHRoaXMuZWxsaXBzaXNDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMudGV4dEFsaWduID09PSBURVhUX0FMSUdOLkxFRlQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGh3ID0gdyAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGNvbnRlbnQsICAtaHcgKyBpIC8gMiwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYodGhpcy50ZXh0QWxpZ24gPT09IFRFWFRfQUxJR04uUklHSFQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBodyA9IHcgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChjb250ZW50LCBodywgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChjb250ZW50LCBpIC8gMiwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgIH1cblxuICAgIHNldENvbmZpZyhjb25maWdzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGNvbmZpZ3MpLmZvckVhY2goayA9PiB7XG4gICAgICAgICAgICBpZihjb25maWdzW2tdICE9PSB1bmRlZmluZWQgJiYgY29uZmlnc1trXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXNba10gPSBjb25maWdzW2tdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jhd0NvbmZpZ3Nba10gPSBjb25maWdzW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcmVDYWxjdWxhdGVUZXh0KCk7XG4gICAgICAgIHRoaXMuc2hhZG93Q2FjaGUoKTtcbiAgICB9XG5cbiAgICBjbGljaygpIHtcbiAgICAgICAgaWYoIXRoaXMuX3N0YXR1cy5lZGl0aW5nKSB7XG4gICAgICAgICAgICBsZXQgZmxhZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2VkaXQnLCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpICBcbiAgICAgICAgICAgIGlmKCFmbGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMuX2JlbG9uZ3MuX2N1cnJlbnRwO1xuICAgICAgICAgICAgY29uc3QgamZsb3cgPSB0aGlzLl9qZmxvdzsgXG4gICAgICAgICAgICBpZihwb2ludCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvck9mZnNldCA9IHRoaXMuX3Bvc2l0aW9uVG9DdXJzb3JPZmZzZXQocG9pbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3JPZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBpbnB1dEVsZW1lbnQgPSBjcmVhdGVJbnB1dEVsZW1lbnQoXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udHJvbENhbGxiYWNrLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmYXVsdENhbGxiYWNrLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgY29uc3Qgd3JhcHBlciA9IGpmbG93LkRPTXdyYXBwZXI7XG4gICAgICAgICAgICB3cmFwcGVyLmFwcGVuZChpbnB1dEVsZW1lbnQpOyAgXG4gICAgICAgICAgICBpbnB1dEVsZW1lbnQuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pOyAgICAgIFxuICAgICAgICAgICAgamZsb3cuc2V0Rm9jdXNJbnN0YW5jZSh0aGlzKTtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9zdGF0dXMsIHtcbiAgICAgICAgICAgICAgICBlZGl0aW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIG9sZFZhbDogdGhpcy5jb250ZW50LFxuICAgICAgICAgICAgICAgIGlucHV0RWxlbWVudCxcbiAgICAgICAgICAgICAgICBjdXJzb3JhbmltZTogamZsb3cucmVxdWVzdEpGbG93QW5pbWUoKGVsYXBzZWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdEVsYXBzZWQgPSB0aGlzLl9zdGF0dXMubGFzdEVsYXBzZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuX3N0YXR1cy5yZWZyZXNoRWxhcHNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzLmxhc3RFbGFwc2VkID0gZWxhcHNlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5yZWZyZXNoRWxhcHNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKGVsYXBzZWQgLSBsYXN0RWxhcHNlZCA+IDUwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzLmN1cnNvcnNob3cgPSAhdGhpcy5fc3RhdHVzLmN1cnNvcnNob3c7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMubGFzdEVsYXBzZWQgPSBlbGFwc2VkO1xuICAgICAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmKHRoaXMuZW1wdHlXaGVuSW5wdXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3luY1NoYWRvd0lucHV0UG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9tYWtlRnVuY3Rpb25hbCgpIHtcbiAgICAgICAgY29uc3QgYmx1ckhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5lZGl0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZih0aGlzLl9zdGF0dXMuaW5wdXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzLmlucHV0RWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMuX2JlbG9uZ3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9qZmxvdy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYoZXZlbnQuY3VycmVudFRhcmdldCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5fc3RhdHVzLmVkaXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RGdWxsUmFuZ2UoKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZihldmVudC5jdXJyZW50VGFyZ2V0ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBldmVudC5kZXRhaWwuYnViYmxlcyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYodGhpcy5fc3RhdHVzLmVkaXRpbmcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMuX2JlbG9uZ3MuX2N1cnJlbnRwO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX3Bvc2l0aW9uVG9DdXJzb3JPZmZzZXQocG9pbnQpO1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuX3N0YXR1cy5zaGlmdE9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYWxSYW5nZSA9IHRoaXMuX3RleHRSYW5nZS5pbml0aWFsUmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fdGV4dFJhbmdlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZWZyb206IE1hdGgubWluKG9mZnNldCwgaW5pdGlhbFJhbmdlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlVG86IE1hdGgubWF4KG9mZnNldCwgaW5pdGlhbFJhbmdlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvck9mZnNldCA9IHRoaXMuX3RleHRSYW5nZS5yYW5nZVRvO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMuaW5wdXRFbGVtZW50LmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy5fcmVmcmVzaEN1cnNvcigpOyAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yT2Zmc2V0ID0gb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5pbnB1dEVsZW1lbnQuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWZyZXNoQ3Vyc29yKCk7ICBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zeW5jU2hhZG93SW5wdXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICB0aGlzLmNsaWNrKCk7XG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgYmx1ckhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdjaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICAgIG9sZFZhbDogdGhpcy5fc3RhdHVzLm9sZFZhbCxcbiAgICAgICAgICAgICAgICB2YWw6IHRoaXMuY29udGVudCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMuX3RleHRSYW5nZS5lbmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5jdXJzb3JhbmltZT8uY2FuY2VsKClcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fc3RhdHVzLCB7XG4gICAgICAgICAgICAgICAgZWRpdGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgY3Vyc29yc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjdXJzb3JhbmltZTogbnVsbCxcbiAgICAgICAgICAgICAgICBsYXN0RWxhcHNlZDogMCxcbiAgICAgICAgICAgICAgICByZWZyZXNoRWxhcHNlZDogZmFsc2UsXG5cbiAgICAgICAgICAgICAgICBjdXJzb3JEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hpZnRPbjogZmFsc2UsXG5cbiAgICAgICAgICAgICAgICBvbGRWYWw6ICcnLFxuICAgICAgICAgICAgICAgIGlucHV0RWxlbWVudDogbnVsbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignaW5zdGFuY2VQcmVzc1N0YXJ0JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZih0aGlzLl9zdGF0dXMuZWRpdGluZyAmJiAhdGhpcy5fc3RhdHVzLnNoaWZ0T24pIHtcbiAgICAgICAgICAgICAgICBldmVudC5kZXRhaWwuYnViYmxlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGV2ZW50LmRldGFpbC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy5fYmVsb25ncy5fY3VycmVudHA7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IHRoaXMuX3Bvc2l0aW9uVG9DdXJzb3JPZmZzZXQocG9pbnQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dFJhbmdlLmluaXRpYWxSYW5nZSA9IGM7XG4gICAgICAgICAgICAgICAgY29uc3QgamZsb3cgPSBldmVudC5kZXRhaWwuamZsb3c7XG4gICAgICAgICAgICAgICAgbGV0IG1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IChlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBqZmxvdy5fY2FsY3VsYXRlUG9pbnRCYWNrKFtvZmZzZXRYLCBvZmZzZXRZXSk7XG4gICAgICAgICAgICAgICAgICAgIGpmbG93Ll9zdGFjay5jaGVja0hpdChwKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMuX2JlbG9uZ3MuX2N1cnJlbnRwO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjID0gdGhpcy5fcG9zaXRpb25Ub0N1cnNvck9mZnNldChwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYWxSYW5nZSA9IHRoaXMuX3RleHRSYW5nZS5pbml0aWFsUmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5lZGl0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fdGV4dFJhbmdlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZWZyb206IE1hdGgubWluKGMsIGluaXRpYWxSYW5nZSksXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZVRvOiBNYXRoLm1heChjLCBpbml0aWFsUmFuZ2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCB0KVxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKCFtb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dFJhbmdlLmluaXRpYWxSYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFuZ2VUbyA9IHRoaXMuX3RleHRSYW5nZS5yYW5nZVRvO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3JPZmZzZXQgPSByYW5nZVRvO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMuZWRpdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5pbnB1dEVsZW1lbnQuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pOyAgIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0UmFuZ2UuaW5pdGlhbFJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX3Bvc2l0aW9uVG9DdXJzb3JPZmZzZXQocG9pbnQpIHtcbiAgICAgICAgY29uc3QgW3hdID0gcG9pbnQ7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoLzI7XG4gICAgICAgIGNvbnN0IFtveF0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IHggLSAob3ggLSB3KTtcbiAgICAgICAgbGV0IGN1cnNvck9mZnNldCA9IDA7XG4gICAgICAgIGlmKG9mZnNldFggPj0gdGhpcy5fdGV4dFdpZHRoKSB7XG4gICAgICAgICAgICBjdXJzb3JPZmZzZXQgPSB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3Vyc29yT2Zmc2V0ID0gdGhpcy5fY2FsY3VsYXRlT2Zmc2V0KG9mZnNldFgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN1cnNvck9mZnNldDtcbiAgICB9XG5cbiAgICBfY2FsY3VsYXRlT2Zmc2V0KG9mZngpIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQ7XG4gICAgICAgIGlmKHRoaXMuc3BhY2VQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgY29udGVudCA9IHRoaXMucmVwbGFjZVNwYWNlSG9sZGVyKGNvbnRlbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1heEwgPSBjb250ZW50Lmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRXaWR0aCA9IHRoaXMuX3RleHRXaWR0aDtcbiAgICAgICAgaWYoY29udGVudFdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbGx3aWR0aCA9IGNvbnRlbnRXaWR0aDtcbiAgICAgICAgbGV0IGlkeCA9IE1hdGguZmxvb3Iob2ZmeCAvIGFsbHdpZHRoICogbWF4TCkgO1xuICAgICAgICByZXF1ZXN0Q2FjaGVDYW52YXMoKGN0eCkgPT4ge1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBgJHt0aGlzLmZvbnRTaXplfSAke3RoaXMuZm9udEZhbWlseX1gO1xuICAgICAgICAgICAgbGV0IGcxLCBnMjtcbiAgICAgICAgICAgIGxldCBsYXN0aWR4O1xuXG4gICAgICAgICAgICBsZXQgYyA9IGNvbnRlbnQuc3Vic3RyaW5nKDAsIGlkeCk7XG4gICAgICAgICAgICBsZXQgYzEgPSBjb250ZW50LnN1YnN0cmluZyhpZHgtMSwgaWR4KTtcbiAgICAgICAgICAgIGxldCBjMiA9IGNvbnRlbnQuc3Vic3RyaW5nKGlkeCwgaWR4KzEpO1xuICAgICAgICAgICAgbGV0IHcgPSBjdHgubWVhc3VyZVRleHQoYykud2lkdGg7XG4gICAgICAgICAgICBsZXQgdzEgPSBjdHgubWVhc3VyZVRleHQoYzEpLndpZHRoO1xuICAgICAgICAgICAgbGV0IHcyID0gY3R4Lm1lYXN1cmVUZXh0KGMyKS53aWR0aDtcbiAgICAgICAgICAgIGcxID0gdyAtIHcxLzI7XG4gICAgICAgICAgICBnMiA9IHcgKyB3Mi8yO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYoZzEgPD0gb2ZmeCAmJiBnMiA+PSBvZmZ4KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgICAgIGlmKGcxID4gb2ZmeCkge1xuICAgICAgICAgICAgICAgICAgICAvLyDlt6bkvqflsJHkuoZcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BhbncgPSBnMiAtIG9mZng7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RpZHggPSBpZHg7XG4gICAgICAgICAgICAgICAgICAgIGlmKHNwYW53IDwgMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHggLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeCAtPSBNYXRoLmZsb29yKHNwYW53IC8gZzIgKiBsYXN0aWR4KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGMgPSBjb250ZW50LnN1YnN0cmluZyhpZHgsIGxhc3RpZHgpO1xuICAgICAgICAgICAgICAgICAgICB3IC09IGN0eC5tZWFzdXJlVGV4dChjKS53aWR0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoZzIgPCBvZmZ4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWPs+S+p+WwkeS6hlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGFudyA9IG9mZnggLSBnMTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdGlkeCA9IGlkeDtcbiAgICAgICAgICAgICAgICAgICAgaWYoc3BhbncgPCAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWR4ICs9IE1hdGguZmxvb3Ioc3BhbncgLyAoYWxsd2lkdGggLSBnMSkgKiAobWF4TCAtIGxhc3RpZHgpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGMgPSBjb250ZW50LnN1YnN0cmluZyhsYXN0aWR4LCBpZHgpO1xuICAgICAgICAgICAgICAgICAgICB3ICs9IGN0eC5tZWFzdXJlVGV4dChjKS53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgYzEgPSBjb250ZW50LnN1YnN0cmluZyhpZHgtMSwgaWR4KTtcbiAgICAgICAgICAgICAgICBjMiA9IGNvbnRlbnQuc3Vic3RyaW5nKGlkeCwgaWR4KzEpO1xuICAgICAgICAgICAgICAgIHcxID0gY3R4Lm1lYXN1cmVUZXh0KGMxKS53aWR0aDtcbiAgICAgICAgICAgICAgICB3MiA9IGN0eC5tZWFzdXJlVGV4dChjMikud2lkdGg7XG4gICAgICAgICAgICAgICAgZzEgPSB3IC0gdzEvMjtcbiAgICAgICAgICAgICAgICBnMiA9IHcgKyB3Mi8yO1xuICAgICAgICAgICAgfSB3aGlsZShpZHggPj0gMCAmJiBpZHggPD0gbWF4TClcbiAgICAgICAgICAgIFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG5cbiAgICBfcmVmcmVzaEN1cnNvcigpIHtcbiAgICAgICAgaWYodGhpcy5fc3RhdHVzLmVkaXRpbmcpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fc3RhdHVzLCB7XG4gICAgICAgICAgICAgICAgY3Vyc29yc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICByZWZyZXNoRWxhcHNlZDogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuX3RleHRSYW5nZS5lbmFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHRSYW5nZS5lbmFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcihjdHgpIHtcbiAgICAgICAgaWYodGhpcy5faXNNb3Zpbmcpe1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC42XG4gICAgICAgIH1cbiAgICAgICAgaWYoIWN0eC5kaXNhYmxlQ2FjaGUgJiYgIXRoaXMuX3N0YXR1cy5lZGl0aW5nICYmIHRoaXMuX2pmbG93LnNjYWxlICogcGFyc2VJbnQodGhpcy5mb250U2l6ZSkgPCA4KSB7XG4gICAgICAgICAgICBjb25zdCBbY3gsIGN5XSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICAgICAgLy8gdGhpcy5fc2hhZG93Q2FjaGUucmVuZGVyKGN0eCk7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjeCwgY3kpO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLl9zaGFkb3dDYWNoZS5pbWFnZUJ1ZmZlciwgLXRoaXMud2lkdGgvMiwgLXRoaXMuaGVpZ2h0LzIsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLWN4LCAtY3kpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZvbnQgPSBgJHt0aGlzLmZvbnRXZWlnaHR9ICR7dGhpcy5mb250U2l6ZX0gJHt0aGlzLmZvbnRGYW1pbHl9YDtcbiAgICAgICAgaWYoY3R4LmZvbnQgIT09IGZvbnQpIHtcbiAgICAgICAgICAgIGN0eC5mb250ID0gZm9udFxuICAgICAgICB9XG5cbiAgICAgICAgaWYoY3R4LnRleHRBbGlnbiAhPT0gdGhpcy50ZXh0QWxpZ24pIHtcbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSB0aGlzLnRleHRBbGlnbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGN0eC50ZXh0QmFzZWxpbmUgIT09IHRoaXMudGV4dEJhc2VsaW5lKSB7XG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gdGhpcy50ZXh0QmFzZWxpbmU7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5pc0VtcHR5ID8gdGhpcy5wbGFjZWhvbGRlckNvbG9yIDogdGhpcy50ZXh0Q29sb3I7XG4gICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5jdXJyZW50Q29udGVudDtcbiAgICAgICAgaWYodGhpcy5zcGFjZVBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICBpZih0aGlzLnRleHRBbGlnbiA9PT0gVEVYVF9BTElHTi5MRUZUKXtcbiAgICAgICAgICAgICAgICBjb25zdCBodyA9IHRoaXMud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIGxldCB3ID0gdGhpcy5hbmNob3JbMF0gLSBodyArIHRoaXMuaW5kZW50IC8gMjtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5hbmNob3JbMV07XG4gICAgICAgICAgICAgICAgdGhpcy5fc3BhY2VkQ29udGVudFNlZ21uZW50LmZvckVhY2goc2VnID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHNlZ1syXTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHNlZ1swXSwgdywgeSk7XG4gICAgICAgICAgICAgICAgICAgIHcgKz0gc2VnWzFdO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYodGhpcy5lbGxpcHNpc0NvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gdGhpcy5lbGxpcHNpc0NvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy50ZXh0QWxpZ24gPT09IFRFWFRfQUxJR04uTEVGVCl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGh3ID0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChjb250ZW50LCB0aGlzLmFuY2hvclswXSAtIGh3ICsgdGhpcy5pbmRlbnQgLyAyLCB0aGlzLmFuY2hvclsxXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKHRoaXMudGV4dEFsaWduID09PSBURVhUX0FMSUdOLlJJR0hUKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGh3ID0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChjb250ZW50LCB0aGlzLmFuY2hvclswXSArIGh3LCB0aGlzLmFuY2hvclsxXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGNvbnRlbnQsIHRoaXMuYW5jaG9yWzBdICsgdGhpcy5pbmRlbnQgLyAyLCB0aGlzLmFuY2hvclsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICBjb25zdCBodyA9IHRoaXMud2lkdGgvMjtcbiAgICAgICAgY29uc3QgdGV4dGhlaWdodCA9IHRoaXMuX3RleHRIZWlnaHRcbiAgICAgICAgY29uc3QgW3gsIHldID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IGx4ID0geCAtIGh3O1xuICAgICAgICBjb25zdCBseSA9IHkgLSB0ZXh0aGVpZ2h0LzI7XG5cbiAgICAgICAgaWYodGhpcy5fc3RhdHVzLmN1cnNvcnNob3cgJiYgdGhpcy5fc3RhdHVzLmVkaXRpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX2N1cnNvck9mZnNldDtcbiAgICAgICAgICAgIGxldCBjID0gY29udGVudC5zdWJzdHJpbmcoMCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmKHRoaXMuc3BhY2VQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgICAgIGMgPSB0aGlzLnJlcGxhY2VTcGFjZUhvbGRlcihjLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGN3ID0gbHggKyBjdHgubWVhc3VyZVRleHQoYykud2lkdGg7XG4gICAgICAgICAgICBjb25zdCBjX2xlbiA9IHRoaXMuX3RleHRIZWlnaHQvMjtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oY3csIHkgLSBjX2xlbik7XG4gICAgICAgICAgICBjdHgubGluZVRvKGN3LCB5ICsgY19sZW4pO1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDI7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmN1cnNvckNvbG9yO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5fdGV4dFJhbmdlLmVuYWJsZSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHJhbmdlZnJvbSwgcmFuZ2VUb1xuICAgICAgICAgICAgfSA9IHRoaXMuX3RleHRSYW5nZTtcbiAgICAgICAgICAgIGNvbnN0IGMgPSB0aGlzLmNvbnRlbnQuc3Vic3RyaW5nKDAsIHJhbmdlZnJvbSk7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMuY29udGVudC5zdWJzdHJpbmcocmFuZ2Vmcm9tLCByYW5nZVRvKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCB4ID0gbHggKyBjdHgubWVhc3VyZVRleHQoYykud2lkdGg7XG4gICAgICAgICAgICBjb25zdCB3ID0gY3R4Lm1lYXN1cmVUZXh0KHJhbmdlKS53aWR0aDtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5yZWN0KHgsIGx5LCB3LCB0ZXh0aGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnRleHRSYW5nZUNvbG9yXG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9IFxuICAgIH1cblxuICAgIF9pbnB1dENvbnRyb2wob3AsIGRhdGEpIHtcbiAgICAgICAgaWYodGhpcy5fdGV4dFJhbmdlLmVuYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgIGlmKG9wID09PSAnQmFja3NwYWNlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnaW5wdXQnLCB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsOiB0aGlzLl9zdGF0dXMub2xkVmFsLFxuICAgICAgICAgICAgICAgICAgICB2YWw6IHRoaXMuY29udGVudCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zeW5jU2hhZG93SW5wdXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9jdXJzb3JPZmZzZXQ7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQ7XG4gICAgICAgIGxldCBwcmVDb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcoMCwgb2Zmc2V0KTtcbiAgICAgICAgbGV0IGFmdGVyQ29udGVudCBcbiAgICAgICAgaWYodGhpcy5jYWNoZUlkeCkge1xuICAgICAgICAgICAgYWZ0ZXJDb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcodGhpcy5jYWNoZUlkeFsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZnRlckNvbnRlbnQgPSBjb250ZW50LnN1YnN0cmluZyhvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdG9wSW5wdXRFdmVudCA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2gob3Ape1xuICAgICAgICAgICAgY2FzZSBcIklucHV0XCI6XG4gICAgICAgICAgICAgICAgcHJlQ29udGVudCArPSBkYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvck9mZnNldCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSBwcmVDb250ZW50ICsgYWZ0ZXJDb250ZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNvbXBvc2l0aW9uc3RhcnRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlSWR4ID0gW3ByZUNvbnRlbnQubGVuZ3RoLCBwcmVDb250ZW50Lmxlbmd0aF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY29tcG9zaXRpb251cGRhdGVcIjpcbiAgICAgICAgICAgICAgICBwcmVDb250ZW50ID0gcHJlQ29udGVudC5zdWJzdHJpbmcoMCwgdGhpcy5jYWNoZUlkeFswXSk7XG4gICAgICAgICAgICAgICAgcHJlQ29udGVudCArPSBkYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudCA9IHByZUNvbnRlbnQgKyBhZnRlckNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3JPZmZzZXQgPSB0aGlzLmNhY2hlSWR4WzBdICsgZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZUlkeFsxXSA9IHRoaXMuY2FjaGVJZHhbMF0gKyBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjb21wb3NpdGlvbmVuZFwiOlxuICAgICAgICAgICAgICAgIHByZUNvbnRlbnQgPSBwcmVDb250ZW50LnN1YnN0cmluZygwLCB0aGlzLmNhY2hlSWR4WzBdKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3JPZmZzZXQgPSB0aGlzLmNhY2hlSWR4WzBdICsgZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZUlkeCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcHJlQ29udGVudCArPSBkYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudCA9IHByZUNvbnRlbnQgKyBhZnRlckNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRW50ZXJcIjpcbiAgICAgICAgICAgICAgICBpZih0aGlzLmNhY2hlSWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGRlZmF1bHRBY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnZW50ZXJrZXlwcmVzc2VkJywge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6ICh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRBY3QgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0b3BJbnB1dCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BJbnB1dEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIGlmKGRlZmF1bHRBY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5famZsb3cuYmx1cigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgIFxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkJhY2tzcGFjZVwiOlxuICAgICAgICAgICAgICAgIGlmKHRoaXMuY2FjaGVJZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmVDb250ZW50ID0gcHJlQ29udGVudC5zdWJzdHJpbmcoMCwgcHJlQ29udGVudC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3JPZmZzZXQgPSBNYXRoLm1heCgwLCB0aGlzLl9jdXJzb3JPZmZzZXQtMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50ID0gcHJlQ29udGVudCArIGFmdGVyQ29udGVudDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXN0b3BJbnB1dEV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2lucHV0Jywge1xuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICAgICAgICBvbGRWYWw6IHRoaXMuX3N0YXR1cy5vbGRWYWwsXG4gICAgICAgICAgICAgICAgdmFsOiB0aGlzLmNvbnRlbnQsXG4gICAgICAgICAgICB9KSk7XG4gICAgXG4gICAgICAgIH1cbiAgICAgICBcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIHRoaXMuc3luY1NoYWRvd0lucHV0UG9zaXRpb24oKTtcbiAgICB9XG5cbiAgICByZWZyZXNoKCkge1xuICAgICAgICB0aGlzLnByZUNhbGN1bGF0ZVRleHQoKTtcbiAgICAgICAgdGhpcy5fYmVsb25ncy5yZWNhbGN1bGF0ZVVwKCk7XG4gICAgICAgIHRoaXMuX2pmbG93LnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgfVxuXG4gICAgc3luY1NoYWRvd0lucHV0UG9zaXRpb24oKSB7XG4gICAgICAgIGlmKHRoaXMuX3N0YXR1cy5lZGl0aW5nKSB7XG4gICAgICAgICAgICBjb25zdCBodyA9IHRoaXMud2lkdGgvMjtcbiAgICAgICAgICAgIGNvbnN0IGhoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgICAgIGxldCBseCA9IHRoaXMuYW5jaG9yWzBdIC0gaHc7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9jdXJzb3JPZmZzZXQ7XG5cbiAgICAgICAgICAgIHJlcXVlc3RDYWNoZUNhbnZhcygoY3R4KSA9PiB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5mb250ID0gYCR7dGhpcy5mb250U2l6ZX0gJHt0aGlzLmZvbnRGYW1pbHl9YDtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gdGhpcy5jb250ZW50LnN1YnN0cmluZygwLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGx4ICs9IGN0eC5tZWFzdXJlVGV4dChjKS53aWR0aDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLmNhbGN1bGF0ZVRvUmVhbFdvcmxkKFtseCwgaGhdKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhc01ldGEgPSB0aGlzLl9qZmxvdy5jYW52YXNNZXRhO1xuICAgICAgICAgICAgY29uc3QgcHggPSBNYXRoLm1pbihjYW52YXNNZXRhLmFjdHVhbF93aWR0aCAtIDEyMCwgcG9pbnRbMF0pO1xuICAgICAgICAgICAgdGhpcy5fc3RhdHVzLmlucHV0RWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7cHh9cHgsICR7cG9pbnRbMV19cHgpYFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NvbnRyb2xDYWxsYmFjayhvcCwgZGF0YSwgZSkge1xuICAgICAgICBpZih0aGlzLl9zdGF0dXMuZWRpdGluZykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9zdGF0dXMsIHtcbiAgICAgICAgICAgICAgICBjdXJzb3JzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgIHJlZnJlc2hFbGFwc2VkOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKG9wKXtcbiAgICAgICAgICAgIGNhc2UgXCJJbnB1dFwiOlxuICAgICAgICAgICAgY2FzZSBcImNvbXBvc2l0aW9uc3RhcnRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjb21wb3NpdGlvbnVwZGF0ZVwiOlxuICAgICAgICAgICAgY2FzZSBcImNvbXBvc2l0aW9uZW5kXCI6XG4gICAgICAgICAgICBjYXNlIFwiRW50ZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJCYWNrc3BhY2VcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dENvbnRyb2wob3AsIGRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkFycm93TGVmdFwiOlxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX3RleHRSYW5nZS5lbmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dFJhbmdlLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9vbkFycm93TGVmdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjpcbiAgICAgICAgICAgICAgICBpZih0aGlzLl90ZXh0UmFuZ2UuZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHRSYW5nZS5lbmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fb25BcnJvd1JpZ2h0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiU2hpZnRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9vblNoaWZ0VG9nZ2xlKGRhdGEpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQ3RybEFcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RGdWxsUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJDT1BZXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fY29weShlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJDVVRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXQoZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUEFTVEVcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXN0ZShlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgX29uQXJyb3dMZWZ0KCkge1xuICAgICAgICB0aGlzLl9jdXJzb3JPZmZzZXQgPSBNYXRoLm1heCgwLCB0aGlzLl9jdXJzb3JPZmZzZXQgLSAxKTtcbiAgICAgICAgdGhpcy5famZsb3cuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgdGhpcy5zeW5jU2hhZG93SW5wdXRQb3NpdGlvbigpO1xuICAgIH1cblxuICAgIF9vbkFycm93UmlnaHQoKSB7XG4gICAgICAgIHRoaXMuX2N1cnNvck9mZnNldCA9IE1hdGgubWluKHRoaXMuY29udGVudC5sZW5ndGgsIHRoaXMuX2N1cnNvck9mZnNldCArIDEpO1xuICAgICAgICB0aGlzLl9qZmxvdy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICB0aGlzLnN5bmNTaGFkb3dJbnB1dFBvc2l0aW9uKCk7XG4gICAgfSAgICBcblxuICAgIF9vblNoaWZ0VG9nZ2xlKHZhbCkge1xuICAgICAgICB0aGlzLl9zdGF0dXMuc2hpZnRPbiA9IHZhbDtcbiAgICAgICAgaWYodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0UmFuZ2UuaW5pdGlhbFJhbmdlID0gdGhpcy5fY3Vyc29yT2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdGV4dFJhbmdlLmluaXRpYWxSYW5nZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc2VsZWN0RnVsbFJhbmdlKCkge1xuICAgICAgICB0aGlzLl90ZXh0UmFuZ2UgPSB7XG4gICAgICAgICAgICBlbmFibGU6IHRydWUsXG4gICAgICAgICAgICByYW5nZWZyb206IDAsXG4gICAgICAgICAgICByYW5nZVRvOiB0aGlzLmNvbnRlbnQubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3Vyc29yT2Zmc2V0ID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBfY2xlYXJUZXh0UmFuZ2UoKSB7XG4gICAgICAgIGlmKHRoaXMuX3RleHRSYW5nZS5lbmFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmFuZ2Vmcm9tLCByYW5nZVRvIH0gPSB0aGlzLl90ZXh0UmFuZ2U7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5jb250ZW50O1xuICAgICAgICAgICAgY29uc3QgcHJlQ29udGVudCA9IGNvbnRlbnQuc3Vic3RyaW5nKDAsIHJhbmdlZnJvbSk7XG4gICAgICAgICAgICBjb25zdCBhZnRlckNvbnRlbnQgPSBjb250ZW50LnN1YnN0cmluZyhyYW5nZVRvKTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudCA9IHByZUNvbnRlbnQgKyBhZnRlckNvbnRlbnQ7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3JPZmZzZXQgPSBwcmVDb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuX3RleHRSYW5nZS5lbmFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRTZWxlY3Rpb24oKSB7XG4gICAgICAgIGlmKHRoaXMuX3RleHRSYW5nZS5lbmFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmFuZ2Vmcm9tLCByYW5nZVRvIH0gPSB0aGlzLl90ZXh0UmFuZ2U7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5jb250ZW50O1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQuc3Vic3RyaW5nKHJhbmdlZnJvbSwgcmFuZ2VUbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgX2NvcHkoZXZlbnQpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5fZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGlmKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgZXZlbnQuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCBzZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jdXQoZXZlbnQpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5fZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGlmKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgZXZlbnQuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCBzZWxlY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wYXN0ZShldmVudCkge1xuICAgICAgICBsZXQgcGFzdGVDb250ZW50ID0gKGV2ZW50LmNsaXBib2FyZERhdGEgfHwgd2luZG93LmNsaXBib2FyZERhdGEpLmdldERhdGEoXCJ0ZXh0XCIpO1xuICAgICAgICBsZXQgZmxhZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ3Bhc3RlJywge1xuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgY29udGVudDogcGFzdGVDb250ZW50LFxuICAgICAgICAgICAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgICAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzb2x2ZVBhc3RlQ29udGVudChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHBhc3RlQ29udGVudCA9IGNhbGxiYWNrKHBhc3RlQ29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYoZmxhZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NsZWFyVGV4dFJhbmdlKCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX2N1cnNvck9mZnNldDtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuY29udGVudDtcbiAgICAgICAgY29uc3QgcHJlQ29udGVudCA9IGNvbnRlbnQuc3Vic3RyaW5nKDAsIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGFmdGVyQ29udGVudCA9IGNvbnRlbnQuc3Vic3RyaW5nKG9mZnNldCk7XG4gICAgICAgIHRoaXMuY29udGVudCA9IHByZUNvbnRlbnQgKyBwYXN0ZUNvbnRlbnQgKyBhZnRlckNvbnRlbnQ7XG4gICAgICAgIHRoaXMuX2N1cnNvck9mZnNldCA9IChwcmVDb250ZW50ICsgcGFzdGVDb250ZW50KS5sZW5ndGg7XG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH1cbiAgICBfZGVmYXVsdENhbGxiYWNrKG9wLCBlKSB7XG4gICAgICAgIHN3aXRjaChvcCl7XG4gICAgICAgICAgICBjYXNlICdLZXlEb3duJzogXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdrZXlkb3duJywge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGtleTogZS5rZXksXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGUuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgcmF3RXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnS2V5VXAnOiBcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2tleXVwJywge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGtleTogZS5rZXksXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGUuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgcmF3RXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmKHRoaXMuX2pmbG93Ll9mb2N1cy5pbnN0YW5jZSA9PT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy5famZsb3cuYmx1cigpO1xuICAgICAgICB9XG4gICAgfVxufSAgICAgICBcblxuZXhwb3J0IGRlZmF1bHQgVGV4dDtcblxuXG5mdW5jdGlvbiBjcmVhdGVJbnB1dEVsZW1lbnQoY29udHJvbENhbGxiYWNrLCBkZWZhdWx0Q2FsbGJhY2spIHtcbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKCdzdHlsZScsYFxuICAgICAgICB3aWR0aDogMTAwcHg7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBib3JkZXI6bm9uZTtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgICAgei1pbmRleDogLTE7XG4gICAgICAgIGNvbnRhaW46IHN0cmljdDtgKTtcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgLTEpO1xuICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnc3BlbGxjaGVjaycsIGZhbHNlKTtcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2F1dG9jb3JyZWN0JywgJ29mZicpO1xuXG5cbiAgICAvLyBsZXQgY29udGVudCA9IGNvbmZpZ3MuY29udGVudDtcbiAgICAvLyBsZXQgc3RhcnRpZHggPSAwO1xuXG4gICAgLy8gZnVuY3Rpb24gcmVuZGVyQ29udGVudCgpIHtcbiAgICAvLyAgICAgY29uZmlncy5jYWxsYmFjayhjb250ZW50KVxuICAgIC8vIH1cbiAgICBsZXQgc3RvcElucHV0ID0gZmFsc2U7XG4gICAgbGV0IHN0YXR1cyA9IHtcbiAgICAgICAgY3RybE9uOiBmYWxzZSxcbiAgICB9XG5cbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmVpbnB1dCcsIGUgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmKGUuZGF0YSkge1xuICAgICAgICAgICAgLy8gY29udGVudCArPSBlLmRhdGE7XG4gICAgICAgICAgICAvLyByZW5kZXJDb250ZW50KCk7XG4gICAgICAgICAgICBpZighc3RvcElucHV0KSB7XG4gICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKCdJbnB1dCcsIGUuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIChlKSA9PiB7XG4gICAgICAgIC8vIGNhY2hlIGNvbXBvc2l0aW9uIHN0YXJ0IG9mZnNldFxuICAgICAgICAvLyBzdGFydGlkeCA9IGNvbnRlbnQubGVuZ3RoO1xuICAgICAgICBjb250cm9sQ2FsbGJhY2soJ2NvbXBvc2l0aW9uc3RhcnQnKTtcbiAgICAgICAgc3RvcElucHV0ID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnVwZGF0ZScsIChlKSA9PiB7XG4gICAgICAgIC8vIHVwZGF0ZSBjb250ZW50XG4gICAgICAgIC8vIGNvbnRlbnQgPSBjb250ZW50LnN1YnN0cmluZygwLCBzdGFydGlkeCk7XG4gICAgICAgIC8vIGNvbnRlbnQgKz0gZS5kYXRhO1xuICAgICAgICAvLyByZW5kZXJDb250ZW50KCk7XG4gICAgICAgIGNvbnRyb2xDYWxsYmFjaygnY29tcG9zaXRpb251cGRhdGUnLCBlLmRhdGEpO1xuICAgIH0pO1xuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgKGUpID0+IHtcbiAgICAgICAgLy8gcmVwbGFjZSB0ZXh0IGF0IHN0YXJ0IG9mZnNldFxuICAgICAgICAvLyBjb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcoMCwgc3RhcnRpZHgpO1xuICAgICAgICAvLyBzdGFydGlkeCA9IDA7XG4gICAgICAgIC8vIGNvbnRlbnQgKz0gZS5kYXRhO1xuICAgICAgICAvLyByZW5kZXJDb250ZW50KCk7XG4gICAgICAgIGNvbnRyb2xDYWxsYmFjaygnY29tcG9zaXRpb25lbmQnLCBlLmRhdGEpO1xuICAgICAgICBpbnB1dC52YWx1ZSA9ICcnO1xuICAgICAgICBzdG9wSW5wdXQgPSBmYWxzZVxuICAgIH0pO1xuXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgc3dpdGNoKGV2ZW50LmtleSkge1xuICAgICAgICAgICAgY2FzZSBcIlNoaWZ0XCI6XG4gICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKFwiU2hpZnRcIiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIk1ldGFcIjpcbiAgICAgICAgICAgIGNhc2UgXCJDb250cm9sXCI6XG4gICAgICAgICAgICAgICAgc3RhdHVzLmN0cmxPbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZXZlbnQpID0+IHtcbiAgICAgICAgc3dpdGNoKGV2ZW50LmNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJFbnRlclwiOlxuICAgICAgICAgICAgICAgIC8vIGNvbnRlbnQgPSBjb250ZW50ICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyQ29udGVudCgpO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjaygnRW50ZXInKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJCYWNrc3BhY2VcIjpcbiAgICAgICAgICAgICAgICAvLyBjb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcoMCwgY29udGVudC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAvLyByZW5kZXJDb250ZW50KCk7XG4gICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKCdCYWNrc3BhY2UnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soXCJBcnJvd0xlZnRcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjayhcIkFycm93UmlnaHRcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XG4gICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKFwiQXJyb3dEb3duXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soXCJBcnJvd1VwXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaChldmVudC5rZXkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJTaGlmdFwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjayhcIlNoaWZ0XCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIk1ldGFcIjpcbiAgICAgICAgICAgIGNhc2UgXCJDb250cm9sXCI6XG4gICAgICAgICAgICAgICAgc3RhdHVzLmN0cmxPbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICBpZihzdGF0dXMuY3RybE9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjaygnQ3RybEEnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgZGVmYXVsdENhbGxiYWNrKCdLZXlVcCcsIGV2ZW50KTtcbiAgICB9KTtcblxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZXZlbnQpID0+IHtcbiAgICAgICAgZGVmYXVsdENhbGxiYWNrKCdLZXlEb3duJywgZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY29weScsIGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnRyb2xDYWxsYmFjaygnQ09QWScsIG51bGwsIGV2ZW50KTtcbiAgICB9KTtcblxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2N1dCcsIGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnRyb2xDYWxsYmFjaygnQ1VUJywgbnVsbCwgZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigncGFzdGUnLCBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBjb250cm9sQ2FsbGJhY2soJ1BBU1RFJywgbnVsbCwgZXZlbnQpO1xuICAgIH0pO1xuICAgIHJldHVybiBpbnB1dDtcbn1cbiIsImltcG9ydCBSZWN0YW5nbGUgZnJvbSAnLi9zaGFwZXMvcmVjdGFuZ2xlJztcbmltcG9ydCBTdGFja01peGluIGZyb20gJy4vc3RhY2tNaXhpbic7XG5pbXBvcnQgTGF5b3V0TWl4aW4gZnJvbSAnLi9sYXlvdXRNaXhpbic7XG5pbXBvcnQgeyBib3VuZGluZ19ib3ggfSBmcm9tICcuLi91dGlscy9mdW5jdGlvbnMnO1xuaW1wb3J0IHsgRElSRUNUSU9OIH0gZnJvbSAnLi4vdXRpbHMvY29uc3RhbmNlJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBJY29ufkltYWdlQm91bmRpbmdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aCAgIC0g5Zu+54mH5a695bqmXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0ICAgLSDlm77niYfpq5jluqYgXG4gKi9cbi8qKlxuICog5Zu+54mH5Y2V5YWDIOmFjee9rlxuICogQHR5cGVkZWYge1JlY3RhbmdsZX5SZWN0YW5nbGVDb25maWdzfSBJY29ufkljb25Db25maWdzXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW1hZ2UgICAtIOWbvueJh+WcsOWdgFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGltYWdlV2lkdGggICAtIOWbvueJh+WuveW6plxuICogQHByb3BlcnR5IHtudW1iZXJ9IGltYWdlSGVpZ2h0ICAgLSDlm77niYfpq5jluqZcbiAqL1xuXG4vKipcbiAqIOWbvueJh+WNleWFg1xuICogQGRlc2NyaXB0aW9uIOWbvueJh+WNleWFg+WPr+S7pee7mOWItuWbvueJh++8jOWbvueJh+WKoOi9veWQjuS8muiHquWKqOmHjeaWsOe7mOWItlxuICogQGNvbnN0cnVjdG9yIEljb25cbiAqIEBleHRlbmRzIFJlY3RhbmdsZVxuICogQHBhcmFtIHtJY29ufkljb25Db25maWdzfSBjb25maWdzIC0g6YWN572uXG4gKi9cbmNsYXNzIEljb24gZXh0ZW5kcyBSZWN0YW5nbGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3MpIHtcbiAgICAgICAgc3VwZXIoY29uZmlncylcbiAgICAgICAgLyoqIEBtZW1iZXIge0NhbnZhc0ltYWdlU291cmNlfSAgICAgIC0g5Zu+54mHICovXG4gICAgICAgIHRoaXMuaW1hZ2UgPSBjb25maWdzLmltYWdlO1xuICAgICAgICB0aGlzLmltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2pmbG93Ll9yZW5kZXIoKTtcbiAgICAgICAgICAgIC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyB9KVxuICAgICAgICB9XG4gICAgICAgIC8qKiBAbWVtYmVyIHtJY29ufkltYWdlQm91bmRpbmd9ICAgICAgLSDlm77niYfnu7TluqYgKi9cbiAgICAgICAgdGhpcy5pbWFnZUJvdW5kaW5nID0ge1xuICAgICAgICAgICAgd2lkdGg6IGNvbmZpZ3MuaW1hZ2VXaWR0aCB8fCBjb25maWdzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBjb25maWdzLmltYWdlSGVpZ2h0IHx8ICBjb25maWdzLmhlaWdodCxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldENvbmZpZyhjb25maWdzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGNvbmZpZ3MpLmZvckVhY2goayA9PiB7XG4gICAgICAgICAgICBpZihjb25maWdzW2tdICE9PSB1bmRlZmluZWQgJiYgY29uZmlnc1trXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXNba10gPSBjb25maWdzW2tdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jhd0NvbmZpZ3Nba10gPSBjb25maWdzW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYoY29uZmlncy5pbWFnZSAmJiAhY29uZmlncy5pbWFnZS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhpcy5pbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5famZsb3cuX3JlbmRlcigpO1xuICAgICAgICAgICAgICAgIC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gICAgIHRoaXMuX2pmbG93Ll9yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAvLyB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW1hZ2VCb3VuZGluZyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBjb25maWdzLmltYWdlV2lkdGggfHwgY29uZmlncy53aWR0aCB8fCB0aGlzLmltYWdlQm91bmRpbmcud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGNvbmZpZ3MuaW1hZ2VIZWlnaHQgfHwgIGNvbmZpZ3MuaGVpZ2h0IHx8IHRoaXMuaW1hZ2VCb3VuZGluZy5oZWlnaHQsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGlmKHRoaXMuX2lzTW92aW5nKXtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNlxuICAgICAgICB9XG4gICAgICAgIFJlY3RhbmdsZS5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcywgY3R4KTtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuYW5jaG9yWzBdIC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLmFuY2hvclsxXSAtIHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgaWYodGhpcy5vcGFjaXR5IDwgMSkge1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5vcGFjaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuaW1hZ2UuY29tcGxldGUpIHtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5pbWFnZSwgeCwgeSwgdGhpcy5pbWFnZUJvdW5kaW5nLndpZHRoLCB0aGlzLmltYWdlQm91bmRpbmcuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IEljb247IiwiaW1wb3J0IFJlY3RhbmdsZSBmcm9tICcuL3NoYXBlcy9yZWN0YW5nbGUnO1xuLyoqXG4gKiBAZnVudGlvbiBkb21GYWN0b3J5XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lciAtIERPTeWuueWZqFxuICovXG4vKipcbiAqIERPTeWFg+e0oOWuueWZqCDphY3nva5cbiAqIEB0eXBlZGVmIHtSZWN0YW5nbGV+Q29uZmlnc30gU2hhZG93RG9tflJlY3RhbmdsZUNvbmZpZ3NcbiAqIEBwcm9wZXJ0eSB7ZG9tRmFjdG9yeX0gY3JlYXRlRG9jdW1lbnQgLSDlrr1cbiAqL1xuLyoqXG4gKiBET03lhYPntKDlrrnlmagg5YaF5a655Y+v6LS0IERPTSDlhYPntKDvvIzmlK/mjIHnvKnmlL7lubPnp7tcbiAqIEBjb25zdHJ1Y3RvciBTaGFkb3dEb21cbiAqIEBleHRlbmRzIFJlY3RhbmdsZVxuICogQHBhcmFtIHtTaGFkb3dEb21+UmVjdGFuZ2xlQ29uZmlnc30gY29uZmlnc1xuICovXG5jbGFzcyBTaGFkb3dEb20gZXh0ZW5kcyBSZWN0YW5nbGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3MpIHtcbiAgICAgICAgc3VwZXIoY29uZmlncyk7XG4gICAgICAgIHRoaXMuZG9tRmFjdG9yeSA9IGNvbmZpZ3MuY3JlYXRlRG9jdW1lbnQ7XG4gICAgICAgIHRoaXMuX2RvbSA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0UmVhbFdvcmxkUG9zaXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGIgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVUb1JlYWxXb3JsZChiLnNsaWNlKDAsIDIpKTtcbiAgICB9XG5cbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIGlmKCF0aGlzLl9kb20gJiYgdGhpcy5kb21GYWN0b3J5KSB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmKCF0aGlzLl9kb20pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UmVhbFdvcmxkUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9qZmxvdy5zY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBgXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogJHt0aGlzLndpZHRofXB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAke3RoaXMuaGVpZ2h0fXB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3A7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoJHtwb3NbMF19cHgsICR7cG9zWzFdfXB4KSBzY2FsZSgke3NjYWxlfSk7YCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvbSA9IGNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5famZsb3cuRE9Nd3JhcHBlci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbUZhY3RvcnkoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UmVhbFdvcmxkUG9zaXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5famZsb3cuc2NhbGU7XG4gICAgICAgICAgICB0aGlzLl9kb20uc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke3Bvc1swXX1weCwgJHtwb3NbMV19cHgpIHNjYWxlKCR7c2NhbGV9KWBcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5yZW5kZXIoY3R4KVxuICAgIH0gICAgXG5cbiAgICBvbkVudGVyVmlld2JveCgpIHtcbiAgICAgICAgaWYodGhpcy5fZG9tKSB7XG4gICAgICAgICAgICB0aGlzLl9kb20uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkxlYXZlVmlld2JveCgpe1xuICAgICAgICBpZih0aGlzLl9kb20pIHtcbiAgICAgICAgICAgIHRoaXMuX2RvbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgXG4gICAgICAgIGlmKHRoaXMuX2RvbSkge1xuICAgICAgICAgICAgdGhpcy5famZsb3cuRE9Nd3JhcHBlci5yZW1vdmVDaGlsZCh0aGlzLl9kb20pO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBTaGFkb3dEb207XG4iLCJpbXBvcnQgQmFzZUxpbmsgZnJvbSAnLi9iYXNlLWxpbmsnO1xuaW1wb3J0IHsgZGlzdFRvU2VnbWVudFNxdWFyZWQsXG4gICAgaXNQb2x5TGluZUludGVyc2VjdGlvblJlY3RhbmdlLFxuICAgIGNvbXBhcmVCb3VuZGluZ2JveCxcbiAgICBjb3B5Qm91bmRpbmdib3hcbn0gZnJvbSAnLi4vdXRpbHMvZnVuY3Rpb25zJztcbmltcG9ydCB7IEFQUFJPWElNQVRFIH0gZnJvbSAnLi4vdXRpbHMvY29uc3RhbmNlJztcbi8qKlxuICogQHR5cGVkZWYge0Jhc2VMaW5rfkNvbmZpZ3N9IExpbmt+Q29uZmlnc1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IGFwcHJveGltYXRlICAgLSDngrnlh7vlk43lupTojIPlm7RcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyW119IGxpbmVEYXNoICAgIC0g6Jma57q/5pWw57uEXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRvdWJsZUxpbmsgICAtIOWPjOWQkeeureWktFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGZvbnRGYW1pbHkgICAgLSDov57nur/kuIrnmoTmloflrZflrZfkvZNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBmb250U2l6ZSAgICAgIC0g6L+e57q/5LiK55qE5paH5a2X5aSn5bCPXG4gKiBAcHJvcGVydHkge1N0cmluZ30gY29udGVudCAgICAgICAtIOi/nue6v+S4iueahOaWh+Wtl1xuICovXG4vKipcbiAqIOebtOe6v1xuICogQGNvbnN0cnVjdG9yIExpbmtcbiAqIEBleHRlbmRzIEJhc2VMaW5rXG4gKiBAcGFyYW0ge0xpbmt+Q29uZmlnc30gY29uZmlncyAtIOmFjee9rlxuICovXG5jbGFzcyBMaW5rIGV4dGVuZHMgQmFzZUxpbmsge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3MpIHtcbiAgICAgICAgc3VwZXIoY29uZmlncyk7XG4gICAgICAgIHRoaXMuZm9udEZhbWlseSAgICA9IGNvbmZpZ3MuZm9udEZhbWlseSA9ICctYXBwbGUtc3lzdGVtLEJsaW5rTWFjU3lzdGVtRm9udCxTZWdvZSBVSSxSb2JvdG8sSGVsdmV0aWNhIE5ldWUsSGVsdmV0aWNhLFRhaG9tYSxBcmlhbCxOb3RvIFNhbnMsUGluZ0ZhbmcgU0MsTWljcm9zb2Z0IFlhSGVpLEhpcmFnaW5vIFNhbnMgR0Isc2Fucy1zZXJpZixBcHBsZSBDb2xvciBFbW9qaSxTZWdvZSBVSSBFbW9qaSxTZWdvZSBVSSBTeW1ib2wsTm90byBDb2xvciBFbW9qaSdcbiAgICAgICAgdGhpcy5mb250U2l6ZSAgICAgID0gY29uZmlncy5mb250U2l6ZSB8fCAnMTJweCc7XG4gICAgICAgIHRoaXMuY29udGVudCAgICAgICA9IGNvbmZpZ3MuY29udGVudCB8fCAnJztcbiAgICAgICAgdGhpcy5saW5lRGFzaCAgICAgID0gY29uZmlncy5saW5lRGFzaDtcbiAgICAgICAgdGhpcy5hcHByb3hpbWF0ZSAgPSBjb25maWdzLmFwcHJveGltYXRlIHx8IEFQUFJPWElNQVRFO1xuXG4gICAgICAgIHRoaXMuX2NhY2hlQW5nbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2NhY2hlUG9pbnRzID0gW107XG4gICAgICAgIHRoaXMuX2NhY2hlQm91bmRpbmdib3ggPSB7XG4gICAgICAgICAgICBmcm9tOiBbXSxcbiAgICAgICAgICAgIHRvOiBbXVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIF9jYWxjdWxhdGVBbmNob3JQb2ludHMoKSB7XG4gICAgICAgIGNvbnN0IHAwID0gdGhpcy5mcm9tLmNhbGN1bGF0ZUludGVyc2VjdGlvbih0aGlzLnRvLmdldENlbnRlcigpKTtcbiAgICAgICAgY29uc3QgcDEgPSB0aGlzLnRvLmNhbGN1bGF0ZUludGVyc2VjdGlvbih0aGlzLmZyb20uZ2V0Q2VudGVyKCkpO1xuICAgICAgICB0aGlzLl9jYWNoZVBvaW50c1swXSA9IHAwO1xuICAgICAgICB0aGlzLl9jYWNoZVBvaW50c1sxXSA9IHAxO1xuICAgICAgICBjb25zdCBkeCA9IHAxWzBdIC0gcDBbMF07XG4gICAgICAgIGNvbnN0IGR5ID0gcDFbMV0gLSBwMFsxXTtcbiAgICAgICAgY29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG4gICAgICAgIHRoaXMuX2NhY2hlQW5nbGUgPSBhbmdsZTtcbiAgICB9XG4gICAgXG4gICAgaXNJblZpZXdCb3goYnIpIHtcbiAgICAgICAgY29uc3QgZnJvbWJveCA9IHRoaXMuZnJvbS5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgY29uc3QgdG9ib3ggPSB0aGlzLnRvLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICBjb25zdCBfYm94ID0gdGhpcy5fY2FjaGVCb3VuZGluZ2JveDtcbiAgICAgICAgaWYoIWNvbXBhcmVCb3VuZGluZ2JveChfYm94LmZyb20sIGZyb21ib3gpIHx8IGNvbXBhcmVCb3VuZGluZ2JveChfYm94LnRvLCB0b2JveCkpIHtcbiAgICAgICAgICAgIGNvcHlCb3VuZGluZ2JveChfYm94LmZyb20sIGZyb21ib3gpO1xuICAgICAgICAgICAgY29weUJvdW5kaW5nYm94KF9ib3gudG8sIHRvYm94KTtcbiAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZUFuY2hvclBvaW50cygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJlbmRlcihjdHgpIHtcbiAgICAgICAgY29uc3QgWyBwMCwgcDEgXSA9IHRoaXMuX2NhY2hlUG9pbnRzO1xuICAgICAgICBjb25zdCBhbmdsZSA9IHRoaXMuX2NhY2hlQW5nbGU7XG4gICAgICAgIGNvbnN0IGR4ID0gcDFbMF0gLSBwMFswXTtcbiAgICAgICAgY29uc3QgZHkgPSBwMVsxXSAtIHAwWzFdO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgaWYodGhpcy5jb250ZW50KXsgXG5cbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgIGN0eC5mb250ID0gYCR7dGhpcy5mb250U2l6ZX0gJHt0aGlzLmZvbnRGYW1pbHl9YDtcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBhY3R1YWxCb3VuZGluZ0JveExlZnQsXG4gICAgICAgICAgICAgICAgYWN0dWFsQm91bmRpbmdCb3hSaWdodCxcbiAgICAgICAgICAgICAgICBmb250Qm91bmRpbmdCb3hBc2NlbnQsXG4gICAgICAgICAgICAgICAgZm9udEJvdW5kaW5nQm94RGVzY2VudFxuICAgICAgICAgICAgfSA9IGN0eC5tZWFzdXJlVGV4dCh0aGlzLmNvbnRlbnQpO1xuICAgICAgICAgICAgY29uc3QgeCA9IGR4IC8yICsgcDBbMF07XG4gICAgICAgICAgICBjb25zdCB5ID0gZHkgLzIgKyBwMFsxXTtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLmNvbnRlbnQsIHgsIHkpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLmFicyhhY3R1YWxCb3VuZGluZ0JveExlZnQpICsgTWF0aC5hYnMoYWN0dWFsQm91bmRpbmdCb3hSaWdodCkgKyAyMDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IChNYXRoLmFicyhmb250Qm91bmRpbmdCb3hBc2NlbnQpICsgTWF0aC5hYnMoZm9udEJvdW5kaW5nQm94RGVzY2VudCkpICogMS41O1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgbGV0IHJlZ2lvbiA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgICAgIHJlZ2lvbi5yZWN0KHggLSB3aWR0aC8yICwgeSAtIGhlaWdodC8yLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IHJ4ID0gTWF0aC5taW4ocDFbMF0sIHAwWzBdKSAtIDEwO1xuICAgICAgICAgICAgY29uc3QgcnkgPSBNYXRoLm1pbihwMVsxXSwgcDBbMV0pIC0gMTA7XG4gICAgICAgICAgICBjb25zdCBydyA9IE1hdGguYWJzKGR4KSArIDIwO1xuICAgICAgICAgICAgY29uc3QgcmggPSBNYXRoLmFicyhkeSkgKyAyMDtcbiAgICAgICAgICAgIHJlZ2lvbi5yZWN0KHJ4ICwgcnksIHJ3LCByaCk7XG4gICAgICAgICAgICBjdHguY2xpcChyZWdpb24sIFwiZXZlbm9kZFwiKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgY3R4Lm1vdmVUbyhwMFswXSwgcDBbMV0pO1xuICAgICAgICBjdHgubGluZVRvKHAxWzBdLCBwMVsxXSk7XG4gICAgICAgIGlmKHRoaXMubGluZURhc2gpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguc2V0TGluZURhc2godGhpcy5saW5lRGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBpZih0aGlzLmxpbmVEYXNoKSB7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnRyYW5zbGF0ZShwMVswXSwgcDFbMV0pO1xuICAgICAgICBjdHgucm90YXRlKGFuZ2xlKTtcbiAgICAgICAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgICAgICAgY3R4LmxpbmVUbygtNSwgLTQpO1xuICAgICAgICBjdHgubGluZVRvKC01LCA0KTtcbiAgICAgICAgY3R4LmxpbmVUbygwLCAwKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnJvdGF0ZSgtYW5nbGUpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKC1wMVswXSwgLXAxWzFdKTtcbiAgICB9XG5cbiAgICBpc0hpdChwb2ludCkge1xuICAgICAgICBpZighdGhpcy5fY2FjaGVQb2ludHMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgWyBzdGFydCwgZW5kIF0gPSB0aGlzLl9jYWNoZVBvaW50cztcbiAgICAgICAgY29uc3QgZGlzdCA9IGRpc3RUb1NlZ21lbnRTcXVhcmVkKHBvaW50LCBzdGFydCwgZW5kKVxuICAgICAgICByZXR1cm4gZGlzdCA8IHRoaXMuYXBwcm94aW1hdGU7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMaW5rOyIsImltcG9ydCBCYXNlTGluayBmcm9tICcuL2Jhc2UtbGluayc7XG5pbXBvcnQgeyBcbiAgICBwb2x5bGluZVBvaW50cywgXG4gICAgZGlzdFRvU2VnbWVudFNxdWFyZWQsIFxuICAgIG1ha2VSYWRpdXNGcm9tVmVjdG9yLCBcbiAgICBtaW5JbnRlcnNlY3Rpb25CZXR3ZWVuTm9kZXMsXG4gICAgaXNQb2x5TGluZUludGVyc2VjdGlvblJlY3RhbmdlLFxufSBmcm9tICcuLi91dGlscy9mdW5jdGlvbnMnO1xuaW1wb3J0IHsgQVBQUk9YSU1BVEUsIERJUkVDVElPTiB9IGZyb20gJy4uL3V0aWxzL2NvbnN0YW5jZSc7XG4vLyBpbXBvcnQgeyBkaXN0MiwgYmV6aWVyUG9pbnQgfSBmcm9tICcuLi91dGlscy9mdW5jdGlvbnMnO1xuY29uc3QgUElJTlJBVElPID0gTWF0aC5QSSAvIDE4MFxuLyoqXG4gKiBAdHlwZWRlZiB7QmFzZUxpbmt+Q29uZmlnc30gUG9seUxpbmt+Q29uZmlnc1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IGFwcHJveGltYXRlICAgLSDngrnlh7vlk43lupTojIPlm7RcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByYWRpdXMgICAgICAgIC0g5ouQ6KeS5byn5bqmXG4gKiBAcHJvcGVydHkge051bWJlcn0gbWluU3BhblggICAgICAtIOi1t+eCuee7iOeCueWcqCB4IOaWueWQkeacgOWwj+eahOi3qOW6plxuICogQHByb3BlcnR5IHtOdW1iZXJ9IG1pblNwYW5ZICAgICAgLSDotbfngrnnu4jngrnlnKggeSDmlrnlkJHmnIDlsI/nmoTot6jluqZcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IGxpbmVEYXNoICAgIC0g6Jma57q/5pWw57uEXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRvdWJsZUxpbmsgICAtIOWPjOWQkeeureWktFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGZvbnRGYW1pbHkgICAgLSDov57nur/kuIrnmoTmloflrZflrZfkvZNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBmb250U2l6ZSAgICAgIC0g6L+e57q/5LiK55qE5paH5a2X5aSn5bCPXG4gKiBAcHJvcGVydHkge1N0cmluZ30gY29udGVudCAgICAgICAtIOi/nue6v+S4iueahOaWh+Wtl1xuICogQHByb3BlcnR5IHtTdHJpbmd9IGlzU2VsZiAgICAgICAgLSDmmK/lkKbkuLroh6rov57mjqVcbiAqL1xuLyoqXG4gKiDmlrnlvaLmipjnur9cbiAqIEBjb25zdHJ1Y3RvciBQb2x5TGlua1xuICogQGV4dGVuZHMgQmFzZUxpbmtcbiAqIEBwYXJhbSB7UG9seUxpbmt+Q29uZmlnc30gY29uZmlncyAtIOmFjee9rlxuICovXG5jbGFzcyBQb2x5TGluayBleHRlbmRzIEJhc2VMaW5rIHtcbiAgICAgLyoqXG4gICAgICog5Yib5bu65pa55b2i5oqY57q/XG4gICAgICogQHBhcmFtIHtQb2x5TGlua35Db25maWdzfSBjb25maWdzIC0g6YWN572uXG4gICAgICoqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3MpIHtcbiAgICAgICAgc3VwZXIoY29uZmlncyk7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgLSDngrnlh7vlk43lupTojIPlm7QgKi9cbiAgICAgICAgdGhpcy5hcHByb3hpbWF0ZSAgID0gY29uZmlncy5hcHByb3hpbWF0ZSB8fCBBUFBST1hJTUFURTtcbiAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAtIOaLkOinkuW8p+W6piAqL1xuICAgICAgICB0aGlzLnJhZGl1cyAgICAgICAgPSBjb25maWdzLnJhZGl1cyB8fCAwO1xuICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgIC0g6LW354K557uI54K55ZyoIHgg5pa55ZCR5pyA5bCP55qE6Leo5bqmICovXG4gICAgICAgIHRoaXMubWluU3BhblggICAgICA9IGNvbmZpZ3MubWluU3BhblggfHwgMTA7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgLSDotbfngrnnu4jngrnlnKggeSDmlrnlkJHmnIDlsI/nmoTot6jluqYgKi9cbiAgICAgICAgdGhpcy5taW5TcGFuWSAgICAgID0gY29uZmlncy5taW5TcGFuWSB8fCAxMDtcbiAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgLSDomZrnur/mlbDnu4QgKi9cbiAgICAgICAgdGhpcy5saW5lRGFzaCAgICAgID0gY29uZmlncy5saW5lRGFzaDtcbiAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgLSDlj4zlkJHnrq3lpLQgKi9cbiAgICAgICAgdGhpcy5kb3VibGVMaW5rICAgID0gY29uZmlncy5kb3VibGVMaW5rO1xuICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAtIOi/nue6v+S4iueahOaWh+Wtl+Wtl+S9kyAqL1xuICAgICAgICB0aGlzLmZvbnRGYW1pbHkgICAgPSBjb25maWdzLmZvbnRGYW1pbHkgPSAnLWFwcGxlLXN5c3RlbSxCbGlua01hY1N5c3RlbUZvbnQsU2Vnb2UgVUksUm9ib3RvLEhlbHZldGljYSBOZXVlLEhlbHZldGljYSxUYWhvbWEsQXJpYWwsTm90byBTYW5zLFBpbmdGYW5nIFNDLE1pY3Jvc29mdCBZYUhlaSxIaXJhZ2lubyBTYW5zIEdCLHNhbnMtc2VyaWYsQXBwbGUgQ29sb3IgRW1vamksU2Vnb2UgVUkgRW1vamksU2Vnb2UgVUkgU3ltYm9sLE5vdG8gQ29sb3IgRW1vamknXG4gICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgIC0g6L+e57q/5LiK55qE5paH5a2X5aSn5bCPICovXG4gICAgICAgIHRoaXMuZm9udFNpemUgICAgICA9IGNvbmZpZ3MuZm9udFNpemUgfHwgJzEycHgnO1xuICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAtIOi/nue6v+S4iueahOaWh+WtlyAqL1xuICAgICAgICB0aGlzLmNvbnRlbnQgICAgICAgPSBjb25maWdzLmNvbnRlbnQgfHwgJyc7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgIC0g5piv5ZCm5Li66Ieq6L+e5o6lICovXG4gICAgICAgIHRoaXMuaXNTZWxmICAgICAgICA9ICEhY29uZmlncy5pc1NlbGZcblxuICAgICAgICB0aGlzLm5vQXJyb3cgICAgICAgPSAhIWNvbmZpZ3Mubm9BcnJvdyBcbiAgICAgICAgdGhpcy5fY2FjaGVBbmdsZSA9IFtdO1xuICAgICAgICB0aGlzLl9jYWNoZVBvaW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9jYWNoZUJvdW5kaW5nYm94ID0ge1xuICAgICAgICAgICAgZnJvbTogW10sXG4gICAgICAgICAgICB0bzogW11cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBfY2FsY3VsYXRlQW5jaG9yUG9pbnRzKCkge1xuICAgICAgICBjb25zdCBkbXNmcm9tID0gdGhpcy5mcm9tLmdldEludGVyc2VjdGlvbnNJbkZvdXJEaW1lbnNpb24oKTtcbiAgICAgICAgY29uc3QgZG1zdG8gPSB0aGlzLnRvLmdldEludGVyc2VjdGlvbnNJbkZvdXJEaW1lbnNpb24oKTtcbiAgICAgICAgY29uc3QgX2NhY2hlQW5nbGUgPSB0aGlzLl9jYWNoZUFuZ2xlO1xuICAgICAgICBpZih0aGlzLmlzU2VsZil7XG4gICAgICAgICAgICBwb2x5bGluZVBvaW50cyhcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZVBvaW50cyxcbiAgICAgICAgICAgICAgICBkbXNmcm9tW3RoaXMuZnJvbURpcl0sXG4gICAgICAgICAgICAgICAgZG1zdG9bRElSRUNUSU9OLlNFTEZdLFxuICAgICAgICAgICAgICAgIHRoaXMuZnJvbURpcixcbiAgICAgICAgICAgICAgICB0aGlzLnRvRGlyLCBcbiAgICAgICAgICAgICAgICB0aGlzLm1pblNwYW5YLCBcbiAgICAgICAgICAgICAgICB0aGlzLm1pblNwYW5ZLFxuICAgICAgICAgICAgICAgIHRydWUpO1xuICAgICAgICAgICAgX2NhY2hlQW5nbGVbMF0gPSB0aGlzLmZyb21EaXI7XG4gICAgICAgICAgICBfY2FjaGVBbmdsZVsxXSA9IHRoaXMudG9EaXI7XG4gICAgICAgIH0gZWxzZSBpZih0aGlzLmZyb21EaXIgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnRvRGlyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBvbHlsaW5lUG9pbnRzKFxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlUG9pbnRzLFxuICAgICAgICAgICAgICAgIGRtc2Zyb21bdGhpcy5mcm9tRGlyXSxcbiAgICAgICAgICAgICAgICBkbXN0b1t0aGlzLnRvRGlyXSxcbiAgICAgICAgICAgICAgICB0aGlzLmZyb21EaXIsXG4gICAgICAgICAgICAgICAgdGhpcy50b0RpciwgdGhpcy5taW5TcGFuWCAsIHRoaXMubWluU3BhblkpO1xuICAgICAgICAgICAgX2NhY2hlQW5nbGVbMF0gPSB0aGlzLmZyb21EaXI7XG4gICAgICAgICAgICBfY2FjaGVBbmdsZVsxXSA9IHRoaXMudG9EaXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtZXRhID0gbWluSW50ZXJzZWN0aW9uQmV0d2Vlbk5vZGVzKGRtc2Zyb20sIGRtc3RvKTtcbiAgICAgICAgICAgIHBvbHlsaW5lUG9pbnRzKFxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlUG9pbnRzLFxuICAgICAgICAgICAgICAgIG1ldGEuZnJvbVAsXG4gICAgICAgICAgICAgICAgbWV0YS50b1AsXG4gICAgICAgICAgICAgICAgbWV0YS5mcm9tRGlyLFxuICAgICAgICAgICAgICAgIG1ldGEudG9EaXIsXG4gICAgICAgICAgICAgICAgdGhpcy5taW5TcGFuWCAsIHRoaXMubWluU3BhblkpO1xuICAgICAgICAgICAgX2NhY2hlQW5nbGVbMF0gPSBtZXRhLmZyb21EaXI7XG4gICAgICAgICAgICBfY2FjaGVBbmdsZVsxXSA9IG1ldGEudG9EaXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaXNJblZpZXdCb3goYnIpIHtcbiAgICAgICAgaWYodGhpcy5fc3RhdGljKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVBbmNob3JQb2ludHMoKTsgICAgIFxuICAgICAgICByZXR1cm4gaXNQb2x5TGluZUludGVyc2VjdGlvblJlY3RhbmdlKHRoaXMuX2NhY2hlUG9pbnRzLCBicik7XG4gICAgfVxuXG4gICAgcmVuZGVyKGN0eCkge1xuICAgICAgICAvLyB0aGlzLl9jYWxjdWxhdGVBbmNob3JQb2ludHMoKTtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gdGhpcy5yYWRpdXM7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX2NhY2hlUG9pbnRzO1xuICAgICAgICBjb25zdCBwID0gcG9pbnRzWzBdO1xuICAgICAgICBjb25zdCBwRW5kID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgYW5nbGVFbmQgPSAoKHRoaXMuX2NhY2hlQW5nbGVbMV0gKyAyKSAlIDQpICogOTAgKiBQSUlOUkFUSU87XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgaWYodGhpcy5kb3VibGVMaW5rKSB7XG4gICAgICAgICAgICBjb25zdCBiZWdpbkFuZ2xlID0gKCh0aGlzLl9jYWNoZUFuZ2xlWzBdICsgMikgJSA0KSAqIDkwICogUElJTlJBVElPO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShwWzBdLCBwWzFdKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoYmVnaW5BbmdsZSk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKDUsIDApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbygwLCAtNCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKDAsIDQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyg1LCAwKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICBjdHgucm90YXRlKC1iZWdpbkFuZ2xlKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLXBbMF0sIC1wWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8ocFswXSwgcFsxXSk7XG4gICAgICAgIHBvaW50cy5zbGljZSgxLCBwb2ludHMubGVuZ3RoIC0gMSkuZm9yRWFjaCgocCwgaWR4KSA9PiB7XG4gICAgICAgICAgICBpZih0aGlzLnJhZGl1cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBMYXN0ID0gcG9pbnRzW2lkeF07XG4gICAgICAgICAgICAgICAgY29uc3QgcE5leHQgPSBwb2ludHNbaWR4KzJdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcDEsIHAyIH0gPSBtYWtlUmFkaXVzRnJvbVZlY3RvcihwTGFzdCwgcCwgcE5leHQsIHJhZGl1cyk7XG4gICAgICAgICAgICAgICAgaWYocDEgJiYgcDIpe1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHAxWzBdLCBwMVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHBbMF0sIHBbMV0sIHAyWzBdLCBwMlsxXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwWzBdLCBwWzFdKTtcbiAgICAgICAgICAgICAgICB9ICBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwWzBdLCBwWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5saW5lVG8ocEVuZFswXSwgcEVuZFsxXSk7XG5cbiAgICAgICAgaWYodGhpcy5saW5lRGFzaCkge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaCh0aGlzLmxpbmVEYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGlmKHRoaXMubGluZURhc2gpIHtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZighdGhpcy5ub0Fycm93KSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHBFbmRbMF0sIHBFbmRbMV0pO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShhbmdsZUVuZCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKDAsIDApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbygtNSwgLTQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbygtNSwgNCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKDAsIDApO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoLWFuZ2xlRW5kKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLXBFbmRbMF0sIC1wRW5kWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5mb250ID0gYCR7dGhpcy5mb250U2l6ZX0gJHt0aGlzLmZvbnRGYW1pbHl9YDtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5mcm9tRGlyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBESVJFQ1RJT04uQk9UVE9NOlxuICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGhpcy5jb250ZW50LCBwWzBdICsgMiwgcFsxXSArIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBESVJFQ1RJT04uUklHSFQ6XG4gICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLmNvbnRlbnQsIHBbMF0gKyAxMCwgcFsxXSAtIDIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgaXNIaXQocG9pbnQpIHtcbiAgICAgICAgaWYodGhpcy5fc3RhdGljKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIXRoaXMuX2NhY2hlUG9pbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9pbnRzID0gdGhpcy5fY2FjaGVQb2ludHM7XG4gICAgICAgIGxldCBsYXN0UCA9IHBvaW50c1swXTtcbiAgICAgICAgY29uc3QgcmVtYWluUG9pbnRzID0gcG9pbnRzLnNsaWNlKDEpXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQID0gcmVtYWluUG9pbnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZihjdXJyZW50UCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBkaXN0VG9TZWdtZW50U3F1YXJlZChwb2ludCwgbGFzdFAsIGN1cnJlbnRQKTtcbiAgICAgICAgICAgICAgICBpZihkaXN0IDwgdGhpcy5hcHByb3hpbWF0ZSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RQID0gY3VycmVudFA7XG4gICAgICAgIH0gd2hpbGUobGFzdFApXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY2xvbmVTdGF0aWMoKSB7XG4gICAgICAgIGNvbnN0IHQgPSBuZXcgUG9seUxpbmsoe30pO1xuICAgICAgICBPYmplY3QuYXNzaWduKHQsIHtcbiAgICAgICAgICAgIHJhZGl1czogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICBfY2FjaGVQb2ludHM6IHRoaXMuX2NhY2hlUG9pbnRzLFxuICAgICAgICAgICAgX2NhY2hlQW5nbGU6IHRoaXMuX2NhY2hlQW5nbGUsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgZG91YmxlTGluazogdGhpcy5kb3VibGVMaW5rLFxuICAgICAgICAgICAgcmFkaXVzOiB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAgIGxpbmVEYXNoOiB0aGlzLmxpbmVEYXNoLFxuICAgICAgICAgICAgbm9BcnJvdzogdGhpcy5ub0Fycm93LFxuICAgICAgICAgICAgY29udGVudDogdGhpcy5jb250ZW50LFxuICAgICAgICAgICAgZm9udFNpemU6IHRoaXMuZm9udFNpemUsXG4gICAgICAgICAgICBmb250RmFtaWx5OiB0aGlzLmZvbnRGYW1pbHksXG4gICAgICAgICAgICBmcm9tRGlyOiB0aGlzLmZyb21EaXIsXG4gICAgICAgICAgICBfc3RhdGljOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQb2x5TGluazsiLCJpbXBvcnQgQmFzZUxpbmsgZnJvbSAnLi9iYXNlLWxpbmsnO1xuaW1wb3J0IHsgYmV6aWVyUG9pbnRzLCBkaXN0VG9CZXppZXJTZWdtZW50U3F1YXJlZCwgZ2V0QmV6aWVyQW5nbGUsIG1pbkludGVyc2VjdGlvbkJldHdlZW5Ob2RlcyB9IGZyb20gJy4uL3V0aWxzL2Z1bmN0aW9ucyc7XG5pbXBvcnQgeyBBUFBST1hJTUFURSwgRElSRUNUSU9OIH0gZnJvbSAnLi4vdXRpbHMvY29uc3RhbmNlJztcbmltcG9ydCB7IGRpc3QyLCBiZXppZXJQb2ludCB9IGZyb20gJy4uL3V0aWxzL2Z1bmN0aW9ucyc7XG5jb25zdCBQSUlOUkFUSU8gPSBNYXRoLlBJIC8gMTgwXG4vKipcbiAqIEB0eXBlZGVmIHtCYXNlTGlua35Db25maWdzfSBCZXppZXJMaW5rfkNvbmZpZ3NcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBhcHByb3hpbWF0ZSAgIC0g54K55Ye75ZON5bqU6IyD5Zu0XG4gKiBAcHJvcGVydHkge051bWJlcn0gbWluU3BhblggICAgICAtIOi1t+eCuee7iOeCueWcqCB4IOaWueWQkeacgOWwj+eahOi3qOW6plxuICogQHByb3BlcnR5IHtOdW1iZXJ9IG1pblNwYW5ZICAgICAgLSDotbfngrnnu4jngrnlnKggeSDmlrnlkJHmnIDlsI/nmoTot6jluqZcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyW119IGxpbmVEYXNoICAgIC0g6Jma57q/5pWw57uEXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRvdWJsZUxpbmsgICAtIOWPjOWQkeeureWktFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGZvbnRGYW1pbHkgICAgLSDov57nur/kuIrnmoTmloflrZflrZfkvZNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBmb250U2l6ZSAgICAgIC0g6L+e57q/5LiK55qE5paH5a2X5aSn5bCPXG4gKiBAcHJvcGVydHkge1N0cmluZ30gY29udGVudCAgICAgICAtIOi/nue6v+S4iueahOaWh+Wtl1xuICogQHByb3BlcnR5IHtCb29sZWFufSBpc1NlbGYgICAgICAgIC0g5piv5ZCm5Li66Ieq6L+e5o6lXG4gKi9cbi8qKlxuICog6LSd5aGe5bCU5puy57q/XG4gKiBAY29uc3RydWN0b3IgQmV6aWVyTGlua1xuICogQGV4dGVuZHMgQmFzZUxpbmtcbiAqIEBwYXJhbSB7QmV6aWVyTGlua35Db25maWdzfSBjb25maWdzIC0g6YWN572uXG4gKi9cbmNsYXNzIEJlemllckxpbmsgZXh0ZW5kcyBCYXNlTGluayB7XG4gICAgIC8qKlxuICAgICAqIOWIm+W7uui0neWhnuWwlOabsue6vy5cbiAgICAgKiBAcGFyYW0ge0Jlemllckxpbmt+Q29uZmlnc30gY29uZmlncyAtIOmFjee9rlxuICAgICAqKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3MpO1xuICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAgIC0g54K55Ye75ZON5bqU6IyD5Zu0ICovXG4gICAgICAgIHRoaXMuYXBwcm94aW1hdGUgICA9IGNvbmZpZ3MuYXBwcm94aW1hdGUgfHwgQVBQUk9YSU1BVEU7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgICAgLSDotbfngrnnu4jngrnlnKggeCDmlrnlkJHmnIDlsI/nmoTot6jluqYgKi9cbiAgICAgICAgdGhpcy5taW5TcGFuWCAgICAgID0gY29uZmlncy5taW5TcGFuWCB8fCAwO1xuICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAgIC0g6LW354K557uI54K55ZyoIHkg5pa55ZCR5pyA5bCP55qE6Leo5bqmICovXG4gICAgICAgIHRoaXMubWluU3BhblkgICAgICA9IGNvbmZpZ3MubWluU3BhblkgfHwgMDtcbiAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcltdfSAgICAgIC0g6Jma57q/5pWw57uEICovXG4gICAgICAgIHRoaXMubGluZURhc2ggICAgICA9IGNvbmZpZ3MubGluZURhc2g7XG4gICAgICAgIHRoaXMubGluZVdpZHRoICAgICA9IGNvbmZpZ3MubGluZVdpZHRoIHx8IDE7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtCb29sZWFufSAgICAgIC0g5Y+M5ZCR566t5aS0ICovXG4gICAgICAgIHRoaXMuZG91YmxlTGluayAgICA9IGNvbmZpZ3MuZG91YmxlTGluaztcbiAgICAgICAgLyoqIEBtZW1iZXIge1N0cmluZ30gICAgICAtIOi/nue6v+S4iueahOaWh+Wtl+Wtl+S9kyAqL1xuICAgICAgICB0aGlzLmZvbnRGYW1pbHkgICAgPSBjb25maWdzLmZvbnRGYW1pbHkgPSAnLWFwcGxlLXN5c3RlbSxCbGlua01hY1N5c3RlbUZvbnQsU2Vnb2UgVUksUm9ib3RvLEhlbHZldGljYSBOZXVlLEhlbHZldGljYSxUYWhvbWEsQXJpYWwsTm90byBTYW5zLFBpbmdGYW5nIFNDLE1pY3Jvc29mdCBZYUhlaSxIaXJhZ2lubyBTYW5zIEdCLHNhbnMtc2VyaWYsQXBwbGUgQ29sb3IgRW1vamksU2Vnb2UgVUkgRW1vamksU2Vnb2UgVUkgU3ltYm9sLE5vdG8gQ29sb3IgRW1vamknXG4gICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgICAgLSDov57nur/kuIrnmoTmloflrZflpKflsI8gKi9cbiAgICAgICAgdGhpcy5mb250U2l6ZSAgICAgID0gY29uZmlncy5mb250U2l6ZSB8fCAnMTJweCc7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtTdHJpbmd9ICAgICAgLSDov57nur/kuIrnmoTmloflrZcgKi9cbiAgICAgICAgdGhpcy5jb250ZW50ICAgICAgID0gY29uZmlncy5jb250ZW50IHx8ICcnO1xuICAgICAgICAvKiogQG1lbWJlciB7Qm9vbGVhbn0gICAgICAtIOaYr+WQpuS4uuiHqui/nuaOpSAqL1xuICAgICAgICB0aGlzLmlzU2VsZiAgICAgICAgPSAhIWNvbmZpZ3MuaXNTZWxmXG4gICAgfVxuICAgIFxuICAgIC8vIGdldENvbG9yKCkge1xuICAgIC8vICAgICBpZih0aGlzLl9pc1RhcmdldGluZykge1xuICAgIC8vICAgICAgICAgcmV0dXJuIHRoaXMuaG92ZXJTdHlsZTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICByZXR1cm4gdGhpcy5kZWZhdWx0U3R5bGU7XG4gICAgLy8gfVxuICAgIFxuICAgIC8vIF9jYWxjdWxhdGVBbmNob3JQb2ludHMoKSB7XG4gICAgLy8gICAgIGxldCBzdGFydDtcbiAgICAvLyAgICAgbGV0IGVuZDtcbiAgICAvLyAgICAgaWYodGhpcy5mcm9tRGlyICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyAgICAgICAgIHN0YXJ0ID0ge1xuICAgIC8vICAgICAgICAgICAgIGRpcjogdGhpcy5mcm9tRGlyLFxuICAgIC8vICAgICAgICAgICAgIHA6IHRoaXMuZnJvbS5nZXRJbnRlcnNlY3Rpb25zSW5Gb3VyRGltZW5zaW9uKClbdGhpcy5mcm9tRGlyXSxcbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgfSBlbHNlIHtcbiAgICAvLyAgICAgICAgIHN0YXJ0ID0gdGhpcy5mcm9tLmNhbGN1bGF0ZUludGVyc2VjdGlvbkluRm91ckRpbWVuc2lvbih0aGlzLnRvLmdldENlbnRlcigpLCAnZnJvbScpO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIGlmKHRoaXMudG9EaXIgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vICAgICAgICAgZW5kID0ge1xuICAgIC8vICAgICAgICAgICAgIGRpcjogdGhpcy50b0RpcixcbiAgICAvLyAgICAgICAgICAgICBwOiB0aGlzLnRvLmdldEludGVyc2VjdGlvbnNJbkZvdXJEaW1lbnNpb24oKVt0aGlzLnRvRGlyXSxcbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgfSBlbHNlIHtcbiAgICAvLyAgICAgICAgIGVuZCA9IHRoaXMudG8uY2FsY3VsYXRlSW50ZXJzZWN0aW9uSW5Gb3VyRGltZW5zaW9uKHRoaXMuZnJvbS5nZXRDZW50ZXIoKSwgJ3RvJyk7XG4gICAgLy8gICAgIH1cbiAgICAgICAgXG4gICAgICAgIFxuICAgIC8vICAgICAvLyBjb25zdCBzdGFydCA9IHRoaXMuZnJvbS5jYWxjdWxhdGVJbnRlcnNlY3Rpb25JbkZvdXJEaW1lbnNpb24odGhpcy50by5nZXRDZW50ZXIoKSwgJ2Zyb20nKTtcbiAgICAvLyAgICAgLy8gY29uc3QgZW5kID0gdGhpcy50by5jYWxjdWxhdGVJbnRlcnNlY3Rpb25JbkZvdXJEaW1lbnNpb24odGhpcy5mcm9tLmdldENlbnRlcigpLCAndG8nKTtcbiAgICAvLyAgICAgY29uc3QgcDEgPSBzdGFydC5wO1xuICAgIC8vICAgICBjb25zdCBwMiA9IGVuZC5wO1xuICAgIC8vICAgICBjb25zdCBwb2ludHMgPSBiZXppZXJQb2ludHMocDEsIHAyLCBzdGFydC5kaXIsIGVuZC5kaXIsIHRoaXMuYW50aWNsb2NrKTtcblxuICAgIC8vICAgICB0aGlzLl9jYWNoZVBvaW50cyA9IFsuLi5wMSwgLi4ucG9pbnRzXVxuICAgIC8vIH1cblxuICAgIF9jYWxjdWxhdGVBbmNob3JQb2ludHMoKSB7XG4gICAgICAgIGNvbnN0IGRtc2Zyb20gPSB0aGlzLmZyb20uZ2V0SW50ZXJzZWN0aW9uc0luRm91ckRpbWVuc2lvbigpO1xuICAgICAgICBjb25zdCBkbXN0byA9IHRoaXMudG8uZ2V0SW50ZXJzZWN0aW9uc0luRm91ckRpbWVuc2lvbigpO1xuICAgICAgICBpZih0aGlzLmlzU2VsZikge1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gYmV6aWVyUG9pbnRzKFxuICAgICAgICAgICAgICAgIGRtc2Zyb21bdGhpcy5mcm9tRGlyXSxcbiAgICAgICAgICAgICAgICBkbXN0b1tESVJFQ1RJT04uU0VMRl0sXG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tRGlyLFxuICAgICAgICAgICAgICAgIERJUkVDVElPTi5CT1RUT00sIFxuICAgICAgICAgICAgICAgIHRoaXMubWluU3BhblgsIFxuICAgICAgICAgICAgICAgIHRoaXMubWluU3BhblkpO1xuXG4gICAgICAgICAgICB0aGlzLl9jYWNoZVBvaW50cyA9IFsuLi5kbXNmcm9tW3RoaXMuZnJvbURpcl0sIC4uLnBvaW50c10gXG4gICAgICAgICAgICB0aGlzLl9jYWNoZUFuZ2xlID0gW3RoaXMuZnJvbURpciwgRElSRUNUSU9OLkJPVFRPTV1cbiAgICAgICAgfSBlbHNlIGlmKHRoaXMuZnJvbURpciAhPT0gdW5kZWZpbmVkICYmIHRoaXMudG9EaXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gYmV6aWVyUG9pbnRzKFxuICAgICAgICAgICAgICAgIGRtc2Zyb21bdGhpcy5mcm9tRGlyXSxcbiAgICAgICAgICAgICAgICBkbXN0b1t0aGlzLnRvRGlyXSxcbiAgICAgICAgICAgICAgICB0aGlzLmZyb21EaXIsXG4gICAgICAgICAgICAgICAgdGhpcy50b0RpciwgdGhpcy5taW5TcGFuWCAsIHRoaXMubWluU3BhblkpO1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVQb2ludHMgPSBbLi4uZG1zZnJvbVt0aGlzLmZyb21EaXJdLCAuLi5wb2ludHNdIFxuICAgICAgICAgICAgdGhpcy5fY2FjaGVBbmdsZSA9IFt0aGlzLmZyb21EaXIsIHRoaXMudG9EaXJdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtZXRhID0gbWluSW50ZXJzZWN0aW9uQmV0d2Vlbk5vZGVzKGRtc2Zyb20sIGRtc3RvKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IGJlemllclBvaW50cyhcbiAgICAgICAgICAgICAgICBtZXRhLmZyb21QLFxuICAgICAgICAgICAgICAgIG1ldGEudG9QLFxuICAgICAgICAgICAgICAgIG1ldGEuZnJvbURpcixcbiAgICAgICAgICAgICAgICBtZXRhLnRvRGlyKTtcblxuICAgICAgICAgICAgdGhpcy5fY2FjaGVQb2ludHMgPSBbLi4ubWV0YS5mcm9tUCwgLi4ucG9pbnRzXTtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlQW5nbGUgPSBbbWV0YS5mcm9tRGlyLCBtZXRhLnRvRGlyXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcihjdHgpIHtcbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlQW5jaG9yUG9pbnRzKCk7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX2NhY2hlUG9pbnRzO1xuICAgICAgICBjb25zdCBhbmdsZSA9IGdldEJlemllckFuZ2xlLmFwcGx5KG51bGwsIFsxLCAuLi5wb2ludHNdKVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmxpbmVXaWR0aDtcbiAgICAgICAgaWYodGhpcy5kb3VibGVMaW5rKSB7XG4gICAgICAgICAgICBjb25zdCBiZWdpbkFuZ2xlID0gKCh0aGlzLl9jYWNoZUFuZ2xlWzBdICsgMikgJSA0KSAqIDkwICogUElJTlJBVElPO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgICAgICAgICBjdHgucm90YXRlKGJlZ2luQW5nbGUpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyg1LCAwKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oMCwgLTQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbygwLCA0KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oNSwgMCk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZSgtYmVnaW5BbmdsZSk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1wb2ludHNbMF0sIC1wb2ludHNbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF0sIHBvaW50c1sxXSlcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8oLi4ucG9pbnRzLnNsaWNlKDIpKTtcbiAgICAgICAgaWYodGhpcy5saW5lRGFzaCkge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaCh0aGlzLmxpbmVEYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGlmKHRoaXMubGluZURhc2gpIHtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHBvaW50c1s2XSwgcG9pbnRzWzddKTtcbiAgICAgICAgY3R4LnJvdGF0ZShhbmdsZSk7XG4gICAgICAgIGN0eC5tb3ZlVG8oNSwgMCk7XG4gICAgICAgIGN0eC5saW5lVG8oMCwgLTQpO1xuICAgICAgICBjdHgubGluZVRvKDAsIDQpO1xuICAgICAgICBjdHgubGluZVRvKDUsIDApO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHgucm90YXRlKC1hbmdsZSk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoLXBvaW50c1s2XSwgLXBvaW50c1s3XSk7XG4gICAgICAgIGlmKHRoaXMuY29udGVudCkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY29uc3QgaGFzRmxpcCA9IHBvaW50c1swXSA+IHBvaW50c1s2XTtcbiAgICAgICAgICAgIGxldCBbeCwgeSwgYW5nbGVdID0gYmV6aWVyUG9pbnQoMC41LCBwb2ludHMpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoYW5nbGUpO1xuICAgICAgICAgICAgaWYoaGFzRmxpcCl7XG4gICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShNYXRoLlBJKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5mb250ID0gYCR7dGhpcy5mb250U2l6ZX0gJHt0aGlzLmZvbnRGYW1pbHl9YDtcbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLmNvbnRlbnQsIDAsIC0ocGFyc2VJbnQodGhpcy5mb250U2l6ZSkgfHwgMTIpLzQpO1xuICAgICAgICAgICAgaWYoaGFzRmxpcCl7XG4gICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShNYXRoLlBJKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5yb3RhdGUoLWFuZ2xlKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLXgsIC15KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzSGl0KHBvaW50KSB7XG4gICAgICAgIGlmKCF0aGlzLl9jYWNoZVBvaW50cykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9jYWNoZVBvaW50cztcbiAgICAgICAgY29uc3QgZGlzdCA9IGRpc3RUb0JlemllclNlZ21lbnRTcXVhcmVkKHBvaW50LCBwb2ludHMpXG4gICAgICAgIHJldHVybiBkaXN0IDwgdGhpcy5hcHByb3hpbWF0ZTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJlemllckxpbms7IiwiLyoqXG4gKiDnur/mgKfluIPlsYDphY3nva5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IExpbmVhckxheW91dH5Db25maWdzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGlyZWN0aW9uICAgICAtIOaOkuWIl+aWueWQkSDpu5jorqQgdmVydGljYWxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBnYXAgICAgICAgICAgIC0g6L656LedLCDpu5jorqTmmK8gNVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGFsaWdubWVudCAgICAgLSDlnoLnm7TmjpLliJfmlrnlkJHlr7npvZDmlrnlvI8g6buY6K6kIGNlbnRlclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGp1c3RpZnkgICAgICAgLSDmjpLliJfmlrnlkJHlr7npvZDmlrnlvI8g6buY6K6kIGNlbnRlclxuICovXG4vKipcbiAgICDnur/mgKfluIPlsYBcblxuICAgIOaOkuWIl+aWueWQkVxuICAgIGRpcmVjdGlvbjpcbiAgICAgICAgKyB2ZXJ0aWNhbCDku47kuIroh7PkuIvmjpLluINcbiAgICAgICAgKyBob3Jpem9udGFsIOS7juW3puiHs+WPs+aOkuW4g1xuICAgIFxuICAgIOS4jemHjeWPoO+8jOS4ree6v+Wvuem9kFxuICAgIOWPqumSiOWvueW9k+WJjeeahCBncm91cFxuXG4gICAg5a+56b2Q5pa55byPXG4gICAgYWxpZ25tZW50OiBcbiAgICAgICAgKyBzdGFydCDkuLvovbTlt6bkvqflr7npvZBcbiAgICAgICAgKyBjZW50ZXIg5Li76L205a+56b2QXG4gICAgICAgICsgZW5kICAg5Li76L205Y+z5L6n5a+56b2QXG4gICAganVzdGlmeTogXG4gICAgICAgICsgc3RhcnQg5byA5aeL5pe25a+56b2QXG4gICAgICAgICsgY2VudGVyIOWxheS4reWvuem9kFxuICAgICAgICArIGVuZCAgIOacq+WwvuWvuem9kFxuICAgICAgICArIHNwYWNlLWJldHdlZW4g5bmz5Z2H5YiG6YWN56m66Ze05a+56b2QXG5cbiAqIEBjb25zdHJ1Y3RvciBMaW5lYXJMYXlvdXRcbiAqIEBpbXBsZW1lbnRzIHtMYXlvdXR9XG4gKiBAcGFyYW0ge0xpbmVhckxheW91dH5Db25maWdzfSBjb25maWdzIC0g6YWN572uXG4gKi9cblxuY2xhc3MgTGluZWFyTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzID0ge30pIHtcbiAgICAgICAgLyoqIEBtZW1iZXIge3N0cmluZ30gIC0g5o6S5YiX5pa55ZCRIOm7mOiupCB2ZXJ0aWNhbCAqL1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9ICAgICBjb25maWdzLmRpcmVjdGlvbiB8fCAndmVydGljYWwnO1xuICAgICAgICAvKiogQG1lbWJlciB7bnVtYmVyfSAgLSDovrnot50sIOm7mOiupOaYryA1ICovXG4gICAgICAgIHRoaXMuZ2FwID0gICAgICAgICAgIGNvbmZpZ3MuZ2FwID8/IDU7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtzdHJpbmd9ICAtIOWeguebtOaOkuWIl+aWueWQkeWvuem9kOaWueW8jyDpu5jorqQgY2VudGVyICovXG4gICAgICAgIHRoaXMuYWxpZ25tZW50ID0gICAgIGNvbmZpZ3MuYWxpZ25tZW50IHx8ICdjZW50ZXInO1xuICAgICAgICAvKiogQG1lbWJlciB7c3RyaW5nfSAgLSDmjpLliJfmlrnlkJHlr7npvZDmlrnlvI8g6buY6K6kIGNlbnRlciAqL1xuICAgICAgICB0aGlzLmp1c3RpZnkgPSAgICAgICBjb25maWdzLmp1c3RpZnkgfHwgJ2NlbnRlcic7XG4gICAgICAgIC8vIHRoaXMud2lkdGhTZXRCeVBhcmVudCA9ICBjb25maWdzLndpZHRoID09PSAnMTAwJSdcbiAgICAgICAgdGhpcy5fcmF3Q29uZmlncyA9IGNvbmZpZ3M7XG4gICAgfVxuXG5cbiAgICByZWZsb3coZ3JvdXApIHtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBncm91cC5fc3RhY2suZmlsdGVyKGluc3RhbmNlID0+IGluc3RhbmNlLnZpc2libGUgJiYgIWluc3RhbmNlLmFic29sdXRlUG9zaXRpb24pO1xuICAgICAgICBjb25zdCBhYnNvbHV0ZVN0YWNrID0gZ3JvdXAuX3N0YWNrLmZpbHRlcihpbnN0YW5jZSA9PiBpbnN0YW5jZS52aXNpYmxlICYmIGluc3RhbmNlLmFic29sdXRlUG9zaXRpb24pXG4gICAgICAgIGNvbnN0IGdyb3VwV2lkdGggPSBncm91cC53aWR0aCAtIGdyb3VwLnBhZGRpbmcubGVmdCAtIGdyb3VwLnBhZGRpbmcucmlnaHQ7XG4gICAgICAgIGlmKHRoaXMuZGlyZWN0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICBsZXQgcmVkdWNlSGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIGxldCBsYXN0SW5zdGFuY2VIZWlnaHQgPSAwO1xuICAgICAgICAgICAgbGV0IG1heFdpZHRoID0gMDtcbiAgICAgICAgICAgIGxldCBhbGxIZWlnaHQgPSAwO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRBbGwgPSBzdGFjay5jb25jYXQoYWJzb2x1dGVTdGFjayk7XG4gICAgICAgICAgICBjaGlsZEFsbC5mb3JFYWNoKChpbnN0YW5jZSwgaWR4KSA9PiAge1xuICAgICAgICAgICAgICAgIGlmKGluc3RhbmNlLmRpc3BsYXkgPT09ICdibG9jaycpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uud2lkdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAvLyBpbnN0YW5jZS5kZWZpbmVkV2lkdGggPSBtYXhXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UucmVzZXRDaGlsZHJlblBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnJlZmxvdygpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5fZ2V0Qm91bmRpbmdHcm91cFJlY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc3RhY2suZm9yRWFjaCgoaW5zdGFuY2UsIGlkeCkgPT4gIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGluc3RhbmNlLmdldEJvdW5kaW5nRGltZW5zaW9uKCk7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coaGVpZ2h0LCBpbnN0YW5jZS50eXBlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBnYXAgPSAoaWR4ID4gMCA/IHRoaXMuZ2FwIDogMCk7XG4gICAgICAgICAgICAgICAgaWYoaW5zdGFuY2UuZGlzcGxheSAhPT0gJ291dHN0cmV0Y2gnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heFdpZHRoID0gTWF0aC5tYXgod2lkdGgsIG1heFdpZHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWxsSGVpZ2h0ICs9IChoZWlnaHQgKyBnYXApO1xuICAgICAgICAgICAgICAgIHJlZHVjZUhlaWdodCArPSAoaGVpZ2h0LzIgKyBnYXAgKyBsYXN0SW5zdGFuY2VIZWlnaHQpXG4gICAgICAgICAgICAgICAgbGFzdEluc3RhbmNlSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5hbmNob3IgPSBbMCwgcmVkdWNlSGVpZ2h0XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2hpbGRBbGwuZm9yRWFjaCgoaW5zdGFuY2UsIGlkeCkgPT4gIHtcbiAgICAgICAgICAgICAgICBpZihpbnN0YW5jZS5kaXNwbGF5ID09PSAnYmxvY2snKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluc3RhbmNlLmRlZmluZWRXaWR0aCA9IG1heFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5yZXNldENoaWxkcmVuUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uud2lkdGggPSBtYXhXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UucmVmbG93KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluc3RhbmNlLl9nZXRCb3VuZGluZ0dyb3VwUmVjdCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihpbnN0YW5jZS5kaXNwbGF5ID09PSAnb3V0c3RyZXRjaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdyA9IGdyb3VwLl9iZWxvbmdzLndpZHRoIC0gZ3JvdXAuX2JlbG9uZ3MucGFkZGluZy5sZWZ0IC0gZ3JvdXAuX2JlbG9uZ3MucGFkZGluZy5yaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UucmVzZXRDaGlsZHJlblBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLndpZHRoID0gTWF0aC5tYXgodywgbWF4V2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5yZWZsb3coKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1heChncm91cFdpZHRoLCBtYXhXaWR0aCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGFsbEhlaWdodCA9IGFsbEhlaWdodC8yO1xuICAgICAgICAgICAgaWYodGhpcy5hbGlnbm1lbnQgPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5mb3JFYWNoKChpbnN0YW5jZSwgaWR4KSA9PiAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHdpZHRoIH0gPSBpbnN0YW5jZS5nZXRCb3VuZGluZ0RpbWVuc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5hbmNob3JbMF0gPSAtKG1heFdpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuYW5jaG9yWzFdIC09IGFsbEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cobWF4V2lkdGgsIHdpZHRoLCBpbnN0YW5jZS5hbmNob3JbMF0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMuYWxpZ25tZW50ID09PSAnZW5kJykge1xuICAgICAgICAgICAgICAgIHN0YWNrLmZvckVhY2goKGluc3RhbmNlLCBpZHgpID0+ICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGggfSA9IGluc3RhbmNlLmdldEJvdW5kaW5nRGltZW5zaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmFuY2hvclswXSA9IChtYXhXaWR0aCAtIHdpZHRoKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmFuY2hvclsxXSAtPSBhbGxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMuYWxpZ25tZW50ID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgIHN0YWNrLmZvckVhY2goKGluc3RhbmNlLCBpZHgpID0+ICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGggfSA9IGluc3RhbmNlLmdldEJvdW5kaW5nRGltZW5zaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmFuY2hvclsxXSAtPSBhbGxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBcbiAgICAgICAgaWYodGhpcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgbGV0IHJlZHVjZVdpZHRoID0gMDtcbiAgICAgICAgICAgIGxldCBsYXN0SW5zdGFuY2VXaWR0aCA9IDA7XG4gICAgICAgICAgICBsZXQgbWF4SGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIGxldCBhbGxXaWR0aCA9IDA7XG4gICAgICAgICAgICBsZXQgYWxsUHVyZVdpZHRoID0gMDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3RhY2suZm9yRWFjaCgoaW5zdGFuY2UsIGlkeCkgPT4gIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGluc3RhbmNlLmdldEJvdW5kaW5nRGltZW5zaW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2FwID0gKGlkeCA+IDAgPyB0aGlzLmdhcCA6IDApO1xuICAgICAgICAgICAgICAgIG1heEhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgbWF4SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBhbGxXaWR0aCArPSAod2lkdGgrZ2FwKTtcbiAgICAgICAgICAgICAgICBhbGxQdXJlV2lkdGggKz0gd2lkdGg7XG4gICAgICAgICAgICAgICAgcmVkdWNlV2lkdGggKz0gKHdpZHRoLzIgKyBnYXAgKyBsYXN0SW5zdGFuY2VXaWR0aClcbiAgICAgICAgICAgICAgICBsYXN0SW5zdGFuY2VXaWR0aCA9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5hbmNob3IgPSBbcmVkdWNlV2lkdGgsIDBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmKHRoaXMuanVzdGlmeSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpdGhkcmF3ID0gZ3JvdXBXaWR0aC8yO1xuICAgICAgICAgICAgICAgIHN0YWNrLmZvckVhY2goKGluc3RhbmNlLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuYW5jaG9yWzBdIC09IHdpdGhkcmF3O1xuICAgICAgICAgICAgICAgIH0pOyAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLmp1c3RpZnkgPT09ICdlbmQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2l0aGRyYXcgPSBncm91cFdpZHRoLzIgLSBhbGxXaWR0aDtcbiAgICAgICAgICAgICAgICBzdGFjay5mb3JFYWNoKChpbnN0YW5jZSwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmFuY2hvclswXSArPSB3aXRoZHJhdztcbiAgICAgICAgICAgICAgICB9KTsgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5qdXN0aWZ5ID09PSAnY2VudGVyJykgeyBcbiAgICAgICAgICAgICAgICBjb25zdCB3aXRoZHJhdyA9IGFsbFdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICBzdGFjay5mb3JFYWNoKChpbnN0YW5jZSwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmFuY2hvclswXSAtPSB3aXRoZHJhdztcbiAgICAgICAgICAgICAgICB9KSAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMuanVzdGlmeSA9PT0gJ3NwYWNlLWJldHdlZW4nICYmIHN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IE1hdGgubWF4KGdyb3VwV2lkdGgsIGFsbFdpZHRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBnYXBBdmVyYWdlID0gKHdpZHRoIC0gYWxsV2lkdGgpIC8gKHN0YWNrLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpdGhkcmF3ID0gd2lkdGgvMjtcbiAgICAgICAgICAgICAgICBzdGFjay5mb3JFYWNoKChpbnN0YW5jZSwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmFuY2hvclswXSArPSAoKGdhcEF2ZXJhZ2UgKiBpZHgpIC0gd2l0aGRyYXcpO1xuICAgICAgICAgICAgICAgIH0pOyAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLmFsaWdubWVudCA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgICAgIHN0YWNrLmZvckVhY2goKGluc3RhbmNlLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBoZWlnaHQgfSA9IGluc3RhbmNlLmdldEJvdW5kaW5nRGltZW5zaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmFuY2hvclsxXSA9IC0obWF4SGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMuYWxpZ25tZW50ID09PSAnZW5kJykge1xuICAgICAgICAgICAgICAgIHN0YWNrLmZvckVhY2goKGluc3RhbmNlLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBoZWlnaHQgfSA9IGluc3RhbmNlLmdldEJvdW5kaW5nRGltZW5zaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmFuY2hvclsxXSA9IChtYXhIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoYWJzb2x1dGVTdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmKGdyb3VwLmRpc3BsYXkgPT09ICdibG9jaycpIHtcbiAgICAgICAgICAgICAgICBncm91cC5nZXRCb3VuZGluZ0RpbWVuc2lvbigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncm91cC5fZ2V0Qm91bmRpbmdHcm91cFJlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFdJRFRIID0gZ3JvdXAud2lkdGggLzI7XG4gICAgICAgICAgICBjb25zdCBIRUlHSFQgPSBncm91cC5oZWlnaHQgLzI7XG4gICAgICAgICAgICBjb25zdCBzaGlmdHkgPSAoZ3JvdXAucGFkZGluZy50b3AgLSBncm91cC5wYWRkaW5nLmJvdHRvbSkvMjtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0eCA9IChncm91cC5wYWRkaW5nLmxlZnQgLSBncm91cC5wYWRkaW5nLnJpZ2h0KS8yO1xuICAgICAgICAgICAgYWJzb2x1dGVTdGFjay5mb3JFYWNoKGluc3RhbmNlID0+IHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5hbmNob3IgPSB0aGlzLl9yZXNvbHZlQWJzb2x1dGVBbmNob3IoaW5zdGFuY2UuYWJzb2x1dGVQb3NpdGlvbiwgaW5zdGFuY2UsIFdJRFRILCBIRUlHSFQsIHNoaWZ0eCwgc2hpZnR5KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVzb2x2ZUFic29sdXRlQW5jaG9yKGNvbmZpZywgaW5zdGFuY2UsIHcsIGgsIHNoaWZ0eCwgc2hpZnR5KXtcbiAgICAgICAgY29uc3QgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIGNlbnRlclgsIGNlbnRlclkgfSA9IGNvbmZpZztcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBpbnN0YW5jZS5nZXRCb3VuZGluZ0RpbWVuc2lvbigpO1xuICAgICAgICBjb25zdCBodyA9IHdpZHRoIC8gMjtcbiAgICAgICAgY29uc3QgaGggPSBoZWlnaHQgLyAyO1xuICAgICAgICBsZXQgeSA9IDA7XG4gICAgICAgIGxldCB4ID0gMDtcbiAgICAgICAgaWYodHlwZW9mIHRvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHkgPSB0b3AgKyBoaCAtIGggLSBzaGlmdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodHlwZW9mIHJpZ2h0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgeCA9IHcgLSByaWdodCAtIGh3IC0gc2hpZnR4O1xuICAgICAgICB9XG4gICAgICAgIGlmKHR5cGVvZiBib3R0b20gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB5ID0gaCAtIGJvdHRvbSAtIGhoIC0gc2hpZnR5O1xuICAgICAgICB9XG4gICAgICAgIGlmKHR5cGVvZiBsZWZ0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgeCA9IGxlZnQgKyBodyAtIHcgLSBzaGlmdHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYodHlwZW9mIGNlbnRlclggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB4ID0gY2VudGVyWDtcbiAgICAgICAgfVxuICAgICAgICBpZih0eXBlb2YgY2VudGVyWSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHkgPSBjZW50ZXJZO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbeCwgeV1cbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lYXJMYXlvdXQodGhpcy5fcmF3Q29uZmlncyk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMaW5lYXJMYXlvdXQ7IiwiXG5leHBvcnQgY29uc3QgRURJVE9SX0VWRU5UUyA9IHtcbiAgICBJTlBVVDogJ2lucHV0JyxcbiAgICBDT05UUk9MX0NNRDogJ2NvbnRyb2wnXG59XG5cbmV4cG9ydCBjb25zdCBLRVlCT0FSRF9JTlBVVCA9IHtcbiAgICBJTlBVVDogJ2lucHV0JyxcbiAgICBDT01QT1NJVElPTl9TVEFSVDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxuICAgIENPTVBPU0lUSU9OX1VQREFURTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcbiAgICBDT01QT1NJVElPTl9FTkQ6ICdjb21wb3NpdGlvbmVuZCcsXG4gICAgRU5URVI6ICdlbnRlcicsXG4gICAgREVMRVRFOiAnZGVsZXRlJyxcbiAgICBCQUNLU1BBQ0U6ICdiYWNrc3BhY2UnLFxufVxuXG5leHBvcnQgY29uc3QgS0VZQk9BUkRfQ09NTUFORFMgPSB7XG4gICAgQVJST1dfTEVGVDogJ2Fycm93TGVmdCcsXG4gICAgQVJST1dfUklHSFQ6ICdhcnJvd1JpZ2h0JyxcbiAgICBBUlJPV19VUDogJ2Fycm93VXAnLFxuICAgIEFSUk9XX0RPV046ICdhcnJvd0Rvd24nLFxuICAgIFVORE86ICd1bmRvJyxcbiAgICBSRURPOiAncmVkbycsXG4gICAgU0hJRlRfRE9XTjogJ3NoaWZ0X2Rvd24nLFxuICAgIFNISUZUX1VQOiAnc2hpZnRfdXAnLFxuICAgIENUUkxBOiAnY3RybGEnLFxuICAgIENPUFk6ICdjb3B5JyxcbiAgICBDVVQ6ICdjdXQnLFxuICAgIFBBU1RFOiAncGFzdGUnLFxufVxuXG5leHBvcnQgY29uc3QgTU9VU0VfQ09NTUFORFMgPSB7XG4gICAgU1RBUlRfRURJVDogJ3N0YXJ0ZWRpdCcsXG4gICAgRURJVF9DTElDSzogJ2VkaXRjbGljaycsXG4gICAgU0hJRlRfT05fQ0xJQ0s6ICdzaGlmdG9uY2xpY2snLFxuICAgIERPVUJMRV9DTElDSzogJ2RvdWJsZWNsaWNrJ1xufVxuXG5cbmV4cG9ydCBjb25zdCBPUEVSUkFUSU9OID0ge1xuICAgIFBMQUlOSU5QVVQ6ICdwbGFpbmlucHV0JyxcbiAgICBTUEFDRUlOUFVUOiAnc3BhY2VpbnB1dCcsXG4gICAgUkVUVVJOSU5QVVQ6ICdyZXR1cm5pbnB1dCcsXG4gICAgQ0FSRVRNT1ZFTUVOVDogJ2NhcmV0bW92ZW1lbnQnLFxuICAgIERFTEVURV9JTl9MSU5FOiAnZGVsZXRlaW5saW5lJyxcbiAgICBERUxFVEVfSU5fRURJVEFSRUE6ICdkZWxldGVpbmVkaXRhcmVhJyxcbiAgICBFTlNVUkVfREVMRVRFOiAnZW5zdXJlZGVsZXRlJyxcbiAgICBTRUxFQ1RJT05fREVMRVRFOiAnc2VsZWN0aW9uZGVsZXRlJyxcbiAgICBTRUxFQ1RJT05fSU5QVVQ6ICdzZWxlY3Rpb25pbnB1dCcsXG4gICAgQ09NUE9TSVRFX0lOU0VSVDogJ2NvbXBvc2l0ZWluc2VydCdcbn1cbiIsImltcG9ydCB7IEtFWUJPQVJEX0NPTU1BTkRTLCBLRVlCT0FSRF9JTlBVVCwgRURJVE9SX0VWRU5UUyB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuY2xhc3MgU2hhZG93SW5wdXQgZXh0ZW5kcyBFdmVudFRhcmdldHtcbiAgICBfaW5wdXRFbGVtZW50ID0gbnVsbDtcblxuICAgIGNvbnN0cnVjdG9yKHdyYXBwZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5faW5wdXRFbGVtZW50ID0gY3JlYXRlSW5wdXRFbGVtZW50KHRoaXMuY29udHJvbENhbGxiYWNrLmJpbmQodGhpcykpO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZCh0aGlzLl9pbnB1dEVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9pbnB1dEVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG4gICAgY29udHJvbENhbGxiYWNrKGtpbmQsIGRhdGEpIHtcbiAgICAgICAgc3dpdGNoKGtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfSU5QVVQuSU5QVVQ6XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0lOUFVULkNPTVBPU0lUSU9OX1NUQVJUOlxuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9JTlBVVC5DT01QT1NJVElPTl9VUERBVEU6XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0lOUFVULkNPTVBPU0lUSU9OX0VORDpcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfSU5QVVQuRU5URVI6XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0lOUFVULkJBQ0tTUEFDRTpcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfSU5QVVQuREVMRVRFOlxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoRURJVE9SX0VWRU5UUy5JTlBVVCwge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9DT01NQU5EUy5BUlJPV19MRUZUOlxuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9DT01NQU5EUy5BUlJPV19SSUdIVDpcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfQ09NTUFORFMuQVJST1dfVVA6XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0NPTU1BTkRTLkFSUk9XX0RPV046XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0NPTU1BTkRTLkNUUkxBOlxuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9DT01NQU5EUy5TSElGVF9ET1dOOlxuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9DT01NQU5EUy5TSElGVF9VUDpcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfQ09NTUFORFMuVU5ETzpcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfQ09NTUFORFMuUkVETzpcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfQ09NTUFORFMuQ09QWTpcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfQ09NTUFORFMuQ1VUOlxuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9DT01NQU5EUy5QQVNURTpcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KEVESVRPUl9FVkVOVFMuQ09OVFJPTF9DTUQsIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIHRoaXMuX2lucHV0RWxlbWVudC5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7ICBcbiAgICB9XG5cbiAgICBzeW5jUG9zaXRpb24oeCwgeSkge1xuICAgICAgICB0aGlzLl9pbnB1dEVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke3h9cHgsICR7eX1weClgXG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYodGhpcy5yZW1vdmVMaXNlbnRlcikge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXNlbnRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lucHV0RWxlbWVudC5yZW1vdmUoKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNoYWRvd0lucHV0O1xuXG5mdW5jdGlvbiBjcmVhdGVJbnB1dEVsZW1lbnQoY29udHJvbENhbGxiYWNrKSB7XG4gICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnc3R5bGUnLGBcbiAgICAgICAgd2lkdGg6IDEwMHB4O1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgYm9yZGVyOm5vbmU7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgIHotaW5kZXg6IC0xO1xuICAgICAgICBjb250YWluOiBzdHJpY3Q7YCk7XG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIC0xKTtcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ3NwZWxsY2hlY2snLCBmYWxzZSk7XG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKCdhdXRvY29ycmVjdCcsICdvZmYnKTtcblxuICAgIGxldCBzdG9wSW5wdXQgPSBmYWxzZTtcbiAgICBsZXQgc3RhdHVzID0ge1xuICAgICAgICBjdHJsT246IGZhbHNlLFxuICAgICAgICBzaGlmdE9uOiBmYWxzZSxcbiAgICB9XG5cbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmVpbnB1dCcsIGUgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmKGUuZGF0YSkge1xuICAgICAgICAgICAgLy8gY29udGVudCArPSBlLmRhdGE7XG4gICAgICAgICAgICAvLyByZW5kZXJDb250ZW50KCk7XG4gICAgICAgICAgICBpZighc3RvcElucHV0KSB7XG4gICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKEtFWUJPQVJEX0lOUFVULklOUFVULCBlLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgZSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgY29uc3QgcGFzdGVDb250ZW50ID0gKGUuY2xpcGJvYXJkRGF0YSB8fCB3aW5kb3cuY2xpcGJvYXJkRGF0YSkuZ2V0RGF0YShcInRleHRcIik7XG4gICAgICAgIGNvbnRyb2xDYWxsYmFjayhLRVlCT0FSRF9DT01NQU5EUy5QQVNURSwgcGFzdGVDb250ZW50KTtcbiAgICB9KTtcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjb3B5JywgZSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgY29udHJvbENhbGxiYWNrKEtFWUJPQVJEX0NPTU1BTkRTLkNPUFksIGUpO1xuICAgIH0pO1xuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2N1dCcsIGUgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnRyb2xDYWxsYmFjayhLRVlCT0FSRF9DT01NQU5EUy5DVVQsIGUpO1xuICAgIH0pO1xuXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIChlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xDYWxsYmFjayhLRVlCT0FSRF9JTlBVVC5DT01QT1NJVElPTl9TVEFSVCk7XG4gICAgICAgIHN0b3BJbnB1dCA9IHRydWU7XG4gICAgfSk7XG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb251cGRhdGUnLCAoZSkgPT4ge1xuICAgICAgICBjb250cm9sQ2FsbGJhY2soS0VZQk9BUkRfSU5QVVQuQ09NUE9TSVRJT05fVVBEQVRFLCBlLmRhdGEpO1xuICAgIH0pO1xuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgKGUpID0+IHtcbiAgICAgICAgY29udHJvbENhbGxiYWNrKEtFWUJPQVJEX0lOUFVULkNPTVBPU0lUSU9OX0VORCwgZS5kYXRhKTtcbiAgICAgICAgaW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgc3RvcElucHV0ID0gZmFsc2VcbiAgICB9KTtcblxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmKHN0b3BJbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaChldmVudC5rZXkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJTaGlmdFwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjayhLRVlCT0FSRF9DT01NQU5EUy5TSElGVF9VUCk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnNoaWZ0T24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJNZXRhXCI6XG4gICAgICAgICAgICBjYXNlIFwiQ29udHJvbFwiOlxuICAgICAgICAgICAgICAgIHN0YXR1cy5jdHJsT24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgfSlcblxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYoc3RvcElucHV0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKGV2ZW50LmNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJFbnRlclwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjayhLRVlCT0FSRF9JTlBVVC5FTlRFUik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQmFja3NwYWNlXCI6XG4gICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKEtFWUJPQVJEX0lOUFVULkJBQ0tTUEFDRSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRGVsZXRlXCI6XG4gICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKEtFWUJPQVJEX0lOUFVULkRFTEVURSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6XG4gICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKEtFWUJPQVJEX0NPTU1BTkRTLkFSUk9XX0xFRlQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soS0VZQk9BUkRfQ09NTUFORFMuQVJST1dfUklHSFQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkFycm93RG93blwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjayhLRVlCT0FSRF9DT01NQU5EUy5BUlJPV19ET1dOKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBcnJvd1VwXCI6XG4gICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKEtFWUJPQVJEX0NPTU1BTkRTLkFSUk9XX1VQKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2goZXZlbnQua2V5KSB7XG4gICAgICAgICAgICBjYXNlIFwiU2hpZnRcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soS0VZQk9BUkRfQ09NTUFORFMuU0hJRlRfRE9XTik7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnNoaWZ0T24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIk1ldGFcIjpcbiAgICAgICAgICAgIGNhc2UgXCJDb250cm9sXCI6XG4gICAgICAgICAgICAgICAgc3RhdHVzLmN0cmxPbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICBpZihzdGF0dXMuY3RybE9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjayhLRVlCT0FSRF9DT01NQU5EUy5DVFJMQSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gY2FzZSAnYyc6XG4gICAgICAgICAgICAvLyAgICAgaWYoc3RhdHVzLmN0cmxPbikge1xuICAgICAgICAgICAgLy8gICAgICAgICBjb250cm9sQ2FsbGJhY2soS0VZQk9BUkRfQ09NTUFORFMuQ1RSTEMpO1xuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vICAgICBicmVhazsgXG4gICAgICAgICAgICAvLyBjYXNlICd2JzpcbiAgICAgICAgICAgIC8vICAgICBpZihzdGF0dXMuY3RybE9uKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgIGNvbnRyb2xDYWxsYmFjayhLRVlCT0FSRF9DT01NQU5EUy5DVFJMVik7XG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gICAgIGJyZWFrOyAgIFxuICAgICAgICAgICAgLy8gY2FzZSAneCc6XG4gICAgICAgICAgICAvLyAgICAgaWYoc3RhdHVzLmN0cmxPbikge1xuICAgICAgICAgICAgLy8gICAgICAgICBjb250cm9sQ2FsbGJhY2soS0VZQk9BUkRfQ09NTUFORFMuQ1RSTFgpO1xuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgICAgICAgIGlmKHN0YXR1cy5jdHJsT24pIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKEtFWUJPQVJEX0NPTU1BTkRTLlJFRE8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgICAgICAgIGlmKChzdGF0dXMuY3RybE9uICYmIHN0YXR1cy5zaGlmdE9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soS0VZQk9BUkRfQ09NTUFORFMuUkVETyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKHN0YXR1cy5jdHJsT24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKEtFWUJPQVJEX0NPTU1BTkRTLlVORE8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAgIFxuICAgIH0pXG4gICAgcmV0dXJuIGlucHV0O1xufSIsImNsYXNzIENhcmV0IHsgXG4gICAgX3JvdyA9IDA7XG4gICAgX2NvbHVtbiA9IFswLDBdO1xuXG4gICAgX3N0YXR1cyA9IHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgYW5pbWU6IG51bGwsXG4gICAgICAgIGxhc3RFbGFwc2VkOiAwLFxuICAgICAgICByZWZyZXNoRWxhcHNlZDogZmFsc2UsXG4gICAgfVxuXG4gICAgc2V0Um93KHJvdykge1xuICAgICAgICB0aGlzLl9yb3cgPSByb3c7XG4gICAgfVxuICAgIHNldENvbHVtbihjb2x1bW5vcmlkeCwgY29sdW1uKSB7XG4gICAgICAgIGlmKGNvbHVtbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jb2x1bW5bY29sdW1ub3JpZHhdID0gY29sdW1uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY29sdW1uID0gY29sdW1ub3JpZHg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRSb3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3c7XG4gICAgfVxuXG4gICAgZ2V0Q29sdW1uKGlkeCkge1xuICAgICAgICBpZihpZHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtbltpZHhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW47XG4gICAgfVxuXG4gICAgYW5pbWF0ZShqZmxvdykge1xuICAgICAgICB0aGlzLl9zdGF0dXMuYW5pbWUgPSBqZmxvdy5yZXF1ZXN0SkZsb3dBbmltZSgoZWxhcHNlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGFzdEVsYXBzZWQgPSB0aGlzLl9zdGF0dXMubGFzdEVsYXBzZWQ7XG4gICAgICAgICAgICBpZih0aGlzLl9zdGF0dXMucmVmcmVzaEVsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMubGFzdEVsYXBzZWQgPSBlbGFwc2VkO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5yZWZyZXNoRWxhcHNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZWxhcHNlZCAtIGxhc3RFbGFwc2VkID4gNTAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzLnNob3cgPSAhdGhpcy5fc3RhdHVzLnNob3c7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzLmxhc3RFbGFwc2VkID0gZWxhcHNlZDtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNhbmNlbEFuaW1hdGUoKSB7XG4gICAgICAgIHRoaXMuX3N0YXR1cy5hbmltZS5jYW5jZWwoKVxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3N0YXR1cywge1xuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIGFuaW1lOiBudWxsLFxuICAgICAgICAgICAgbGFzdEVsYXBzZWQ6IDAsXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgaXNTaG93KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdHVzLnNob3c7XG4gICAgfVxuXG4gICAgcmVmcmVzaCgpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9zdGF0dXMsIHtcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICByZWZyZXNoRWxhcHNlZDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdG9SYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLl9yb3csIC4uLnRoaXMuX2NvbHVtbl07XG4gICAgfVxuXG4gICAgZnJvbVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIHRoaXMuX3JvdyA9IHJhbmdlWzBdO1xuICAgICAgICB0aGlzLl9jb2x1bW4gPSByYW5nZS5zbGljZSgxKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhcmV0OyIsImltcG9ydCB7IHJlcXVlc3RDYWNoZUNhbnZhcyB9IGZyb20gJy4uLy4uL3V0aWxzL2NhbnZhcyc7XG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0QnlXaWR0aChcbiAgICBvZmZ4LCBcbiAgICB0ZXh0bWV0YSxcbiAgICBmb250U2l6ZSwgZm9udEZhbWlseSxcbiAgICBzcGFjZUhvbGRlclxuKSB7XG4gICAgY29uc3QgY29udGVudCA9IHRleHRtZXRhLmdldFJlbmRlclNvdXJjZShzcGFjZUhvbGRlcik7XG4gICAgY29uc3QgbWF4TCA9IGNvbnRlbnQubGVuZ3RoIC0gMTtcbiAgICBpZih0ZXh0bWV0YS53aWR0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgYWxsd2lkdGggPSB0ZXh0bWV0YS53aWR0aDtcbiAgICBsZXQgaWR4ID0gTWF0aC5mbG9vcihvZmZ4IC8gYWxsd2lkdGggKiBtYXhMKSA7XG4gICAgcmVxdWVzdENhY2hlQ2FudmFzKChjdHgpID0+IHtcbiAgICAgICAgY3R4LmZvbnQgPSBgJHtmb250U2l6ZX0gJHtmb250RmFtaWx5fWA7XG4gICAgICAgIGxldCBnMSwgZzI7XG4gICAgICAgIGxldCBsYXN0aWR4O1xuXG4gICAgICAgIGxldCBjID0gY29udGVudC5zdWJzdHJpbmcoMCwgaWR4KTtcbiAgICAgICAgbGV0IGMxID0gY29udGVudC5zdWJzdHJpbmcoaWR4LTEsIGlkeCk7XG4gICAgICAgIGxldCBjMiA9IGNvbnRlbnQuc3Vic3RyaW5nKGlkeCwgaWR4KzEpO1xuICAgICAgICBsZXQgdyA9IGN0eC5tZWFzdXJlVGV4dChjKS53aWR0aDtcbiAgICAgICAgbGV0IHcxID0gY3R4Lm1lYXN1cmVUZXh0KGMxKS53aWR0aDtcbiAgICAgICAgbGV0IHcyID0gY3R4Lm1lYXN1cmVUZXh0KGMyKS53aWR0aDtcbiAgICAgICAgZzEgPSB3IC0gdzEvMjtcbiAgICAgICAgZzIgPSB3ICsgdzIvMjtcbiAgICAgICAgXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmKGcxIDw9IG9mZnggJiYgZzIgPj0gb2ZmeCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSAgXG4gICAgICAgICAgICBpZihnMSA+IG9mZngpIHtcbiAgICAgICAgICAgICAgICAvLyDlt6bkvqflsJHkuoZcbiAgICAgICAgICAgICAgICBjb25zdCBzcGFudyA9IGcyIC0gb2ZmeDtcbiAgICAgICAgICAgICAgICBsYXN0aWR4ID0gaWR4O1xuICAgICAgICAgICAgICAgIGlmKHNwYW53IDwgMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkeCAtPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlkeCAtPSBNYXRoLmZsb29yKHNwYW53IC8gZzIgKiBsYXN0aWR4KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjID0gY29udGVudC5zdWJzdHJpbmcoaWR4LCBsYXN0aWR4KTtcbiAgICAgICAgICAgICAgICB3IC09IGN0eC5tZWFzdXJlVGV4dChjKS53aWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSBpZihnMiA8IG9mZngpIHtcbiAgICAgICAgICAgICAgICAvLyDlj7PkvqflsJHkuoZcbiAgICAgICAgICAgICAgICBjb25zdCBzcGFudyA9IG9mZnggLSBnMTtcbiAgICAgICAgICAgICAgICBsYXN0aWR4ID0gaWR4O1xuICAgICAgICAgICAgICAgIGlmKHNwYW53IDwgMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlkeCArPSBNYXRoLmZsb29yKHNwYW53IC8gKGFsbHdpZHRoIC0gZzEpICogKG1heEwgLSBsYXN0aWR4KSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYyA9IGNvbnRlbnQuc3Vic3RyaW5nKGxhc3RpZHgsIGlkeCk7XG4gICAgICAgICAgICAgICAgdyArPSBjdHgubWVhc3VyZVRleHQoYykud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGMxID0gY29udGVudC5zdWJzdHJpbmcoaWR4LTEsIGlkeCk7XG4gICAgICAgICAgICBjMiA9IGNvbnRlbnQuc3Vic3RyaW5nKGlkeCwgaWR4KzEpO1xuICAgICAgICAgICAgdzEgPSBjdHgubWVhc3VyZVRleHQoYzEpLndpZHRoO1xuICAgICAgICAgICAgdzIgPSBjdHgubWVhc3VyZVRleHQoYzIpLndpZHRoO1xuICAgICAgICAgICAgZzEgPSB3IC0gdzEvMjtcbiAgICAgICAgICAgIGcyID0gdyArIHcyLzI7XG4gICAgICAgIH0gd2hpbGUoaWR4ID49IDAgJiYgaWR4IDw9IG1heEwpXG4gICAgICAgIFxuICAgIH0pO1xuICAgIHJldHVybiBpZHg7XG59IiwiaW1wb3J0IHsgY2FsY3VsYXRlT2Zmc2V0QnlXaWR0aCB9IGZyb20gJy4uL3V0aWxzJ1xuZXhwb3J0IGNsYXNzIEFyZWEge1xuICAgIF9saW5lcyA9IFtdOyBcblxuICAgIGdldChpZHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVzW2lkeF07XG4gICAgfVxuXG4gICAgZ2V0TGluZUFib3ZlKG9mZnNldFkpIHtcbiAgICAgICAgbGV0IHJvdyA9IDA7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gdGhpcy5fbGluZXM7XG4gICAgICAgIHdoaWxlKHJvdyA8IGxpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYobGluZXNbcm93XS5yZWR1Y2VIZWlnaHQgPiBvZmZzZXRZKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3cgKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHJvdywgbGluZXMubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgdHJ1bmNhdGUoY29uZmlncykge1xuICAgICAgICBjb25zdCBsID0gTGluZS5jcmVhdGUoY29uZmlncyk7XG4gICAgICAgIHRoaXMuX2xpbmVzID0gW2xdO1xuICAgICAgICByZXR1cm4gbDtcbiAgICB9XG5cbiAgICBwdXNoKGxpbmUpIHtcbiAgICAgICAgdGhpcy5fbGluZXMucHVzaChsaW5lKTtcbiAgICB9XG5cbiAgICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2xpbmVzLmZvckVhY2goY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVzLmxlbmd0aDtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBMaW5lIHtcbiAgICB3aWR0aCA9IDA7XG4gICAgYW5jaG9yWSA9IDA7XG4gICAgaGVpZ2h0ID0gMDtcbiAgICByZWR1Y2VIZWlnaHQgPSAwO1xuICAgIF9lbGVtZW50cyA9IFtdXG5cbiAgICBzdGF0aWMgY3JlYXRlKGNvbmZpZ3MpIHtcbiAgICAgICAgY29uc3QgbCA9IG5ldyBMaW5lKGNvbmZpZ3MpO1xuICAgICAgICByZXR1cm4gbDtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzID0ge30pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjb25maWdzKTtcbiAgICB9XG5cbiAgICBfZWxlbWVudHMgPSBbXTtcblxuICAgIGdldChpZHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRzW2lkeF07XG4gICAgfVxuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBpbnNlcnQoaWR4LCBlbGVtKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzLnNwbGljZShpZHgsIDAsIGVsZW0pXG4gICAgfVxuICAgIHB1c2goZWxlbSkge1xuICAgICAgICB0aGlzLl9lbGVtZW50cy5wdXNoKGVsZW0pO1xuICAgIH1cbiAgICB0YWlsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudHNbdGhpcy5fZWxlbWVudHMubGVuZ3RoLTFdO1xuICAgIH1cbiAgICBjb3B5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudHMuc2xpY2UoKTtcbiAgICB9XG5cbiAgICBnZXRDb2x1bW5OZWFyZXN0KG9mZnNldFgsIGVsZW1lbnRTcGFjZSwgZm9udFNpemUsIGZvbnRGYW1pbHksIGVkaXRvcikge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuX2VsZW1lbnRzO1xuICAgICAgICBpZihvZmZzZXRYID49IHRoaXMud2lkdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBlbGVtZW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgY29uc3QgZWxlbSA9IGVsZW1lbnRzW2NdO1xuICAgICAgICAgICAgbGV0IHEgPSAwO1xuICAgICAgICAgICAgaWYoZWxlbS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICBxID0gZWxlbS5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIHJldHVybiBbYywgcV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBlbGVtX2lkeCA9IDA7XG4gICAgICAgICAgICBsZXQgbGFzdF9jID0gMDtcbiAgICAgICAgICAgIGxldCBfYyA9IDA7IFxuICAgICAgICAgICAgbGV0IGxhc3RlbCA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZShlbGVtX2lkeCA8IGVsZW1lbnRzLmxlbmd0aCAtMSkge1xuICAgICAgICAgICAgICAgIGxhc3RfYyA9IF9jO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gZWxlbWVudHNbZWxlbV9pZHhdO1xuICAgICAgICAgICAgICAgIGlmKGVsLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb3VibGVNYXJnaW4gPSAobGFzdGVsICYmIGxhc3RlbC50eXBlID09PSAndGV4dCcpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXJnaW4gPSBkb3VibGVNYXJnaW4gPyBlbGVtZW50U3BhY2UqMiA6IGVsZW1lbnRTcGFjZTtcbiAgICAgICAgICAgICAgICAgICAgX2MgKz0gKGVsLndpZHRoICsgbWFyZ2luKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfYyArPSBlbC53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoX2MgPiBvZmZzZXRYKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RlbCA9IGVsXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0ZWwgPSBlbFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGVsZW1faWR4Kys7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihfYyA8PSBvZmZzZXRYKSB7XG4gICAgICAgICAgICAgICAgbGFzdF9jID0gX2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ZXh0bWV0YSA9IGVsZW1lbnRzW2VsZW1faWR4XTtcbiAgICAgICAgICAgIGlmKHRleHRtZXRhLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnggPSBvZmZzZXRYIC0gbGFzdF9jO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IGNhbGN1bGF0ZU9mZnNldEJ5V2lkdGgob2ZmeCwgdGV4dG1ldGEsIGZvbnRTaXplLCBmb250RmFtaWx5LCBlZGl0b3Iuc3BhY2VIb2xkZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtlbGVtX2lkeCwgaWR4XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2ZmeCA9IG9mZnNldFggLSBsYXN0X2M7XG4gICAgICAgICAgICAgICAgaWYob2ZmeCA+IGxhc3RlbC53aWR0aC8yKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtlbGVtX2lkeCsxLCAwXVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbZWxlbV9pZHgsIDBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yRWFjaChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9lbGVtZW50cy5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBGbGF0dGVuVGV4dEVsZW1lbnRzIHtcbiAgICBzdGF0aWMgY3JlYXRlKGVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IF9lID0gbmV3IEZsYXR0ZW5UZXh0RWxlbWVudHMoKTtcbiAgICAgICAgX2UuZnJvbShlbGVtZW50cyk7XG4gICAgICAgIHJldHVybiBfZTtcbiAgICB9XG4gICAgX3RleHRFbGVtZW50cyA9IFtdO1xuICAgIF9yZWNvcmRzID0gW107XG4gICAgX2NhcmV0UmVjb3JkID0gbnVsbDtcblxuICAgIGluc2VydEJlZm9yZShhbmNob3IsIGVsZW0pIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5maW5kSW5kZXgoYW5jaG9yKTtcbiAgICAgICAgdGhpcy5pbmVyc2V0QXQoaWR4LCBlbGVtKTtcbiAgICB9XG4gICAgaW5zZXJ0QWZ0ZXIoYW5jaG9yLCBlbGVtLCBuZWVkV3JhcCkge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmZpbmRJbmRleChhbmNob3IpO1xuICAgICAgICAvLyBjb25zdCBuZXh0ID0gdGhpcy5nZXQoaWR4KzEpO1xuICAgICAgICBpZihuZWVkV3JhcCkge1xuICAgICAgICAgICAgZWxlbS5zZXROZWVkV3JhcCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZXJzZXRBdChpZHgrMSwgZWxlbSk7XG4gICAgfVxuICAgIGZpbmRJbmRleChlbGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0RWxlbWVudHMuZmluZEluZGV4KGVsID0+IGVsID09PSBlbGVtKTtcbiAgICB9XG4gICAgZ2V0KGlkeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dEVsZW1lbnRzW2lkeF07XG4gICAgfVxuICAgIGZyb20oZWxlbWVudHMpIHtcbiAgICAgICAgdGhpcy5fdGV4dEVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgfVxuICAgIGluZXJzZXRBdChpZHgsIGVsZW0pIHtcbiAgICAgICAgdGhpcy5zcGxpY2UoaWR4LCAwLCBlbGVtKVxuICAgIH1cbiAgICBwdXNoKGVsZW0pIHtcbiAgICAgICAgdGhpcy5zcGxpY2UodGhpcy5sZW5ndGgoKSwgMCwgZWxlbSk7XG4gICAgfVxuICAgIHJlbW92ZShpZHgpIHtcbiAgICAgICAgdGhpcy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG4gICAgc3BsaWNlKCkge1xuICAgICAgICBjb25zdCByZW1vdmVkID0gdGhpcy5fdGV4dEVsZW1lbnRzLnNwbGljZSguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9yZWNvcmRzLnB1c2goe1xuICAgICAgICAgICAgb3A6ICdzcGxpY2UnLFxuICAgICAgICAgICAgYXJnczogYXJndW1lbnRzLFxuICAgICAgICAgICAgcmVtb3ZlZCxcbiAgICAgICAgfSlcbiAgICB9XG4gICAgc2xpY2UoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dEVsZW1lbnRzLnNsaWNlKC4uLmFyZ3MpXG4gICAgfVxuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0RWxlbWVudHMuc2xpY2UoKTtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRFbGVtZW50cy5sZW5ndGggPT09IDEgJiYgdGhpcy5fdGV4dEVsZW1lbnRzWzBdLnNvdXJjZSA9PT0gJyc7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fdGV4dEVsZW1lbnRzLmZvckVhY2goY2FsbGJhY2spO1xuICAgIH1cbiAgICB0YWlsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dEVsZW1lbnRzW3RoaXMuX3RleHRFbGVtZW50cy5sZW5ndGgtMV07XG4gICAgfVxuICAgIGZpbHRlcihjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dEVsZW1lbnRzLmZpbHRlcihjYWxsYmFjayk7XG4gICAgfVxuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRFbGVtZW50cy5sZW5ndGg7XG4gICAgfVxuXG4gICAgc3RhcnRSZWNvcmQoKSB7XG4gICAgICAgIHRoaXMuX2NhcmV0UmVjb3JkID0ge1xuICAgICAgICAgICAgYmVmb3JlOiBudWxsLFxuICAgICAgICAgICAgYWZ0ZXI6IG51bGwsXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVjb3JkcyA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVjb3JkcztcbiAgICB9XG5cbiAgICBnZXRSZWNvcmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWNvcmRzO1xuICAgIH1cblxuICAgIHJlY29yZEJlZm9yZUNhcmV0KGNhcmV0KSB7XG4gICAgICAgIHRoaXMuX2NhcmV0UmVjb3JkLmJlZm9yZSA9IGNhcmV0LnRvUmFuZ2UoKTtcbiAgICB9XG5cbiAgICByZWNvcmRBZnRlckNhcmV0KGNhcmV0KSB7XG4gICAgICAgIHRoaXMuX2NhcmV0UmVjb3JkLmFmdGVyID0gY2FyZXQudG9SYW5nZSgpO1xuICAgIH1cblxuICAgIGdldENhcmV0UmVjb3JkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FyZXRSZWNvcmQ7XG4gICAgfVxuXG4gICAgY29sbGVjdFJlY29yZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWNvcmRzO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRleHRFbGVtZW50IHtcbiAgICBuZWVkV3JhcCA9IGZhbHNlO1xuICAgIHdpZHRoID0gMDtcbiAgICByZWR1Y2VXaWR0aCA9IDA7XG4gICAgaGVpZ2h0ID0gMDtcbiAgICBhbmNob3JYID0gMDtcbiAgICBhbmNob3JZID0gMDtcbiAgICBkaXJ0eSA9IHRydWU7XG4gICAgaXNUYWlsID0gZmFsc2U7XG5cbiAgICBfc3BhY2VSZWNvcmRzID0gW107XG4gICAgX3NwYWNlZENvbnRlbnRTZWdtbmVudCA9IFtdO1xuICAgIF9yZXR1cm5TeW1ib2wgPSB7XG4gICAgICAgIHN5bWJvbDogJ+KGsicsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBzb3VyY2UpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuXG4gICAgZ2V0UmVuZGVyU291cmNlKHNwYWNlSG9sZGVyKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgaWYoc3BhY2VIb2xkZXIuZW5hYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudC5yZXBsYWNlKC9cXHMvZywgc3BhY2VIb2xkZXIuc3BhY2VQbGFjZWhvbGRlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG5cbiAgICBzZXRTb3VyY2VXaXRoUmVjb3JkKHNvdXJjZSwgc3BhY2VIb2xkZXIsIHJlY29yZHMpIHtcbiAgICAgICAgY29uc3QgbGFzdFNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgICB0aGlzLnNldFNvdXJjZShzb3VyY2UsIHNwYWNlSG9sZGVyKTtcbiAgICAgICAgaWYocmVjb3Jkcykge1xuICAgICAgICAgICAgcmVjb3Jkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBvcDogJ3NldFNvdXJjZScsXG4gICAgICAgICAgICAgICAgYXJnczogW3RoaXMsIHNvdXJjZSwgbGFzdFNvdXJjZV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFNvdXJjZShzb3VyY2UsIHNwYWNlSG9sZGVyKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaWYoc3BhY2VIb2xkZXIuZW5hYmxlKSB7XG4gICAgICAgICAgICBjb25zdCByID0gdGhpcy5fc3BhY2VSZWNvcmRzO1xuICAgICAgICAgICAgY29uc3QgcCA9IHNwYWNlSG9sZGVyLnNwYWNlUGxhY2Vob2xkZXJcbiAgICAgICAgICAgIHIubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGxldCBsYXN0T2Zmc2V0O1xuICAgICAgICAgICAgc291cmNlLnJlcGxhY2UoL1xccy9nLCAoXywgb2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYobGFzdE9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHIucHVzaChvZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihvZmZzZXQgLSBsYXN0T2Zmc2V0ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByLnB1c2gobGFzdE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHIucHVzaChvZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgaWYobGFzdE9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgci5wdXNoKGxhc3RPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0TmVlZFdyYXAobmVlZFdyYXAsIHJlY29yZHMpIHtcbiAgICAgICAgY29uc3QgbGFzdFdyYXAgPSB0aGlzLm5lZWRXcmFwO1xuICAgICAgICB0aGlzLm5lZWRXcmFwID0gbmVlZFdyYXA7XG4gICAgICAgIGlmKGxhc3RXcmFwIT09IG5lZWRXcmFwICYmIHJlY29yZHMpIHtcbiAgICAgICAgICAgIHJlY29yZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3A6ICdzZXROZWVkV3JhcCcsXG4gICAgICAgICAgICAgICAgYXJnczogW3RoaXMsIG5lZWRXcmFwLCBsYXN0V3JhcF0sXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2hpZnQob2Zmc2V0LCBzdGVwKSB7XG4gICAgICAgIGlmKHRoaXMudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5zb3VyY2U7XG4gICAgICAgICAgICBjb25zdCBsID0gY29udGVudC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBuZXh0T2Zmc2V0ID0gb2Zmc2V0ICsgc3RlcDtcbiAgICAgICAgICAgIGlmKG5leHRPZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdwcmV2JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKG5leHRPZmZzZXQgPiBsICl7Ly8tICgoaXNUYWlsIHx8IHRoaXMubmVlZFdyYXApID8gMCA6IDEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICduZXh0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnc2VsZic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZihzdGVwID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbmV4dCc7XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgaWYoc3RlcCA8IDApe1xuICAgICAgICAgICAgICAgIHJldHVybiAncHJldic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0YWlsT2Zmc2V0KCkge1xuICAgICAgICBpZih0aGlzLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgaWYodGhpcy5uZWVkV3JhcCB8fCB0aGlzLmlzVGFpbCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIHRoaXMuc291cmNlLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoZWFkT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBwcmVDYWxjdWxhdGVUZXh0KGN0eCwgc3BhY2VIb2xkZXIpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuZ2V0UmVuZGVyU291cmNlKHNwYWNlSG9sZGVyKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IGN0eC5tZWFzdXJlVGV4dChjb250ZW50KS53aWR0aDtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICBpZihzcGFjZUhvbGRlci5lbmFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNfd2lkdGggPSBjdHgubWVhc3VyZVRleHQoc3BhY2VIb2xkZXIuc3BhY2VQbGFjZWhvbGRlcikud2lkdGg7XG4gICAgICAgICAgICB0aGlzLl9yZXR1cm5TeW1ib2wud2lkdGggPSBjdHgubWVhc3VyZVRleHQodGhpcy5fcmV0dXJuU3ltYm9sLnN5bWJvbCkud2lkdGg7XG4gICAgICAgICAgICBjb25zdCByMiA9IHRoaXMuX3NwYWNlZENvbnRlbnRTZWdtbmVudDtcbiAgICAgICAgICAgIGxldCBsYXN0T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHIyLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBpZih0aGlzLl9zcGFjZVJlY29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IHRoaXMuX3NwYWNlUmVjb3JkczsgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBsID0gci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlKGkgPCBsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGYgPSByW2krK107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSByW2krK107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHEgPSBjb250ZW50LnN1YnN0cmluZyhsYXN0T2Zmc2V0LCBmKTtcbiAgICAgICAgICAgICAgICAgICAgcjIucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBxLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1lYXN1cmVUZXh0KHEpLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICByMi5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuc3Vic3RyaW5nKGYsIHQrMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAodCAtIGYgKyAxKSAqIHNfd2lkdGgsICBcbiAgICAgICAgICAgICAgICAgICAgICAgICdwbGFjZWhvbGRlcicsXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSB0KzFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihsYXN0T2Zmc2V0IDwgY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBxID0gY29udGVudC5zdWJzdHJpbmcobGFzdE9mZnNldCk7XG4gICAgICAgICAgICAgICAgcjIucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIHEsXG4gICAgICAgICAgICAgICAgICAgIGN0eC5tZWFzdXJlVGV4dChxKS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQnLFxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHRoaXMubmVlZFdyYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoICs9IHRoaXMuX3JldHVyblN5bWJvbC53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG5cbiAgICByZW5kZXIoY3R4LCBzcGFjZUhvbGRlciwgdGV4dENvbG9yKSB7XG4gICAgICAgIGlmKHNwYWNlSG9sZGVyLmVuYWJsZSkge1xuICAgICAgICAgICAgY29uc3QgaHcgPSB0aGlzLndpZHRoLzI7XG4gICAgICAgICAgICBsZXQgX3cgPSAgLWh3ICsgdGhpcy5hbmNob3JYO1xuICAgICAgICAgICAgY29uc3Qgc3BhY2VQbGFjZWhvbGRlckNvbG9yID0gc3BhY2VIb2xkZXIuc3BhY2VQbGFjZWhvbGRlckNvbG9yO1xuICAgICAgICAgICAgdGhpcy5fc3BhY2VkQ29udGVudFNlZ21uZW50LmZvckVhY2goc2VnID0+IHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gc2VnWzJdID09PSAndGV4dCcgPyB0ZXh0Q29sb3IgOiBzcGFjZVBsYWNlaG9sZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IHNlZ1sxXS8yO1xuICAgICAgICAgICAgICAgIF93ICs9IHQ7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHNlZ1swXSwgX3csIHRoaXMuYW5jaG9yWSk7XG4gICAgICAgICAgICAgICAgX3cgKz0gdDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBpZih0aGlzLm5lZWRXcmFwKSB7XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9IHNwYWNlSG9sZGVyLnJldHVybkZvbnQ7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHNwYWNlUGxhY2Vob2xkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGhpcy5fcmV0dXJuU3ltYm9sLnN5bWJvbCwgXG4gICAgICAgICAgICAgICAgICAgIF93ICsgdGhpcy5fcmV0dXJuU3ltYm9sLndpZHRoLzIsIHRoaXMuYW5jaG9yWSk7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjsgICBcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFRleHQodGhpcy5zb3VyY2UsIHRoaXMuYW5jaG9yWCwgdGhpcy5hbmNob3JZKVxuICAgIH1cbn0iLCJpbXBvcnQgeyBUZXh0RWxlbWVudCB9IGZyb20gXCIuLi9zdG9yYWdlXCI7XG5jbGFzcyBSYW5nZSB7XG4gICAgX2VuYWJsZSA9IGZhbHNlO1xuICAgIF9yYW5nZUZyb20gPSBudWxsOyAvLyBbcm93LCBlbGVtX2lkeCwgb2Zmc2V0XVxuICAgIF9yYW5nZVRvID0gbnVsbDsgICAvLyBbcm93LCBlbGVtX2lkeCwgb2Zmc2V0XVxuICAgIF9pbml0aWFsUmFuZ2UgPSBudWxsOyBcblxuICAgIHNldEluaXRpYWxSYW5nZShpbml0aWFsUmFuZ2UpIHtcbiAgICAgICAgdGhpcy5faW5pdGlhbFJhbmdlID0gaW5pdGlhbFJhbmdlO1xuICAgIH1cblxuICAgIGdldFJhbmdlRnJvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhbmdlRnJvbTtcbiAgICB9XG5cbiAgICBnZXRSYW5nZVRvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmFuZ2VUbztcbiAgICB9XG5cbiAgICBpc0VuYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZTtcbiAgICB9XG5cbiAgICBlbmFibGUoKSB7XG4gICAgICAgIHRoaXMuX2VuYWJsZSA9IHRydWU7XG4gICAgfVxuICAgIGRpc2FibGUoKSB7XG4gICAgICAgIHRoaXMuX2VuYWJsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGhhbmRsZUNhcmV0KGNhcmV0KSB7XG4gICAgICAgIGNvbnN0IFthLCBiLCBjXSA9IHRoaXMuX3JhbmdlVG87XG4gICAgICAgIGNhcmV0LnNldFJvdyhhKTtcbiAgICAgICAgY2FyZXQuc2V0Q29sdW1uKFtiLCBjXSk7XG4gICAgfVxuXG4gICAgc2V0UmFuZ2UoYW5vdGhlcikge1xuICAgICAgICBjb25zdCBhID0gdGhpcy5faW5pdGlhbFJhbmdlO1xuICAgICAgICBpZih0aGlzLl9jb21wYXJlUmFuZ2UoYSwgYW5vdGhlcikpIHtcbiAgICAgICAgICAgIHRoaXMuX3JhbmdlRnJvbSA9IGE7XG4gICAgICAgICAgICB0aGlzLl9yYW5nZVRvID0gYW5vdGhlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JhbmdlRnJvbSA9IGFub3RoZXI7XG4gICAgICAgICAgICB0aGlzLl9yYW5nZVRvID0gYTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgX2NvbXBhcmVSYW5nZShyMSwgcjIpIHtcbiAgICAgICAgaWYocjFbMF0gPiByMlswXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHIxWzBdID09PSByMlswXSAmJiByMVsxXSA+IHIyWzFdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYocjFbMF0gPT09IHIyWzBdICYmIHIxWzFdID09PSByMlsxXSAmJiByMVsyXSA+IHIyWzJdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gVE9ETyBcbiAgICBnZXRSYW5nZUNvcHkoZWRpdG9yKSB7XG4gICAgICAgIGlmKHRoaXMuX2VuYWJsZSkge1xuICAgICAgICAgICAgY29uc3QgYXJlYSA9IGVkaXRvci5fYXJlYTtcbiAgICAgICAgICAgIGNvbnN0IGNhcmV0ID0gZWRpdG9yLl9jYXJldDtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlRnJvbSA9IHRoaXMuX3JhbmdlRnJvbTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlVG8gPSB0aGlzLl9yYW5nZVRvO1xuICAgICAgICAgICAgY29uc3QgZWxlbUZyb20gPSBhcmVhLmdldChyYW5nZUZyb21bMF0pLmdldChyYW5nZUZyb21bMV0pO1xuICAgICAgICAgICAgY29uc3QgZWxlbVRvID0gYXJlYS5nZXQocmFuZ2VUb1swXSkuZ2V0KHJhbmdlVG9bMV0pO1xuICAgICAgICAgICAgaWYoZWxlbUZyb20gPT09IGVsZW1Ubykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBlbGVtRnJvbS5zb3VyY2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMuc3Vic3RyaW5nKHJhbmdlRnJvbVsyXSwgcmFuZ2VUb1syXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGZsYXR0ZW5UeHRFbGVtID0gZWRpdG9yLl9mbGF0dGVuVHh0RWxlbVxuICAgICAgICAgICAgbGV0IHByZUNvbnRlbnQgPSAnJztcbiAgICAgICAgICAgIGxldCBhZnRlckNvbnRlbnQgPSAnJztcbiAgICAgICAgICAgIGNvbnN0IGZyb21JZHggPSBmbGF0dGVuVHh0RWxlbS5maW5kSW5kZXgoZWxlbUZyb20pO1xuICAgICAgICAgICAgY29uc3QgdG9JZHggPSBmbGF0dGVuVHh0RWxlbS5maW5kSW5kZXgoZWxlbVRvKTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1zID0gZmxhdHRlblR4dEVsZW0uc2xpY2UoZnJvbUlkeCwgdG9JZHgrMSk7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IGVsZW1zLnNsaWNlKDEsIGVsZW1zLmxlbmd0aC0xKS5maWx0ZXIoKGVsKSA9PiBlbC50eXBlID09PSAndGV4dCcpO1xuICAgICAgICAgICAgcHJlQ29udGVudCA9IGVsZW1Gcm9tLnNvdXJjZS5zdWJzdHJpbmcocmFuZ2VGcm9tWzJdKTtcbiAgICAgICAgICAgIGFmdGVyQ29udGVudCA9IGVsZW1Uby5zb3VyY2Uuc3Vic3RyaW5nKDAsIHJhbmdlVG9bMl0pO1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBwcmVDb250ZW50O1xuICAgICAgICAgICAgaWYoZWxlbUZyb20ubmVlZFdyYXApIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ICs9ICdcXG4nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IGVsLnNvdXJjZVxuICAgICAgICAgICAgICAgIGlmKGVsLm5lZWRXcmFwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gJ1xcbidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50ICsgYWZ0ZXJDb250ZW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVsZXRlKGVkaXRvciwgcmVjb3Jkcykge1xuICAgICAgICBpZih0aGlzLl9lbmFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyZWEgPSBlZGl0b3IuX2FyZWE7XG4gICAgICAgICAgICBjb25zdCBjYXJldCA9IGVkaXRvci5fY2FyZXQ7XG4gICAgICAgICAgICBjb25zdCByYW5nZUZyb20gPSB0aGlzLl9yYW5nZUZyb207XG4gICAgICAgICAgICBjb25zdCByYW5nZVRvID0gdGhpcy5fcmFuZ2VUbztcbiAgICAgICAgICAgIGNvbnN0IGVsZW1Gcm9tID0gYXJlYS5nZXQocmFuZ2VGcm9tWzBdKS5nZXQocmFuZ2VGcm9tWzFdKTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1UbyA9IGFyZWEuZ2V0KHJhbmdlVG9bMF0pLmdldChyYW5nZVRvWzFdKTtcbiAgICAgICAgICAgIGxldCBbcm93LCBlbGVtX2lkeCwgb2Zmc2V0XSA9IHJhbmdlRnJvbTtcbiAgICAgICAgICAgIHJlY29yZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3A6ICdyYW5nZScsXG4gICAgICAgICAgICAgICAgYXJnczogW3JhbmdlRnJvbS5zbGljZSgpLCByYW5nZVRvLnNsaWNlKCldLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGlmKGVsZW1Gcm9tID09PSBlbGVtVG8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gZWxlbUZyb20uc291cmNlO1xuICAgICAgICAgICAgICAgIGVsZW1Gcm9tLnNldFNvdXJjZVdpdGhSZWNvcmQoXG4gICAgICAgICAgICAgICAgICAgIGMuc3Vic3RyaW5nKDAsIHJhbmdlRnJvbVsyXSkgKyBjLnN1YnN0cmluZyhyYW5nZVRvWzJdKSwgXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5zcGFjZUhvbGRlcixcbiAgICAgICAgICAgICAgICAgICAgcmVjb3Jkcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZsYXR0ZW5UeHRFbGVtID0gZWRpdG9yLl9mbGF0dGVuVHh0RWxlbVxuICAgICAgICAgICAgICAgIGxldCBwcmVDb250ZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgbGV0IGFmdGVyQ29udGVudCA9ICcnO1xuICAgICAgICAgICAgICAgIGxldCBwcmVFbGVtZW50O1xuICAgICAgICAgICAgICAgIGxldCBhZnRlckVsZW1lbnQ7ICBcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tSWR4ID0gZmxhdHRlblR4dEVsZW0uZmluZEluZGV4KGVsZW1Gcm9tKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b0lkeCA9IGZsYXR0ZW5UeHRFbGVtLmZpbmRJbmRleChlbGVtVG8pO1xuICAgICAgICAgICAgICAgIGxldCBlbmRUZXh0TmVlZFdyYXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZihlbGVtRnJvbS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlQ29udGVudCA9IGVsZW1Gcm9tLnNvdXJjZS5zdWJzdHJpbmcoMCwgcmFuZ2VGcm9tWzJdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmVFbGVtZW50ID0gZmxhdHRlblR4dEVsZW0uZ2V0KGZyb21JZHgtMSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoZWxlbVRvLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBhZnRlckNvbnRlbnQgPSBlbGVtVG8uc291cmNlLnN1YnN0cmluZyhyYW5nZVRvWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kVGV4dE5lZWRXcmFwID0gZWxlbVRvLm5lZWRXcmFwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyRWxlbWVudCA9IGZsYXR0ZW5UeHRFbGVtLmdldCh0b0lkeC0xKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihwcmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5UeHRFbGVtLnNwbGljZShmcm9tSWR4LCB0b0lkeC1mcm9tSWR4KzEpO1xuICAgICAgICAgICAgICAgICAgICBpZihwcmVFbGVtZW50LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYocHJlRWxlbWVudC5uZWVkV3JhcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtX2lkeCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gcHJlRWxlbWVudC5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlRWxlbWVudC5zZXRTb3VyY2VXaXRoUmVjb3JkKHByZUVsZW1lbnQuc291cmNlICsgYWZ0ZXJDb250ZW50LCBlZGl0b3Iuc3BhY2VIb2xkZXIsIHJlY29yZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlRWxlbWVudC5zZXROZWVkV3JhcChlbmRUZXh0TmVlZFdyYXAsIHJlY29yZHMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IG5ldyBUZXh0RWxlbWVudCgndGV4dCcsIHByZUNvbnRlbnQgKyBhZnRlckNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdC5zZXROZWVkV3JhcChlbmRUZXh0TmVlZFdyYXAsIHJlY29yZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhdHRlblR4dEVsZW0uc3BsaWNlKGZyb21JZHgsIDAsIHQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmbGF0dGVuVHh0RWxlbS5zcGxpY2UoZnJvbUlkeCwgdG9JZHgtZnJvbUlkeCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGFmdGVyRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IG5ldyBUZXh0RWxlbWVudCgndGV4dCcsIHByZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhdHRlblR4dEVsZW0uc3BsaWNlKGZyb21JZHgsIDAsIHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVRvLnNldFNvdXJjZVdpdGhSZWNvcmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlQ29udGVudCArIGFmdGVyQ29udGVudCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNwYWNlSG9sZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKGZsYXR0ZW5UeHRFbGVtLmxlbmd0aCgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVsZW1faWR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZmxhdHRlblR4dEVsZW0ucHVzaChuZXcgVGV4dEVsZW1lbnQoJ3RleHQnLCAnJykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNhcmV0LnNldFJvdyhyb3cpO1xuICAgICAgICAgICAgY2FyZXQuc2V0Q29sdW1uKFtlbGVtX2lkeCwgb2Zmc2V0XSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBSYW5nZTsiLCJcbmZ1bmN0aW9uIGlzU2V0U291cmNlQmF0Y2goeCkge1xuICAgIHJldHVybiB4Lmxlbmd0aCA9PT0gMSAmJiB4WzBdLm9wID09PSAnc2V0U291cmNlJztcbn1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVuZG9SZWRvIHtcbiAgICBzdGF0aWMgX2xlbmd0aCA9IDUwO1xuICAgIF91bmRvID0gW107XG4gICAgX3JlZG8gPSBbXTtcbiAgICBfZWRpdG9yID0gbnVsbDtcblxuICAgIHdyaXRlKHgsIGNhcmV0UmVjb3JkKSB7XG4gICAgICAgIGlmKHgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYoaXNTZXRTb3VyY2VCYXRjaCh4KSkge1xuICAgICAgICAgICAgY29uc3QgdCA9IHhbMF07XG4gICAgICAgICAgICBjb25zdCBsYXN0VW5kbyA9IHRoaXMuZ2V0TGFzdFVuZG8oKTtcbiAgICAgICAgICAgIGlmKGxhc3RVbmRvICYmIGlzU2V0U291cmNlQmF0Y2gobGFzdFVuZG8uX2JhdGNoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHEgPSBsYXN0VW5kby5fYmF0Y2hbMF07XG4gICAgICAgICAgICAgICAgaWYocS5hcmdzWzBdID09PSB0LmFyZ3NbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcS5hcmdzWzFdID0gdC5hcmdzWzFdO1xuICAgICAgICAgICAgICAgICAgICBsYXN0VW5kby5fY2FyZXRNZXRhVG8gPSBjYXJldFJlY29yZC5hZnRlcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByID0gbmV3IEJhdGNoQWN0aW9uKHgpO1xuICAgICAgICByLl9jYXJldE1ldGFGcm9tID0gY2FyZXRSZWNvcmQuYmVmb3JlO1xuICAgICAgICByLl9jYXJldE1ldGFUbyA9IGNhcmV0UmVjb3JkLmFmdGVyO1xuICAgICAgICB0aGlzLl91bmRvLnB1c2gocik7XG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLl91bmRvLmxlbmd0aCA+IFVuZG9SZWRvLl9sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3VuZG8uc3BsaWNlKDAsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuX3JlZG8ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWRvID0gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRMYXN0VW5kbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VuZG9bdGhpcy5fdW5kby5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICB1bmRvKCkge1xuICAgICAgICBjb25zdCB4ID0gdGhpcy5fdW5kby5wb3AoKTtcbiAgICAgICAgaWYoeCkge1xuICAgICAgICAgICAgeC51bmRvKHRoaXMuX2VkaXRvcilcbiAgICAgICAgICAgIHRoaXMuX3JlZG8ucHVzaCh4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICByZWRvKCkge1xuICAgICAgICBsZXQgeCA9IHRoaXMuX3JlZG8ucG9wKCk7XG4gICAgICAgIHdoaWxlKHggJiYgeC5TS0lQX1JFRE8pIHtcbiAgICAgICAgICAgIHggPSB0aGlzLl9yZWRvLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHgpIHtcbiAgICAgICAgICAgIHgucmVkbyh0aGlzLl9lZGl0b3IpXG4gICAgICAgICAgICB0aGlzLl91bmRvLnB1c2goeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxufVxuXG5jbGFzcyBCYXRjaEFjdGlvbiB7XG4gICAgX2JhdGNoID0gW107XG4gICAgX2NhcmV0TWV0YUZyb20gPSBudWxsO1xuICAgIF9jYXJldE1ldGFUbyA9IG51bGw7XG4gICAgY29uc3RydWN0b3IoYmF0Y2gpIHtcbiAgICAgICAgdGhpcy5fYmF0Y2ggPSBiYXRjaDtcbiAgICB9XG5cbiAgICB1cGRhdGVDYXJldE1ldGFUbyhtZXRhKSB7XG4gICAgICAgIHRoaXMuX2NhcmV0TWV0YVRvID0gbWV0YTtcbiAgICB9XG5cbiAgICB1bmRvKGVkaXRvcikge1xuICAgICAgICB0aGlzLl9iYXRjaC5zbGljZSgpLnJldmVyc2UoKS5mb3JFYWNoKGFjdGlvbiA9PiB7XG4gICAgICAgICAgICBzd2l0Y2goYWN0aW9uLm9wKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncmFuZ2UnOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbcmFuZ2VGcm9tLCByYW5nZVRvXSA9IGFjdGlvbi5hcmdzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IGVkaXRvci5fcmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEluaXRpYWxSYW5nZShyYW5nZUZyb20pO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRSYW5nZShyYW5nZVRvKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuZW5hYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NldFNvdXJjZSc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtlbGVtLCBzLCBsc10gPSBhY3Rpb24uYXJncztcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRTb3VyY2UobHMsIGVkaXRvci5zcGFjZUhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NldE5lZWRXcmFwJzpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW28sIHAsIHFdID0gYWN0aW9uLmFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIG8ubmVlZFdyYXAgPSBxO1xuICAgICAgICAgICAgICAgICAgICBvLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmxhdHRlblR4dEVsZW0gPSBlZGl0b3IuX2ZsYXR0ZW5UeHRFbGVtO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbYSwgYiwgLi4uY10gPSBhY3Rpb24uYXJncztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlZCA9IGFjdGlvbi5yZW1vdmVkO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IDBcbiAgICAgICAgICAgICAgICAgICAgaWYoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmxhdHRlblR4dEVsZW0uc3BsaWNlKGEsIGksIC4uLnJlbW92ZWQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWRpdG9yLl9jYXJldC5mcm9tUmFuZ2UodGhpcy5fY2FyZXRNZXRhRnJvbSk7XG4gICAgfVxuXG4gICAgcmVkbyhlZGl0b3IpIHtcbiAgICAgICAgdGhpcy5fYmF0Y2guZm9yRWFjaChhY3Rpb24gPT4ge1xuICAgICAgICAgICAgc3dpdGNoKGFjdGlvbi5vcCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NldFNvdXJjZSc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtlbGVtLCBzLCBsc10gPSBhY3Rpb24uYXJncztcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRTb3VyY2UocywgZWRpdG9yLnNwYWNlSG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2V0TmVlZFdyYXAnOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbbywgcCwgcV0gPSBhY3Rpb24uYXJncztcbiAgICAgICAgICAgICAgICAgICAgby5uZWVkV3JhcCA9IHA7XG4gICAgICAgICAgICAgICAgICAgIG8uZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbGF0dGVuVHh0RWxlbSA9IGVkaXRvci5fZmxhdHRlblR4dEVsZW07XG4gICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5UeHRFbGVtLnNwbGljZSguLi5hY3Rpb24uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBlZGl0b3IuX2NhcmV0LmZyb21SYW5nZSh0aGlzLl9jYXJldE1ldGFUbyk7XG4gICAgfVxufSIsImNsYXNzIENvbW1hbmQge1xuICAgIHN0YXRpYyBjcmVhdGUoZWRpdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhlZGl0b3IpXG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoZWRpdG9yKSB7XG4gICAgICAgIHRoaXMuX2VkaXRvciA9IGVkaXRvcjtcbiAgICB9XG5cbiAgICBleGVjKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29tbWFuZDsiLCJpbXBvcnQgQ29tbWFuZCBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHsgS0VZQk9BUkRfQ09NTUFORFMgfSBmcm9tICcuLi9iYXNlL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBjbGFzcyBBcnJvd0xlZnRDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gICAgc3RhdGljIF9uYW1lID0gS0VZQk9BUkRfQ09NTUFORFMuQVJST1dfTEVGVDtcblxuICAgIGV4ZWMoKSB7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuX2VkaXRvcjtcbiAgICAgICAgZWRpdG9yLl9yYW5nZS5kaXNhYmxlKCk7XG4gICAgICAgIGNvbnN0IGZsYXR0ZW5UeHRFbGVtID0gZWRpdG9yLl9mbGF0dGVuVHh0RWxlbVxuICAgICAgICBjb25zdCBjYXJldCA9IGVkaXRvci5fY2FyZXQ7XG4gICAgICAgIGNvbnN0IHJvdyA9IGNhcmV0LmdldFJvdygpO1xuICAgICAgICBjb25zdCBjb2x1bW4gPSBjYXJldC5nZXRDb2x1bW4oKTtcbiAgICAgICAgY29uc3QgW2VsZW1pZHgsIG9mZnNldF0gPSBjb2x1bW47XG4gICAgICAgIGNvbnN0IGxpbmUgPSBlZGl0b3IuX2FyZWEuZ2V0KHJvdyk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBsaW5lLmdldChlbGVtaWR4KTtcbiAgICAgICAgY29uc3QgaWR4ID0gZmxhdHRlblR4dEVsZW0uZmluZEluZGV4KGVsZW1lbnQpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBlbGVtZW50LnNoaWZ0KG9mZnNldCwgLTEpO1xuICAgICAgICBzd2l0Y2gocmVzdWx0KSB7XG4gICAgICAgICAgICBjYXNlICdwcmV2JzpcbiAgICAgICAgICAgICAgICBpZihlbGVtaWR4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGxpbmUuZ2V0KGVsZW1pZHggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgY2FyZXQuc2V0Q29sdW1uKFtlbGVtaWR4IC0gMSwgZWwudGFpbE9mZnNldCgpXSlcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoaWR4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVSb3cgPSByb3cgLSAxO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVFbGVtaWR4ID0gZWRpdG9yLl9hcmVhLmdldChwcmVSb3cpLmxlbmd0aCgpIC0gMVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBmbGF0dGVuVHh0RWxlbS5nZXQoaWR4LTEpLnRhaWxPZmZzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FyZXQuc2V0Um93KHByZVJvdyk7XG4gICAgICAgICAgICAgICAgICAgIGNhcmV0LnNldENvbHVtbihbcHJlRWxlbWlkeCwgb2Zmc2V0XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2VsZic6XG4gICAgICAgICAgICAgICAgY2FyZXQuc2V0Q29sdW1uKDEsIG9mZnNldCAtIDEpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FyZXQucmVmcmVzaCgpO1xuICAgICAgICBlZGl0b3Iuc3luY1NoYWRvd0lucHV0UG9zaXRpb24oKTtcbiAgICAgICAgZWRpdG9yLl9qZmxvdy5fcmVuZGVyKCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFycm93UmlnaHRDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gICAgc3RhdGljIF9uYW1lID0gS0VZQk9BUkRfQ09NTUFORFMuQVJST1dfUklHSFQ7XG5cbiAgICBleGVjKCkge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLl9lZGl0b3I7XG4gICAgICAgIGVkaXRvci5fcmFuZ2UuZGlzYWJsZSgpO1xuICAgICAgICBjb25zdCBmbGF0dGVuVHh0RWxlbSA9IGVkaXRvci5fZmxhdHRlblR4dEVsZW1cbiAgICAgICAgY29uc3QgY2FyZXQgPSBlZGl0b3IuX2NhcmV0O1xuICAgICAgICBjb25zdCByb3cgPSBjYXJldC5nZXRSb3coKTtcbiAgICAgICAgY29uc3QgY29sdW1uID0gY2FyZXQuZ2V0Q29sdW1uKCk7XG4gICAgICAgIGNvbnN0IFtlbGVtaWR4LCBvZmZzZXRdID0gY29sdW1uO1xuICAgICAgICBjb25zdCBsaW5lID0gZWRpdG9yLl9hcmVhLmdldChyb3cpO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gbGluZS5nZXQoZWxlbWlkeCk7XG4gICAgICAgIGNvbnN0IGlkeCA9IGZsYXR0ZW5UeHRFbGVtLmZpbmRJbmRleChlbGVtZW50KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZWxlbWVudC5zaGlmdChvZmZzZXQsIDEsIGlkeCA9PT0gZmxhdHRlblR4dEVsZW0ubGVuZ3RoKCktMSk7XG4gICAgICAgIHN3aXRjaChyZXN1bHQpIHtcbiAgICAgICAgICAgIGNhc2UgJ25leHQnOlxuICAgICAgICAgICAgICAgIGlmKGVsZW1pZHggPCBsaW5lLmxlbmd0aCgpLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWwgPSBsaW5lLmdldChlbGVtaWR4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGVsZW1lbnQudHlwZSA9PT0gJ3RleHQnICYmIGVsLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXQuc2V0Q29sdW1uKFtlbGVtaWR4ICsgMiwgZWwuaGVhZE9mZnNldCgpXSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0LnNldENvbHVtbihbZWxlbWlkeCArIDEsIGVsLmhlYWRPZmZzZXQoKV0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoaWR4IDwgZmxhdHRlblR4dEVsZW0ubGVuZ3RoKCktMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhZnRlclJvdyA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGZsYXR0ZW5UeHRFbGVtLmdldChpZHggKyAxKS5oZWFkT2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNhcmV0LnNldFJvdyhhZnRlclJvdyk7XG4gICAgICAgICAgICAgICAgICAgIGNhcmV0LnNldENvbHVtbihbMCwgb2Zmc2V0XSk7XG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2VsZic6XG4gICAgICAgICAgICAgICAgY2FyZXQuc2V0Q29sdW1uKDEsIG9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FyZXQucmVmcmVzaCgpO1xuICAgICAgICBlZGl0b3Iuc3luY1NoYWRvd0lucHV0UG9zaXRpb24oKTtcbiAgICAgICAgZWRpdG9yLl9qZmxvdy5fcmVuZGVyKCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFycm93VXBDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gICAgc3RhdGljIF9uYW1lID0gS0VZQk9BUkRfQ09NTUFORFMuQVJST1dfVVA7XG5cbiAgICBleGVjKCkge1xuICAgICAgICB0aGlzLl9lZGl0b3IuX3JhbmdlLmRpc2FibGUoKTtcbiAgICAgICAgY29uc3QgbmV4dFJvdyA9IHRoaXMuX2VkaXRvci5fY2FyZXQuZ2V0Um93KCkgLSAxO1xuICAgICAgICBpZihuZXh0Um93ID4gLTEpe1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlcihuZXh0Um93KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBcnJvd0Rvd25Db21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gICAgc3RhdGljIF9uYW1lID0gS0VZQk9BUkRfQ09NTUFORFMuQVJST1dfRE9XTjtcblxuICAgIGV4ZWMoKSB7XG4gICAgICAgIHRoaXMuX2VkaXRvci5fcmFuZ2UuZGlzYWJsZSgpO1xuICAgICAgICBjb25zdCBuZXh0Um93ID0gdGhpcy5fZWRpdG9yLl9jYXJldC5nZXRSb3coKSArIDE7XG4gICAgICAgIGlmKG5leHRSb3cgPCB0aGlzLl9lZGl0b3IuX2FyZWEubGVuZ3RoKCkpe1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlcihuZXh0Um93KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IF9taXhpbiA9IHtcbiAgICBfaGFuZGxlcihuZXh0Um93KSB7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuX2VkaXRvcjtcbiAgICAgICAgY29uc3QgY2FyZXQgPSBlZGl0b3IuX2NhcmV0O1xuICAgICAgICBjb25zdCByb3cgPSBjYXJldC5nZXRSb3coKTtcbiAgICAgICAgY29uc3QgY29sdW1uID0gY2FyZXQuZ2V0Q29sdW1uKCk7XG4gICAgICAgIGNvbnN0IFtlbGVtaWR4LCBvZmZzZXRdID0gY29sdW1uO1xuICAgICAgICBjb25zdCBhcmVhID0gZWRpdG9yLl9hcmVhO1xuICAgICAgICBjb25zdCBsaW5lID0gYXJlYS5nZXQocm93KTtcbiAgICAgICAgbGV0IGN1cnJFbGVtID0gbGluZS5nZXQoZWxlbWlkeCk7XG4gICAgICAgIGxldCBjdXJyRWxlbVJlZHVjZVdpZHRoID0gY3VyckVsZW0ucmVkdWNlV2lkdGg7XG4gICAgICAgIGlmKG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIGN1cnJFbGVtUmVkdWNlV2lkdGggKz0gZWRpdG9yLm1lYXN1cmVUZXh0V2lkdGgoY3VyckVsZW0uZ2V0UmVuZGVyU291cmNlKGVkaXRvci5zcGFjZUhvbGRlcikuc3Vic3RyaW5nKDAsIG9mZnNldCkpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IG5leHRMaW5lID0gYXJlYS5nZXQobmV4dFJvdyk7XG4gICAgICAgIGNvbnN0IG5leHRDb2x1bW4gPSBuZXh0TGluZS5nZXRDb2x1bW5OZWFyZXN0KGN1cnJFbGVtUmVkdWNlV2lkdGgsIGVkaXRvci5lbGVtZW50U3BhY2UsIGVkaXRvci5mb250U2l6ZSwgZWRpdG9yLmZvbnRGYW1pbHksIGVkaXRvcilcbiAgICAgICAgY2FyZXQuc2V0Um93KG5leHRSb3cpO1xuICAgICAgICBjYXJldC5zZXRDb2x1bW4obmV4dENvbHVtbik7XG4gICAgICAgIFxuICAgICAgICBjYXJldC5yZWZyZXNoKCk7XG4gICAgICAgIGVkaXRvci5zeW5jU2hhZG93SW5wdXRQb3NpdGlvbigpO1xuICAgICAgICBlZGl0b3IuX2pmbG93Ll9yZW5kZXIoKTtcbiAgICB9XG59XG5cbk9iamVjdC5hc3NpZ24oQXJyb3dVcENvbW1hbmQucHJvdG90eXBlLCBfbWl4aW4pO1xuT2JqZWN0LmFzc2lnbihBcnJvd0Rvd25Db21tYW5kLnByb3RvdHlwZSwgX21peGluKTsiLCJpbXBvcnQgQ29tbWFuZCBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHsgVGV4dEVsZW1lbnQgfSBmcm9tICcuLi9zdG9yYWdlJztcbmltcG9ydCB7IEVESVRPUl9FVkVOVFMsIEtFWUJPQVJEX0lOUFVUIH0gZnJvbSAnLi4vYmFzZS9jb25zdGFudHMnO1xuZnVuY3Rpb24gX2JsYW5kQWRqYWNlbnRFbGVtZW50KGVkaXRvciwgZWxlbTEsIGVsZW0yLCBkZWZhdWx0T2Zmc2V0LCByZWNvcmRzKSB7XG4gICAgaWYoIWVsZW0xKSB7XG4gICAgICAgIHJldHVybiBbZGVmYXVsdE9mZnNldCwgZmFsc2VdO1xuICAgIH1cbiAgICBpZihlbGVtMS50eXBlID09PSAndGV4dCcgJiYgZWxlbTIudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGVsZW0xLnNvdXJjZS5sZW5ndGg7XG4gICAgICAgIGVsZW0xLnNldFNvdXJjZVdpdGhSZWNvcmQoZWxlbTEuc291cmNlICsgZWxlbTIuc291cmNlLCBlZGl0b3Iuc3BhY2VIb2xkZXIsIHJlY29yZHMpO1xuICAgICAgICBlbGVtMS5zZXROZWVkV3JhcChlbGVtMi5uZWVkV3JhcCwgcmVjb3JkcylcbiAgICAgICAgcmV0dXJuIFtvZmZzZXQsIHRydWVdO1xuICAgIH1cbiAgICByZXR1cm4gW2RlZmF1bHRPZmZzZXQsIGZhbHNlXTtcbn1cblxuZXhwb3J0IGNsYXNzIElucHV0IGV4dGVuZHMgQ29tbWFuZCB7XG4gICAgc3RhdGljIF9uYW1lID0gRURJVE9SX0VWRU5UUy5JTlBVVDtcblxuICAgIGNhY2hlSWR4ID0gbnVsbDtcblxuICAgIGV4ZWMoa2luZCwgZGF0YSkge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLl9lZGl0b3I7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gZWRpdG9yLl9yYW5nZTtcbiAgICAgICAgY29uc3QgY2FyZXQgPSBlZGl0b3IuX2NhcmV0O1xuICAgICAgICBjb25zdCBmbGF0dGVuVHh0RWxlbSA9IGVkaXRvci5fZmxhdHRlblR4dEVsZW07XG4gICAgICAgIGNvbnN0IHVuZG9yZWRvID0gZWRpdG9yLl91bmRvcmVkbztcbiAgICAgICAgY29uc3QgcmVjb3JkcyA9IGZsYXR0ZW5UeHRFbGVtLnN0YXJ0UmVjb3JkKCk7XG4gICAgICAgIGZsYXR0ZW5UeHRFbGVtLnJlY29yZEJlZm9yZUNhcmV0KGNhcmV0KTtcbiAgICAgICAgLy8gbGV0IF9hZnRlclJhbmdlRGVsZXRlID0gZmFsc2U7XG4gICAgICAgIGlmKHJhbmdlLmlzRW5hYmxlKCkpIHtcbiAgICAgICAgICAgIHJhbmdlLmRlbGV0ZShlZGl0b3IsIHJlY29yZHMpO1xuICAgICAgICAgICAgaWYoa2luZCA9PT0gS0VZQk9BUkRfSU5QVVQuQkFDS1NQQUNFIHx8IGtpbmQgPT09IEtFWUJPQVJEX0lOUFVULkRFTEVURSkge1xuICAgICAgICAgICAgICAgIGZsYXR0ZW5UeHRFbGVtLmNvbGxlY3RSZWNvcmRzKCk7XG4gICAgICAgICAgICAgICAgZmxhdHRlblR4dEVsZW0ucmVjb3JkQWZ0ZXJDYXJldChjYXJldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZWRpdG9yLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICB1bmRvcmVkby53cml0ZShyZWNvcmRzLCBmbGF0dGVuVHh0RWxlbS5nZXRDYXJldFJlY29yZCgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VkaXRvci5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgLy8gX2FmdGVyUmFuZ2VEZWxldGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCByb3cgPSBjYXJldC5nZXRSb3coKTtcbiAgICAgICAgbGV0IFtlbGVtX2lkeCwgb2Zmc2V0XSA9IGNhcmV0LmdldENvbHVtbigpO1xuICAgICAgICBjb25zdCBhcmVhID0gZWRpdG9yLl9hcmVhO1xuICAgICAgICBjb25zdCBsaW5lID0gYXJlYS5nZXQocm93KTtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBsaW5lLmdldChlbGVtX2lkeCk7XG4gICAgICAgIGxldCBwcmVFbGVtID0gbGluZS5nZXQoZWxlbV9pZHgtMSk7XG4gICAgICAgIFxuICAgICAgICBsZXQgY29udGVudCA9ICcnO1xuICAgICAgICBpZihlbGVtZW50LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgY29udGVudCA9IGVsZW1lbnQuc291cmNlO1xuICAgICAgICB9IGVsc2UgaWYocHJlRWxlbT8udHlwZSA9PT0ndGV4dCcpe1xuICAgICAgICAgICAgY29udGVudCA9IHByZUVsZW0uc291cmNlO1xuICAgICAgICAgICAgZWxlbWVudCA9IHByZUVsZW07XG4gICAgICAgICAgICBvZmZzZXQgPSBjb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIGVsZW1faWR4IC09IDE7XG4gICAgICAgICAgICBjYXJldC5zZXRDb2x1bW4oW2VsZW1faWR4LCBjb250ZW50Lmxlbmd0aF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV3RWxlbWVudCA9IG5ldyBUZXh0RWxlbWVudCgndGV4dCcsICcnKTtcbiAgICAgICAgICAgIGZsYXR0ZW5UeHRFbGVtLmluc2VydEJlZm9yZShlbGVtZW50LCBuZXdFbGVtZW50KTtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBuZXdFbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHByZUNvbnRlbnQgPSBjb250ZW50LnN1YnN0cmluZygwLCBvZmZzZXQpO1xuICAgICAgICBsZXQgYWZ0ZXJDb250ZW50IFxuICAgICAgICBpZih0aGlzLmNhY2hlSWR4KSB7XG4gICAgICAgICAgICBhZnRlckNvbnRlbnQgPSBjb250ZW50LnN1YnN0cmluZyh0aGlzLmNhY2hlSWR4WzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFmdGVyQ29udGVudCA9IGNvbnRlbnQuc3Vic3RyaW5nKG9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2goa2luZCl7XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0lOUFVULklOUFVUOlxuICAgICAgICAgICAgICAgIC8vIGlmKF9hZnRlclJhbmdlRGVsZXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGVsZW1lbnQgPSBmbGF0dGVuVHh0RWxlbS5nZXQoMCk7XG4gICAgICAgICAgICAgICAgLy8gICAgIGFmdGVyQ29udGVudCA9ICcnO1xuICAgICAgICAgICAgICAgIC8vICAgICBwcmVDb250ZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmKC9cXHI/W1xcblxcdF0vLnRlc3QoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJvd3MgPSBkYXRhLnNwbGl0KC9cXHI/W1xcblxcdF0vKSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgLy8gc291cmNlID0gc291cmNlLnJlcGxhY2UoL1xcdC8sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gZmxhdHRlblR4dEVsZW0uZmluZEluZGV4KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0TmVlZFdyYXAgPSBlbGVtZW50Lm5lZWRXcmFwO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNldFNvdXJjZVdpdGhSZWNvcmQocHJlQ29udGVudCArIHJvd3Muc2hpZnQoKSwgZWRpdG9yLnNwYWNlSG9sZGVyLCByZWNvcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZXROZWVkV3JhcCh0cnVlLCByZWNvcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVtcCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG47XG4gICAgICAgICAgICAgICAgICAgIGxldCBfcm93ID0gcm93O1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29sO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZShyb3dzLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0biA9IG5ldyBUZXh0RWxlbWVudCgndGV4dCcsIHJvd3Muc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bi5uZWVkV3JhcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wLnB1c2godG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JvdysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbCA9IHRuLnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRuLnNvdXJjZSArPSBhZnRlckNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRuLm5lZWRXcmFwID0gbGFzdE5lZWRXcmFwO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wLmZvckVhY2goKHQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5UeHRFbGVtLmluZXJzZXRBdChpZHggKyAxICsgaSwgdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjYXJldC5zZXRSb3coX3Jvdyk7XG4gICAgICAgICAgICAgICAgICAgIGNhcmV0LnNldENvbHVtbihbMCwgY29sXSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmVDb250ZW50ICs9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGNhcmV0LnNldENvbHVtbigxLCBjYXJldC5nZXRDb2x1bW4oMSkgKyBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0U291cmNlV2l0aFJlY29yZChwcmVDb250ZW50ICsgYWZ0ZXJDb250ZW50LCBlZGl0b3Iuc3BhY2VIb2xkZXIsIHJlY29yZHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfSU5QVVQuQ09NUE9TSVRJT05fU1RBUlQ6XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZUlkeCA9IFtwcmVDb250ZW50Lmxlbmd0aCwgcHJlQ29udGVudC5sZW5ndGhdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9JTlBVVC5DT01QT1NJVElPTl9VUERBVEU6XG4gICAgICAgICAgICAgICAgcHJlQ29udGVudCA9IHByZUNvbnRlbnQuc3Vic3RyaW5nKDAsIHRoaXMuY2FjaGVJZHhbMF0pO1xuICAgICAgICAgICAgICAgIHByZUNvbnRlbnQgKz0gZGF0YTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNldFNvdXJjZVdpdGhSZWNvcmQocHJlQ29udGVudCArIGFmdGVyQ29udGVudCwgZWRpdG9yLnNwYWNlSG9sZGVyLCByZWNvcmRzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBfdCA9IHRoaXMuY2FjaGVJZHhbMF0gKyBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjYXJldC5zZXRDb2x1bW4oMSwgX3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVJZHhbMV0gPSBfdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfSU5QVVQuQ09NUE9TSVRJT05fRU5EOlxuICAgICAgICAgICAgICAgIHByZUNvbnRlbnQgPSBwcmVDb250ZW50LnN1YnN0cmluZygwLCB0aGlzLmNhY2hlSWR4WzBdKTtcbiAgICAgICAgICAgICAgICBjYXJldC5zZXRDb2x1bW4oMSwgdGhpcy5jYWNoZUlkeFswXSArIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlSWR4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwcmVDb250ZW50ICs9IGRhdGE7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRTb3VyY2VXaXRoUmVjb3JkKHByZUNvbnRlbnQgKyBhZnRlckNvbnRlbnQsIGVkaXRvci5zcGFjZUhvbGRlciwgcmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0lOUFVULkVOVEVSOlxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3ROZWVkV3JhcCA9IGVsZW1lbnQubmVlZFdyYXA7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRTb3VyY2VXaXRoUmVjb3JkKHByZUNvbnRlbnQsIGVkaXRvci5zcGFjZUhvbGRlciwgcmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXROZWVkV3JhcCh0cnVlLCByZWNvcmRzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gbmV3IFRleHRFbGVtZW50KCd0ZXh0JywgYWZ0ZXJDb250ZW50KTtcbiAgICAgICAgICAgICAgICBmbGF0dGVuVHh0RWxlbS5pbnNlcnRBZnRlcihlbGVtZW50LCB0LCBsYXN0TmVlZFdyYXApO1xuICAgICAgICAgICAgICAgIGNhcmV0LnNldFJvdyhyb3crMSk7XG4gICAgICAgICAgICAgICAgY2FyZXQuc2V0Q29sdW1uKFswLCAwXSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9JTlBVVC5CQUNLU1BBQ0U6XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZWxlbWVudC5zaGlmdChvZmZzZXQsIC0xKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2gocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3ByZXYnOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlkeCA9IGZsYXR0ZW5UeHRFbGVtLmZpbmRJbmRleChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGVsZW1faWR4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOihjOWGhVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5UeHRFbGVtLnNwbGljZShpZHgtMSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4IC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxlbWVudC5zZXRTb3VyY2UoYWZ0ZXJDb250ZW50LCByZWNvcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50LmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbb2Zmc2V0LCBkZWxldGVvcF0gPSBfYmxhbmRBZGphY2VudEVsZW1lbnQoZWRpdG9yLCBmbGF0dGVuVHh0RWxlbS5nZXQoaWR4LTEpLCBlbGVtZW50LCAwLCByZWNvcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihkZWxldGVvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGF0dGVuVHh0RWxlbS5yZW1vdmUoaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXQuc2V0Q29sdW1uKFtlbGVtX2lkeCAtICgob2Zmc2V0ID4gMCB8fCBkZWxldGVvcCk/MjoxKSwgb2Zmc2V0XSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihpZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g5o2i6KGM5LqGXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlUm93ID0gcm93IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVFbGVtaWR4ID0gYXJlYS5nZXQocHJlUm93KS5sZW5ndGgoKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW29mZnNldCwgZGVsZXRlb3BdID0gX2JsYW5kQWRqYWNlbnRFbGVtZW50KGVkaXRvciwgZmxhdHRlblR4dEVsZW0uZ2V0KGlkeC0xKSwgZWxlbWVudCwgMCwgcmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGVsZXRlb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhdHRlblR4dEVsZW0ucmVtb3ZlKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0LnNldFJvdyhwcmVSb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0LnNldENvbHVtbihbcHJlRWxlbWlkeCwgb2Zmc2V0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2VsZic6XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVDb250ZW50ID0gcHJlQ29udGVudC5zdWJzdHJpbmcoMCwgcHJlQ29udGVudC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0LnNldENvbHVtbigxLCBjYXJldC5nZXRDb2x1bW4oMSktMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0U291cmNlV2l0aFJlY29yZChwcmVDb250ZW50ICsgYWZ0ZXJDb250ZW50LCBlZGl0b3Iuc3BhY2VIb2xkZXIsIHJlY29yZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9JTlBVVC5ERUxFVEU6XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hpZnRyZXN1bHQgPSBlbGVtZW50LnNoaWZ0KG9mZnNldCwgMSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoKHNoaWZ0cmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ25leHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlkeCA9IGZsYXR0ZW5UeHRFbGVtLmZpbmRJbmRleChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGVsZW1faWR4IDwgbGluZS5sZW5ndGgoKS0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g6KGM5YaFXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhdHRlblR4dEVsZW0uc3BsaWNlKGlkeCsxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0RWxlbSA9IGZsYXR0ZW5UeHRFbGVtLmdldChpZHgrMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW29mZnNldCwgZGVsZXRlb3BdID0gX2JsYW5kQWRqYWNlbnRFbGVtZW50KGVsZW1lbnQsIG5leHRFbGVtLCBlbGVtZW50LnNvdXJjZS5sZW5ndGgsIHJlY29yZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRlbGV0ZW9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5UeHRFbGVtLnJlbW92ZShpZHgrMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0LnNldENvbHVtbihbZWxlbV9pZHgsIG9mZnNldF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoaWR4IDwgZmxhdHRlblR4dEVsZW0ubGVuZ3RoKCktMSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g5o2i6KGM5LqGXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dEVsZW0gPSBmbGF0dGVuVHh0RWxlbS5nZXQoaWR4KzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtvZmZzZXQsIGRlbGV0ZW9wXSA9IF9ibGFuZEFkamFjZW50RWxlbWVudChlbGVtZW50LCBuZXh0RWxlbSwgZWxlbWVudC5zb3VyY2UubGVuZ3RoLCByZWNvcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihkZWxldGVvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGF0dGVuVHh0RWxlbS5yZW1vdmUoaWR4KzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldC5zZXRDb2x1bW4oW2VsZW1faWR4LCBvZmZzZXRdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlbGYnOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJDb250ZW50ID0gYWZ0ZXJDb250ZW50LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0U291cmNlV2l0aFJlY29yZChwcmVDb250ZW50ICsgYWZ0ZXJDb250ZW50LCBlZGl0b3Iuc3BhY2VIb2xkZXIsIHJlY29yZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZmxhdHRlblR4dEVsZW0uY29sbGVjdFJlY29yZHMoKTtcbiAgICAgICAgZmxhdHRlblR4dEVsZW0ucmVjb3JkQWZ0ZXJDYXJldChjYXJldCk7XG4gICAgICAgIHVuZG9yZWRvLndyaXRlKHJlY29yZHMsIGZsYXR0ZW5UeHRFbGVtLmdldENhcmV0UmVjb3JkKCkpO1xuICAgICAgICB0aGlzLl9lZGl0b3IucmVmcmVzaCgpO1xuICAgIH1cblxuICAgIFxufSIsImltcG9ydCBDb21tYW5kIGZyb20gJy4vYmFzZSc7XG5cbmltcG9ydCB7IE1PVVNFX0NPTU1BTkRTIH0gZnJvbSAnLi4vYmFzZS9jb25zdGFudHMnO1xuaW1wb3J0IEpGbG93RXZlbnQgZnJvbSAnLi4vLi4vLi4vZXZlbnRzL2luZGV4JztcblxuZXhwb3J0IGNsYXNzIFN0YXJ0RWRpdENvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgICBzdGF0aWMgX25hbWUgPSBNT1VTRV9DT01NQU5EUy5TVEFSVF9FRElUO1xuXG4gICAgZXhlYygpIHtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5fZWRpdG9yO1xuICAgICAgICBpZighdGhpcy5fc3RhcnRFZGl0KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBqZmxvdyA9IGVkaXRvci5famZsb3c7XG4gICAgICAgIGVkaXRvci5tb3ZlQ2FyZXRCeUhpdFBvaW50KCk7XG4gICAgICAgIGVkaXRvci5jcmVhdGVTaGFkb3dJbnB1dCgpO1xuICAgICAgICBlZGl0b3IuX2NhcmV0LmFuaW1hdGUoamZsb3cpO1xuICAgICAgICBlZGl0b3Iuc3luY1NoYWRvd0lucHV0UG9zaXRpb24oKTtcbiAgICB9XG5cbiAgICBfc3RhcnRFZGl0KCkge1xuICAgICAgICBsZXQgZmxhZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuX2VkaXRvcjtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2VkaXQnLCB7XG4gICAgICAgICAgICB0YXJnZXQ6IGVkaXRvcixcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpIFxuICAgICAgICByZXR1cm4gZmxhZzsgXG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEVkaXRDbGlja0NvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgICBzdGF0aWMgX25hbWUgPSBNT1VTRV9DT01NQU5EUy5FRElUX0NMSUNLO1xuXG4gICAgZXhlYygpIHtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5fZWRpdG9yO1xuICAgICAgICBlZGl0b3IubW92ZUNhcmV0QnlIaXRQb2ludCgpO1xuICAgICAgICBlZGl0b3IuX2NhcmV0LnJlZnJlc2goKTtcbiAgICAgICAgZWRpdG9yLnN5bmNTaGFkb3dJbnB1dFBvc2l0aW9uKCk7XG4gICAgICAgIGVkaXRvci5fcmFuZ2UuZGlzYWJsZSgpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIERvdWJsZUNsaWNrQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICAgIHN0YXRpYyBfbmFtZSA9IE1PVVNFX0NPTU1BTkRTLkRPVUJMRV9DTElDSztcblxuICAgIGV4ZWMoKSB7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuX2VkaXRvcjtcbiAgICAgICAgZWRpdG9yLm1vdmVDYXJldEJ5SGl0UG9pbnQoKTtcbiAgICAgICAgY29uc3QgY2FyZXQgPSBlZGl0b3IuX2NhcmV0O1xuICAgICAgICBjb25zdCByYW5nZSA9IGVkaXRvci5fcmFuZ2U7XG4gICAgICAgIGNvbnN0IGFyZWEgPSBlZGl0b3IuX2FyZWE7XG4gICAgICAgIGNvbnN0IHJvdyA9IGNhcmV0LmdldFJvdygpO1xuICAgICAgICBjb25zdCBsaW5lID0gYXJlYS5nZXQocm93KTtcbiAgICAgICAgY29uc3QgZWxlbV9pZHggPSBsaW5lLmxlbmd0aCgpIC0gMTtcbiAgICAgICAgcmFuZ2Uuc2V0SW5pdGlhbFJhbmdlKFtyb3csIDAsIDBdKTtcbiAgICAgICAgcmFuZ2Uuc2V0UmFuZ2UoW1xuICAgICAgICAgICAgcm93LCBlbGVtX2lkeCwgbGluZS50YWlsKCkudGFpbE9mZnNldCgpXG4gICAgICAgIF0pO1xuICAgICAgICByYW5nZS5oYW5kbGVDYXJldChjYXJldCk7XG4gICAgICAgIHJhbmdlLmVuYWJsZSgpO1xuICAgICAgICBlZGl0b3Iuc3luY1NoYWRvd0lucHV0UG9zaXRpb24oKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQ29tbWFuZCBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHsgS0VZQk9BUkRfQ09NTUFORFMsIE1PVVNFX0NPTU1BTkRTIH0gZnJvbSAnLi4vYmFzZS9jb25zdGFudHMnO1xuXG5leHBvcnQgY2xhc3MgU2hpZnRVcENvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgICBzdGF0aWMgX25hbWUgPSBLRVlCT0FSRF9DT01NQU5EUy5TSElGVF9VUDtcbiAgICBleGVjKCkge1xuICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMuX2VkaXRvci5fcmFuZ2U7XG4gICAgICAgIHJhbmdlLnNldEluaXRpYWxSYW5nZShudWxsKTtcbiAgICAgICAgdGhpcy5fZWRpdG9yLnRvZ2dsZVNoaWZ0KGZhbHNlKVxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNoaWZ0RG93bkNvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgICBzdGF0aWMgX25hbWUgPSBLRVlCT0FSRF9DT01NQU5EUy5TSElGVF9ET1dOO1xuICAgIFxuICAgIGV4ZWMoKSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5fZWRpdG9yLl9yYW5nZTtcbiAgICAgICAgY29uc3QgY2FyZXQgPSB0aGlzLl9lZGl0b3IuX2NhcmV0O1xuICAgICAgICByYW5nZS5zZXRJbml0aWFsUmFuZ2UoY2FyZXQudG9SYW5nZSgpKTtcbiAgICAgICAgdGhpcy5fZWRpdG9yLnRvZ2dsZVNoaWZ0KHRydWUpXG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2hpZnRPbkNsaWNrQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICAgIHN0YXRpYyBfbmFtZSA9IE1PVVNFX0NPTU1BTkRTLlNISUZUX09OX0NMSUNLO1xuXG4gICAgZXhlYygpIHtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5fZWRpdG9yO1xuICAgICAgICBlZGl0b3IubW92ZUNhcmV0QnlIaXRQb2ludCgpO1xuICAgICAgICBjb25zdCBjYXJldCA9IHRoaXMuX2VkaXRvci5fY2FyZXQ7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5fZWRpdG9yLl9yYW5nZTtcbiAgICAgICAgcmFuZ2Uuc2V0UmFuZ2UoY2FyZXQudG9SYW5nZSgpKTtcbiAgICAgICAgcmFuZ2UuZW5hYmxlKCk7XG4gICAgICAgIHJhbmdlLmhhbmRsZUNhcmV0KGNhcmV0KTtcbiAgICAgICAgY2FyZXQucmVmcmVzaCgpO1xuICAgICAgICBlZGl0b3Iuc3luY1NoYWRvd0lucHV0UG9zaXRpb24oKTtcbiAgICB9XG59IiwiaW1wb3J0IENvbW1hbmQgZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7IEtFWUJPQVJEX0NPTU1BTkRTIH0gZnJvbSAnLi4vYmFzZS9jb25zdGFudHMnO1xuXG5leHBvcnQgY2xhc3MgQ3RybEFDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gICAgc3RhdGljIF9uYW1lID0gS0VZQk9BUkRfQ09NTUFORFMuQ1RSTEE7XG4gICAgZXhlYygpIHtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5fZWRpdG9yO1xuICAgICAgICBjb25zdCBjYXJldCA9IGVkaXRvci5fY2FyZXQ7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gZWRpdG9yLl9yYW5nZTtcbiAgICAgICAgY29uc3QgYXJlYSA9IGVkaXRvci5fYXJlYTtcbiAgICAgICAgY29uc3Qgcm93ID0gYXJlYS5sZW5ndGgoKSAtIDE7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBhcmVhLmdldChyb3cpO1xuICAgICAgICBjb25zdCBlbGVtX2lkeCA9IGxpbmUubGVuZ3RoKCkgLSAxO1xuICAgICAgICByYW5nZS5zZXRJbml0aWFsUmFuZ2UoWzAsIDAsIDBdKTtcbiAgICAgICAgcmFuZ2Uuc2V0UmFuZ2UoW1xuICAgICAgICAgICAgcm93LCBlbGVtX2lkeCwgbGluZS50YWlsKCkudGFpbE9mZnNldCgpXG4gICAgICAgIF0pO1xuICAgICAgICByYW5nZS5oYW5kbGVDYXJldChjYXJldCk7XG4gICAgICAgIHJhbmdlLmVuYWJsZSgpO1xuICAgICAgICBlZGl0b3Iuc3luY1NoYWRvd0lucHV0UG9zaXRpb24oKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQ29tbWFuZCBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHsgS0VZQk9BUkRfQ09NTUFORFMgfSBmcm9tICcuLi9iYXNlL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBjbGFzcyBVbmRvQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICAgIHN0YXRpYyBfbmFtZSA9IEtFWUJPQVJEX0NPTU1BTkRTLlVORE87XG4gICAgZXhlYygpIHtcbiAgICAgICAgdGhpcy5fZWRpdG9yLl9yYW5nZS5kaXNhYmxlKClcbiAgICAgICAgdGhpcy5fZWRpdG9yLl91bmRvcmVkby51bmRvKCk7XG4gICAgICAgIHRoaXMuX2VkaXRvci5yZWZyZXNoKCk7XG5cbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSZWRvQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICAgIHN0YXRpYyBfbmFtZSA9IEtFWUJPQVJEX0NPTU1BTkRTLlJFRE87XG4gICAgZXhlYygpIHtcbiAgICAgICAgdGhpcy5fZWRpdG9yLl9yYW5nZS5kaXNhYmxlKClcbiAgICAgICAgdGhpcy5fZWRpdG9yLl91bmRvcmVkby5yZWRvKCk7XG4gICAgICAgIHRoaXMuX2VkaXRvci5yZWZyZXNoKCk7XG4gICAgfVxufSIsImltcG9ydCBDb21tYW5kIGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgeyBLRVlCT0FSRF9DT01NQU5EUywgRURJVE9SX0VWRU5UUywgS0VZQk9BUkRfSU5QVVQgfSBmcm9tICcuLi9iYXNlL2NvbnN0YW50cyc7XG5pbXBvcnQgSkZsb3dFdmVudCBmcm9tICcuLi8uLi8uLi9ldmVudHMnO1xuZXhwb3J0IGNsYXNzIENvcHlDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gICAgc3RhdGljIF9uYW1lID0gS0VZQk9BUkRfQ09NTUFORFMuQ09QWTtcbiAgICBleGVjKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuX2VkaXRvcjtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBlZGl0b3IuX3JhbmdlO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gcmFuZ2UuZ2V0UmFuZ2VDb3B5KGVkaXRvcik7XG4gICAgICAgIGlmKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LmNsaXBib2FyZERhdGEuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDdXRDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gICAgc3RhdGljIF9uYW1lID0gS0VZQk9BUkRfQ09NTUFORFMuQ1VUO1xuICAgIGV4ZWMoZXZlbnQpIHsgICBcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5fZWRpdG9yO1xuICAgICAgICBjb25zdCByYW5nZSA9IGVkaXRvci5fcmFuZ2U7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSByYW5nZS5nZXRSYW5nZUNvcHkoZWRpdG9yKTtcbiAgICAgICAgaWYoY29udGVudCkge1xuICAgICAgICAgICAgZXZlbnQuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZihyYW5nZS5pc0VuYWJsZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBjbWQgPSBlZGl0b3IuY29tbWFuZHMuZ2V0KEVESVRPUl9FVkVOVFMuSU5QVVQpO1xuICAgICAgICAgICAgY21kLmV4ZWMoS0VZQk9BUkRfSU5QVVQuQkFDS1NQQUNFKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFBhc3RlQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICAgIHN0YXRpYyBfbmFtZSA9IEtFWUJPQVJEX0NPTU1BTkRTLlBBU1RFO1xuICAgIGV4ZWMocGFzdGVDb250ZW50KSB7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuX2VkaXRvcjtcbiAgICAgICAgaWYocGFzdGVDb250ZW50KSB7XG4gICAgICAgICAgICBsZXQgX3ByZXZlbnREZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgncGFzdGUnLCB7XG4gICAgICAgICAgICAgICAgY29udGVudDogcGFzdGVDb250ZW50LFxuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIF9wcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYoIV9wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNtZCA9IGVkaXRvci5jb21tYW5kcy5nZXQoRURJVE9SX0VWRU5UUy5JTlBVVCk7XG4gICAgICAgICAgICAgICAgY21kLmV4ZWMoS0VZQk9BUkRfSU5QVVQuSU5QVVQsIHBhc3RlQ29udGVudCk7ICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4iLCJleHBvcnQge1xuICAgIEFycm93TGVmdENvbW1hbmQsIFxuICAgIEFycm93UmlnaHRDb21tYW5kLFxuICAgIEFycm93VXBDb21tYW5kLFxuICAgIEFycm93RG93bkNvbW1hbmRcbn0gZnJvbSAnLi9tb3ZlbWVudCc7XG5leHBvcnQgeyBJbnB1dCB9IGZyb20gJy4vaW5wdXQnO1xuZXhwb3J0IHsgXG4gICAgU3RhcnRFZGl0Q29tbWFuZCxcbiAgICBFZGl0Q2xpY2tDb21tYW5kLFxuICAgIERvdWJsZUNsaWNrQ29tbWFuZCxcbn0gZnJvbSAnLi9tb3VzZSdcbmV4cG9ydCB7XG4gICAgU2hpZnREb3duQ29tbWFuZCxcbiAgICBTaGlmdFVwQ29tbWFuZCxcbiAgICBTaGlmdE9uQ2xpY2tDb21tYW5kXG59IGZyb20gJy4vc2hpZnQnO1xuXG5leHBvcnQge1xuICAgIEN0cmxBQ29tbWFuZFxufSBmcm9tICcuL2N0cmwnO1xuXG5leHBvcnQgIHtcbiAgICBVbmRvQ29tbWFuZCxcbiAgICBSZWRvQ29tbWFuZFxufSBmcm9tICcuL3VuZG9yZWRvJztcblxuXG5leHBvcnQge1xuICAgIENvcHlDb21tYW5kLFxuICAgIFBhc3RlQ29tbWFuZCxcbiAgICBDdXRDb21tYW5kLFxufSBmcm9tICcuL2NsaXBib2FyZCciLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9ub2RlJztcbmltcG9ydCBTdGFja01peGluIGZyb20gJy4uL3N0YWNrTWl4aW4nO1xuaW1wb3J0IExheW91dE1peGluIGZyb20gJy4uL2xheW91dE1peGluJztcbmltcG9ydCBKRmxvd0V2ZW50IGZyb20gJy4uLy4uL2V2ZW50cy9pbmRleCc7XG5pbXBvcnQgeyByZXF1ZXN0Q2FjaGVDYW52YXMgfSBmcm9tICcuLi8uLi91dGlscy9jYW52YXMnO1xuaW1wb3J0IFNoYWRvd0NhY2hlIGZyb20gJy4uL3NoYXBlcy9zaGFkb3ctY2FjaGUnO1xuaW1wb3J0IFNoYWRvd0lucHV0IGZyb20gJy4vYmFzZS9zaGFkb3ctaW5wdXQnO1xuXG5pbXBvcnQgQ2FyZXQgZnJvbSAnLi9iYXNlL2NhcmV0JztcbmltcG9ydCBSYW5nZSBmcm9tICcuL2Jhc2UvcmFuZ2UnO1xuaW1wb3J0IFVuZG9SZWRvIGZyb20gJy4vdW5kb3JlZG8nO1xuaW1wb3J0IHtcbiAgICBBcmVhLFxuICAgIEZsYXR0ZW5UZXh0RWxlbWVudHMsXG4gICAgTGluZSxcbiAgICBUZXh0RWxlbWVudFxufSBmcm9tICcuL3N0b3JhZ2UnO1xuXG5pbXBvcnQgeyBcbiAgICBJbnB1dCxcbiAgICBBcnJvd0xlZnRDb21tYW5kLFxuICAgIEFycm93UmlnaHRDb21tYW5kLFxuICAgIEFycm93VXBDb21tYW5kLFxuICAgIEFycm93RG93bkNvbW1hbmQsXG4gICAgU3RhcnRFZGl0Q29tbWFuZCxcbiAgICBTaGlmdERvd25Db21tYW5kLFxuICAgIFNoaWZ0VXBDb21tYW5kLFxuICAgIFNoaWZ0T25DbGlja0NvbW1hbmQsXG4gICAgRWRpdENsaWNrQ29tbWFuZCxcbiAgICBDdHJsQUNvbW1hbmQsXG4gICAgRG91YmxlQ2xpY2tDb21tYW5kLFxuICAgIC8vIFJldHVybkNvbW1hbmQsXG4gICAgLy8gRGVsZXRlQ29tbWFuZCxcbiAgICBVbmRvQ29tbWFuZCxcbiAgICBSZWRvQ29tbWFuZCxcbiAgICBDb3B5Q29tbWFuZCxcbiAgICBQYXN0ZUNvbW1hbmQsXG4gICAgQ3V0Q29tbWFuZCxcbn0gZnJvbSAnLi9jb21tYW5kJ1xuaW1wb3J0IHsgRURJVE9SX0VWRU5UUywgS0VZQk9BUkRfQ09NTUFORFMsIE1PVVNFX0NPTU1BTkRTIH0gZnJvbSAnLi9iYXNlL2NvbnN0YW50cyc7XG5cbmNsYXNzIFRleHRHcm91cCBleHRlbmRzIE5vZGUge1xuXG4gICAgZ2V0IGN1cnJlbnRMaW5lSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lSGVpZ2h0IHx8IHBhcnNlSW50KHRoaXMuZm9udFNpemUpO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3MpIHtcbiAgICAgICAgc3VwZXIoY29uZmlncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdUZXh0R3JvdXAnO1xuICAgICAgICB0aGlzLmluaXRTdGFjayhjb25maWdzKTtcbiAgICAgICAgdGhpcy5pbml0TGF5b3V0KGNvbmZpZ3MpO1xuXG4gICAgICAgIHRoaXMuX3VuZG9yZWRvID0gbmV3IFVuZG9SZWRvKCk7XG4gICAgICAgIHRoaXMuX3VuZG9yZWRvLl9lZGl0b3IgPSB0aGlzO1xuICAgICAgICB0aGlzLl9jYXJldCA9IG5ldyBDYXJldCgpO1xuICAgICAgICB0aGlzLl9yYW5nZSA9IG5ldyBSYW5nZSgpO1xuICAgICAgICB0aGlzLl9zaGFkb3dJbnB1dCA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0aGlzLnRleHRDb2xvciA9IGNvbmZpZ3MudGV4dENvbG9yIHx8ICd0cmFuc3BhcmVudCc7XG4gICAgICAgIHRoaXMuZm9udEZhbWlseSA9IGNvbmZpZ3MuZm9udEZhbWlseSB8fCAnLWFwcGxlLXN5c3RlbSxCbGlua01hY1N5c3RlbUZvbnQsU2Vnb2UgVUksUm9ib3RvLEhlbHZldGljYSBOZXVlLEhlbHZldGljYSxUYWhvbWEsQXJpYWwsTm90byBTYW5zLFBpbmdGYW5nIFNDLE1pY3Jvc29mdCBZYUhlaSxIaXJhZ2lubyBTYW5zIEdCLHNhbnMtc2VyaWYsQXBwbGUgQ29sb3IgRW1vamksU2Vnb2UgVUkgRW1vamksU2Vnb2UgVUkgU3ltYm9sLE5vdG8gQ29sb3IgRW1vamknXG4gICAgICAgIHRoaXMuZm9udFNpemUgPSBjb25maWdzLmZvbnRTaXplIHx8ICcyOHB4JztcbiAgICAgICAgdGhpcy5mb250V2VpZ2h0ID0gY29uZmlncy5mb250V2VpZ2h0IHx8ICcnO1xuICAgICAgICB0aGlzLmVsZW1lbnRTcGFjZSA9IGNvbmZpZ3MuZWxlbWVudFNwYWNlIHx8IDU7XG4gICAgICAgIHRoaXMubGluZVNwYWNlID0gY29uZmlncy5saW5lU3BhY2UgfHwgNTtcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IGNvbmZpZ3MucGxhY2Vob2xkZXIgfHwgJ+ivt+i+k+WFpSc7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJDb2xvciA9IGNvbmZpZ3MucGxhY2Vob2xkZXJDb2xvciB8fCAnI2VlZSc7XG4gICAgICAgIHRoaXMuY3Vyc29yQ29sb3IgPSBjb25maWdzLmN1cnNvckNvbG9yIHx8ICcjNjBDRkM0JztcbiAgICAgICAgdGhpcy50ZXh0UmFuZ2VDb2xvciA9IGNvbmZpZ3MudGV4dFJhbmdlQ29sb3IgfHwgJyM0RTc1RUMxQSc7XG4gICAgICAgIHRoaXMubWluV2lkdGggPSBjb25maWdzLm1pbldpZHRoIHx8IDA7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnNwYWNlSG9sZGVyID0ge1xuICAgICAgICAgICAgZW5hYmxlOiBmYWxzZSxcbiAgICAgICAgfVxuICAgICAgICBpZihjb25maWdzLnNwYWNlUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5zcGFjZUhvbGRlciwge1xuICAgICAgICAgICAgICAgIGVuYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzcGFjZVBsYWNlaG9sZGVyOiBjb25maWdzLnNwYWNlUGxhY2Vob2xkZXIsXG4gICAgICAgICAgICAgICAgc3BhY2VQbGFjZWhvbGRlckNvbG9yOiBjb25maWdzLnNwYWNlUGxhY2Vob2xkZXJDb2xvcixcbiAgICAgICAgICAgICAgICByZXR1cm5Gb250OiBjb25maWdzLnJldHVybkZvbnQsXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIFxuXG5cbiAgICAgICAgdGhpcy5yZXNvbHZlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gY29uZmlncy5yZXNvbHZlcigpO1xuICAgICAgICAgICAgaWYoZWxlbWVudHMubGVuZ3RoID09PSAwIHx8IGVsZW1lbnRzW2VsZW1lbnRzLmxlbmd0aC0xXS50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG5ldyBUZXh0RWxlbWVudCgndGV4dCcsICcnKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgICAgIGlmKGVsLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBlbC5zZXRTb3VyY2UoZWwuc291cmNlLCB0aGlzLnNwYWNlSG9sZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhpcy5fbGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fYXJlYSA9IG5ldyBBcmVhKCk7XG4gICAgICAgIHRoaXMuX2ZsYXR0ZW5UeHRFbGVtID0gRmxhdHRlblRleHRFbGVtZW50cy5jcmVhdGUodGhpcy5yZXNvbHZlcigpKTsgXG4gICAgICAgIHRoaXMuX3N0YXR1cyA9IHtcbiAgICAgICAgICAgIGVkaXRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgZHJhZ292ZXI6IGZhbHNlLFxuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbW1hbmRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJlZ2lzdENvbW1hbmQoU3RhcnRFZGl0Q29tbWFuZCk7XG4gICAgICAgIHRoaXMucmVnaXN0Q29tbWFuZChFZGl0Q2xpY2tDb21tYW5kKTtcbiAgICAgICAgdGhpcy5yZWdpc3RDb21tYW5kKFNoaWZ0VXBDb21tYW5kKTtcbiAgICAgICAgdGhpcy5yZWdpc3RDb21tYW5kKFNoaWZ0RG93bkNvbW1hbmQpO1xuICAgICAgICB0aGlzLnJlZ2lzdENvbW1hbmQoU2hpZnRPbkNsaWNrQ29tbWFuZCk7XG4gICAgICAgIHRoaXMucmVnaXN0Q29tbWFuZChJbnB1dCk7XG4gICAgICAgIHRoaXMucmVnaXN0Q29tbWFuZChBcnJvd0xlZnRDb21tYW5kKTtcbiAgICAgICAgdGhpcy5yZWdpc3RDb21tYW5kKEFycm93UmlnaHRDb21tYW5kKTtcbiAgICAgICAgdGhpcy5yZWdpc3RDb21tYW5kKEFycm93VXBDb21tYW5kKTtcbiAgICAgICAgdGhpcy5yZWdpc3RDb21tYW5kKEFycm93RG93bkNvbW1hbmQpO1xuICAgICAgICB0aGlzLnJlZ2lzdENvbW1hbmQoQ3RybEFDb21tYW5kKTtcbiAgICAgICAgdGhpcy5yZWdpc3RDb21tYW5kKERvdWJsZUNsaWNrQ29tbWFuZCk7XG4gICAgICAgIC8vIHRoaXMucmVnaXN0Q29tbWFuZChSZXR1cm5Db21tYW5kKTtcbiAgICAgICAgLy8gdGhpcy5yZWdpc3RDb21tYW5kKERlbGV0ZUNvbW1hbmQpO1xuICAgICAgICB0aGlzLnJlZ2lzdENvbW1hbmQoVW5kb0NvbW1hbmQpO1xuICAgICAgICB0aGlzLnJlZ2lzdENvbW1hbmQoUmVkb0NvbW1hbmQpO1xuICAgICAgICB0aGlzLnJlZ2lzdENvbW1hbmQoQ29weUNvbW1hbmQpO1xuICAgICAgICB0aGlzLnJlZ2lzdENvbW1hbmQoQ3V0Q29tbWFuZCk7XG4gICAgICAgIHRoaXMucmVnaXN0Q29tbWFuZChQYXN0ZUNvbW1hbmQpO1xuICAgICAgICB0aGlzLl9tYWtlRnVuY3Rpb25hbCgpO1xuXG4gICAgICAgIHRoaXMuX2NhY2hlVmlld0JveCA9IFtdO1xuICAgIH1cblxuICAgIHJlZ2lzdENvbW1hbmQoY21kKSB7XG4gICAgICAgIGlmKCF0aGlzLmNvbW1hbmRzLmhhcyhjbWQuX25hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRzLnNldChjbWQuX25hbWUsIGNtZC5jcmVhdGUodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX21ha2VGdW5jdGlvbmFsKCkge1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZihldmVudC5jdXJyZW50VGFyZ2V0ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC5kZXRhaWwuYnViYmxlcyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYodGhpcy5fc3RhdHVzLmVkaXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4ZWNDb21tYW5kKE1PVVNFX0NPTU1BTkRTLkRPVUJMRV9DTElDSylcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZihldmVudC5jdXJyZW50VGFyZ2V0ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC5kZXRhaWwuYnViYmxlcyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGNvbW1uZDtcbiAgICAgICAgICAgIGlmKHRoaXMuX3N0YXR1cy5lZGl0aW5nKSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5fc3RhdHVzLnNoaWZ0T24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbW5kID0gTU9VU0VfQ09NTUFORFMuU0hJRlRfT05fQ0xJQ0tcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21tbmQgPSBNT1VTRV9DT01NQU5EUy5FRElUX0NMSUNLXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21tbmQgPSBNT1VTRV9DT01NQU5EUy5TVEFSVF9FRElUXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmV4ZWNDb21tYW5kKGNvbW1uZClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMuZWRpdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYodGhpcy5fc2hhZG93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9zaGFkb3dJbnB1dC5yZWxlYXNlRXZlbnRMaXN0ZW5yKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hhZG93SW5wdXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWRvd0lucHV0ID0gdW5kZWZpbmVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLl9iZWxvbmdzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5famZsb3cuX3JlbmRlcigpO1xuICAgICAgICAgICAgfSBcblxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdjaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICAgIHRleHRFbGVtZW50czogdGhpcy5fZmxhdHRlblR4dEVsZW0uY29weSgpLFxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICB0aGlzLl9yYW5nZS5kaXNhYmxlKCk7XG4gICAgICAgICAgICB0aGlzLl9jYXJldC5jYW5jZWxBbmltYXRlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignaW5zdGFuY2VQcmVzc1N0YXJ0JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZih0aGlzLl9zdGF0dXMuZWRpdGluZyAmJiAhdGhpcy5fc3RhdHVzLnNoaWZ0T24pIHtcbiAgICAgICAgICAgICAgICBldmVudC5kZXRhaWwuYnViYmxlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGV2ZW50LmRldGFpbC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIC8vIGV2ZW50LmRldGFpbC5qZmxvdy5zZXRNb3ZpbmdUYXJnZXRzKG51bGwpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy5fY3VycmVudHA7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IHRoaXMuX3Bvc2l0aW9uVG9DdXJzb3JPZmZzZXQocG9pbnQpO1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuX2N1cnNvciA9IGM7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGlzLl9yYW5nZTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZXRJbml0aWFsUmFuZ2UoW2Mucm93LCAuLi5jLmNvbHVtbl0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGpmbG93ID0gZXZlbnQuZGV0YWlsLmpmbG93O1xuICAgICAgICAgICAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSAoZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5lZGl0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gamZsb3cuX2NhbGN1bGF0ZVBvaW50QmFjayhbb2Zmc2V0WCwgb2Zmc2V0WV0pO1xuICAgICAgICAgICAgICAgICAgICBqZmxvdy5fc3RhY2suY2hlY2tIaXQocClcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLl9jdXJyZW50cDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYyA9IHRoaXMuX3Bvc2l0aW9uVG9DdXJzb3JPZmZzZXQocG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLl9jdXJzb3IgPSBjO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRSYW5nZShbYy5yb3csIC4uLmMuY29sdW1uXSk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgIH0pLmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHQpXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0SW5pdGlhbFJhbmdlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBpZighbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByYW5nZS5oYW5kbGVDYXJldCh0aGlzLl9jYXJldClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzLmVkaXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaGFkb3dJbnB1dC5mb2N1cygpOyAgIFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdlbnRlcicsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubW92ZUNhcmV0QnlIaXRQb2ludCgpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdHVzLmRyYWdvdmVyID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1vdmVDYXJldEJ5SGl0UG9pbnQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2xlYXZlJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc3RhdHVzLmRyYWdvdmVyID0gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG9uRHJvcCA9ICgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmKCF0aGlzLl9zdGF0dXMuZHJhZ292ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC5kZXRhaWwuYnViYmxlcyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fc3RhdHVzLmRyYWdvdmVyID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBjYXJldCA9IHRoaXMuX2NhcmV0O1xuICAgICAgICAgICAgY29uc3Qgcm93ID0gY2FyZXQuZ2V0Um93KCk7XG4gICAgICAgICAgICBjb25zdCBjb2x1bW4gPSBjYXJldC5nZXRDb2x1bW4oKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSB0aGlzLl9hcmVhLmdldChyb3cpO1xuICAgICAgICAgICAgbGV0IFtlbGVtaWR4LCBvZmZzZXRdID0gY29sdW1uO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGxpbmUuZ2V0KGVsZW1pZHgpO1xuICAgICAgICAgICAgY29uc3QgcHJlRWxlbSA9IGxpbmUuZ2V0KGVsZW1pZHgtMSk7XG4gICAgICAgICAgICBsZXQgZmxhdHRlblR4dEVsZW0gPSB0aGlzLl9mbGF0dGVuVHh0RWxlbTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGV0IGlkeCA9IGZsYXR0ZW5UeHRFbGVtLmZpbmRJbmRleChlbGVtZW50KVxuICAgICAgICAgICAgaWYoZWxlbWVudC50eXBlICE9PSAndGV4dCcgJiYgcHJlRWxlbT8udHlwZSA9PT0ndGV4dCcpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBwcmVFbGVtLnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWR4ID0gZmxhdHRlblR4dEVsZW0uZmluZEluZGV4KHByZUVsZW0pICAgXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGxhc3RMZW5ndGggPSBmbGF0dGVuVHh0RWxlbS5sZW5ndGgoKVxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdpbnNlcnQnLCB7XG4gICAgICAgICAgICAgICAgLi4uZXZlbnQuZGV0YWlsLFxuICAgICAgICAgICAgICAgIHR5cGU6IGV2ZW50LnR5cGUsXG4gICAgICAgICAgICAgICAgdGV4dEVsZW1lbnRzOiBmbGF0dGVuVHh0RWxlbS5jb3B5KCksXG4gICAgICAgICAgICAgICAgaWR4LCBvZmZzZXQsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAvLyBhZnRlciBpbnNlcnRcbiAgICAgICAgICAgIGZsYXR0ZW5UeHRFbGVtID0gdGhpcy5fZmxhdHRlblR4dEVsZW07XG4gICAgICAgICAgICBpZih0aGlzLl9zdGF0dXMuZWRpdGluZykge1xuICAgICAgICAgICAgICAgIGlmKGZsYXR0ZW5UeHRFbGVtLmxlbmd0aCgpID4gbGFzdExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjYXJldC5zZXRDb2x1bW4oW1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWlkeCArIGZsYXR0ZW5UeHRFbGVtLmxlbmd0aCgpIC0gbGFzdExlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hhZG93SW5wdXQuZm9jdXMoKTsgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLl9zdGF0dXMuZWRpdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhcmV0LnJlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3luY1NoYWRvd0lucHV0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuX3JhbmdlLmRpc2FibGUoKTtcbiAgICAgICAgfSkuYmluZCh0aGlzKVxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3ByZXNzRW5kJywgb25Ecm9wKVxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCBvbkRyb3ApO1xuICAgIH1cblxuICAgIHRvZ2dsZVNoaWZ0KHZhbCkge1xuICAgICAgICB0aGlzLl9zdGF0dXMuc2hpZnRPbiA9IHZhbDtcbiAgICB9XG5cbiAgICBleGVjQ29tbWFuZChraW5kLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGNtZCA9IHRoaXMuY29tbWFuZHMuZ2V0KGtpbmQpO1xuICAgICAgICBjbWQuZXhlYyhkYXRhKTtcbiAgICB9XG5cbiAgICBjcmVhdGVTaGFkb3dJbnB1dCgpIHtcbiAgICAgICAgY29uc3QgamZsb3cgPSB0aGlzLl9qZmxvdztcbiAgICAgICAgbGV0IHNoYWRvd0lucHV0ID0gbmV3IFNoYWRvd0lucHV0KGpmbG93LkRPTXdyYXBwZXIpO1xuICAgICAgICBjb25zdCBfYSA9IGUgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2luZCA9IGUuZGV0YWlsLmtpbmQ7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gZS5kZXRhaWwuZGF0YTtcbiAgICAgICAgICAgIHRoaXMuZXhlY0NvbW1hbmQoa2luZCwgZGF0YSlcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgX2IgPSBlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtpbmQgPSBlLmRldGFpbC5raW5kO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGUuZGV0YWlsLmRhdGE7XG4gICAgICAgICAgICBjb25zdCBjbWQgPSB0aGlzLmNvbW1hbmRzLmdldChFRElUT1JfRVZFTlRTLklOUFVUKTtcbiAgICAgICAgICAgIGNtZC5leGVjKGtpbmQsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHNoYWRvd0lucHV0LmFkZEV2ZW50TGlzdGVuZXIoRURJVE9SX0VWRU5UUy5DT05UUk9MX0NNRCwgX2EpO1xuICAgICAgICBzaGFkb3dJbnB1dC5hZGRFdmVudExpc3RlbmVyKEVESVRPUl9FVkVOVFMuSU5QVVQsIF9iKTtcblxuICAgICAgICBzaGFkb3dJbnB1dC5yZW1vdmVMaXNlbnRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2hhZG93SW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihFRElUT1JfRVZFTlRTLkNPTlRST0xfQ01ELCBfYSk7XG4gICAgICAgICAgICBzaGFkb3dJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKEVESVRPUl9FVkVOVFMuSU5QVVQsIF9iKTtcbiAgICAgICAgICAgIHNoYWRvd0lucHV0LnJlbW92ZUxpc2VudGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zaGFkb3dJbnB1dCA9IHNoYWRvd0lucHV0O1xuICAgICAgICB0aGlzLl9zdGF0dXMuZWRpdGluZyA9IHRydWU7XG4gICAgICAgIGpmbG93LnNldEZvY3VzSW5zdGFuY2UodGhpcyk7XG4gICAgfVxuXG4gICAgbW92ZUNhcmV0QnlIaXRQb2ludCgpIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLl9jdXJyZW50cDtcbiAgICAgICAgY29uc3QgY2FyZXQgPSB0aGlzLl9jYXJldDtcbiAgICAgICAgY29uc3QgeyByb3csIGNvbHVtbiB9ID0gdGhpcy5fcG9zaXRpb25Ub0N1cnNvck9mZnNldChwb2ludCk7XG4gICAgICAgIGNhcmV0LnNldFJvdyhyb3cpO1xuICAgICAgICBjYXJldC5zZXRDb2x1bW4oY29sdW1uKTtcbiAgICB9XG5cbiAgICByZWZyZXNoKCkge1xuICAgICAgICB0aGlzLnJlY2FsY3VsYXRlVXAoKTtcbiAgICAgICAgdGhpcy5zeW5jU2hhZG93SW5wdXRQb3NpdGlvbigpO1xuICAgICAgICB0aGlzLl9qZmxvdy5fcmVuZGVyKCk7XG4gICAgfVxuXG4gICAgcmVmcmVzaFRleHRFbGVtZW50cygpIHtcbiAgICAgICAgdGhpcy5fZmxhdHRlblR4dEVsZW0gPSBGbGF0dGVuVGV4dEVsZW1lbnRzLmNyZWF0ZSh0aGlzLnJlc29sdmVyKCkpOyBcbiAgICB9XG5cbiAgICBfcG9zaXRpb25Ub0N1cnNvck9mZnNldChwb2ludCkge1xuICAgICAgICBjb25zdCBbeCwgeV0gPSBwb2ludDtcbiAgICAgICAgLy8gY29uc3QgW3gwLCB5MF0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgYXJlYSA9IHRoaXMuX2FyZWE7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoLzI7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICBjb25zdCBvZmZzZXRYID0geCArIHc7XG4gICAgICAgIGNvbnN0IG9mZnNldFkgPSB5ICsgaDtcbiAgICAgICAgY29uc3Qgcm93ID0gYXJlYS5nZXRMaW5lQWJvdmUob2Zmc2V0WSlcbiAgICAgICAgY29uc3QgY3VyckxpbmUgPSBhcmVhLmdldChyb3cpO1xuICAgICAgICBjb25zdCBjb2x1bW4gPSBjdXJyTGluZS5nZXRDb2x1bW5OZWFyZXN0KG9mZnNldFgsIHRoaXMuZWxlbWVudFNwYWNlLCB0aGlzLmZvbnRTaXplLCB0aGlzLmZvbnRGYW1pbHksIHRoaXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm93LCBcbiAgICAgICAgICAgIGNvbHVtbixcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jYXJldFRvUG9zaXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHJvdyA9IHRoaXMuX2NhcmV0LmdldFJvdygpO1xuICAgICAgICBjb25zdCBjb2x1bW4gPSB0aGlzLl9jYXJldC5nZXRDb2x1bW4oKTtcbiAgICAgICAgY29uc3QgbGluZSA9IHRoaXMuX2FyZWEuZ2V0KHJvdyk7XG4gICAgICAgIGNvbnN0IFtlbGVtaWR4LCBvZmZzZXRdID0gY29sdW1uO1xuICAgICAgICBjb25zdCBtZXRhID0gbGluZS5nZXQoZWxlbWlkeCk7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX2ZsYXR0ZW5UeHRFbGVtLmZpbmRJbmRleChtZXRhKTtcbiAgICAgICAgY29uc3QgcHJlRWxlbSA9IHRoaXMuX2ZsYXR0ZW5UeHRFbGVtLmdldChpZHgtMSk7XG4gICAgICAgIGxldCBjdztcbiAgICAgICAgbGV0IGNfbGVuID0gdGhpcy5jdXJyZW50TGluZUhlaWdodC8yO1xuICAgICAgICBpZihtZXRhLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgY29uc3QgYyA9IG1ldGEuZ2V0UmVuZGVyU291cmNlKHRoaXMuc3BhY2VIb2xkZXIpLnN1YnN0cmluZygwLCBvZmZzZXQpO1xuICAgICAgICAgICAgcmVxdWVzdENhY2hlQ2FudmFzKChjdHgpID0+IHtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSBgJHt0aGlzLmZvbnRTaXplfSAke3RoaXMuZm9udEZhbWlseX1gO1xuICAgICAgICAgICAgICAgIGN3ID0gbWV0YS5hbmNob3JYIC0gbWV0YS53aWR0aC8yICsgY3R4Lm1lYXN1cmVUZXh0KGMpLndpZHRoXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3cgPSBtZXRhLmFuY2hvclggLSBtZXRhLndpZHRoLzJcbiAgICAgICAgICAgIGNfbGVuID0gTWF0aC5tYXgoY19sZW4sIG1ldGEuaGVpZ2h0LzIpO1xuICAgICAgICB9XG4gICAgICAgIGlmKG9mZnNldCA9PT0gMCAmJiBwcmVFbGVtICYmIHByZUVsZW0udHlwZSAhPT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBjX2xlbiA9IE1hdGgubWF4KGNfbGVuLCBwcmVFbGVtLmhlaWdodC8yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2N3LCBjX2xlbiwgbGluZS5hbmNob3JZLCBwcmVFbGVtLCBtZXRhXVxuICAgIH1cblxuICAgIHN5bmNTaGFkb3dJbnB1dFBvc2l0aW9uKCkge1xuICAgICAgICBpZih0aGlzLl9zdGF0dXMuZWRpdGluZykge1xuICAgICAgICAgICAgY29uc3QgW2N3LCBjX2xlbiwgYW5jaG9yWV0gPSB0aGlzLl9jYXJldFRvUG9zaXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy5jYWxjdWxhdGVUb1JlYWxXb3JsZChbY3csIGFuY2hvclkgKyBjX2xlbl0pO1xuICAgICAgICAgICAgY29uc3QgY2FudmFzTWV0YSA9IHRoaXMuX2pmbG93LmNhbnZhc01ldGE7XG4gICAgICAgICAgICBjb25zdCBweCA9IE1hdGgubWluKGNhbnZhc01ldGEuYWN0dWFsX3dpZHRoIC0gMTIwLCBwb2ludFswXSk7XG4gICAgICAgICAgICAvLyByZXR1cm4gW3B4LCBwb2ludFsxXV07XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dJbnB1dC5zeW5jUG9zaXRpb24ocHgsIHBvaW50WzFdKTtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd0lucHV0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIHJlbmRlcihjdHgpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgaWYodGhpcy5faXNNb3Zpbmcpe1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC42XG4gICAgICAgIH0gZWxzZSBpZih0aGlzLm9wYWNpdHkgIT09IDEpIHtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMub3BhY2l0eTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbY3gsIGN5XSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCBqZmxvdyA9IHRoaXMuX2pmbG93O1xuICAgICAgICBjb25zdCBhcmVhID0gdGhpcy5fYXJlYTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShjeCwgY3kpO1xuICAgICAgICAvLyBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIC8vIGN0eC5yZWN0KC13aWR0aC8yLCAtaGVpZ2h0LzIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAvLyBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGNvbnN0IGZsYXR0ZW5UeHRFbGVtID0gdGhpcy5fZmxhdHRlblR4dEVsZW07XG4gICAgICAgIGlmKGZsYXR0ZW5UeHRFbGVtLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBgJHt0aGlzLmZvbnRXZWlnaHR9ICR7dGhpcy5mb250U2l6ZX0gJHt0aGlzLmZvbnRGYW1pbHl9YDtcbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnBsYWNlaG9sZGVyQ29sb3I7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQodGhpcy5wbGFjZWhvbGRlciwgMCwgMCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3JhbmRlckN1cnNvcihjdHgpO1xuXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1jeCwgLWN5KTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5mb250ID0gYCR7dGhpcy5mb250V2VpZ2h0fSAke3RoaXMuZm9udFNpemV9ICR7dGhpcy5mb250RmFtaWx5fWA7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy50ZXh0Q29sb3I7XG4gICAgICAgIGFyZWEuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgICAgIGxpbmUuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICAgICAgaWYoZWwudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnJlbmRlcihjdHgsIHRoaXMuc3BhY2VIb2xkZXIsIHRoaXMudGV4dENvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3R4LmZpbGxUZXh0KGVsLnNvdXJjZSwgZWwuYW5jaG9yWCwgZWwuYW5jaG9yWSlcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgICAgZmxhdHRlblR4dEVsZW0uZm9yRWFjaChlbGVtID0+IHtcbiAgICAgICAgICAgIGlmKGVsZW0udHlwZSAhPT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBqZmxvdy5nZXRSZW5kZXJOb2RlQnlTb3VyY2UoZWxlbS5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIGlmKGluc3RhbmNlICYmIGluc3RhbmNlLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UucmVuZGVyKGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMuX3JhbmRlckN1cnNvcihjdHgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJSYW5nZShjdHgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKC1jeCwgLWN5KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBfcmFuZGVyQ3Vyc29yKGN0eCkge1xuICAgICAgICBpZih0aGlzLl9jYXJldC5pc1Nob3coKSAmJiAodGhpcy5fc3RhdHVzLmVkaXRpbmcgfHwgdGhpcy5fc3RhdHVzLmRyYWdvdmVyKSkge1xuICAgICAgICAgICAgY29uc3QgW2N3LCBjX2xlbiwgYW5jaG9yWV0gPSB0aGlzLl9jYXJldFRvUG9zaXRpb24oKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oY3csIGFuY2hvclkgLSBjX2xlbik7XG4gICAgICAgICAgICBjdHgubGluZVRvKGN3LCBhbmNob3JZICsgY19sZW4pO1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDI7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmN1cnNvckNvbG9yO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3JlbmRlclJhbmdlKGN0eCkge1xuICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMuX3JhbmdlO1xuICAgICAgICBpZihyYW5nZS5pc0VuYWJsZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBhcmVhID0gdGhpcy5fYXJlYTtcbiAgICAgICAgICAgIGNvbnN0IHRleHRSYW5nZUNvbG9yID0gdGhpcy50ZXh0UmFuZ2VDb2xvcjtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NraGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBibG9ja3dpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVTcGFjZSA9IHRoaXMubGluZVNwYWNlO1xuICAgICAgICAgICAgY29uc3QgW3JfZiwgaWR4X2YsIG9mZnNldF9mXSA9IHJhbmdlLmdldFJhbmdlRnJvbSgpO1xuICAgICAgICAgICAgY29uc3QgW3JfdCwgaWR4X3QsIG9mZnNldF90XSA9IHJhbmdlLmdldFJhbmdlVG8oKTtcbiAgICAgICAgICAgIGlmKHJfZiA9PT0gcl90KSB7XG4gICAgICAgICAgICAgICAgaWYoaWR4X2YgPT09IGlkeF90ICYmIG9mZnNldF9mID09IG9mZnNldF90KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IGFyZWEuZ2V0KHJfZik7XG4gICAgICAgICAgICAgICAgbGV0IHNwYWNlID0gKHJfZiA9PT0gYXJlYS5sZW5ndGgoKS0xID8gMCA6IGxpbmVTcGFjZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbHR5ID0gbGluZS5yZWR1Y2VIZWlnaHQgLSBzcGFjZSAtIGxpbmUuaGVpZ2h0IC0gYmxvY2toZWlnaHQvMjtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBsaW5lLmhlaWdodDtcbiAgICAgICAgICAgICAgICBjb25zdCB4MSA9IHRoaXMuX21lYXN1cmVFbGVtZW50T2Zmc2V0WChsaW5lLmdldChpZHhfZiksIG9mZnNldF9mLCBjdHgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHgyID0gdGhpcy5fbWVhc3VyZUVsZW1lbnRPZmZzZXRYKGxpbmUuZ2V0KGlkeF90KSwgb2Zmc2V0X3QsIGN0eCk7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5yZWN0KHgxLCBsdHkgLCB4MiAtIHgxLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0UmFuZ2VDb2xvclxuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBfciA9IHJfZjtcbiAgICAgICAgICAgICAgICBsZXQgYmVnaW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3aGlsZShfciA8PSByX3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IGFyZWEuZ2V0KF9yKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlID0gKF9yID09PSBhcmVhLmxlbmd0aCgpLTEgPyAwIDogbGluZVNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbHR5ID0gbGluZS5yZWR1Y2VIZWlnaHQgLSBzcGFjZSAtIGxpbmUuaGVpZ2h0IC0gYmxvY2toZWlnaHQvMjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gbGluZS5oZWlnaHQ7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKGJlZ2lubmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxlbSA9IGxpbmUuZ2V0KGlkeF9mKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLl9tZWFzdXJlRWxlbWVudE9mZnNldFgoZWxlbSwgb2Zmc2V0X2YsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0RWxlbSA9IGxpbmUudGFpbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IGxhc3RFbGVtLmFuY2hvclggKyBsYXN0RWxlbS53aWR0aC8yO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoeCwgbHR5LCB0IC0geCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0UmFuZ2VDb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKF9yID09PSByX3Qpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxlbSA9IGxpbmUuZ2V0KGlkeF90KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLl9tZWFzdXJlRWxlbWVudE9mZnNldFgoZWxlbSwgb2Zmc2V0X3QsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVjdCgtYmxvY2t3aWR0aC8yLCBsdHkgLCBlbGVtLnJlZHVjZVdpZHRoICsgKHggLSBlbGVtLmFuY2hvclggKyBlbGVtLndpZHRoLzIpLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRSYW5nZUNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoLWJsb2Nrd2lkdGgvMiwgbHR5LCBsaW5lLndpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRSYW5nZUNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBiZWdpbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3IrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfbWVhc3VyZUVsZW1lbnRPZmZzZXRYKGVsZW1lbnQsIG9mZnNldCwgY3R4KSB7XG4gICAgICAgIGlmKGVsZW1lbnQudHlwZSAhPT0gJ3RleHQnIHx8IG9mZnNldCA9PT0gMCl7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5hbmNob3JYIC0gZWxlbWVudC53aWR0aC8yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50LmFuY2hvclggLSBlbGVtZW50LndpZHRoLzIgKyBjdHgubWVhc3VyZVRleHQoZWxlbWVudC5nZXRSZW5kZXJTb3VyY2UodGhpcy5zcGFjZUhvbGRlcikuc3Vic3RyaW5nKDAsIG9mZnNldCkpLndpZHRoO1xuICAgIH1cblxuICAgIG1lYXN1cmVUZXh0V2lkdGgoY29udGVudCkge1xuICAgICAgICBsZXQgdDtcbiAgICAgICAgcmVxdWVzdENhY2hlQ2FudmFzKChjdHgpID0+IHtcbiAgICAgICAgICAgIGN0eC5mb250ID0gYCR7dGhpcy5mb250U2l6ZX0gJHt0aGlzLmZvbnRGYW1pbHl9YDtcbiAgICAgICAgICAgIHQgPSBjdHgubWVhc3VyZVRleHQoY29udGVudCkud2lkdGg7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG5cbiAgICBnZXRCb3VuZGluZ0RpbWVuc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgfSBcbiAgICB9XG5cbiAgICBnZXRCb3VuZGluZ1JlY3QoKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aCAvMjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIGNvbnN0IGx0eCA9IGFuY2hvclswXSAtIHc7XG4gICAgICAgIGNvbnN0IGx0eSA9IGFuY2hvclsxXSAtIGg7XG4gICAgICAgIGNvbnN0IHJieCA9IGFuY2hvclswXSArIHc7XG4gICAgICAgIGNvbnN0IHJieSA9IGFuY2hvclsxXSArIGg7XG4gICAgICAgIGNvbnN0IGJyID0gdGhpcy5fYm91bmRpbmdyZWN0O1xuICAgICAgICBiclswXSA9IGx0eDtcbiAgICAgICAgYnJbMV0gPSBsdHk7XG4gICAgICAgIGJyWzJdID0gcmJ4O1xuICAgICAgICBiclszXSA9IHJieTtcbiAgICAgICAgcmV0dXJuIGJyXG4gICAgfVxuXG4gICAgX2dldFZpZXdCb3goKSB7XG4gICAgICAgIGNvbnN0IGJlbG9uZ3NfdmJveCA9IHRoaXMuX2JlbG9uZ3MuZ2V0Q2FjaGVWaWV3Qm94KCk7XG4gICAgICAgIGNvbnN0IGNhY2hlVmlld0JveCA9IHRoaXMuX2NhY2hlVmlld0JveDtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVBvaW50QmFja1dpdGhQb2ludChiZWxvbmdzX3Zib3hbMF0sIGJlbG9uZ3NfdmJveFsxXSwgY2FjaGVWaWV3Qm94LCAwLCAxKTtcbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlUG9pbnRCYWNrV2l0aFBvaW50KGJlbG9uZ3NfdmJveFsyXSwgYmVsb25nc192Ym94WzNdLCBjYWNoZVZpZXdCb3gsIDIsIDMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVWaWV3Qm94O1xuICAgIH1cbiAgICBcbiAgICBnZXRDYWNoZVZpZXdCb3goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZVZpZXdCb3g7XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlVG9Db29yZGluYXRpb24ocG9pbnQpIHtcbiAgICAgICAgY29uc3QgW2d4LCBneV0gPSBwb2ludDtcbiAgICAgICAgY29uc3QgW2N4LCBjeV0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgLy8gY29uc3QgcCA9IFtjeCArIGFuY2hvclswXSAtIHNwYW5ILCBjeSArIGFuY2hvclsxXSAtIHNwYW5WXTtcbiAgICAgICAgY29uc3QgcCA9IFtneCArIGN4LCBneSArIGN5XVxuICAgICAgICBpZih0aGlzLl9iZWxvbmdzICYmIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKHApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxjdWxhdGVUb1JlYWxXb3JsZChwb2ludCkge1xuICAgICAgICBjb25zdCBbZ3gsIGd5XSA9IHBvaW50O1xuICAgICAgICBjb25zdCBbY3gsIGN5XSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCBwID0gW2d4ICsgY3gsIGd5ICsgY3ldXG4gICAgICAgIGlmKHRoaXMuX2JlbG9uZ3MgJiYgdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb1JlYWxXb3JsZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9SZWFsV29ybGQocCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxjdWxhdGVUb1JlYWxXb3JsZFdpdGhQb2ludGVyKG91dHBvaW50LCBpbnBvaW50KSB7XG4gICAgICAgIG91dHBvaW50WzBdID0gaW5wb2ludFswXSArIHRoaXMuYW5jaG9yWzBdO1xuICAgICAgICBvdXRwb2ludFsxXSA9IGlucG9pbnRbMV0gKyB0aGlzLmFuY2hvclsxXTtcbiAgICAgICAgaWYodGhpcy5fYmVsb25ncyAmJiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvUmVhbFdvcmxkV2l0aFBvaW50ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvUmVhbFdvcmxkV2l0aFBvaW50ZXIob3V0cG9pbnQsIG91dHBvaW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jYWxjdWxhdGVQb2ludEJhY2socG9pbnQpIHtcbiAgICAgICAgY29uc3QgW2d4LCBneV0gPSBwb2ludDtcbiAgICAgICAgY29uc3QgW2N4LCBjeV0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgcCA9IFtneCAtIGN4LCBneSAtIGN5XVxuICAgICAgICByZXR1cm4gcFxuICAgIH1cblxuICAgIF9jYWxjdWxhdGVQb2ludEJhY2tXaXRoUG9pbnQoYSwgYiwgYXJyLCBpZHgxLCBpZHgyKSB7XG4gICAgICAgIGFycltpZHgxXSA9IGEgLSB0aGlzLmFuY2hvclswXTtcbiAgICAgICAgYXJyW2lkeDJdID0gYiAtIHRoaXMuYW5jaG9yWzFdO1xuICAgIH1cblxuICAgIGlzSGl0KHBvaW50LCBjb25kaXRpb24pIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuX2NhbGN1bGF0ZVBvaW50QmFjayhwb2ludCk7XG4gICAgICAgIGNvbnN0IGpmbG93ID0gdGhpcy5famZsb3c7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRwID0gcDsgLy8g5pqC5a2Y77yM5Li65LqG5ZCO57ut6K6h566X5Yir55qE5L2N572uXG4gICAgICAgIGxldCB2YWxpZEluc3RhbmNlID0gW107XG4gICAgICAgIGNvbnN0IGZsYXR0ZW5UeHRFbGVtID0gdGhpcy5fZmxhdHRlblR4dEVsZW07XG4gICAgICAgIGZsYXR0ZW5UeHRFbGVtLmZvckVhY2goZWxlbSA9PiB7XG4gICAgICAgICAgICBpZihlbGVtLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gamZsb3cuZ2V0UmVuZGVyTm9kZUJ5U291cmNlKGVsZW0uc291cmNlKTtcbiAgICAgICAgICAgICAgICBpZihpbnN0YW5jZS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkSW5zdGFuY2UucHVzaChpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl9zdGFjay5jaGVja0hpdChwLCBjb25kaXRpb24sIChpKSA9PiB2YWxpZEluc3RhbmNlLmluY2x1ZGVzKGkpKTtcbiAgICAgICAgXG4gICAgICAgIGlmKHRhcmdldCkgcmV0dXJuIHRhcmdldDtcblxuICAgICAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGggLzI7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICByZXR1cm4gcG9pbnRbMF0gPiBhbmNob3JbMF0gLSB3XG4gICAgICAgICAgICAmJiBwb2ludFswXSA8IGFuY2hvclswXSArIHdcbiAgICAgICAgICAgICYmIHBvaW50WzFdID4gYW5jaG9yWzFdIC0gaFxuICAgICAgICAgICAgJiYgcG9pbnRbMV0gPCBhbmNob3JbMV0gKyBoO1xuICAgIH1cblxuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCB0ID0gbmV3IFNoYWRvd0NhY2hlKHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgIGNhY2hlOiAoY3R4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2N4LCBjeV0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1jeCArIHRoaXMud2lkdGgvMiwgLWN5ICsgdGhpcy5oZWlnaHQvMik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZih0aGlzLl9qZmxvdy5fZm9jdXMuaW5zdGFuY2UgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2pmbG93LmJsdXIoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuT2JqZWN0LmFzc2lnbihUZXh0R3JvdXAucHJvdG90eXBlLCBTdGFja01peGluKTtcbk9iamVjdC5hc3NpZ24oVGV4dEdyb3VwLnByb3RvdHlwZSwgTGF5b3V0TWl4aW4pO1xuT2JqZWN0LmFzc2lnbihUZXh0R3JvdXAucHJvdG90eXBlLCB7XG4gICAgICAgIC8vIOWxj+iUvei/meS4pOS4quaWueazle+8jOWPquagueaNrnJlZmxvd+mHjeeul1xuICAgIF9nZXRCb3VuZGluZ0dyb3VwUmVjdCgpIHt9LFxuICAgIHJlc2V0Q2hpbGRyZW5Qb3NpdGlvbigpIHt9LFxuICAgIHJlZmxvdygpIHtcbiAgICAgICAgbGV0IGxpbmVIZWlnaHQgPSB0aGlzLmN1cnJlbnRMaW5lSGVpZ2h0O1xuICAgICAgICBjb25zdCBmbGF0dGVuVHh0RWxlbSA9IHRoaXMuX2ZsYXR0ZW5UeHRFbGVtO1xuICAgICAgICBjb25zdCBhcmVhID0gdGhpcy5fYXJlYTtcbiAgICAgICAgaWYoZmxhdHRlblR4dEVsZW0uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBsZXQgd2lkdGggPSAwO1xuICAgICAgICAgICAgY29uc3QgdCA9IGZsYXR0ZW5UeHRFbGVtLmdldCgwKTtcbiAgICAgICAgICAgIHJlcXVlc3RDYWNoZUNhbnZhcygoY3R4KSA9PiB7XG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSBgJHt0aGlzLmZvbnRTaXplfSAke3RoaXMuZm9udEZhbWlseX1gO1xuICAgICAgICAgICAgICAgIHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHRoaXMucGxhY2Vob2xkZXIpLndpZHRoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBsaW5lID0gYXJlYS50cnVuY2F0ZSh7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBsaW5lSGVpZ2h0LFxuICAgICAgICAgICAgICAgIHJlZHVjZUhlaWdodDogbGluZUhlaWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGluZS5pbnNlcnQoMCwgdCk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHQsIHtcbiAgICAgICAgICAgICAgICBhbmNob3JYOiAtd2lkdGgvMixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGxpbmVIZWlnaHQsXG4gICAgICAgICAgICAgICAgaXNUYWlsOiB0cnVlLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBqZmxvdyA9IHRoaXMuX2pmbG93O1xuICAgICAgICBjb25zdCBzcGFjZUhvbGRlciA9IHRoaXMuc3BhY2VIb2xkZXI7XG4gICAgICAgIHJlcXVlc3RDYWNoZUNhbnZhcygoY3R4KSA9PiB7XG4gICAgICAgICAgICBjdHguZm9udCA9IGAke3RoaXMuZm9udFNpemV9ICR7dGhpcy5mb250RmFtaWx5fWA7XG4gICAgICAgICAgICBmbGF0dGVuVHh0RWxlbS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmKGVsZW1lbnQudHlwZSA9PT0gJ3RleHQnICYmIGVsZW1lbnQuZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5wcmVDYWxjdWxhdGVUZXh0KGN0eCwgc3BhY2VIb2xkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbmV4dEFyZWEgPSBuZXcgQXJlYSgpO1xuICAgICAgICBuZXh0QXJlYS50cnVuY2F0ZSh7XG4gICAgICAgICAgICBoZWlnaHQ6IGxpbmVIZWlnaHQsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbGluZSA9IG5leHRBcmVhLmdldCgwKTtcbiAgICAgICAgbGV0IGFsbEhlaWdodCA9IDA7XG4gICAgICAgIGxldCBhbGxXaWR0aCA9IDA7XG4gICAgICAgIGxldCBsYXN0RWxlbSA9IG51bGw7XG4gICAgICAgIGNvbnN0IGxpbmVTcGFjZSA9IHRoaXMubGluZVNwYWNlO1xuICAgICAgICBjb25zdCBlbGVtZW50U3BhY2UgPSB0aGlzLmVsZW1lbnRTcGFjZTtcbiAgICAgICAgZmxhdHRlblR4dEVsZW0uZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgIGxpbmUucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIGVsZW1lbnQucmVkdWNlV2lkdGggPSBsaW5lLndpZHRoO1xuICAgICAgICAgICAgaWYoZWxlbWVudC50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgbGluZS53aWR0aCArPSBlbGVtZW50LndpZHRoO1xuICAgICAgICAgICAgICAgIGlmKGVsZW1lbnQubmVlZFdyYXApe1xuICAgICAgICAgICAgICAgICAgICBhbGxIZWlnaHQgKz0gKGxpbmUuaGVpZ2h0ICsgbGluZVNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgbGluZS5yZWR1Y2VIZWlnaHQgPSBhbGxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGFsbFdpZHRoID0gTWF0aC5tYXgobGluZS53aWR0aCwgYWxsV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gTGluZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBsaW5lSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEFyZWEucHVzaChsaW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBqZmxvdy5nZXRSZW5kZXJOb2RlQnlTb3VyY2UoZWxlbWVudC5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuaGVpZ2h0ID0gbm9kZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgbGluZS5oZWlnaHQgPSBNYXRoLm1heChsaW5lLmhlaWdodCwgbm9kZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmdpbiA9ICghbGFzdEVsZW0gfHwgbGFzdEVsZW0udHlwZSA9PT0gJ3RleHQnKSA/IGVsZW1lbnRTcGFjZSoyIDogZWxlbWVudFNwYWNlO1xuICAgICAgICAgICAgICAgIGxpbmUud2lkdGggKz0gbm9kZS53aWR0aCttYXJnaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0RWxlbSA9IGVsZW1lbnQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZsYXR0ZW5UeHRFbGVtLnRhaWwoKS5pc1RhaWwgPSB0cnVlO1xuICAgICAgICBhbGxIZWlnaHQgKz0gbGluZS5oZWlnaHRcbiAgICAgICAgbGluZS5yZWR1Y2VIZWlnaHQgPSBhbGxIZWlnaHQ7XG4gICAgICAgIGFsbFdpZHRoID0gTWF0aC5tYXgodGhpcy5taW5XaWR0aCwgTWF0aC5tYXgobGluZS53aWR0aCwgYWxsV2lkdGgpKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGhoID0gYWxsSGVpZ2h0LzI7XG4gICAgICAgIGNvbnN0IGh3ID0gYWxsV2lkdGgvMjtcbiAgICAgICAgbGV0IHR5ID0gLWhoO1xuICAgICAgICBsZXQgbGFzdFJlZHVjZVkgPSAwO1xuXG4gICAgICAgIG5leHRBcmVhLmZvckVhY2gobCA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGhlaWdodCwgcmVkdWNlSGVpZ2h0IH0gPSBsO1xuICAgICAgICAgICAgY29uc3QgYW5jaG9yWSA9IHR5ICsgbGFzdFJlZHVjZVkgKyBoZWlnaHQgLyAyO1xuICAgICAgICAgICAgbC5hbmNob3JZID0gYW5jaG9yWTtcbiAgICAgICAgICAgIGxldCByZWR1Y2VYID0gLWh3O1xuICAgICAgICAgICAgbGV0IGxhc3RlbCA9IG51bGw7XG4gICAgICAgICAgICBsLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgICAgIGlmKGVsLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBlbC5hbmNob3JZID0gYW5jaG9yWTtcbiAgICAgICAgICAgICAgICAgICAgZWwuYW5jaG9yWCA9IHJlZHVjZVggKyBlbC53aWR0aC8yO1xuICAgICAgICAgICAgICAgICAgICByZWR1Y2VYICs9IGVsLndpZHRoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlck5vZGUgPSBqZmxvdy5nZXRSZW5kZXJOb2RlQnlTb3VyY2UoZWwuc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG91YmxlTWFyZ2luID0gKCFsYXN0ZWwgfHwgbGFzdGVsLnR5cGUgPT09ICd0ZXh0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcmdpbiA9IGRvdWJsZU1hcmdpbiA/IGVsZW1lbnRTcGFjZSoyIDogZWxlbWVudFNwYWNlO1xuICAgICAgICAgICAgICAgICAgICBlbC53aWR0aCA9IHJlbmRlck5vZGUud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGVsLmFuY2hvclkgPSBhbmNob3JZO1xuICAgICAgICAgICAgICAgICAgICBlbC5hbmNob3JYID0gcmVkdWNlWCArIGVsLndpZHRoLzIgKyAoZG91YmxlTWFyZ2luID8gbWFyZ2luLzIgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTm9kZS5hbmNob3IgPSBbZWwuYW5jaG9yWCwgZWwuYW5jaG9yWV07XG4gICAgICAgICAgICAgICAgICAgIHJlZHVjZVggKz0gKGVsLndpZHRoICsgbWFyZ2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdGVsID0gZWw7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgbGFzdFJlZHVjZVkgPSByZWR1Y2VIZWlnaHQ7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9hcmVhID0gbmV4dEFyZWE7XG4gICAgICAgIHRoaXMud2lkdGggPSBhbGxXaWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBhbGxIZWlnaHQ7XG4gICAgfSxcbiAgICBkb1JlY2FsY3VsYXRlKCkge1xuICAgICAgICBpZih0aGlzLl9fbW91bnRlZF9fKSB7XG4gICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlVXAoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5fX21vdW50ZWRfXyA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cbn0pXG5leHBvcnQgZGVmYXVsdCBUZXh0R3JvdXA7XG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuL25vZGUnO1xuXG4vLyBleHBvcnQgY29uc3QgUExBQ0VIT0xERVJfU1lNQk9MID0gU3ltYm9sKCdQTEFDRUhPTERFUl9TWU1CT0wnKTtcblxuZXhwb3J0IGNsYXNzIE5vZGVQbGFjZWhvbGRlciBleHRlbmRzIE5vZGUge1xuICAgIHR5cGUgPSAnTk9ERV9QTEFDRUhPTERFUidcbn0iLCJpbXBvcnQgeyBjcmVhdGVDYW52YXMsIHJlc2l6ZUNhbnZhcywgbGlzdGVuT25EZXZpY2VQaXhlbFJhdGlvIH0gZnJvbSAnLi4vdXRpbHMvY2FudmFzJztcbmltcG9ydCB7IGJvdW5kaW5nX2JveCwgZG9PdmVybGFwLCBkZWJvdW5jZSB9IGZyb20gJy4uL3V0aWxzL2Z1bmN0aW9ucyc7XG5pbXBvcnQgeyBKRkxPV19NT0RFIH0gZnJvbSAnLi4vdXRpbHMvY29uc3RhbmNlJztcbmltcG9ydCBHaG9zdE5vZGUgZnJvbSAnLi4vaW5zdGFuY2UvZ2hvc3ROb2RlJztcbmltcG9ydCB7IE5vZGVXZWFrTWFwTWl4aW4gfSBmcm9tICcuLi9pbnN0YW5jZS9ub2RlV2Vha01hcCc7XG5pbXBvcnQgU3RhY2tNaXhpbiBmcm9tICcuLi9pbnN0YW5jZS9zdGFja01peGluJztcbmltcG9ydCBMYXlvdXRNaXhpbiBmcm9tICcuLi9pbnN0YW5jZS9sYXlvdXRNaXhpbic7XG5pbXBvcnQgTWVzc2FnZU1peGluIGZyb20gJy4uL2luc3RhbmNlL21lc3NhZ2VNaXhpbic7XG5pbXBvcnQgQW5pbWVNaXhpbiBmcm9tICcuLi9hbmltZS9hbmltZU1peGluJztcbmltcG9ydCBNaW5pTWFwTWl4aW4gZnJvbSAnLi4vbWluaU1hcC9taW5pbWFwLW1peGluJztcbmltcG9ydCBTY3JvbGxCYXJNaXhpbiBmcm9tICcuLi9zY3JvbGxiYXIvc2Nyb2xsYmFyTWl4aW4nO1xuaW1wb3J0IFNjaGVkdWxlTWl4aW4gZnJvbSAnLi9zY2hlZHVsZSc7XG4vLyBpbXBvcnQgeyBzZXRVbmlxdWVJZCwgZ2V0VW5pcXVlSWQgfSBmcm9tICcuLi91dGlscy9mdW5jdGlvbnMnO1xuaW1wb3J0IEpGbG93RXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcblxuaW1wb3J0IEV2ZW50QWRhcHRlciBmcm9tICcuLi9ldmVudHMvYWRhcHRlcic7XG5cbmltcG9ydCBHcm91cEZhY3RvcnkgZnJvbSAnLi4vaW5zdGFuY2UvZ3JvdXBGYWN0b3J5JztcbmltcG9ydCBQb2ludCBmcm9tICcuLi9pbnN0YW5jZS9zaGFwZXMvcG9pbnQnO1xuaW1wb3J0IFJlY3RhbmdsZSBmcm9tICcuLi9pbnN0YW5jZS9zaGFwZXMvcmVjdGFuZ2xlJztcbmltcG9ydCBDYXBzdWxlIGZyb20gJy4uL2luc3RhbmNlL3NoYXBlcy9jYXBzdWxlJztcbmltcG9ydCBDYXBzdWxlVmVydGljYWwgZnJvbSAnLi4vaW5zdGFuY2Uvc2hhcGVzL2NhcHN1bGUtdmVydGljYWwnO1xuaW1wb3J0IFJob21idXMgZnJvbSAnLi4vaW5zdGFuY2Uvc2hhcGVzL3Job21idXMnO1xuaW1wb3J0IERpYW1vbmQgZnJvbSAnLi4vaW5zdGFuY2Uvc2hhcGVzL2RpYW1vbmQnO1xuaW1wb3J0IERpYW1vbmRWZXJ0aWNhbCBmcm9tICcuLi9pbnN0YW5jZS9zaGFwZXMvZGlhbW9uZC12ZXJ0aWNhbCc7XG4vLyBpbXBvcnQgeyBjcmVhdGVJbnB1dFRleHRTdHlsZSB9IGZyb20gJy4uL2luc3RhbmNlL3RleHQnO1xuLy8gY3JlYXRlSW5wdXRUZXh0U3R5bGUoKTtcbi8qKlxuICogQGZ1bnRpb24gc2V0SW5pdGlhbFBvc2l0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gUmVhbGJveFggLSDlhoXlrrnmmKDlsITliLBjYW52YXPkuIrnmoQgWFxuICogQHBhcmFtIHtOdW1iZXJ9IFJlYWxib3hZIC0g5YaF5a655pig5bCE5YiwY2FudmFz5LiK55qEIFkgXG4gKiBAcGFyYW0ge051bWJlcn0gUmVhbGJveFcgLSDlhoXlrrnmmKDlsITliLBjYW52YXPkuIrnmoTlrr3luqZcbiAqIEBwYXJhbSB7TnVtYmVyfSBSZWFsYm94SCAtIOWGheWuueaYoOWwhOWIsGNhbnZhc+S4iueahOmrmOW6piBcbiAqIEBwYXJhbSB7TnVtYmVyfSBDYW52YXNXaWR0aCAgLSDop4bnqpflrr3luqZcbiAqIEBwYXJhbSB7TnVtYmVyfSBDYW52YXNIZWlnaHQgIC0g6KeG56qX6auY5bqmXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0g5Yid5aeL5L2N572uIHsgeCwgeSB9XG4gKi9cblxuLyoqXG4gKiBAZnVudGlvbiBsaW5rR2VuXG4gKiBAcGFyYW0ge05vZGV9IGZyb20gLSDlh7rlj5Hnu5jlm77oioLngrlcbiAqIEBwYXJhbSB7Tm9kZX0gdG8gLSDkuLTml7boioLngrnvvIzlvZPliY3pvKDmoIfmjIfnmoTlnLDmlrlcbiAqIEByZXR1cm4ge0Jhc2VlTGlua30gLSDov57nur/lr7nosaFcbiAqL1xuXG5cbi8qKiBcbiAqIEBjbGFzcyBHcm91cFxuICogQGNsYXNzZGVzYyDnn6nlvaLnu4TljZXlhYMg55SxIHtAbGluayBHcm91cEZhY3Rvcnl9IOmAmui/hyB7QGxpbmsgUmVjdGFuZ2xlfSDnlJ/miJBcbiAqIEBncm91cGZyb20gUmVjdGFuZ2xlXG4gKiBAYXVnbWVudHMgR3JvdXBUZW1wbGF0ZVxuICogQGF1Z21lbnRzIFJlY3RhbmdsZVxuICogQHBhcmFtIHsoUmVjdGFuZ2xlflJlY3RhbmdsZUNvbmZpZ3N8R3JvdXBUZW1wbGF0ZX5Hcm91cENvbmZpZ3MpfSBjb25maWdzIC0g6YWN572uXG4gKi9cbmV4cG9ydCBjb25zdCBHcm91cCA9IEdyb3VwRmFjdG9yeShSZWN0YW5nbGUpO1xuLyoqIFxuICogQGNsYXNzIENhcHN1bGVHcm91cFxuICogQGNsYXNzZGVzYyDog7blm4rnu4TljZXlhYMg55SxIHtAbGluayBHcm91cEZhY3Rvcnl9IOmAmui/hyB7QGxpbmsgQ2Fwc3VsZX0g55Sf5oiQXG4gKiBAZ3JvdXBmcm9tIENhcHN1bGVcbiAqIEBhdWdtZW50cyBHcm91cFRlbXBsYXRlXG4gKiBAYXVnbWVudHMgQ2Fwc3VsZVxuICogQHBhcmFtIHsoQ2Fwc3VsZX5DYXBzdWxlQ29uZmlnc3xHcm91cFRlbXBsYXRlfkdyb3VwQ29uZmlncyl9IGNvbmZpZ3MgLSDphY3nva5cbiAqL1xuZXhwb3J0IGNvbnN0IENhcHN1bGVHcm91cCA9IEdyb3VwRmFjdG9yeShDYXBzdWxlKTtcbi8qKiBcbiAqIEBjbGFzcyBSaG9tYnVzR3JvdXBcbiAqIEBjbGFzc2Rlc2Mg6I+x5b2i57uE5Y2V5YWDIOeUsSB7QGxpbmsgR3JvdXBGYWN0b3J5fSDpgJrov4cge0BsaW5rIFJob21idXN9IOeUn+aIkFxuICogQGF1Z21lbnRzIEdyb3VwVGVtcGxhdGVcbiAqIEBhdWdtZW50cyBSaG9tYnVzXG4gKiBAZ3JvdXBmcm9tIFJob21idXNcbiAqIEBwYXJhbSB7KFJob21idXN+UmhvbWJ1c0NvbmZpZ3N8R3JvdXBUZW1wbGF0ZX5Hcm91cENvbmZpZ3MpfSBjb25maWdzIC0g6YWN572uXG4gKi9cbmV4cG9ydCBjb25zdCBSaG9tYnVzR3JvdXAgPSBHcm91cEZhY3RvcnkoUmhvbWJ1cyk7XG4vKiogXG4gKiBAY2xhc3MgRGlhbW9uZEdyb3VwXG4gKiBAY2xhc3NkZXNjIOmSu+efs+W9oue7hOWNleWFgyDnlLEge0BsaW5rIEdyb3VwRmFjdG9yeX0g6YCa6L+HIHtAbGluayBEaWFtb25kfSDnlJ/miJBcbiAqIEBncm91cGZyb20gRGlhbW9uZFxuICogQGF1Z21lbnRzIEdyb3VwVGVtcGxhdGVcbiAqIEBhdWdtZW50cyBEaWFtb25kXG4gKiBAcGFyYW0geyhEaWFtb25kfkRpYW1vbmRDb25maWdzfEdyb3VwVGVtcGxhdGV+R3JvdXBDb25maWdzKX0gY29uZmlncyAtIOmFjee9rlxuICovXG5leHBvcnQgY29uc3QgRGlhbW9uZEdyb3VwID0gR3JvdXBGYWN0b3J5KERpYW1vbmQsIHtcbiAgICBzaGFwZVNoaWZ0KHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIFt3aWR0aCArIGhlaWdodCAqIDAuMjg4NjUsIGhlaWdodF1cbiAgICB9XG59KTtcbi8qKiBcbiAqIEBjbGFzcyBEaWFtb25kVmVydGljYWxHcm91cFxuICogQGNsYXNzZGVzYyDlnoLnm7Tpkrvnn7PlvaLnu4TljZXlhYMg55SxIHtAbGluayBHcm91cEZhY3Rvcnl9IOmAmui/hyB7QGxpbmsgRGlhbW9uZFZlcnRpY2FsfSDnlJ/miJBcbiAqIEBncm91cGZyb20gRGlhbW9uZFZlcnRpY2FsXG4gKiBAYXVnbWVudHMgR3JvdXBUZW1wbGF0ZVxuICogQGF1Z21lbnRzIERpYW1vbmRWZXJ0aWNhbFxuICogQHBhcmFtIHsoRGlhbW9uZH5EaWFtb25kQ29uZmlnc3xHcm91cFRlbXBsYXRlfkdyb3VwQ29uZmlncyl9IGNvbmZpZ3MgLSDphY3nva5cbiAqL1xuZXhwb3J0IGNvbnN0IERpYW1vbmRWZXJ0aWNhbEdyb3VwID0gR3JvdXBGYWN0b3J5KERpYW1vbmRWZXJ0aWNhbCwge1xuICAgIHNoYXBlU2hpZnQod2lkdGgsIGhlaWdodCkge1xuICAgICAgICByZXR1cm4gW3dpZHRoLCBoZWlnaHQgKyB3aWR0aCAqIDAuNTc3M11cbiAgICB9XG59KTtcbi8qKiBcbiAqIEBjbGFzcyBDYXBzdWxlVmVydGljYWxHcm91cFxuICogQGNsYXNzZGVzYyDlnoLnm7Tpkrvnn7PlvaLnu4TljZXlhYMg55SxIHtAbGluayBHcm91cEZhY3Rvcnl9IOmAmui/hyB7QGxpbmsgQ2Fwc3VsZVZlcnRpY2FsfSDnlJ/miJBcbiAqIEBncm91cGZyb20gQ2Fwc3VsZVZlcnRpY2FsXG4gKiBAYXVnbWVudHMgR3JvdXBUZW1wbGF0ZVxuICogQGF1Z21lbnRzIENhcHN1bGVWZXJ0aWNhbFxuICogQHBhcmFtIHsoQ2Fwc3VsZX5DYXBzdWxlQ29uZmlnc3xHcm91cFRlbXBsYXRlfkdyb3VwQ29uZmlncyl9IGNvbmZpZ3MgLSDphY3nva5cbiAqL1xuZXhwb3J0IGNvbnN0IENhcHN1bGVWZXJ0aWNhbEdyb3VwID0gR3JvdXBGYWN0b3J5KENhcHN1bGVWZXJ0aWNhbCk7XG5cbmV4cG9ydCBjb25zdCBQb2ludEdyb3VwID0gR3JvdXBGYWN0b3J5KFBvaW50LCB7XG4gICAgc2hhcGVTaGlmdCh3aWR0aCwgaGVpZ2h0LCBwKSB7XG4gICAgICAgIGNvbnN0IHIgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KHdpZHRoICogd2lkdGggKyBoZWlnaHQgKiBoZWlnaHQpIC8gMik7XG4gICAgICAgIHAucmFkaXVzID0gcjtcbiAgICAgICAgY29uc3QgdyA9IHIgKiAyO1xuICAgICAgICByZXR1cm4gW3csIHddO1xuICAgIH1cbn0pO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNjcm9sbEdyb3VwIH0gZnJvbSAnLi4vaW5zdGFuY2UvZ3JvdXBzL3Njcm9sbC1ncm91cCc7IFxuLyoqXG4gKiBAdHlwZWRlZiBKRmxvd35KRmxvd0NvbmZpZ3NcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGFsbG93RHJvcCAgICAgIC0g5piv5ZCm5YWB6K64IGRyYWdkcm9wXG4gKiBAcHJvcGVydHkge051bWJlcn0gbWF4Wm9vbSAgICAgICAgIC0g5pyA5aSn57yp5pS+XG4gKiBAcHJvcGVydHkge051bWJlcn0gbWluWm9vbSAgICAgICAgIC0g5pyA5bCP57yp5pS+XG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5pdGlhbFpvb20gICAgIC0g5Yid5aeL57yp5pS+5q+UXG4gKiBAcHJvcGVydHkge0V2ZW50QWRhcHRlcn5wbHVnaW5EZWZ9IGV2ZW50QWRhcHRlclxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0pGbG93fkpGbG93Q29uZmlncyB8IExheW91dE1peGlufkxheW91dENvbmZpZ3N9IEpGbG93fkpGbG93TGF5b3V0Q29uZmlnc1xuICovXG4vKiogXG4gKiBKRmxvdyDlr7nosaFcbiAqIEpGbG93IOaYryBjYW52YXMg5LiK6Z2i5bCB6KOF55qE5LiA5Liq6aG25bGC5a+56LGh77yM5YW35pyJ5aSE55CG5LqL5Lu25ZKM57uY5Yi255qE5Yqf6IO9XG4gKiBAY29uc3RydWN0b3IgSkZsb3dcbiAqIEBwYXJhbSB7SkZsb3d+SkZsb3dMYXlvdXRDb25maWdzfSBjb25maWdzIC0g6YWN572u6aG5XG4gKiBAbWl4ZXMgTGF5b3V0TWl4aW5cbiAqIEBtaXhlcyBTdGFja01peGluXG4gKiBAbWl4ZXMgTWVzc2FnZU1peGluXG4gKi9cbmNsYXNzIEpGbG93IGV4dGVuZHMgRXZlbnRUYXJnZXR7XG4gICAgY29uc3RydWN0b3IoY29uZmlncykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnVuaXF1ZU5hbWUgPSAnamZsb3cnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7RXZlbnRBZGFwdGVyfSBldmVudEFkYXB0ZXIgICAgLSBldmVudEFkYXB0ZXIg5a+56LGhXG4gICAgICAgICAqKi9cbiAgICAgICAgdGhpcy5ldmVudEFkYXB0ZXIgPSBuZXcgRXZlbnRBZGFwdGVyKGNvbmZpZ3MuZXZlbnRBZGFwdGVyKTtcbiAgICAgICAgdGhpcy5pbml0Tm9kZVdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5pbml0QW5pbWUoKTtcbiAgICAgICAgdGhpcy5pbml0U3RhY2soY29uZmlncyk7XG4gICAgICAgIHRoaXMuaW5pdExheW91dChjb25maWdzKTtcbiAgICAgICAgLyoqIEBtZW1iZXIge0NvbnRleHQyZH0gICAgIC0gQ29udGV4dDJkIOWvueixoSAqL1xuICAgICAgICB0aGlzLmN0eCA9IG51bGw7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtFbGVtZW50fSAgICAgICAtIGNhbnZhcyDlhYPntKAgKi9cbiAgICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgICAvKiogQG1lbWJlciB7bnVtYmVyfSAgICAgICAtIOiuvuWkh0RQUiAqL1xuICAgICAgICB0aGlzLmRwciA9IDE7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtudW1iZXJ9ICAgICAgIC0g5YaF6L656LedICovXG4gICAgICAgIHRoaXMucGFkZGluZyA9IDIwO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgLyoqIEBtZW1iZXIge251bWJlcn0gICAgIC0g57yp5pS+ICovXG5cdFx0dGhpcy5zY2FsZSA9IG51bGw7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtudW1iZXJ9ICAgICAtIOWIneWni+e8qeaUviAqL1xuICAgICAgICB0aGlzLmluaXRpYWxab29tID0gY29uZmlncy5pbml0aWFsWm9vbTtcbiAgICAgICAgLyoqIEBtZW1iZXIge3NldEluaXRpYWxQb3NpdGlvbn0gLSDliJ3lp4vkvY3nva7orqHnrpcgKi9cbiAgICAgICAgdGhpcy5pbml0aWFsUG9zaXRpb24gPSBjb25maWdzLnNldEluaXRpYWxQb3NpdGlvbjtcbiAgICAgICAgLyoqIEBtZW1iZXIge251bWJlcn0gICAgIC0g5pyA5aSn57yp5pS+ICovXG4gICAgICAgIHRoaXMubWF4Wm9vbSA9IGNvbmZpZ3MubWF4Wm9vbSB8fCAzO1xuICAgICAgICAvKiogQG1lbWJlciB7bnVtYmVyfSAgICAgLSDmnIDlsI/nvKnmlL4gKi9cbiAgICAgICAgdGhpcy5taW5ab29tID0gY29uZmlncy5taW5ab29tIHx8IC41O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5Ob2RlUmVuZGVyVG9wID0gISFjb25maWdzLk5vZGVSZW5kZXJUb3BcblxuICAgICAgICB0aGlzLndvcmxkTWFyZ2luID0gY29uZmlncy53b3JsZE1hcmdpbjtcblxuICAgICAgICB0aGlzLmRyYWdnaW5nYmVoYXZpb3IgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIHBhbkluQm9yZGVyOiB7XG4gICAgICAgICAgICAgICAgZW5hYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDIwLFxuICAgICAgICAgICAgICAgIGRlbHRhbW92ZW1lbnQ6IDgsXG4gICAgICAgICAgICAgICAgYWxsb3dNb3ZpbmdUYXJnZXRJblBhbjogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIGNvbmZpZ3MuZHJhZ2dpbmdiZWhhdmlvciB8fCB7fSk7XG4gICAgICAgIHRoaXMuc2Nyb2xsQmFyQmVoYXZpb3IgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGVuYWJsZTogdHJ1ZSxcbiAgICAgICAgfSwgY29uZmlncy5zY3JvbGxCYXJCZWhhdmlvciB8fCB7fSlcblx0XHQvLyB0aGlzLmluaXRTY2FsZSA9IDE7XG5cdFx0Ly8gdGhpcy5pbml0UG9zaXRpb24gPSBudWxsXG5cdFx0dGhpcy5vZmZlc2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGFzdFN0YXRlID0ge1xuICAgICAgICAgICAgeDogbnVsbCxcbiAgICAgICAgICAgIHk6IG51bGwsXG4gICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICBwcm9jZXNzaW5nOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9sYXN0RHJhZ1N0YXRlID0ge1xuICAgICAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICAgICAgdGFyZ2V0TGluazogbnVsbCxcbiAgICAgICAgICAgIHByb2Nlc3Npbmc6IGZhbHNlLFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0ge1xuICAgICAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgICAgICBsaW5rOiBudWxsLFxuICAgICAgICAgICAgbW92aW5nOiBudWxsLFxuICAgICAgICAgICAgaXNJbnN0YW5jZURpcnR5OiBmYWxzZSwgXG4gICAgICAgICAgICBpc0xpbmtEaXJ0eTogZmFsc2UsIFxuICAgICAgICAgICAgLy8gaXNNb3ZpbmdEaXJ0eTogZmFsc2UsIFxuICAgICAgICAgICAgY2FjaGU6IHtcbiAgICAgICAgICAgICAgICBzdGFjazogbnVsbCxcbiAgICAgICAgICAgICAgICBiZWxvbmdzOiBudWxsLFxuICAgICAgICAgICAgICAgIHBvaW50OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICB4OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgeTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGluaXRpYWxYOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgaW5pdGlhbFk6IHVuZGVmaW5lZCwgXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgZHJhZ292ZXJpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwcm9jZXNzaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtb3ZpbmdTdGF0ZTogZmFsc2UsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9mb2N1cyA9IHtcbiAgICAgICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZHJhZ092ZXJUYXJnZXQgPSBudWxsO1xuICAgICAgICAvLyB0aGlzLmxvY2sgPSBjb25maWdzLmxvY2s7XG5cbiAgICAgICAgdGhpcy5hbGxvd0Ryb3AgPSBjb25maWdzLmFsbG93RHJvcDtcbiAgICAgICAgLy8g5Li05pe257uY5Yi255qE5a+56LGhXG4gICAgICAgIHRoaXMuX3RlbXBOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGVtcExpbmsgPSBudWxsO1xuXG4gICAgICAgIHRoaXMubW9kZSA9IEpGTE9XX01PREUuREVGQVVMVDtcblxuICAgICAgICB0aGlzLl9hbGxvd01vdmluZ1RhcmdldCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5jYW52YXNNZXRhID0ge31cblxuICAgICAgICB0aGlzLl9jYWNoZVZpZXdCb3ggPSBbXVxuXG4gICAgICAgIHRoaXMuX19tb3VudGVkX18gPSBmYWxzZTtcblxuICAgICAgICAvLyB0aGlzLl9hbGxvd1pvb20gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGFsbG93Wm9vbSgpIHtcbiAgICAvLyAgICAgdGhpcy5fYWxsb3dab29tID0gdHJ1ZTtcbiAgICAvLyB9XG5cbiAgICAvLyBhYmFuZG9uWm9vbSgpIHtcbiAgICAvLyAgICAgdGhpcy5fYWxsb3dab29tID0gZmFsc2U7XG4gICAgLy8gfVxuICAgIC8qKlxuICAgICAqIOiuvue9ruW9k+WJjeaLluWKqOeahCBKRmxvdyDlr7nosaFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSB0YXJnZXRzIC0g5YW35pyJIGFuY2hvciDlsZ7mgKfnmoTlr7nosaFcbiAgICAgKi9cbiAgICBzZXRNb3ZpbmdUYXJnZXRzKHRhcmdldHMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl90YXJnZXQsIHtcbiAgICAgICAgICAgIG1vdmluZzogdGFyZ2V0cywgICAgICAgXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6+572u5b2T5YmN5ouW5Yqo55qEIEpGbG93IOWvueixoVxuICAgICAqIEBwYXJhbSB7SW5zdGFuY2V9IGluc3RhbmNlIC0gSkZsb3cg5a+56LGhXG4gICAgICovXG4gICAgc2V0VGVtcERyYWdnaW5nSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICAgICAgaW5zdGFuY2UuX2JlbG9uZ3MgPSB0aGlzO1xuICAgICAgICB0aGlzLl90ZW1wTm9kZSA9IGluc3RhbmNlO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3RhcmdldCwge1xuICAgICAgICAgICAgbW92aW5nOiBbdGhpcy5fdGVtcE5vZGVdLFxuICAgICAgICAgICAgZHJhZ2dpbmc6IHRydWUsXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5Y+W5raI5b2T5YmN5ouW5Yqo55qEIEpGbG93IOWvueixoVxuICAgICAqIEByZXR1cm4ge251bWJlcltdfSBwb2ludCAtIEpGbG93IOWdkOagh1xuICAgICAqL1xuICAgIHJlbW92ZVRlbXBEcmFnZ2luZ0luc3RhbmNlKCkge1xuICAgICAgICBpZih0aGlzLl90ZW1wTm9kZSkge1xuICAgICAgICAgICAgLy8gdGhpcy5yZW1vdmVGcm9tU3RhY2sodGhpcy5fdGVtcE5vZGUpO1xuICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5fdGVtcE5vZGUuYW5jaG9yO1xuICAgICAgICAgICAgdGhpcy5fdGVtcE5vZGUgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGFuY2hvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiDlhbPpl63pu5jorqTlr7nosaHmi5bliqjmlYjmnpxcbiAgICAgKi9cbiAgICBwcmV2ZW50RGVmYXVsdERyYWdnaW5nKCkge1xuICAgICAgICB0aGlzLl9hbGxvd01vdmluZ1RhcmdldCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDlvIDlkK/pu5jorqTlr7nosaHmi5bliqjmlYjmnpxcbiAgICAgKi9cbiAgICBhbGxvd0RlZmF1bHREcmFnZ2luZygpIHtcbiAgICAgICAgdGhpcy5fYWxsb3dNb3ZpbmdUYXJnZXQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDlnKggRG9jdW1lbnQg5YWD57Sg5LiK5Yid5aeL5YyW5a6e5L6LXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBkb20gXG4gICAgICovXG4gICAgJG1vdW50KGRvbSkge1xuICAgICAgICBjb25zdCB7IFxuICAgICAgICAgICAgY2FudmFzLCBcbiAgICAgICAgICAgIGN0eCwgXG4gICAgICAgICAgICBzY2FsZTogZHByLCBcbiAgICAgICAgICAgIHdpZHRoOiBjX3dpZHRoLCBcbiAgICAgICAgICAgIGhlaWdodDogY19oZWlnaHQsIFxuICAgICAgICAgICAgcmF3X3dpZHRoLFxuICAgICAgICAgICAgcmF3X2hlaWdodCxcbiAgICAgICAgICAgIGxlZnQsIHRvcCBcbiAgICAgICAgfSA9IGNyZWF0ZUNhbnZhcyhkb20pO1xuICAgICAgICB0aGlzLnJlZmxvdygpO1xuICAgICAgICB0aGlzLmN0eCA9IGN0eCAvL25ldyBDYW52YXNDb250ZXh0MmQoY3R4LCBkcHIpO1xuICAgICAgICB0aGlzLkRPTXdyYXBwZXIgPSBkb207XG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgICB0aGlzLmNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2RhdGEtamZsb3cnLCB0cnVlKTtcbiAgICAgICAgdGhpcy5jYW52YXMuJGpmbG93ID0gdGhpcztcbiAgICAgICAgdGhpcy5jYW52YXNNZXRhID0ge1xuICAgICAgICAgICAgd2lkdGg6IHJhd193aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogcmF3X2hlaWdodCxcbiAgICAgICAgICAgIGFjdHVhbF93aWR0aDogY193aWR0aCxcbiAgICAgICAgICAgIGFjdHVhbF9oZWlnaHQ6IGNfaGVpZ2h0XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcHIgPSBkcHI7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9nZXRCb3VuZGluZ0dyb3VwUmVjdCgpO1xuXG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLnBhZGRpbmc7XG4gICAgICAgIGNvbnN0IHsgd2lkdGg6IHBfd2lkdGgsIGhlaWdodDogcF9oZWlnaHQsIHg6IHBfeCwgeTogcF95IH0gPSB0aGlzLmJvdW5kaW5nX2JveDtcbiAgICAgICAgY29uc3QgY29udGVudEJveCA9IHtcbiAgICAgICAgICAgIHg6IHBhZGRpbmcsXG4gICAgICAgICAgICB5OiBwYWRkaW5nLFxuICAgICAgICAgICAgd2lkdGg6IGNfd2lkdGggLSBwYWRkaW5nICogMixcbiAgICAgICAgICAgIGhlaWdodDogY19oZWlnaHQgLSBwYWRkaW5nICogMixcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHsgeDogMCwgeTogMCwgb2Zmc2V0WDogMCwgb2Zmc2V0WTogMCB9O1xuICAgICAgICBjb25zdCB3X3JhdGlvID0gY29udGVudEJveC53aWR0aCAvIHBfd2lkdGg7XG4gICAgICAgIGNvbnN0IGhfcmF0aW8gPSBjb250ZW50Qm94LmhlaWdodCAvIHBfaGVpZ2h0O1xuICAgICAgICBjb25zdCBhbGlnbiA9IHdfcmF0aW8gPD0gaF9yYXRpbyA/ICd4JyA6ICd5JztcbiAgICAgICAgbGV0IHNjYWxlUmF0aW87XG4gICAgICAgIGlmKHRoaXMuaW5pdGlhbFpvb20pIHtcbiAgICAgICAgICAgIHNjYWxlUmF0aW8gPSB0aGlzLmluaXRpYWxab29tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2NhbGVSYXRpbyA9IE1hdGgubWluKHdfcmF0aW8sIGhfcmF0aW8pO1xuICAgICAgICB9XG4gICAgICAgXG4gICAgICAgIHRoaXMuc2NhbGUgPSBzY2FsZVJhdGlvO1xuICAgICAgICBpZihzY2FsZVJhdGlvID4gdGhpcy5tYXhab29tKSB7XG4gICAgICAgICAgICB0aGlzLm1heFpvb20gPSBzY2FsZVJhdGlvO1xuICAgICAgICB9XG4gICAgICAgIGlmKHNjYWxlUmF0aW8gPCB0aGlzLm1pblpvb20pIHtcbiAgICAgICAgICAgIHRoaXMubWluWm9vbSA9IHNjYWxlUmF0aW87XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVhbGJveFggPSBwX3ggKiBzY2FsZVJhdGlvO1xuICAgICAgICBjb25zdCByZWFsYm94WSA9IHBfeSAqIHNjYWxlUmF0aW87XG4gICAgICAgIGNvbnN0IHJlYWxib3hXID0gY29udGVudEJveC53aWR0aDtcbiAgICAgICAgY29uc3QgcmVhbGJveEggPSBjb250ZW50Qm94LmhlaWdodDtcbiAgICAgICAgaWYodGhpcy5pbml0aWFsUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy5pbml0aWFsUG9zaXRpb24ocmVhbGJveFgsIHJlYWxib3hZLCByZWFsYm94VywgcmVhbGJveEgsIGNvbnRlbnRCb3gueCwgY29udGVudEJveC55LCBjX3dpZHRoLCBjX2hlaWdodCwgcF94LCBwX3ksIHBfd2lkdGgsIHBfaGVpZ2h0KTtcbiAgICAgICAgICAgIHBvc2l0aW9uLnggPSB4O1xuICAgICAgICAgICAgcG9zaXRpb24ueSA9IHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbi54ID0gYWxpZ24gPT09ICd4JyA/IGNvbnRlbnRCb3gueCA6IChyZWFsYm94VyAtIHBfd2lkdGggKiBzY2FsZVJhdGlvKSAvIDIgKyBwYWRkaW5nXG4gICAgICAgICAgICBwb3NpdGlvbi55ID0gYWxpZ24gPT09ICd5JyA/IGNvbnRlbnRCb3gueSA6IChyZWFsYm94SCAtIHBfaGVpZ2h0ICogc2NhbGVSYXRpbykgLyAyICsgcGFkZGluZ1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBwb3NpdGlvbi5vZmZzZXRYID0gcG9zaXRpb24ueCAtIHJlYWxib3hYO1xuICAgICAgICBwb3NpdGlvbi5vZmZzZXRZID0gcG9zaXRpb24ueSAtIHJlYWxib3hZO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIHRoaXMuX3JlYWR5VG9SZW5kZXIgPSB0cnVlO1xuICAgICAgICBpZih0aGlzLnNjcm9sbEJhckJlaGF2aW9yLmVuYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5pbml0U2Nyb2xsQmFyKHRoaXMuc2Nyb2xsQmFyQmVoYXZpb3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMuaW5pdFNjaGVkdWxlKCk7XG4gICAgICAgIC8vIHRoaXMuc2NoZWR1bGVSZW5kZXIoKCkgPT4ge1xuICAgICAgICAvLyAgICAgdGhpcy5fY3JlYXRlRXZlbnRIYW5kbGVyKCk7XG4gICAgICAgIC8vIH0pO1xuICAgICAgICB0aGlzLl9fcmVuZGVyKCk7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUV2ZW50SGFuZGxlcigpO1xuICAgICAgICBcbiAgICAgICAgbGlzdGVuT25EZXZpY2VQaXhlbFJhdGlvKChkcHIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZHByID0gZHByO1xuICAgICAgICAgICAgLy8gdGhpcy5jdHguc2V0RFBSKGRwcilcbiAgICAgICAgICAgIHRoaXMucmVzaXplQ2FudmFzKCk7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgIH0sIChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lEcHJMaXN0ZW5lciA9IGhhbmRsZXI7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9fbW91bnRlZF9fID0gdHJ1ZTtcbiAgICAgICAgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6+572uSmZsb3fov5vlhaXov57nur/mqKHlvI9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIC0g5b2T5YmN6L+e57q/55qE5Ye65Y+R5Y6f5aeL5pWw5o2uXG4gICAgICogQHBhcmFtIHtsaW5rR2VufSBsaW5rR2VuIC0g55Sf5oiQ6L+e57q/5Y2V5YWD55qE5pa55rOVXG4gICAgICovXG4gICAgc2V0TGlua2luZ01vZGUoc291cmNlLCBsaW5rR2VuLCBpc1RhaWwpIHtcbiAgICAgICAgY29uc3QgcmVuZGVyTm9kZSA9IHRoaXMuZ2V0UmVuZGVyTm9kZUJ5U291cmNlKHNvdXJjZSlcbiAgICAgICAgdGhpcy5fdGVtcE5vZGUgPSBuZXcgR2hvc3ROb2RlKCk7XG4gICAgICAgIGlmKGlzVGFpbCkge1xuICAgICAgICAgICAgdGhpcy5fdGVtcExpbmsgPSBsaW5rR2VuKHtcbiAgICAgICAgICAgICAgICBmcm9tOiB0aGlzLl90ZW1wTm9kZSxcbiAgICAgICAgICAgICAgICB0bzogcmVuZGVyTm9kZSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90ZW1wTGluayA9IGxpbmtHZW4oe1xuICAgICAgICAgICAgICAgIGZyb206IHJlbmRlck5vZGUsXG4gICAgICAgICAgICAgICAgdG86IHRoaXMuX3RlbXBOb2RlLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICBpbnN0YW5jZTogc291cmNlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1vZGUgPSBKRkxPV19NT0RFLkxJTktJTkc7XG4gICAgfVxuXG4gICAgaXNJbkxpbmtpbmdNb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09PSBKRkxPV19NT0RFLkxJTktJTkc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6L+e57q/5qih5byP5LiL77yM6K6+572u5b2T5YmN5Li05pe26L+e57q/55qE5bGe5oCnXG4gICAgICogQHBhcmFtIHtCYXNlTGlua35Db25maWdzfSBjb25maWdzIC0g5b2T5YmN6L+e57q/55qE5Ye65Y+R5Y6f5aeL5pWw5o2uXG4gICAgICovXG4gICAgc2V0TGlua2luZ0xpbmsoY29uZmlncykge1xuICAgICAgICBpZih0aGlzLm1vZGUgPT09IEpGTE9XX01PREUuTElOS0lORykge1xuICAgICAgICAgICAgdGhpcy5fdGVtcExpbmsuc2V0Q29uZmlnKGNvbmZpZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOi/nue6v+aooeW8j+S4i++8jOmHjei/nuWbnuS4tOaXtum8oOagh+iKgueCuVxuICAgICAqL1xuICAgIHJlc2V0TGlua2luZ0xpbmsoKSB7XG4gICAgICAgIGlmKHRoaXMubW9kZSA9PT0gSkZMT1dfTU9ERS5MSU5LSU5HKSB7XG4gICAgICAgICAgICB0aGlzLl90ZW1wTGluay5zZXRDb25maWcoe1xuICAgICAgICAgICAgICAgIHRvOiB0aGlzLl90ZW1wTm9kZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFyVGVtcCgpIHtcbiAgICAgICAgaWYodGhpcy5fdGVtcE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBOb2RlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBOb2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLl90ZW1wTGluaykge1xuICAgICAgICAgICAgdGhpcy5fdGVtcExpbmsuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5fdGVtcExpbmsgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgIH1cblxuICAgIHByZXZlbnRDbGVhclRlbXAoKSB7XG4gICAgICAgIHRoaXMuX3ByZXZlbnRDbGVhclRlbXAgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWkluWxguWuueWZqOWkp+Wwj+WPmOWMluWQju+8jOiwg+eUqOatpOaWueazleWPr+S7peaUueWPmOW9k+WJjWNhbnZhc+eahOeKtuaAgVxuICAgICAqL1xuICAgIHJlc2l6ZUNhbnZhcygpIHtcbiAgICAgICAgaWYodGhpcy5jYW52YXMgJiYgdGhpcy5ET013cmFwcGVyKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGNfd2lkdGgsIFxuICAgICAgICAgICAgICAgIGhlaWdodDogY19oZWlnaHQsIFxuICAgICAgICAgICAgICAgIHJhd193aWR0aCxcbiAgICAgICAgICAgICAgICByYXdfaGVpZ2h0LFxuICAgICAgICAgICAgfSA9IHJlc2l6ZUNhbnZhcyh0aGlzLmNhbnZhcywgdGhpcy5ET013cmFwcGVyKTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzTWV0YSA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogcmF3X3dpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcmF3X2hlaWdodCxcbiAgICAgICAgICAgICAgICBhY3R1YWxfd2lkdGg6IGNfd2lkdGgsXG4gICAgICAgICAgICAgICAgYWN0dWFsX2hlaWdodDogY19oZWlnaHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldEZvY3VzSW5zdGFuY2Uobm9kZSkge1xuICAgICAgICB0aGlzLl9mb2N1cy5pbnN0YW5jZSA9IG5vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog56e75Yqo55S75biD5Yiw5Lul55uu5qCH57uY5Zu+6IqC54K55Li65Lit5b+D55qE5L2N572u5LiKXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIC0g57uY5Zu+6IqC54K5XG4gICAgICovXG4gICAgZm9jdXNPbihub2RlKSB7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IHRoaXMuX2NhbGN1bGF0ZVBvaW50QmFjayhbXG4gICAgICAgICAgICB0aGlzLmNhbnZhc01ldGEuYWN0dWFsX3dpZHRoLzIsXG4gICAgICAgICAgICB0aGlzLmNhbnZhc01ldGEuYWN0dWFsX2hlaWdodC8yXG4gICAgICAgIF0pO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gbm9kZS5hbmNob3I7XG4gICAgICAgIGlmKG5vZGUuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24pIHtcbiAgICAgICAgICAgIG9mZnNldCA9IG5vZGUuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24ob2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlbHRhWCA9IChjZW50ZXJbMF0gLSBvZmZzZXRbMF0pICogdGhpcy5zY2FsZTtcbiAgICAgICAgY29uc3QgZGVsdGFZID0gKGNlbnRlclsxXSAtIG9mZnNldFsxXSkgKiB0aGlzLnNjYWxlO1xuICAgICAgICBcblxuICAgICAgICB0aGlzLl9yZWNhbGN1bGF0ZVBvc2l0aW9uKGRlbHRhWCwgZGVsdGFZKVxuICAgICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB9XG4gICAgXG4gICAgX2dldEJvdW5kaW5nR3JvdXBSZWN0KCkge1xuICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9zdGFjay5nZXRCb3VuZGluZ1JlY3RQb2ludHMoKTtcbiAgICAgICAgaWYodGhpcy5ib3VuZGluZ19ib3gpIHtcbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdfYm94ID0gYm91bmRpbmdfYm94KHBvaW50cyk7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgeDogbm93eCxcbiAgICAgICAgICAgICAgICB5OiBub3d5LFxuICAgICAgICAgICAgfSA9IHRoaXMuYm91bmRpbmdfYm94O1xuICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi54ID0gdGhpcy5wb3NpdGlvbi5vZmZzZXRYICsgbm93eCAqIHNjYWxlO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi55ID0gdGhpcy5wb3NpdGlvbi5vZmZzZXRZICsgbm93eSAqIHNjYWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ib3VuZGluZ19ib3ggPSBib3VuZGluZ19ib3gocG9pbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jcmVhdGVFdmVudEhhbmRsZXIoKSB7IFxuICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgICAgbGV0IGRlc3Ryb3lMaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5ldmVudEFkYXB0ZXIuYXBwbHkodGhpcyk7XG4gICAgICAgIGNvbnN0IGRlc3Ryb3lQbGFpbkV2ZW50TGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QWRhcHRlci51bmxvYWQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lEcHJMaXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgICAgIGRlc3Ryb3lMaXN0ZW5lciA9IGRlc3Ryb3lQbGFpbkV2ZW50TGlzdGVuZXI7XG5cbiAgICAgICAgaWYodGhpcy5hbGxvd0Ryb3ApIHtcbiAgICAgICAgICAgIGNvbnN0IGRyYWdvdmVySGFuZGxlciA9IHRoaXMuX29uRHJhZ292ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGRyb3BIYW5kbGVyID0gdGhpcy5fb25Ecm9wLmJpbmQodGhpcyk7XG4gICAgICAgICAgICBjb25zdCBkcmFnbGVhdmVIYW5sZGVyID0gdGhpcy5fb25EcmFnTGVhdmUuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIGRyYWdvdmVySGFuZGxlcik7XG4gICAgICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIGRyb3BIYW5kbGVyKTtcbiAgICAgICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLCBkcmFnbGVhdmVIYW5sZGVyKTtcbiAgICAgICAgICAgIGRlc3Ryb3lMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBkZXN0cm95UGxhaW5FdmVudExpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgZHJhZ292ZXJIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJvcCcsIGRyb3BIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ2xlYXZlJywgZHJhZ2xlYXZlSGFubGRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gXG4gICAgICAgIHRoaXMuZGVzdHJveSA9IGRlc3Ryb3lMaXN0ZW5lcjtcbiAgICB9XG5cbiAgICBfdGFyZ2V0TG9ja09uKG9mZnNldFBvaW50LCBldmVudCkge1xuICAgICAgICBsZXQgcG9pbnQgPSB0aGlzLl9jYWxjdWxhdGVQb2ludEJhY2sob2Zmc2V0UG9pbnQpO1xuICAgICAgICBjb25zdCB0b3BMYXllclBvaW50ID0gcG9pbnQ7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRwID0gcG9pbnQ7XG4gICAgICAgIGxldCBzdGFjayA9IHRoaXMuX3N0YWNrO1xuICAgICAgICBjb25zdCBiciA9IHRoaXMuX2dldFZpZXdCb3goKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gc3RhY2suY2hlY2tIaXQoXG4gICAgICAgICAgICBwb2ludCwgXG4gICAgICAgICAgICAvLyDlupTnlKjkuo7miYDmnIlcbiAgICAgICAgICAgIChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5fdGFyZ2V0LnN0YXR1cy5kcmFnZ2luZyBcbiAgICAgICAgICAgICAgICAgICAgJiYgKGluc3RhbmNlID09PSB0aGlzLl9nZXRNb3ZpbmdUYXJnZXQoKSkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8g5LuF5a+55LqO5pys5bGC6L+H5rukXG4gICAgICAgICAgICAoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9PdmVybGFwKGJyLCBpbnN0YW5jZS5nZXRCb3VuZGluZ1JlY3QoKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBsZXQgbGlua1N0YWNrID0gdGhpcy5fbGlua1N0YWNrO1xuICAgICAgICBsZXQgYmVsb25ncyA9IHRoaXM7XG4gICAgICAgIC8qXG4gICAgICAgIGlmKHRhcmdldCkge1xuICAgICAgICAgICAgbGlua1N0YWNrID0gdGFyZ2V0Ll9iZWxvbmdzLl9saW5rU3RhY2s7XG4gICAgICAgICAgICBwb2ludCA9IHRhcmdldC5fYmVsb25ncy5fY3VycmVudHA7XG4gICAgICAgICAgICBzdGFjayA9IHRhcmdldC5fYmVsb25ncy5fc3RhY2s7XG4gICAgICAgICAgICBiZWxvbmdzID0gdGFyZ2V0Ll9iZWxvbmdzXG4gICAgICAgIH0qL1xuICAgICAgICAvLyDmmoLml7borr7lrprlj6rmnInpobblsYLmnInov57nur9cbiAgICAgICAgbGV0IHRhcmdldExpbms7XG4gICAgICAgIGlmKCF0YXJnZXQgfHwgdGFyZ2V0Ll9iZWxvbmdzID09PSB0aGlzKSB7XG4gICAgICAgICAgICB0YXJnZXRMaW5rID0gbGlua1N0YWNrLmNoZWNrSGl0KHBvaW50LCAobGluaykgPT4ge1xuICAgICAgICAgICAgICAgIGlmKCF0aGlzLl90YXJnZXQuc3RhdHVzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbW92aW5ndGFyZ2V0ID0gdGhpcy5fZ2V0TW92aW5nVGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmsuZnJvbSA9PT0gbW92aW5ndGFyZ2V0IHx8IGxpbmsudG8gPT09IG1vdmluZ3RhcmdldDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmKCF0YXJnZXRMaW5rKSB7XG4gICAgICAgICAgICB0YXJnZXRMaW5rID0gbGlua1N0YWNrLmNoZWNrSGl0KHBvaW50LCAobGluaykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAhbGluay5PTl9UT1A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl90YXJnZXQsIHtcbiAgICAgICAgICAgIGluc3RhbmNlOiB0YXJnZXQsXG4gICAgICAgICAgICBsaW5rOiB0YXJnZXRMaW5rLCBcbiAgICAgICAgICAgIGlzSW5zdGFuY2VEaXJ0eTogdGFyZ2V0ID09PSB0aGlzLl90YXJnZXQuaW5zdGFuY2UsXG4gICAgICAgICAgICBpc0xpbmtEaXJ0eTogdGFyZ2V0TGluayA9PT0gdGhpcy5fdGFyZ2V0LmxpbmssXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3RhcmdldC5jYWNoZSwge1xuICAgICAgICAgICAgc3RhY2ssXG4gICAgICAgICAgICBiZWxvbmdzLFxuICAgICAgICAgICAgcG9pbnQsXG4gICAgICAgICAgICB0b3BMYXllclBvaW50LFxuICAgICAgICB9KVxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3RhcmdldC5tZXRhLCB7XG4gICAgICAgICAgICB4OiBvZmZzZXRQb2ludFswXSxcbiAgICAgICAgICAgIHk6IG9mZnNldFBvaW50WzFdLFxuICAgICAgICB9KTtcbiAgICAgXG4gICAgICAgIGlmKGV2ZW50ID09PSAncHJlc3NTdGFydCcgJiYgIXRoaXMuX3RhcmdldC5zdGF0dXMuZHJhZ2dpbmcgJiYgIXRoaXMuX3RhcmdldC5zdGF0dXMuZHJhZ292ZXJpbmcpIHtcbiAgICAgICAgICAgIGxldCBtb3Zpbmd0YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgICB3aGlsZSAobW92aW5ndGFyZ2V0ICYmIG1vdmluZ3RhcmdldC5fYmVsb25ncy5sb2NrICYmIG1vdmluZ3RhcmdldCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgIG1vdmluZ3RhcmdldCA9IG1vdmluZ3RhcmdldC5fYmVsb25ncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0TW92aW5nVGFyZ2V0cyhtb3Zpbmd0YXJnZXQgJiYgWyBtb3Zpbmd0YXJnZXQgXSlcbiAgICAgICAgICAgIGlmKG1vdmluZ3RhcmdldCkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICAgICAqIOW8gOWni+aLluaLveaXtu+8jOaLluaLveWvueixoeiuvue9ruS5i+WJjVxuICAgICAgICAgICAgICAgICAqIEBldmVudCBOb2RlI2FmdGVyUmVzb2x2ZU1vdmluZ1RhcmdldFxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtFdmVudH0gZXZlbnQgICAgICAgICAgIC0g5Y6f5aeL5LqL5Lu2IFxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SkZsb3d9IGpmbG93ICAgICAgICAgICAtIOW9k+WJjUpGbG935a+56LGhIFxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Tm9kZX0gdGFyZ2V0ICAgICAgICAgICAtIOebruagh+iKgueCuVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRhcmdldC5idWJibGVFdmVudChuZXcgSkZsb3dFdmVudCgnYWZ0ZXJSZXNvbHZlTW92aW5nVGFyZ2V0Jywge1xuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBtb3Zpbmd0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihbJ3ByZXNzU3RhcnQnLCAnY2xpY2snLCAnZGJsY2xpY2snLCAnY29udGV4dGNsaWNrJ10uaW5jbHVkZXMoZXZlbnQpKSB7XG4gICAgICAgICAgICBpZih0aGlzLl9mb2N1cy5pbnN0YW5jZSAmJiB0aGlzLl9mb2N1cy5pbnN0YW5jZSAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9jdXMuaW5zdGFuY2UuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnYmx1cicsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRlZFRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb2N1cy5pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICB9ICAgXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldDtcbiAgICB9XG5cbiAgICBibHVyKCkge1xuICAgICAgICBpZih0aGlzLl9mb2N1cy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5fZm9jdXMuaW5zdGFuY2UuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnYmx1cicsIHtcbiAgICAgICAgICAgICAgICByZWxhdGVkVGFyZ2V0OiBudWxsLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5fZm9jdXMuaW5zdGFuY2UgPSBudWxsO1xuICAgICAgICB9ICBcbiAgICB9XG5cbiAgICBfZ2V0TW92aW5nVGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0Lm1vdmluZyAmJiB0aGlzLl90YXJnZXQubW92aW5nWzBdO1xuICAgIH1cblxuICAgIF9wcm9jZXNzRHJhZ092ZXIoaW5zdGFuY2UsIGV2ZW50KSB7XG4gICAgICAgIGlmKHRoaXMuX2RyYWdPdmVyVGFyZ2V0ICE9PSBpbnN0YW5jZSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5yZWFkTWVzc2FnZSgpPy5pbnN0YW5jZTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdDdXJyZW50RGF0YSA9IHRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IHsgcG9pbnQgfSA9IHRoaXMuX3RhcmdldC5jYWNoZTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdfcHJvY2Vzc0RyYWdPdmVyJywgdGhpcy5fZHJhZ092ZXJUYXJnZXQpXG4gICAgICAgICAgICBpZih0aGlzLl9kcmFnT3ZlclRhcmdldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZElucyA9IHRoaXMuX2RyYWdPdmVyVGFyZ2V0O1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICogZHJhZ2xlYXZlIOmAgOWHuuS6i+S7tlxuICAgICAgICAgICAgICAgICogQGV2ZW50IEluc3RhbmNlI2RyYWdsZWF2ZVxuICAgICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IGV2ZW50ICAgICAgICAgICAtIOWOn+Wni+S6i+S7tiBcbiAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBpbnN0YW5jZSAgICAgICAtIGRyYWdsZWF2ZeeahOWvueixoSBcbiAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7dGFyZ2V0fSB0YXJnZXQgICAgICAgICAtIGRyYWcg5pC65bim55qE5a+56LGh77yI54m55oyH5LuO5aSW6Z2i5ouW6L+bY2FudmFz55qE5a+56LGh77yJIFxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgb2xkSW5zLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2RyYWdsZWF2ZScsIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBvbGRJbnMsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50LFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgKiBkcmFnZW50ZXIg6L+b5YWl5LqL5Lu2XG4gICAgICAgICAgICAgICAgKiBAZXZlbnQgSW5zdGFuY2UjZHJhZ2VudGVyXG4gICAgICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtFdmVudH0gZXZlbnQgICAgICAgICAgIC0g5Y6f5aeL5LqL5Lu2IFxuICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IGluc3RhbmNlICAgICAgIC0gZHJhZ2VudGVy55qE5a+56LGhIFxuICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHt0YXJnZXR9IHRhcmdldCAgICAgICAgIC0gZHJhZyDmkLrluKbnmoTlr7nosaHvvIjnibnmjIfku47lpJbpnaLmi5bov5tjYW52YXPnmoTlr7nosaHvvIkgXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdkcmFnZW50ZXInLCB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kcmFnT3ZlclRhcmdldCA9IGluc3RhbmNlO1xuICAgICAgICB9IGVsc2UgaWYodGhpcy5fZHJhZ092ZXJUYXJnZXQpe1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAqIGRyYWdvdmVyIOi/m+WFpeS6i+S7tlxuICAgICAgICAgICAgKiBAZXZlbnQgSW5zdGFuY2UjZHJhZ292ZXJcbiAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICogQHByb3BlcnR5IHtFdmVudH0gZXZlbnQgICAgICAgICAgIC0g5Y6f5aeL5LqL5Lu2IFxuICAgICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gaW5zdGFuY2UgICAgICAgLSBkcmFnb3ZlcueahOWvueixoSBcbiAgICAgICAgICAgICogQHByb3BlcnR5IHt0YXJnZXR9IHRhcmdldCAgICAgICAgIC0gZHJhZyDmkLrluKbnmoTlr7nosaHvvIjnibnmjIfku47lpJbpnaLmi5bov5tjYW52YXPnmoTlr7nosaHvvIkgXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fZHJhZ092ZXJUYXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnZHJhZ292ZXInLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLl9kcmFnQ3VycmVudERhdGEsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wcm9jZXNzUGFuSW5Cb3JkZXIoKTtcbiAgICB9XG5cbiAgICBfcHJvY2Vzc1BhbkluQm9yZGVyKCkge1xuICAgICAgICBpZih0aGlzLmRyYWdnaW5nYmVoYXZpb3I/LnBhbkluQm9yZGVyPy5lbmFibGUpIHtcbiAgICAgICAgICAgIGlmKCF0aGlzLmRyYWdnaW5nYmVoYXZpb3IucGFuSW5Cb3JkZXIudGltZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nYmVoYXZpb3IucGFuSW5Cb3JkZXIudGltZXIgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoRGF0ZS5ub3coKSAtIHRoaXMuZHJhZ2dpbmdiZWhhdmlvci5wYW5JbkJvcmRlci50aW1lciA+IDUwMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFt4LCB5LCB3LCBoXSA9IHRoaXMuX2NhY2hlVmlld0JveDtcbiAgICAgICAgICAgICAgICBjb25zdCBbcHgsIHB5XSA9IHRoaXMuX2N1cnJlbnRwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFtb3ZlbWVudFxuICAgICAgICAgICAgICAgIH0gPSB0aGlzLmRyYWdnaW5nYmVoYXZpb3IucGFuSW5Cb3JkZXI7XG4gICAgICAgICAgICAgICAgbGV0IGRlbHRhWCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGRlbHRhWSA9IDA7XG4gICAgICAgICAgICAgICAgaWYocHggPCB4ICsgcGFkZGluZykge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YVggPSBkZWx0YW1vdmVtZW50O1xuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgaWYocHggPiB3IC0gcGFkZGluZykge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YVggPSAtZGVsdGFtb3ZlbWVudDtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgIGlmKHB5IDwgeSArIHBhZGRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFZID0gZGVsdGFtb3ZlbWVudDtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgIGlmKHB5ID4gaCAtIHBhZGRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFZID0gLWRlbHRhbW92ZW1lbnQ7XG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9fcHJvY2Vzc092ZXJBbmltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fcHJvY2Vzc092ZXJBbmltZS5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoZGVsdGFYIHx8IGRlbHRhWSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fcHJvY2Vzc092ZXJBbmltZSA9IHRoaXMucmVxdWVzdEpGbG93QW5pbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYW5IYW5kbGVyKGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgICAgICAgICAgICAgICAgfSkgXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ2JlaGF2aW9yLnBhbkluQm9yZGVyLnRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfb25EcmFnb3ZlcihldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaWYodGhpcy5fbGFzdERyYWdTdGF0ZS5wcm9jZXNzaW5nKSByZXR1cm47XG4gICAgICAgIHRoaXMuX2xhc3REcmFnU3RhdGUucHJvY2Vzc2luZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnRcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl90YXJnZXQuc3RhdHVzLCB7XG4gICAgICAgICAgICBkcmFnb3ZlcmluZzogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5fdGFyZ2V0TG9ja09uKFtvZmZzZXRYLCBvZmZzZXRZXSlcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLl90YXJnZXQuaW5zdGFuY2UgfHwgdGhpcy5fdGFyZ2V0Lmxpbms7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NEcmFnT3ZlcihpbnN0YW5jZSwgZXZlbnQpO1xuICAgICAgICBpZih0aGlzLl90YXJnZXQuaXNMaW5rRGlydHkgfHwgdGhpcy5fdGFyZ2V0LmlzSW5zdGFuY2VEaXJ0eSkge1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5fcmVuZGVyKCk7ICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldC5pc0xpbmtEaXJ0eSA9IGZhbHNlOyBcbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXQuaXNJbnN0YW5jZURpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdERyYWdTdGF0ZS5wcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbGFzdERyYWdTdGF0ZS5wcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgIH0gXG4gICAgfVxuXG4gICAgX2NhbmNlbFBhbkluQm9yZGVyKCkge1xuICAgICAgICBpZih0aGlzLl9fcHJvY2Vzc092ZXJBbmltZSkge1xuICAgICAgICAgICAgdGhpcy5fX3Byb2Nlc3NPdmVyQW5pbWUuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5kcmFnZ2luZ2JlaGF2aW9yPy5wYW5JbkJvcmRlcikge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ2JlaGF2aW9yLnBhbkluQm9yZGVyLnRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9vbkRyYWdMZWF2ZSgpIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsUGFuSW5Cb3JkZXIoKTtcbiAgICB9XG5cbiAgICBfb25Ecm9wKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2NhbmNlbFBhbkluQm9yZGVyKCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB0aGlzLmNvbnN1bWVNZXNzYWdlKCk7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gcGF5bG9hZD8uaW5zdGFuY2U7XG4gICAgICAgIGlmKHRoaXMuX2RyYWdPdmVyVGFyZ2V0KSB7XG4gICAgICAgICAgICBjb25zdCBvbGRJbnMgPSB0aGlzLl9kcmFnT3ZlclRhcmdldDtcbiAgICAgICAgICAgIG9sZElucy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdkcmFnb3ZlcmVuZCcsIHtcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogb2xkSW5zLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ092ZXJUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGxpbmssXG4gICAgICAgICAgICBpbnN0YW5jZTogdGFyZ2V0LFxuICAgICAgICB9ID0gdGhpcy5fdGFyZ2V0O1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBwb2ludCwgYmVsb25nc1xuICAgICAgICB9ID0gdGhpcy5fdGFyZ2V0LmNhY2hlO1xuICAgICAgICBpZihsaW5rKSB7ICAgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOS4ouWcqOe6v+S4iuS6i+S7tlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBldmVudCBCYXNlTGluayNkcm9wXG4gICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtFdmVudH0gZXZlbnQgICAgICAgICAgIC0g5Y6f5aeL5LqL5Lu2IFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IGluc3RhbmNlICAgICAgIC0g5ouW5Yqo55qE5a+56LGhIFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtCYXNlTGlua30gbGluayAgICAgICAgIC0g55uu5qCH6L+e57q/IFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtKRmxvd30gamZsb3cgICAgICAgICAgIC0g5b2T5YmNSkZsb3flr7nosaEgXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0dyb3VwfEpGbG93fSBiZWxvbmdzICAgLSDov57nur/miYDlnKjnmoTnu5jlm77moIjnmoTlr7nosaFcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IHBvaW50ICAgICAgICAtIOW3sue7j+iuoeeul+WIsOe7mOWbvuagiOWvueW6lOWdkOagh+ezu+S4i+eahOWdkOagh1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBpbnN0YW5jZS5hbmNob3IgPSBwb2ludDtcbiAgICAgICAgICAgIGxpbmsuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnZHJvcCcsIHtcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBsaW5rLFxuICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgICAgIGJlbG9uZ3MsXG4gICAgICAgICAgICAgICAgcG9pbnRcbiAgICAgICAgICAgIH0pKVxuICAgICAgICB9IGVsc2UgaWYodGFyZ2V0KSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOS4ouWcqOiKgueCueS4iuS6i+S7tlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBldmVudCBOb2RlI2Ryb3BcbiAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0V2ZW50fSBldmVudCAgICAgICAgICAgLSDljp/lp4vkuovku7YgXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gaW5zdGFuY2UgICAgICAgLSDmi5bliqjnmoTlr7nosaEgXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0pGbG93fSBqZmxvdyAgICAgICAgICAgLSDlvZPliY1KRmxvd+WvueixoSBcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Tm9kZX0gdGFyZ2V0ICAgICAgICAgICAtIOebruagh+iKgueCuVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJbXX0gcG9pbnQgICAgICAgIC0g5bey57uP6K6h566X5Yiw57uY5Zu+5qCI5a+55bqU5Z2Q5qCH57O75LiL55qE5Z2Q5qCHXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRhcmdldC5idWJibGVFdmVudChuZXcgSkZsb3dFdmVudCgnZHJvcCcsIHtcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgcG9pbnQsXG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgKiDkuKLlnKjkuLvlm77kuIrkuovku7ZcbiAgICAgICAgICAgICpcbiAgICAgICAgICAgICogQGV2ZW50IEpGbG93I2Ryb3BcbiAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICogQHByb3BlcnR5IHtFdmVudH0gZXZlbnQgICAgICAgICAgIC0g5Y6f5aeL5LqL5Lu2IFxuICAgICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gaW5zdGFuY2UgICAgICAgLSDmi5bliqjnmoTlr7nosaEgXG4gICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SkZsb3d9IGpmbG93ICAgICAgICAgICAtIOW9k+WJjUpGbG935a+56LGhIFxuICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcltdfSBwb2ludCAgICAgICAgLSDlt7Lnu4/orqHnrpfliLDnu5jlm77moIjlr7nlupTlnZDmoIfns7vkuIvnmoTlnZDmoIdcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2Ryb3AnLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHBvaW50LFxuICAgICAgICAgICAgfSkpXG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsRHJvcCgpO1xuICAgICAgICB9KVxuICAgIH1cbiAgICBjYW5jZWxEcm9wKCkge1xuICAgICAgICB0aGlzLl90YXJnZXQuaW5zdGFuY2UgPSBudWxsO1xuICAgICAgICB0aGlzLl90YXJnZXQubGluayA9IG51bGw7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fdGFyZ2V0LnN0YXR1cywge1xuICAgICAgICAgICAgZHJhZ292ZXJpbmc6IGZhbHNlLFxuICAgICAgICB9KVxuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiDnvKnmlL7mk43kvZzlpITnkIblh73mlbBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0WCAtIOS6i+S7tuWvueixoeS4jmNhbnZhc+eahOWGheWhq+WFhei+ue+8iHBhZGRpbmcgZWRnZe+8ieWcqCBYIOi9tOaWueWQkeS4iueahOWBj+enu+mHj+OAglxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRZIC0g5LqL5Lu25a+56LGh5LiOY2FudmFz55qE5YaF5aGr5YWF6L6577yIcGFkZGluZyBlZGdl77yJ5ZyoIFkg6L205pa55ZCR5LiK55qE5YGP56e76YeP44CCIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVggIC0g5rC05bmz5rua5Yqo6YePXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWSAgLSDlnoLnm7Tmu5rliqjph49cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQgLSDljp/nlJ/kuovku7ZcbiAgICAgKi9cbiAgICB6b29tSGFuZGxlcihvZmZzZXRYLCBvZmZzZXRZLCBkZWx0YVgsIGRlbHRhWSwgZXZlbnQpIHtcbiAgICAgICAgLy8gaWYoIXRoaXMuX2FsbG93Wm9vbSkgcmV0dXJuO1xuICAgICAgICBpZih0aGlzLl96b29taW5nKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3pvb21pbmcgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IHdpZHRoOiBwX3dpZHRoLCBoZWlnaHQ6IHBfaGVpZ2h0LCB4LCB5IH0gPSB0aGlzLmJvdW5kaW5nX2JveDtcbiAgICAgICAgY29uc3QgeyBhY3R1YWxfd2lkdGg6IGN3LCBhY3R1YWxfaGVpZ2h0OiBjaCB9ID0gdGhpcy5jYW52YXNNZXRhO1xuICAgICAgICBsZXQgbWluWm9vbSA9IHRoaXMubWluWm9vbTtcbiAgICAgICAgaWYodGhpcy53b3JsZE1hcmdpbikge1xuICAgICAgICAgICAgY29uc3QgbSA9IHRoaXMud29ybGRNYXJnaW47XG4gICAgICAgICAgICBjb25zdCBtYXhXaWR0aCA9IHBfd2lkdGggKyBtICogMjtcbiAgICAgICAgICAgIGNvbnN0IG1heEhlaWdodCA9IHBfaGVpZ2h0ICsgbSAqIDI7XG4gICAgICAgICAgICBtaW5ab29tID0gTWF0aC5tYXgobWluWm9vbSwgTWF0aC5tYXgoY3cgLyBtYXhXaWR0aCwgY2ggLyBtYXhIZWlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3U2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgICBjb25zdCBhbW91bnQgPSBkZWx0YVkgPiAwID8gMS4wNSA6IDEgLyAxLjA1O1xuICAgICAgICBuZXdTY2FsZSAqPSBhbW91bnQ7XG4gICAgICAgIG5ld1NjYWxlID0gTWF0aC5taW4odGhpcy5tYXhab29tLCBNYXRoLm1heChtaW5ab29tLCBuZXdTY2FsZSkpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKG5ld1NjYWxlKTtcbiAgICAgICAgLy8gaWYgKHRoaXMubWF4Wm9vbSAmJiBuZXdTY2FsZSA+IHRoaXMubWF4Wm9vbSl7XG4gICAgICAgIC8vICAgICAvLyBjb3VsZCBqdXN0IHJldHVybiBidXQgdGhlbiB3b24ndCBzdG9wIGV4YWN0bHkgYXQgbWF4Wm9vbVxuICAgICAgICAvLyAgICAgbmV3U2NhbGUgPSB0aGlzLm1heFpvb207XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBpZih0aGlzLm1pblpvb20gJiYgbmV3U2NhbGUgPCB0aGlzLm1pblpvb20pIHtcbiAgICAgICAgLy8gICAgIG5ld1NjYWxlID0gdGhpcy5taW5ab29tO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgdmFyIGRlbHRhU2NhbGUgICAgPSBuZXdTY2FsZSAtIHRoaXMuc2NhbGU7XG4gICAgICAgIHZhciBjdXJyZW50V2lkdGggID0gcF93aWR0aCAqIHRoaXMuc2NhbGU7XG4gICAgICAgIHZhciBjdXJyZW50SGVpZ2h0ID0gcF9oZWlnaHQgKiB0aGlzLnNjYWxlO1xuICAgICAgICB2YXIgZGVsdGFXaWR0aCAgICA9IHBfd2lkdGggKiBkZWx0YVNjYWxlO1xuICAgICAgICB2YXIgZGVsdGFIZWlnaHQgICA9IHBfaGVpZ2h0ICogZGVsdGFTY2FsZTtcblxuICAgICAgICB2YXIgdFggPSBvZmZzZXRYIC0gdGhpcy5wb3NpdGlvbi54O1xuICAgICAgICB2YXIgdFkgPSBvZmZzZXRZIC0gdGhpcy5wb3NpdGlvbi55O1xuICAgICAgICB2YXIgcFggPSAtdFggLyBjdXJyZW50V2lkdGg7XG4gICAgICAgIHZhciBwWSA9IC10WSAvIGN1cnJlbnRIZWlnaHQ7XG5cbiAgICAgICAgdGhpcy5zY2FsZSA9IG5ld1NjYWxlO1xuICAgICAgICB0aGlzLl9yZWNhbGN1bGF0ZVBvc2l0aW9uKHBYICogZGVsdGFXaWR0aCwgcFkgKiBkZWx0YUhlaWdodCk7XG4gICAgICAgIFxuICAgICAgICAvLyB0aGlzLnBvc2l0aW9uLnggKz0gcFggKiBkZWx0YVdpZHRoO1xuICAgICAgICAvLyB0aGlzLnBvc2l0aW9uLnkgKz0gcFkgKiBkZWx0YUhlaWdodDtcbiAgICAgICAgLy8gdGhpcy5wb3NpdGlvbi5vZmZzZXRYID0gdGhpcy5wb3NpdGlvbi54IC0geCAqIG5ld1NjYWxlO1xuICAgICAgICAvLyB0aGlzLnBvc2l0aW9uLm9mZnNldFkgPSB0aGlzLnBvc2l0aW9uLnkgLSB5ICogbmV3U2NhbGU7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnem9vbXBhbicsIHtcbiAgICAgICAgICAgICBkZWx0YVg6IDAsIGRlbHRhWTogMFxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIHRoaXMuc2V0QW5pbWVDbG9jaygpXG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fem9vbWluZyA9IGZhbHNlO1xuICAgICAgICB9KVxuICAgICAgICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHRpbWVzdGFtcCkgPT4ge1xuICAgICAgICAvLyAgICAgdGhpcy5zZXRBbmltZUNsb2NrKHRpbWVzdGFtcCk7XG4gICAgICAgIC8vICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICAgICAgLy8gICAgIHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gfSlcbiAgICB9XG4gICAgLyoqXG4gICAgICog5bmz56e755S75biD5pON5L2c5aSE55CG5Ye95pWwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWCAgLSDmsLTlubPmu5rliqjph49cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFZICAtIOWeguebtOa7muWKqOmHj1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudCAtIOWOn+eUn+S6i+S7tlxuICAgICAqL1xuICAgIHBhbkhhbmRsZXIoZGVsdGFYLCBkZWx0YVksIGV2ZW50KSB7XG4gICAgICAgIGlmKHRoaXMuX3Bhbm5pbmcpIHJldHVybjtcbiAgICAgICAgdGhpcy5fcGFubmluZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGRyYWdnaW5nLFxuICAgICAgICB9ID0gdGhpcy5fdGFyZ2V0LnN0YXR1cztcbiAgICAgICAgaWYoZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdmluZ3RhcmdldCA9IHRoaXMuX3RhcmdldC5tb3Zpbmc7XG4gICAgICAgICAgICBpZihtb3Zpbmd0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmRyYWdnaW5nYmVoYXZpb3IucGFuSW5Cb3JkZXIuYWxsb3dNb3ZpbmdUYXJnZXRJblBhbikge1xuICAgICAgICAgICAgICAgICAgICBtb3Zpbmd0YXJnZXQuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuYW5jaG9yWzBdICs9IC1kZWx0YVggLyB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdC5hbmNob3JbMV0gKz0gLWRlbHRhWSAvIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVjYWxjdWxhdGVQb3NpdGlvbihkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnvKnmlL7lubPnp7vkuovku7ZcbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IEpGbG93I3pvb21wYW5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCd6b29tcGFuJywge1xuICAgICAgICAgICAgZGVsdGFYLFxuICAgICAgICAgICAgZGVsdGFZXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wYW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH0pXG4gICAgICAgIC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSgodGltZXN0YW1wKSA9PiB7XG4gICAgICAgIC8vICAgICB0aGlzLnNldEFuaW1lQ2xvY2sodGltZXN0YW1wKTtcbiAgICAgICAgLy8gICAgIHRoaXMuX3JlbmRlcigpO1xuICAgICAgICAvLyAgICAgdGhpcy5fcGFubmluZyA9IGZhbHNlO1xuICAgICAgICAvLyB9KVxuICAgIH1cbiAgICAvKipcbiAgICAgKiDlvIDlp4vmjInljovlpITnkIblh73mlbBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0WCAtIOS6i+S7tuWvueixoeS4jmNhbnZhc+eahOWGheWhq+WFhei+ue+8iHBhZGRpbmcgZWRnZe+8ieWcqCBYIOi9tOaWueWQkeS4iueahOWBj+enu+mHj+OAglxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRZIC0g5LqL5Lu25a+56LGh5LiOY2FudmFz55qE5YaF5aGr5YWF6L6577yIcGFkZGluZyBlZGdl77yJ5ZyoIFkg6L205pa55ZCR5LiK55qE5YGP56e76YeP44CCIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudCAtIOWOn+eUn+S6i+S7tlxuICAgICAqL1xuICAgIHByZXNzU3RhcnRIYW5kbGVyKG9mZnNldFgsIG9mZnNldFksIGV2ZW50KSB7XG4gICAgICAgIGlmKHRoaXMuY2hlY2tTY3JvbGxEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl90YXJnZXQubWV0YSwge1xuICAgICAgICAgICAgaW5pdGlhbFg6IG9mZnNldFgsXG4gICAgICAgICAgICBpbml0aWFsWTogb2Zmc2V0WSxcbiAgICAgICAgfSlcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgbGluayxcbiAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgIH0gPSB0aGlzLl90YXJnZXRMb2NrT24oW29mZnNldFgsIG9mZnNldFldLCAncHJlc3NTdGFydCcpO1xuICAgICAgICAvLyDlkI7nu63lj6rmlK/mjIEgY2xpY2sg5Yqo5L2cXG4gICAgICAgIGlmKHRoaXMubW9kZSA9PT0gSkZMT1dfTU9ERS5MSU5LSU5HKSByZXR1cm47XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fdGFyZ2V0LnN0YXR1cywge1xuICAgICAgICAgICAgZHJhZ2dpbmc6IHRydWUsXG4gICAgICAgICAgICBwcm9jZXNzaW5nOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmKHRoaXMuX3RhcmdldC5tb3ZpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdmluZyA9IHRoaXMuX2dldE1vdmluZ1RhcmdldCgpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDlvIDlp4vmi5bliqjnu4TnmoTkuovku7bvvIjnibnmjIdsb2Nr55qE6aG25bGC57uE77yJXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV2ZW50IE5vZGUjcHJlc3NTdGFydFxuICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IGV2ZW50ICAgICAgICAgICAtIOWOn+Wni+S6i+S7tiBcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Tm9kZX0gaW5zdGFuY2UgICAgICAgLSDmi5bliqjnmoTlr7nosaEgXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0pGbG93fSBqZmxvdyAgICAgICAgICAgLSDlvZPliY1KRmxvd+WvueixoSBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbW92aW5nLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ3ByZXNzU3RhcnQnLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IG1vdmluZyxcbiAgICAgICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgIH0pKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLl9yZXNvbHZlTG9ja09uVGFyZ2V0KGxpbmssIGluc3RhbmNlKVxuICAgICAgICBpZih0KSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOW8gOWni+aLluWKqOWvueixoeS6i+S7tu+8iOWwseaYr+ebruagh+WvueixoeeahOaLluWKqOS6i+S7tu+8jOS6i+S7tuaUr+aMgeWGkuazoe+8iVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBldmVudCBOb2RlI2luc3RhbmNlUHJlc3NTdGFydFxuICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IGV2ZW50ICAgICAgICAgICAtIOWOn+Wni+S6i+S7tiBcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Tm9kZX0gaW5zdGFuY2UgICAgIC0g5ouW5Yqo55qE5a+56LGhIFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtKRmxvd30gamZsb3cgICAgICAgICAgIC0g5b2T5YmNSkZsb3flr7nosaEgXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGJ1YmJsZXMgICAgICAgLSDlhpLms6FcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gY29uc3QgdCA9IHRoaXMuX3RhcmdldC5pbnN0YW5jZTtcbiAgICAgICAgICAgIHQuYnViYmxlRXZlbnQobmV3IEpGbG93RXZlbnQoJ2luc3RhbmNlUHJlc3NTdGFydCcsIHtcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHQsXG4gICAgICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmV2ZW50UHJlc3NTZXF1ZWVuY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGVhclRhcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmV2ZW50UHJlc3NTZXF1ZWVuY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICB9XG4gICAgICAgIGlmKCF0aGlzLl9wcmV2ZW50UHJlc3NTZXF1ZWVuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnamZsb3dQcmVzc1N0YXJ0Jywge1xuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOaMieWOi+S4reWkhOeQhuWHveaVsFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRYIC0g5LqL5Lu25a+56LGh5LiOY2FudmFz55qE5YaF5aGr5YWF6L6577yIcGFkZGluZyBlZGdl77yJ5ZyoIFgg6L205pa55ZCR5LiK55qE5YGP56e76YeP44CCXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFkgLSDkuovku7blr7nosaHkuI5jYW52YXPnmoTlhoXloavlhYXovrnvvIhwYWRkaW5nIGVkZ2XvvInlnKggWSDovbTmlrnlkJHkuIrnmoTlgY/np7vph4/jgIIgXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50IC0g5Y6f55Sf5LqL5Lu2XG4gICAgICovXG4gICAgcHJlc3NNb3ZlSGFuZGxlcihvZmZzZXRYLCBvZmZzZXRZLCBldmVudCkge1xuICAgICAgICBpZih0aGlzLl9wcmV2ZW50UHJlc3NTZXF1ZWVuY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLmNoZWNrU2Nyb2xsRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGRyYWdnaW5nLCBwcm9jZXNzaW5nXG4gICAgICAgIH0gPSB0aGlzLl90YXJnZXQuc3RhdHVzO1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMuX3RhcmdldC5tZXRhO1xuICAgICAgICAvLyB0aGlzLmNhbnZhcy5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgICAgIGlmKCFkcmFnZ2luZykge1xuICAgICAgICAgICAgaWYodGhpcy5jaGVja1Njcm9sbEJhckhvdmVyKG9mZnNldFgsIG9mZnNldFkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0U2Nyb2xsQmFySG92ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIWRyYWdnaW5nICYmICFwcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgbGluayxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICAgfSA9IHRoaXMuX3RhcmdldExvY2tPbihbb2Zmc2V0WCwgb2Zmc2V0WV0pO1xuICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMuX3Jlc29sdmVMb2NrT25UYXJnZXQobGluaywgaW5zdGFuY2UpO1xuICAgICAgICAgICAgaWYodCkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICogaW5zdGFuY2UgbW91c2Vtb3ZlIOWOn+eUn+S6i+S7tu+8jOS7heWcqOaXoOaLluaLveaXtuinpuWPkVxuICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAqIEBldmVudCBOb2RlI2luc3RhbmNlbW91c2Vtb3ZlXG4gICAgICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtFdmVudH0gZXZlbnQgICAgICAgICAgIC0g5Y6f5aeL5LqL5Lu2XG4gICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge05vZGV9IGluc3RhbmNlICAgICAgICAgICAtIOWOn+Wni+S6i+S7tlxuICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtKRmxvd30gamZsb3cgICAgICAgICAgIC0g5b2T5YmNSkZsb3flr7nosaEgXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAvLyBpbnN0YW5jZS5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdpbnN0YW5jZW1vdXNlbW92ZScsIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgLy8gICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgIC8vICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgICAgICAvLyB9KSlcbiAgICAgICAgICAgICAgICB0LmJ1YmJsZUV2ZW50KG5ldyBKRmxvd0V2ZW50KCdpbnN0YW5jZW1vdXNlbW92ZScsIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0LFxuICAgICAgICAgICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdpbnN0YW5jZW1vdXNlbW92ZScsIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcblxuICAgICAgICAgICAgaWYodGhpcy5tb2RlID09PSBKRkxPV19NT0RFLkxJTktJTkcpIHtcbiAgICAgICAgICAgICAgICAvLyBpZihpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIC8vICAgICBpbnN0YW5jZS5idWJibGVFdmVudChuZXcgSkZsb3dFdmVudCgnbGlua2luZycsIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgdGFyZ2V0OiBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGNhbGxiYWNrOiAocCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRwID0gcDtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgICAgfSkpXG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcE5vZGUuYW5jaG9yID0gdGhpcy5fY3VycmVudHA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldC5pc0xpbmtEaXJ0eSA9IGZhbHNlOyBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LmlzSW5zdGFuY2VEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXQuc3RhdHVzLnByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NQYW5JbkJvcmRlcigpO1xuICAgICAgICAgICAgICAgIC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSgodGltZXN0YW1wKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gICAgIHRoaXMuc2V0QW5pbWVDbG9jayh0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgIC8vICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5fdGFyZ2V0LmlzTGlua0RpcnR5ID0gZmFsc2U7IFxuICAgICAgICAgICAgICAgIC8vICAgICB0aGlzLl90YXJnZXQuaXNJbnN0YW5jZURpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gICAgIHRoaXMuX3RhcmdldC5zdGF0dXMucHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIH0pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjYW52YXMgbW91c2Vtb3ZlIOWOn+eUn+S6i+S7tlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgSkZsb3cjY2FudmFzbW91c2Vtb3ZlXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IGV2ZW50ICAgICAgICAgICAtIOWOn+Wni+S6i+S7tlxuICAgICAgICAgKiBAcHJvcGVydHkge0pGbG93fSBqZmxvdyAgICAgICAgICAgLSDlvZPliY1KRmxvd+WvueixoSBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnY2FudmFzbW91c2Vtb3ZlJywge1xuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgfSkpXG5cbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBpZighZHJhZ2dpbmcpIHJldHVybjtcbiAgICAgICAgLy8gdGhpcy5jYW52YXMuc3R5bGUuY3Vyc29yID0gJ2dyYWJiaW5nJztcbiAgICAgICAgaWYocHJvY2Vzc2luZykgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgbW92aW5ndGFyZ2V0ID0gdGhpcy5fdGFyZ2V0Lm1vdmluZzsvLyB0aGlzLl90ZW1wTm9kZSA/IFt0aGlzLl90ZW1wTm9kZV0gOiB0aGlzLl90YXJnZXQubW92aW5nO1xuICAgICAgICB0aGlzLl90YXJnZXQuc3RhdHVzLm1vdmluZ1N0YXRlID0gdHJ1ZVxuICAgICAgICB0aGlzLl90YXJnZXQuc3RhdHVzLnByb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgICBjb25zdCBkZWx0YVggPSBvZmZzZXRYIC0geDtcbiAgICAgICAgY29uc3QgZGVsdGFZID0gb2Zmc2V0WSAtIHk7XG4gICAgICAgIGlmKG1vdmluZ3RhcmdldCkge1xuICAgICAgICAgICAgaWYodGhpcy5fYWxsb3dNb3ZpbmdUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBtb3Zpbmd0YXJnZXQuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdC5hbmNob3JbMF0gKz0gZGVsdGFYIC8gdGhpcy5zY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgdC5hbmNob3JbMV0gKz0gZGVsdGFZIC8gdGhpcy5zY2FsZTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVjYWxjdWxhdGVQb3NpdGlvbihkZWx0YVgsIGRlbHRhWSk7ICAgIFxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCd6b29tcGFuJywge1xuICAgICAgICAgICAgICAgIGRlbHRhWCwgZGVsdGFZXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpbnN0YW5jZSwgbGluayB9ID0gdGhpcy5fdGFyZ2V0TG9ja09uKFtvZmZzZXRYLCBvZmZzZXRZXSk7XG5cbiAgICAgICAgdGhpcy5fcHJvY2Vzc0RyYWdPdmVyKGluc3RhbmNlIHx8IGxpbmssIGV2ZW50KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LmlzTGlua0RpcnR5ID0gZmFsc2U7IFxuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LmlzSW5zdGFuY2VEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LnN0YXR1cy5wcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgIH0pXG4gICAgICAgIC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSgodGltZXN0YW1wKSA9PiB7XG4gICAgICAgIC8vICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICAgICAgLy8gICAgIHRoaXMuX3RhcmdldC5pc0xpbmtEaXJ0eSA9IGZhbHNlOyBcbiAgICAgICAgLy8gICAgIHRoaXMuX3RhcmdldC5pc0luc3RhbmNlRGlydHkgPSBmYWxzZTtcbiAgICAgICAgLy8gICAgIHRoaXMuX3RhcmdldC5zdGF0dXMucHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICAvLyB9KVxuICAgIH1cbiAgICAvKipcbiAgICAgKiDmjInljovnu5PmnZ/lpITnkIblh73mlbBcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRG9jdW1lbnQgLSDmmK/lkKbkuLogZG9jdW1lbnQg6Kem5Y+RXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50IC0g5Y6f55Sf5LqL5Lu2XG4gICAgICovXG4gICAgcHJlc3NVcEhhbmxkZXIoaXNEb2N1bWVudCwgZXZlbnQpIHtcbiAgICAgICAgaWYodGhpcy5fcHJldmVudFByZXNzU2VxdWVlbmNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKHRoaXMuX19wcm9jZXNzT3ZlckFuaW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9fcHJvY2Vzc092ZXJBbmltZS5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kcmFnT3ZlclRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NhbmNlbFBhbkluQm9yZGVyKCk7XG4gICAgICAgIC8vIHRoaXMucmVzZXRTY29sbEJhclN0YXR1cygpO1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fdGFyZ2V0Lm1ldGE7XG4gICAgICAgIGlmKHRoaXMubW9kZSA9PT0gSkZMT1dfTU9ERS5MSU5LSU5HKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0gdGhpcy5fdGFyZ2V0Lmluc3RhbmNlO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMuY29uc3VtZU1lc3NhZ2UoKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHBheWxvYWQpXG4gICAgICAgICAgICBsZXQgX3ByZXZlbnREZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBwcmV2ZW50RGVmYXVsdCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBfcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIGlmKHQpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBjYW52YXMgbW91c2Vtb3ZlIOWOn+eUn+S6i+S7tlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQGV2ZW50IE5vZGUjbGlua1xuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtFdmVudH0gZXZlbnQgICAgICAgICAgIC0g5Y6f5aeL5LqL5Lu2XG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtOb2RlfSB0YXJnZXQgICAgICAgICAgIC0g5Y6f5aeL5LqL5Lu2XG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtvYmplY3R9IHBheWxvYWQgICAgICAgIC0g5Lyg5YWl55qE5raI5oGvXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtKRmxvd30gamZsb3cgICAgICAgICAgIC0g5b2T5YmNSkZsb3flr7nosaEgICAgICAgLSDlvZPliY1KRmxvd+WvueixoSBcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0LmJ1YmJsZUV2ZW50KG5ldyBKRmxvd0V2ZW50KCdsaW5rJywge1xuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0LFxuICAgICAgICAgICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbGluazogdGhpcy5fdGVtcExpbmssXG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0LFxuICAgICAgICAgICAgICAgIH0pKSAgICAgICAgXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnRcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2xpbmsnLCB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yOiB0aGlzLl9jYWxjdWxhdGVQb2ludEJhY2soW29mZnNldFgsIG9mZnNldFldKSxcbiAgICAgICAgICAgICAgICAgICAgbGluazogdGhpcy5fdGVtcExpbmssXG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoX3ByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2xlYXJUYXJnZXQoKTtcbiAgICAgICAgICAgIGlmKCF0aGlzLl9wcmV2ZW50Q2xlYXJUZW1wKSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5fdGVtcE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcE5vZGUuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wTm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX3RlbXBMaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBMaW5rLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcExpbmsgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByZXZlbnRDbGVhclRlbXAgPSBmYWxzZVxuICAgICAgICAgICAgdGhpcy5tb2RlID0gSkZMT1dfTU9ERS5ERUZBVUxUO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKHRoaXMuX3RhcmdldC5tb3ZpbmcpIHtcbiAgICAgICAgICAgIGxldCBjaGVja3Jlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYodGhpcy5fbGF5b3V0LnN0YXRpYykge1xuICAgICAgICAgICAgICAgIGNoZWNrcmVzdWx0ID0gdGhpcy5zdGF0aWNDaGVjayh0aGlzLl9nZXRNb3ZpbmdUYXJnZXQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCFjaGVja3Jlc3VsdCAmJiB0aGlzLl90YXJnZXQubGluaykge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQsIGJlbG9uZ3NcbiAgICAgICAgICAgICAgICB9ID0gdGhpcy5fdGFyZ2V0LmNhY2hlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLl90YXJnZXQubGluaztcbiAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuX2dldE1vdmluZ1RhcmdldCgpO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIOaLluWKqOWIsOe6v+S4iuS6i+S7tlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQGV2ZW50IEJhc2VMaW5rI2Ryb3BcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IGV2ZW50ICAgICAgICAgICAtIOWOn+Wni+S6i+S7tiBcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gaW5zdGFuY2UgICAgIC0g5ouW5Yqo55qE5a+56LGhIFxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QmFzZUxpbmt9IGxpbmsgICAgICAgICAtIOebruagh+i/nue6vyBcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0pGbG93fSBqZmxvdyAgICAgICAgICAgLSDlvZPliY1KRmxvd+WvueixoSBcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0dyb3VwfEpGbG93fSBiZWxvbmdzICAgLSDov57nur/miYDlnKjnmoTnu5jlm77moIjnmoTlr7nosaFcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBsaW5rLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2Ryb3AnLCB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgbGluayxcbiAgICAgICAgICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGJlbG9uZ3MsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldC5saW5rID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXQuaW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHRoaXMuX3RhcmdldC5tb3ZpbmcpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLl90YXJnZXQuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIOaLluWKqOWQjuaUvue9ruWIsCBJbnN0YW5jZSDkuIrnmoTkuovku7bvvIznlLHooqvmi5bliqjliLDnmoTlr7nosaHop6blj5FcbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogQGV2ZW50IE5vZGUjcHJlc3NFbmRcbiAgICAgICAgICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtFdmVudH0gZXZlbnQgICAgICAgICAgIC0g5Y6f5aeL5LqL5Lu2IFxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge05vZGV9IGluc3RhbmNlICAgICAgICAgLSDmi5bliqjnmoTlr7nosaEgXG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SkZsb3d9IGpmbG93ICAgICAgICAgICAtIOW9k+WJjUpGbG935a+56LGhIFxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0luc3RhbmNlfSB0YXJnZXQgICAgICAgLSDmi5bliqjliLDnmoTlr7nosaFcbiAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtib29sZWFufSBidWJibGVzICAgICAgIC0g5YaS5rOhXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAvLyAgY29uc29sZS5sb2coJ3ByZXNzRW5kJywgdGhpcy5fdGFyZ2V0Lmluc3RhbmNlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXQuaW5zdGFuY2UuYnViYmxlRXZlbnQobmV3IEpGbG93RXZlbnQoJ3ByZXNzRW5kJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZTogdGhpcy5fZ2V0TW92aW5nVGFyZ2V0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy5fdGFyZ2V0Lmluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIOaLluWKqOWQjuaUvue9ruWIsOS4u+WbvuS4iueahOS6i+S7tlxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBAZXZlbnQgSkZsb3cjcHJlc3NFbmRcbiAgICAgICAgICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtFdmVudH0gZXZlbnQgICAgICAgICAgIC0g5Y6f5aeL5LqL5Lu2IFxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0luc3RhbmNlfSBpbnN0YW5jZSAgICAgICAtIOaLluWKqOeahOWvueixoSBcbiAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtKRmxvd30gamZsb3cgICAgICAgICAgIC0g5b2T5YmNSkZsb3flr7nosaEgXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ3ByZXNzRW5kJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZTogdGhpcy5fZ2V0TW92aW5nVGFyZ2V0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0Lm1vdmluZyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVRlbXBEcmFnZ2luZ0luc3RhbmNlKClcbiAgICAgICAgICAgIC8vIHRoaXMuX3RhcmdldC5pc01vdmluZ0RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbGVhclRhcmdldCgpO1xuICAgIH1cbiAgICAgLyoqXG4gICAgICog6I+c5Y2V5by55Ye65aSE55CG5Ye95pWwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFggLSDkuovku7blr7nosaHkuI5jYW52YXPnmoTlhoXloavlhYXovrnvvIhwYWRkaW5nIGVkZ2XvvInlnKggWCDovbTmlrnlkJHkuIrnmoTlgY/np7vph4/jgIJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0WSAtIOS6i+S7tuWvueixoeS4jmNhbnZhc+eahOWGheWhq+WFhei+ue+8iHBhZGRpbmcgZWRnZe+8ieWcqCBZIOi9tOaWueWQkeS4iueahOWBj+enu+mHj+OAgiBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQgLSDljp/nlJ/kuovku7ZcbiAgICAgKi9cbiAgICBjbGlja0hhbmxkZXIob2Zmc2V0WCwgb2Zmc2V0WSwgZXZlbnQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgbGluayxcbiAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgbWV0YVxuICAgICAgICB9ID0gdGhpcy5fdGFyZ2V0TG9ja09uKFtvZmZzZXRYLCBvZmZzZXRZXSwgJ2NsaWNrJyk7XG4gICAgICAgIGlmKE1hdGguYWJzKG1ldGEuaW5pdGlhbFggLSBtZXRhLngpIDwgMVxuICAgICAgICAgICAgJiYgTWF0aC5hYnMobWV0YS5pbml0aWFsWSAtIG1ldGEueSkgPCAxKSB7IFxuICAgICAgICAgICAgICAgIGlmKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5jYW52YXMpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGVhclRhcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3RhcmdldC5tZXRhLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsWDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFk6IHVuZGVmaW5lZCwgXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdG9wTGF5ZXJQb2ludCB9ID0gdGhpcy5fdGFyZ2V0LmNhY2hlXG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMuX3Jlc29sdmVMb2NrT25UYXJnZXQobGluaywgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIGlmKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdDtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIOeCueWHu+S6i+S7tu+8iOWGkuazoe+8iVxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBAZXZlbnQgSW5zdGFuY2UjY29udGV4dGNsaWNrXG4gICAgICAgICAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IGV2ZW50ICAgICAgICAgICAtIOWOn+Wni+S6i+S7tiBcbiAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtJbnN0YW5jZX0gdGFyZ2V0ICAgICAgIC0g5Y+z6ZSu5a+56LGhIFxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0pGbG93fSBqZmxvdyAgICAgICAgICAgLSDlvZPliY1KRmxvd+WvueixoVxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcltdfSB0b3BMYXllclBvaW50ICAtIGpmbG935Z2Q5qCH57O75LiK55qE5L2N572uXG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gYnViYmxlcyAgICAgICAtIOWGkuazoVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmJ1YmJsZUV2ZW50KG5ldyBKRmxvd0V2ZW50KCdjbGljaycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BMYXllclBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIOeCueWHu+S6i+S7tlxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBAZXZlbnQgSkZsb3cjY29udGV4dGNsaWNrXG4gICAgICAgICAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IGV2ZW50ICAgICAgICAgICAtIOWOn+Wni+S6i+S7tiBcbiAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtKRmxvd30gamZsb3cgICAgICAgICAgIC0g5b2T5YmNSkZsb3flr7nosaFcbiAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJbXX0gdG9wTGF5ZXJQb2ludCAgLSBqZmxvd+WdkOagh+ezu+S4iueahOS9jee9rlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdjbGljaycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BMYXllclBvaW50LFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFyVGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl90YXJnZXQubWV0YSwge1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsWDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsWTogdW5kZWZpbmVkLCBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICog6I+c5Y2V5by55Ye65aSE55CG5Ye95pWwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFggLSDkuovku7blr7nosaHkuI5jYW52YXPnmoTlhoXloavlhYXovrnvvIhwYWRkaW5nIGVkZ2XvvInlnKggWCDovbTmlrnlkJHkuIrnmoTlgY/np7vph4/jgIJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0WSAtIOS6i+S7tuWvueixoeS4jmNhbnZhc+eahOWGheWhq+WFhei+ue+8iHBhZGRpbmcgZWRnZe+8ieWcqCBZIOi9tOaWueWQkeS4iueahOWBj+enu+mHj+OAgiBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQgLSDljp/nlJ/kuovku7ZcbiAgICAgKi9cbiAgICBjb250ZXh0TWVudUhhbmxkZXIob2Zmc2V0WCwgb2Zmc2V0WSwgZXZlbnQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgbGluayxcbiAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgIH0gPSB0aGlzLl90YXJnZXRMb2NrT24oW29mZnNldFgsIG9mZnNldFldLCAnY29udGV4dGNsaWNrJyk7XG4gICAgICAgIGNvbnN0IHsgdG9wTGF5ZXJQb2ludCB9ID0gdGhpcy5fdGFyZ2V0LmNhY2hlXG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLl9yZXNvbHZlTG9ja09uVGFyZ2V0KGxpbmssIGluc3RhbmNlKTtcbiAgICAgICAgaWYodCkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5Y+z6ZSu5LqL5Lu277yI5YaS5rOh77yJXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV2ZW50IEluc3RhbmNlI2NvbnRleHRjbGlja1xuICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IGV2ZW50ICAgICAgICAgICAtIOWOn+Wni+S6i+S7tiBcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SW5zdGFuY2V9IHRhcmdldCAgICAgICAtIOWPs+mUruWvueixoSBcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SkZsb3d9IGpmbG93ICAgICAgICAgICAtIOW9k+WJjUpGbG935a+56LGhXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcltdfSB0b3BMYXllclBvaW50ICAtIGpmbG935Z2Q5qCH57O75LiK55qE5L2N572uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGJ1YmJsZXMgICAgICAgLSDlhpLms6FcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGFyZ2V0LmJ1YmJsZUV2ZW50KG5ldyBKRmxvd0V2ZW50KCdjb250ZXh0Y2xpY2snLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHRvcExheWVyUG9pbnQsXG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDlj7PplK7kuovku7ZcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXZlbnQgSkZsb3cjY29udGV4dGNsaWNrXG4gICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtFdmVudH0gZXZlbnQgICAgICAgICAgIC0g5Y6f5aeL5LqL5Lu2IFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtKRmxvd30gamZsb3cgICAgICAgICAgIC0g5b2T5YmNSkZsb3flr7nosaFcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IHRvcExheWVyUG9pbnQgIC0gamZsb3flnZDmoIfns7vkuIrnmoTkvY3nva5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdjb250ZXh0Y2xpY2snLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICAgICAgdG9wTGF5ZXJQb2ludCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRibGNsaWNrSGFuZGxlcihvZmZzZXRYLCBvZmZzZXRZLCBldmVudCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBsaW5rLFxuICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgfSA9IHRoaXMuX3RhcmdldExvY2tPbihbb2Zmc2V0WCwgb2Zmc2V0WV0sICdkYmxjbGljaycpO1xuICAgICAgICBjb25zdCB7IHRvcExheWVyUG9pbnQgfSA9IHRoaXMuX3RhcmdldC5jYWNoZVxuICAgICAgICBjb25zdCB0ID0gdGhpcy5fcmVzb2x2ZUxvY2tPblRhcmdldChsaW5rLCBpbnN0YW5jZSk7XG4gICAgICAgIGlmKHQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHQ7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOWPs+mUruS6i+S7tlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBldmVudCBJbnN0YW5jZSNkYmxjbGlja1xuICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IGV2ZW50ICAgICAgICAgICAtIOWOn+Wni+S6i+S7tiBcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SW5zdGFuY2V9IHRhcmdldCAgICAgICAtIOWPs+mUruWvueixoSBcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SkZsb3d9IGpmbG93ICAgICAgICAgICAtIOW9k+WJjUpGbG935a+56LGhXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcltdfSB0b3BMYXllclBvaW50ICAtIGpmbG935Z2Q5qCH57O75LiK55qE5L2N572uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGJ1YmJsZXMgICAgICAgLSDlhpLms6FcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGFyZ2V0LmJ1YmJsZUV2ZW50KG5ldyBKRmxvd0V2ZW50KCdkYmxjbGljaycsIHtcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgdG9wTGF5ZXJQb2ludCxcbiAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2RibGNsaWNrJywge1xuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgICAgIHRvcExheWVyUG9pbnQsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKl9vblpvb20oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbGV0IHsgb2Zmc2V0WCwgb2Zmc2V0WSwgZGVsdGFYLCBkZWx0YVkgfSA9IGV2ZW50XG4gICAgICAgIGlmKGV2ZW50LmN0cmxLZXkpIHsgXG4gICAgICAgICAgICBkZWx0YVkgPSAtZGVsdGFZO1xuICAgICAgICAgICAgdGhpcy56b29tSGFuZGxlcihvZmZzZXRYLCBvZmZzZXRZLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhbkhhbmRsZXIoLWRlbHRhWCwgLWRlbHRhWSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfb25QcmVzc1N0YXJ0KGV2ZW50KSB7IFxuICAgICAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFksIGRlbHRhWSwgYnV0dG9uIH0gPSBldmVudFxuICAgICAgICBpZihidXR0b24gIT09IDApIHJldHVybjtcbiAgICAgICAgdGhpcy5wcmVzc1N0YXJ0SGFuZGxlcihvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICB9XG5cbiAgICBfb25QcmVzc01vdmUoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudFxuICAgICAgICB0aGlzLnByZXNzTW92ZUhhbmRsZXIob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgfVxuXG4gICAgX29uUHJlc3NVcChldmVudCwgaXNEb2N1bWVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgY29uc3QgeyBidXR0b24gfSA9IGV2ZW50XG4gICAgICAgIGlmKGJ1dHRvbiAhPT0gMCkgcmV0dXJuO1xuICAgICAgICB0aGlzLnByZXNzVXBIYW5sZGVyKGlzRG9jdW1lbnQpXG4gICAgfVxuXG4gICAgX29uUHJlc3NVcERvY3VtZW50KGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX29uUHJlc3NVcChldmVudCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgX29uQ29udGV4dE1lbnUoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnQ7XG4gICAgICAgIHRoaXMuY29udGV4dE1lbnVIYW5sZGVyKG9mZnNldFgsIG9mZnNldFkpO1xuICAgIH0qL1xuICAgIF9yZXNvbHZlTG9ja09uVGFyZ2V0KGxpbmssIGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBsaW5rPy5PTl9UT1AgPyBsaW5rIDogKGluc3RhbmNlIHx8IGxpbmspO1xuICAgIH1cblxuICAgIF9jbGVhclRhcmdldCgpe1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3RhcmdldC5tZXRhLCB7XG4gICAgICAgICAgICB4OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBpbml0aWFsWDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gaW5pdGlhbFk6IHVuZGVmaW5lZCwgXG4gICAgICAgIH0pXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fdGFyZ2V0LnN0YXR1cywge1xuICAgICAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAgICAgcHJvY2Vzc2luZzogZmFsc2UsXG4gICAgICAgICAgICBtb3ZpbmdTdGF0ZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3RhcmdldCwge1xuICAgICAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgICAgICBsaW5rOiBudWxsLFxuICAgICAgICAgICAgbW92aW5nOiBudWxsLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfcmVjYWxjdWxhdGVQb3NpdGlvbihkZWx0YVgsIGRlbHRhWSwgc2NhbGUpIHtcbiAgICAgICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLmJvdW5kaW5nX2JveDtcbiAgICAgICAgY29uc3QgeyBhY3R1YWxfd2lkdGg6IGN3LCBhY3R1YWxfaGVpZ2h0OiBjaCB9ID0gdGhpcy5jYW52YXNNZXRhO1xuICAgICAgICBpZihzY2FsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgXG5cbiAgICAgICAgaWYodGhpcy53b3JsZE1hcmdpbikge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coc2NhbGUpXG4gICAgICAgICAgICBjb25zdCBtID0gdGhpcy53b3JsZE1hcmdpbjtcbiAgICAgICAgICAgIGNvbnN0IGJ4MSA9ICh4ICsgd2lkdGggKyBtKSpzY2FsZSAtIGN3O1xuICAgICAgICAgICAgY29uc3QgYngyID0gKHggLSBtKSpzY2FsZTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGJ4MSwgYngyKVxuICAgICAgICAgICAgY29uc3Qgc3ggPSB4ICogc2NhbGU7XG4gICAgICAgICAgICBjb25zdCBweCA9IHRoaXMucG9zaXRpb24ueCArIGRlbHRhWDtcbiAgICAgICAgICAgIGNvbnN0IGN4ID0gcHggLSBzeDtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ub2Zmc2V0WCA9IE1hdGgubWluKE1hdGgubWF4KC1ieDEsIGN4KSwgLWJ4Mik7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnBvc2l0aW9uLm9mZnNldFgpXG4gICAgICAgICAgICAvLyB0aGlzLnBvc2l0aW9uLm9mZnNldFggPSBNYXRoLm1heChNYXRoLm1pbigtYngyLCBjeCksIC1ieDEpO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi54ID0gdGhpcy5wb3NpdGlvbi5vZmZzZXRYICsgc3g7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnBvc2l0aW9uLngsIGRlbHRhWClcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMucG9zaXRpb24ub2Zmc2V0WClcblxuICAgICAgICAgICAgY29uc3QgYnkxID0gKHkgKyBoZWlnaHQgKyBtKSpzY2FsZSAtIGNoO1xuICAgICAgICAgICAgY29uc3QgYnkyID0gKHkgLSBtKSpzY2FsZTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGJ5MSwgYnkyKVxuICAgICAgICAgICAgY29uc3Qgc3kgPSB5ICogc2NhbGU7XG4gICAgICAgICAgICBjb25zdCBweSA9IHRoaXMucG9zaXRpb24ueSArIGRlbHRhWTtcbiAgICAgICAgICAgIGNvbnN0IGN5ID0gcHkgLSBzeTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ub2Zmc2V0WSA9IE1hdGgubWluKE1hdGgubWF4KC1ieTEsIGN5KSwgLWJ5Mik7XG4gICAgICAgICAgICAvLyB0aGlzLnBvc2l0aW9uLm9mZnNldFkgPSBNYXRoLm1heChNYXRoLm1pbigtYnkyLCBjeSksIC1ieTEpO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi55ID0gdGhpcy5wb3NpdGlvbi5vZmZzZXRZICsgc3k7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnggKz0gZGVsdGFYO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi55ICs9IGRlbHRhWTsgXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLm9mZnNldFggPSB0aGlzLnBvc2l0aW9uLnggLSB4ICogc2NhbGU7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLm9mZnNldFkgPSB0aGlzLnBvc2l0aW9uLnkgLSB5ICogc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfVxuXG4gICAgY2FsY3VsYXRlVG9SZWFsV29ybGQocCkge1xuICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuIFtwWzBdICogc2NhbGUgKyBwb3NpdGlvbi5vZmZzZXRYLCBwWzFdICogc2NhbGUgKyBwb3NpdGlvbi5vZmZzZXRZXVxuICAgIH1cblxuICAgIF9jYWxjdWxhdGVQb2ludEJhY2socCkge1xuICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuIFsocFswXSAtIHBvc2l0aW9uLm9mZnNldFgpL3NjYWxlLCAocFsxXSAtIHBvc2l0aW9uLm9mZnNldFkpIC8gc2NhbGVdO1xuICAgIH1cblxuICAgIF9jYWxjdWxhdGVQb2ludEJhY2tXaXRoUG9pbnQoYSwgYiwgYXJyLCBpZHgxLCBpZHgyKSB7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICBhcnJbaWR4MV0gPSAoYSAtIHBvc2l0aW9uLm9mZnNldFgpIC8gc2NhbGU7XG4gICAgICAgIGFycltpZHgyXSA9IChiIC0gcG9zaXRpb24ub2Zmc2V0WSkgLyBzY2FsZVxuICAgIH1cblxuICAgIF9jYWxjdWxhdGVEaXN0YW5jZShsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlICogbDtcbiAgICB9XG5cbiAgICBfcmVzZXRUcmFuc2Zvcm0oKSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGg6IGNfd2lkdGgsIGhlaWdodDogY19oZWlnaHQgfSA9IHRoaXMuY2FudmFzTWV0YTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKCk7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY193aWR0aCwgY19oZWlnaHQpO1xuICAgICAgICBjdHguc2NhbGUodGhpcy5kcHIsIHRoaXMuZHByKTtcbiAgICAgICAgY3R4LnRyYW5zZm9ybShzY2FsZSwgMCwgMCwgc2NhbGUsIHBvc2l0aW9uLm9mZnNldFgsIHBvc2l0aW9uLm9mZnNldFkpO1xuICAgICAgICAvLyBjdHguX2N0eC5zZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgLy8gY3R4Ll9jdHguY2xlYXJSZWN0KDAsIDAsIGNfd2lkdGgsIGNfaGVpZ2h0KTtcbiAgICAgICAgLy8gY3R4Ll9jdHguc2NhbGUodGhpcy5kcHIsIHRoaXMuZHByKTtcbiAgICAgICAgLy8gY3R4LnRyYW5zZm9ybShzY2FsZSwgcG9zaXRpb24ub2Zmc2V0WCwgcG9zaXRpb24ub2Zmc2V0WSk7XG4gICAgfVxuXG4gICAgcmVzZXRUcmFuc2Zvcm0oY3R4KSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKCk7XG4gICAgICAgIGN0eC5zY2FsZSh0aGlzLmRwciwgdGhpcy5kcHIpO1xuICAgICAgICBjdHgudHJhbnNmb3JtKHNjYWxlLCAwLCAwLCBzY2FsZSwgcG9zaXRpb24ub2Zmc2V0WCwgcG9zaXRpb24ub2Zmc2V0WSk7XG4gICAgfVxuXG4gICAgX2dldFZpZXdCb3goKSB7XG4gICAgICAgIC8vIGNvbnN0IGNhY2hlVmlld0JveCA9IFtcbiAgICAgICAgLy8gICAgIC4uLnRoaXMuX2NhbGN1bGF0ZVBvaW50QmFjayhbMCwwXSksXG4gICAgICAgIC8vICAgICAuLi50aGlzLl9jYWxjdWxhdGVQb2ludEJhY2soW3RoaXMuY2FudmFzTWV0YS5hY3R1YWxfd2lkdGgsdGhpcy5jYW52YXNNZXRhLmFjdHVhbF9oZWlnaHRdKSxcbiAgICAgICAgLy8gXTtcbiAgICAgICAgY29uc3QgY2FjaGVWaWV3Qm94ID0gdGhpcy5fY2FjaGVWaWV3Qm94O1xuICAgICAgICB0aGlzLl9jYWxjdWxhdGVQb2ludEJhY2tXaXRoUG9pbnQoMCwwLCBjYWNoZVZpZXdCb3gsIDAsIDEpO1xuICAgICAgICB0aGlzLl9jYWxjdWxhdGVQb2ludEJhY2tXaXRoUG9pbnQoXG4gICAgICAgICAgICB0aGlzLmNhbnZhc01ldGEuYWN0dWFsX3dpZHRoLFxuICAgICAgICAgICAgdGhpcy5jYW52YXNNZXRhLmFjdHVhbF9oZWlnaHQsIFxuICAgICAgICAgICAgY2FjaGVWaWV3Qm94LCAyLCAzKTtcbiAgICAgICAgcmV0dXJuIGNhY2hlVmlld0JveDtcbiAgICB9XG5cbiAgICBzZXROb2RlVG9Ub3BMYXllcihub2RlKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fc3RhY2suZmluZEluZGV4KG4gPT4gbiA9PT0gbm9kZSk7XG4gICAgICAgIGlmKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgW3JlbmRlck5vZGVdID0gdGhpcy5fc3RhY2suc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YWNrLnB1c2gocmVuZGVyTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRDYWNoZVZpZXdCb3goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZVZpZXdCb3g7XG4gICAgfVxuXG4gICAgXG4gICAgX3JlbmRlcigpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgIH1cblxuICAgICAvKipcbiAgICAgKiDnu5jliLbnlLvluINcbiAgICAgKi9cbiAgICBfX3JlbmRlcigpIHtcbiAgICAgICAgaWYoIXRoaXMuX3JlYWR5VG9SZW5kZXIpIHJldHVybjtcbiAgICAgICAgLy8gaWYodGhpcy5oYXNBbmltZUFuZEZyYW1lUmVuZGVyZWQoKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLnJ1bkFuaW1lRnJhbWUoKTtcbiAgICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnYmVmb3JlSmZsb3dSZW5kZXInLCB7XG4gICAgICAgICAgICBjdHhcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBiciA9IHRoaXMuX2dldFZpZXdCb3goKTtcblxuICAgICAgICBpZih0aGlzLk5vZGVSZW5kZXJUb3ApIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmtTdGFjay5yZW5kZXIoY3R4LCAobGluaykgPT4gIWxpbmsuT05fVE9QICYmIGxpbmsuaXNJblZpZXdCb3goYnIpKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YWNrLnJlbmRlcihjdHgsIChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRvT3ZlcmxhcChiciwgaW5zdGFuY2UuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLl9pc0luVmlld0JveCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9saW5rU3RhY2sucmVuZGVyKGN0eCwgKGxpbmspID0+IGxpbmsuT05fVE9QICYmIGxpbmsuaXNJblZpZXdCb3goYnIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YWNrLnJlbmRlcihjdHgsIChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRvT3ZlcmxhcChiciwgaW5zdGFuY2UuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGluc3RhbmNlLl9sYXlvdXROb2RlLnR5cGUsIHJlc3VsdClcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5faXNJblZpZXdCb3ggPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fbGlua1N0YWNrLnJlbmRlcihjdHgsIChsaW5rKSA9PiBsaW5rLmlzSW5WaWV3Qm94KGJyKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3R4LnNhdmUoKTtcbiAgICAgICAgLy8gZm9yKGxldCBpID0wO2k8MjAwMDtpKyspIHtcbiAgICAgICAgLy8gICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgLy8gICAgIGN0eC5maWxsU3R5bGUgPSBgcmdiKCR7cGFyc2VJbnQoTWF0aC5yYW5kb20oKSoyNTUpfSwke3BhcnNlSW50KE1hdGgucmFuZG9tKCkqMjU1KX0sJHtwYXJzZUludChNYXRoLnJhbmRvbSgpKjI1NSl9KWBcbiAgICAgICAgLy8gICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgLy8gICAgICAgICBNYXRoLnJhbmRvbSgpKjI1MCwgXG4gICAgICAgIC8vICAgICAgICAgTWF0aC5yYW5kb20oKSoyNDAsIFxuICAgICAgICAvLyAgICAgICAgIE1hdGgucmFuZG9tKCkqMjAwLCBcbiAgICAgICAgLy8gICAgICAgICBNYXRoLnJhbmRvbSgpKjMwMClcbiAgICAgICAgLy8gfVxuICAgICAgICBcbiAgICAgICAgLy8gY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICBpZih0aGlzLl90ZW1wTm9kZSkge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBOb2RlLnJlbmRlcihjdHgpXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuX3RlbXBMaW5rKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgdGhpcy5fdGVtcExpbmsuaXNJblZpZXdCb3goYnIpXG4gICAgICAgICAgICB0aGlzLl90ZW1wTGluay5yZW5kZXIoY3R4KVxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnYWZ0ZXJKZmxvd1JlbmRlcicsIHtcbiAgICAgICAgICAgIGN0eFxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMucmVuZGVyU2Nyb2xsQmFyKGN0eCk7XG4gICAgICAgIC8vIHRoaXMuc2V0RnJhbWVSZW5kZXJlZCgpO1xuICAgIH1cbn1cbk9iamVjdC5hc3NpZ24oSkZsb3cucHJvdG90eXBlLCBNZXNzYWdlTWl4aW4pO1xuT2JqZWN0LmFzc2lnbihKRmxvdy5wcm90b3R5cGUsIFN0YWNrTWl4aW4pO1xuT2JqZWN0LmFzc2lnbihKRmxvdy5wcm90b3R5cGUsIExheW91dE1peGluKTtcbk9iamVjdC5hc3NpZ24oSkZsb3cucHJvdG90eXBlLCB7XG4gICAgcmVjYWxjdWxhdGVVcCgpIHtcbiAgICAgICAgaWYodGhpcy5fX21vdW50ZWRfXykge1xuICAgICAgICAgICAgdGhpcy5yZWZsb3coKTtcbiAgICAgICAgfVxuICAgIH1cbn0pXG5cbk9iamVjdC5hc3NpZ24oSkZsb3cucHJvdG90eXBlLCBOb2RlV2Vha01hcE1peGluKTtcbk9iamVjdC5hc3NpZ24oSkZsb3cucHJvdG90eXBlLCBBbmltZU1peGluKTtcbk9iamVjdC5hc3NpZ24oSkZsb3cucHJvdG90eXBlLCBNaW5pTWFwTWl4aW4pO1xuT2JqZWN0LmFzc2lnbihKRmxvdy5wcm90b3R5cGUsIFNjaGVkdWxlTWl4aW4pO1xuT2JqZWN0LmFzc2lnbihKRmxvdy5wcm90b3R5cGUsIFNjcm9sbEJhck1peGluKTtcblxuZXhwb3J0IGRlZmF1bHQgSkZsb3c7XG5leHBvcnQgeyBKRkxPV19NT0RFIH0gZnJvbSAnLi4vdXRpbHMvY29uc3RhbmNlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSkZsb3dFdmVudCB9IGZyb20gJy4uL2V2ZW50cyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNvbW1vbkV2ZW50QWRhcHRlciB9IGZyb20gJy4uL2V2ZW50cy9jb21tb25BZGFwdGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSW5zdGFuY2UgfSBmcm9tICcuLi9pbnN0YW5jZS9pbnN0YW5jZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5vZGUgfSBmcm9tICcuLi9pbnN0YW5jZS9ub2RlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQmFzZUxpbmsgfSBmcm9tICcuLi9pbnN0YW5jZS9iYXNlLWxpbmsnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQb2ludCB9IGZyb20gJy4uL2luc3RhbmNlL3NoYXBlcy9wb2ludCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFJlY3RhbmdsZSB9IGZyb20gJy4uL2luc3RhbmNlL3NoYXBlcy9yZWN0YW5nbGUnO1xuLy8gZXhwb3J0IHsgZGVmYXVsdCBhcyBHcm91cCB9IGZyb20gJy4uL2luc3RhbmNlL3NoYXBlcy9yZWN0YW5nbGUtZ3JvdXAnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDYXBzdWxlIH0gZnJvbSAnLi4vaW5zdGFuY2Uvc2hhcGVzL2NhcHN1bGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDYXBzdWxlVmVydGljYWwgfSBmcm9tICcuLi9pbnN0YW5jZS9zaGFwZXMvY2Fwc3VsZS12ZXJ0aWNhbCc7XG4vLyBleHBvcnQgeyBkZWZhdWx0IGFzIENhcHN1bGVHcm91cCB9IGZyb20gJy4uL2luc3RhbmNlL3NoYXBlcy9jYXBzdWxlLWdyb3VwJztcbi8vIGV4cG9ydCB7IGRlZmF1bHQgYXMgQ2Fwc3VsZVZlcnRpY2FsR3JvdXAgfSBmcm9tICcuLi9pbnN0YW5jZS9zaGFwZXMvY2Fwc3VsZS12ZXJ0aWNhbC1ncm91cCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERpYW1vbmQgfSBmcm9tICcuLi9pbnN0YW5jZS9zaGFwZXMvZGlhbW9uZCc7XG4vLyBleHBvcnQgeyBkZWZhdWx0IGFzIERpYW1vbmRHcm91cCB9IGZyb20gJy4uL2luc3RhbmNlL3NoYXBlcy9kaWFtb25kLWdyb3VwJztcbi8vIGV4cG9ydCB7IGRlZmF1bHQgYXMgRGlhbW9uZFZlcnRpY2FsR3JvdXAgfSBmcm9tICcuLi9pbnN0YW5jZS9zaGFwZXMvZGlhbW9uZC12ZXJ0aWNhbC1ncm91cCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFJob21idXMgfSBmcm9tICcuLi9pbnN0YW5jZS9zaGFwZXMvcmhvbWJ1cyc7XG4vLyBleHBvcnQgeyBkZWZhdWx0IGFzIFJob21idXNHcm91cCB9IGZyb20gJy4uL2luc3RhbmNlL3NoYXBlcy9yaG9tYnVzLWdyb3VwJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGV4dCB9IGZyb20gJy4uL2luc3RhbmNlL2VsZW1lbnRzL3RleHQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBJY29uIH0gZnJvbSAnLi4vaW5zdGFuY2UvaW1hZ2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTaGFkb3dEb20gfSBmcm9tICcuLi9pbnN0YW5jZS9zaGFkb3dEb20nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBHcm91cEZhY3RvcnkgfSBmcm9tICcuLi9pbnN0YW5jZS9ncm91cEZhY3RvcnknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaW5rIH0gZnJvbSAnLi4vaW5zdGFuY2UvbGluayc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBvbHlMaW5rIH0gZnJvbSAnLi4vaW5zdGFuY2UvcG9seS1saW5rJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQmV6aWVyTGluayB9IGZyb20gJy4uL2luc3RhbmNlL2Jlemllci1saW5rJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGluZWFyTGF5b3V0fSBmcm9tICcuLi9sYXlvdXQvbGluZWFyLWxheW91dCc7XG4vLyBleHBvcnQgeyBkZWZhdWx0IGFzIFRyZWVMYXlvdXQgfSBmcm9tICcuLi9sZXItbGF5b3V0YTt5b3V0L3RyZWUtbGF5b3V0Jztcbi8vIGV4cG9ydCB7IGRlZmF1bHQgYXMgTG93Y29kZWxheW91dCB9IGZyb20gJy4uL2xheW91dC9sb3ctY29kZS1sYXlvdXQnO1xuLy8gZXhwb3J0IHsgZGVmYXVsdCBhcyBFUkxheW91dCB9IGZyb20gJy4uL2xheW91dC9lci1sYXlvdXQvZXItbGF5b3V0Jztcbi8vIGV4cG9ydCB7IGRlZmF1bHQgYXMgT3JhbmdlIH0gZnJvbSAnLi4vaW5zdGFuY2Uvbm9kZVdyYXBwZXIvb3JhbmdlL29yYW5nZSdcbi8vIGV4cG9ydCB7IGRlZmF1bHQgYXMgVGV4dEVkaXRvciB9IGZyb20gJy4uL2luc3RhbmNlL3RleHQtZWRpdG9yJztcbi8vIGV4cG9ydCB7IGRlZmF1bHQgYXMgVGV4dEdyb3VwfSBmcm9tICcuLi9pbnN0YW5jZS90ZXh0LWdyb3VwJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGV4dEdyb3VwfSBmcm9tICcuLi9pbnN0YW5jZS90ZXh0LWdyb3VwL3RleHQtZ3JvdXAnO1xuZXhwb3J0IHsgVGV4dEVsZW1lbnQgfSBmcm9tICcuLi9pbnN0YW5jZS90ZXh0LWdyb3VwL3N0b3JhZ2UnO1xuLy8gZXhwb3J0IHsgSkZsb3dQYXRoMkQgfSBmcm9tICcuLi91dGlscy9wYXRoLTJkJztcblxuZXhwb3J0IHsgTm9kZVBsYWNlaG9sZGVyIH0gZnJvbSAnLi4vaW5zdGFuY2Uvbm9kZS1wbGFjZWhvbGRlcic7XG5leHBvcnQgeyBhZGRSZWZsb3dXb3JrIH0gZnJvbSAnLi4vZGlydHktd29yay9kaXJ0eS13b3JrJztcbiIsImltcG9ydCBwYWNrYWdlSnNvbiBmcm9tICcuLi9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgZGVmYXVsdCBhcyBKRmxvdyB9IGZyb20gJy4vY29yZS9mbG93JzsgXG5leHBvcnQgZGVmYXVsdCBKRmxvdztcbmV4cG9ydCAqIGZyb20gJy4vY29yZS9mbG93Jztcbi8vIGV4cG9ydCB7IGRlZmF1bHQgYXMgSkZsb3dWdWVQbHVnaW4sIEpGbG93TGlua0dyb3VwIH0gZnJvbSAnLi92dWUtcGx1Z2luL0pGbG93UGx1Z2luLmpzJztcbkpGbG93LiRqZmxvd192ZXJzaW9uID0gcGFja2FnZUpzb24udmVyc2lvbjtcbi8vIGNvbnNvbGUubG9nKGBqZmxvdyB2ZXJzaW9uQCR7cGFja2FnZUpzb24udmVyc2lvbn1gKSJdLCJuYW1lcyI6WyJjcmVhdGVDYW52YXMiLCJ3cmFwcGVyIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsIl93cmFwcGVyJGdldEJvdW5kaW5nQyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIndpZHRoIiwiaGVpZ2h0IiwibGVmdCIsInRvcCIsInN0eWxlIiwidXNlclNlbGVjdCIsInNjYWxlIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsIk1hdGgiLCJmbG9vciIsInBvc2l0aW9uIiwib3ZlcmZsb3ciLCJhcHBlbmQiLCJyYXdfd2lkdGgiLCJyYXdfaGVpZ2h0IiwicmVzaXplQ2FudmFzIiwiX3dyYXBwZXIkZ2V0Qm91bmRpbmdDMiIsImNhaGVDYW52YXMiLCJjYWhlQ2FudmFzY3R4IiwicmVxdWVzdENhY2hlQ2FudmFzIiwicmVuZGVyIiwiY2xlYXJSZWN0Iiwic2F2ZSIsInJlc3RvcmUiLCJsaXN0ZW5PbkRldmljZVBpeGVsUmF0aW8iLCJjYWxsYmFjayIsImRlc3Ryb3lIYW5kbGVyIiwidGFyZ2V0IiwibWF0Y2hNZWRpYSIsImNvbmNhdCIsIm9uQ2hhbmdlIiwiY29uc29sZSIsImxvZyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvbmNlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIkRJUkVDVElPTiIsIlJJR0hUIiwiQk9UVE9NIiwiTEVGVCIsIlRPUCIsIlNFTEYiLCJuZXh0RGlyZWN0aW9uIiwiZGlyZWN0aW9uIiwiY2xvY2t3aXNlIiwibmV4dERpciIsIm9wcG9zaXRlRGlyZWN0aW9uIiwiQVBQUk9YSU1BVEUiLCJKRkxPV19NT0RFIiwiREVGQVVMVCIsIkxJTktJTkciLCJMSU5FX0RJUiIsIkZST00iLCJUTyIsIkJlemllciIsImJvdW5kaW5nX2JveCIsInBvaW50cyIsImxlbmd0aCIsIngiLCJ5IiwibWluX3giLCJJbmZpbml0eSIsIm1pbl95IiwibWF4X3giLCJtYXhfeSIsImlkeCIsIml0ZW0iLCJtYXgiLCJzcXIiLCJkaXN0MiIsInYiLCJ3IiwiZGlzdFRvU2VnbWVudFNxdWFyZWQiLCJwIiwibDIiLCJ0IiwibWluIiwibWluSW50ZXJzZWN0aW9uQmV0d2Vlbk5vZGVzIiwiZG1zZnJvbSIsImRtc3RvIiwibWV0YSIsImZyb21EaXIiLCJmcm9tUCIsInRvRGlyIiwidG9QIiwiZGlzdE1pbiIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiZGYiLCJwZiIsImR0IiwicHQiLCJkaXN0IiwiYXNzaWduIiwiX3Jlc29sdmVDb250cm9sUG9pbnQiLCJkaXIiLCJzcGFueCIsInNwYW55IiwiYmV6aWVyUG9pbnRzIiwicDEiLCJwMiIsInN0YXJ0X2RpciIsImFyZ3VtZW50cyIsInVuZGVmaW5lZCIsImVuZF9kaXIiLCJtaW5TcGFuWCIsIm1pblNwYW5ZIiwiYWJzIiwiY3AxIiwiY3AyIiwiYXJyb3dzcGFuIiwiaW5jbHVkZXMiLCJpc1ZlcnRpY2FsRW5kIiwiZW5kWCIsImVuZFkiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJiZXppZXJQb2ludCIsIlAiLCJxIiwidSIsImFuZ2xlIiwiYXRhbjIiLCJkaXN0VG9CZXppZXJTZWdtZW50U3F1YXJlZCIsImIiLCJfY29uc3RydWN0IiwicG9pbnQiLCJwcm9qZWN0IiwiZCIsImdldEJlemllckFuZ2xlIiwic3giLCJzeSIsImNwMXgiLCJjcDF5IiwiY3AyeCIsImNwMnkiLCJleCIsImV5IiwiZHgiLCJwb3ciLCJkeSIsIlBJIiwiZ2V0SW5zdGFuY2VIZWlnaHQiLCJpbnN0YW5jZSIsInJlY3QiLCJnZXRCb3VuZGluZ1JlY3QiLCJwb2x5bGluZVBvaW50cyIsImlzU2VsZiIsImRpclNwYW4iLCJpc1ZlcnRpY2FsU3RhcnQiLCJ5cCIsInB1c2giLCJ4cCIsInBtaWRkbGUiLCJ1bnNoaWZ0IiwibWludXNWZWMiLCJhYnNWZWMiLCJ2ZWMiLCJzcXJ0Iiwic2NhbGVWZWMiLCJtYWtlUmFkaXVzRnJvbVZlY3RvciIsInBiZWZvcmUiLCJwbmV4dCIsInJhZGl1cyIsInZlYzEiLCJ2ZWMyIiwiYWJzVmVjMSIsImFic1ZlYzIiLCJyMSIsInIyIiwiZG9PdmVybGFwIiwicmVjMSIsInJlYzIiLCJpc1BvbHlMaW5lSW50ZXJzZWN0aW9uUmVjdGFuZ2UiLCJwb2x5bGluZSIsImwiLCJpIiwiX3JlY3QiLCJfc2xpY2VkVG9BcnJheSIsImwwIiwibDEiLCJyMCIsImNwIiwiZGVib3VuY2UiLCJmdW5jIiwiX3RoaXMiLCJ0aW1lb3V0IiwidGltZXIiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2FsbCIsImNvbXBhcmVCb3VuZGluZ2JveCIsImEiLCJjb3B5Qm91bmRpbmdib3giLCJpc2hpdEtleSIsIlN5bWJvbCIsImlzSW5WaWV3Qm94IiwiSW5zdGFuY2UiLCJfRXZlbnRUYXJnZXQiLCJfaW5oZXJpdHMiLCJfc3VwZXIiLCJfY3JlYXRlU3VwZXIiLCJjb25maWdzIiwiX2NsYXNzQ2FsbENoZWNrIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInZpc2libGUiLCJfYmVsb25ncyIsImJvcmRlcldpZHRoIiwiYm9yZGVyQ29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJzaGFkb3dDb2xvciIsInNoYWRvd0JsdXIiLCJzaGFkb3dPZmZzZXRYIiwic2hhZG93T2Zmc2V0WSIsIm9wYWNpdHkiLCJfYm91bmRpbmdyZWN0IiwiX2NyZWF0ZUNsYXNzIiwia2V5IiwiZ2V0IiwiX2pmbG93IiwiX3RhcmdldCIsImxpbmsiLCJfZ2V0TW92aW5nVGFyZ2V0Iiwic3RhdHVzIiwibW92aW5nU3RhdGUiLCJzZXQiLCJpc2hpdCIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsImRldGFpbCIsImpmbG93IiwiX2pmbG93Um9vdCIsInVuaXF1ZU5hbWUiLCJ2YWwiLCJvbGR2YWwiLCJvbkVudGVyVmlld2JveCIsIm9uTGVhdmVWaWV3Ym94IiwidmFsdWUiLCJzZXRDb25maWciLCJfdGhpczIiLCJrIiwiaXNIaXQiLCJjYWxjdWxhdGVJbnRlcnNlY3Rpb24iLCJnZXRJbnRlcnNlY3Rpb25zSW5Gb3VyRGltZW5zaW9uIiwiZ2V0Q2VudGVyIiwiYW5jaG9yIiwiZ2V0Qm91bmRpbmdEaW1lbnNpb24iLCJidWJibGVFdmVudCIsImN1c3RvbUV2ZW50IiwiY3VycmVudFRhcmdldCIsImJ1YmJsZXMiLCJjYWxjdWxhdGVUb1JlYWxXb3JsZCIsImNhbGN1bGF0ZVRvUmVhbFdvcmxkV2l0aFBvaW50ZXIiLCJvdXRwb2ludCIsImlucG9pbnQiLCJjYWxjdWxhdGVUb1JlYWxXb3JsZFdpdGhTY2FsYXIiLCJyZWNhbGN1bGF0ZVVwIiwiZGVzdHJveSIsIl93cmFwTmF0aXZlU3VwZXIiLCJFdmVudFRhcmdldCIsInF1ZXVlIiwiY2xlYXJRdWV1ZSIsInF1ZXVlU2V0IiwiV2Vha1NldCIsImNoZWNrV29yayIsImhhcyIsImdldFN0YWNrUGF0aCIsIm5vZGUiLCJleHAiLCJfc3RhY2siLCJmaW5kSW5kZXgiLCJuIiwic29ydEJ5UGF0aCIsIm1hcCIsIldlYWtNYXAiLCJzb3J0IiwiYXBhdGgiLCJicGF0aCIsIl9hIiwic3BsaXQiLCJfYiIsIl9wIiwiX3EiLCJhZGRDbGVhclNvdXJjZVdvcmsiLCJzb3VyY2UiLCJhZGRSZWZsb3dXb3JrIiwicGFyZW50IiwiZG9SZWNhbGN1bGF0ZSIsImFkZCIsImZsdXNoIiwiaW5GbHVzaCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJvb3RzIiwiU2V0Iiwic2hpZnQiLCJfY2xlYXJRdWV1ZSRzaGlmdCIsIl9jbGVhclF1ZXVlJHNoaWZ0MiIsImdldFJlbmRlck5vZGVCeVNvdXJjZSIsImNsZWFyU291cmNlIiwiQXJyYXkiLCJmcm9tIiwiX3JlbmRlciIsIk5vZGUiLCJfSW5zdGFuY2UiLCJfZGVmaW5lUHJvcGVydHkiLCJfcmF3Q29uZmlncyIsImFic29sdXRlUG9zaXRpb24iLCJzdGFjayIsInMiLCJfdGhpczMiLCJzZXRBbmNob3JYIiwic2V0QW5jaG9yWSIsInNldEFuY2hvciIsImJlZm9yZVJlbmRlciIsIl9nZXRWaWV3Qm94IiwiY2xvbmUiLCJDIiwiY29uc3RydWN0b3IiLCJHaG9zdE5vZGUiLCJfTm9kZSIsIl90aGlzJGFuY2hvciIsIngyIiwieTIiLCJfcmVmIiwiX3RoaXMkYW5jaG9yMiIsImdldE1hcE9iamVjdCIsImxheW91dE5vZGUiLCJqZmxvd05vZGUiLCJqZmxvd2xpbmtzIiwiamZsb3dGcm9tTGlua3MiLCJqZmxvd1RvTGlua3MiLCJOb2RlV2Vha01hcCIsIl9tYXAiLCJNYXAiLCJvYmoiLCJfZGVsZXRlIiwiY2xlYXIiLCJOb2RlV2Vha01hcE1peGluIiwiaW5pdE5vZGVXZWFrTWFwIiwic291cmNlX0xheW91dF9SZW5kZXJfTm9kZU1hcCIsIm1hcHBpbmciLCJyZW1vdmVSZW5kZXJOb2RlQnlTb3VyY2UiLCJzaXplIiwiZ2V0TGF5b3V0Tm9kZUJ5U291cmNlIiwiZ2V0U291cmNlUmVuZGVyTWV0YSIsIl9tZXRhIiwiX29iamVjdFNwcmVhZCIsIl9nZXRNYXAiLCJzZXRMYXlvdXROb2RlQnlTb3VyY2UiLCJzZXRSZW5kZXJOb2RlQnlTb3VyY2UiLCJ0byIsImFkZExpbmtOb2RlQnlTb3VyY2UiLCJzb3VyY2VGcm9tIiwic291cmNlVG8iLCJyZW1vdmVMaW5rTm9kZUJ5U291cmNlIiwiY2hhbmdlTGlua05vZGVCeVNvdXJjZSIsInByZXZTb3VyY2UiLCJuZXh0U291cmNlIiwiSW5zdGFuY2VTdGFjayIsIl9BcnJheSIsIl9jdXJyZW50SGl0IiwiY2IiLCJfZ2V0IiwiX2dldFByb3RvdHlwZU9mIiwicHJvdG90eXBlIiwidHlwZSIsImZpbHRlciIsInNsaWNlIiwic3VwZXJmaWx0ZXIiLCJjb25kaXRpb24iLCJtb3ZpbmdUYXJnZXQiLCJfaXNNb3ZpbmciLCJyZXNldEhpdFN0YXR1cyIsIl9pc0hpdCIsImNoZWNrSGl0IiwiY3VycmVudENvbnN0cmFpbnQiLCJpZ25vcmVIaXQiLCJnZXRCb3VuZGluZ1JlY3RQb2ludHMiLCJnZXRBbmNob3JSZWN0UG9pbnRzIiwiU3RhY2tNaXhpbiIsImluc3RhbmNlcyIsImxpbmtzIiwiX2xpbmtTdGFjayIsImluaXRTdGFjayIsImRhdGEiLCJhZGRUb1N0YWNrIiwiaW5zZXJ0VG9TdGFja0JlZm9yZSIsImFuY2hvck5vZGUiLCJyZW1vdmVGcm9tU3RhY2siLCJzcGxpY2UiLCJyZXBsYWNlRnJvbVN0YWNrIiwiaW5kZXgiLCJhZGRUb0xpbmtTdGFjayIsImZpbmQiLCJyZW1vdmVGcm9tTGlua1N0YWNrIiwiZW1wdHlMaW5rIiwicmVzZXRDaGlsZHJlblBvc2l0aW9uIiwiYWRkSW5zdGFuY2VUb0xpbmsiLCJ0YXJnZXRMaW5rIiwiX2NvbnN0dWN0b3IiLCJfX3Byb3RvX18iLCJpbnRlcmF0ZU5vZGVTdGFjayIsIkxheW91dE1peGluIiwiX2xheW91dCIsImluaXRMYXlvdXQiLCJsYXlvdXQiLCJfdGhpcyRfYmVsb25ncyIsImRpcnR5IiwiX3RoaXMkZ2V0Qm91bmRpbmdEaW1lIiwid29sZCIsImhvbGQiLCJfZ2V0Qm91bmRpbmdHcm91cFJlY3QiLCJyZWZsb3ciLCJfdGhpcyRnZXRCb3VuZGluZ0RpbWUyIiwid25vdyIsImhub3ciLCJyZWNhbGN1bGF0ZURvd24iLCJyZWZsb3dBZnRlciIsInJlY2FsY3VsYXRlIiwic3RhdGljQ2hlY2siLCJNZXNzYWdlTWl4aW4iLCJfbWVzc2FnZSIsInNlbmRNZXNzYWdlIiwibXNnIiwiY29uc3VtZU1lc3NhZ2UiLCJyZWFkTWVzc2FnZSIsImluaXRBbmltZSIsImFuaW1lX3F1ZXVlIiwiX19hbmltZUNsb2NrX18iLCJyZXF1ZXN0SkZsb3dBbmltZSIsImZyYW1lQ2FsbEJhY2siLCJlbnF1ZXVlQW5pbWUiLCJfcnVuQW5pbWUiLCJhbmltZU1ldGEiLCJzdGFydCIsImNhbmNlbCIsIl9jYW5jZWxBbmltZSIsIm0iLCJydW5BbmltZSIsInNjaGVkdWxlUmVuZGVyIiwicnVuQW5pbWVGcmFtZSIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJlbGFwc2VkIiwiY2FwdHVyZU1hcCIsIl9yZWYkcGFkZGluZyIsInBhZGRpbmciLCJfcmVmJHBsYWNlbWVudCIsInBsYWNlbWVudCIsIl90aGlzJGJvdW5kaW5nX2JveCIsInBfd2lkdGgiLCJwX2hlaWdodCIsInBfeCIsInBfeSIsIm1pbmlNYXAiLCJfdGhpcyRtaW5pTWFwIiwiX3JlbmRlck1hcCIsInByZXNzRG93biIsImV2ZW50Iiwib2Zmc2V0WCIsIm9mZnNldFkiLCJkZWx0YVgiLCJkZWx0YVkiLCJfb25Nb3ZlTWFwIiwiY2FjaGVNaW5pbWFwQ3R4IiwiX3RoaXMkbWluaU1hcDIiLCJwYWQyIiwicGFkIiwiciIsIm1feCIsIm1feSIsImNhY2hlY3R4Iiwic2V0VHJhbnNmb3JtIiwidHJhbnNmb3JtIiwiYnIiLCJOb2RlUmVuZGVyVG9wIiwiX2NhY2hlTWFwSW1hZ2VEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwicHV0SW1hZ2VEYXRhIiwiX3RoaXMkX2dldFZpZXdCb3giLCJfdGhpcyRfZ2V0Vmlld0JveDIiLCJiZWdpblBhdGgiLCJjbGlwIiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJfdGhpcyRfZ2V0Vmlld0JveDMiLCJfdGhpcyRfZ2V0Vmlld0JveDQiLCJfcmVjYWxjdWxhdGVQb3NpdGlvbiIsIkpGbG93RXZlbnQiLCJfQ3VzdG9tRXZlbnQiLCJvcmlnaW5FdmVudCIsIlNjcm9sbEJhciIsImJhcldpZHRoIiwiYmFyTWFyZ2luWCIsImJhck1hcmdpblkiLCJwbGFpbkNvbG9yIiwiZm9jdXNDb2xvciIsImlzRm9jdXMiLCJjeSIsImJ5IiwicmMiLCJsYyIsIm1vdmVUbyIsImFyYyIsImxpbmVUbyIsImNsb3NlUGF0aCIsInRjIiwiYmMiLCJjeCIsInJ4IiwiZmlsbCIsImgiLCJpbml0U2Nyb2xsQmFyIiwiYmFyQ29sb3IiLCJiYXJGb2N1c0NvbG9yIiwiX3Njcm9sbGJhckVuYWJsZSIsIl9zY3JvbGxiYXJYIiwiX3Njcm9sbGJhclkiLCJfc2Nyb2xsQmFyU3RhdHVzIiwiZHJhZ2dpbmciLCJ4c2NhbGUiLCJ5c2NhbGUiLCJiYXJJbml0WCIsImJhckluaXRZIiwic3RvcFpvb21wYW5XYXRjaCIsInNjcm9sbEJhck9uUGFuQW5kWm9vbSIsImUiLCJjbGllbnRYIiwiY2xpZW50WSIsIm9uU2Nyb2xsYmFyUHJlc3NTdGFydCIsImNoZWNrU2Nyb2xsRHJhZ2dpbmciLCJ4aGl0IiwiYmFyU3RhcnRYIiwieWhpdCIsImJhclN0YXJ0WSIsImYiLCJvbkRyYWdnaW5nU2Nyb2xsYmFyIiwiYmluZCIsIl90aGlzJF9zY3JvbGxCYXJTdGF0dSIsInNjb2xsYmFySGVpZ2h0Iiwic2NvbGxiYXJXaWR0aCIsInJlYWxSIiwicmVhbEwiLCJyZWFsVCIsInJlYWxCIiwiX3RoaXMkY2FudmFzTWV0YSIsImNhbnZhc01ldGEiLCJhY3R1YWxfd2lkdGgiLCJhY3R1YWxfaGVpZ2h0IiwieG5ldyIsInJhdGlvSW5YIiwicmF0aW9YIiwieW5ldyIsInJhdGlvSW5ZIiwicmF0aW9ZIiwiY2hlY2tTY3JvbGxCYXJIb3ZlciIsImN1cnNvciIsInJlc2V0U2Nyb2xsQmFySG92ZXIiLCJfZ2V0U2Nyb2xsVmlld0JvdW5kaW5nYm94IiwiX3RoaXMkYm91bmRpbmdfYm94MiIsIl90aGlzJF9nZXRTY3JvbGxWaWV3QiIsInZ3IiwidmgiLCJfdGhpcyRjYW52YXNNZXRhMiIsImFuY2hvclgiLCJhbmNob3JZIiwicmVzZXRTY29sbEJhclN0YXR1cyIsInJlbmRlclNjcm9sbEJhciIsImRwciIsIl90aGlzJF9zY3JvbGxCYXJTdGF0dTIiLCJ0b2dnbGVSZW5kZXIiLCJfX3JlbmRlcnN0b3BfXyIsImluaXRTY2hlZHVsZSIsIl9fY2xvY2tfXyIsImlzRmlyc3RUaW1lIiwiX19yZW5kZXIiLCJnZXREZWZhdWx0UGx1Z2luIiwiX21vdXNlU3RhdHVzIiwicG9pbnRlckRvd24iLCJ3aGVlbCIsInByZXZlbnREZWZhdWx0IiwiY3RybEtleSIsInpvb21IYW5kbGVyIiwicGFuSGFuZGxlciIsInBvaW50ZXJkb3duIiwiYnV0dG9uIiwicHJlc3NTdGFydEhhbmRsZXIiLCJwb2ludGVybW92ZSIsInByZXNzTW92ZUhhbmRsZXIiLCJwb2ludGVydXAiLCJwcmVzc1VwSGFubGRlciIsImNvbnRleHRtZW51Iiwic3RvcFByb3BhZ2F0aW9uIiwiY29udGV4dE1lbnVIYW5sZGVyIiwiZGJsY2xpY2siLCJkYmxjbGlja0hhbmRsZXIiLCJjbGljayIsImNsaWNrSGFubGRlciIsIkV2ZW50QWRhcHRlciIsInBsdWdpbiIsInVzZSIsImNhbnZhc0hhbmRsZXJzIiwiZG9jdW1lbnRIYW5kbGVycyIsImNhIiwiZG9jT2JqIiwiZXZlbnROYW1lIiwiaGFzT3duUHJvcGVydHkiLCJhcHBseSIsIl90aGlzJHBsdWdpbiIsIl9sb29wIiwiaGFuZGxlciIsImhhbmRsZXJXcmFwcGVyZCIsIl9sb29wMiIsIm9wdGlvbnMiLCJ1bmxvYWQiLCJfcmVmMiIsIkdyb3VwTWl4aW4iLCJfc2V0UGFkZGluZyIsInBhZGRpbmdUb3AiLCJyaWdodCIsInBhZGRpbmdSaWdodCIsImJvdHRvbSIsInBhZGRpbmdCb3R0b20iLCJwYWRkaW5nTGVmdCIsIl9zZXRNYXJnaW4iLCJtYXJnaW4iLCJtYXJnaW5Ub3AiLCJtYXJnaW5SaWdodCIsIm1hcmdpbkJvdHRvbSIsIm1hcmdpbkxlZnQiLCJfZ2V0Q2VudGVyIiwibXgiLCJteSIsImNlbnRlclgiLCJjZW50ZXJZIiwiX3NoYXBlIiwiX2NlbnRlciIsIl9jYWxjdWxhdGVQb2ludEJhY2siLCJfcG9pbnQiLCJneCIsImd5IiwiX3RoaXMkX2dldENlbnRlciIsIl90aGlzJF9nZXRDZW50ZXIyIiwiX2NhbGN1bGF0ZVBvaW50QmFja1dpdGhQb2ludCIsImFyciIsImlkeDEiLCJpZHgyIiwiY2FsY3VsYXRlVG9Db29yZGluYXRpb24iLCJfcG9pbnQyIiwiX3RoaXMkX2dldENlbnRlcjMiLCJfdGhpcyRfZ2V0Q2VudGVyNCIsIl9wb2ludDMiLCJfdGhpcyRfZ2V0Q2VudGVyNSIsIl90aGlzJF9nZXRDZW50ZXI2IiwibHR4IiwibHR5IiwicmJ4IiwicmJ5IiwiX3AyIiwiX3BvaW50NCIsIngxIiwieTEiLCJ2ZWN4IiwidmVjeSIsInRoZXRhMSIsInRoZXRhMiIsImRpcngiLCJkaXJ5IiwiX19tb3VudGVkX18iLCJkZWZhdWx0U2hpZnQiLCJHcm91cEZhY3RvcnkiLCJqZmxvd05vZGVDb25zdHJ1Y3RvciIsInNoYXBlU2hpZnQiLCJfY29uZmlncyRsb2NrIiwiX2NvbmZpZ3MkdHJhbnNwYXJlbnQiLCJkZWZpbmVkV2lkdGgiLCJtaW5XaWR0aCIsImRlZmluZWRIZWlnaHQiLCJsb2NrIiwiZGlzcGxheSIsInRyYW5zcGFyZW50IiwiX2NhY2hlVmlld0JveCIsIl9zaGFwZVNoaWZ0IiwiX3NoYXBlU2hpZnQyIiwic2hhcGVXaWR0aCIsInNoYXBlSGVpZ2h0IiwiYmJveCIsInBhZGRpbmdXaWR0aCIsInBhZGRpbmdIZWlnaHQiLCJfcGFkZGluZ1dpZHRoIiwiX3BhZGRpbmdIZWlnaHQiLCJfc2hhcGVTaGlmdDMiLCJfc2hhcGVTaGlmdDQiLCJiZWxvbmdzX3Zib3giLCJnZXRDYWNoZVZpZXdCb3giLCJjYWNoZVZpZXdCb3giLCJnbG9iYWxBbHBoYSIsIl90aGlzJF9nZXRDZW50ZXI3IiwiX3RoaXMkX2dldENlbnRlcjgiLCJ0cmFuc2xhdGUiLCJfY3VycmVudHAiLCJQb2ludCIsIl9kb0NhY2hlIiwibGluZVdpZHRoIiwic3Ryb2tlU3R5bGUiLCJzdHJva2UiLCJyYXRpbyIsImNhbGN1bGF0ZUludGVyc2VjdGlvbkluRm91ckRpbWVuc2lvbiIsImVuZCIsIl9hbGxJbnRlcnNlY3Rpb25zIiwiX3RoaXMkYW5jaG9yMyIsImFsbEludGVyc2VjdGlvbnMiLCJpbnRlckRpciIsIlJlY3RhbmdsZSIsImJvcmRlclJhZGl1cyIsIl9zZXRCb3JkZXIiLCJfY29uZmlncyRib3JkZXIiLCJfY29uZmlncyRib3JkZXIyIiwiX2NvbmZpZ3MkYm9yZGVyMyIsIl9jb25maWdzJGJvcmRlcjQiLCJfY29uZmlncyRib3JkZXI1IiwiX2NvbmZpZ3MkYm9yZGVyNiIsIl9jb25maWdzJGJvcmRlcjciLCJfY29uZmlncyRib3JkZXI4IiwiX2NvbmZpZ3MkYm9yZGVyOSIsIl9jb25maWdzJGJvcmRlcjEwIiwiX2NvbmZpZ3MkYm9yZGVyMTEiLCJfY29uZmlncyRib3JkZXIxMiIsImJvcmRlciIsImNvbG9yIiwiZW5hYmxlIiwieHQiLCJ5dCIsInF1YWRyYXRpY0N1cnZlVG8iLCJzd2l0Y2hQYXRoIiwiUGF0aDJEIiwidHkiLCJ0b3BQYXRoIiwiX3AzIiwiX3A0IiwiQ2Fwc3VsZSIsImh3IiwiaGgiLCJsZWZ0Q2VudGVyIiwicmlnaHRDZW50ZXIiLCJ3dyIsInJyIiwiQ2Fwc3VsZVZlcnRpY2FsIiwiX0NhcHN1bGUiLCJ0b3BDZW50ZXIiLCJib3R0b21DZW50ZXIiLCJ5eSIsIlJob21idXMiLCJkaWFnb25hbHNWIiwiZGlhZ29uYWxzSCIsImNlbnRlciIsIkRpYW1vbmQiLCJzaWRlIiwic2luU0lERSIsInNpbiIsImNvc1NJREUiLCJjb3MiLCJ4eCIsIl9jYWNoZVBvaW50cyIsInBvbHlnb24iLCJvZGQiLCJqIiwiYmFja3NxcnQzIiwiRGlhbW9uZFZlcnRpY2FsIiwiX0RpYW1vbmQiLCJ0b3BtaWRkbGUiLCJib3R0b21taWRkbGUiLCJ4bGVmdCIsInhyaWdodCIsIklubmVyU2Nyb2xsQmFyIiwiX1Njcm9sbEJhciIsInNldEhpdCIsIm9uSGl0IiwiU2Nyb2xsR3JvdXAiLCJfc3VwZXIyIiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiLCJfb2Zmc2V0IiwiX3Jlc2V0T2Zmc2V0IiwiX2YiLCJoaXRTY3JvbGxYIiwiaGl0U2Nyb2xsWSIsIl90aGlzNCIsImpmbG93SW5zdGFuY2UiLCJKRkxPVyIsIl9zY3JvbGxXaWR0aCIsIl9vdXRlcldpZHRoIiwiX2lubmVyV2lkdGgiLCJfc2Nyb2xsSGVpZ2h0IiwiX291dGVySGVpZ2h0IiwiX2lubmVySGVpZ2h0Iiwib3V0ZXJXaWR0aCIsIm91dGVySGVpZ2h0IiwiX3RoaXMkX29mZnNldCIsInR4Iiwib2Zmc2V0IiwiX3RoaXMkX29mZnNldDIiLCJfdGhpcyRfb2Zmc2V0MyIsIl90aGlzJGFuY2hvcjQiLCJ3MiIsImgyIiwiX3RoaXMkX29mZnNldDQiLCJfdGhpcyRhbmNob3I1Iiwic3AiLCJpc0luQm91bmQiLCJfdGhpcyRfb2Zmc2V0NSIsIkJhc2VMaW5rIiwidmlld2JveCIsImJyaW5nVG9Ub3AiLCJsaW5rU3RhY2siLCJTaGFkb3dDYWNoZSIsImltYWdlQnVmZmVyIiwiY2FjaGUiLCJkcmF3SW1hZ2UiLCJURVhUX0FMSUdOIiwiQ0VOVEVSIiwiU1BBQ0VfUkVHIiwiVGV4dCIsIl9SZWN0YW5nbGUiLCJjb250ZW50IiwiZm9udEZhbWlseSIsImZvbnRTaXplIiwiZm9udFdlaWdodCIsInRleHRDb2xvciIsInBsYWNlaG9sZGVyQ29sb3IiLCJ0ZXh0QWxpZ24iLCJ0ZXh0QmFzZWxpbmUiLCJsaW5lSGVpZ2h0IiwiaW5kZW50IiwiZWRpdGFibGUiLCJlbGxpcHNpcyIsInBsYWNlaG9sZGVyIiwiZW1wdHlXaGVuSW5wdXQiLCJlZGl0dGluZyIsImRpc2FibGVkIiwiY3Vyc29yQ29sb3IiLCJ0ZXh0UmFuZ2VDb2xvciIsInNwYWNlUGxhY2Vob2xkZXIiLCJzcGFjZVBsYWNlaG9sZGVyQ29sb3IiLCJzcGFjZVJlY29yZHMiLCJfc3BhY2VkQ29udGVudFNlZ21uZW50IiwiX3N0YXR1cyIsImVkaXRpbmciLCJjdXJzb3JzaG93IiwiY3Vyc29yYW5pbWUiLCJsYXN0RWxhcHNlZCIsInJlZnJlc2hFbGFwc2VkIiwiY3Vyc29yRHJhZ2dpbmciLCJzaGlmdE9uIiwib2xkVmFsIiwiaW5wdXRFbGVtZW50IiwiX2N1cnNvck9mZnNldCIsIl90ZXh0UmFuZ2UiLCJyYW5nZWZyb20iLCJyYW5nZVRvIiwiaW5pdGlhbFJhbmdlIiwiX21ha2VGdW5jdGlvbmFsIiwicHJlQ2FsY3VsYXRlVGV4dCIsInNoYWRvd0NhY2hlIiwicmVwbGFjZVNwYWNlSG9sZGVyIiwidXNlQ2FjaGUiLCJyZXBsYWNlIiwibGFzdE9mZnNldCIsImMiLCJfIiwiZm9udCIsInRfaCIsInBhcnNlSW50IiwiY3VycmVudENvbnRlbnQiLCJfY3R4JG1lYXN1cmVUZXh0IiwibWVhc3VyZVRleHQiLCJmb250Qm91bmRpbmdCb3hBc2NlbnQiLCJmb250Qm91bmRpbmdCb3hEZXNjZW50IiwiX3RleHRXaWR0aCIsIl9jYWxjdWxhdGVPZmZzZXQiLCJlbGxpcHNpc0NvbnRlbnQiLCJzdWJzdHJpbmciLCJfY3R4JG1lYXN1cmVUZXh0MiIsInNfd2lkdGgiLCJwY29sb3IiLCJfdGV4dEhlaWdodCIsIl9zaGFkb3dDYWNoZSIsImlzRW1wdHkiLCJfdyIsInNlZyIsImZpbGxUZXh0IiwiX3RoaXM1IiwiZmxhZyIsIl9wb3NpdGlvblRvQ3Vyc29yT2Zmc2V0IiwiY3JlYXRlSW5wdXRFbGVtZW50IiwiX2NvbnRyb2xDYWxsYmFjayIsIl9kZWZhdWx0Q2FsbGJhY2siLCJET013cmFwcGVyIiwiZm9jdXMiLCJwcmV2ZW50U2Nyb2xsIiwic2V0Rm9jdXNJbnN0YW5jZSIsInN5bmNTaGFkb3dJbnB1dFBvc2l0aW9uIiwiX3RoaXM2IiwiYmx1ckhhbmRsZXIiLCJyZW1vdmUiLCJfc2VsZWN0RnVsbFJhbmdlIiwiX3JlZnJlc2hDdXJzb3IiLCJfdGhpczYkX3N0YXR1cyRjdXJzb3IiLCJtb3ZlZCIsIm94IiwiY3Vyc29yT2Zmc2V0Iiwib2ZmeCIsIl90aGlzNyIsIm1heEwiLCJjb250ZW50V2lkdGgiLCJhbGx3aWR0aCIsImcxIiwiZzIiLCJsYXN0aWR4IiwiYzEiLCJjMiIsIncxIiwic3BhbnciLCJkaXNhYmxlQ2FjaGUiLCJ0ZXh0aGVpZ2h0IiwibHgiLCJseSIsImN3IiwiY19sZW4iLCJfdGhpcyRfdGV4dFJhbmdlIiwicmFuZ2UiLCJfaW5wdXRDb250cm9sIiwib3AiLCJfY2xlYXJUZXh0UmFuZ2UiLCJyZWZyZXNoIiwicHJlQ29udGVudCIsImFmdGVyQ29udGVudCIsImNhY2hlSWR4Iiwic3RvcElucHV0RXZlbnQiLCJkZWZhdWx0QWN0Iiwic3RvcElucHV0IiwiYmx1ciIsIl90aGlzOCIsInB4IiwiX29uQXJyb3dMZWZ0IiwiX29uQXJyb3dSaWdodCIsIl9vblNoaWZ0VG9nZ2xlIiwiX2NvcHkiLCJfY3V0IiwiX3Bhc3RlIiwiX3RoaXMkX3RleHRSYW5nZTIiLCJfZ2V0U2VsZWN0aW9uIiwiX3RoaXMkX3RleHRSYW5nZTMiLCJzZWxlY3Rpb24iLCJjbGlwYm9hcmREYXRhIiwic2V0RGF0YSIsInBhc3RlQ29udGVudCIsImdldERhdGEiLCJyZXNvbHZlUGFzdGVDb250ZW50IiwiY29kZSIsInJhd0V2ZW50IiwiX2ZvY3VzIiwiY29udHJvbENhbGxiYWNrIiwiZGVmYXVsdENhbGxiYWNrIiwiaW5wdXQiLCJzZXRBdHRyaWJ1dGUiLCJjdHJsT24iLCJJY29uIiwiaW1hZ2UiLCJvbmxvYWQiLCJpbWFnZUJvdW5kaW5nIiwiaW1hZ2VXaWR0aCIsImltYWdlSGVpZ2h0IiwiY29tcGxldGUiLCJTaGFkb3dEb20iLCJkb21GYWN0b3J5IiwiY3JlYXRlRG9jdW1lbnQiLCJfZG9tIiwiZ2V0UmVhbFdvcmxkUG9zaXRpb24iLCJjb250YWluZXIiLCJwb3MiLCJhcHBlbmRDaGlsZCIsInJlbW92ZUNoaWxkIiwiTGluayIsIl9CYXNlTGluayIsImxpbmVEYXNoIiwiYXBwcm94aW1hdGUiLCJfY2FjaGVBbmdsZSIsIl9jYWNoZUJvdW5kaW5nYm94IiwiX2NhbGN1bGF0ZUFuY2hvclBvaW50cyIsInAwIiwiZnJvbWJveCIsInRvYm94IiwiX2JveCIsIl90aGlzJF9jYWNoZVBvaW50cyIsImFjdHVhbEJvdW5kaW5nQm94TGVmdCIsImFjdHVhbEJvdW5kaW5nQm94UmlnaHQiLCJyZWdpb24iLCJyeSIsInJ3IiwicmgiLCJzZXRMaW5lRGFzaCIsInJvdGF0ZSIsIl90aGlzJF9jYWNoZVBvaW50czIiLCJQSUlOUkFUSU8iLCJQb2x5TGluayIsImRvdWJsZUxpbmsiLCJub0Fycm93IiwiX3N0YXRpYyIsInBFbmQiLCJhbmdsZUVuZCIsImJlZ2luQW5nbGUiLCJwTGFzdCIsInBOZXh0IiwiX21ha2VSYWRpdXNGcm9tVmVjdG9yIiwibGFzdFAiLCJyZW1haW5Qb2ludHMiLCJjdXJyZW50UCIsImNsb25lU3RhdGljIiwiX09iamVjdCRhc3NpZ24iLCJCZXppZXJMaW5rIiwiYmV6aWVyQ3VydmVUbyIsImhhc0ZsaXAiLCJfYmV6aWVyUG9pbnQiLCJfYmV6aWVyUG9pbnQyIiwiTGluZWFyTGF5b3V0IiwiX2NvbmZpZ3MkZ2FwIiwiZ2FwIiwiYWxpZ25tZW50IiwianVzdGlmeSIsImdyb3VwIiwiYWJzb2x1dGVTdGFjayIsImdyb3VwV2lkdGgiLCJyZWR1Y2VIZWlnaHQiLCJsYXN0SW5zdGFuY2VIZWlnaHQiLCJhbGxIZWlnaHQiLCJjaGlsZEFsbCIsIl9pbnN0YW5jZSRnZXRCb3VuZGluZyIsIl9pbnN0YW5jZSRnZXRCb3VuZGluZzIiLCJfaW5zdGFuY2UkZ2V0Qm91bmRpbmczIiwiX2luc3RhbmNlJGdldEJvdW5kaW5nNCIsInJlZHVjZVdpZHRoIiwibGFzdEluc3RhbmNlV2lkdGgiLCJhbGxXaWR0aCIsImFsbFB1cmVXaWR0aCIsIl9pbnN0YW5jZSRnZXRCb3VuZGluZzUiLCJ3aXRoZHJhdyIsImdhcEF2ZXJhZ2UiLCJfaW5zdGFuY2UkZ2V0Qm91bmRpbmc2IiwiX2luc3RhbmNlJGdldEJvdW5kaW5nNyIsIldJRFRIIiwiSEVJR0hUIiwic2hpZnR5Iiwic2hpZnR4IiwiX3Jlc29sdmVBYnNvbHV0ZUFuY2hvciIsImNvbmZpZyIsIl9pbnN0YW5jZSRnZXRCb3VuZGluZzgiLCJFRElUT1JfRVZFTlRTIiwiSU5QVVQiLCJDT05UUk9MX0NNRCIsIktFWUJPQVJEX0lOUFVUIiwiQ09NUE9TSVRJT05fU1RBUlQiLCJDT01QT1NJVElPTl9VUERBVEUiLCJDT01QT1NJVElPTl9FTkQiLCJFTlRFUiIsIkRFTEVURSIsIkJBQ0tTUEFDRSIsIktFWUJPQVJEX0NPTU1BTkRTIiwiQVJST1dfTEVGVCIsIkFSUk9XX1JJR0hUIiwiQVJST1dfVVAiLCJBUlJPV19ET1dOIiwiVU5ETyIsIlJFRE8iLCJTSElGVF9ET1dOIiwiU0hJRlRfVVAiLCJDVFJMQSIsIkNPUFkiLCJDVVQiLCJQQVNURSIsIk1PVVNFX0NPTU1BTkRTIiwiU1RBUlRfRURJVCIsIkVESVRfQ0xJQ0siLCJTSElGVF9PTl9DTElDSyIsIkRPVUJMRV9DTElDSyIsIk9QRVJSQVRJT04iLCJQTEFJTklOUFVUIiwiU1BBQ0VJTlBVVCIsIlJFVFVSTklOUFVUIiwiQ0FSRVRNT1ZFTUVOVCIsIkRFTEVURV9JTl9MSU5FIiwiREVMRVRFX0lOX0VESVRBUkVBIiwiRU5TVVJFX0RFTEVURSIsIlNFTEVDVElPTl9ERUxFVEUiLCJTRUxFQ1RJT05fSU5QVVQiLCJDT01QT1NJVEVfSU5TRVJUIiwiU2hhZG93SW5wdXQiLCJfaW5wdXRFbGVtZW50Iiwia2luZCIsInN5bmNQb3NpdGlvbiIsInJlbW92ZUxpc2VudGVyIiwiQ2FyZXQiLCJzaG93IiwiYW5pbWUiLCJzZXRSb3ciLCJyb3ciLCJfcm93Iiwic2V0Q29sdW1uIiwiY29sdW1ub3JpZHgiLCJjb2x1bW4iLCJfY29sdW1uIiwiZ2V0Um93IiwiZ2V0Q29sdW1uIiwiYW5pbWF0ZSIsImNhbmNlbEFuaW1hdGUiLCJpc1Nob3ciLCJ0b1JhbmdlIiwiZnJvbVJhbmdlIiwiY2FsY3VsYXRlT2Zmc2V0QnlXaWR0aCIsInRleHRtZXRhIiwic3BhY2VIb2xkZXIiLCJnZXRSZW5kZXJTb3VyY2UiLCJBcmVhIiwiX2xpbmVzIiwiZ2V0TGluZUFib3ZlIiwibGluZXMiLCJ0cnVuY2F0ZSIsIkxpbmUiLCJjcmVhdGUiLCJsaW5lIiwiX2VsZW1lbnRzIiwiaW5zZXJ0IiwiZWxlbSIsInRhaWwiLCJjb3B5IiwiZ2V0Q29sdW1uTmVhcmVzdCIsImVsZW1lbnRTcGFjZSIsImVkaXRvciIsImVsZW1lbnRzIiwiZWxlbV9pZHgiLCJsYXN0X2MiLCJfYyIsImxhc3RlbCIsImVsIiwiZG91YmxlTWFyZ2luIiwiRmxhdHRlblRleHRFbGVtZW50cyIsImluc2VydEJlZm9yZSIsImluZXJzZXRBdCIsImluc2VydEFmdGVyIiwibmVlZFdyYXAiLCJzZXROZWVkV3JhcCIsIl90ZXh0RWxlbWVudHMiLCJfdGhpcyRfdGV4dEVsZW1lbnRzIiwicmVtb3ZlZCIsIl9yZWNvcmRzIiwiYXJncyIsIl90aGlzJF90ZXh0RWxlbWVudHMyIiwic3RhcnRSZWNvcmQiLCJfY2FyZXRSZWNvcmQiLCJiZWZvcmUiLCJhZnRlciIsImdldFJlY29yZCIsInJlY29yZEJlZm9yZUNhcmV0IiwiY2FyZXQiLCJyZWNvcmRBZnRlckNhcmV0IiwiZ2V0Q2FyZXRSZWNvcmQiLCJjb2xsZWN0UmVjb3JkcyIsIl9lIiwiVGV4dEVsZW1lbnQiLCJzeW1ib2wiLCJzZXRTb3VyY2VXaXRoUmVjb3JkIiwicmVjb3JkcyIsImxhc3RTb3VyY2UiLCJzZXRTb3VyY2UiLCJfc3BhY2VSZWNvcmRzIiwibGFzdFdyYXAiLCJzdGVwIiwibmV4dE9mZnNldCIsInRhaWxPZmZzZXQiLCJpc1RhaWwiLCJoZWFkT2Zmc2V0IiwiX3JldHVyblN5bWJvbCIsInJldHVybkZvbnQiLCJSYW5nZSIsInNldEluaXRpYWxSYW5nZSIsIl9pbml0aWFsUmFuZ2UiLCJnZXRSYW5nZUZyb20iLCJfcmFuZ2VGcm9tIiwiZ2V0UmFuZ2VUbyIsIl9yYW5nZVRvIiwiaXNFbmFibGUiLCJfZW5hYmxlIiwiZGlzYWJsZSIsImhhbmRsZUNhcmV0IiwiX3RoaXMkX3JhbmdlVG8iLCJzZXRSYW5nZSIsImFub3RoZXIiLCJfY29tcGFyZVJhbmdlIiwiZ2V0UmFuZ2VDb3B5IiwiYXJlYSIsIl9hcmVhIiwiX2NhcmV0IiwicmFuZ2VGcm9tIiwiZWxlbUZyb20iLCJlbGVtVG8iLCJmbGF0dGVuVHh0RWxlbSIsIl9mbGF0dGVuVHh0RWxlbSIsImZyb21JZHgiLCJ0b0lkeCIsImVsZW1zIiwicHJlRWxlbWVudCIsImFmdGVyRWxlbWVudCIsImVuZFRleHROZWVkV3JhcCIsImlzU2V0U291cmNlQmF0Y2giLCJVbmRvUmVkbyIsIndyaXRlIiwiY2FyZXRSZWNvcmQiLCJsYXN0VW5kbyIsImdldExhc3RVbmRvIiwiX2JhdGNoIiwiX2NhcmV0TWV0YVRvIiwiQmF0Y2hBY3Rpb24iLCJfY2FyZXRNZXRhRnJvbSIsIl91bmRvIiwiX2xlbmd0aCIsIl9yZWRvIiwidW5kbyIsInBvcCIsIl9lZGl0b3IiLCJyZWRvIiwiU0tJUF9SRURPIiwiZGVmYXVsdCIsImJhdGNoIiwidXBkYXRlQ2FyZXRNZXRhVG8iLCJyZXZlcnNlIiwiYWN0aW9uIiwiX2FjdGlvbiRhcmdzIiwiX3JhbmdlIiwiX2FjdGlvbiRhcmdzMiIsImxzIiwiX2FjdGlvbiRhcmdzMyIsIm8iLCJfYWN0aW9uJGFyZ3M0IiwiX3RvQXJyYXkiLCJfYWN0aW9uJGFyZ3M1IiwiX2FjdGlvbiRhcmdzNiIsIkNvbW1hbmQiLCJleGVjIiwiQXJyb3dMZWZ0Q29tbWFuZCIsIl9Db21tYW5kIiwiZWxlbWlkeCIsImVsZW1lbnQiLCJyZXN1bHQiLCJwcmVSb3ciLCJwcmVFbGVtaWR4IiwiQXJyb3dSaWdodENvbW1hbmQiLCJfQ29tbWFuZDIiLCJfY29sdW1uMiIsImFmdGVyUm93IiwiQXJyb3dVcENvbW1hbmQiLCJfQ29tbWFuZDMiLCJfc3VwZXIzIiwibmV4dFJvdyIsIl9oYW5kbGVyIiwiQXJyb3dEb3duQ29tbWFuZCIsIl9Db21tYW5kNCIsIl9zdXBlcjQiLCJfbWl4aW4iLCJfY29sdW1uMyIsImN1cnJFbGVtIiwiY3VyckVsZW1SZWR1Y2VXaWR0aCIsIm1lYXN1cmVUZXh0V2lkdGgiLCJuZXh0TGluZSIsIm5leHRDb2x1bW4iLCJfYmxhbmRBZGphY2VudEVsZW1lbnQiLCJlbGVtMSIsImVsZW0yIiwiZGVmYXVsdE9mZnNldCIsIklucHV0IiwiX2xlbiIsIl9rZXkiLCJ1bmRvcmVkbyIsIl91bmRvcmVkbyIsIl9jYXJldCRnZXRDb2x1bW4iLCJfY2FyZXQkZ2V0Q29sdW1uMiIsInByZUVsZW0iLCJuZXdFbGVtZW50IiwidGVzdCIsInJvd3MiLCJsYXN0TmVlZFdyYXAiLCJ0ZW1wIiwidG4iLCJjb2wiLCJfdCIsIl9ibGFuZEFkamFjZW50RWxlbWVudDIiLCJfYmxhbmRBZGphY2VudEVsZW1lbnQzIiwiZGVsZXRlb3AiLCJfYmxhbmRBZGphY2VudEVsZW1lbnQ0IiwiX2JsYW5kQWRqYWNlbnRFbGVtZW50NSIsInNoaWZ0cmVzdWx0IiwibmV4dEVsZW0iLCJfYmxhbmRBZGphY2VudEVsZW1lbnQ2IiwiX2JsYW5kQWRqYWNlbnRFbGVtZW50NyIsIl9ibGFuZEFkamFjZW50RWxlbWVudDgiLCJfYmxhbmRBZGphY2VudEVsZW1lbnQ5IiwiU3RhcnRFZGl0Q29tbWFuZCIsIl9zdGFydEVkaXQiLCJtb3ZlQ2FyZXRCeUhpdFBvaW50IiwiY3JlYXRlU2hhZG93SW5wdXQiLCJFZGl0Q2xpY2tDb21tYW5kIiwiRG91YmxlQ2xpY2tDb21tYW5kIiwiU2hpZnRVcENvbW1hbmQiLCJ0b2dnbGVTaGlmdCIsIlNoaWZ0RG93bkNvbW1hbmQiLCJTaGlmdE9uQ2xpY2tDb21tYW5kIiwiQ3RybEFDb21tYW5kIiwiVW5kb0NvbW1hbmQiLCJSZWRvQ29tbWFuZCIsIkNvcHlDb21tYW5kIiwiQ3V0Q29tbWFuZCIsImNtZCIsImNvbW1hbmRzIiwiUGFzdGVDb21tYW5kIiwiX3ByZXZlbnREZWZhdWx0IiwiVGV4dEdyb3VwIiwiX3NoYWRvd0lucHV0IiwibGluZVNwYWNlIiwicmVzb2x2ZXIiLCJkcmFnb3ZlciIsInJlZ2lzdENvbW1hbmQiLCJfbmFtZSIsImV4ZWNDb21tYW5kIiwiY29tbW5kIiwidGV4dEVsZW1lbnRzIiwib25Ecm9wIiwibGFzdExlbmd0aCIsInNoYWRvd0lucHV0IiwiX3RoaXMkX3Bvc2l0aW9uVG9DdXJzIiwicmVmcmVzaFRleHRFbGVtZW50cyIsImN1cnJMaW5lIiwiX2NhcmV0VG9Qb3NpdGlvbiIsImN1cnJlbnRMaW5lSGVpZ2h0IiwiX3RoaXMkX2NhcmV0VG9Qb3NpdGlvIiwiX3RoaXMkX2NhcmV0VG9Qb3NpdGlvMiIsIl9yYW5kZXJDdXJzb3IiLCJfcmVuZGVyUmFuZ2UiLCJfdGhpcyRfY2FyZXRUb1Bvc2l0aW8zIiwiX3RoaXMkX2NhcmV0VG9Qb3NpdGlvNCIsImJsb2NraGVpZ2h0IiwiYmxvY2t3aWR0aCIsIl9yYW5nZSRnZXRSYW5nZUZyb20iLCJfcmFuZ2UkZ2V0UmFuZ2VGcm9tMiIsInJfZiIsImlkeF9mIiwib2Zmc2V0X2YiLCJfcmFuZ2UkZ2V0UmFuZ2VUbyIsIl9yYW5nZSRnZXRSYW5nZVRvMiIsInJfdCIsImlkeF90Iiwib2Zmc2V0X3QiLCJzcGFjZSIsIl9tZWFzdXJlRWxlbWVudE9mZnNldFgiLCJfciIsImJlZ2lubmluZyIsImxhc3RFbGVtIiwidmFsaWRJbnN0YW5jZSIsIl90aGlzNyRhbmNob3IiLCJuZXh0QXJlYSIsImxhc3RSZWR1Y2VZIiwicmVkdWNlWCIsInJlbmRlck5vZGUiLCJOb2RlUGxhY2Vob2xkZXIiLCJBbmltZU1peGluIiwiTWluaU1hcE1peGluIiwiU2Nyb2xsQmFyTWl4aW4iLCJTY2hlZHVsZU1peGluIiwiR3JvdXAiLCJDYXBzdWxlR3JvdXAiLCJSaG9tYnVzR3JvdXAiLCJEaWFtb25kR3JvdXAiLCJEaWFtb25kVmVydGljYWxHcm91cCIsIkNhcHN1bGVWZXJ0aWNhbEdyb3VwIiwiUG9pbnRHcm91cCIsImNlaWwiLCJKRmxvdyIsImV2ZW50QWRhcHRlciIsImluaXRpYWxab29tIiwiaW5pdGlhbFBvc2l0aW9uIiwic2V0SW5pdGlhbFBvc2l0aW9uIiwibWF4Wm9vbSIsIm1pblpvb20iLCJ3b3JsZE1hcmdpbiIsImRyYWdnaW5nYmVoYXZpb3IiLCJwYW5JbkJvcmRlciIsImRlbHRhbW92ZW1lbnQiLCJhbGxvd01vdmluZ1RhcmdldEluUGFuIiwic2Nyb2xsQmFyQmVoYXZpb3IiLCJvZmZlc2V0IiwiX2xhc3RTdGF0ZSIsInByb2Nlc3NpbmciLCJfbGFzdERyYWdTdGF0ZSIsIm1vdmluZyIsImlzSW5zdGFuY2VEaXJ0eSIsImlzTGlua0RpcnR5IiwiYmVsb25ncyIsImluaXRpYWxYIiwiaW5pdGlhbFkiLCJkcmFnb3ZlcmluZyIsIl9kcmFnT3ZlclRhcmdldCIsImFsbG93RHJvcCIsIl90ZW1wTm9kZSIsIl90ZW1wTGluayIsIm1vZGUiLCJfYWxsb3dNb3ZpbmdUYXJnZXQiLCJzZXRNb3ZpbmdUYXJnZXRzIiwidGFyZ2V0cyIsInNldFRlbXBEcmFnZ2luZ0luc3RhbmNlIiwicmVtb3ZlVGVtcERyYWdnaW5nSW5zdGFuY2UiLCJwcmV2ZW50RGVmYXVsdERyYWdnaW5nIiwiYWxsb3dEZWZhdWx0RHJhZ2dpbmciLCIkbW91bnQiLCJkb20iLCJfY3JlYXRlQ2FudmFzIiwiY193aWR0aCIsImNfaGVpZ2h0IiwiJGpmbG93IiwiY29udGVudEJveCIsIndfcmF0aW8iLCJoX3JhdGlvIiwiYWxpZ24iLCJzY2FsZVJhdGlvIiwicmVhbGJveFgiLCJyZWFsYm94WSIsInJlYWxib3hXIiwicmVhbGJveEgiLCJfdGhpcyRpbml0aWFsUG9zaXRpb24iLCJfcmVhZHlUb1JlbmRlciIsIl9jcmVhdGVFdmVudEhhbmRsZXIiLCJkZXN0cm95RHByTGlzdGVuZXIiLCJzZXRMaW5raW5nTW9kZSIsImxpbmtHZW4iLCJpc0luTGlua2luZ01vZGUiLCJzZXRMaW5raW5nTGluayIsInJlc2V0TGlua2luZ0xpbmsiLCJjbGVhclRlbXAiLCJwcmV2ZW50Q2xlYXJUZW1wIiwiX3ByZXZlbnRDbGVhclRlbXAiLCJfcmVzaXplQ2FudmFzMiIsImZvY3VzT24iLCJub3d4Iiwibm93eSIsImRlc3Ryb3lMaXN0ZW5lciIsImRlc3Ryb3lQbGFpbkV2ZW50TGlzdGVuZXIiLCJkcmFnb3ZlckhhbmRsZXIiLCJfb25EcmFnb3ZlciIsImRyb3BIYW5kbGVyIiwiX29uRHJvcCIsImRyYWdsZWF2ZUhhbmxkZXIiLCJfb25EcmFnTGVhdmUiLCJfdGFyZ2V0TG9ja09uIiwib2Zmc2V0UG9pbnQiLCJ0b3BMYXllclBvaW50IiwibW92aW5ndGFyZ2V0IiwiT05fVE9QIiwicmVsYXRlZFRhcmdldCIsIl9wcm9jZXNzRHJhZ092ZXIiLCJfdGhpcyRyZWFkTWVzc2FnZSIsIl9kcmFnQ3VycmVudERhdGEiLCJvbGRJbnMiLCJfcHJvY2Vzc1BhbkluQm9yZGVyIiwiX3RoaXMkZHJhZ2dpbmdiZWhhdmlvIiwiX3RoaXMkX2NhY2hlVmlld0JveCIsIl90aGlzJF9jdXJyZW50cCIsInB5IiwiX3RoaXMkZHJhZ2dpbmdiZWhhdmlvMiIsIl9fcHJvY2Vzc092ZXJBbmltZSIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsIl9jYW5jZWxQYW5JbkJvcmRlciIsIl90aGlzJGRyYWdnaW5nYmVoYXZpbzMiLCJwYXlsb2FkIiwiX3RoaXMkX3RhcmdldCIsIl90aGlzJF90YXJnZXQkY2FjaGUiLCJjYW5jZWxEcm9wIiwiX3pvb21pbmciLCJfdGhpcyRib3VuZGluZ19ib3gzIiwiY2giLCJuZXdTY2FsZSIsImFtb3VudCIsImRlbHRhU2NhbGUiLCJjdXJyZW50V2lkdGgiLCJjdXJyZW50SGVpZ2h0IiwiZGVsdGFXaWR0aCIsImRlbHRhSGVpZ2h0IiwidFgiLCJ0WSIsInBYIiwicFkiLCJfdGhpczkiLCJfcGFubmluZyIsIl90aGlzMTAiLCJfdGhpcyRfdGFyZ2V0TG9ja09uIiwiX3Jlc29sdmVMb2NrT25UYXJnZXQiLCJfcHJldmVudFByZXNzU2VxdWVlbmNlIiwiX2NsZWFyVGFyZ2V0IiwiX3RoaXMxMSIsIl90aGlzJF90YXJnZXQkc3RhdHVzIiwiX3RoaXMkX3RhcmdldCRtZXRhIiwiX3RoaXMkX3RhcmdldExvY2tPbjIiLCJfdGhpcyRfdGFyZ2V0TG9ja09uMyIsImlzRG9jdW1lbnQiLCJjaGVja3Jlc3VsdCIsIl90aGlzJF90YXJnZXQkY2FjaGUyIiwiX3RoaXMkX3RhcmdldExvY2tPbjQiLCJfdGhpcyRfdGFyZ2V0TG9ja09uNSIsIl90aGlzJF90YXJnZXRMb2NrT242IiwiX3RoaXMkYm91bmRpbmdfYm94NCIsImJ4MSIsImJ4MiIsImJ5MSIsImJ5MiIsIl9jYWxjdWxhdGVEaXN0YW5jZSIsIl9yZXNldFRyYW5zZm9ybSIsIl90aGlzJGNhbnZhc01ldGEzIiwicmVzZXRUcmFuc2Zvcm0iLCJzZXROb2RlVG9Ub3BMYXllciIsIl90aGlzJF9zdGFjayRzcGxpY2UiLCJfdGhpcyRfc3RhY2skc3BsaWNlMiIsIl9pc0luVmlld0JveCIsImNvbW1vbkV2ZW50QWRhcHRlciIsInBhY2thZ2VKc29uIiwiJGpmbG93X3ZlcnNpb24iLCJ2ZXJzaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///406\n')}},__webpack_require__={d:(Q,U)=>{for(var B in U)__webpack_require__.o(U,B)&&!__webpack_require__.o(Q,B)&&Object.defineProperty(Q,B,{enumerable:!0,get:U[B]})},o:(Q,U)=>Object.prototype.hasOwnProperty.call(Q,U),r:Q=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})}},__webpack_exports__={};return __webpack_modules__[406](0,__webpack_exports__,__webpack_require__),__webpack_exports__})()}));
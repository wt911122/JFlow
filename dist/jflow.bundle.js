!function(Q,U){"object"==typeof exports&&"object"==typeof module?module.exports=U():"function"==typeof define&&define.amd?define([],U):"object"==typeof exports?exports["@joskii/jflow"]=U():Q["@joskii/jflow"]=U()}(self,(function(){return(()=>{"use strict";var __webpack_modules__={406:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "BaseLink": () => (/* reexport */ base_link),\n  "BezierLink": () => (/* reexport */ bezier_link),\n  "Capsule": () => (/* reexport */ capsule),\n  "CapsuleGroup": () => (/* reexport */ CapsuleGroup),\n  "CapsuleVertical": () => (/* reexport */ capsule_vertical),\n  "CapsuleVerticalGroup": () => (/* reexport */ CapsuleVerticalGroup),\n  "Diamond": () => (/* reexport */ diamond),\n  "DiamondGroup": () => (/* reexport */ DiamondGroup),\n  "DiamondVerticalGroup": () => (/* reexport */ DiamondVerticalGroup),\n  "Group": () => (/* reexport */ Group),\n  "GroupFactory": () => (/* reexport */ groupFactory),\n  "Icon": () => (/* reexport */ instance_image),\n  "Instance": () => (/* reexport */ instance_instance),\n  "JFLOW_MODE": () => (/* reexport */ JFLOW_MODE),\n  "JFlowEvent": () => (/* reexport */ events),\n  "LinearLayout": () => (/* reexport */ linear_layout),\n  "Link": () => (/* reexport */ instance_link),\n  "Node": () => (/* reexport */ node),\n  "NodePlaceholder": () => (/* reexport */ NodePlaceholder),\n  "Point": () => (/* reexport */ point),\n  "PointGroup": () => (/* reexport */ PointGroup),\n  "PolyLink": () => (/* reexport */ poly_link),\n  "Rectangle": () => (/* reexport */ rectangle),\n  "Rhombus": () => (/* reexport */ rhombus),\n  "RhombusGroup": () => (/* reexport */ RhombusGroup),\n  "ScrollGroup": () => (/* reexport */ scroll_group),\n  "ShadowDom": () => (/* reexport */ shadowDom),\n  "Text": () => (/* reexport */ elements_text),\n  "TextElement": () => (/* reexport */ TextElement),\n  "TextGroup": () => (/* reexport */ text_group),\n  "addReflowWork": () => (/* reexport */ dirty_work_addReflowWork),\n  "commonEventAdapter": () => (/* reexport */ commonAdapter),\n  "default": () => (/* binding */ src)\n});\n\n;// CONCATENATED MODULE: ./package.json\nconst package_namespaceObject = {"i8":"1.0.8"};\n;// CONCATENATED MODULE: ./src/core/utils/canvas.js\n/**\n * @typedef {Object} CanvasMeta\n * @property {Element} canvas - canvas 元素\n * @property {number} width - 画布宽度\n * @property {number} height - 画布高度\n * @property {number} raw_width - 画布元素宽度\n * @property {number} raw_height - 画布元素高度\n * @property {number} left - 画布距离左端距离\n * @property {number} top - 画布距离顶端距离\n * @property {Context2d} ctx - Context2d\n * @property {number} scale - 当前的像素设备比\n */\n/**\n * 创建一个 canvas 元素\n * @param  {Element} wrapper - dom元素\n * @return {CanvasMeta}\n */\nfunction createCanvas(wrapper) {\n  var canvas = document.createElement(\'canvas\');\n  var ctx = canvas.getContext(\'2d\');\n  var _wrapper$getBoundingC = wrapper.getBoundingClientRect(),\n    width = _wrapper$getBoundingC.width,\n    height = _wrapper$getBoundingC.height,\n    left = _wrapper$getBoundingC.left,\n    top = _wrapper$getBoundingC.top;\n  canvas.style.width = width + "px";\n  canvas.style.height = height + "px";\n  canvas.style.userSelect = \'none\';\n  var scale = window.devicePixelRatio;\n  canvas.width = Math.floor(width * scale);\n  canvas.height = Math.floor(height * scale);\n  if (wrapper) {\n    wrapper.style.position = \'relative\';\n    wrapper.style.overflow = \'hidden\';\n    wrapper.append(canvas);\n  }\n  return {\n    canvas: canvas,\n    width: width,\n    height: height,\n    raw_width: canvas.width,\n    raw_height: canvas.height,\n    left: left,\n    top: top,\n    ctx: ctx,\n    scale: scale\n  };\n}\nfunction canvas_resizeCanvas(canvas, wrapper) {\n  var _wrapper$getBoundingC2 = wrapper.getBoundingClientRect(),\n    width = _wrapper$getBoundingC2.width,\n    height = _wrapper$getBoundingC2.height,\n    left = _wrapper$getBoundingC2.left,\n    top = _wrapper$getBoundingC2.top;\n  canvas.style.width = width + "px";\n  canvas.style.height = height + "px";\n  var scale = window.devicePixelRatio;\n  canvas.width = Math.floor(width * scale);\n  canvas.height = Math.floor(height * scale);\n  return {\n    width: width,\n    height: height,\n    raw_width: canvas.width,\n    raw_height: canvas.height\n  };\n}\nvar caheCanvas = document.createElement(\'canvas\');\ncaheCanvas.width = 1;\ncaheCanvas.height = 1;\nvar caheCanvasctx = caheCanvas.getContext(\'2d\');\nvar scale = window.devicePixelRatio;\ncaheCanvasctx.scale(scale, scale);\n\n/**\n * 在离线canvas上绘制元素\n * @param  {render} render - 绘图函数\n */\nfunction requestCacheCanvas(render) {\n  caheCanvasctx.clearRect(0, 0, 5, 5);\n  caheCanvasctx.save();\n  render(caheCanvasctx);\n  caheCanvasctx.restore();\n  caheCanvasctx.clearRect(0, 0, 5, 5);\n}\nfunction listenOnDevicePixelRatio(callback, destroyHandler) {\n  var target = matchMedia("(resolution: ".concat(window.devicePixelRatio, "dppx)"));\n  function onChange() {\n    console.log("devicePixelRatio changed: " + window.devicePixelRatio);\n    callback(window.devicePixelRatio);\n    listenOnDevicePixelRatio(callback, destroyHandler);\n  }\n  destroyHandler(function () {\n    console.log(\'remove devicePixelRatio event handler\');\n    target.removeEventListener("change", onChange, {\n      once: true\n    });\n  });\n  target.addEventListener("change", onChange, {\n    once: true\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/bezier-js/src/utils.js\n\n\n// math-inlining.\nconst { abs, cos, sin, acos, atan2, sqrt, pow } = Math;\n\n// cube root function yielding real roots\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n}\n\n// trig constants\nconst pi = Math.PI,\n  tau = 2 * pi,\n  quart = pi / 2,\n  // float precision significant decimal\n  epsilon = 0.000001,\n  // extremas used in bbox calculation and similar algorithms\n  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n  // a zero coordinate, which is surprisingly useful\n  ZERO = { x: 0, y: 0, z: 0 };\n\n// Bezier utility functions\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [\n    -0.0640568928626056260850430826247450385909,\n    0.0640568928626056260850430826247450385909,\n    -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404,\n    -0.3150426796961633743867932913198102407864,\n    0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524,\n    0.4337935076260451384870842319133497124524,\n    -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107,\n    -0.6480936519369755692524957869107476266696,\n    0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232,\n    0.7401241915785543642438281030999784255232,\n    -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761,\n    -0.8864155270044010342131543419821967550873,\n    0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548,\n    0.9382745520027327585236490017087214496548,\n    -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411,\n    -0.9951872199970213601799974097007368118745,\n    0.9951872199970213601799974097007368118745,\n  ],\n\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [\n    0.1279381953467521569740561652246953718517,\n    0.1279381953467521569740561652246953718517,\n    0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264,\n    0.121670472927803391204463153476262425607,\n    0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622,\n    0.1155056680537256013533444839067835598622,\n    0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946,\n    0.0976186521041138882698806644642471544279,\n    0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185,\n    0.086190161531953275917185202983742667185,\n    0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193,\n    0.0592985849154367807463677585001085845412,\n    0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593,\n    0.0442774388174198061686027482113382288593,\n    0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491,\n    0.0123412297999871995468056670700372915759,\n    0.0123412297999871995468056670700372915759,\n  ],\n\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== "undefined") {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points;\n\n    // constant?\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    }\n\n    // linear?\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n      return ret;\n    }\n\n    // quadratic/cubic curve?\n    if (order < 4) {\n      let mt2 = mt * mt,\n        t2 = t * t,\n        a,\n        b,\n        c,\n        d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n      return ret;\n    }\n\n    // higher order curves: use de Casteljau\'s computation\n    const dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,\n        };\n        if (typeof dCpts[i].z !== "undefined") {\n          dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n      r = ratios,\n      p = points;\n\n    let f1 = r[0],\n      f2 = r[1],\n      f3 = r[2],\n      f4 = r[3],\n      d;\n\n    // spec for linear\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to quadratic\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to cubic\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d\n          ? false\n          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t,\n      };\n    }\n  },\n\n  derive: function (points, _3d) {\n    const dpoints = [];\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y),\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n        list.push(dpt);\n      }\n      dpoints.push(list);\n      p = list;\n    }\n    return dpoints;\n  },\n\n  between: function (v, m, M) {\n    return (\n      (m <= v && v <= M) ||\n      utils.approximately(v, m) ||\n      utils.approximately(v, M)\n    );\n  },\n\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n\n  length: function (derivativeFn) {\n    const z = 0.5,\n      len = utils.Tvalues.length;\n\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n    return z * sum;\n  },\n\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n      d2 = te - ts,\n      v2 = v - ds,\n      r = v2 / d1;\n    return ts + d2 * r;\n  },\n\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y),\n    };\n    if (v1.z !== undefined && v2.z !== undefined) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n\n  pointToString: function (p) {\n    let s = p.x + "/" + p.y;\n    if (typeof p.z !== "undefined") {\n      s += "/" + p.z;\n    }\n    return s;\n  },\n\n  pointsToString: function (points) {\n    return "[" + points.map(utils.pointToString).join(", ") + "]";\n  },\n\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n      dy1 = v1.y - o.y,\n      dx2 = v2.x - o.x,\n      dy2 = v2.y - o.y,\n      cross = dx1 * dy2 - dy1 * dx2,\n      dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = "" + v;\n    const pos = s.indexOf(".");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n      dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n      mpos,\n      d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return { mdist: mdist, mpos: mpos };\n  },\n\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === "undefined") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const bottom = pow(t, n) + pow(1 - t, n),\n      top = bottom - 1;\n    return abs(top / bottom);\n  },\n\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === "undefined") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const top = pow(1 - t, n),\n      bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx =\n        (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d == 0) {\n      return false;\n    }\n    return { x: nx / d, y: ny / d };\n  },\n\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      x3 = p3.x,\n      y3 = p3.y,\n      x4 = p4.x,\n      y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n\n  makeline: function (p1, p2) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      dx = (x2 - x1) / 3,\n      dy = (y2 - y1) / 3;\n    return new Bezier(\n      x1,\n      y1,\n      x1 + dx,\n      y1 + dy,\n      x1 + 2 * dx,\n      y1 + 2 * dy,\n      x2,\n      y2\n    );\n  },\n\n  findbbox: function (sections) {\n    let mx = nMax,\n      my = nMax,\n      MX = nMin,\n      MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },\n    };\n  },\n\n  shapeintersections: function (\n    s1,\n    bbox1,\n    s2,\n    bbox2,\n    curveIntersectionThreshold\n  ) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end]),\n    };\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(\n        shape,\n        shape.bbox,\n        s2,\n        s2.bbox,\n        curveIntersectionThreshold\n      );\n    };\n    return shape;\n  },\n\n  getminmax: function (curve, d, list) {\n    if (!list) return { min: 0, max: 0 };\n    let min = nMax,\n      max = nMin,\n      t,\n      c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n      if (c[d] < min) {\n        min = c[d];\n      }\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n    return { min: min, mid: (min + max) / 2, max: max, size: max - min };\n  },\n\n  align: function (points, line) {\n    const tx = line.p1.x,\n      ty = line.p1.y,\n      a = -atan2(line.p2.y - ty, line.p2.x - tx),\n      d = function (v) {\n        return {\n          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a),\n        };\n      };\n    return points.map(d);\n  },\n\n  roots: function (points, line) {\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\n\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n        b = aligned[1].y,\n        c = aligned[2].y,\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n      return [];\n    }\n\n    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n    const pa = aligned[0].y,\n      pb = aligned[1].y,\n      pc = aligned[2].y,\n      pd = aligned[3].y;\n\n    let d = -pa + 3 * pb - 3 * pc + pd,\n      a = 3 * pa - 6 * pb + 3 * pc,\n      b = -3 * pa + 3 * pb,\n      c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        }\n        // linear solution:\n        return [-c / b].filter(reduce);\n      }\n      // quadratic solution:\n      const q = sqrt(b * b - 4 * a * c),\n        a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    }\n\n    // at this point, we know we need a cubic solution:\n\n    a /= d;\n    b /= d;\n    c /= d;\n\n    const p = (3 * b - a * a) / 3,\n      p3 = p / 3,\n      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n      q2 = q / 2,\n      discriminant = q2 * q2 + p3 * p3 * p3;\n\n    let u1, v1, x1, x2, x3;\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n        mp33 = mp3 * mp3 * mp3,\n        r = sqrt(mp33),\n        t = -q / (2 * r),\n        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n        phi = acos(cosphi),\n        crtr = crt(r),\n        t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n        b = p[1],\n        c = p[2],\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    }\n\n    // linear roots are even easier\n    if (p.length === 2) {\n      const a = p[0],\n        b = p[1];\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n      return [];\n    }\n\n    return [];\n  },\n\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n      dnm,\n      adk,\n      dk,\n      k = 0,\n      r = 0;\n\n    //\n    // We\'re using the following formula for curvature:\n    //\n    //              x\'y" - y\'x"\n    //   k(t) = ------------------\n    //           (x\'² + y\'²)^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y\'z" - y"z\')² + (z\'x" - z"x\')² + (x\'y" - x"y\')²)\n    //   k(t) = -------------------------------------------------------\n    //                     (x\'² + y\'² + z\'²)^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(\n        pow(d.y * dd.z - dd.y * d.z, 2) +\n          pow(d.z * dd.x - dd.z * d.x, 2) +\n          pow(d.x * dd.y - dd.x * d.y, 2)\n      );\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return { k: 0, r: 0 };\n    }\n\n    k = num / dnm;\n    r = dnm / num;\n\n    // We\'re also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we\'re just going to\n    // ballpark it based on an epsilon.\n    if (!kOnly) {\n      // compute k\'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return { k: k, r: r, dk: dk, adk: adk };\n  },\n\n  inflections: function (points) {\n    if (points.length < 4) return [];\n\n    // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),\n      a = p[2].x * p[1].y,\n      b = p[3].x * p[1].y,\n      c = p[1].x * p[2].y,\n      d = p[3].x * p[2].y,\n      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n      v2 = 18 * (3 * a - b - 3 * c),\n      v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n      return [];\n    }\n\n    const trm = v2 * v2 - 4 * v1 * v3,\n      sq = Math.sqrt(trm),\n      d2 = 2 * v1;\n\n    if (utils.approximately(d2, 0)) return [];\n\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n\n  bboxoverlap: function (b1, b2) {\n    const dims = ["x", "y"],\n      len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n    return true;\n  },\n\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n      c2b = c2.bbox(),\n      r = 100000,\n      threshold = curveIntersectionThreshold || 0.5;\n\n    if (\n      c1b.x.size + c1b.y.size < threshold &&\n      c2b.x.size + c2b.y.size < threshold\n    ) {\n      return [\n        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +\n          "/" +\n          (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,\n      ];\n    }\n\n    let cc1 = c1.split(0.5),\n      cc2 = c2.split(0.5),\n      pairs = [\n        { left: cc1.left, right: cc2.left },\n        { left: cc1.left, right: cc2.right },\n        { left: cc1.right, right: cc2.right },\n        { left: cc1.right, right: cc2.left },\n      ];\n\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n\n    let results = [];\n\n    if (pairs.length === 0) return results;\n\n    pairs.forEach(function (pair) {\n      results = results.concat(\n        utils.pairiteration(pair.left, pair.right, threshold)\n      );\n    });\n\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n\n    return results;\n  },\n\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n      dy1 = p2.y - p1.y,\n      dx2 = p3.x - p2.x,\n      dy2 = p3.y - p2.y,\n      dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n      dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n      dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n      dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n      // chord midpoints\n      mx1 = (p1.x + p2.x) / 2,\n      my1 = (p1.y + p2.y) / 2,\n      mx2 = (p2.x + p3.x) / 2,\n      my2 = (p2.y + p3.y) / 2,\n      // midpoint offsets\n      mx1n = mx1 + dx1p,\n      my1n = my1 + dy1p,\n      mx2n = mx2 + dx2p,\n      my2n = my2 + dy2p,\n      // intersection of these lines:\n      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n      r = utils.dist(arc, p1);\n\n    // arc start/end values, over mid point:\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n      m = atan2(p2.y - arc.y, p2.x - arc.x),\n      e = atan2(p3.y - arc.y, p3.x - arc.x),\n      _;\n\n    // determine arc direction (cw/ccw correction)\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    }\n    // assign and done.\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n\n  numberSort: function (a, b) {\n    return a - b;\n  },\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/bezier-js/src/poly-bezier.js\n\n\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return (\n      "[" +\n      this.curves\n        .map(function (curve) {\n          return utils.pointsToString(curve.points);\n        })\n        .join(", ") +\n      "]"\n    );\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves\n      .map(function (v) {\n        return v.length();\n      })\n      .reduce(function (a, b) {\n        return a + b;\n      });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/bezier-js/src/bezier.js\n/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\n\n\n\n// math-inlining.\nconst { abs: bezier_abs, min, max, cos: bezier_cos, sin: bezier_sin, acos: bezier_acos, sqrt: bezier_sqrt } = Math;\nconst bezier_pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst bezier_ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === "object") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        ["x", "y", "z"].forEach(function (d) {\n          if (typeof point[d] !== "undefined") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            "Only new Bezier(point[]) is accepted for 4th and higher order curves"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            "Only new Bezier(point[]) is accepted for 4th and higher order curves"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== "undefined"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = ["x", "y"]);\n    if (_3d) dims.push("z");\n    this.dimlen = dims.length;\n\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    this._linear = !aligned.some((p) => bezier_abs(p.y) > 0.0001);\n\n    this._lut = [];\n\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === "undefined") {\n      t = 0.5;\n    }\n    // shortcuts, although they\'re really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === "undefined") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === "undefined") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = ["M", x, y, this.order === 2 ? "Q" : "C"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(" ");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error("incorrect number of ratio values");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return "" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join("");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps) {\n      return this._lut;\n    }\n    this._lut = [];\n    // We want a range from 0 to 1 inclusive, so\n    // we decrement and then use <= rather than <:\n    steps--;\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = bezier_sqrt(d.x * d.x + d.y * d.y);\n    return { x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = bezier_sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = bezier_sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = bezier_sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use "de Casteljau" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we\'re done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== "undefined") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return bezier_abs(bezier_acos(s)) < bezier_pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (bezier_abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === "function") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for degenerate (=linear) curves.\n    const clockwise = this.clockwise;\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const points = this.points;\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error("cannot scale this curve. Try reducing it first.");\n    }\n    // move all points by distance \'d\' wrt the origin \'o\'\n\n    // move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by "however much necessary to\n    // ensure the correct tangent to endpoint".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = bezier_sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = typeof d2 === "undefined" ? d1 : d2;\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== "undefined" && typeof d4 !== "undefined";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the "return" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves),\n      slen = segments.length;\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // "simple" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return bezier_abs(d1 - ref) + bezier_abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the "good `t` closest to no-longer-good"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move \'e\' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we\'re done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc\'s end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * bezier_cos(arc.e),\n                y: arc.y + arc.r * bezier_sin(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move \'e\' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log("L835: [F] arc found", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\n\n\n;// CONCATENATED MODULE: ./src/core/utils/constance.js\n/**\n * 方向\n * @readonly\n * @enum {number}\n */\nvar DIRECTION = {\n  /** RIGHT */\n  RIGHT: 0,\n  /** BOTTOM */\n  BOTTOM: 1,\n  /** LEFT */\n  LEFT: 2,\n  /** TOP */\n  TOP: 3,\n  /** SELF */\n  SELF: 100\n};\nfunction nextDirection(direction, clockwise) {\n  var nextDir = (direction + (clockwise ? 1 : -1)) % 4;\n  return nextDir;\n}\nfunction oppositeDirection(direction) {\n  return (direction + 2) % 4;\n}\nvar APPROXIMATE = 6;\nvar JFLOW_MODE = {\n  DEFAULT: \'DEFAULT\',\n  LINKING: \'LINKING\'\n};\nvar LINE_DIR = {\n  FROM: \'from\',\n  TO: \'to\'\n};\n;// CONCATENATED MODULE: ./src/core/utils/functions.js\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n\n\n/**\n * 根据点计算最小外接矩形\n * @param {number[][]} points - 点集合\n * @return {Object} demension 宽高，坐标\n */\nfunction bounding_box(points) {\n  if (points.length === 0) {\n    return {\n      width: 1,\n      height: 1,\n      x: 0,\n      y: 0\n    };\n  }\n  var min_x = Infinity;\n  var min_y = Infinity;\n  var max_x = -Infinity;\n  var max_y = -Infinity;\n  for (var idx in points) {\n    var item = points[idx];\n    if (item[0] < min_x) {\n      min_x = item[0];\n    }\n    if (item[0] > max_x) {\n      max_x = item[0];\n    }\n    if (item[1] < min_y) {\n      min_y = item[1];\n    }\n    if (item[1] > max_y) {\n      max_y = item[1];\n    }\n  }\n  return {\n    // points: [(min_x,min_y),(max_x,min_y),(max_x,max_y),(min_x,max_y)],\n    width: Math.max(max_x - min_x, 10),\n    height: Math.max(max_y - min_y, 10),\n    x: min_x,\n    y: min_y\n  };\n}\nfunction sqr(x) {\n  return x * x;\n}\nfunction dist2(v, w) {\n  return sqr(v[0] - w[0]) + sqr(v[1] - w[1]);\n}\n\n// p - point\n// v - start point of segment\n// w - end point of segment\nfunction distToSegmentSquared(p, v, w) {\n  var l2 = dist2(v, w);\n  if (l2 === 0) return dist2(p, v);\n  var t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\n  t = Math.max(0, Math.min(1, t));\n  return dist2(p, [v[0] + t * (w[0] - v[0]), v[1] + t * (w[1] - v[1])]);\n}\nfunction minIntersectionBetweenNodes(dmsfrom, dmsto) {\n  var meta = {\n    fromDir: null,\n    fromP: null,\n    toDir: null,\n    toP: null,\n    distMin: Infinity\n  };\n  Object.keys(dmsfrom).forEach(function (df) {\n    if (+df === DIRECTION.SELF) {\n      return;\n    }\n    var pf = dmsfrom[df];\n    Object.keys(dmsto).forEach(function (dt) {\n      if (+dt === DIRECTION.SELF) {\n        return;\n      }\n      var pt = dmsto[dt];\n      var dist = dist2(pf, pt);\n      if (dist < meta.distMin) {\n        Object.assign(meta, {\n          distMin: dist,\n          fromDir: +df,\n          fromP: pf,\n          toDir: +dt,\n          toP: pt\n        });\n      }\n    });\n  });\n  return meta;\n}\n\n// export function bezierPoints(p1, p2, start_dir = DIRECTION.TOP, end_dir = DIRECTION.TOP, anticlock = false) {\n//     const isSameDirection = start_dir === end_dir;\n//     const isVerticalStart = [DIRECTION.TOP, DIRECTION.BOTTOM].includes(start_dir);   \n//     const isVerticalEnd = [DIRECTION.TOP, DIRECTION.BOTTOM].includes(end_dir);\n//     const arrowspan = [DIRECTION.TOP, DIRECTION.LEFT].includes(end_dir) ? -5 : 5;\n//     const endX = isVerticalEnd ? p2[0] : p2[0] + arrowspan;\n//     const endY = isVerticalEnd ? p2[1] + arrowspan : p2[1];\n//     if(isSameDirection) {\n//         let span = Math.abs(isVerticalStart ? (endY - p1[1]) : (endX - p1[0]))\n//         span = Math.min(span, 50);\n//         const symb = [DIRECTION.RIGHT, DIRECTION.BOTTOM].includes(end_dir)\n//         span = symb ? span : - span;\n//         const cp1 = isVerticalStart ? [p1[0], p1[1] + span] : [p1[0] + span, p1[1]];\n//         const cp2 = isVerticalEnd ? [endX, endY + span] : [endX + span, endY];\n//         return [ \n//             ...cp1,\n//             ...cp2,\n//             endX, endY ];\n//     }\n//     let spanStart = (anticlock ? -5 : 1) * (isVerticalStart ? (endY - p1[1]) / 2 : (endX - p1[0]) / 2)\n//     let spanEnd = (anticlock ? -4 : 1) * (isVerticalEnd ? (p1[1] - endY) / 2 : (p1[0] - endX) / 2)\n//     let u1 = spanStart / Math.abs(spanStart);\n//     spanStart = u1 * Math.min(Math.abs(spanStart), 50);\n//     let u2 = spanEnd / Math.abs(spanEnd);\n//     spanEnd = u2 * Math.min(Math.abs(spanEnd), 50);\n//     const cp1 = isVerticalStart ? [p1[0], p1[1] + spanStart] : [p1[0] + spanStart, p1[1]];\n//     const cp2 = isVerticalEnd ? [endX, endY + spanEnd] : [endX + spanEnd, endY];\n//     return [ \n//         ...cp1,\n//         ...cp2,\n//         endX, endY ];\n// }\nfunction _resolveControlPoint(p, dir, spanx, spany) {\n  if (dir === DIRECTION.TOP) {\n    return [p[0], p[1] - spany];\n  }\n  if (dir === DIRECTION.BOTTOM) {\n    return [p[0], p[1] + spany];\n  }\n  if (dir === DIRECTION.LEFT) {\n    return [p[0] - spanx, p[1]];\n  }\n  if (dir === DIRECTION.RIGHT) {\n    return [p[0] + spanx, p[1]];\n  }\n}\nfunction bezierPoints(p1, p2) {\n  var start_dir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DIRECTION.TOP;\n  var end_dir = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DIRECTION.TOP;\n  var minSpanX = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  var minSpanY = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  var spanx = Math.max(Math.abs((p1[0] - p2[0]) / 2), minSpanX);\n  var spany = Math.max(Math.abs((p1[1] - p2[1]) / 2), minSpanY);\n  var cp1 = _resolveControlPoint(p1, start_dir, spanx, spany);\n  var cp2 = _resolveControlPoint(p2, end_dir, spanx, spany);\n  var arrowspan = [DIRECTION.TOP, DIRECTION.LEFT].includes(end_dir) ? -5 : 5;\n  var isVerticalEnd = [DIRECTION.TOP, DIRECTION.BOTTOM].includes(end_dir);\n  var endX = isVerticalEnd ? p2[0] : p2[0] + arrowspan;\n  var endY = isVerticalEnd ? p2[1] + arrowspan : p2[1];\n  return [].concat(_toConsumableArray(cp1), _toConsumableArray(cp2), [endX, endY]);\n}\nfunction bezierPoint(t, P) {\n  var q = 1 - t;\n  var x = q * q * q * P[0] + 3 * q * q * t * P[2] + 3 * q * t * t * P[4] + t * t * t * P[6];\n  var y = q * q * q * P[1] + 3 * q * q * t * P[3] + 3 * q * t * t * P[5] + t * t * t * P[7];\n  var u = q * q * (P[2] - P[0]) + 2 * t * q * (P[4] - P[2]) + t * t * (P[6] - P[4]);\n  var v = q * q * (P[3] - P[1]) + 2 * t * q * (P[5] - P[3]) + t * t * (P[7] - P[5]);\n  var angle = Math.atan2(v, u);\n  // console.log(angle * 180)\n  // if(angle < 0) {\n  //     angle = Math.PI + angle;\n  // }\n  return [x, y, angle];\n}\n\n// export function bezierPoints(p1, p2, start_vec, end_vec) {\n\n// }\n\nfunction distToBezierSegmentSquared(p, points) {\n  var b = _construct(Bezier, _toConsumableArray(points));\n  var point = b.project({\n    x: p[0],\n    y: p[1]\n  });\n  var d = dist2(p, [point.x, point.y]);\n  return d;\n}\nfunction getBezierAngle(t, sx, sy, cp1x, cp1y, cp2x, cp2y, ex, ey) {\n  var dx = Math.pow(1 - t, 2) * (cp1x - sx) + 2 * t * (1 - t) * (cp2x - cp1x) + t * t * (ex - cp2x);\n  var dy = Math.pow(1 - t, 2) * (cp1y - sy) + 2 * t * (1 - t) * (cp2y - cp1y) + t * t * (ey - cp2y);\n  return -Math.atan2(dx, dy) + 0.5 * Math.PI;\n}\nfunction getInstanceHeight(instance) {\n  var rect = instance.getBoundingRect();\n  // let min_y = Infinity;\n  // let max_y = -Infinity;\n  // let min_x = Infinity;\n  // let max_x = -Infinity;\n  // rect.forEach(point => {\n  //     max_y = Math.max(max_y, point[1]);\n  //     min_y = Math.min(min_y, point[1]);\n  //     max_x = Math.max(max_x, point[0]);\n  //     min_x = Math.min(min_x, point[0]);\n  // });\n  return {\n    height: rect[3] - rect[1],\n    width: rect[2] - rect[0]\n  };\n}\nfunction polylinePoints(points, p1, p2) {\n  var start_dir = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DIRECTION.TOP;\n  var end_dir = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DIRECTION.TOP;\n  var minSpanX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 10;\n  var minSpanY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 10;\n  var isSelf = arguments.length > 7 ? arguments[7] : undefined;\n  var dirSpan = Math.abs(start_dir - end_dir);\n  // const spanx = Math.max(Math.abs((p1[0] - p2[0])/2), minSpanX);\n  // const spany = Math.max(Math.abs((p1[1] - p2[1])/2), minSpanY);\n  var isVerticalStart = start_dir === DIRECTION.TOP || start_dir === DIRECTION.BOTTOM;\n  points.length = 0;\n  switch (dirSpan) {\n    case 0:\n      // 都按向右好了\n      if (start_dir === DIRECTION.TOP) {\n        var y = Math.min(p1[1], p2[1]);\n        var yp = y - minSpanY;\n        points.push([p1[0], yp]);\n        points.push([p2[0], yp]);\n      }\n      if (start_dir === DIRECTION.BOTTOM) {\n        var _y = Math.max(p1[1], p2[1]);\n        var _yp = _y + minSpanY;\n        points.push([p1[0], _yp]);\n        points.push([p2[0], _yp]);\n      }\n      if (start_dir === DIRECTION.LEFT) {\n        var x = Math.min(p1[0], p2[0]);\n        var xp = x - minSpanX;\n        points.push([xp, p1[1]]);\n        points.push([xp, p2[1]]);\n      }\n      if (start_dir === DIRECTION.RIGHT) {\n        var _x = Math.max(p1[0], p2[0]);\n        var _xp = _x + minSpanX;\n        points.push([_xp, p1[1]]);\n        points.push([_xp, p2[1]]);\n      }\n      break;\n    case 1:\n    case 3:\n      if (isSelf) {\n        if (!isVerticalStart) {\n          points.push([p1[0] + minSpanX, p1[1]]);\n          points.push([p1[0] + minSpanX, p2[1] + minSpanY]);\n          points.push([p2[0], p2[1] + minSpanY]);\n        } else {\n          points.push([p1[0], p1[1] + minSpanY]);\n          points.push([p2[0] + minSpanX, p1[1] + minSpanY]);\n          points.push([p2[0] + minSpanX, p2[1]]);\n        }\n      } else {\n        var point = isVerticalStart ? [p1[0], p2[1]] : [p2[0], p1[1]];\n        points.push(point);\n      }\n      break;\n    case 2:\n      var pmiddle = [(p1[0] - p2[0]) / 2 + p2[0], (p1[1] - p2[1]) / 2 + p2[1]];\n      if (isVerticalStart) {\n        points.push([p1[0], pmiddle[1]]);\n        points.push([p2[0], pmiddle[1]]);\n      } else {\n        points.push([pmiddle[0], p1[1]]);\n        points.push([pmiddle[0], p2[1]]);\n      }\n      break;\n    default:\n      break;\n  }\n  points.unshift(p1);\n  points.push(p2);\n}\nfunction minusVec(p1, p2) {\n  return [p1[0] - p2[0], p1[1] - p2[1]];\n}\nfunction absVec(vec) {\n  return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);\n}\nfunction scaleVec(vec, scale) {\n  return [vec[0] * scale, vec[1] * scale];\n}\nfunction makeRadiusFromVector(pbefore, p, pnext, radius) {\n  var vec1 = minusVec(p, pbefore);\n  var vec2 = minusVec(p, pnext);\n  var absVec1 = absVec(vec1);\n  var absVec2 = absVec(vec2);\n  if (!absVec1 || !absVec2) {\n    return {\n      p1: null,\n      p2: null\n    };\n  }\n  var r1 = scaleVec(vec1, radius / absVec1);\n  var r2 = scaleVec(vec2, radius / absVec2);\n  return {\n    p1: minusVec(p, r1),\n    p2: minusVec(p, r2)\n  };\n}\n// 矩形重叠计算\nfunction doOverlap(rec1, rec2) {\n  if (rec1[0] == rec1[2] || rec1[1] == rec1[3] || rec2[0] == rec2[2] || rec2[1] == rec2[3]) {\n    // the line cannot have positive overlap\n    return false;\n  }\n  return !(rec1[2] <= rec2[0] ||\n  // left\n  rec1[3] <= rec2[1] ||\n  // bottom\n  rec1[0] >= rec2[2] ||\n  // right\n  rec1[1] >= rec2[3]); // top\n}\n\nfunction isPolyLineIntersectionRectange(polyline, rect) {\n  var p = polyline[0];\n  var l = polyline.length;\n  var i = 1;\n  var _rect = _slicedToArray(rect, 4),\n    l0 = _rect[0],\n    l1 = _rect[1],\n    r0 = _rect[2],\n    r1 = _rect[3];\n  while (i < l) {\n    var cp = polyline[i];\n    if (p[0] === cp[0]) {\n      // vertical\n      if (p[0] < r0 && p[0] > l0 && !(p[1] > r1 && cp[1] > r1 || p[1] < l1 && cp[1] < l1)) {\n        return true;\n      }\n    } else {\n      // horizontal\n      if (p[1] < r1 && p[1] > l1 && !(p[0] > r0 && cp[0] > r0 || p[0] < l0 && cp[0] < l0)) {\n        return true;\n      }\n    }\n    p = cp;\n    i++;\n  }\n  return false;\n}\nfunction debounce(func) {\n  var _this = this;\n  var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;\n  var timer;\n  return function () {\n    clearTimeout(timer);\n    timer = setTimeout(function () {\n      func.call(_this);\n    }, timeout);\n  };\n}\nfunction compareBoundingbox(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\nfunction copyBoundingbox(a, b) {\n  a[0] = b[0];\n  a[1] = b[1];\n  a[2] = b[2];\n  a[3] = b[3];\n}\n;// CONCATENATED MODULE: ./src/core/instance/instance.js\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) instance_setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = instance_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return instance_construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return instance_setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction instance_construct(Parent, args, Class) { if (instance_isNativeReflectConstruct()) { instance_construct = Reflect.construct.bind(); } else { instance_construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) instance_setPrototypeOf(instance, Class.prototype); return instance; }; } return instance_construct.apply(null, arguments); }\nfunction instance_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }\nfunction instance_setPrototypeOf(o, p) { instance_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return instance_setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n// import { setUniqueId, getUniqueId } from \'../utils/functions\';\n// import { nextDirection } from \'../utils/constance\';\n// const margin = 5;\nvar ishitKey = Symbol(\'ishit\');\nvar isInViewBox = Symbol(\'isInViewBox\');\n/**\n * @typedef Instance~Configs\n * @type {object}\n * @property {number} borderWidth      - 边的宽度 默认是 2\n * @property {string} borderColor      - 边框颜色 默认 black\n * @property {string} color            - 填充颜色 默认 white\n * @property {string} shadowColor      - 阴影颜色\n * @property {string} shadowBlur       - 阴影扩散范围\n * @property {string} shadowOffsetX    - 阴影偏移 X\n * @property {string} shadowOffsetX    - 阴影偏移 Y\n */\n\n/** \n * 图中的最小单元\n * @constructor Instance\n * @extends EventTarget\n * @param {Instance~Configs} configs - 最小单元的一些通用属性配置\n */\nvar Instance = /*#__PURE__*/function (_EventTarget) {\n  _inherits(Instance, _EventTarget);\n  var _super = _createSuper(Instance);\n  function Instance() {\n    var _this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, Instance);\n    _this = _super.call(this);\n    Object.assign(_assertThisInitialized(_this), configs);\n    // this.anchor = configs.anchor || [0, 0];\n    // this.belongs = undefined;\n    /** @member {boolean}      - 元素可见 默认 true */\n    _this.visible = true;\n    // this._jflow = undefined;\n    _this._belongs = undefined;\n    _this[ishitKey] = false;\n\n    /** @member {number}      - 边的宽度 默认是 0 */\n    _this.borderWidth = configs.borderWidth || 0;\n    /** @member {string}     - 边框颜色 默认 transparent */\n    _this.borderColor = configs.borderColor || \'transparent\';\n    /** @member {string}     - 填充颜色 默认 transparent */\n    _this.backgroundColor = configs.backgroundColor || \'transparent\';\n    /** @member {string}     - 阴影颜色 空就不显示阴影 */\n    _this.shadowColor = configs.shadowColor;\n    /** @member {string}     - 阴影扩散范围 默认 5 */\n    _this.shadowBlur = configs.shadowBlur || 5;\n    /** @member {string}     - 阴影偏移 X */\n    _this.shadowOffsetX = configs.shadowOffsetX || 0;\n    /** @member {string}     - 阴影偏移 Y */\n    _this.shadowOffsetY = configs.shadowOffsetY || 0;\n    /** @member {number}     - 透明度 */\n    _this.opacity = configs.opacity || 1;\n    _this._boundingrect = [0, 0, 0, 0];\n    return _this;\n  }\n  /**\n   * @member {boolean} - 当前单元选中状态\n   */\n  _createClass(Instance, [{\n    key: "_isTargeting",\n    get: function get() {\n      return this === (this._jflow._target.instance || this._jflow._target.link);\n    }\n    /**\n     * @member {boolean} - 当前单元移动状态\n     */\n  }, {\n    key: "_isMoving",\n    get: function get() {\n      return this === this._jflow._getMovingTarget() && this._jflow._target.status.movingState; // 移动了之后才能被当做移动状态\n    }\n    /**\n     * @member {boolean}  - 当前单元碰撞检测状态\n     */\n  }, {\n    key: "_isHit",\n    get: function get() {\n      return this[ishitKey];\n    }\n    /**\n     * @member {JFlow}  - canvas上 jflow 实体\n     */,\n    set: function set(ishit) {\n      if (this[ishitKey] !== ishit) {\n        /**\n         * 鼠标移入事件\n         *\n         * @event Instance#mouseenter\n         * @type {object}\n         * @property {Instance} instance      - 移入的对象 \n         */\n        /**\n         * 鼠标移出事件\n         *\n         * @event Instance#mouseleave\n         * @type {object}\n         * @property {Instance} instance      - 移入的对象 \n         */\n        this.dispatchEvent(new CustomEvent(ishit ? \'mouseenter\' : \'mouseleave\', {\n          detail: {\n            instance: this,\n            jflow: this._jflow\n          }\n        }));\n      }\n      this[ishitKey] = ishit; // validation could be checked here such as only allowing non numerical values\n    }\n  }, {\n    key: "_jflow",\n    get: function get() {\n      if (this._jflowRoot) {\n        return this._jflowRoot;\n      }\n      if (!this._belongs) {\n        return undefined;\n      }\n      return this._belongs.uniqueName === \'jflow\' ? this._belongs : this._belongs._jflow;\n    }\n  }, {\n    key: "isInViewBox",\n    get: function get() {\n      return this[isInViewBox];\n    }\n  }, {\n    key: "_isInViewBox",\n    set: function set(val) {\n      var oldval = this[isInViewBox];\n      if (val !== oldval) {\n        if (val) {\n          this.onEnterViewbox();\n        } else {\n          this.onLeaveViewbox();\n        }\n      }\n      this[isInViewBox] = val;\n    }\n\n    /**\n     * 当节点离开可视区域的回调\n     */\n  }, {\n    key: "onEnterViewbox",\n    value: function onEnterViewbox() {\n      return;\n    }\n\n    /**\n     * 当节点离开可视区域的回调\n     */\n  }, {\n    key: "onLeaveViewbox",\n    value: function onLeaveViewbox() {\n      return;\n    }\n\n    /**\n     * 改变当前配置\n     * @param {Configs} configs - The string containing two comma-separated numbers.\n     */\n  }, {\n    key: "setConfig",\n    value: function setConfig(configs) {\n      var _this2 = this;\n      Object.keys(configs).forEach(function (k) {\n        if (configs[k] !== undefined && configs[k] !== null) {\n          _this2[k] = configs[k];\n        }\n      });\n    }\n    /**\n     * 绘制单元\n     * @param {Context2d} ctx \n     */\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      throw \'require render implement\';\n    }\n    /**\n     * 判断当前单元是否被命中\n     * @param {number[]} point \n     * @return {Boolean}\n     */\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      throw \'require isHit implement\';\n    }\n    /**\n     * 计算当前的最大外接矩形的\n     * @return {number[]} [leftx, lefty, rightx, righty]\n     */\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      throw \'require getBoundingRect implement\';\n    }\n  }, {\n    key: "calculateIntersection",\n    value: function calculateIntersection() {\n      throw \'require calculateIntersection implement\';\n    }\n    /**\n     * 计算当前连线接入点的位置\n     * @return {Object} intersection 交叉点\n     * @return {number} intersection[DIRECTION.TOP] 上\n     * @return {number} intersection[DIRECTION.BOTTOM] 下\n     * @return {number} intersection[DIRECTION.LEFT] 上\n     * @return {number} intersection[DIRECTION.RIGHT] 右\n     */\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      throw \'require getIntersectionsInFourDimension implement\';\n    }\n\n    /**\n     * 获取当前所在层级的坐标\n     * @return {Number[]} 坐标\n     */\n  }, {\n    key: "getCenter",\n    value: function getCenter() {\n      return this.anchor;\n    }\n    /**\n     * 获取宽高\n     * @return {Object} demension 宽高\n     * @return {number} demension.width 宽\n     * @return {number} demension.height 高\n     */\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      var rect = instance.getBoundingRect();\n      var min_y = Infinity;\n      var max_y = -Infinity;\n      var min_x = Infinity;\n      var max_x = -Infinity;\n      rect.forEach(function (point) {\n        max_y = Math.max(max_y, point[1]);\n        min_y = Math.min(min_y, point[1]);\n        max_x = Math.max(max_x, point[0]);\n        min_x = Math.min(min_x, point[0]);\n      });\n      return {\n        height: max_y - min_y,\n        width: max_x - min_x\n      };\n    }\n    /**\n     * 冒泡事件\n     * @param {JFlowEvent} customEvent 自定义事件\n     */\n  }, {\n    key: "bubbleEvent",\n    value: function bubbleEvent(customEvent) {\n      customEvent.detail.currentTarget = this;\n      this.dispatchEvent(customEvent);\n      if (customEvent.detail.bubbles) {\n        if (this._belongs.bubbleEvent) {\n          this._belongs.bubbleEvent(customEvent);\n        } else {\n          this._belongs.dispatchEvent(customEvent);\n        }\n      }\n    }\n    /**\n     * 反算回页面的像素坐标\n     * @param {Number[]} point\n     * @return {Number[]} 世界坐标\n     */\n  }, {\n    key: "calculateToRealWorld",\n    value: function calculateToRealWorld(point) {\n      if (this._belongs && this._belongs.calculateToRealWorld) {\n        return this._belongs.calculateToRealWorld(point);\n      } else {\n        return point;\n      }\n    }\n  }, {\n    key: "calculateToRealWorldWithPointer",\n    value: function calculateToRealWorldWithPointer(outpoint, inpoint) {\n      if (this._belongs && this._belongs.calculateToRealWorldWithPointer) {\n        this._belongs.calculateToRealWorldWithPointer(outpoint, inpoint);\n      }\n    }\n  }, {\n    key: "calculateToRealWorldWithScalar",\n    value: function calculateToRealWorldWithScalar(length) {\n      return this._jflow.scale * length;\n    }\n\n    /**\n     * 从当前布局中删除虚拟布局节点\n     */\n    // removeFromLayoutSource() {\n    //     if(this._layoutNode) {\n    //         this._layoutNode.remove();\n    //     }\n    // }\n  }, {\n    key: "recalculateUp",\n    value: function recalculateUp() {\n      if (this._belongs) {\n        this._belongs.recalculateUp();\n      }\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      // this._belongs = undefined;\n      // this.removeEventListener();\n    }\n  }]);\n  return Instance;\n}( /*#__PURE__*/_wrapNativeSuper(EventTarget));\n/* harmony default export */ const instance_instance = (Instance);\n;// CONCATENATED MODULE: ./src/core/dirty-work/dirty-work.js\nfunction dirty_work_slicedToArray(arr, i) { return dirty_work_arrayWithHoles(arr) || dirty_work_iterableToArrayLimit(arr, i) || dirty_work_unsupportedIterableToArray(arr, i) || dirty_work_nonIterableRest(); }\nfunction dirty_work_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction dirty_work_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return dirty_work_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dirty_work_arrayLikeToArray(o, minLen); }\nfunction dirty_work_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction dirty_work_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction dirty_work_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar queue = [];\nvar clearQueue = [];\nvar queueSet = new WeakSet();\nvar checkWork = function checkWork(target) {\n  return queueSet.has(target);\n};\nvar getStackPath = function getStackPath(node) {\n  var t = node;\n  var exp = 1;\n  var p = \'\';\n  while (t && t._belongs) {\n    var idx = t._belongs._stack.findIndex(function (n) {\n      return n === t;\n    });\n    p = idx + (p && \'.\' + p);\n    t = t._belongs;\n  }\n  return p;\n};\nvar sortByPath = function sortByPath() {\n  var map = new WeakMap();\n  queue.sort(function (a, b) {\n    var apath = map.get(a);\n    if (apath === undefined) {\n      apath = getStackPath(a);\n      map.set(a, apath);\n    }\n    var bpath = map.get(b);\n    if (bpath === undefined) {\n      bpath = getStackPath(b);\n      map.set(b, bpath);\n    }\n    var _a = apath.split(\'.\');\n    var _b = bpath.split(\'.\');\n    if (_a.length < _b.length) {\n      return 1;\n    }\n    if (_a.length > _b.length) {\n      return -1;\n    }\n    for (var i = 0; i < _a.length; i++) {\n      var _p = +_a[i];\n      var _q = +_b[i];\n      if (_p < _q) {\n        return 1;\n      }\n      if (_p > _q) {\n        return -1;\n      }\n    }\n    return 0;\n  });\n};\nvar addClearSourceWork = function addClearSourceWork(jflow, source) {\n  clearQueue.push([jflow, source]);\n};\n\n// work is sync function!!\nvar dirty_work_addReflowWork = function addReflowWork(target, parent) {\n  if (target.doRecalculate) {\n    if (!queueSet.has(target)) {\n      queue.push(target);\n      queueSet.add(target);\n    }\n  }\n  if (parent && parent.doRecalculate && !queueSet.has(parent)) {\n    queue.push(parent);\n    queueSet.add(parent);\n  }\n\n  // if(target.doRecalculate) {\n  //     if(!checkWork(target)) {\n  //         queue.push(target);\n  //         queueSet.add(target);\n  //     }\n  // }  \n  // if(parent) {\n  //     if(checkWork(parent)) {\n  //         const idx = queue.findIndex(p => p === parent);\n  //         queue.splice(idx, 1);\n  //         queue.push(parent);\n  //     } else {\n  //         queue.push(parent);\n  //         queueSet.add(parent);\n  //     }\n\n  // }\n  flush();\n};\nvar inFlush = false;\nvar flush = function flush() {\n  if (inFlush) {\n    return;\n  }\n  inFlush = true;\n  requestAnimationFrame(function () {\n    var roots = new Set();\n    sortByPath();\n    while (queue.length) {\n      var target = queue.shift();\n      if (target.doRecalculate && target._jflow) {\n        target.doRecalculate();\n        roots.add(target._jflow);\n      }\n      // console.log(target.width, target.height)\n    }\n\n    while (clearQueue.length) {\n      var _clearQueue$shift = clearQueue.shift(),\n        _clearQueue$shift2 = dirty_work_slicedToArray(_clearQueue$shift, 2),\n        jflow = _clearQueue$shift2[0],\n        source = _clearQueue$shift2[1];\n      if (!jflow.getRenderNodeBySource(source)) {\n        jflow.clearSource(source);\n      }\n    }\n    // console.log(\'-----dirty---flush-----\')\n    queueSet = new WeakSet();\n    inFlush = false;\n    Array.from(roots).forEach(function (jflow) {\n      jflow._render();\n    });\n  });\n};\n;// CONCATENATED MODULE: ./src/core/instance/node.js\nfunction node_typeof(obj) { "@babel/helpers - typeof"; return node_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, node_typeof(obj); }\nfunction node_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction node_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, node_toPropertyKey(descriptor.key), descriptor); } }\nfunction node_createClass(Constructor, protoProps, staticProps) { if (protoProps) node_defineProperties(Constructor.prototype, protoProps); if (staticProps) node_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction node_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) node_setPrototypeOf(subClass, superClass); }\nfunction node_setPrototypeOf(o, p) { node_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return node_setPrototypeOf(o, p); }\nfunction node_createSuper(Derived) { var hasNativeReflectConstruct = node_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = node_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = node_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return node_possibleConstructorReturn(this, result); }; }\nfunction node_possibleConstructorReturn(self, call) { if (call && (node_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return node_assertThisInitialized(self); }\nfunction node_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction node_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction node_getPrototypeOf(o) { node_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return node_getPrototypeOf(o); }\nfunction _defineProperty(obj, key, value) { key = node_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction node_toPropertyKey(arg) { var key = node_toPrimitive(arg, "string"); return node_typeof(key) === "symbol" ? key : String(key); }\nfunction node_toPrimitive(input, hint) { if (node_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (node_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n\n\n/**\n * 绝对定位 配置， 绝对定位不受布局影响，相对于当前组来定位\n * @typedef {object} Node~AbsolutePosition \n * @property {number} top       - 上距离\n * @property {number} bottom    - 下距离\n * @property {number} right     - 右距离\n * @property {number} left      - 左距离\n */\n/**\n * Node 配置\n * @typedef {Instance~Configs} Node~Configs \n * @property {number[]} anchor - 坐标\n * @property {Node~AbsolutePosition} absolutePosition - 绝对定位位置\n */\n/**\n * 节点基类\n * @constructor Node\n * @extends Instance\n * @param {Node~Configs} configs - 节点配置\n */\nvar Node = /*#__PURE__*/function (_Instance) {\n  node_inherits(Node, _Instance);\n  var _super = node_createSuper(Node);\n  function Node() {\n    var _this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    node_classCallCheck(this, Node);\n    _this = _super.call(this, configs);\n    _defineProperty(node_assertThisInitialized(_this), "INSTANCE_TYPE", \'NODE\');\n    _this._rawConfigs = configs;\n    // for layout\n    /** @member {number[]} */\n    _this.anchor = configs.anchor || [0, 0];\n    /** @member {Node~AbsolutePosition} */\n    _this.absolutePosition = configs.absolutePosition;\n    return _this;\n  }\n  node_createClass(Node, [{\n    key: "nextSibling",\n    get: function get() {\n      var _this2 = this;\n      if (!this._belongs) {\n        return null;\n      }\n      var stack = this._belongs._stack;\n      var idx = stack.findIndex(function (s) {\n        return s === _this2;\n      });\n      if (idx !== -1) {\n        return stack[idx + 1];\n      }\n      return null;\n    }\n  }, {\n    key: "setConfig",\n    value: function setConfig(configs) {\n      var _this3 = this;\n      Object.keys(configs).forEach(function (k) {\n        if (configs[k] !== undefined && configs[k] !== null) {\n          _this3[k] = configs[k];\n          _this3._rawConfigs[k] = configs[k];\n        }\n      });\n    }\n  }, {\n    key: "setAnchorX",\n    value: function setAnchorX(x) {\n      this.anchor[0] = x;\n    }\n  }, {\n    key: "setAnchorY",\n    value: function setAnchorY(y) {\n      this.anchor[1] = y;\n    }\n  }, {\n    key: "setAnchor",\n    value: function setAnchor(x, y) {\n      this.anchor[0] = x;\n      this.anchor[1] = y;\n    }\n  }, {\n    key: "beforeRender",\n    value: function beforeRender() {\n      return doOverlap(this._belongs._getViewBox(), this.getBoundingRect());\n    }\n  }, {\n    key: "addReflowWork",\n    value: function addReflowWork() {\n      dirty_work_addReflowWork(this, this._belongs);\n    }\n\n    /**\n     * 克隆当前节点.\n     * @return {Node} 当前节点的副本\n     */\n  }, {\n    key: "clone",\n    value: function clone() {\n      var C = this.constructor;\n      var t = new C(this._rawConfigs);\n      t.visible = this.visible;\n      return t;\n    }\n  }]);\n  return Node;\n}(instance_instance);\n/* harmony default export */ const node = (Node);\n;// CONCATENATED MODULE: ./src/core/instance/ghostNode.js\nfunction ghostNode_typeof(obj) { "@babel/helpers - typeof"; return ghostNode_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, ghostNode_typeof(obj); }\nfunction ghostNode_defineProperty(obj, key, value) { key = ghostNode_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction ghostNode_slicedToArray(arr, i) { return ghostNode_arrayWithHoles(arr) || ghostNode_iterableToArrayLimit(arr, i) || ghostNode_unsupportedIterableToArray(arr, i) || ghostNode_nonIterableRest(); }\nfunction ghostNode_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction ghostNode_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return ghostNode_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ghostNode_arrayLikeToArray(o, minLen); }\nfunction ghostNode_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ghostNode_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction ghostNode_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction ghostNode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction ghostNode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, ghostNode_toPropertyKey(descriptor.key), descriptor); } }\nfunction ghostNode_createClass(Constructor, protoProps, staticProps) { if (protoProps) ghostNode_defineProperties(Constructor.prototype, protoProps); if (staticProps) ghostNode_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction ghostNode_toPropertyKey(arg) { var key = ghostNode_toPrimitive(arg, "string"); return ghostNode_typeof(key) === "symbol" ? key : String(key); }\nfunction ghostNode_toPrimitive(input, hint) { if (ghostNode_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (ghostNode_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction ghostNode_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) ghostNode_setPrototypeOf(subClass, superClass); }\nfunction ghostNode_setPrototypeOf(o, p) { ghostNode_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return ghostNode_setPrototypeOf(o, p); }\nfunction ghostNode_createSuper(Derived) { var hasNativeReflectConstruct = ghostNode_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = ghostNode_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = ghostNode_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return ghostNode_possibleConstructorReturn(this, result); }; }\nfunction ghostNode_possibleConstructorReturn(self, call) { if (call && (ghostNode_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return ghostNode_assertThisInitialized(self); }\nfunction ghostNode_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction ghostNode_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction ghostNode_getPrototypeOf(o) { ghostNode_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return ghostNode_getPrototypeOf(o); }\n\n\nvar GhostNode = /*#__PURE__*/function (_Node) {\n  ghostNode_inherits(GhostNode, _Node);\n  var _super = ghostNode_createSuper(GhostNode);\n  function GhostNode(configs) {\n    ghostNode_classCallCheck(this, GhostNode);\n    return _super.call(this, configs);\n  }\n  ghostNode_createClass(GhostNode, [{\n    key: "render",\n    value: function render(ctx) {}\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      return false;\n    }\n  }, {\n    key: "calculateIntersection",\n    value: function calculateIntersection(point) {\n      return this.anchor;\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var _this$anchor = ghostNode_slicedToArray(this.anchor, 2),\n        x2 = _this$anchor[0],\n        y2 = _this$anchor[1];\n      return [x2, y2, x2, y2];\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        width: 0,\n        height: 0\n      };\n    }\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      var _ref;\n      var _this$anchor2 = ghostNode_slicedToArray(this.anchor, 2),\n        x2 = _this$anchor2[0],\n        y2 = _this$anchor2[1];\n      return _ref = {}, ghostNode_defineProperty(_ref, DIRECTION.RIGHT, [x2 + 1, y2]), ghostNode_defineProperty(_ref, DIRECTION.LEFT, [x2 - 1, y2]), ghostNode_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + 1]), ghostNode_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - 1]), _ref;\n    }\n  }]);\n  return GhostNode;\n}(node);\n/* harmony default export */ const ghostNode = (GhostNode);\n;// CONCATENATED MODULE: ./src/core/instance/nodeWeakMap.js\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { nodeWeakMap_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction nodeWeakMap_defineProperty(obj, key, value) { key = nodeWeakMap_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction nodeWeakMap_typeof(obj) { "@babel/helpers - typeof"; return nodeWeakMap_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, nodeWeakMap_typeof(obj); }\nfunction nodeWeakMap_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction nodeWeakMap_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, nodeWeakMap_toPropertyKey(descriptor.key), descriptor); } }\nfunction nodeWeakMap_createClass(Constructor, protoProps, staticProps) { if (protoProps) nodeWeakMap_defineProperties(Constructor.prototype, protoProps); if (staticProps) nodeWeakMap_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction nodeWeakMap_toPropertyKey(arg) { var key = nodeWeakMap_toPrimitive(arg, "string"); return nodeWeakMap_typeof(key) === "symbol" ? key : String(key); }\nfunction nodeWeakMap_toPrimitive(input, hint) { if (nodeWeakMap_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (nodeWeakMap_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction getMapObject() {\n  return {\n    layoutNode: undefined,\n    jflowNode: undefined,\n    jflowlinks: [],\n    jflowFromLinks: new Set(),\n    jflowToLinks: new Set()\n  };\n}\nvar NodeWeakMap = /*#__PURE__*/function () {\n  function NodeWeakMap() {\n    nodeWeakMap_classCallCheck(this, NodeWeakMap);\n    this._map = new Map();\n  }\n  nodeWeakMap_createClass(NodeWeakMap, [{\n    key: "get",\n    value: function get(source) {\n      return this._map.get(source);\n    }\n  }, {\n    key: "set",\n    value: function set(source) {\n      var obj = getMapObject();\n      this._map.set(source, obj);\n      return obj;\n    }\n  }, {\n    key: "has",\n    value: function has(source) {\n      return this._map.has(source);\n    }\n  }, {\n    key: "delete",\n    value: function _delete(source) {\n      this._map["delete"](source);\n    }\n  }, {\n    key: "clear",\n    value: function clear() {\n      this._map.clear();\n    }\n  }]);\n  return NodeWeakMap;\n}();\nvar NodeWeakMapMixin = {\n  initNodeWeakMap: function initNodeWeakMap() {\n    this.source_Layout_Render_NodeMap = new NodeWeakMap();\n  },\n  getRenderNodeBySource: function getRenderNodeBySource(source) {\n    var mapping = this.source_Layout_Render_NodeMap.get(source);\n    if (mapping) {\n      return mapping.jflowNode;\n    }\n    return undefined;\n  },\n  removeRenderNodeBySource: function removeRenderNodeBySource(source, instance) {\n    var map = this.source_Layout_Render_NodeMap;\n    var obj = map.get(source);\n    if (obj && obj.jflowNode === instance) {\n      obj.jflowNode = undefined;\n    }\n    if (obj && obj.jflowFromLinks.size === 0 && obj.jflowToLinks.size === 0) {\n      this.source_Layout_Render_NodeMap["delete"](source);\n    }\n  },\n  getLayoutNodeBySource: function getLayoutNodeBySource(source) {\n    var mapping = this.source_Layout_Render_NodeMap.get(source);\n    if (mapping) {\n      return mapping.layoutNode;\n    }\n    return undefined;\n  },\n  getSourceRenderMeta: function getSourceRenderMeta(source) {\n    var map = this.source_Layout_Render_NodeMap;\n    var _meta = map.get(source);\n    if (!_meta) {\n      return null;\n    }\n    return _objectSpread(_objectSpread({}, _meta), {}, {\n      jflowFromLinks: Array.from(_meta.jflowFromLinks),\n      jflowToLinks: Array.from(_meta.jflowToLinks)\n    });\n  },\n  _getMap: function _getMap(source) {\n    if (!source) {\n      return null;\n    }\n    var map = this.source_Layout_Render_NodeMap;\n    var obj;\n    if (map.has(source)) {\n      obj = map.get(source);\n    } else {\n      obj = map.set(source);\n    }\n    return obj;\n  },\n  setLayoutNodeBySource: function setLayoutNodeBySource(source, layoutNode) {\n    var obj = this._getMap(source);\n    obj.layoutNode = layoutNode;\n  },\n  setRenderNodeBySource: function setRenderNodeBySource(source, instance) {\n    var obj = this._getMap(source);\n    obj.jflowNode = instance;\n    if (obj.jflowFromLinks.size > 0) {\n      obj.jflowFromLinks.forEach(function (link) {\n        link.from = instance;\n      });\n    }\n    if (obj.jflowToLinks.size > 0) {\n      obj.jflowToLinks.forEach(function (link) {\n        link.to = instance;\n      });\n    }\n  },\n  addLinkNodeBySource: function addLinkNodeBySource(sourceFrom, sourceTo, link) {\n    var obj = this._getMap(sourceFrom);\n    obj.jflowFromLinks.add(link);\n    obj = this._getMap(sourceTo);\n    obj.jflowToLinks.add(link);\n  },\n  removeLinkNodeBySource: function removeLinkNodeBySource(sourceFrom, sourceTo, link) {\n    var map = this.source_Layout_Render_NodeMap;\n    var obj = map.get(sourceFrom);\n    if (obj) {\n      obj.jflowFromLinks["delete"](link);\n      if (obj.jflowFromLinks.size === 0 && obj.jflowToLinks.size === 0 && !obj.jflowNode) {\n        this.source_Layout_Render_NodeMap["delete"](sourceFrom);\n      }\n    }\n    obj = map.get(sourceTo);\n    if (obj) {\n      obj.jflowToLinks["delete"](link);\n      if (obj.jflowFromLinks.size === 0 && obj.jflowToLinks.size === 0 && !obj.jflowNode) {\n        this.source_Layout_Render_NodeMap["delete"](sourceTo);\n      }\n    }\n  },\n  changeLinkNodeBySource: function changeLinkNodeBySource(prevSource, nextSource, link, dir) {\n    var obj = this._getMap(prevSource);\n    if (obj) {\n      if (dir === \'from\') {\n        obj.jflowFromLinks["delete"](link);\n      }\n      if (dir === \'to\') {\n        obj.jflowToLinks["delete"](link);\n      }\n    }\n    obj = this._getMap(nextSource);\n    if (obj) {\n      if (dir === \'from\') {\n        obj.jflowFromLinks.add(link);\n        if (obj.jflowNode) {\n          link.from = obj.jflowNode;\n        }\n      }\n      if (dir === \'to\') {\n        obj.jflowToLinks.add(link);\n        if (obj.jflowNode) {\n          link.to = obj.jflowNode;\n        }\n      }\n    }\n  },\n  changeNodeBySource: function changeNodeBySource(prevSource, nextSource, instance) {\n    if (prevSource && nextSource) {\n      var oldobj = this._getMap(prevSource);\n      var newobj = this._getMap(nextSource);\n      newobj.jflowNode = instance;\n      oldobj.jflowFromLinks.forEach(function (link) {\n        newobj.jflowFromLinks.add(link);\n      });\n      oldobj.jflowToLinks.forEach(function (link) {\n        newobj.jflowFromLinks.add(link);\n      });\n      newobj.jflowFromLinks.forEach(function (link) {\n        link.from = instance;\n      });\n      newobj.jflowToLinks.forEach(function (link) {\n        link.to = instance;\n      });\n      this.source_Layout_Render_NodeMap["delete"](prevSource);\n    }\n  }\n};\n/* harmony default export */ const nodeWeakMap = ((/* unused pure expression or super */ null && (NodeWeakMap)));\n;// CONCATENATED MODULE: ./src/core/instance/stack.js\nfunction stack_typeof(obj) { "@babel/helpers - typeof"; return stack_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, stack_typeof(obj); }\nfunction stack_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction stack_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, stack_toPropertyKey(descriptor.key), descriptor); } }\nfunction stack_createClass(Constructor, protoProps, staticProps) { if (protoProps) stack_defineProperties(Constructor.prototype, protoProps); if (staticProps) stack_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction stack_toPropertyKey(arg) { var key = stack_toPrimitive(arg, "string"); return stack_typeof(key) === "symbol" ? key : String(key); }\nfunction stack_toPrimitive(input, hint) { if (stack_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (stack_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = stack_getPrototypeOf(object); if (object === null) break; } return object; }\nfunction stack_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) stack_setPrototypeOf(subClass, superClass); }\nfunction stack_createSuper(Derived) { var hasNativeReflectConstruct = stack_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = stack_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = stack_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return stack_possibleConstructorReturn(this, result); }; }\nfunction stack_possibleConstructorReturn(self, call) { if (call && (stack_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return stack_assertThisInitialized(self); }\nfunction stack_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction stack_wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; stack_wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !stack_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return stack_construct(Class, arguments, stack_getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return stack_setPrototypeOf(Wrapper, Class); }; return stack_wrapNativeSuper(Class); }\nfunction stack_construct(Parent, args, Class) { if (stack_isNativeReflectConstruct()) { stack_construct = Reflect.construct.bind(); } else { stack_construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) stack_setPrototypeOf(instance, Class.prototype); return instance; }; } return stack_construct.apply(null, arguments); }\nfunction stack_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction stack_isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }\nfunction stack_setPrototypeOf(o, p) { stack_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return stack_setPrototypeOf(o, p); }\nfunction stack_getPrototypeOf(o) { stack_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return stack_getPrototypeOf(o); }\n// import { NodePlaceholder } from \'./node-placeholder\';\n/**\n * 绘图栈\n * @extends Array\n */\nvar InstanceStack = /*#__PURE__*/function (_Array) {\n  stack_inherits(InstanceStack, _Array);\n  var _super = stack_createSuper(InstanceStack);\n  function InstanceStack() {\n    var _this;\n    stack_classCallCheck(this, InstanceStack);\n    _this = _super.call(this);\n    _this._currentHit = null;\n    return _this;\n  }\n  stack_createClass(InstanceStack, [{\n    key: "forEach",\n    value: function forEach(cb) {\n      return _get(stack_getPrototypeOf(InstanceStack.prototype), "forEach", this).call(this, function (i, idx) {\n        if (i.type === \'NODE_PLACEHOLDER\') {\n          return;\n        }\n        cb(i, idx);\n      });\n    }\n  }, {\n    key: "filter",\n    value: function filter(cb) {\n      return Array.from(_get(stack_getPrototypeOf(InstanceStack.prototype), "filter", this).call(this, function (i, idx) {\n        if (i.type === \'NODE_PLACEHOLDER\') {\n          return false;\n        }\n        return cb(i, idx);\n      }));\n    }\n  }, {\n    key: "slice",\n    value: function slice() {\n      return Array.from(_get(stack_getPrototypeOf(InstanceStack.prototype), "filter", this).call(this, function (i, idx) {\n        return i.type !== \'NODE_PLACEHOLDER\';\n      }));\n    }\n  }, {\n    key: "superfilter",\n    value: function superfilter(cb) {\n      return _get(stack_getPrototypeOf(InstanceStack.prototype), "filter", this).call(this, function (i, idx) {\n        return cb(i, idx);\n      });\n    }\n    /**\n     * 绘制当前栈\n     * @param {Context2d} ctx - canvas context2d\n     */\n  }, {\n    key: "render",\n    value: function render(ctx, condition) {\n      var movingTarget;\n      this.forEach(function (instance) {\n        if (instance._isMoving) {\n          movingTarget = instance;\n          return;\n        }\n        if (instance.visible && (!condition || condition(instance))) {\n          if (instance.beforeRender) {\n            if (!instance.beforeRender(ctx)) {\n              return;\n            }\n          }\n          ctx.save();\n          instance.render(ctx);\n          ctx.restore();\n        }\n      });\n      if (movingTarget) {\n        ctx.save();\n        // if(movingTarget.reflow && !movingTarget._reflowed) {\n        //     movingTarget.reflow();\n        //     movingTarget._reflowed = true;\n        // }\n        movingTarget.render(ctx);\n        ctx.restore();\n      }\n    }\n  }, {\n    key: "resetHitStatus",\n    value: function resetHitStatus() {\n      this._currentHit = null;\n      this.forEach(function (i) {\n        if (i._stack) {\n          i._stack.resetHitStatus();\n        }\n        i._isHit = false;\n      });\n    }\n\n    /**\n     * 碰撞对象过滤条件\n     * @name InstanceStack~InstanceFilter\n     * @function\n     * @param {Instance} instance - 当前对象\n    */\n    /**\n     * 碰撞检测\n     * @param {number[]} point - 碰撞点\n     * @param {InstanceStack~InstanceFilter} condition - 碰撞对象过滤条件\n     * @return {Instance}\n     */\n  }, {\n    key: "checkHit",\n    value: function checkHit(point, condition, currentConstraint) {\n      var i = this.length - 1;\n      while (i >= 0) {\n        var instance = this[i];\n        if (instance.type === \'NODE_PLACEHOLDER\') {\n          i--;\n          continue;\n        }\n        if (instance.visible && !instance.ignoreHit) {\n          if (condition && condition(instance)) {\n            i--;\n            continue;\n          }\n          if (currentConstraint && !currentConstraint(instance)) {\n            i--;\n            continue;\n          }\n          var ishit = instance.isHit(point, condition);\n          if (ishit) {\n            if (this._currentHit !== instance) {\n              if (this._currentHit) {\n                this._currentHit._isHit = false;\n              }\n              instance._isHit = true;\n              this._currentHit = instance;\n            }\n            if (typeof ishit !== \'boolean\') {\n              return ishit;\n            }\n            return instance;\n          } else {\n            instance._isHit = false;\n          }\n        }\n        i--;\n      }\n      if (this._currentHit) {\n        this._currentHit._isHit = false;\n      }\n      this._currentHit = null;\n      return null;\n    }\n    /**\n     * 获取当前层栈的最小外接矩形\n     * @return {number[][]} - 外接矩形坐标\n     */\n  }, {\n    key: "getBoundingRectPoints",\n    value: function getBoundingRectPoints() {\n      var points = [];\n      this.forEach(function (instance) {\n        if (instance.visible && !instance.absolutePosition) {\n          var rect = instance.getBoundingRect();\n          points.push([rect[0], rect[1]]);\n          points.push([rect[2], rect[3]]);\n        }\n      });\n      return points;\n    }\n\n    /**\n     * 获取当前层栈的锚点矩形\n     * @return {number[][]} - 锚点矩形坐标\n     */\n  }, {\n    key: "getAnchorRectPoints",\n    value: function getAnchorRectPoints() {\n      var points = [];\n      this.forEach(function (instance) {\n        if (instance.visible && !instance.absolutePosition) {\n          points.push(instance.anchor);\n        }\n      });\n      return points;\n    }\n  }]);\n  return InstanceStack;\n}( /*#__PURE__*/stack_wrapNativeSuper(Array));\n/* harmony default export */ const stack = (InstanceStack);\n;// CONCATENATED MODULE: ./src/core/instance/stackMixin.js\n\n\n\n// import { setUniqueId, getUniqueId } from \'../utils/functions\';\n/**\n * 对象栈 mixin 用于方便控制节点栈和连线栈\n *\n * @mixin\n */\nvar StackMixin = {\n  /** @property {Node[]}          - 对象数组 */\n  instances: [],\n  /** @property {BaseLink[]}      - 连线数组 */\n  links: [],\n  /** @property {InstanceStack}       - 对象栈 */\n  _stack: null,\n  /** @property {InstanceStack}       - 连线栈 */\n  _linkStack: null,\n  /**\n   * 初始化对象栈\n   * @param {JflowConfigs} configs - 配置\n   */\n  initStack: function initStack() {\n    var _this = this;\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      data = _ref.data;\n    this._stack = new stack();\n    this._linkStack = new stack();\n    if (!data) return;\n    this.instances = data.instances;\n    this.links = data.links;\n    this.instances.forEach(function (i) {\n      _this._stack.push(i);\n      i._belongs = _this;\n    });\n    this.links.forEach(function (link) {\n      _this._linkStack.push(link);\n      link._belongs = _this;\n    });\n  },\n  /**\n   * 加入节点对象\n   * @param {Node} instance - 节点对象\n   */\n  addToStack: function addToStack(instance) {\n    // console.log(\'-----addToStack----\', instance)\n    instance._belongs = this;\n    this._stack.push(instance);\n    dirty_work_addReflowWork(instance, this);\n    // this.recalculate()\n  },\n  insertToStackBefore: function insertToStackBefore(instance, anchorNode) {\n    // console.log(\'-----insertToStackBefore----\')\n    if (instance._belongs) {\n      instance._belongs.removeFromStack(instance);\n    }\n    instance._belongs = this;\n    var idx = this._stack.findIndex(function (s) {\n      return s === anchorNode;\n    });\n    if (idx !== -1) {\n      this._stack.splice(idx, 0, instance);\n      dirty_work_addReflowWork(instance, this);\n    } else {\n      this.addToStack(instance);\n    }\n  },\n  /**\n   * 替换对象\n   * @param {Instance} target - 被替换的对象\n   * @param {Instance} instance - 替换对象\n   */\n  replaceFromStack: function replaceFromStack(target, instance) {\n    var index = this._stack.findIndex(function (i) {\n      return i === target;\n    });\n    this._stack.splice(index, 1, instance);\n    target._belongs = null;\n    instance._belongs = this;\n    // this.recalculate()\n  },\n  /**\n   * 加入连线对象\n   * @param {BaseLink} instance - 连线对象\n   */\n  addToLinkStack: function addToLinkStack(link) {\n    if (this._linkStack.find(function (l) {\n      return l === link;\n    })) {\n      return;\n    }\n    link._belongs = this;\n    this._linkStack.push(link);\n  },\n  /**\n   * 删除节点对象\n   * @param {Node} target - 节点对象\n   */\n  removeFromStack: function removeFromStack(target) {\n    // console.log(\'-----removeFromStack----\')\n    // this.removeLinkOnInstance(target);\n    var index = this._stack.findIndex(function (i) {\n      return i === target;\n    });\n    if (index !== -1) {\n      this._stack.splice(index, 1);\n      dirty_work_addReflowWork(this);\n    }\n    // this.recalculate()\n  },\n  /**\n   * 删除连线对象\n   * @param {Node} target - 连线对象\n   */\n  removeFromLinkStack: function removeFromLinkStack(target) {\n    var index = this._linkStack.findIndex(function (i) {\n      return i === target;\n    });\n    if (index !== -1) {\n      this._linkStack.splice(index, 1);\n    }\n  },\n  emptyLink: function emptyLink() {\n    this._linkStack = new stack();\n  },\n  /**\n   * 重置当前栈中对象的位置\n   */\n  resetChildrenPosition: function resetChildrenPosition() {\n    this._stack.forEach(function (i) {\n      i.anchor = [0, 0];\n    });\n  },\n  addInstanceToLink: function addInstanceToLink(targetLink, instance) {\n    this.addToStack(instance);\n    var from = targetLink.from,\n      to = targetLink.to;\n    var index = this._linkStack.findIndex(function (l) {\n      return l === targetLink;\n    });\n    var _constuctor = targetLink.__proto__.constructor;\n    var l1 = new _constuctor({\n      from: from,\n      to: instance\n    });\n    l1._belongs = this;\n    var l2 = new _constuctor({\n      from: instance,\n      to: to\n    });\n    l2._belongs = this;\n    this._linkStack.splice(index, 1, l1, l2);\n  },\n  /**\n   * 循环当前栈中节点\n   * @property {stackIteratorCallback} 循环访问栈中每个节点\n   */\n  interateNodeStack: function interateNodeStack(callback) {\n    this._stack.forEach(function (instance) {\n      callback(instance);\n    });\n  }\n  /**\n  * 循环访问栈中每个节点\n  * @callback stackIteratorCallback\n  * @param {Node} instance 栈中节点\n  */\n};\n/* harmony default export */ const stackMixin = (StackMixin);\n;// CONCATENATED MODULE: ./src/core/instance/layoutMixin.js\n/**\n * Layout mixin 配置\n * @typedef {Object} LayoutMixin~LayoutConfigs\n * @property {Layout} layout             - 布局对象 \n */\n/**\n * 布局 mixin 用于注册和方便控制布局\n *\n * @mixin\n */\nvar LayoutMixin = {\n  /** @property {Layout}      - 布局对象 */\n  _layout: null,\n  /**\n   * 初始化布局\n   * @param {LayoutMixin~LayoutConfigs} configs - 配置\n   */\n  initLayout: function initLayout() {\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._layout = configs.layout;\n  },\n  /**\n   * 从当前层出发，向上层递归重排\n   */\n  recalculateUp: function recalculateUp() {\n    var _this$_belongs;\n    // console.log(\'----recalculateUp----\')\n    var dirty = true;\n    if (this.getBoundingDimension) {\n      var _this$getBoundingDime = this.getBoundingDimension(),\n        wold = _this$getBoundingDime.width,\n        hold = _this$getBoundingDime.height;\n      if (this.resetChildrenPosition) {\n        this.resetChildrenPosition();\n      }\n      if (this._getBoundingGroupRect) {\n        this._getBoundingGroupRect();\n      }\n      this.reflow();\n      if (this._getBoundingGroupRect) {\n        this._getBoundingGroupRect();\n      }\n      var _this$getBoundingDime2 = this.getBoundingDimension(),\n        wnow = _this$getBoundingDime2.width,\n        hnow = _this$getBoundingDime2.height;\n      dirty = wold !== wnow || hold !== hnow;\n    } else {\n      this.reflow();\n    }\n    if (this._belongs && dirty) {\n      this._belongs.recalculateUp();\n    }\n    if (!dirty || ((_this$_belongs = this._belongs) === null || _this$_belongs === void 0 ? void 0 : _this$_belongs.uniqueName) === \'jflow\') {\n      this.recalculateDown();\n    }\n  },\n  recalculateDown: function recalculateDown() {\n    if (this._layout && this._layout.reflowAfter) {\n      this._layout.reflowAfter(this);\n    }\n    this._stack.forEach(function (instance) {\n      if (instance.recalculateDown) {\n        instance.recalculateDown();\n      }\n    });\n  },\n  /**\n   * 重新计算布局，相当于浏览器里面重排，并重算当前布局下的最小外接矩形\n   */\n  recalculate: function recalculate() {\n    // console.log(\'----recalculate----\')\n    this.reflow();\n    if (this._getBoundingGroupRect) {\n      this._getBoundingGroupRect();\n    }\n  },\n  /**\n   * 布局静态检查\n   * @param {Instance} instance - 检查单元\n   * @return {Boolean} - 检查结果 \n   */\n  staticCheck: function staticCheck(instance) {\n    if (this._layout) {\n      return this._layout.staticCheck(instance, this);\n    }\n    return false;\n  },\n  /**\n   * 重新计算布局，相当于浏览器里面重排\n   */\n  reflow: function reflow() {\n    if (this._layout) {\n      this._layout.reflow(this);\n    }\n  }\n};\n/* harmony default export */ const layoutMixin = (LayoutMixin);\n;// CONCATENATED MODULE: ./src/core/instance/messageMixin.js\n/**\n * 消息 mixin 用于给Jflow传递消息\n *\n * @mixin\n */\nvar MessageMixin = {\n  _message: null,\n  /**\n   * 发送消息\n   * @param {Object} msg - 消息体\n   */\n  sendMessage: function sendMessage(msg) {\n    this._message = msg;\n  },\n  /**\n   * 接收消息\n   * @return {Object} msg - 消息体\n   */\n  consumeMessage: function consumeMessage() {\n    var msg = this._message;\n    this._message = null;\n    return msg;\n  },\n  readMessage: function readMessage() {\n    return this._message;\n  }\n};\n/* harmony default export */ const messageMixin = (MessageMixin);\n;// CONCATENATED MODULE: ./src/core/anime/animeMixin.js\n/* harmony default export */ const animeMixin = ({\n  initAnime: function initAnime() {\n    this.anime_queue = [];\n    this.__animeClock__ = undefined;\n    // this.animeclock = undefined;\n    // this.frameRendered = false;\n  },\n  // setAnimeClock(time) {\n  //     if(time !== this.animeclock) {\n  //         this.frameRendered = false;\n  //         this.animeclock = time;\n  //     }\n  // },\n  // hasAnimeAndFrameRendered() {\n  //     return this.anime_queue.length && this.frameRendered;\n  // },\n  // setFrameRendered() {\n  //     if(this.anime_queue.length) {\n  //         this.frameRendered = true;\n  //     }\n  // },\n  requestJFlowAnime: function requestJFlowAnime(frameCallBack) {\n    var meta = this.enqueueAnime(frameCallBack);\n    this._runAnime();\n    return meta;\n  },\n  enqueueAnime: function enqueueAnime(callback) {\n    var _this = this;\n    var animeMeta = {\n      start: undefined,\n      callback: callback,\n      cancel: function cancel() {\n        _this._cancelAnime(animeMeta);\n        _this._render();\n      }\n    };\n    this.anime_queue.push(animeMeta);\n    return animeMeta;\n  },\n  _cancelAnime: function _cancelAnime(meta) {\n    var idx = this.anime_queue.findIndex(function (m) {\n      return m === meta;\n    });\n    ~idx && this.anime_queue.splice(idx, 1);\n  },\n  runAnime: function runAnime() {\n    this._runAnime();\n    // requestAnimationFrame(this._runAnime.bind(this));\n  },\n  _runAnime: function _runAnime() {\n    var _this2 = this;\n    if (this.anime_queue.length) {\n      requestAnimationFrame(function () {\n        _this2.scheduleRender();\n        _this2._runAnime();\n      });\n      // requestAnimationFrame(this._runAnime.bind(this))\n    }\n  },\n  runAnimeFrame: function runAnimeFrame() {\n    this.anime_queue.forEach(function (meta) {\n      var timestamp = Date.now();\n      if (!meta.start) {\n        meta.start = timestamp;\n      }\n      var elapsed = timestamp - meta.start;\n      meta.callback(elapsed);\n    });\n  }\n});\n;// CONCATENATED MODULE: ./src/core/miniMap/minimap-mixin.js\nfunction minimap_mixin_slicedToArray(arr, i) { return minimap_mixin_arrayWithHoles(arr) || minimap_mixin_iterableToArrayLimit(arr, i) || minimap_mixin_unsupportedIterableToArray(arr, i) || minimap_mixin_nonIterableRest(); }\nfunction minimap_mixin_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction minimap_mixin_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return minimap_mixin_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return minimap_mixin_arrayLikeToArray(o, minLen); }\nfunction minimap_mixin_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction minimap_mixin_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction minimap_mixin_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/* harmony default export */ const minimap_mixin = ({\n  // 传入一个别的 context2d 来绘制\n  captureMap: function captureMap(wrapper, _ref) {\n    var _this = this;\n    var _ref$padding = _ref.padding,\n      padding = _ref$padding === void 0 ? 0 : _ref$padding,\n      _ref$placement = _ref.placement,\n      placement = _ref$placement === void 0 ? \'normal\' : _ref$placement;\n    this._getBoundingGroupRect();\n    var _this$bounding_box = this.bounding_box,\n      p_width = _this$bounding_box.width,\n      p_height = _this$bounding_box.height,\n      p_x = _this$bounding_box.x,\n      p_y = _this$bounding_box.y;\n    var miniMap = this.miniMap;\n    if (!miniMap) {\n      this.miniMap = createCanvas(wrapper);\n      var _this$miniMap = this.miniMap,\n        _width = _this$miniMap.width,\n        _height = _this$miniMap.height,\n        _raw_width = _this$miniMap.raw_width,\n        _raw_height = _this$miniMap.raw_height;\n      this.addEventListener(\'zoompan\', function () {\n        _this._renderMap && _this._renderMap();\n      });\n      var pressDown = false;\n      this.miniMap.canvas.addEventListener(\'pointerdown\', function (event) {\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY,\n          deltaX = event.deltaX,\n          deltaY = event.deltaY;\n        pressDown = true;\n        _this._onMoveMap && _this._onMoveMap(offsetX, offsetY);\n      });\n      this.miniMap.canvas.addEventListener(\'pointermove\', function (event) {\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY,\n          deltaX = event.deltaX,\n          deltaY = event.deltaY;\n        if (pressDown) {\n          _this._onMoveMap && _this._onMoveMap(offsetX, offsetY);\n        }\n        if (offsetY < 5 || offsetX < 5 || offsetX > _width - 5 || offsetY > _height - 5) {\n          pressDown = false;\n        }\n      });\n      this.miniMap.canvas.addEventListener(\'pointerup\', function () {\n        pressDown = false;\n      });\n      var caheCanvas = document.createElement(\'canvas\');\n      caheCanvas.width = _raw_width;\n      caheCanvas.height = _raw_height;\n      this.cacheMinimapCtx = caheCanvas.getContext(\'2d\');\n    }\n    var _this$miniMap2 = this.miniMap,\n      width = _this$miniMap2.width,\n      height = _this$miniMap2.height,\n      raw_width = _this$miniMap2.raw_width,\n      raw_height = _this$miniMap2.raw_height,\n      left = _this$miniMap2.left,\n      top = _this$miniMap2.top,\n      scale = _this$miniMap2.scale,\n      ctx = _this$miniMap2.ctx;\n    var pad2 = padding * 2;\n    var pad = padding;\n    var r1 = (width - pad2) / p_width;\n    var r2 = (height - pad2) / p_height;\n    var r = Math.min(r1, r2);\n    var m_x = 0;\n    var m_y = 0;\n    if (placement === \'center\') {\n      m_y = (height - p_height * r) / 2 - p_y * r;\n      m_x = (width - p_width * r) / 2 - p_x * r;\n    } else {\n      if (r1 < r2) {\n        m_y = (height - p_height * r) / 2 - p_y * r;\n        m_x = pad;\n      } else {\n        m_x = (width - p_width * r) / 2 - p_x * r;\n        m_y = pad;\n      }\n    }\n    var cachectx = this.cacheMinimapCtx;\n    cachectx.setTransform();\n    cachectx.clearRect(0, 0, raw_width, raw_height);\n    cachectx.scale(scale, scale);\n    cachectx.transform(r, 0, 0, r, m_x, m_y);\n    // ctx.fillStyle = \'red\';\n    // ctx.arc( 30, 30, 100, 0, 2*Math.PI);\n    // ctx.fill()\n    // debugger\n    var br = [0, 0, 0, 0];\n    if (this.NodeRenderTop) {\n      this._linkStack.render(cachectx, function (link) {\n        link.isInViewBox(br);\n        return true;\n      });\n      // this._linkStack.render(cachectx);\n      this._stack.render(cachectx);\n    } else {\n      this._stack.render(cachectx);\n      this._linkStack.render(cachectx, function (link) {\n        link.isInViewBox(br);\n        return true;\n      });\n    }\n    var _cacheMapImageData = cachectx.getImageData(0, 0, raw_width, raw_height);\n    this._renderMap = function () {\n      ctx.save();\n      ctx.setTransform();\n      ctx.clearRect(0, 0, raw_width, raw_height);\n      // if(!i) {\n      ctx.scale(scale, scale);\n      ctx.putImageData(_cacheMapImageData, 0, 0);\n      ctx.transform(r, 0, 0, r, m_x, m_y);\n      var _this$_getViewBox = _this._getViewBox(),\n        _this$_getViewBox2 = minimap_mixin_slicedToArray(_this$_getViewBox, 4),\n        x = _this$_getViewBox2[0],\n        y = _this$_getViewBox2[1],\n        t = _this$_getViewBox2[2],\n        d = _this$_getViewBox2[3];\n      ctx.beginPath();\n      ctx.rect(x, y, t - x, d - y);\n      ctx.setTransform();\n      ctx.rect(0, 0, raw_width, raw_height);\n      ctx.clip("evenodd");\n      ctx.fillStyle = \'rgba(0,0,0,0.4)\';\n      ctx.fillRect(0, 0, raw_width, raw_height);\n      ctx.restore();\n      // }\n    };\n\n    this._renderMap();\n    this._onMoveMap = function (offsetX, offsetY) {\n      var _this$_getViewBox3 = _this._getViewBox(),\n        _this$_getViewBox4 = minimap_mixin_slicedToArray(_this$_getViewBox3, 4),\n        x = _this$_getViewBox4[0],\n        y = _this$_getViewBox4[1],\n        t = _this$_getViewBox4[2],\n        d = _this$_getViewBox4[3];\n      // const w = t-x;\n      var a = (t - x) / 2 + x;\n      var b = (d - y) / 2 + y;\n      var p = [a * r + m_x, b * r + m_y];\n      _this._recalculatePosition((p[0] - offsetX) / r * _this.scale, (p[1] - offsetY) / r * _this.scale);\n      _this._render();\n      _this._renderMap();\n    };\n    // this._render(ctx);\n  }\n});\n;// CONCATENATED MODULE: ./src/core/events/index.js\nfunction events_typeof(obj) { "@babel/helpers - typeof"; return events_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, events_typeof(obj); }\nfunction events_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction events_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? events_ownKeys(Object(source), !0).forEach(function (key) { events_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : events_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction events_defineProperty(obj, key, value) { key = events_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction events_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, events_toPropertyKey(descriptor.key), descriptor); } }\nfunction events_createClass(Constructor, protoProps, staticProps) { if (protoProps) events_defineProperties(Constructor.prototype, protoProps); if (staticProps) events_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction events_toPropertyKey(arg) { var key = events_toPrimitive(arg, "string"); return events_typeof(key) === "symbol" ? key : String(key); }\nfunction events_toPrimitive(input, hint) { if (events_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (events_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction events_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction events_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) events_setPrototypeOf(subClass, superClass); }\nfunction events_createSuper(Derived) { var hasNativeReflectConstruct = events_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = events_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = events_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return events_possibleConstructorReturn(this, result); }; }\nfunction events_possibleConstructorReturn(self, call) { if (call && (events_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return events_assertThisInitialized(self); }\nfunction events_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction events_wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; events_wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !events_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return events_construct(Class, arguments, events_getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return events_setPrototypeOf(Wrapper, Class); }; return events_wrapNativeSuper(Class); }\nfunction events_construct(Parent, args, Class) { if (events_isNativeReflectConstruct()) { events_construct = Reflect.construct.bind(); } else { events_construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) events_setPrototypeOf(instance, Class.prototype); return instance; }; } return events_construct.apply(null, arguments); }\nfunction events_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction events_isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }\nfunction events_setPrototypeOf(o, p) { events_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return events_setPrototypeOf(o, p); }\nfunction events_getPrototypeOf(o) { events_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return events_getPrototypeOf(o); }\n/**\n * JFlow 抛出事件\n * @extends CustomEvent\n * @property {Event}  originEvent      - 原始事件\n * @property {Instance} target         - 事件触发对象\n * @property {JFlow} jflow             - JFlow 对象\n * @property {boolean} bubbles         - 冒泡标识\n */\nvar JFlowEvent = /*#__PURE__*/function (_CustomEvent) {\n  events_inherits(JFlowEvent, _CustomEvent);\n  var _super = events_createSuper(JFlowEvent);\n  function JFlowEvent(event) {\n    var configs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    events_classCallCheck(this, JFlowEvent);\n    var detail = events_objectSpread(events_objectSpread({}, configs), {}, {\n      originEvent: configs.event,\n      target: configs.target,\n      jflow: configs.jflow,\n      bubbles: configs.bubbles || false\n    });\n    return _super.call(this, event, {\n      detail: detail\n    });\n  }\n  return events_createClass(JFlowEvent);\n}( /*#__PURE__*/events_wrapNativeSuper(CustomEvent));\n/* harmony default export */ const events = (JFlowEvent);\n;// CONCATENATED MODULE: ./src/core/scrollbar/scrollbarMixin.js\nfunction scrollbarMixin_typeof(obj) { "@babel/helpers - typeof"; return scrollbarMixin_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, scrollbarMixin_typeof(obj); }\nfunction scrollbarMixin_slicedToArray(arr, i) { return scrollbarMixin_arrayWithHoles(arr) || scrollbarMixin_iterableToArrayLimit(arr, i) || scrollbarMixin_unsupportedIterableToArray(arr, i) || scrollbarMixin_nonIterableRest(); }\nfunction scrollbarMixin_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction scrollbarMixin_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return scrollbarMixin_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return scrollbarMixin_arrayLikeToArray(o, minLen); }\nfunction scrollbarMixin_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction scrollbarMixin_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction scrollbarMixin_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction scrollbarMixin_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction scrollbarMixin_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, scrollbarMixin_toPropertyKey(descriptor.key), descriptor); } }\nfunction scrollbarMixin_createClass(Constructor, protoProps, staticProps) { if (protoProps) scrollbarMixin_defineProperties(Constructor.prototype, protoProps); if (staticProps) scrollbarMixin_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction scrollbarMixin_toPropertyKey(arg) { var key = scrollbarMixin_toPrimitive(arg, "string"); return scrollbarMixin_typeof(key) === "symbol" ? key : String(key); }\nfunction scrollbarMixin_toPrimitive(input, hint) { if (scrollbarMixin_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (scrollbarMixin_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\nvar ScrollBar = /*#__PURE__*/function () {\n  function ScrollBar(dir) {\n    var configs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    scrollbarMixin_classCallCheck(this, ScrollBar);\n    this.anchor = [0, 0];\n    this.width = configs.barWidth || 4;\n    this.height = configs.barWidth || 4;\n    this.barMarginX = 0;\n    this.barMarginY = 0;\n    this.dir = dir;\n    this.plainColor = configs.plainColor || \'rgba(0, 0, 0, 0.15)\';\n    this.focusColor = configs.focusColor || \'rgba(0, 0, 0, 0.25)\';\n    this.isFocus = false;\n  }\n  scrollbarMixin_createClass(ScrollBar, [{\n    key: "render",\n    value: function render(ctx) {\n      var _this$anchor = scrollbarMixin_slicedToArray(this.anchor, 2),\n        x = _this$anchor[0],\n        y = _this$anchor[1];\n      ctx.save();\n      ctx.beginPath();\n      if (this.dir === \'x\') {\n        var radius = this.height / 2;\n        var cy = y + radius;\n        var by = y + this.height;\n        var rc = x + this.width - this.barMarginX * 2 - radius;\n        var lc = x + this.barMarginX + radius;\n        ctx.moveTo(lc, by);\n        ctx.arc(lc, cy, radius, Math.PI / 2, Math.PI / 2 * 3);\n        ctx.lineTo(rc, y);\n        ctx.arc(rc, cy, radius, -Math.PI / 2, Math.PI / 2);\n        ctx.closePath();\n      } else {\n        var _radius = this.width / 2;\n        var tc = y + this.barMarginY + _radius;\n        var bc = y + this.height - this.barMarginY * 2 - _radius;\n        var cx = x + _radius;\n        var rx = x + this.width;\n        ctx.moveTo(x, tc);\n        ctx.arc(cx, tc, _radius, -Math.PI, 0);\n        ctx.lineTo(rx, bc);\n        ctx.arc(cx, bc, _radius, 0, Math.PI);\n        ctx.closePath();\n      }\n      //   ctx.rect(\n      // x + this.barMarginX,\n      // y + this.barMarginY,\n      // this.width - this.barMarginX*2,\n      // this.height - this.barMarginY*2);\n\n      ctx.fillStyle = this.isFocus ? this.focusColor : this.plainColor;\n      ctx.fill();\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      var anchor = this.anchor;\n      var w = this.width;\n      var h = this.height;\n      return point[0] > anchor[0] - 5 && point[0] < anchor[0] + w + 5 && point[1] > anchor[1] - 5 && point[1] < anchor[1] + h + 5;\n    }\n  }]);\n  return ScrollBar;\n}();\n/* harmony default export */ const scrollbarMixin = ({\n  initScrollBar: function initScrollBar() {\n    var _this = this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var barColor = configs.barColor,\n      barFocusColor = configs.barFocusColor,\n      barMarginX = configs.barMarginX,\n      barMarginY = configs.barMarginY,\n      barWidth = configs.barWidth;\n    this._scrollbarEnable = true;\n    this._scrollbarX = new ScrollBar(\'x\', {\n      plainColor: barColor,\n      focusColor: barFocusColor,\n      barWidth: barWidth\n    });\n    this._scrollbarX.barMarginX = barMarginX || 5;\n    this._scrollbarY = new ScrollBar(\'y\', {\n      plainColor: barColor,\n      focusColor: barFocusColor,\n      barWidth: barWidth\n    });\n    this._scrollbarY.barMarginY = barMarginY || 5;\n    this._scrollBarStatus = {\n      dragging: false,\n      target: null,\n      xscale: undefined,\n      yscale: undefined,\n      barInitX: 0,\n      barInitY: 0\n    };\n    this.stopZoompanWatch = false;\n    this.addEventListener(\'zoompan\', function () {\n      if (!_this.stopZoompanWatch) {\n        _this.scrollBarOnPanAndZoom();\n      }\n    });\n    this.scrollBarOnPanAndZoom();\n    this.canvas.addEventListener(\'pointerdown\', function (e) {\n      var offsetX = e.offsetX,\n        offsetY = e.offsetY,\n        clientX = e.clientX,\n        clientY = e.clientY;\n      _this.onScrollbarPressStart(offsetX, offsetY, clientX, clientY);\n    });\n  },\n  checkScrollDragging: function checkScrollDragging() {\n    return this._scrollBarStatus && this._scrollBarStatus.dragging;\n  },\n  onScrollbarPressStart: function onScrollbarPressStart(offsetX, offsetY, clientX, clientY) {\n    var _this2 = this;\n    this.stopZoompanWatch = true;\n    var xhit = this._scrollbarX.isHit([offsetX, offsetY]);\n    if (xhit) {\n      Object.assign(this._scrollBarStatus, {\n        dragging: true,\n        target: this._scrollbarX,\n        barStartX: this._scrollbarX.anchor[0],\n        barInitX: clientX\n      });\n    }\n    var yhit = this._scrollbarY.isHit([offsetX, offsetY]);\n    if (yhit) {\n      Object.assign(this._scrollBarStatus, {\n        dragging: true,\n        target: this._scrollbarY,\n        barStartY: this._scrollbarY.anchor[1],\n        barInitY: clientY\n      });\n    }\n    var f = function (e) {\n      var offsetX = e.offsetX,\n        offsetY = e.offsetY,\n        clientX = e.clientX,\n        clientY = e.clientY;\n      _this2.onDraggingScrollbar(offsetX, offsetY, clientX, clientY);\n    }.bind(this);\n    document.addEventListener(\'pointermove\', f);\n    var t = function (e) {\n      Object.assign(_this2._scrollBarStatus, {\n        dragging: false,\n        target: null,\n        x: undefined,\n        y: undefined\n      });\n      document.removeEventListener(\'pointermove\', f);\n      document.removeEventListener(\'pointerup\', t);\n      _this2.canvas.removeEventListener(\'pointerup\', t);\n      _this2.stopZoompanWatch = false;\n    }.bind(this);\n    this.canvas.addEventListener(\'pointerup\', t, {\n      once: true\n    });\n    document.addEventListener(\'pointerup\', t, {\n      once: true\n    });\n  },\n  onDraggingScrollbar: function onDraggingScrollbar(offsetX, offsetY, clientX, clientY) {\n    if (this._scrollbarEnable && this._scrollBarStatus.dragging) {\n      var _this$_scrollBarStatu = this._scrollBarStatus,\n        target = _this$_scrollBarStatu.target,\n        barInitX = _this$_scrollBarStatu.barInitX,\n        barStartX = _this$_scrollBarStatu.barStartX,\n        barInitY = _this$_scrollBarStatu.barInitY,\n        barStartY = _this$_scrollBarStatu.barStartY,\n        xscale = _this$_scrollBarStatu.xscale,\n        yscale = _this$_scrollBarStatu.yscale,\n        scollbarHeight = _this$_scrollBarStatu.scollbarHeight,\n        scollbarWidth = _this$_scrollBarStatu.scollbarWidth,\n        realR = _this$_scrollBarStatu.realR,\n        realL = _this$_scrollBarStatu.realL,\n        realT = _this$_scrollBarStatu.realT,\n        realB = _this$_scrollBarStatu.realB;\n      var _this$canvasMeta = this.canvasMeta,\n        actual_width = _this$canvasMeta.actual_width,\n        actual_height = _this$canvasMeta.actual_height;\n      var _this$bounding_box = this.bounding_box,\n        p_x = _this$bounding_box.x,\n        p_y = _this$bounding_box.y;\n      // console.log(target.dir, realT, realB)\n      var deltaX = 0,\n        deltaY = 0;\n      if (target.dir === \'x\') {\n        deltaX = clientX - barInitX;\n        var xnew = barStartX + deltaX;\n        var q = target.anchor[0] = Math.max(Math.min(xnew, actual_width - scollbarWidth), 0);\n        var ratioInX = q / actual_width;\n        // const y = (realB - (realB - realT) * ratioInY) * this.scale\n        var ratioX = (realR - realL) * ratioInX + realL;\n        var x = (p_x - ratioX) * this.scale;\n        Object.assign(this.position, {\n          offsetX: x - p_x * this.scale,\n          x: x\n        });\n      }\n      if (target.dir === \'y\') {\n        deltaY = clientY - barInitY;\n        var ynew = barStartY + deltaY;\n        var _q = target.anchor[1] = Math.max(Math.min(ynew, actual_height - scollbarHeight), 0);\n        ;\n        var ratioInY = _q / actual_height;\n        // const y = (realB - (realB - realT) * ratioInY) * this.scale\n        var ratioY = (realB - realT) * ratioInY + realT;\n        var y = (p_y - ratioY) * this.scale;\n        Object.assign(this.position, {\n          offsetY: y - p_y * this.scale,\n          y: y\n        });\n      }\n      this.dispatchEvent(new events(\'zoompan\', {\n        deltaX: deltaX,\n        deltaY: deltaY\n      }));\n      this.scheduleRender();\n      return true;\n    }\n    return false;\n  },\n  checkScrollBarHover: function checkScrollBarHover(offsetX, offsetY) {\n    if (this._scrollbarEnable) {\n      var xhit = this._scrollbarX.isHit([offsetX, offsetY]);\n      if (xhit) {\n        // this._scrollBarStatus.hoverTarget = this._scrollbarX;\n        if (!this._scrollbarX.isFocus) {\n          this._scrollbarX.isFocus = true;\n          this.scheduleRender();\n        }\n        this.canvas.style.cursor = \'default\';\n        return true;\n      }\n      var yhit = this._scrollbarY.isHit([offsetX, offsetY]);\n      if (yhit) {\n        // this._scrollBarStatus.hoverTarget = this._scrollbarY;\n        if (!this._scrollbarY.isFocus) {\n          this._scrollbarY.isFocus = true;\n          this.scheduleRender();\n        }\n        this.canvas.style.cursor = \'default\';\n        return true;\n      }\n    }\n    return false;\n  },\n  resetScrollBarHover: function resetScrollBarHover() {\n    if (this._scrollbarEnable) {\n      if (this._scrollbarY.isFocus || this._scrollbarX.isFocus) {\n        this._scrollbarY.isFocus = false;\n        this._scrollbarX.isFocus = false;\n        this.scheduleRender();\n      }\n    }\n  },\n  _getScrollViewBoundingbox: function _getScrollViewBoundingbox() {\n    var padding = 120;\n    var _this$bounding_box2 = this.bounding_box,\n      p_width = _this$bounding_box2.width,\n      p_height = _this$bounding_box2.height,\n      p_x = _this$bounding_box2.x,\n      p_y = _this$bounding_box2.y;\n    var p = padding;\n    var p2 = padding * 2;\n    return {\n      width: p_width + p2,\n      height: p_height + p2,\n      x: p_x - p,\n      y: p_y - p\n    };\n  },\n  scrollBarOnPanAndZoom: function scrollBarOnPanAndZoom() {\n    if (!this._scrollbarEnable || this._scrollBarStatus.dragging) {\n      return;\n    }\n    var _this$_getScrollViewB = this._getScrollViewBoundingbox(),\n      p_width = _this$_getScrollViewB.width,\n      p_height = _this$_getScrollViewB.height,\n      p_x = _this$_getScrollViewB.x,\n      p_y = _this$_getScrollViewB.y;\n    var _this$_getViewBox = this._getViewBox(),\n      _this$_getViewBox2 = scrollbarMixin_slicedToArray(_this$_getViewBox, 4),\n      x = _this$_getViewBox2[0],\n      y = _this$_getViewBox2[1],\n      r = _this$_getViewBox2[2],\n      b = _this$_getViewBox2[3];\n    var realR = Math.max(r, p_x + p_width);\n    var realL = Math.min(x, p_x);\n    var realT = Math.min(y, p_y);\n    var realB = Math.max(b, p_y + p_height);\n    var vw = r - x;\n    var vh = b - y;\n    var _this$canvasMeta2 = this.canvasMeta,\n      actual_width = _this$canvasMeta2.actual_width,\n      actual_height = _this$canvasMeta2.actual_height;\n    var xscale = vw / (realR - realL);\n    if (xscale < 1) {\n      var scollbarWidth = actual_width * xscale;\n      var anchorX = (x - realL) * xscale * this.scale;\n      this._scrollbarX.anchor = [anchorX, actual_height - 10];\n      this._scrollbarX.width = scollbarWidth;\n      this._scrollBarStatus.scollbarWidth = scollbarWidth;\n    }\n    var yscale = vh / (realB - realT);\n    if (yscale < 1) {\n      var scollbarHeight = actual_height * yscale;\n      var anchorY = (y - realT) * yscale * this.scale;\n      this._scrollbarY.anchor = [actual_width - 10, anchorY];\n      this._scrollbarY.height = scollbarHeight;\n      this._scrollBarStatus.scollbarHeight = scollbarHeight;\n    }\n    Object.assign(this._scrollBarStatus, {\n      yscale: yscale,\n      xscale: xscale,\n      realR: realR,\n      realL: realL,\n      realT: realT,\n      realB: realB\n    });\n  },\n  resetScollBarStatus: function resetScollBarStatus() {\n    if (this._scrollbarEnable) {\n      Object.assign(this._scrollBarStatus, {\n        dragging: false,\n        target: null,\n        x: undefined,\n        y: undefined\n      });\n    }\n  },\n  renderScrollBar: function renderScrollBar(ctx) {\n    if (this._scrollbarEnable) {\n      ctx.setTransform();\n      ctx.scale(this.dpr, this.dpr);\n      var _this$_scrollBarStatu2 = this._scrollBarStatus,\n        xscale = _this$_scrollBarStatu2.xscale,\n        yscale = _this$_scrollBarStatu2.yscale;\n      if (xscale < 1) {\n        this._scrollbarX.render(ctx);\n      }\n      if (yscale < 1) {\n        this._scrollbarY.render(ctx);\n      }\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/core/flow/schedule.js\n/* harmony default export */ const schedule = ({\n  toggleRender: function toggleRender(val) {\n    this.__renderstop__ = !val;\n  },\n  initSchedule: function initSchedule() {\n    this.__clock__ = undefined;\n  },\n  scheduleRender: function scheduleRender(callback) {\n    var _this = this;\n    requestAnimationFrame(function (timestamp) {\n      var isFirstTime = _this.__clock__ !== timestamp;\n      if (!_this.__renderstop__ && isFirstTime) {\n        _this.__render();\n      }\n      if (callback) {\n        callback(timestamp);\n      }\n      _this.__clock__ = timestamp;\n    });\n  }\n});\n;// CONCATENATED MODULE: ./src/core/events/adapter.js\nfunction adapter_typeof(obj) { "@babel/helpers - typeof"; return adapter_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, adapter_typeof(obj); }\nfunction adapter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction adapter_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, adapter_toPropertyKey(descriptor.key), descriptor); } }\nfunction adapter_createClass(Constructor, protoProps, staticProps) { if (protoProps) adapter_defineProperties(Constructor.prototype, protoProps); if (staticProps) adapter_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction adapter_toPropertyKey(arg) { var key = adapter_toPrimitive(arg, "string"); return adapter_typeof(key) === "symbol" ? key : String(key); }\nfunction adapter_toPrimitive(input, hint) { if (adapter_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (adapter_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n/**\n * 事件处理函数\n * @name EventAdapter~Handler\n * @function\n * @param {Event} event - 原生事件\n * @param {JFlow} jflow - 当前jflow 对象\n */\n\n/**\n * EventAdapter 对象 plugin 配置\n * @typedef {Object} EventAdapter~pluginDef\n * @property {Object} canvas - canvas 相关的事件\n * @property {EventAdapter~Handler} canvas.eventName - 注册 canvas 上的事件处理\n * @property {Object} document - document 相关的事件\n * @property {EventAdapter~Handler} document.eventName - 注册 document 上的事件处理\n */\n\nfunction getDefaultPlugin() {\n  var _mouseStatus = {\n    // x: undefined,\n    // y: undefined,\n    // enableClick: false,\n    pointerDown: false,\n    dirty: false\n  };\n  return {\n    canvas: {\n      wheel: function wheel(event, jflow) {\n        event.preventDefault();\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY,\n          deltaX = event.deltaX,\n          deltaY = event.deltaY;\n        if (event.ctrlKey) {\n          deltaY = -deltaY;\n          jflow.zoomHandler(offsetX, offsetY, deltaX, deltaY, event);\n        } else {\n          jflow.panHandler(-deltaX, -deltaY, event);\n        }\n      },\n      pointerdown: function pointerdown(event, jflow) {\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY,\n          deltaY = event.deltaY,\n          button = event.button;\n        if (button !== 0) return;\n        _mouseStatus.pointerDown = true;\n        jflow.pressStartHandler(offsetX, offsetY, event);\n      },\n      pointermove: function pointermove(event, jflow) {\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY;\n        if (_mouseStatus.pointerDown) {\n          _mouseStatus.dirty = true;\n        }\n        jflow.pressMoveHandler(offsetX, offsetY, event);\n      },\n      pointerup: function pointerup(event, jflow) {\n        event.preventDefault();\n        // event.stopPropagation(); ALWAYS ENABLE PROPAGATION \n        var offsetX = event.offsetX,\n          offsetY = event.offsetY,\n          button = event.button;\n        if (button !== 0) return;\n        if (_mouseStatus.pointerDown && _mouseStatus.dirty) {\n          _mouseStatus.pointerDown = false;\n          _mouseStatus.dirty = false;\n          jflow.pressUpHanlder(false, event);\n        }\n      },\n      contextmenu: function contextmenu(event, jflow) {\n        event.preventDefault();\n        event.stopPropagation();\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY;\n        jflow.contextMenuHanlder(offsetX, offsetY, event);\n      },\n      dblclick: function dblclick(event, jflow) {\n        event.preventDefault();\n        event.stopPropagation();\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY;\n        jflow.dblclickHandler(offsetX, offsetY, event);\n      },\n      click: function click(event, jflow) {\n        event.preventDefault();\n        event.stopPropagation();\n        var offsetX = event.offsetX,\n          offsetY = event.offsetY;\n        if (!_mouseStatus.dirty) {\n          _mouseStatus.pointerDown = false;\n          _mouseStatus.dirty = false;\n          jflow.clickHanlder(offsetX, offsetY, event);\n        }\n      }\n    },\n    document: {\n      pointerup: function pointerup(event, jflow) {\n        jflow.pressUpHanlder(true, event);\n      }\n    }\n  };\n}\n\n/** \n * EventAdapter 对象\n * EventAdapter 通过 plugin 的形式实现多种交互方式的映射\n * @constructor EventAdapter\n */\nvar EventAdapter = /*#__PURE__*/function () {\n  function EventAdapter() {\n    var plugin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    adapter_classCallCheck(this, EventAdapter);\n    this.plugin = getDefaultPlugin();\n    this.use(plugin);\n    this.canvasHandlers = [];\n    this.documentHandlers = [];\n  }\n  adapter_createClass(EventAdapter, [{\n    key: "use",\n    value: function use() {\n      var plugin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var ca = plugin.canvas,\n        docObj = plugin.document;\n      if (ca) {\n        for (var eventName in ca) {\n          if (ca.hasOwnProperty(eventName)) {\n            this.plugin.canvas[eventName] = ca[eventName];\n          }\n        }\n      }\n      if (docObj) {\n        for (var _eventName in docObj) {\n          if (docObj.hasOwnProperty(_eventName)) {\n            this.plugin.document[_eventName] = docObj[_eventName];\n          }\n        }\n      }\n    }\n  }, {\n    key: "apply",\n    value: function apply(jflow) {\n      var _this = this;\n      var _this$plugin = this.plugin,\n        ca = _this$plugin.canvas,\n        docObj = _this$plugin.document;\n      var canvas = jflow.canvas;\n      var _loop = function _loop() {\n        var handler = ca[eventName];\n        function handlerWrapperd(e) {\n          handler(e, jflow);\n        }\n        canvas.addEventListener(eventName, handlerWrapperd);\n        _this.canvasHandlers.push({\n          eventName: eventName,\n          handlerWrapperd: handlerWrapperd\n        });\n      };\n      for (var eventName in ca) {\n        _loop();\n      }\n      var _loop2 = function _loop2() {\n        var handler;\n        var options = {};\n        if (typeof docObj[_eventName2] === \'function\') {\n          handler = docObj[_eventName2];\n        } else {\n          handler = docObj[_eventName2].handler;\n          Object.assign(options, docObj[_eventName2].options);\n        }\n        function handlerWrapperd(e) {\n          handler(e, jflow);\n        }\n        document.addEventListener(_eventName2, handlerWrapperd, options);\n        _this.documentHandlers.push({\n          eventName: _eventName2,\n          handlerWrapperd: handlerWrapperd,\n          options: options\n        });\n      };\n      for (var _eventName2 in docObj) {\n        _loop2();\n      }\n    }\n  }, {\n    key: "unload",\n    value: function unload(jflow) {\n      var canvas = jflow.canvas;\n      this.canvasHandlers.forEach(function (_ref) {\n        var eventName = _ref.eventName,\n          handlerWrapperd = _ref.handlerWrapperd;\n        canvas.removeEventListener(eventName, handlerWrapperd);\n      });\n      this.documentHandlers.forEach(function (_ref2) {\n        var eventName = _ref2.eventName,\n          handlerWrapperd = _ref2.handlerWrapperd,\n          options = _ref2.options;\n        console.log(\'unload\', eventName);\n        document.removeEventListener(eventName, handlerWrapperd, options);\n      });\n    }\n  }]);\n  return EventAdapter;\n}();\n/* harmony default export */ const adapter = (EventAdapter);\n;// CONCATENATED MODULE: ./src/core/instance/groupFactory.js\nfunction groupFactory_typeof(obj) { "@babel/helpers - typeof"; return groupFactory_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, groupFactory_typeof(obj); }\nfunction groupFactory_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, groupFactory_toPropertyKey(descriptor.key), descriptor); } }\nfunction groupFactory_createClass(Constructor, protoProps, staticProps) { if (protoProps) groupFactory_defineProperties(Constructor.prototype, protoProps); if (staticProps) groupFactory_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction groupFactory_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction groupFactory_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) groupFactory_setPrototypeOf(subClass, superClass); }\nfunction groupFactory_setPrototypeOf(o, p) { groupFactory_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return groupFactory_setPrototypeOf(o, p); }\nfunction groupFactory_createSuper(Derived) { var hasNativeReflectConstruct = groupFactory_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = groupFactory_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = groupFactory_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return groupFactory_possibleConstructorReturn(this, result); }; }\nfunction groupFactory_possibleConstructorReturn(self, call) { if (call && (groupFactory_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return groupFactory_assertThisInitialized(self); }\nfunction groupFactory_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction groupFactory_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction groupFactory_getPrototypeOf(o) { groupFactory_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return groupFactory_getPrototypeOf(o); }\nfunction groupFactory_slicedToArray(arr, i) { return groupFactory_arrayWithHoles(arr) || groupFactory_iterableToArrayLimit(arr, i) || groupFactory_unsupportedIterableToArray(arr, i) || groupFactory_nonIterableRest(); }\nfunction groupFactory_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction groupFactory_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return groupFactory_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return groupFactory_arrayLikeToArray(o, minLen); }\nfunction groupFactory_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction groupFactory_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction groupFactory_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction groupFactory_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction groupFactory_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? groupFactory_ownKeys(Object(source), !0).forEach(function (key) { groupFactory_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : groupFactory_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction groupFactory_defineProperty(obj, key, value) { key = groupFactory_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction groupFactory_toPropertyKey(arg) { var key = groupFactory_toPrimitive(arg, "string"); return groupFactory_typeof(key) === "symbol" ? key : String(key); }\nfunction groupFactory_toPrimitive(input, hint) { if (groupFactory_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (groupFactory_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n\n\n\nvar GroupMixin = groupFactory_objectSpread(groupFactory_objectSpread(groupFactory_objectSpread({}, stackMixin), layoutMixin), {}, {\n  _setPadding: function _setPadding(configs) {\n    this.padding = {\n      top: configs.paddingTop || configs.padding || 0,\n      right: configs.paddingRight || configs.padding || 0,\n      bottom: configs.paddingBottom || configs.padding || 0,\n      left: configs.paddingLeft || configs.padding || 0\n    };\n  },\n  _setMargin: function _setMargin(configs) {\n    this.margin = {\n      top: configs.marginTop || configs.margin || 0,\n      right: configs.marginRight || configs.margin || 0,\n      bottom: configs.marginBottom || configs.margin || 0,\n      left: configs.marginLeft || configs.margin || 0\n    };\n  },\n  _getCenter: function _getCenter() {\n    var anchor = this.anchor;\n    var padding = this.padding;\n    var margin = this.margin;\n    var mx = (margin.left - margin.right) / 2;\n    var my = (margin.top - margin.bottom) / 2;\n    var centerX = (padding.left - padding.right) / 2 + mx;\n    var centerY = (padding.top - padding.bottom) / 2 + my;\n    this._shape.anchor = [anchor[0] + mx, anchor[1] + my];\n    this._center[0] = anchor[0] + centerX;\n    this._center[1] = anchor[1] + centerY;\n    return this._center;\n  },\n  setAnchorX: function setAnchorX(x) {\n    this.anchor[0] = x;\n    this._getCenter();\n  },\n  setAnchorY: function setAnchorY(y) {\n    this.anchor[1] = y;\n    this._getCenter();\n  },\n  setAnchor: function setAnchor(x, y) {\n    this.anchor[0] = x;\n    this.anchor[1] = y;\n    this._getCenter();\n  },\n  _calculatePointBack: function _calculatePointBack(point) {\n    var _point = groupFactory_slicedToArray(point, 2),\n      gx = _point[0],\n      gy = _point[1];\n    var _this$_getCenter = this._getCenter(),\n      _this$_getCenter2 = groupFactory_slicedToArray(_this$_getCenter, 2),\n      cx = _this$_getCenter2[0],\n      cy = _this$_getCenter2[1];\n    var p = [gx - cx, gy - cy];\n    return p;\n  },\n  _calculatePointBackWithPoint: function _calculatePointBackWithPoint(a, b, arr, idx1, idx2) {\n    var anchor = this.anchor;\n    var padding = this.padding;\n    var margin = this.margin;\n    arr[idx1] = a - (anchor[0] + (padding.left - padding.right) / 2 + (margin.left - margin.right) / 2);\n    arr[idx2] = b - (anchor[1] + (padding.top - padding.bottom) / 2 + (margin.top - margin.bottom) / 2);\n  },\n  /**\n   * 反算回 canvas 顶层坐标\n   * @param {Number[]} point\n   * @return {Number[]} 世界坐标\n   */\n  calculateToCoordination: function calculateToCoordination(point) {\n    var _point2 = groupFactory_slicedToArray(point, 2),\n      gx = _point2[0],\n      gy = _point2[1];\n    var _this$_getCenter3 = this._getCenter(),\n      _this$_getCenter4 = groupFactory_slicedToArray(_this$_getCenter3, 2),\n      cx = _this$_getCenter4[0],\n      cy = _this$_getCenter4[1];\n    // const p = [cx + anchor[0] - spanH, cy + anchor[1] - spanV];\n    var p = [gx + cx, gy + cy];\n    if (this._belongs && this._belongs.calculateToCoordination) {\n      return this._belongs.calculateToCoordination(p);\n    } else {\n      return p;\n    }\n  },\n  /**\n   * 反算回页面的像素坐标，重载 {@link Instance#calculateToRealWorld}\n   * @param {Number[]} point\n   * @return {Number[]} 世界坐标\n   */\n  calculateToRealWorld: function calculateToRealWorld(point) {\n    var _point3 = groupFactory_slicedToArray(point, 2),\n      gx = _point3[0],\n      gy = _point3[1];\n    var _this$_getCenter5 = this._getCenter(),\n      _this$_getCenter6 = groupFactory_slicedToArray(_this$_getCenter5, 2),\n      cx = _this$_getCenter6[0],\n      cy = _this$_getCenter6[1];\n    var p = [gx + cx, gy + cy];\n    if (this._belongs && this._belongs.calculateToRealWorld) {\n      return this._belongs.calculateToRealWorld(p);\n    }\n  },\n  calculateToRealWorldWithPointer: function calculateToRealWorldWithPointer(outpoint, inpoint) {\n    outpoint[0] = inpoint[0] + this._center[0];\n    outpoint[1] = inpoint[1] + this._center[1];\n    if (this._belongs && this._belongs.calculateToRealWorldWithPointer) {\n      return this._belongs.calculateToRealWorldWithPointer(outpoint, outpoint);\n    }\n  },\n  clone: function clone() {\n    var C = this.constructor;\n    var configs = Object.assign({}, this._rawConfigs, {\n      layout: this._layout && this._layout.clone()\n    });\n    var t = new C(configs);\n    this.interateNodeStack(function (instance) {\n      t.addToStack(instance.clone());\n    });\n    t.recalculate();\n    t.visible = this.visible;\n    return t;\n  },\n  getBoundingDimension: function getBoundingDimension() {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  },\n  getBoundingRect: function getBoundingRect() {\n    var anchor = this.anchor;\n    var w = this.width / 2;\n    var h = this.height / 2;\n    var ltx = anchor[0] - w;\n    var lty = anchor[1] - h;\n    var rbx = anchor[0] + w;\n    var rby = anchor[1] + h;\n    var br = this._boundingrect;\n    br[0] = ltx;\n    br[1] = lty;\n    br[2] = rbx;\n    br[3] = rby;\n    return br;\n  },\n  getIntersectionsInFourDimension: function getIntersectionsInFourDimension() {\n    var _ref;\n    var p2 = this.anchor;\n    if (this._belongs && this._belongs.calculateToCoordination) {\n      p2 = this._belongs.calculateToCoordination(p2);\n    }\n    var _p = p2,\n      _p2 = groupFactory_slicedToArray(_p, 2),\n      x2 = _p2[0],\n      y2 = _p2[1];\n    var w = this.width / 2;\n    var h = this.height / 2;\n    return _ref = {}, groupFactory_defineProperty(_ref, DIRECTION.RIGHT, [x2 + w, y2]), groupFactory_defineProperty(_ref, DIRECTION.LEFT, [x2 - w, y2]), groupFactory_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + h]), groupFactory_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - h]), groupFactory_defineProperty(_ref, DIRECTION.SELF, [x2 + w * 0.618, y2 + h * 0.618]), _ref;\n  },\n  calculateIntersection: function calculateIntersection(point) {\n    var _point4 = groupFactory_slicedToArray(point, 2),\n      x1 = _point4[0],\n      y1 = _point4[1];\n    var _this$anchor = groupFactory_slicedToArray(this.anchor, 2),\n      x2 = _this$anchor[0],\n      y2 = _this$anchor[1];\n    var w = this.width / 2;\n    var h = this.height / 2;\n    var vecx = x2 - x1;\n    var vecy = y2 - y1;\n    var theta1 = h / w;\n    var theta2 = Math.abs(vecy / vecx);\n    var dirx = x1 > x2;\n    var diry = y1 > y2;\n    var x, y;\n    if (theta2 < theta1) {\n      x = x2 + (dirx ? w : -w);\n      y = w * (diry ? theta2 : -theta2) + y2;\n    } else {\n      y = y2 + (diry ? h : -h);\n      x = h / (dirx ? theta2 : -theta2) + x2;\n    }\n    return [x, y];\n  },\n  onEnterViewbox: function onEnterViewbox() {\n    this.interateNodeStack(function (instance) {\n      instance.onEnterViewbox();\n    });\n  },\n  onLeaveViewbox: function onLeaveViewbox() {\n    this.interateNodeStack(function (instance) {\n      instance.onLeaveViewbox();\n    });\n  },\n  destroy: function destroy() {\n    this._shape.destroy();\n    this.interateNodeStack(function (instance) {\n      instance.destroy();\n    });\n  },\n  doRecalculate: function doRecalculate() {\n    if (this.__mounted__) {\n      this.recalculateUp();\n    } else {\n      this.recalculate();\n      this.__mounted__ = true;\n    }\n  }\n});\nfunction defaultShift(width, height) {\n  return [width, height];\n}\n\n/**\n * 根据paddingbox宽高来计算shapeshiftbox的宽高\n * @function shapeShift\n * @param {number} width            - paddingBox宽\n * @param {number} height           - paddingBox高\n * @return {number[]}\n */\n\n/**\n * 组工厂函数，用于通过JFlow 绘图节点来创建不同的组\n * @global \n * @function GroupFactory\n * @param {Node} jflowNodeConstructor - 绘图节点构造器\n * @param {object} options            - 配置项\n * @param {shapeShift} options.shapeShift - shift层适配方法\n * @return {Group} - 绘图节点构造器\n */\nfunction GroupFactory(jflowNodeConstructor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var shapeShift = typeof options.shapeShift === \'function\' ? options.shapeShift : defaultShift;\n\n  /**\n   * Group 配置\n   * @typedef {Object} GroupTemplate~GroupConfigs\n   * @property {number} width             - 设定宽度\n   * @property {number} minWidth          - 最小宽度\n   * @property {number} height            - 设定高度\n   * @property {number} padding          - 内边距\n   * @property {number} paddingTop          - 内上边距\n   * @property {number} paddingRight         - 内右边距\n   * @property {number} paddingBottom        - 内下边距\n   * @property {number} paddingLeft          - 内左边距\n   * @property {number} margin            - 外边距\n   * @property {number} marginTop          - 外上边距\n   * @property {number} marginRight         - 外右边距\n   * @property {number} marginBottom        - 外下边距\n   * @property {number} marginLeft          - 外左边距\n   * @property {boolean} lock            - 布局锁定状态 默认 true\n   */\n  var t = /*#__PURE__*/function (_Node) {\n    groupFactory_inherits(t, _Node);\n    var _super = groupFactory_createSuper(t);\n    /**\n    * @constructs GroupTemplate\n    * @param {GroupTemplate~GroupConfigs} configs - 组配置\n    * @mixes LayoutMixin\n    * @mixes StackMixin \n    */\n    function t(configs) {\n      var _configs$lock, _configs$transparent;\n      var _this;\n      groupFactory_classCallCheck(this, t);\n      _this = _super.call(this, configs);\n      _this.initStack(configs);\n      _this.initLayout(configs);\n      /** @member {Node}      - 壳绘图单元 */\n      _this._shape = new jflowNodeConstructor(configs);\n      _this._shape.anchor = [0, 0];\n      _this._shape._belongs = groupFactory_assertThisInitialized(_this);\n      _this._center = [0, 0];\n      _this._setPadding(configs);\n      _this._setMargin(configs);\n      /** @member {Number}      - 设定宽度 */\n      _this.definedWidth = configs.width;\n      /** @member {Number}      - 最小宽度 */\n      _this.minWidth = configs.minWidth;\n      /** @member {Number}      - 设定的高度 */\n      _this.definedHeight = configs.height;\n      /** @member {Boolean}      - 组内元素是否锁定， 默认true */\n      _this.lock = (_configs$lock = configs.lock) !== null && _configs$lock !== void 0 ? _configs$lock : true;\n      _this.display = configs.display || \'default\';\n      /** @member {Boolean}      - 组本身是否进入形状判定范围 */\n      _this.transparent = (_configs$transparent = configs.transparent) !== null && _configs$transparent !== void 0 ? _configs$transparent : false;\n      _this._getBoundingGroupRect();\n      _this.reflow();\n      _this._getBoundingGroupRect();\n      _this._cacheViewBox = [];\n      return _this;\n    }\n    return groupFactory_createClass(t);\n  }(node);\n  Object.assign(t.prototype, GroupMixin);\n  Object.assign(t.prototype, {\n    reflow: function reflow() {\n      GroupMixin.reflow.call(this);\n      var margin = this.margin;\n      var _shapeShift = shapeShift(this.width - margin.left - margin.right, this.height - margin.top - margin.bottom, this._shape),\n        _shapeShift2 = groupFactory_slicedToArray(_shapeShift, 2),\n        shapeWidth = _shapeShift2[0],\n        shapeHeight = _shapeShift2[1];\n      this._shape.width = shapeWidth;\n      this._shape.height = shapeHeight;\n    },\n    setConfig: function setConfig(configs) {\n      this._shape.setConfig(configs);\n      this._setPadding(configs);\n      this._setMargin(configs);\n      if (\'opacity\' in configs) {\n        this.opacity = configs.opacity;\n      }\n      if (configs.layout && this._layout !== configs.layout) {\n        this._layout = configs.layout;\n      }\n    },\n    _getBoundingGroupRect: function _getBoundingGroupRect() {\n      var points = this._stack.getBoundingRectPoints();\n      // content box \n      var bbox = bounding_box(points);\n\n      // padding box \n      var padding = this.padding;\n      var minWidth = this.minWidth; // - padding.left - padding.right;\n      var definedWidth = this.definedWidth; // - padding.left - padding.right;\n      var w = bbox.width + padding.left + padding.right;\n      var h = bbox.height + padding.top + padding.bottom;\n      var paddingWidth = minWidth ? Math.max(minWidth, w) : definedWidth || w;\n      var paddingHeight = this.definedHeight || h;\n      this._paddingWidth = paddingWidth;\n      this._paddingHeight = paddingHeight;\n\n      // shapeBox\n      var _shapeShift3 = shapeShift(paddingWidth, paddingHeight, this._shape),\n        _shapeShift4 = groupFactory_slicedToArray(_shapeShift3, 2),\n        shapeWidth = _shapeShift4[0],\n        shapeHeight = _shapeShift4[1];\n      this._shape.width = shapeWidth;\n      this._shape.height = shapeHeight;\n      // marginBox\n      var margin = this.margin;\n      this.width = shapeWidth + margin.left + margin.right;\n      this.height = shapeHeight + margin.top + margin.bottom;\n    },\n    _getViewBox: function _getViewBox() {\n      var belongs_vbox = this._belongs.getCacheViewBox();\n      var cacheViewBox = this._cacheViewBox;\n      this._calculatePointBackWithPoint(belongs_vbox[0], belongs_vbox[1], cacheViewBox, 0, 1);\n      this._calculatePointBackWithPoint(belongs_vbox[2], belongs_vbox[3], cacheViewBox, 2, 3);\n      return this._cacheViewBox;\n    },\n    getCacheViewBox: function getCacheViewBox() {\n      return this._cacheViewBox;\n    },\n    render: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      } else if (this.opacity !== 1) {\n        ctx.globalAlpha = this.opacity;\n      }\n      var _this$_getCenter7 = this._getCenter(),\n        _this$_getCenter8 = groupFactory_slicedToArray(_this$_getCenter7, 2),\n        cx = _this$_getCenter8[0],\n        cy = _this$_getCenter8[1];\n      this._shape.render(ctx);\n      ctx.translate(cx, cy);\n      this._stack.render(ctx);\n      // this._linkStack.render(ctx);    \n      ctx.translate(-cx, -cy);\n      ctx.restore();\n\n      // ctx.save();\n      // ctx.beginPath();\n      // ctx.arc(cx, cy, 5, 0, Math.PI*2);\n      // ctx.fillStyle = \'rgb(0,0,0)\'\n      // ctx.fill();\n      // ctx.restore();\n    },\n    isHit: function isHit(point, condition) {\n      var p = this._calculatePointBack(point);\n      this._currentp = p; // 暂存，为了后续计算别的位置\n      var target = this._stack.checkHit(p, condition);\n      if (target) return target;\n      if (!this.transparent) {\n        return this._shape.isHit(point);\n      }\n      return false;\n    }\n  });\n  return t;\n}\n/* harmony default export */ const groupFactory = (GroupFactory);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/point.js\nfunction point_typeof(obj) { "@babel/helpers - typeof"; return point_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, point_typeof(obj); }\nfunction point_defineProperty(obj, key, value) { key = point_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction point_slicedToArray(arr, i) { return point_arrayWithHoles(arr) || point_iterableToArrayLimit(arr, i) || point_unsupportedIterableToArray(arr, i) || point_nonIterableRest(); }\nfunction point_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction point_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return point_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return point_arrayLikeToArray(o, minLen); }\nfunction point_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction point_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction point_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction point_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction point_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, point_toPropertyKey(descriptor.key), descriptor); } }\nfunction point_createClass(Constructor, protoProps, staticProps) { if (protoProps) point_defineProperties(Constructor.prototype, protoProps); if (staticProps) point_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction point_toPropertyKey(arg) { var key = point_toPrimitive(arg, "string"); return point_typeof(key) === "symbol" ? key : String(key); }\nfunction point_toPrimitive(input, hint) { if (point_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (point_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction point_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) point_setPrototypeOf(subClass, superClass); }\nfunction point_setPrototypeOf(o, p) { point_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return point_setPrototypeOf(o, p); }\nfunction point_createSuper(Derived) { var hasNativeReflectConstruct = point_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = point_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = point_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return point_possibleConstructorReturn(this, result); }; }\nfunction point_possibleConstructorReturn(self, call) { if (call && (point_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return point_assertThisInitialized(self); }\nfunction point_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction point_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction point_getPrototypeOf(o) { point_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return point_getPrototypeOf(o); }\n\n\n/**\n * 圆形单元 配置\n * @typedef {Node~Configs} Point~PointConfigs\n * @property {number} radius  - 半径\n */\n/**\n * 圆形节点\n * @constructor Point\n * @extends Node\n * @param {Point~PointConfigs} configs - 配置\n */\nvar Point = /*#__PURE__*/function (_Node) {\n  point_inherits(Point, _Node);\n  var _super = point_createSuper(Point);\n  function Point(configs) {\n    var _this;\n    point_classCallCheck(this, Point);\n    _this = _super.call(this, configs);\n    _this.type = \'Point\';\n    /** @member {Number}      - 半径 */\n    _this.radius = configs.radius || 10;\n    _this._doCache();\n    return _this;\n  }\n  point_createClass(Point, [{\n    key: "setConfig",\n    value: function setConfig(configs) {\n      var _this2 = this;\n      Object.keys(configs).forEach(function (k) {\n        if (configs[k] !== undefined && configs[k] !== null) {\n          _this2[k] = configs[k];\n          _this2._rawConfigs[k] = configs[k];\n        }\n      });\n      this._doCache();\n    }\n  }, {\n    key: "_doCache",\n    value: function _doCache() {\n      this.width = this.radius * 2;\n      this.height = this.radius * 2;\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      ctx.beginPath();\n      ctx.arc(this.anchor[0], this.anchor[1], this.radius, 0, 2 * Math.PI);\n      ctx.fillStyle = this.backgroundColor;\n      ctx.fill();\n      if (this.borderWidth) {\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeStyle = this.borderColor;\n        ctx.stroke();\n      }\n      // if(this._isTargeting) {\n      //     this.renderFocus(ctx);\n      // }\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      var anchor = this.anchor;\n      return Math.pow(point[0] - anchor[0], 2) + Math.pow(point[1] - anchor[1], 2) < this.radius * this.radius;\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var r = this.radius;\n      var ltx = anchor[0] - r;\n      var lty = anchor[1] - r;\n      var rbx = anchor[0] + r;\n      var rby = anchor[1] + r;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }, {\n    key: "calculateIntersection",\n    value: function calculateIntersection(point) {\n      var _point = point_slicedToArray(point, 2),\n        x1 = _point[0],\n        y1 = _point[1];\n      var _this$anchor = point_slicedToArray(this.anchor, 2),\n        x2 = _this$anchor[0],\n        y2 = _this$anchor[1];\n      var vecx = x2 - x1;\n      var vecy = y2 - y1;\n      var dist = Math.sqrt(vecx * vecx + vecy * vecy);\n      var ratio = this.radius / dist;\n      return [x2 - ratio * vecx, y2 - ratio * vecy];\n    }\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      var _ref;\n      var _this$anchor2 = point_slicedToArray(this.anchor, 2),\n        x2 = _this$anchor2[0],\n        y2 = _this$anchor2[1];\n      var r = this.radius;\n      return _ref = {}, point_defineProperty(_ref, DIRECTION.RIGHT, [x2 + r, y2]), point_defineProperty(_ref, DIRECTION.LEFT, [x2 - r, y2]), point_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + r]), point_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - r]), _ref;\n    }\n  }, {\n    key: "calculateIntersectionInFourDimension",\n    value: function calculateIntersectionInFourDimension(point, end) {\n      var _allIntersections;\n      var _point2 = point_slicedToArray(point, 2),\n        x1 = _point2[0],\n        y1 = _point2[1];\n      var _this$anchor3 = point_slicedToArray(this.anchor, 2),\n        x2 = _this$anchor3[0],\n        y2 = _this$anchor3[1];\n      var r = this.radius;\n      var vecx = x2 - x1;\n      var vecy = y2 - y1;\n      var allIntersections = (_allIntersections = {}, point_defineProperty(_allIntersections, DIRECTION.RIGHT, [x2 + r, y2]), point_defineProperty(_allIntersections, DIRECTION.LEFT, [x2 - r, y2]), point_defineProperty(_allIntersections, DIRECTION.BOTTOM, [x2, y2 + r]), point_defineProperty(_allIntersections, DIRECTION.TOP, [x2, y2 - r]), _allIntersections);\n      // console.log(Math.abs(vecx) > Math.abs(vecy), vecx, r)\n      // if() {\n      //     return {\n      //         p: [x2 + (vecx<0?r:-r), y2],\n      //         dir: vecx<0 ? DIRECTION.RIGHT : DIRECTION.LEFT,\n      //     }\n      // } else {\n      //     return {\n      //         p: [x2, y2+(vecy<0?r:-r)],\n      //         dir: vecy<0 ? DIRECTION.BOTTOM : DIRECTION.TOP,\n      //     }\n      // }\n      var interDir = Math.abs(vecy) > Math.abs(vecx) ? vecy < 0 ? DIRECTION.BOTTOM : DIRECTION.TOP : vecx < 0 ? DIRECTION.RIGHT : DIRECTION.LEFT;\n\n      // interDir = this.checkLinked(interDir, end);\n      return {\n        p: allIntersections[interDir],\n        dir: interDir\n      };\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        width: this.width,\n        height: this.height\n      };\n    }\n  }]);\n  return Point;\n}(node);\n/* harmony default export */ const point = (Point);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/rectangle.js\nfunction rectangle_typeof(obj) { "@babel/helpers - typeof"; return rectangle_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, rectangle_typeof(obj); }\nfunction rectangle_defineProperty(obj, key, value) { key = rectangle_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction rectangle_slicedToArray(arr, i) { return rectangle_arrayWithHoles(arr) || rectangle_iterableToArrayLimit(arr, i) || rectangle_unsupportedIterableToArray(arr, i) || rectangle_nonIterableRest(); }\nfunction rectangle_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction rectangle_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return rectangle_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return rectangle_arrayLikeToArray(o, minLen); }\nfunction rectangle_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction rectangle_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction rectangle_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction rectangle_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction rectangle_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, rectangle_toPropertyKey(descriptor.key), descriptor); } }\nfunction rectangle_createClass(Constructor, protoProps, staticProps) { if (protoProps) rectangle_defineProperties(Constructor.prototype, protoProps); if (staticProps) rectangle_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction rectangle_toPropertyKey(arg) { var key = rectangle_toPrimitive(arg, "string"); return rectangle_typeof(key) === "symbol" ? key : String(key); }\nfunction rectangle_toPrimitive(input, hint) { if (rectangle_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (rectangle_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction rectangle_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) rectangle_setPrototypeOf(subClass, superClass); }\nfunction rectangle_setPrototypeOf(o, p) { rectangle_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rectangle_setPrototypeOf(o, p); }\nfunction rectangle_createSuper(Derived) { var hasNativeReflectConstruct = rectangle_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rectangle_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rectangle_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rectangle_possibleConstructorReturn(this, result); }; }\nfunction rectangle_possibleConstructorReturn(self, call) { if (call && (rectangle_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return rectangle_assertThisInitialized(self); }\nfunction rectangle_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction rectangle_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction rectangle_getPrototypeOf(o) { rectangle_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rectangle_getPrototypeOf(o); }\n\n\n/**\n * @typedef Rectangle~border\n * @type {object}\n * @property {number} borderColor      - 边框宽度, 默认 0\n * @property {number} borderWidth      - 边框颜色, 默认 transparent\n */\n/**\n * @typedef Rectangle~borders\n * @type {object}\n * @property {Rectangle~border} top      - 上边框\n * @property {Rectangle~border} right      - 右边框\n * @property {Rectangle~border} bottom      - 下边框\n * @property {Rectangle~border} left      - 左边框\n */\n\n/**\n * 矩形单元 配置\n * @typedef {Node~Configs} Rectangle~RectangleConfigs\n * @property {number} width - 宽\n * @property {number} height - 高\n * @property {number} borderRadius - 圆角矩形半径\n * @property {string} borderColor - 边框颜色, 默认 transparent\n * @property {string} borderWidth - 边框宽度, 默认 0\n * @property {Rectangle~borders} border      - 边框设置\n */\n/**\n * 矩形单元\n * @constructor Rectangle\n * @extends Node\n * @param {Rectangle~RectangleConfigs} configs\n */\nvar Rectangle = /*#__PURE__*/function (_Node) {\n  rectangle_inherits(Rectangle, _Node);\n  var _super = rectangle_createSuper(Rectangle);\n  function Rectangle() {\n    var _this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    rectangle_classCallCheck(this, Rectangle);\n    _this = _super.call(this, configs);\n    _this.type = \'Rectangle\';\n    /** @member {Number}      - 宽 */\n    _this.width = configs.width || 10;\n    /** @member {Number}      - 高 */\n    _this.height = configs.height || 10;\n    /** @member {Number}      - 圆角矩形半径 */\n    _this.borderRadius = configs.borderRadius || 0;\n    _this._setBorder(configs);\n    return _this;\n  }\n  rectangle_createClass(Rectangle, [{\n    key: "_setBorder",\n    value: function _setBorder(configs) {\n      var _configs$border, _configs$border2, _configs$border3, _configs$border4, _configs$border5, _configs$border6, _configs$border7, _configs$border8, _configs$border9, _configs$border10, _configs$border11, _configs$border12;\n      /** @member {Rectangle~borders}      - 边框设置，优先级高于 borderWidth，borderColor */\n      this.border = {\n        top: {\n          color: ((_configs$border = configs.border) === null || _configs$border === void 0 || (_configs$border = _configs$border.top) === null || _configs$border === void 0 ? void 0 : _configs$border.borderColor) || configs.borderColor || \'transparent\',\n          width: ((_configs$border2 = configs.border) === null || _configs$border2 === void 0 || (_configs$border2 = _configs$border2.top) === null || _configs$border2 === void 0 ? void 0 : _configs$border2.borderWidth) || configs.borderWidth || 0,\n          enable: (_configs$border3 = configs.border) === null || _configs$border3 === void 0 || (_configs$border3 = _configs$border3.top) === null || _configs$border3 === void 0 ? void 0 : _configs$border3.borderWidth\n        },\n        right: {\n          color: ((_configs$border4 = configs.border) === null || _configs$border4 === void 0 || (_configs$border4 = _configs$border4.right) === null || _configs$border4 === void 0 ? void 0 : _configs$border4.borderColor) || configs.borderColor || \'transparent\',\n          width: ((_configs$border5 = configs.border) === null || _configs$border5 === void 0 || (_configs$border5 = _configs$border5.right) === null || _configs$border5 === void 0 ? void 0 : _configs$border5.borderWidth) || configs.borderWidth || 0,\n          enable: (_configs$border6 = configs.border) === null || _configs$border6 === void 0 || (_configs$border6 = _configs$border6.right) === null || _configs$border6 === void 0 ? void 0 : _configs$border6.borderWidth\n        },\n        bottom: {\n          color: ((_configs$border7 = configs.border) === null || _configs$border7 === void 0 || (_configs$border7 = _configs$border7.bottom) === null || _configs$border7 === void 0 ? void 0 : _configs$border7.borderColor) || configs.borderColor || \'transparent\',\n          width: ((_configs$border8 = configs.border) === null || _configs$border8 === void 0 || (_configs$border8 = _configs$border8.bottom) === null || _configs$border8 === void 0 ? void 0 : _configs$border8.borderWidth) || configs.borderWidth || 0,\n          enable: (_configs$border9 = configs.border) === null || _configs$border9 === void 0 || (_configs$border9 = _configs$border9.bottom) === null || _configs$border9 === void 0 ? void 0 : _configs$border9.borderWidth\n        },\n        left: {\n          color: ((_configs$border10 = configs.border) === null || _configs$border10 === void 0 || (_configs$border10 = _configs$border10.left) === null || _configs$border10 === void 0 ? void 0 : _configs$border10.borderColor) || configs.borderColor || \'transparent\',\n          width: ((_configs$border11 = configs.border) === null || _configs$border11 === void 0 || (_configs$border11 = _configs$border11.left) === null || _configs$border11 === void 0 ? void 0 : _configs$border11.borderWidth) || configs.borderWidth || 0,\n          enable: (_configs$border12 = configs.border) === null || _configs$border12 === void 0 || (_configs$border12 = _configs$border12.left) === null || _configs$border12 === void 0 ? void 0 : _configs$border12.borderWidth\n        }\n      };\n      this.borderColor = configs.borderColor || \'transparent\';\n      this.borderWidth = configs.borderWidth || 0;\n    }\n  }, {\n    key: "setConfig",\n    value: function setConfig(configs) {\n      var _this2 = this;\n      Object.keys(configs).forEach(function (k) {\n        if (configs[k] !== undefined && configs[k] !== null) {\n          _this2[k] = configs[k];\n          _this2._rawConfigs[k] = configs[k];\n        }\n      });\n      this._setBorder(configs);\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      var radius = this.borderRadius,\n        anchor = this.anchor,\n        width = this.width,\n        height = this.height;\n      var x = this.anchor[0] - this.width / 2;\n      var y = this.anchor[1] - this.height / 2;\n      var xt = this.anchor[0] + this.width / 2;\n      var yt = this.anchor[1] + this.height / 2;\n      if (this.borderRadius) {\n        ctx.beginPath();\n        ctx.moveTo(x + radius, y);\n        ctx.lineTo(x + width - radius, y);\n        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n        ctx.lineTo(x + width, y + height - radius);\n        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n        ctx.lineTo(x + radius, y + height);\n        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n        ctx.lineTo(x, y + radius);\n        ctx.quadraticCurveTo(x, y, x + radius, y);\n        ctx.closePath();\n      } else {\n        ctx.beginPath();\n        ctx.rect(this.anchor[0] - this.width / 2, this.anchor[1] - this.height / 2, this.width, this.height);\n      }\n      if (this.borderWidth) {\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeStyle = this.borderColor;\n      }\n      if (this.shadowColor && this.shadowColor !== \'transparent\') {\n        ctx.shadowColor = this.shadowColor;\n        var scale = this._jflow.scale;\n        ctx.shadowBlur = this.shadowBlur * scale;\n        ctx.shadowOffsetX = this.shadowOffsetX * scale;\n        ctx.shadowOffsetY = this.shadowOffsetY * scale;\n        var switchPath = new Path2D();\n        if (this.borderRadius) {\n          switchPath.moveTo(x + radius, y);\n          switchPath.lineTo(x + width - radius, y);\n          switchPath.quadraticCurveTo(x + width, y, x + width, y + radius);\n          switchPath.lineTo(x + width, y + height - radius);\n          switchPath.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n          switchPath.lineTo(x + radius, y + height);\n          switchPath.quadraticCurveTo(x, y + height, x, y + height - radius);\n          switchPath.lineTo(x, y + radius);\n          switchPath.quadraticCurveTo(x, y, x + radius, y);\n          switchPath.closePath();\n        } else {\n          switchPath.rect(this.anchor[0] - this.width / 2, this.anchor[1] - this.height / 2, this.width, this.height);\n        }\n        switchPath.rect(x - 10, y - 10, this.width + 20, this.height + 20);\n        ctx.save();\n        ctx.clip(switchPath, "evenodd");\n        ctx.stroke();\n        ctx.restore();\n      }\n      ctx.fillStyle = this.backgroundColor;\n      ctx.fill();\n      if (this.borderRadius && this.borderWidth) {\n        ctx.shadowColor = \'transparent\';\n        ctx.stroke();\n      }\n      if (this.borderRadius) {\n        if (this.border.top.enable) {\n          var ty = y - this.border.top.width / 2;\n          // console.log(this.border.top.width)\n          ctx.beginPath();\n          var topPath = new Path2D();\n          topPath.moveTo(x, ty + radius);\n          topPath.quadraticCurveTo(x, ty, x + radius, ty);\n          topPath.lineTo(x + width - radius, ty);\n          topPath.quadraticCurveTo(x + width, ty, x + width, ty + radius);\n          topPath.closePath();\n          ctx.clip(topPath);\n          ctx.save();\n          ctx.shadowColor = \'transparent\';\n          ctx.fillStyle = this.border.top.color;\n          ctx.rect(x, ty, this.width, this.border.top.width);\n          ctx.fill();\n          ctx.restore();\n\n          // ctx.stroke();\n          // ctx.save();\n          // ctx.beginPath();\n          // ctx.moveTo(x, ty + radius);\n          // ctx.quadraticCurveTo(x, ty, x + radius, ty);\n          // ctx.lineTo(x + width - radius, ty);\n          // ctx.quadraticCurveTo(x + width, ty, x + width, ty + radius);\n          // ctx.closePath();\n\n          // // ctx.fill();\n          // ctx.clip();\n\n          // ctx.beginPath();\n          // ctx.rect(x, ty, this.width, this.border.top.width);\n          // ctx.fillStyle = this.border.top.color;\n          // ctx.shadowColor = \'transparent\';\n          // ctx.fill();\n          // ctx.restore();\n        }\n      } else {\n        if (this.border.top.width) {\n          ctx.beginPath();\n          ctx.moveTo(x, y);\n          ctx.lineTo(xt, y);\n          ctx.strokeStyle = this.border.top.color;\n          ctx.lineWidth = this.border.top.width;\n          ctx.stroke();\n        }\n        if (this.border.right.width) {\n          ctx.beginPath();\n          ctx.moveTo(xt, y);\n          ctx.lineTo(xt, yt);\n          ctx.strokeStyle = this.border.right.color;\n          ctx.lineWidth = this.border.right.width;\n          ctx.stroke();\n        }\n        if (this.border.bottom.width) {\n          ctx.beginPath();\n          ctx.moveTo(xt, yt);\n          ctx.lineTo(x, yt);\n          ctx.strokeStyle = this.border.bottom.color;\n          ctx.lineWidth = this.border.bottom.width;\n          ctx.stroke();\n        }\n        if (this.border.left.width) {\n          ctx.beginPath();\n          ctx.moveTo(x, yt);\n          ctx.lineTo(x, y);\n          ctx.strokeStyle = this.border.left.color;\n          ctx.lineWidth = this.border.left.width;\n          ctx.stroke();\n        }\n      }\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      return point[0] > anchor[0] - w && point[0] < anchor[0] + w && point[1] > anchor[1] - h && point[1] < anchor[1] + h;\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var ltx = anchor[0] - w;\n      var lty = anchor[1] - h;\n      var rbx = anchor[0] + w;\n      var rby = anchor[1] + h;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        height: this.height,\n        width: this.width\n      };\n    }\n  }, {\n    key: "calculateIntersection",\n    value: function calculateIntersection(point) {\n      var _point = rectangle_slicedToArray(point, 2),\n        x1 = _point[0],\n        y1 = _point[1];\n      var _this$anchor = rectangle_slicedToArray(this.anchor, 2),\n        x2 = _this$anchor[0],\n        y2 = _this$anchor[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var vecx = x2 - x1;\n      var vecy = y2 - y1;\n      var theta1 = h / w;\n      var theta2 = Math.abs(vecy / vecx);\n      var dirx = x1 > x2;\n      var diry = y1 > y2;\n      var x, y;\n      if (theta2 < theta1) {\n        x = x2 + (dirx ? w : -w);\n        y = w * (diry ? theta2 : -theta2) + y2;\n      } else {\n        y = y2 + (diry ? h : -h);\n        x = h / (dirx ? theta2 : -theta2) + x2;\n      }\n      return [x, y];\n    }\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      var _ref;\n      var p2 = this.anchor;\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        p2 = this._belongs.calculateToCoordination(p2);\n      }\n      var _p = p2,\n        _p2 = rectangle_slicedToArray(_p, 2),\n        x2 = _p2[0],\n        y2 = _p2[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      return _ref = {}, rectangle_defineProperty(_ref, DIRECTION.RIGHT, [x2 + w, y2]), rectangle_defineProperty(_ref, DIRECTION.LEFT, [x2 - w, y2]), rectangle_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + h]), rectangle_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - h]), _ref;\n    }\n  }, {\n    key: "calculateIntersectionInFourDimension",\n    value: function calculateIntersectionInFourDimension(point, end) {\n      var _allIntersections;\n      var _point2 = rectangle_slicedToArray(point, 2),\n        x1 = _point2[0],\n        y1 = _point2[1];\n      var p2 = this.anchor;\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        p2 = this._belongs.calculateToCoordination(p2);\n      }\n      var _p3 = p2,\n        _p4 = rectangle_slicedToArray(_p3, 2),\n        x2 = _p4[0],\n        y2 = _p4[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var allIntersections = (_allIntersections = {}, rectangle_defineProperty(_allIntersections, DIRECTION.RIGHT, [x2 + w, y2]), rectangle_defineProperty(_allIntersections, DIRECTION.LEFT, [x2 - w, y2]), rectangle_defineProperty(_allIntersections, DIRECTION.BOTTOM, [x2, y2 + h]), rectangle_defineProperty(_allIntersections, DIRECTION.TOP, [x2, y2 - h]), _allIntersections);\n      var vecx = x2 - x1;\n      var vecy = y2 - y1;\n      var theta1 = h / w;\n      var theta2 = Math.abs(vecy / vecx);\n      var dirx = x1 > x2;\n      var diry = y1 > y2;\n      var interDir = theta2 > theta1 ? diry ? DIRECTION.BOTTOM : DIRECTION.TOP : dirx ? DIRECTION.RIGHT : DIRECTION.LEFT;\n\n      // if(this._belongs && this._belongs.calculateToCoordination) {\n      //     console.log(JSON.stringify(this._intersections));\n      //     console.log(interDir)\n      // }\n      // interDir = this.checkLinked(interDir, end);\n      // if(this._belongs && this._belongs.calculateToCoordination) {\n      //     console.log(interDir)\n      // }\n\n      // if(!interDir) {\n      //     debugger\n      // }\n      // let endDir = interDir;\n      // if(end === \'to\') {\n      //     endDir = oppositeDirection(endDir)\n      // }\n      return {\n        p: allIntersections[interDir],\n        dir: interDir\n      };\n    }\n  }]);\n  return Rectangle;\n}(node);\n/* harmony default export */ const rectangle = (Rectangle);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/capsule.js\nfunction capsule_typeof(obj) { "@babel/helpers - typeof"; return capsule_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, capsule_typeof(obj); }\nfunction capsule_defineProperty(obj, key, value) { key = capsule_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction capsule_slicedToArray(arr, i) { return capsule_arrayWithHoles(arr) || capsule_iterableToArrayLimit(arr, i) || capsule_unsupportedIterableToArray(arr, i) || capsule_nonIterableRest(); }\nfunction capsule_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction capsule_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return capsule_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return capsule_arrayLikeToArray(o, minLen); }\nfunction capsule_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction capsule_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction capsule_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction capsule_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction capsule_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, capsule_toPropertyKey(descriptor.key), descriptor); } }\nfunction capsule_createClass(Constructor, protoProps, staticProps) { if (protoProps) capsule_defineProperties(Constructor.prototype, protoProps); if (staticProps) capsule_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction capsule_toPropertyKey(arg) { var key = capsule_toPrimitive(arg, "string"); return capsule_typeof(key) === "symbol" ? key : String(key); }\nfunction capsule_toPrimitive(input, hint) { if (capsule_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (capsule_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction capsule_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) capsule_setPrototypeOf(subClass, superClass); }\nfunction capsule_setPrototypeOf(o, p) { capsule_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return capsule_setPrototypeOf(o, p); }\nfunction capsule_createSuper(Derived) { var hasNativeReflectConstruct = capsule_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = capsule_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = capsule_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return capsule_possibleConstructorReturn(this, result); }; }\nfunction capsule_possibleConstructorReturn(self, call) { if (call && (capsule_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return capsule_assertThisInitialized(self); }\nfunction capsule_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction capsule_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction capsule_getPrototypeOf(o) { capsule_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return capsule_getPrototypeOf(o); }\n\n\n/**\n * 胶囊单元 配置\n * @typedef {Node~Configs} Capsule~CapsuleConfigs\n * @property {number} width  - 内部矩形宽\n * @property {number} height - 内部矩形高\n */\n/**\n * 胶囊单元\n * @constructor Capsule\n * @extends Node\n * @param {Capsule~CapsuleConfigs} configs - 配置\n */\nvar Capsule = /*#__PURE__*/function (_Node) {\n  capsule_inherits(Capsule, _Node);\n  var _super = capsule_createSuper(Capsule);\n  function Capsule() {\n    var _this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    capsule_classCallCheck(this, Capsule);\n    _this = _super.call(this, configs);\n    _this.type = \'Capsule\';\n    /** @member {Number}      - 内部矩形宽 */\n    _this.width = configs.width || 20;\n    /** @member {Number}      - 内部矩形高 */\n    _this.height = configs.height || 10;\n    return _this;\n  }\n  capsule_createClass(Capsule, [{\n    key: "render",\n    value: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      ctx.beginPath();\n      var _this$anchor = capsule_slicedToArray(this.anchor, 2),\n        x = _this$anchor[0],\n        y = _this$anchor[1];\n      var hw = this.width / 2;\n      var hh = this.height / 2;\n      var leftCenter = x - hw + hh;\n      var rightCenter = x + hw - hh;\n      var top = y - hh;\n      var bottom = y + hh;\n      ctx.moveTo(leftCenter, top);\n      ctx.lineTo(rightCenter, top);\n      ctx.arc(rightCenter, y, hh, -Math.PI / 2, Math.PI / 2);\n      ctx.lineTo(leftCenter, bottom);\n      ctx.arc(leftCenter, y, hh, Math.PI / 2, Math.PI / 2 * 3);\n      ctx.fillStyle = this.backgroundColor;\n      if (this.shadowColor) {\n        ctx.shadowColor = this.shadowColor;\n        ctx.shadowBlur = this.shadowBlur;\n        ctx.shadowOffsetX = this.shadowOffsetX;\n        ctx.shadowOffsetY = this.shadowOffsetY;\n      }\n      ctx.fill();\n      if (this.borderWidth) {\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeStyle = this.borderColor;\n        ctx.stroke();\n      }\n      // ctx.fillStyle = \'rgba(0,0,0,0.3)\';\n      // ctx.fillRect(x-hw, y-hh, this.width, this.height)\n\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      var anchor = this.anchor;\n      var hw = this.width / 2;\n      var hh = this.height / 2;\n      var ww = Math.abs(hw - hh);\n      var leftCenter = anchor[0] - hw + hh;\n      var rightCenter = anchor[0] + hw - hh;\n      var rr = hh * hh;\n      return point[0] > anchor[0] - ww && point[0] < anchor[0] + ww && point[1] > anchor[1] - hh && point[1] < anchor[1] + hh || Math.pow(point[0] - leftCenter, 2) + Math.pow(point[1] - anchor[1], 2) < rr || Math.pow(point[0] - rightCenter, 2) + Math.pow(point[1] - anchor[1], 2) < rr;\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var ltx = anchor[0] - w;\n      var lty = anchor[1] - h;\n      var rbx = anchor[0] + w;\n      var rby = anchor[1] + h;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        height: this.height,\n        width: this.width\n      };\n    }\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      var _ref;\n      var p2 = this.anchor;\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        p2 = this._belongs.calculateToCoordination(p2);\n      }\n      var _p = p2,\n        _p2 = capsule_slicedToArray(_p, 2),\n        x2 = _p2[0],\n        y2 = _p2[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      return _ref = {}, capsule_defineProperty(_ref, DIRECTION.RIGHT, [x2 + w, y2]), capsule_defineProperty(_ref, DIRECTION.LEFT, [x2 - w, y2]), capsule_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + h]), capsule_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - h]), _ref;\n    }\n  }]);\n  return Capsule;\n}(node);\n/* harmony default export */ const capsule = (Capsule);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/capsule-vertical.js\nfunction capsule_vertical_typeof(obj) { "@babel/helpers - typeof"; return capsule_vertical_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, capsule_vertical_typeof(obj); }\nfunction capsule_vertical_slicedToArray(arr, i) { return capsule_vertical_arrayWithHoles(arr) || capsule_vertical_iterableToArrayLimit(arr, i) || capsule_vertical_unsupportedIterableToArray(arr, i) || capsule_vertical_nonIterableRest(); }\nfunction capsule_vertical_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction capsule_vertical_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return capsule_vertical_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return capsule_vertical_arrayLikeToArray(o, minLen); }\nfunction capsule_vertical_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction capsule_vertical_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction capsule_vertical_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction capsule_vertical_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction capsule_vertical_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, capsule_vertical_toPropertyKey(descriptor.key), descriptor); } }\nfunction capsule_vertical_createClass(Constructor, protoProps, staticProps) { if (protoProps) capsule_vertical_defineProperties(Constructor.prototype, protoProps); if (staticProps) capsule_vertical_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction capsule_vertical_toPropertyKey(arg) { var key = capsule_vertical_toPrimitive(arg, "string"); return capsule_vertical_typeof(key) === "symbol" ? key : String(key); }\nfunction capsule_vertical_toPrimitive(input, hint) { if (capsule_vertical_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (capsule_vertical_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction capsule_vertical_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) capsule_vertical_setPrototypeOf(subClass, superClass); }\nfunction capsule_vertical_setPrototypeOf(o, p) { capsule_vertical_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return capsule_vertical_setPrototypeOf(o, p); }\nfunction capsule_vertical_createSuper(Derived) { var hasNativeReflectConstruct = capsule_vertical_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = capsule_vertical_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = capsule_vertical_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return capsule_vertical_possibleConstructorReturn(this, result); }; }\nfunction capsule_vertical_possibleConstructorReturn(self, call) { if (call && (capsule_vertical_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return capsule_vertical_assertThisInitialized(self); }\nfunction capsule_vertical_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction capsule_vertical_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction capsule_vertical_getPrototypeOf(o) { capsule_vertical_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return capsule_vertical_getPrototypeOf(o); }\n\n/**\n * 垂直胶囊单元\n * @constructor CapsuleVertical\n * @extends Capsule\n * @param {Capsule~CapsuleConfigs} configs - 配置\n */\nvar CapsuleVertical = /*#__PURE__*/function (_Capsule) {\n  capsule_vertical_inherits(CapsuleVertical, _Capsule);\n  var _super = capsule_vertical_createSuper(CapsuleVertical);\n  function CapsuleVertical() {\n    capsule_vertical_classCallCheck(this, CapsuleVertical);\n    return _super.apply(this, arguments);\n  }\n  capsule_vertical_createClass(CapsuleVertical, [{\n    key: "render",\n    value: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      ctx.beginPath();\n      var _this$anchor = capsule_vertical_slicedToArray(this.anchor, 2),\n        x = _this$anchor[0],\n        y = _this$anchor[1];\n      var hw = this.width / 2;\n      var hh = this.height / 2;\n      var topCenter = y - hh + hw;\n      var bottomCenter = y + hh - hw;\n      var left = x - hw;\n      var right = x + hw;\n      ctx.moveTo(left, topCenter);\n      ctx.arc(x, topCenter, hw, -Math.PI, 0);\n      ctx.lineTo(right, bottomCenter);\n      ctx.arc(x, bottomCenter, hw, 0, Math.PI);\n      ctx.closePath();\n      ctx.fillStyle = this.backgroundColor;\n      if (this.shadowColor) {\n        ctx.shadowColor = this.shadowColor;\n        ctx.shadowBlur = this.shadowBlur;\n        ctx.shadowOffsetX = this.shadowOffsetX;\n        ctx.shadowOffsetY = this.shadowOffsetY;\n      }\n      ctx.fill();\n      if (this.borderWidth) {\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeStyle = this.borderColor;\n        ctx.stroke();\n      }\n      // ctx.fillStyle = \'rgba(0,0,0,0.3)\';\n      // ctx.fillRect(x-hw, y-hh, this.width, this.height)\n\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point, condition) {\n      var _this$anchor2 = capsule_vertical_slicedToArray(this.anchor, 2),\n        x = _this$anchor2[0],\n        y = _this$anchor2[1];\n      var hw = this.width / 2;\n      var hh = this.height / 2;\n      var yy = Math.abs(hh - hw);\n      var topCenter = y - hh + hw;\n      var bottomCenter = y + hh - hw;\n      var rr = hw * hw;\n      return point[0] > x - hw && point[0] < x + hw && point[1] > y - yy && point[1] < y + yy || Math.pow(point[0] - x, 2) + Math.pow(point[1] - topCenter, 2) < rr || Math.pow(point[0] - x, 2) + Math.pow(point[1] - bottomCenter, 2) < rr;\n    }\n  }]);\n  return CapsuleVertical;\n}(capsule);\n/* harmony default export */ const capsule_vertical = (CapsuleVertical);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/rhombus.js\nfunction rhombus_typeof(obj) { "@babel/helpers - typeof"; return rhombus_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, rhombus_typeof(obj); }\nfunction rhombus_defineProperty(obj, key, value) { key = rhombus_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction rhombus_slicedToArray(arr, i) { return rhombus_arrayWithHoles(arr) || rhombus_iterableToArrayLimit(arr, i) || rhombus_unsupportedIterableToArray(arr, i) || rhombus_nonIterableRest(); }\nfunction rhombus_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction rhombus_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return rhombus_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return rhombus_arrayLikeToArray(o, minLen); }\nfunction rhombus_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction rhombus_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction rhombus_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction rhombus_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction rhombus_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, rhombus_toPropertyKey(descriptor.key), descriptor); } }\nfunction rhombus_createClass(Constructor, protoProps, staticProps) { if (protoProps) rhombus_defineProperties(Constructor.prototype, protoProps); if (staticProps) rhombus_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction rhombus_toPropertyKey(arg) { var key = rhombus_toPrimitive(arg, "string"); return rhombus_typeof(key) === "symbol" ? key : String(key); }\nfunction rhombus_toPrimitive(input, hint) { if (rhombus_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (rhombus_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction rhombus_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) rhombus_setPrototypeOf(subClass, superClass); }\nfunction rhombus_setPrototypeOf(o, p) { rhombus_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rhombus_setPrototypeOf(o, p); }\nfunction rhombus_createSuper(Derived) { var hasNativeReflectConstruct = rhombus_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rhombus_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rhombus_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rhombus_possibleConstructorReturn(this, result); }; }\nfunction rhombus_possibleConstructorReturn(self, call) { if (call && (rhombus_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return rhombus_assertThisInitialized(self); }\nfunction rhombus_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction rhombus_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction rhombus_getPrototypeOf(o) { rhombus_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rhombus_getPrototypeOf(o); }\n\n\n/**\n * 菱形单元 配置\n * @typedef {Node~Configs} Rhombus~RhombusConfigs\n * @property {number} diagonalsV  - 内十字高度\n * @property {number} diagonalsH  - 内十字宽度\n */\n/**\n * 菱形单元\n * @constructor Rhombus\n * @param {Rhombus~RhombusConfigs} configs - 配置\n * @extends Node\n */\nvar Rhombus = /*#__PURE__*/function (_Node) {\n  rhombus_inherits(Rhombus, _Node);\n  var _super = rhombus_createSuper(Rhombus);\n  function Rhombus() {\n    var _this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    rhombus_classCallCheck(this, Rhombus);\n    _this = _super.call(this, configs);\n    _this.type = \'Rhombus\';\n    /** @member {Number}      - 内十字高度 */\n    _this.height = configs.diagonalsV || 10;\n    /** @member {Number}      - 内十字宽度 */\n    _this.width = configs.diagonalsH || 20;\n    return _this;\n  }\n  rhombus_createClass(Rhombus, [{\n    key: "render",\n    value: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var center = this.anchor;\n      ctx.translate(center[0], center[1]);\n      ctx.beginPath();\n      ctx.moveTo(0, -h);\n      ctx.lineTo(w, 0);\n      ctx.lineTo(0, h);\n      ctx.lineTo(-w, 0);\n      ctx.closePath();\n      if (this.borderWidth) {\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeStyle = this.borderColor;\n      }\n      if (this.shadowColor) {\n        ctx.shadowColor = this.shadowColor;\n        var scale = this._jflow.scale;\n        ctx.shadowBlur = this.shadowBlur * scale;\n        ctx.shadowOffsetX = this.shadowOffsetX * scale;\n        ctx.shadowOffsetY = this.shadowOffsetY * scale;\n        var switchPath = new Path2D();\n        switchPath.moveTo(0, -h);\n        switchPath.lineTo(w, 0);\n        switchPath.lineTo(0, h);\n        switchPath.lineTo(-w, 0);\n        switchPath.closePath();\n        switchPath.rect(-w - 10, -h - 10, this.width + 20, this.height + 20);\n        // switchPath.moveTo(x, y-h);\n        // switchPath.lineTo(x + w, y);\n        // switchPath.lineTo(x, y + h);\n        // switchPath.lineTo(x-w, y);\n        // switchPath.closePath();\n        // switchPath.rect(x - w - 10, y - h - 10, this.width+ 20, this.height+ 20);\n        ctx.save();\n        ctx.clip(switchPath, "evenodd");\n        ctx.stroke();\n        ctx.restore();\n      }\n      ctx.fillStyle = this.backgroundColor;\n      ctx.fill();\n      if (this.borderWidth) {\n        ctx.shadowColor = \'transparent\';\n        ctx.stroke();\n      }\n      ctx.translate(-center[0], -center[1]);\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      var v = this.height / 2;\n      var h = this.width / 2;\n      var anchor = this.anchor;\n      var x = Math.abs(point[0] - anchor[0]);\n      var y = Math.abs(point[1] - anchor[1]);\n      return x / h + y / v <= 1;\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var ltx = anchor[0] - w;\n      var lty = anchor[1] - h;\n      var rbx = anchor[0] + w;\n      var rby = anchor[1] + h;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        height: this.height,\n        width: this.width\n      };\n    }\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      var _ref;\n      var p2 = this.anchor;\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        p2 = this._belongs.calculateToCoordination(p2);\n      }\n      var _p = p2,\n        _p2 = rhombus_slicedToArray(_p, 2),\n        x2 = _p2[0],\n        y2 = _p2[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      return _ref = {}, rhombus_defineProperty(_ref, DIRECTION.RIGHT, [x2 + w, y2]), rhombus_defineProperty(_ref, DIRECTION.LEFT, [x2 - w, y2]), rhombus_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + h]), rhombus_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - h]), rhombus_defineProperty(_ref, DIRECTION.SELF, [x2 + w * 0.618, y2 + h * 0.618]), _ref;\n    }\n  }]);\n  return Rhombus;\n}(node);\n/* harmony default export */ const rhombus = (Rhombus);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/diamond.js\nfunction diamond_typeof(obj) { "@babel/helpers - typeof"; return diamond_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, diamond_typeof(obj); }\nfunction diamond_defineProperty(obj, key, value) { key = diamond_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction diamond_slicedToArray(arr, i) { return diamond_arrayWithHoles(arr) || diamond_iterableToArrayLimit(arr, i) || diamond_unsupportedIterableToArray(arr, i) || diamond_nonIterableRest(); }\nfunction diamond_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction diamond_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return diamond_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return diamond_arrayLikeToArray(o, minLen); }\nfunction diamond_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction diamond_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction diamond_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction diamond_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction diamond_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, diamond_toPropertyKey(descriptor.key), descriptor); } }\nfunction diamond_createClass(Constructor, protoProps, staticProps) { if (protoProps) diamond_defineProperties(Constructor.prototype, protoProps); if (staticProps) diamond_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction diamond_toPropertyKey(arg) { var key = diamond_toPrimitive(arg, "string"); return diamond_typeof(key) === "symbol" ? key : String(key); }\nfunction diamond_toPrimitive(input, hint) { if (diamond_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (diamond_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction diamond_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) diamond_setPrototypeOf(subClass, superClass); }\nfunction diamond_setPrototypeOf(o, p) { diamond_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return diamond_setPrototypeOf(o, p); }\nfunction diamond_createSuper(Derived) { var hasNativeReflectConstruct = diamond_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = diamond_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = diamond_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return diamond_possibleConstructorReturn(this, result); }; }\nfunction diamond_possibleConstructorReturn(self, call) { if (call && (diamond_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return diamond_assertThisInitialized(self); }\nfunction diamond_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction diamond_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction diamond_getPrototypeOf(o) { diamond_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return diamond_getPrototypeOf(o); }\n\n\n// import { makeBezierPoints } from \'../../utils/functions\';\n/**\n * 钻石形单元 配置\n * @typedef {Node~Configs} Diamond~DiamondConfigs\n * @property {number} width  - 内部矩形宽\n * @property {number} height - 内部矩形高\n * @property {number} side   - 两侧三角形的宽\n */\n/**\n * 钻石形单元\n * @constructor Diamond\n * @param {Diamond~DiamondConfigs} configs - 配置\n * @extends Node\n */\nvar Diamond = /*#__PURE__*/function (_Node) {\n  diamond_inherits(Diamond, _Node);\n  var _super = diamond_createSuper(Diamond);\n  function Diamond() {\n    var _this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    diamond_classCallCheck(this, Diamond);\n    _this = _super.call(this, configs);\n    _this.type = \'Diamond\';\n    /** @member {Number}      - 内部矩形宽 */\n    _this.width = configs.width || 20;\n    /** @member {Number}      - 内部矩形高 */\n    _this.height = configs.height || 10;\n    /** @member {Number}      - 两侧三角形的宽 */\n    _this.side = configs.side || 6;\n    _this._doCache();\n    return _this;\n  }\n  diamond_createClass(Diamond, [{\n    key: "setConfig",\n    value: function setConfig(configs) {\n      var _this2 = this;\n      Object.keys(configs).forEach(function (k) {\n        if (configs[k] !== undefined && configs[k] !== null) {\n          _this2[k] = configs[k];\n          _this2._rawConfigs[k] = configs[k];\n        }\n      });\n      this._doCache();\n    }\n  }, {\n    key: "_doCache",\n    value: function _doCache() {\n      this.sinSIDE = Math.sin(Math.PI / 3) * this.side;\n      this.cosSIDE = Math.cos(Math.PI / 3) * this.side;\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      var _this$anchor = diamond_slicedToArray(this.anchor, 2),\n        x = _this$anchor[0],\n        y = _this$anchor[1];\n      var hw = this.width / 2;\n      var hh = this.height / 2;\n      var xx = hh / 1.732;\n      var leftCenter = x - hw + xx;\n      var rightCenter = x + hw - xx;\n      var right = x + hw;\n      var left = x - hw;\n      var top = y - hh;\n      var bottom = y + hh;\n      this._cachePoints = [[rightCenter, top], [right, y], [rightCenter, bottom], [leftCenter, bottom], [left, y], [leftCenter, top]];\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      ctx.beginPath();\n      var side = this.side,\n        sinSIDE = this.sinSIDE,\n        cosSIDE = this.cosSIDE;\n      ctx.moveTo(x, top);\n      ctx.lineTo(rightCenter - side, top);\n      ctx.quadraticCurveTo(rightCenter, top, rightCenter + cosSIDE, top + sinSIDE);\n      ctx.lineTo(right - cosSIDE, y - sinSIDE);\n      ctx.quadraticCurveTo(right, y, right - cosSIDE, y + sinSIDE);\n      ctx.lineTo(rightCenter + cosSIDE, bottom - sinSIDE);\n      ctx.quadraticCurveTo(rightCenter, bottom, rightCenter - side, bottom);\n      ctx.lineTo(leftCenter + side, bottom);\n      ctx.quadraticCurveTo(leftCenter, bottom, leftCenter - cosSIDE, bottom - sinSIDE);\n      ctx.lineTo(left + cosSIDE, y + sinSIDE);\n      ctx.quadraticCurveTo(left, y, left + cosSIDE, y - sinSIDE);\n      ctx.lineTo(leftCenter - cosSIDE, top + sinSIDE);\n      ctx.quadraticCurveTo(leftCenter, top, leftCenter + side, top);\n      ctx.closePath();\n      ctx.fillStyle = this.backgroundColor;\n      if (this.shadowColor) {\n        ctx.shadowColor = this.shadowColor;\n        ctx.shadowBlur = this.shadowBlur;\n        ctx.shadowOffsetX = this.shadowOffsetX;\n        ctx.shadowOffsetY = this.shadowOffsetY;\n      }\n      ctx.fill();\n      if (this.borderWidth) {\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeStyle = this.borderColor;\n        ctx.stroke();\n      }\n\n      // if(this._isTargeting) {\n      //     this.renderFocus(ctx);\n      // }\n      // ctx.fillStyle = \'rgba(0,0,0,0.3)\';\n      // ctx.fillRect(x-hw, y-hh, this.width, this.height)\n\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      if (!this._cachePoints) return false;\n      var polygon = this._cachePoints;\n      var odd = false;\n      // For each edge (In this case for each point of the polygon and the previous one)\n      for (var i = 0, j = polygon.length - 1; i < polygon.length; i++) {\n        // If a line from the point into infinity crosses this edge\n        if (polygon[i][1] > point[1] !== polygon[j][1] > point[1] // One point needs to be above, one below our y coordinate\n        // ...and the edge doesn\'t cross our Y corrdinate before our x coordinate (but between our x coordinate and infinity)\n        && point[0] < (polygon[j][0] - polygon[i][0]) * (point[1] - polygon[i][1]) / (polygon[j][1] - polygon[i][1]) + polygon[i][0]) {\n          // Invert odd\n          odd = !odd;\n        }\n        j = i;\n      }\n      return odd;\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var ltx = anchor[0] - w;\n      var lty = anchor[1] - h;\n      var rbx = anchor[0] + w;\n      var rby = anchor[1] + h;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        height: this.height,\n        width: this.width\n      };\n    }\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      var _ref;\n      var p2 = this.anchor;\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        p2 = this._belongs.calculateToCoordination(p2);\n      }\n      var _p = p2,\n        _p2 = diamond_slicedToArray(_p, 2),\n        x2 = _p2[0],\n        y2 = _p2[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      return _ref = {}, diamond_defineProperty(_ref, DIRECTION.RIGHT, [x2 + w, y2]), diamond_defineProperty(_ref, DIRECTION.LEFT, [x2 - w, y2]), diamond_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + h]), diamond_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - h]), _ref;\n    }\n  }]);\n  return Diamond;\n}(node);\n/* harmony default export */ const diamond = (Diamond);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/diamond-vertical.js\nfunction diamond_vertical_typeof(obj) { "@babel/helpers - typeof"; return diamond_vertical_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, diamond_vertical_typeof(obj); }\nfunction diamond_vertical_slicedToArray(arr, i) { return diamond_vertical_arrayWithHoles(arr) || diamond_vertical_iterableToArrayLimit(arr, i) || diamond_vertical_unsupportedIterableToArray(arr, i) || diamond_vertical_nonIterableRest(); }\nfunction diamond_vertical_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction diamond_vertical_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return diamond_vertical_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return diamond_vertical_arrayLikeToArray(o, minLen); }\nfunction diamond_vertical_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction diamond_vertical_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction diamond_vertical_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction diamond_vertical_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction diamond_vertical_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, diamond_vertical_toPropertyKey(descriptor.key), descriptor); } }\nfunction diamond_vertical_createClass(Constructor, protoProps, staticProps) { if (protoProps) diamond_vertical_defineProperties(Constructor.prototype, protoProps); if (staticProps) diamond_vertical_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction diamond_vertical_toPropertyKey(arg) { var key = diamond_vertical_toPrimitive(arg, "string"); return diamond_vertical_typeof(key) === "symbol" ? key : String(key); }\nfunction diamond_vertical_toPrimitive(input, hint) { if (diamond_vertical_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (diamond_vertical_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction diamond_vertical_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) diamond_vertical_setPrototypeOf(subClass, superClass); }\nfunction diamond_vertical_setPrototypeOf(o, p) { diamond_vertical_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return diamond_vertical_setPrototypeOf(o, p); }\nfunction diamond_vertical_createSuper(Derived) { var hasNativeReflectConstruct = diamond_vertical_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = diamond_vertical_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = diamond_vertical_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return diamond_vertical_possibleConstructorReturn(this, result); }; }\nfunction diamond_vertical_possibleConstructorReturn(self, call) { if (call && (diamond_vertical_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return diamond_vertical_assertThisInitialized(self); }\nfunction diamond_vertical_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction diamond_vertical_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction diamond_vertical_getPrototypeOf(o) { diamond_vertical_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return diamond_vertical_getPrototypeOf(o); }\n\nvar backsqrt3 = 1 / Math.sqrt(3);\n\n/**\n * 垂直钻石形单元\n * @constructor DiamondVertical\n * @param {Diamond~DiamondConfigs} configs - 配置\n * @extends Diamond\n */\nvar DiamondVertical = /*#__PURE__*/function (_Diamond) {\n  diamond_vertical_inherits(DiamondVertical, _Diamond);\n  var _super = diamond_vertical_createSuper(DiamondVertical);\n  function DiamondVertical(configs) {\n    diamond_vertical_classCallCheck(this, DiamondVertical);\n    return _super.call(this, configs);\n  }\n  diamond_vertical_createClass(DiamondVertical, [{\n    key: "render",\n    value: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      ctx.beginPath();\n      var _this$anchor = diamond_vertical_slicedToArray(this.anchor, 2),\n        x = _this$anchor[0],\n        y = _this$anchor[1];\n      var hw = this.width / 2;\n      var hh = this.height / 2;\n      var yy = hw / 1.732;\n      var top = y - hh;\n      var bottom = y + hh;\n      var topmiddle = y - hh + yy;\n      var bottommiddle = y + hh - yy;\n      var xleft = x - hw;\n      var xright = x + hw;\n      ctx.moveTo(x, top);\n      ctx.lineTo(xright, topmiddle);\n      ctx.lineTo(xright, bottommiddle);\n      ctx.lineTo(x, bottom);\n      ctx.lineTo(xleft, bottommiddle);\n      ctx.lineTo(xleft, topmiddle);\n      ctx.closePath();\n      ctx.fillStyle = this.backgroundColor;\n      if (this.shadowColor) {\n        ctx.shadowColor = this.shadowColor;\n        ctx.shadowBlur = this.shadowBlur;\n        ctx.shadowOffsetX = this.shadowOffsetX;\n        ctx.shadowOffsetY = this.shadowOffsetY;\n      }\n      ctx.fill();\n      if (this.borderWidth) {\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeStyle = this.borderColor;\n        ctx.stroke();\n      }\n      ctx.restore();\n      this._cachePoints = [[x, top], [xright, topmiddle], [xright, bottommiddle], [x, bottom], [xleft, bottommiddle], [xleft, topmiddle]];\n    }\n  }]);\n  return DiamondVertical;\n}(diamond);\n/* harmony default export */ const diamond_vertical = (DiamondVertical);\n;// CONCATENATED MODULE: ./src/core/instance/groups/scroll-group.js\nfunction scroll_group_typeof(obj) { "@babel/helpers - typeof"; return scroll_group_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, scroll_group_typeof(obj); }\nfunction scroll_group_defineProperty(obj, key, value) { key = scroll_group_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction scroll_group_slicedToArray(arr, i) { return scroll_group_arrayWithHoles(arr) || scroll_group_iterableToArrayLimit(arr, i) || scroll_group_unsupportedIterableToArray(arr, i) || scroll_group_nonIterableRest(); }\nfunction scroll_group_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction scroll_group_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return scroll_group_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return scroll_group_arrayLikeToArray(o, minLen); }\nfunction scroll_group_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction scroll_group_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction scroll_group_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction scroll_group_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction scroll_group_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, scroll_group_toPropertyKey(descriptor.key), descriptor); } }\nfunction scroll_group_createClass(Constructor, protoProps, staticProps) { if (protoProps) scroll_group_defineProperties(Constructor.prototype, protoProps); if (staticProps) scroll_group_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction scroll_group_toPropertyKey(arg) { var key = scroll_group_toPrimitive(arg, "string"); return scroll_group_typeof(key) === "symbol" ? key : String(key); }\nfunction scroll_group_toPrimitive(input, hint) { if (scroll_group_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (scroll_group_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction scroll_group_get() { if (typeof Reflect !== "undefined" && Reflect.get) { scroll_group_get = Reflect.get.bind(); } else { scroll_group_get = function _get(target, property, receiver) { var base = scroll_group_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return scroll_group_get.apply(this, arguments); }\nfunction scroll_group_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = scroll_group_getPrototypeOf(object); if (object === null) break; } return object; }\nfunction scroll_group_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) scroll_group_setPrototypeOf(subClass, superClass); }\nfunction scroll_group_setPrototypeOf(o, p) { scroll_group_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return scroll_group_setPrototypeOf(o, p); }\nfunction scroll_group_createSuper(Derived) { var hasNativeReflectConstruct = scroll_group_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = scroll_group_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = scroll_group_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return scroll_group_possibleConstructorReturn(this, result); }; }\nfunction scroll_group_possibleConstructorReturn(self, call) { if (call && (scroll_group_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return scroll_group_assertThisInitialized(self); }\nfunction scroll_group_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction scroll_group_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction scroll_group_getPrototypeOf(o) { scroll_group_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return scroll_group_getPrototypeOf(o); }\n\n\n\n\n\n\n\nvar scroll_group_ishitKey = Symbol(\'ishit\');\nvar InnerScrollBar = /*#__PURE__*/function (_ScrollBar) {\n  scroll_group_inherits(InnerScrollBar, _ScrollBar);\n  var _super = scroll_group_createSuper(InnerScrollBar);\n  function InnerScrollBar(dir) {\n    var _this;\n    var configs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    scroll_group_classCallCheck(this, InnerScrollBar);\n    _this = _super.call(this, dir, configs);\n    _this.visible = false;\n    return _this;\n  }\n  scroll_group_createClass(InnerScrollBar, [{\n    key: "render",\n    value: function render(ctx) {\n      if (this.visible) {\n        scroll_group_get(scroll_group_getPrototypeOf(InnerScrollBar.prototype), "render", this).call(this, ctx);\n      }\n    }\n  }, {\n    key: "setHit",\n    value: function setHit(ishit) {\n      if (this[scroll_group_ishitKey] !== ishit) {\n        this.isFocus = ishit;\n        this.onHit();\n      }\n      this[scroll_group_ishitKey] = ishit;\n    }\n  }]);\n  return InnerScrollBar;\n}(ScrollBar);\nvar ScrollGroup = /*#__PURE__*/function (_Node) {\n  scroll_group_inherits(ScrollGroup, _Node);\n  var _super2 = scroll_group_createSuper(ScrollGroup);\n  function ScrollGroup(configs) {\n    var _configs$lock;\n    var _this2;\n    scroll_group_classCallCheck(this, ScrollGroup);\n    _this2 = _super2.call(this, configs);\n    _this2.type = \'ScrollGroup\';\n    _this2.initStack(configs);\n    _this2.initLayout(configs);\n    _this2.initScrollBar(configs);\n    _this2._shape = new rectangle(configs);\n    _this2._shape.anchor = [0, 0];\n    _this2._shape._belongs = scroll_group_assertThisInitialized(_this2);\n    _this2.maxWidth = configs.maxWidth || Infinity;\n    _this2.definedWidth = configs.definedWidth;\n    _this2.maxHeight = configs.maxHeight || Infinity;\n    _this2.definedHeight = configs.definedHeight;\n    _this2.lock = (_configs$lock = configs.lock) !== null && _configs$lock !== void 0 ? _configs$lock : true;\n    _this2._offset = [0, 0];\n    _this2._getBoundingGroupRect();\n    _this2.reflow();\n    _this2._getBoundingGroupRect();\n    _this2._resetOffset();\n    _this2._cacheViewBox = [];\n    return _this2;\n  }\n  scroll_group_createClass(ScrollGroup, [{\n    key: "initScrollBar",\n    value: function initScrollBar(configs) {\n      var _this3 = this;\n      var barColor = configs.barColor,\n        barFocusColor = configs.barFocusColor,\n        barMarginX = configs.barMarginX,\n        barMarginY = configs.barMarginY,\n        barWidth = configs.barWidth;\n      this._scrollbarX = new InnerScrollBar(\'x\', {\n        plainColor: barColor,\n        focusColor: barFocusColor,\n        barWidth: barWidth\n      });\n      this._scrollbarY = new InnerScrollBar(\'y\', {\n        plainColor: barColor,\n        focusColor: barFocusColor,\n        barWidth: barWidth\n      });\n      this._scrollbarX.barMarginX = barMarginX || 1;\n      this._scrollbarY.barMarginY = barMarginY || 1;\n      var _f = function _f() {\n        _this3._jflow.scheduleRender();\n      };\n      this._scrollbarX.onHit = _f;\n      this._scrollbarY.onHit = _f;\n      this._scrollBarStatus = {\n        dragging: false,\n        target: null,\n        barInitX: 0,\n        barInitY: 0,\n        barStartX: 0,\n        barStartY: 0,\n        hitScrollX: false,\n        hitScrollY: false\n      };\n      // // const jflowInstance = this._jflow;\n      // this.addEventListener(\'instancemousemove\', e => {\n      //     if(this._scrollBarStatus.hitScrollX) {\n      //         if(!this._scrollbarX.isFocus) {\n      //             this._scrollbarX.isFocus = true;\n      //             e.detail.jflow.scheduleRender();\n      //         }\n      //         return;\n      //     }\n      //     if(this._scrollbarX.isFocus) {\n      //         this._scrollbarX.isFocus = false;\n      //         e.detail.jflow.scheduleRender();\n      //     }\n\n      // })\n      this.addEventListener(\'instancePressStart\', function (e) {\n        if (_this3._scrollBarStatus.hitScrollX) {\n          e.detail.preventDefault();\n          e.detail.bubbles = false;\n          var clientX = e.detail.event.clientX;\n          Object.assign(_this3._scrollBarStatus, {\n            dragging: true,\n            target: _this3._scrollbarX,\n            barStartX: _this3._scrollbarX.anchor[0],\n            barInitX: clientX\n          });\n          _this3.onScrollbarPressStart();\n        }\n        if (_this3._scrollBarStatus.hitScrollY) {\n          e.detail.preventDefault();\n          e.detail.bubbles = false;\n          var clientY = e.detail.event.clientY;\n          Object.assign(_this3._scrollBarStatus, {\n            dragging: true,\n            target: _this3._scrollbarY,\n            barStartY: _this3._scrollbarY.anchor[1],\n            barInitY: clientY\n          });\n          _this3.onScrollbarPressStart();\n        }\n      });\n    }\n  }, {\n    key: "onScrollbarPressStart",\n    value: function onScrollbarPressStart() {\n      var _this4 = this;\n      var jflowInstance = this._jflow;\n      var canvas = jflowInstance.canvas;\n      var f = function (e) {\n        var clientX = e.clientX,\n          clientY = e.clientY;\n        _this4.onDraggingScrollbar(clientX, clientY);\n      }.bind(this);\n      document.addEventListener(\'pointermove\', f);\n      var t = function (e) {\n        Object.assign(_this4._scrollBarStatus, {\n          dragging: false,\n          target: null,\n          barInitX: 0,\n          barInitY: 0,\n          barStartX: 0,\n          barStartY: 0,\n          hitScrollX: false,\n          hitScrollY: false\n        });\n        document.removeEventListener(\'pointermove\', f);\n        document.removeEventListener(\'pointerup\', t);\n        canvas.removeEventListener(\'pointerup\', t);\n      }.bind(this);\n      canvas.addEventListener(\'pointerup\', t, {\n        once: true\n      });\n      document.addEventListener(\'pointerup\', t, {\n        once: true\n      });\n    }\n  }, {\n    key: "onDraggingScrollbar",\n    value: function onDraggingScrollbar(clientX, clientY) {\n      if (this._scrollbarX.visible && this._scrollBarStatus.dragging) {\n        var JFLOW = this._jflow;\n        var scale = JFLOW.scale;\n        var _this$_scrollBarStatu = this._scrollBarStatus,\n          target = _this$_scrollBarStatu.target,\n          barInitX = _this$_scrollBarStatu.barInitX,\n          barStartX = _this$_scrollBarStatu.barStartX,\n          barInitY = _this$_scrollBarStatu.barInitY,\n          barStartY = _this$_scrollBarStatu.barStartY;\n        if (target.dir === \'x\') {\n          var _scrollWidth = this._scrollbarX.width;\n          var _outerWidth = this._outerWidth;\n          var deltaX = clientX - barInitX;\n          var xnew = barStartX + deltaX / scale;\n          var q = target.anchor[0] = Math.max(Math.min(xnew, _outerWidth - _scrollWidth), 0);\n          var ratioInX = q / (_outerWidth - _scrollWidth);\n          var s = (this._innerWidth - _outerWidth) / 2;\n          this._offset[0] = s - (this._innerWidth - _outerWidth) * ratioInX;\n          JFLOW.scheduleRender();\n        }\n        if (target.dir === \'y\') {\n          var _scrollHeight = this._scrollbarY.height;\n          var _outerHeight = this._outerHeight;\n          var deltaY = clientY - barInitY;\n          var ynew = barStartY + deltaY / scale;\n          var _q = target.anchor[1] = Math.max(Math.min(ynew, _outerHeight - _scrollHeight), 0);\n          var ratio = _q / (_outerHeight - _scrollHeight);\n          var _s = (this._innerHeight - _outerHeight) / 2;\n          this._offset[1] = _s - (this._innerHeight - _outerHeight) * ratio;\n          JFLOW.scheduleRender();\n        }\n      }\n    }\n  }, {\n    key: "setConfig",\n    value: function setConfig(configs) {\n      this._shape.setConfig(configs);\n    }\n  }, {\n    key: "_getBoundingGroupRect",\n    value: function _getBoundingGroupRect() {\n      var points = this._stack.getBoundingRectPoints();\n      // content box \n      var bbox = bounding_box(points);\n      var w = bbox.width;\n      var h = bbox.height;\n      var outerWidth = this.definedWidth || Math.min(w, this.maxWidth);\n      var outerHeight = this.definedHeight || Math.min(h, this.maxHeight);\n      this._innerWidth = w;\n      this._outerWidth = outerWidth;\n      this._innerHeight = h;\n      this._outerHeight = outerHeight;\n      this._shape.width = outerWidth;\n      this._shape.height = outerHeight;\n      this.width = outerWidth;\n      this.height = outerHeight;\n    }\n  }, {\n    key: "_calculatePointBack",\n    value: function _calculatePointBack(point) {\n      var _point = scroll_group_slicedToArray(point, 2),\n        gx = _point[0],\n        gy = _point[1];\n      var _this$_offset = scroll_group_slicedToArray(this._offset, 2),\n        tx = _this$_offset[0],\n        ty = _this$_offset[1];\n      var _this$anchor = scroll_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor[0],\n        cy = _this$anchor[1];\n      var p = [gx - cx - tx, gy - cy - ty];\n      return p;\n    }\n  }, {\n    key: "_calculatePointBackWithPoint",\n    value: function _calculatePointBackWithPoint(a, b, arr, idx1, idx2) {\n      var anchor = this.anchor;\n      var offset = this._offset;\n      arr[idx1] = a - anchor[0] - offset[0];\n      arr[idx2] = b - anchor[1] - offset[1];\n    }\n  }, {\n    key: "calculateToCoordination",\n    value: function calculateToCoordination(point) {\n      var _point2 = scroll_group_slicedToArray(point, 2),\n        gx = _point2[0],\n        gy = _point2[1];\n      var _this$anchor2 = scroll_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor2[0],\n        cy = _this$anchor2[1];\n      var _this$_offset2 = scroll_group_slicedToArray(this._offset, 2),\n        tx = _this$_offset2[0],\n        ty = _this$_offset2[1];\n      var p = [gx + cx - tx, gy + cy - ty];\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        return this._belongs.calculateToCoordination(p);\n      } else {\n        return p;\n      }\n    }\n  }, {\n    key: "calculateToRealWorld",\n    value: function calculateToRealWorld(point) {\n      var _point3 = scroll_group_slicedToArray(point, 2),\n        gx = _point3[0],\n        gy = _point3[1];\n      var _this$anchor3 = scroll_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor3[0],\n        cy = _this$anchor3[1];\n      var _this$_offset3 = scroll_group_slicedToArray(this._offset, 2),\n        tx = _this$_offset3[0],\n        ty = _this$_offset3[1];\n      var p = [gx + cx - tx, gy + cy - ty];\n      if (this._belongs && this._belongs.calculateToRealWorld) {\n        return this._belongs.calculateToRealWorld(p);\n      }\n    }\n  }, {\n    key: "calculateToRealWorldWithPointer",\n    value: function calculateToRealWorldWithPointer(outpoint, inpoint) {\n      outpoint[0] = inpoint[0] + this.anchor[0] - this.offset[0];\n      outpoint[1] = inpoint[1] + this.anchor[1] - this.offset[1];\n      if (this._belongs && this._belongs.calculateToRealWorldWithPointer) {\n        return this._belongs.calculateToRealWorldWithPointer(outpoint, outpoint);\n      }\n    }\n  }, {\n    key: "_getViewBox",\n    value: function _getViewBox() {\n      var belongs_vbox = this._belongs.getCacheViewBox();\n      var cacheViewBox = this._cacheViewBox;\n      this._calculatePointBackWithPoint(belongs_vbox[0], belongs_vbox[1], cacheViewBox, 0, 1);\n      this._calculatePointBackWithPoint(belongs_vbox[2], belongs_vbox[3], cacheViewBox, 2, 3);\n      return this._cacheViewBox;\n    }\n  }, {\n    key: "getCacheViewBox",\n    value: function getCacheViewBox() {\n      return this._cacheViewBox;\n    }\n  }, {\n    key: "_resetOffset",\n    value: function _resetOffset() {\n      this._offset = [Math.max((this._innerWidth - this._outerWidth) / 2, 0), Math.max((this._innerHeight - this._outerHeight) / 2, 0)];\n      if (this._innerWidth > this._outerWidth) {\n        this._scrollbarX.visible = true;\n        this._scrollbarX.width = this._outerWidth * this._outerWidth / this._innerWidth;\n        this._scrollbarX.anchor = [0, this._outerHeight - 4];\n      } else {\n        this._scrollbarX.visible = false;\n      }\n      if (this._innerHeight > this._outerHeight) {\n        this._scrollbarY.visible = true;\n        this._scrollbarY.height = this._outerHeight * this._outerHeight / this._innerHeight;\n        this._scrollbarY.anchor = [this._outerWidth - 4, 0];\n      } else {\n        this._scrollbarY.visible = false;\n      }\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      } else if (this.opacity !== 1) {\n        ctx.globalAlpha = this.opacity;\n      }\n      var _this$anchor4 = scroll_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor4[0],\n        cy = _this$anchor4[1];\n      var w = this.width;\n      var h = this.height;\n      var w2 = w / 2;\n      var h2 = h / 2;\n      // if((this.width * this.height) * this._jflow.scale < 144) {\n      //     ctx.restore();\n      //     return;\n      // }\n      var _this$_offset4 = scroll_group_slicedToArray(this._offset, 2),\n        tx = _this$_offset4[0],\n        ty = _this$_offset4[1];\n      ctx.translate(cx, cy);\n      this._shape.render(ctx);\n      ctx.translate(-w2, -h2);\n      if (this._scrollbarX.visible) {\n        this._scrollbarX.render(ctx);\n      }\n      if (this._scrollbarY.visible) {\n        this._scrollbarY.render(ctx);\n      }\n      ctx.translate(w2, h2);\n      ctx.save();\n      ctx.beginPath();\n      ctx.rect(-w2, -h2, w, h);\n      ctx.clip();\n      ctx.translate(tx, ty);\n      this._stack.render(ctx);\n      this._linkStack.render(ctx);\n      ctx.translate(-cx - tx, -cy - ty);\n      ctx.restore();\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point, condition) {\n      var _point4 = scroll_group_slicedToArray(point, 2),\n        gx = _point4[0],\n        gy = _point4[1];\n      var _this$anchor5 = scroll_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor5[0],\n        cy = _this$anchor5[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var sp = [gx - cx + w, gy - cy + h];\n      this._scrollBarStatus.hitScrollX = false;\n      this._scrollBarStatus.hitScrollY = false;\n      if (this._scrollbarX.visible) {\n        var xhit = this._scrollbarX.isHit(sp);\n        if (xhit) {\n          this._scrollBarStatus.hitScrollX = true;\n          this._scrollbarX.setHit(true);\n          return true;\n        }\n      }\n      this._scrollbarX.setHit(false);\n      if (this._scrollbarY.visible) {\n        var yhit = this._scrollbarY.isHit(sp);\n        if (yhit) {\n          this._scrollBarStatus.hitScrollY = true;\n          this._scrollbarY.setHit(true);\n          return true;\n        }\n      }\n      this._scrollbarY.setHit(false);\n\n      // const br = this._getViewBox();\n      var isInBound = this._shape.isHit([gx - cx, gy - cy]);\n      if (isInBound) {\n        var _this$_offset5 = scroll_group_slicedToArray(this._offset, 2),\n          tx = _this$_offset5[0],\n          ty = _this$_offset5[1];\n        var p = [gx - cx - tx, gy - cy - ty];\n        this._currentp = p; // 暂存，为了后续计算别的位置\n        var target = this._stack.checkHit(p, condition);\n        if (target) return target;\n      } else {\n        this._stack.resetHitStatus();\n      }\n      return false;\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        width: this.width,\n        height: this.height\n      };\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var ltx = anchor[0] - w;\n      var lty = anchor[1] - h;\n      var rbx = anchor[0] + w;\n      var rby = anchor[1] + h;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }, {\n    key: "getIntersectionsInFourDimension",\n    value: function getIntersectionsInFourDimension() {\n      var _ref;\n      var p2 = this.anchor;\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        p2 = this._belongs.calculateToCoordination(p2);\n      }\n      var _p = p2,\n        _p2 = scroll_group_slicedToArray(_p, 2),\n        x2 = _p2[0],\n        y2 = _p2[1];\n      var w = this.width / 2;\n      var h = this.height / 2;\n      return _ref = {}, scroll_group_defineProperty(_ref, DIRECTION.RIGHT, [x2 + w, y2]), scroll_group_defineProperty(_ref, DIRECTION.LEFT, [x2 - w, y2]), scroll_group_defineProperty(_ref, DIRECTION.BOTTOM, [x2, y2 + h]), scroll_group_defineProperty(_ref, DIRECTION.TOP, [x2, y2 - h]), scroll_group_defineProperty(_ref, DIRECTION.SELF, [x2 + w * 0.618, y2 + h * 0.618]), _ref;\n    }\n  }, {\n    key: "onEnterViewbox",\n    value: function onEnterViewbox() {\n      this.interateNodeStack(function (instance) {\n        instance.onEnterViewbox();\n      });\n    }\n  }, {\n    key: "onLeaveViewbox",\n    value: function onLeaveViewbox() {\n      this.interateNodeStack(function (instance) {\n        instance.onLeaveViewbox();\n      });\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      this._shape.destroy();\n      this.interateNodeStack(function (instance) {\n        instance.destroy();\n      });\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      var C = this.constructor;\n      var configs = Object.assign({}, this._rawConfigs, {\n        layout: this._layout && this._layout.clone()\n      });\n      var t = new C(configs);\n      this.interateNodeStack(function (instance) {\n        t.addToStack(instance.clone());\n      });\n      t.recalculate();\n      t.visible = this.visible;\n      return t;\n    }\n  }]);\n  return ScrollGroup;\n}(node);\nObject.assign(ScrollGroup.prototype, stackMixin);\nObject.assign(ScrollGroup.prototype, layoutMixin);\nObject.assign(ScrollGroup.prototype, {\n  recalculateUp: function recalculateUp() {\n    var dirty = true;\n    if (this.getBoundingDimension) {\n      // const { width: wold, height: hold } = this.getBoundingDimension();\n      var wold = this._innerWidth;\n      var hold = this._innerHeight;\n      if (this.resetChildrenPosition) {\n        this.resetChildrenPosition();\n      }\n      if (this._getBoundingGroupRect) {\n        this._getBoundingGroupRect();\n      }\n      this.reflow();\n      if (this._getBoundingGroupRect) {\n        this._getBoundingGroupRect();\n      }\n      var wnow = this._innerWidth;\n      var hnow = this._innerHeight;\n      // const { width: wnow, height: hnow } = this.getBoundingDimension();\n      dirty = wold !== wnow || hold !== hnow;\n    } else {\n      this.reflow();\n    }\n    if (this._belongs && dirty) {\n      this._resetOffset();\n      this._belongs.recalculateUp();\n    }\n  },\n  recalculate: function recalculate() {\n    var _this$getBoundingDime = this.getBoundingDimension(),\n      wold = _this$getBoundingDime.width,\n      hold = _this$getBoundingDime.height;\n    this.reflow();\n    if (this._getBoundingGroupRect) {\n      this._getBoundingGroupRect();\n    }\n    var _this$getBoundingDime2 = this.getBoundingDimension(),\n      wnow = _this$getBoundingDime2.width,\n      hnow = _this$getBoundingDime2.height;\n    if (wold !== wnow || hold !== hnow) {\n      this._resetOffset();\n    }\n  }\n});\n/* harmony default export */ const scroll_group = (ScrollGroup);\n;// CONCATENATED MODULE: ./src/core/events/commonAdapter.js\n/* harmony default export */ const commonAdapter = ({\n  canvas: {\n    wheel: function wheel(event, jflow) {\n      event.preventDefault();\n      var offsetX = event.offsetX,\n        offsetY = event.offsetY,\n        deltaX = event.deltaX,\n        deltaY = event.deltaY;\n      if (event.ctrlKey) {\n        deltaY = -deltaY;\n      }\n      jflow.zoomHandler(offsetX, offsetY, deltaX, deltaY, event);\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/core/instance/base-link.js\nfunction base_link_typeof(obj) { "@babel/helpers - typeof"; return base_link_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, base_link_typeof(obj); }\nfunction base_link_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction base_link_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, base_link_toPropertyKey(descriptor.key), descriptor); } }\nfunction base_link_createClass(Constructor, protoProps, staticProps) { if (protoProps) base_link_defineProperties(Constructor.prototype, protoProps); if (staticProps) base_link_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction base_link_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) base_link_setPrototypeOf(subClass, superClass); }\nfunction base_link_setPrototypeOf(o, p) { base_link_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return base_link_setPrototypeOf(o, p); }\nfunction base_link_createSuper(Derived) { var hasNativeReflectConstruct = base_link_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = base_link_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = base_link_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return base_link_possibleConstructorReturn(this, result); }; }\nfunction base_link_possibleConstructorReturn(self, call) { if (call && (base_link_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return base_link_assertThisInitialized(self); }\nfunction base_link_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction base_link_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction base_link_getPrototypeOf(o) { base_link_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return base_link_getPrototypeOf(o); }\nfunction base_link_defineProperty(obj, key, value) { key = base_link_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction base_link_toPropertyKey(arg) { var key = base_link_toPrimitive(arg, "string"); return base_link_typeof(key) === "symbol" ? key : String(key); }\nfunction base_link_toPrimitive(input, hint) { if (base_link_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (base_link_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n/**\n * @typedef {Instance~Configs} BaseLink~Configs\n * @property {Instance} from   - 起始单元\n * @property {Instance} to     - 终止单元\n * @property {String} fromDir  - 起始方向 \n * @property {String} toDir    - 终止方向 \n * @property {String} key      - 连线唯一键值\n * @property {String} backgroundColor    - 线条颜色 \n */\n/**\n * 连线基类\n * @constructor BaseLink\n * @extends Instance\n * @param {BaseLink~Configs} configs - 配置\n */\nvar BaseLink = /*#__PURE__*/function (_Instance) {\n  base_link_inherits(BaseLink, _Instance);\n  var _super = base_link_createSuper(BaseLink);\n  function BaseLink() {\n    var _this;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    base_link_classCallCheck(this, BaseLink);\n    _this = _super.call(this);\n    /** @member {Instance}      - 起始单元 */\n    base_link_defineProperty(base_link_assertThisInitialized(_this), "INSTANCE_TYPE", \'LINK\');\n    _this.from = configs.from;\n    /** @member {Instance}      - 终止单元 */\n    _this.to = configs.to;\n    /** @member {DIRECTION}      - 起始方向 */\n    _this.fromDir = configs.fromDir;\n    /** @member {DIRECTION}      - 终止方向 */\n    _this.toDir = configs.toDir;\n    /** @member {number[][]}     - 连线控制点缓存 */\n    _this._cachePoints = null;\n    /** @member {string}     - 连线颜色，默认为 #000 */\n    _this.backgroundColor = configs.backgroundColor || \'#000\';\n    _this.isSelf = !!configs.isSelf;\n    return _this;\n  }\n\n  /**\n   * 是否出现在当前视窗内\n   * @param {number[]} viewbox\n   */\n  base_link_createClass(BaseLink, [{\n    key: "nextSibling",\n    get: function get() {\n      var _this2 = this;\n      if (!this._belongs) {\n        return null;\n      }\n      var stack = this._belongs._linkStack;\n      var idx = stack.findIndex(function (s) {\n        return s === _this2;\n      });\n      if (idx !== -1) {\n        return stack[idx + 1];\n      }\n      return null;\n    }\n  }, {\n    key: "isInViewBox",\n    value: function isInViewBox(viewbox) {\n      return true;\n    }\n  }, {\n    key: "bringToTop",\n    value: function bringToTop() {\n      var _this3 = this;\n      var linkStack = this._jflow._linkStack;\n      var index = linkStack.findIndex(function (l) {\n        return l === _this3;\n      });\n      linkStack.splice(index, 1);\n      linkStack.push(this);\n      this._jflow._render();\n    }\n  }]);\n  return BaseLink;\n}(instance_instance);\n/* harmony default export */ const base_link = (BaseLink);\n;// CONCATENATED MODULE: ./src/core/instance/shapes/shadow-cache.js\nfunction shadow_cache_typeof(obj) { "@babel/helpers - typeof"; return shadow_cache_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, shadow_cache_typeof(obj); }\nfunction shadow_cache_slicedToArray(arr, i) { return shadow_cache_arrayWithHoles(arr) || shadow_cache_iterableToArrayLimit(arr, i) || shadow_cache_unsupportedIterableToArray(arr, i) || shadow_cache_nonIterableRest(); }\nfunction shadow_cache_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction shadow_cache_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return shadow_cache_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return shadow_cache_arrayLikeToArray(o, minLen); }\nfunction shadow_cache_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction shadow_cache_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction shadow_cache_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction shadow_cache_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction shadow_cache_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, shadow_cache_toPropertyKey(descriptor.key), descriptor); } }\nfunction shadow_cache_createClass(Constructor, protoProps, staticProps) { if (protoProps) shadow_cache_defineProperties(Constructor.prototype, protoProps); if (staticProps) shadow_cache_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction shadow_cache_toPropertyKey(arg) { var key = shadow_cache_toPrimitive(arg, "string"); return shadow_cache_typeof(key) === "symbol" ? key : String(key); }\nfunction shadow_cache_toPrimitive(input, hint) { if (shadow_cache_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (shadow_cache_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction shadow_cache_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) shadow_cache_setPrototypeOf(subClass, superClass); }\nfunction shadow_cache_setPrototypeOf(o, p) { shadow_cache_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return shadow_cache_setPrototypeOf(o, p); }\nfunction shadow_cache_createSuper(Derived) { var hasNativeReflectConstruct = shadow_cache_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = shadow_cache_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = shadow_cache_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return shadow_cache_possibleConstructorReturn(this, result); }; }\nfunction shadow_cache_possibleConstructorReturn(self, call) { if (call && (shadow_cache_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return shadow_cache_assertThisInitialized(self); }\nfunction shadow_cache_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction shadow_cache_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction shadow_cache_getPrototypeOf(o) { shadow_cache_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return shadow_cache_getPrototypeOf(o); }\n\nvar ShadowCache = /*#__PURE__*/function (_Node) {\n  shadow_cache_inherits(ShadowCache, _Node);\n  var _super = shadow_cache_createSuper(ShadowCache);\n  function ShadowCache(configs) {\n    var _this;\n    shadow_cache_classCallCheck(this, ShadowCache);\n    _this = _super.call(this, configs);\n    // this.imageData = configs.imageData;\n    _this.width = configs.width;\n    _this.height = configs.height;\n    _this.imageBuffer = document.createElement(\'canvas\');\n    _this.imageBuffer.width = _this.width + 2;\n    _this.imageBuffer.height = _this.height + 2;\n    configs.cache(_this.imageBuffer.getContext(\'2d\'));\n    return _this;\n  }\n  shadow_cache_createClass(ShadowCache, [{\n    key: "render",\n    value: function render(ctx) {\n      var _this$anchor = shadow_cache_slicedToArray(this.anchor, 2),\n        cx = _this$anchor[0],\n        cy = _this$anchor[1];\n      ctx.save();\n      ctx.translate(cx, cy);\n      ctx.beginPath();\n      ctx.drawImage(this.imageBuffer, -this.width / 2, -this.height / 2);\n      ctx.translate(-cx, -cy);\n      ctx.restore();\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        height: this.height,\n        width: this.width\n      };\n    }\n  }, {\n    key: "recalculate",\n    value: function recalculate() {}\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var ltx = anchor[0] - w;\n      var lty = anchor[1] - h;\n      var rbx = anchor[0] + w;\n      var rby = anchor[1] + h;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }]);\n  return ShadowCache;\n}(node);\n/* harmony default export */ const shadow_cache = (ShadowCache);\n;// CONCATENATED MODULE: ./src/core/instance/elements/text.js\nfunction text_typeof(obj) { "@babel/helpers - typeof"; return text_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, text_typeof(obj); }\nfunction text_slicedToArray(arr, i) { return text_arrayWithHoles(arr) || text_iterableToArrayLimit(arr, i) || text_unsupportedIterableToArray(arr, i) || text_nonIterableRest(); }\nfunction text_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction text_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return text_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return text_arrayLikeToArray(o, minLen); }\nfunction text_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction text_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction text_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction text_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction text_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, text_toPropertyKey(descriptor.key), descriptor); } }\nfunction text_createClass(Constructor, protoProps, staticProps) { if (protoProps) text_defineProperties(Constructor.prototype, protoProps); if (staticProps) text_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction text_toPropertyKey(arg) { var key = text_toPrimitive(arg, "string"); return text_typeof(key) === "symbol" ? key : String(key); }\nfunction text_toPrimitive(input, hint) { if (text_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (text_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction text_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) text_setPrototypeOf(subClass, superClass); }\nfunction text_setPrototypeOf(o, p) { text_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return text_setPrototypeOf(o, p); }\nfunction text_createSuper(Derived) { var hasNativeReflectConstruct = text_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = text_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = text_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return text_possibleConstructorReturn(this, result); }; }\nfunction text_possibleConstructorReturn(self, call) { if (call && (text_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return text_assertThisInitialized(self); }\nfunction text_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction text_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction text_getPrototypeOf(o) { text_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return text_getPrototypeOf(o); }\n\n\n\n\nvar TEXT_ALIGN = {\n  CENTER: \'center\',\n  LEFT: \'left\',\n  RIGHT: \'right\'\n};\nvar SPACE_REG = /\\s/g;\nvar Text = /*#__PURE__*/function (_Rectangle) {\n  text_inherits(Text, _Rectangle);\n  var _super = text_createSuper(Text);\n  function Text(configs) {\n    var _this;\n    text_classCallCheck(this, Text);\n    _this = _super.call(this, configs);\n    _this.type = \'Text\';\n    _this.content = configs.content || \'\';\n    _this.fontFamily = configs.fontFamily || \'-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Tahoma,Arial,Noto Sans,PingFang SC,Microsoft YaHei,Hiragino Sans GB,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji\';\n    _this.fontSize = configs.fontSize || \'14px\';\n    _this.fontWeight = configs.fontWeight || \'\';\n    _this.textColor = configs.textColor || \'white\';\n    _this.placeholderColor = configs.placeholderColor || configs.textColor || \'white\';\n    _this.textAlign = configs.textAlign || TEXT_ALIGN.CENTER;\n    _this.textBaseline = configs.textBaseline || \'middle\';\n    _this.lineHeight = configs.lineHeight;\n    _this.indent = configs.indent || 0;\n    _this.backgroundColor = configs.backgroundColor;\n    _this.editable = configs.editable;\n    _this.definedWidth = configs.definedWidth;\n    _this.minWidth = configs.minWidth || 0;\n    _this.maxWidth = configs.maxWidth;\n    _this.ellipsis = configs.ellipsis;\n    _this.placeholder = configs.placeholder || \'\';\n    _this.emptyWhenInput = configs.emptyWhenInput || false;\n    _this.editting = false;\n    _this.disabled = configs.disabled;\n    _this.cursorColor = configs.cursorColor || \'#60CFC4\';\n    _this.textRangeColor = configs.textRangeColor || \'#4E75EC1A\';\n    _this.spacePlaceholder = configs.spacePlaceholder;\n    _this.spacePlaceholderColor = configs.spacePlaceholderColor;\n    _this.spaceRecords = [];\n    _this._spacedContentSegmnent = [];\n    _this._status = {\n      editing: false,\n      cursorshow: true,\n      cursoranime: null,\n      lastElapsed: 0,\n      refreshElapsed: false,\n      cursorDragging: false,\n      shiftOn: false,\n      oldVal: \'\',\n      inputElement: null\n    };\n    _this._cursorOffset = 0;\n    _this._textRange = {\n      enable: false,\n      rangefrom: null,\n      // offsetfrom\n      rangeTo: null,\n      // offsetto\n      initialRange: null // offset\n    };\n\n    if (_this.editable) {\n      _this._makeFunctional();\n    }\n    _this.preCalculateText();\n    _this.shadowCache();\n    return _this;\n  }\n  text_createClass(Text, [{\n    key: "replaceSpaceHolder",\n    value: function replaceSpaceHolder(content) {\n      var useCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (useCache) {\n        return content.replace(/\\s/g, this.spacePlaceholder);\n      }\n      var r = this.spaceRecords;\n      var p = this.spacePlaceholder;\n      r.length = 0;\n      var lastOffset;\n      var c = content.replace(/\\s/g, function (_, offset) {\n        if (lastOffset === undefined) {\n          lastOffset = offset;\n          r.push(offset);\n        }\n        if (offset - lastOffset > 1) {\n          r.push(lastOffset);\n          r.push(offset);\n        }\n        lastOffset = offset;\n        return p;\n      });\n      if (lastOffset !== undefined) {\n        r.push(lastOffset);\n      }\n      return c;\n    }\n  }, {\n    key: "currentContent",\n    get: function get() {\n      return this.content || this.placeholder || \'\';\n    }\n  }, {\n    key: "isEmpty",\n    get: function get() {\n      return !this.content;\n    }\n  }, {\n    key: "preCalculateText",\n    value: function preCalculateText() {\n      var _this2 = this;\n      requestCacheCanvas(function (ctx) {\n        ctx.beginPath();\n        ctx.font = "".concat(_this2.fontWeight, " ").concat(_this2.fontSize, " ").concat(_this2.fontFamily);\n        ctx.textAlign = _this2.textAlign;\n        ctx.textBaseline = _this2.textBaseline;\n        var t_h = parseInt(_this2.fontSize);\n        var content = _this2.currentContent;\n        if (_this2.spacePlaceholder) {\n          content = _this2.replaceSpaceHolder(content);\n        }\n        var _ctx$measureText = ctx.measureText(content),\n          fontBoundingBoxAscent = _ctx$measureText.fontBoundingBoxAscent,\n          fontBoundingBoxDescent = _ctx$measureText.fontBoundingBoxDescent,\n          width = _ctx$measureText.width;\n        _this2._textWidth = _this2.indent + width;\n        if (_this2.definedWidth) {\n          if (_this2.ellipsis && _this2._textWidth > _this2.definedWidth) {\n            var offset = _this2._calculateOffset(_this2.definedWidth - 12);\n            _this2.ellipsisContent = content.substring(0, offset) + \'...\';\n          } else {\n            _this2.ellipsisContent = content;\n          }\n          _this2.width = _this2.definedWidth;\n        } else if (_this2.maxWidth && _this2.ellipsis) {\n          if (_this2._textWidth > _this2.maxWidth) {\n            var ratio = _this2.maxWidth / _this2._textWidth;\n            var l = Math.floor(content.length * ratio - 3);\n            _this2.ellipsisContent = content.substring(0, l) + \'...\';\n          } else {\n            _this2.ellipsisContent = content;\n          }\n          _this2.width = Math.min(_this2.maxWidth, _this2._textWidth);\n        } else {\n          _this2.width = Math.max(_this2.minWidth, _this2._textWidth);\n        }\n        if (_this2.spacePlaceholder) {\n          var _ctx$measureText2 = ctx.measureText(_this2.spacePlaceholder),\n            s_width = _ctx$measureText2.width;\n          var r2 = _this2._spacedContentSegmnent;\n          var textColor = _this2.textColor;\n          var lastOffset = 0;\n          r2.length = 0;\n          if (_this2.spaceRecords.length) {\n            var r = _this2.spaceRecords;\n            var pcolor = _this2.spacePlaceholderColor;\n            var _l = r.length;\n            var i = 0;\n            while (i < _l) {\n              var f = r[i++];\n              var t = r[i++];\n              var q = content.substring(lastOffset, f);\n              r2.push([q, ctx.measureText(q).width, textColor]);\n              r2.push([content.substring(f, t + 1), (t - f + 1) * s_width, pcolor]);\n              lastOffset = t + 1;\n            }\n          }\n          if (lastOffset < content.length) {\n            var _q = content.substring(lastOffset);\n            r2.push([_q, ctx.measureText(_q).width, textColor]);\n          }\n        }\n        var height = Math.abs(fontBoundingBoxAscent) + Math.abs(fontBoundingBoxDescent) || t_h;\n        _this2._textHeight = height;\n        if (_this2.lineHeight) {\n          _this2.height = _this2.lineHeight;\n        } else {\n          _this2.height = height;\n        }\n      });\n    }\n  }, {\n    key: "shadowCache",\n    value: function shadowCache() {\n      var _this3 = this;\n      var scale = window.devicePixelRatio;\n      var w = this.width * scale;\n      var h = this.height * scale;\n      var i = this.indent * scale;\n      var size = parseInt(this.fontSize) * scale;\n      this._shadowCache = new shadow_cache({\n        width: w,\n        height: h,\n        cache: function cache(ctx) {\n          // const [cx, cy] = this.anchor;\n          // ctx.scale(4, 4)\n          ctx.translate(w / 2, h / 2);\n          var font = "".concat(_this3.fontWeight, " ").concat(size, "px ").concat(_this3.fontFamily);\n          ctx.font = font;\n          ctx.textAlign = _this3.textAlign;\n          ctx.textBaseline = _this3.textBaseline;\n          ctx.fillStyle = _this3.isEmpty ? _this3.placeholderColor : _this3.textColor;\n          var content = _this3.currentContent;\n          if (_this3.spacePlaceholder) {\n            if (_this3.textAlign === TEXT_ALIGN.LEFT) {\n              var hw = w / 2;\n              var _w = -hw + i / 2;\n              _this3._spacedContentSegmnent.forEach(function (seg) {\n                ctx.fillStyle = seg[2];\n                ctx.fillText(seg[0], _w, 0);\n                _w += seg[1] * scale;\n              });\n            }\n          } else {\n            if (_this3.ellipsisContent) {\n              content = _this3.ellipsisContent;\n            }\n            if (content) {\n              if (_this3.textAlign === TEXT_ALIGN.LEFT) {\n                var _hw = w / 2;\n                ctx.fillText(content, -_hw + i / 2, 0);\n              } else if (_this3.textAlign === TEXT_ALIGN.RIGHT) {\n                var _hw2 = w / 2;\n                ctx.fillText(content, _hw2, 0);\n              } else {\n                ctx.fillText(content, i / 2, 0);\n              }\n            }\n          }\n        }\n      });\n    }\n  }, {\n    key: "setConfig",\n    value: function setConfig(configs) {\n      var _this4 = this;\n      Object.keys(configs).forEach(function (k) {\n        if (configs[k] !== undefined && configs[k] !== null) {\n          _this4[k] = configs[k];\n          _this4._rawConfigs[k] = configs[k];\n        }\n      });\n      this.preCalculateText();\n      this.shadowCache();\n    }\n  }, {\n    key: "click",\n    value: function click() {\n      var _this5 = this;\n      if (!this._status.editing) {\n        var flag = true;\n        this.dispatchEvent(new events(\'edit\', {\n          target: this,\n          preventDefault: function preventDefault() {\n            flag = false;\n          }\n        }));\n        if (!flag) {\n          return;\n        }\n        var point = this._belongs._currentp;\n        var jflow = this._jflow;\n        if (point) {\n          this._cursorOffset = this._positionToCursorOffset(point);\n        } else {\n          this._cursorOffset = 0;\n        }\n        var inputElement = createInputElement(this._controlCallback.bind(this), this._defaultCallback.bind(this));\n        var wrapper = jflow.DOMwrapper;\n        wrapper.append(inputElement);\n        inputElement.focus({\n          preventScroll: true\n        });\n        jflow.setFocusInstance(this);\n        Object.assign(this._status, {\n          editing: true,\n          oldVal: this.content,\n          inputElement: inputElement,\n          cursoranime: jflow.requestJFlowAnime(function (elapsed) {\n            var lastElapsed = _this5._status.lastElapsed;\n            if (_this5._status.refreshElapsed) {\n              _this5._status.lastElapsed = elapsed;\n              _this5._status.refreshElapsed = false;\n            }\n            if (elapsed - lastElapsed > 500) {\n              _this5._status.cursorshow = !_this5._status.cursorshow;\n              _this5._status.lastElapsed = elapsed;\n            }\n          })\n        });\n        if (this.emptyWhenInput) {\n          this.content = \'\';\n        }\n        this.syncShadowInputPosition();\n      }\n    }\n  }, {\n    key: "_makeFunctional",\n    value: function _makeFunctional() {\n      var _this6 = this;\n      var blurHandler = function blurHandler(event) {\n        _this6._status.editing = false;\n        if (_this6._status.inputElement) {\n          _this6._status.inputElement.remove();\n        }\n        if (_this6._belongs) {\n          _this6._jflow.scheduleRender();\n        }\n      };\n      this.addEventListener(\'dblclick\', function (event) {\n        if (event.currentTarget !== _this6) {\n          return;\n        }\n        if (_this6._status.editing) {\n          _this6._selectFullRange();\n        }\n      });\n      this.addEventListener(\'click\', function (event) {\n        if (event.currentTarget !== _this6) {\n          return;\n        }\n        // event.detail.bubbles = false;\n        if (_this6._status.editing) {\n          var point = _this6._belongs._currentp;\n          var offset = _this6._positionToCursorOffset(point);\n          if (_this6._status.shiftOn) {\n            var initialRange = _this6._textRange.initialRange;\n            Object.assign(_this6._textRange, {\n              rangefrom: Math.min(offset, initialRange),\n              rangeTo: Math.max(offset, initialRange),\n              enable: true\n            });\n            _this6._cursorOffset = _this6._textRange.rangeTo;\n            _this6._status.inputElement.focus({\n              preventScroll: true\n            });\n            // this._refreshCursor();  \n          } else {\n            _this6._cursorOffset = offset;\n            _this6._status.inputElement.focus({\n              preventScroll: true\n            });\n            _this6._refreshCursor();\n            _this6.syncShadowInputPosition();\n          }\n        }\n        _this6.click();\n      });\n      this.addEventListener(\'blur\', function (event) {\n        var _this6$_status$cursor;\n        blurHandler(event);\n        _this6.dispatchEvent(new events(\'change\', {\n          target: _this6,\n          oldVal: _this6._status.oldVal,\n          val: _this6.content\n        }));\n        _this6._textRange.enable = false;\n        (_this6$_status$cursor = _this6._status.cursoranime) === null || _this6$_status$cursor === void 0 ? void 0 : _this6$_status$cursor.cancel();\n        Object.assign(_this6._status, {\n          editing: false,\n          cursorshow: true,\n          cursoranime: null,\n          lastElapsed: 0,\n          refreshElapsed: false,\n          cursorDragging: false,\n          shiftOn: false,\n          oldVal: \'\',\n          inputElement: null\n        });\n      });\n      this.addEventListener(\'instancePressStart\', function (event) {\n        if (_this6._status.editing && !_this6._status.shiftOn) {\n          event.detail.bubbles = false;\n          event.detail.preventDefault();\n          var point = _this6._belongs._currentp;\n          var c = _this6._positionToCursorOffset(point);\n          _this6._textRange.initialRange = c;\n          var jflow = event.detail.jflow;\n          var moved = false;\n          var t = function (e) {\n            moved = true;\n            var offsetX = e.offsetX,\n              offsetY = e.offsetY;\n            var p = jflow._calculatePointBack([offsetX, offsetY]);\n            jflow._stack.checkHit(p);\n            var point = _this6._belongs._currentp;\n            var c = _this6._positionToCursorOffset(point);\n            var initialRange = _this6._textRange.initialRange;\n            _this6._status.editing = false;\n            Object.assign(_this6._textRange, {\n              rangefrom: Math.min(c, initialRange),\n              rangeTo: Math.max(c, initialRange),\n              enable: true\n            });\n          }.bind(_this6);\n          document.addEventListener(\'pointermove\', t);\n          document.addEventListener(\'pointerup\', function (e) {\n            document.removeEventListener(\'pointermove\', t);\n            if (!moved) {\n              _this6._textRange.initialRange = null;\n              return;\n            }\n            var rangeTo = _this6._textRange.rangeTo;\n            _this6._cursorOffset = rangeTo;\n            _this6._status.editing = true;\n            _this6._status.inputElement.focus({\n              preventScroll: true\n            });\n            _this6._textRange.initialRange = null;\n          }, {\n            once: true\n          });\n        }\n      });\n    }\n  }, {\n    key: "_positionToCursorOffset",\n    value: function _positionToCursorOffset(point) {\n      var _point = text_slicedToArray(point, 1),\n        x = _point[0];\n      var w = this.width / 2;\n      var _this$anchor = text_slicedToArray(this.anchor, 1),\n        ox = _this$anchor[0];\n      var offsetX = x - (ox - w);\n      var cursorOffset = 0;\n      if (offsetX >= this._textWidth) {\n        cursorOffset = this.content.length;\n      } else {\n        cursorOffset = this._calculateOffset(offsetX);\n      }\n      return cursorOffset;\n    }\n  }, {\n    key: "_calculateOffset",\n    value: function _calculateOffset(offx) {\n      var _this7 = this;\n      var content = this.content;\n      if (this.spacePlaceholder) {\n        content = this.replaceSpaceHolder(content, true);\n      }\n      var maxL = content.length - 1;\n      var contentWidth = this._textWidth;\n      if (contentWidth === 0) {\n        return 0;\n      }\n      var allwidth = contentWidth;\n      var idx = Math.floor(offx / allwidth * maxL);\n      requestCacheCanvas(function (ctx) {\n        ctx.font = "".concat(_this7.fontSize, " ").concat(_this7.fontFamily);\n        var g1, g2;\n        var lastidx;\n        var c = content.substring(0, idx);\n        var c1 = content.substring(idx - 1, idx);\n        var c2 = content.substring(idx, idx + 1);\n        var w = ctx.measureText(c).width;\n        var w1 = ctx.measureText(c1).width;\n        var w2 = ctx.measureText(c2).width;\n        g1 = w - w1 / 2;\n        g2 = w + w2 / 2;\n        do {\n          if (g1 <= offx && g2 >= offx) {\n            break;\n          }\n          if (g1 > offx) {\n            // 左侧少了\n            var spanw = g2 - offx;\n            lastidx = idx;\n            if (spanw < 100) {\n              idx -= 1;\n            } else {\n              idx -= Math.floor(spanw / g2 * lastidx);\n            }\n            c = content.substring(idx, lastidx);\n            w -= ctx.measureText(c).width;\n          } else if (g2 < offx) {\n            // 右侧少了\n            var _spanw = offx - g1;\n            lastidx = idx;\n            if (_spanw < 100) {\n              idx += 1;\n            } else {\n              idx += Math.floor(_spanw / (allwidth - g1) * (maxL - lastidx));\n            }\n            c = content.substring(lastidx, idx);\n            w += ctx.measureText(c).width;\n          }\n          c1 = content.substring(idx - 1, idx);\n          c2 = content.substring(idx, idx + 1);\n          w1 = ctx.measureText(c1).width;\n          w2 = ctx.measureText(c2).width;\n          g1 = w - w1 / 2;\n          g2 = w + w2 / 2;\n        } while (idx >= 0 && idx <= maxL);\n      });\n      return idx;\n    }\n  }, {\n    key: "_refreshCursor",\n    value: function _refreshCursor() {\n      if (this._status.editing) {\n        Object.assign(this._status, {\n          cursorshow: true,\n          refreshElapsed: true\n        });\n      }\n      if (this._textRange.enable) {\n        this._textRange.enable = false;\n      }\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      if (!ctx.disableCache && !this._status.editing && this._jflow.scale * parseInt(this.fontSize) < 8) {\n        var _this$anchor2 = text_slicedToArray(this.anchor, 2),\n          cx = _this$anchor2[0],\n          cy = _this$anchor2[1];\n        // this._shadowCache.render(ctx);\n        ctx.save();\n        ctx.translate(cx, cy);\n        ctx.beginPath();\n        ctx.drawImage(this._shadowCache.imageBuffer, -this.width / 2, -this.height / 2, this.width, this.height);\n        ctx.translate(-cx, -cy);\n        ctx.restore();\n        return;\n      }\n      var font = "".concat(this.fontWeight, " ").concat(this.fontSize, " ").concat(this.fontFamily);\n      if (ctx.font !== font) {\n        ctx.font = font;\n      }\n      if (ctx.textAlign !== this.textAlign) {\n        ctx.textAlign = this.textAlign;\n      }\n      if (ctx.textBaseline !== this.textBaseline) {\n        ctx.textBaseline = this.textBaseline;\n      }\n      ctx.fillStyle = this.isEmpty ? this.placeholderColor : this.textColor;\n      var content = this.currentContent;\n      if (this.spacePlaceholder) {\n        if (this.textAlign === TEXT_ALIGN.LEFT) {\n          var _hw3 = this.width / 2;\n          var w = this.anchor[0] - _hw3 + this.indent / 2;\n          var _y = this.anchor[1];\n          this._spacedContentSegmnent.forEach(function (seg) {\n            ctx.fillStyle = seg[2];\n            ctx.fillText(seg[0], w, _y);\n            w += seg[1];\n          });\n        }\n      } else {\n        if (this.ellipsisContent) {\n          content = this.ellipsisContent;\n        }\n        if (content) {\n          if (this.textAlign === TEXT_ALIGN.LEFT) {\n            var _hw4 = this.width / 2;\n            ctx.fillText(content, this.anchor[0] - _hw4 + this.indent / 2, this.anchor[1]);\n          } else if (this.textAlign === TEXT_ALIGN.RIGHT) {\n            var _hw5 = this.width / 2;\n            ctx.fillText(content, this.anchor[0] + _hw5, this.anchor[1]);\n          } else {\n            ctx.fillText(content, this.anchor[0] + this.indent / 2, this.anchor[1]);\n          }\n        }\n      }\n      var hw = this.width / 2;\n      var textheight = this._textHeight;\n      var _this$anchor3 = text_slicedToArray(this.anchor, 2),\n        x = _this$anchor3[0],\n        y = _this$anchor3[1];\n      var lx = x - hw;\n      var ly = y - textheight / 2;\n      if (this._status.cursorshow && this._status.editing) {\n        var offset = this._cursorOffset;\n        var c = content.substring(0, offset);\n        if (this.spacePlaceholder) {\n          c = this.replaceSpaceHolder(c, true);\n        }\n        var cw = lx + ctx.measureText(c).width;\n        var c_len = this._textHeight / 2;\n        ctx.beginPath();\n        ctx.moveTo(cw, y - c_len);\n        ctx.lineTo(cw, y + c_len);\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = this.cursorColor;\n        ctx.stroke();\n      }\n      if (this._textRange.enable) {\n        var _this$_textRange = this._textRange,\n          rangefrom = _this$_textRange.rangefrom,\n          rangeTo = _this$_textRange.rangeTo;\n        var _c = this.content.substring(0, rangefrom);\n        var range = this.content.substring(rangefrom, rangeTo);\n        var _x2 = lx + ctx.measureText(_c).width;\n        var _w2 = ctx.measureText(range).width;\n        ctx.beginPath();\n        ctx.rect(_x2, ly, _w2, textheight);\n        ctx.fillStyle = this.textRangeColor;\n        ctx.fill();\n      }\n    }\n  }, {\n    key: "_inputControl",\n    value: function _inputControl(op, data) {\n      if (this._textRange.enable) {\n        this._clearTextRange();\n        if (op === \'Backspace\') {\n          this.dispatchEvent(new events(\'input\', {\n            target: this,\n            oldVal: this._status.oldVal,\n            val: this.content\n          }));\n          this.refresh();\n          this.syncShadowInputPosition();\n          return;\n        }\n      }\n      var offset = this._cursorOffset;\n      var content = this.content;\n      var preContent = content.substring(0, offset);\n      var afterContent;\n      if (this.cacheIdx) {\n        afterContent = content.substring(this.cacheIdx[1]);\n      } else {\n        afterContent = content.substring(offset);\n      }\n      var stopInputEvent = false;\n      switch (op) {\n        case "Input":\n          preContent += data;\n          this._cursorOffset += data.length;\n          this.content = preContent + afterContent;\n          break;\n        case "compositionstart":\n          this.cacheIdx = [preContent.length, preContent.length];\n          break;\n        case "compositionupdate":\n          preContent = preContent.substring(0, this.cacheIdx[0]);\n          preContent += data;\n          this.content = preContent + afterContent;\n          this._cursorOffset = this.cacheIdx[0] + data.length;\n          this.cacheIdx[1] = this.cacheIdx[0] + data.length;\n          break;\n        case "compositionend":\n          preContent = preContent.substring(0, this.cacheIdx[0]);\n          this._cursorOffset = this.cacheIdx[0] + data.length;\n          this.cacheIdx = null;\n          preContent += data;\n          this.content = preContent + afterContent;\n          break;\n        case "Enter":\n          if (this.cacheIdx) {\n            return;\n          }\n          var defaultAct = true;\n          this.dispatchEvent(new events(\'enterkeypressed\', {\n            target: this,\n            handler: function handler(val) {\n              defaultAct = val;\n            },\n            stopInput: function stopInput() {\n              stopInputEvent = true;\n            }\n          }));\n          if (defaultAct) {\n            this._jflow.blur();\n          }\n          break;\n        case "Backspace":\n          if (this.cacheIdx) {\n            return;\n          }\n          preContent = preContent.substring(0, preContent.length - 1);\n          this._cursorOffset = Math.max(0, this._cursorOffset - 1);\n          this.content = preContent + afterContent;\n          break;\n      }\n      if (!stopInputEvent) {\n        this.dispatchEvent(new events(\'input\', {\n          target: this,\n          oldVal: this._status.oldVal,\n          val: this.content\n        }));\n      }\n      this.refresh();\n      this.syncShadowInputPosition();\n    }\n  }, {\n    key: "refresh",\n    value: function refresh() {\n      this.preCalculateText();\n      this._belongs.recalculateUp();\n      this._jflow.scheduleRender();\n    }\n  }, {\n    key: "syncShadowInputPosition",\n    value: function syncShadowInputPosition() {\n      var _this8 = this;\n      if (this._status.editing) {\n        var hw = this.width / 2;\n        var hh = this.height / 2;\n        var lx = this.anchor[0] - hw;\n        var offset = this._cursorOffset;\n        requestCacheCanvas(function (ctx) {\n          ctx.beginPath();\n          ctx.font = "".concat(_this8.fontSize, " ").concat(_this8.fontFamily);\n          var c = _this8.content.substring(0, offset);\n          lx += ctx.measureText(c).width;\n        });\n        var point = this.calculateToRealWorld([lx, hh]);\n        var canvasMeta = this._jflow.canvasMeta;\n        var px = Math.min(canvasMeta.actual_width - 120, point[0]);\n        this._status.inputElement.style.transform = "translate(".concat(px, "px, ").concat(point[1], "px)");\n      }\n    }\n  }, {\n    key: "_controlCallback",\n    value: function _controlCallback(op, data, e) {\n      if (this._status.editing) {\n        Object.assign(this._status, {\n          cursorshow: true,\n          refreshElapsed: true\n        });\n      }\n      switch (op) {\n        case "Input":\n        case "compositionstart":\n        case "compositionupdate":\n        case "compositionend":\n        case "Enter":\n        case "Backspace":\n          this._inputControl(op, data);\n          break;\n        case "ArrowLeft":\n          if (this._textRange.enable) {\n            this._textRange.enable = false;\n          }\n          this._onArrowLeft();\n          break;\n        case "ArrowRight":\n          if (this._textRange.enable) {\n            this._textRange.enable = false;\n          }\n          this._onArrowRight();\n          break;\n        case "Shift":\n          this._onShiftToggle(data);\n          break;\n        case "CtrlA":\n          this._selectFullRange();\n          break;\n        case "COPY":\n          this._copy(e);\n          break;\n        case "CUT":\n          this._cut(e);\n          break;\n        case "PASTE":\n          this._paste(e);\n          break;\n      }\n    }\n  }, {\n    key: "_onArrowLeft",\n    value: function _onArrowLeft() {\n      this._cursorOffset = Math.max(0, this._cursorOffset - 1);\n      this._jflow.scheduleRender();\n      this.syncShadowInputPosition();\n    }\n  }, {\n    key: "_onArrowRight",\n    value: function _onArrowRight() {\n      this._cursorOffset = Math.min(this.content.length, this._cursorOffset + 1);\n      this._jflow.scheduleRender();\n      this.syncShadowInputPosition();\n    }\n  }, {\n    key: "_onShiftToggle",\n    value: function _onShiftToggle(val) {\n      this._status.shiftOn = val;\n      if (val) {\n        this._textRange.initialRange = this._cursorOffset;\n      } else {\n        this._textRange.initialRange = null;\n      }\n    }\n  }, {\n    key: "_selectFullRange",\n    value: function _selectFullRange() {\n      this._textRange = {\n        enable: true,\n        rangefrom: 0,\n        rangeTo: this.content.length\n      };\n      this._cursorOffset = this.content.length;\n    }\n  }, {\n    key: "_clearTextRange",\n    value: function _clearTextRange() {\n      if (this._textRange.enable) {\n        var _this$_textRange2 = this._textRange,\n          rangefrom = _this$_textRange2.rangefrom,\n          rangeTo = _this$_textRange2.rangeTo;\n        var content = this.content;\n        var preContent = content.substring(0, rangefrom);\n        var afterContent = content.substring(rangeTo);\n        this.content = preContent + afterContent;\n        this._cursorOffset = preContent.length;\n        this._textRange.enable = false;\n      }\n    }\n  }, {\n    key: "_getSelection",\n    value: function _getSelection() {\n      if (this._textRange.enable) {\n        var _this$_textRange3 = this._textRange,\n          rangefrom = _this$_textRange3.rangefrom,\n          rangeTo = _this$_textRange3.rangeTo;\n        var content = this.content;\n        return content.substring(rangefrom, rangeTo);\n      }\n      return null;\n    }\n  }, {\n    key: "_copy",\n    value: function _copy(event) {\n      var selection = this._getSelection();\n      if (selection) {\n        event.clipboardData.setData("text/plain", selection);\n      }\n    }\n  }, {\n    key: "_cut",\n    value: function _cut(event) {\n      var selection = this._getSelection();\n      if (selection) {\n        event.clipboardData.setData("text/plain", selection);\n        this._clearTextRange();\n        this.refresh();\n      }\n    }\n  }, {\n    key: "_paste",\n    value: function _paste(event) {\n      var pasteContent = (event.clipboardData || window.clipboardData).getData("text");\n      var flag = false;\n      this.dispatchEvent(new events(\'paste\', {\n        target: this,\n        content: pasteContent,\n        preventDefault: function preventDefault() {\n          flag = true;\n        },\n        resolvePasteContent: function resolvePasteContent(callback) {\n          pasteContent = callback(pasteContent);\n        }\n      }));\n      if (flag) {\n        return;\n      }\n      this._clearTextRange();\n      var offset = this._cursorOffset;\n      var content = this.content;\n      var preContent = content.substring(0, offset);\n      var afterContent = content.substring(offset);\n      this.content = preContent + pasteContent + afterContent;\n      this._cursorOffset = (preContent + pasteContent).length;\n      this.refresh();\n    }\n  }, {\n    key: "_defaultCallback",\n    value: function _defaultCallback(op, e) {\n      switch (op) {\n        case \'KeyDown\':\n          this.dispatchEvent(new events(\'keydown\', {\n            target: this,\n            key: e.key,\n            code: e.code,\n            rawEvent: e\n          }));\n          break;\n        case \'KeyUp\':\n          this.dispatchEvent(new events(\'keyup\', {\n            target: this,\n            key: e.key,\n            code: e.code,\n            rawEvent: e\n          }));\n          break;\n      }\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      if (this._jflow._focus.instance === this) {\n        this._jflow.blur();\n      }\n    }\n  }]);\n  return Text;\n}(rectangle);\n/* harmony default export */ const elements_text = (Text);\nfunction createInputElement(controlCallback, defaultCallback) {\n  var input = document.createElement(\'input\');\n  input.setAttribute(\'style\', "\\n        width: 100px;\\n        position: absolute;\\n        left: 0;\\n        top: 0;\\n        border:none;\\n        opacity: 0;\\n        z-index: -1;\\n        contain: strict;");\n  input.setAttribute(\'tabindex\', -1);\n  input.setAttribute(\'spellcheck\', false);\n  input.setAttribute(\'autocorrect\', \'off\');\n\n  // let content = configs.content;\n  // let startidx = 0;\n\n  // function renderContent() {\n  //     configs.callback(content)\n  // }\n  var stopInput = false;\n  var status = {\n    ctrlOn: false\n  };\n  input.addEventListener(\'beforeinput\', function (e) {\n    e.preventDefault();\n    if (e.data) {\n      // content += e.data;\n      // renderContent();\n      if (!stopInput) {\n        controlCallback(\'Input\', e.data);\n      }\n    }\n  });\n  input.addEventListener(\'compositionstart\', function (e) {\n    // cache composition start offset\n    // startidx = content.length;\n    controlCallback(\'compositionstart\');\n    stopInput = true;\n  });\n  input.addEventListener(\'compositionupdate\', function (e) {\n    // update content\n    // content = content.substring(0, startidx);\n    // content += e.data;\n    // renderContent();\n    controlCallback(\'compositionupdate\', e.data);\n  });\n  input.addEventListener(\'compositionend\', function (e) {\n    // replace text at start offset\n    // content = content.substring(0, startidx);\n    // startidx = 0;\n    // content += e.data;\n    // renderContent();\n    controlCallback(\'compositionend\', e.data);\n    input.value = \'\';\n    stopInput = false;\n  });\n  input.addEventListener(\'keyup\', function (event) {\n    switch (event.key) {\n      case "Shift":\n        controlCallback("Shift", false);\n        break;\n      case "Meta":\n      case "Control":\n        status.ctrlOn = false;\n        break;\n    }\n  });\n  input.addEventListener(\'keydown\', function (event) {\n    switch (event.code) {\n      case "Enter":\n        // content = content + \'\\n\';\n        // renderContent();\n        controlCallback(\'Enter\');\n        break;\n      case "Backspace":\n        // content = content.substring(0, content.length - 1);\n        // renderContent();\n        controlCallback(\'Backspace\');\n        break;\n      case "ArrowLeft":\n        controlCallback("ArrowLeft");\n        break;\n      case "ArrowRight":\n        controlCallback("ArrowRight");\n        break;\n      case "ArrowDown":\n        controlCallback("ArrowDown");\n        break;\n      case "ArrowUp":\n        controlCallback("ArrowUp");\n        break;\n    }\n    switch (event.key) {\n      case "Shift":\n        controlCallback("Shift", true);\n        break;\n      case "Meta":\n      case "Control":\n        status.ctrlOn = true;\n        break;\n      case \'a\':\n        if (status.ctrlOn) {\n          controlCallback(\'CtrlA\');\n        }\n        break;\n    }\n  });\n  input.addEventListener(\'keyup\', function (event) {\n    defaultCallback(\'KeyUp\', event);\n  });\n  input.addEventListener(\'keydown\', function (event) {\n    defaultCallback(\'KeyDown\', event);\n  });\n  input.addEventListener(\'copy\', function (event) {\n    event.preventDefault();\n    event.stopPropagation();\n    controlCallback(\'COPY\', null, event);\n  });\n  input.addEventListener(\'cut\', function (event) {\n    event.preventDefault();\n    event.stopPropagation();\n    controlCallback(\'CUT\', null, event);\n  });\n  input.addEventListener(\'paste\', function (event) {\n    event.preventDefault();\n    event.stopPropagation();\n    controlCallback(\'PASTE\', null, event);\n  });\n  return input;\n}\n;// CONCATENATED MODULE: ./src/core/instance/image.js\nfunction image_typeof(obj) { "@babel/helpers - typeof"; return image_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, image_typeof(obj); }\nfunction image_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction image_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, image_toPropertyKey(descriptor.key), descriptor); } }\nfunction image_createClass(Constructor, protoProps, staticProps) { if (protoProps) image_defineProperties(Constructor.prototype, protoProps); if (staticProps) image_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction image_toPropertyKey(arg) { var key = image_toPrimitive(arg, "string"); return image_typeof(key) === "symbol" ? key : String(key); }\nfunction image_toPrimitive(input, hint) { if (image_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (image_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction image_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) image_setPrototypeOf(subClass, superClass); }\nfunction image_setPrototypeOf(o, p) { image_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return image_setPrototypeOf(o, p); }\nfunction image_createSuper(Derived) { var hasNativeReflectConstruct = image_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = image_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = image_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return image_possibleConstructorReturn(this, result); }; }\nfunction image_possibleConstructorReturn(self, call) { if (call && (image_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return image_assertThisInitialized(self); }\nfunction image_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction image_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction image_getPrototypeOf(o) { image_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return image_getPrototypeOf(o); }\n\n\n\n\n\n\n/**\n * @typedef {Object} Icon~ImageBounding\n * @property {number} width   - 图片宽度\n * @property {number} height   - 图片高度 \n */\n/**\n * 图片单元 配置\n * @typedef {Rectangle~RectangleConfigs} Icon~IconConfigs\n * @property {number} image   - 图片地址\n * @property {number} imageWidth   - 图片宽度\n * @property {number} imageHeight   - 图片高度\n */\n\n/**\n * 图片单元\n * @description 图片单元可以绘制图片，图片加载后会自动重新绘制\n * @constructor Icon\n * @extends Rectangle\n * @param {Icon~IconConfigs} configs - 配置\n */\nvar Icon = /*#__PURE__*/function (_Rectangle) {\n  image_inherits(Icon, _Rectangle);\n  var _super = image_createSuper(Icon);\n  function Icon(configs) {\n    var _this;\n    image_classCallCheck(this, Icon);\n    _this = _super.call(this, configs);\n    /** @member {CanvasImageSource}      - 图片 */\n    _this.image = configs.image;\n    _this.image.onload = function () {\n      _this._jflow._render();\n      // requestAnimationFrame(() => {\n\n      // })\n    };\n    /** @member {Icon~ImageBounding}      - 图片维度 */\n    _this.imageBounding = {\n      width: configs.imageWidth || configs.width,\n      height: configs.imageHeight || configs.height\n    };\n    return _this;\n  }\n  image_createClass(Icon, [{\n    key: "setConfig",\n    value: function setConfig(configs) {\n      var _this2 = this;\n      Object.keys(configs).forEach(function (k) {\n        if (configs[k] !== undefined && configs[k] !== null) {\n          _this2[k] = configs[k];\n          _this2._rawConfigs[k] = configs[k];\n        }\n      });\n      if (configs.image && !configs.image.complete) {\n        this.image.onload = function () {\n          _this2._jflow._render();\n          // requestAnimationFrame(() => {\n          //     this._jflow._render();\n          // })\n        };\n      }\n\n      this.imageBounding = {\n        width: configs.imageWidth || configs.width || this.imageBounding.width,\n        height: configs.imageHeight || configs.height || this.imageBounding.height\n      };\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      }\n      rectangle.prototype.render.call(this, ctx);\n      var x = this.anchor[0] - this.width / 2;\n      var y = this.anchor[1] - this.height / 2;\n      if (this.opacity < 1) {\n        ctx.globalAlpha = this.opacity;\n      }\n      if (this.image.complete) {\n        ctx.drawImage(this.image, x, y, this.imageBounding.width, this.imageBounding.height);\n      }\n      ctx.restore();\n    }\n  }]);\n  return Icon;\n}(rectangle);\n/* harmony default export */ const instance_image = (Icon);\n;// CONCATENATED MODULE: ./src/core/instance/shadowDom.js\nfunction shadowDom_typeof(obj) { "@babel/helpers - typeof"; return shadowDom_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, shadowDom_typeof(obj); }\nfunction shadowDom_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction shadowDom_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, shadowDom_toPropertyKey(descriptor.key), descriptor); } }\nfunction shadowDom_createClass(Constructor, protoProps, staticProps) { if (protoProps) shadowDom_defineProperties(Constructor.prototype, protoProps); if (staticProps) shadowDom_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction shadowDom_toPropertyKey(arg) { var key = shadowDom_toPrimitive(arg, "string"); return shadowDom_typeof(key) === "symbol" ? key : String(key); }\nfunction shadowDom_toPrimitive(input, hint) { if (shadowDom_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (shadowDom_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction shadowDom_get() { if (typeof Reflect !== "undefined" && Reflect.get) { shadowDom_get = Reflect.get.bind(); } else { shadowDom_get = function _get(target, property, receiver) { var base = shadowDom_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return shadowDom_get.apply(this, arguments); }\nfunction shadowDom_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = shadowDom_getPrototypeOf(object); if (object === null) break; } return object; }\nfunction shadowDom_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) shadowDom_setPrototypeOf(subClass, superClass); }\nfunction shadowDom_setPrototypeOf(o, p) { shadowDom_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return shadowDom_setPrototypeOf(o, p); }\nfunction shadowDom_createSuper(Derived) { var hasNativeReflectConstruct = shadowDom_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = shadowDom_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = shadowDom_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return shadowDom_possibleConstructorReturn(this, result); }; }\nfunction shadowDom_possibleConstructorReturn(self, call) { if (call && (shadowDom_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return shadowDom_assertThisInitialized(self); }\nfunction shadowDom_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction shadowDom_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction shadowDom_getPrototypeOf(o) { shadowDom_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return shadowDom_getPrototypeOf(o); }\n\n/**\n * @funtion domFactory\n * @param {Element} container - DOM容器\n */\n/**\n * DOM元素容器 配置\n * @typedef {Rectangle~Configs} ShadowDom~RectangleConfigs\n * @property {domFactory} createDocument - 宽\n */\n/**\n * DOM元素容器 内容可贴 DOM 元素，支持缩放平移\n * @constructor ShadowDom\n * @extends Rectangle\n * @param {ShadowDom~RectangleConfigs} configs\n */\nvar ShadowDom = /*#__PURE__*/function (_Rectangle) {\n  shadowDom_inherits(ShadowDom, _Rectangle);\n  var _super = shadowDom_createSuper(ShadowDom);\n  function ShadowDom(configs) {\n    var _this;\n    shadowDom_classCallCheck(this, ShadowDom);\n    _this = _super.call(this, configs);\n    _this.domFactory = configs.createDocument;\n    _this._dom = null;\n    return _this;\n  }\n  shadowDom_createClass(ShadowDom, [{\n    key: "getRealWorldPosition",\n    value: function getRealWorldPosition() {\n      var b = this.getBoundingRect();\n      return this.calculateToRealWorld(b.slice(0, 2));\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      var _this2 = this;\n      if (!this._dom && this.domFactory) {\n        requestAnimationFrame(function () {\n          if (!_this2._dom) {\n            var container = document.createElement(\'div\');\n            var pos = _this2.getRealWorldPosition();\n            var scale = _this2._jflow.scale;\n            container.setAttribute(\'style\', "\\n                        position: absolute;\\n                        width: ".concat(_this2.width, "px;\\n                        height: ").concat(_this2.height, "px;\\n                        transform-origin: left top;\\n                        top: 0;\\n                        left: 0;\\n                        transform: translate(").concat(pos[0], "px, ").concat(pos[1], "px) scale(").concat(scale, ");"));\n            _this2._dom = container;\n            _this2._jflow.DOMwrapper.appendChild(container);\n            _this2.domFactory(container);\n          }\n        });\n      } else {\n        var pos = this.getRealWorldPosition();\n        var scale = this._jflow.scale;\n        this._dom.style.transform = "translate(".concat(pos[0], "px, ").concat(pos[1], "px) scale(").concat(scale, ")");\n      }\n      shadowDom_get(shadowDom_getPrototypeOf(ShadowDom.prototype), "render", this).call(this, ctx);\n    }\n  }, {\n    key: "onEnterViewbox",\n    value: function onEnterViewbox() {\n      if (this._dom) {\n        this._dom.style.display = \'block\';\n      }\n    }\n  }, {\n    key: "onLeaveViewbox",\n    value: function onLeaveViewbox() {\n      if (this._dom) {\n        this._dom.style.display = \'none\';\n      }\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      if (this._dom) {\n        this._jflow.DOMwrapper.removeChild(this._dom);\n      }\n      shadowDom_get(shadowDom_getPrototypeOf(ShadowDom.prototype), "destroy", this).call(this);\n    }\n  }]);\n  return ShadowDom;\n}(rectangle);\n/* harmony default export */ const shadowDom = (ShadowDom);\n;// CONCATENATED MODULE: ./src/core/instance/link.js\nfunction link_typeof(obj) { "@babel/helpers - typeof"; return link_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, link_typeof(obj); }\nfunction link_slicedToArray(arr, i) { return link_arrayWithHoles(arr) || link_iterableToArrayLimit(arr, i) || link_unsupportedIterableToArray(arr, i) || link_nonIterableRest(); }\nfunction link_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction link_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return link_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return link_arrayLikeToArray(o, minLen); }\nfunction link_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction link_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction link_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction link_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction link_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, link_toPropertyKey(descriptor.key), descriptor); } }\nfunction link_createClass(Constructor, protoProps, staticProps) { if (protoProps) link_defineProperties(Constructor.prototype, protoProps); if (staticProps) link_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction link_toPropertyKey(arg) { var key = link_toPrimitive(arg, "string"); return link_typeof(key) === "symbol" ? key : String(key); }\nfunction link_toPrimitive(input, hint) { if (link_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (link_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction link_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) link_setPrototypeOf(subClass, superClass); }\nfunction link_setPrototypeOf(o, p) { link_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return link_setPrototypeOf(o, p); }\nfunction link_createSuper(Derived) { var hasNativeReflectConstruct = link_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = link_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = link_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return link_possibleConstructorReturn(this, result); }; }\nfunction link_possibleConstructorReturn(self, call) { if (call && (link_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return link_assertThisInitialized(self); }\nfunction link_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction link_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction link_getPrototypeOf(o) { link_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return link_getPrototypeOf(o); }\n\n\n\n/**\n * @typedef {BaseLink~Configs} Link~Configs\n * @property {Number} approximate   - 点击响应范围\n * @property {Number[]} lineDash    - 虚线数组\n * @property {Boolean} doubleLink   - 双向箭头\n * @property {String} fontFamily    - 连线上的文字字体\n * @property {Number} fontSize      - 连线上的文字大小\n * @property {String} content       - 连线上的文字\n */\n/**\n * 直线\n * @constructor Link\n * @extends BaseLink\n * @param {Link~Configs} configs - 配置\n */\nvar Link = /*#__PURE__*/function (_BaseLink) {\n  link_inherits(Link, _BaseLink);\n  var _super = link_createSuper(Link);\n  function Link(configs) {\n    var _this;\n    link_classCallCheck(this, Link);\n    _this = _super.call(this, configs);\n    _this.fontFamily = configs.fontFamily = \'-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Tahoma,Arial,Noto Sans,PingFang SC,Microsoft YaHei,Hiragino Sans GB,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji\';\n    _this.fontSize = configs.fontSize || \'12px\';\n    _this.content = configs.content || \'\';\n    _this.lineDash = configs.lineDash;\n    _this.approximate = configs.approximate || APPROXIMATE;\n    _this._cacheAngle = undefined;\n    _this._cachePoints = [];\n    _this._cacheBoundingbox = {\n      from: [],\n      to: []\n    };\n    return _this;\n  }\n  link_createClass(Link, [{\n    key: "_calculateAnchorPoints",\n    value: function _calculateAnchorPoints() {\n      var p0 = this.from.calculateIntersection(this.to.getCenter());\n      var p1 = this.to.calculateIntersection(this.from.getCenter());\n      this._cachePoints[0] = p0;\n      this._cachePoints[1] = p1;\n      var dx = p1[0] - p0[0];\n      var dy = p1[1] - p0[1];\n      var angle = Math.atan2(dy, dx);\n      this._cacheAngle = angle;\n    }\n  }, {\n    key: "isInViewBox",\n    value: function isInViewBox(br) {\n      var frombox = this.from.getBoundingRect();\n      var tobox = this.to.getBoundingRect();\n      var _box = this._cacheBoundingbox;\n      if (!compareBoundingbox(_box.from, frombox) || compareBoundingbox(_box.to, tobox)) {\n        copyBoundingbox(_box.from, frombox);\n        copyBoundingbox(_box.to, tobox);\n        this._calculateAnchorPoints();\n      }\n      return true;\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      var _this$_cachePoints = link_slicedToArray(this._cachePoints, 2),\n        p0 = _this$_cachePoints[0],\n        p1 = _this$_cachePoints[1];\n      var angle = this._cacheAngle;\n      var dx = p1[0] - p0[0];\n      var dy = p1[1] - p0[1];\n      ctx.fillStyle = ctx.strokeStyle = this.backgroundColor;\n      ctx.beginPath();\n      if (this.content) {\n        ctx.textAlign = \'center\';\n        ctx.font = "".concat(this.fontSize, " ").concat(this.fontFamily);\n        ctx.textBaseline = \'middle\';\n        var _ctx$measureText = ctx.measureText(this.content),\n          actualBoundingBoxLeft = _ctx$measureText.actualBoundingBoxLeft,\n          actualBoundingBoxRight = _ctx$measureText.actualBoundingBoxRight,\n          fontBoundingBoxAscent = _ctx$measureText.fontBoundingBoxAscent,\n          fontBoundingBoxDescent = _ctx$measureText.fontBoundingBoxDescent;\n        var x = dx / 2 + p0[0];\n        var y = dy / 2 + p0[1];\n        ctx.fillText(this.content, x, y);\n        var width = Math.abs(actualBoundingBoxLeft) + Math.abs(actualBoundingBoxRight) + 20;\n        var height = (Math.abs(fontBoundingBoxAscent) + Math.abs(fontBoundingBoxDescent)) * 1.5;\n        ctx.beginPath();\n        var region = new Path2D();\n        region.rect(x - width / 2, y - height / 2, width, height);\n        var rx = Math.min(p1[0], p0[0]) - 10;\n        var ry = Math.min(p1[1], p0[1]) - 10;\n        var rw = Math.abs(dx) + 20;\n        var rh = Math.abs(dy) + 20;\n        region.rect(rx, ry, rw, rh);\n        ctx.clip(region, "evenodd");\n      }\n      ctx.moveTo(p0[0], p0[1]);\n      ctx.lineTo(p1[0], p1[1]);\n      if (this.lineDash) {\n        ctx.save();\n        ctx.setLineDash(this.lineDash);\n      }\n      ctx.stroke();\n      if (this.lineDash) {\n        ctx.restore();\n      }\n      ctx.translate(p1[0], p1[1]);\n      ctx.rotate(angle);\n      ctx.moveTo(0, 0);\n      ctx.lineTo(-5, -4);\n      ctx.lineTo(-5, 4);\n      ctx.lineTo(0, 0);\n      ctx.fill();\n      ctx.rotate(-angle);\n      ctx.translate(-p1[0], -p1[1]);\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      if (!this._cachePoints) return false;\n      var _this$_cachePoints2 = link_slicedToArray(this._cachePoints, 2),\n        start = _this$_cachePoints2[0],\n        end = _this$_cachePoints2[1];\n      var dist = distToSegmentSquared(point, start, end);\n      return dist < this.approximate;\n    }\n  }]);\n  return Link;\n}(base_link);\n/* harmony default export */ const instance_link = (Link);\n;// CONCATENATED MODULE: ./src/core/instance/poly-link.js\nfunction poly_link_typeof(obj) { "@babel/helpers - typeof"; return poly_link_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, poly_link_typeof(obj); }\nfunction poly_link_defineProperty(obj, key, value) { key = poly_link_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction poly_link_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction poly_link_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, poly_link_toPropertyKey(descriptor.key), descriptor); } }\nfunction poly_link_createClass(Constructor, protoProps, staticProps) { if (protoProps) poly_link_defineProperties(Constructor.prototype, protoProps); if (staticProps) poly_link_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction poly_link_toPropertyKey(arg) { var key = poly_link_toPrimitive(arg, "string"); return poly_link_typeof(key) === "symbol" ? key : String(key); }\nfunction poly_link_toPrimitive(input, hint) { if (poly_link_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (poly_link_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction poly_link_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) poly_link_setPrototypeOf(subClass, superClass); }\nfunction poly_link_setPrototypeOf(o, p) { poly_link_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return poly_link_setPrototypeOf(o, p); }\nfunction poly_link_createSuper(Derived) { var hasNativeReflectConstruct = poly_link_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = poly_link_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = poly_link_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return poly_link_possibleConstructorReturn(this, result); }; }\nfunction poly_link_possibleConstructorReturn(self, call) { if (call && (poly_link_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return poly_link_assertThisInitialized(self); }\nfunction poly_link_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction poly_link_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction poly_link_getPrototypeOf(o) { poly_link_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return poly_link_getPrototypeOf(o); }\n\n\n\n// import { dist2, bezierPoint } from \'../utils/functions\';\nvar PIINRATIO = Math.PI / 180;\n/**\n * @typedef {BaseLink~Configs} PolyLink~Configs\n * @property {Number} approximate   - 点击响应范围\n * @property {Number} radius        - 拐角弧度\n * @property {Number} minSpanX      - 起点终点在 x 方向最小的跨度\n * @property {Number} minSpanY      - 起点终点在 y 方向最小的跨度\n * @property {number[]} lineDash    - 虚线数组\n * @property {Boolean} doubleLink   - 双向箭头\n * @property {String} fontFamily    - 连线上的文字字体\n * @property {Number} fontSize      - 连线上的文字大小\n * @property {String} content       - 连线上的文字\n * @property {String} isSelf        - 是否为自连接\n */\n/**\n * 方形折线\n * @constructor PolyLink\n * @extends BaseLink\n * @param {PolyLink~Configs} configs - 配置\n */\nvar PolyLink = /*#__PURE__*/function (_BaseLink) {\n  poly_link_inherits(PolyLink, _BaseLink);\n  var _super = poly_link_createSuper(PolyLink);\n  /**\n  * 创建方形折线\n  * @param {PolyLink~Configs} configs - 配置\n  **/\n  function PolyLink(configs) {\n    var _this;\n    poly_link_classCallCheck(this, PolyLink);\n    _this = _super.call(this, configs);\n    /** @member {Number}   - 点击响应范围 */\n    _this.approximate = configs.approximate || APPROXIMATE;\n    /** @member {Number}   - 拐角弧度 */\n    _this.radius = configs.radius || 0;\n    /** @member {Number}   - 起点终点在 x 方向最小的跨度 */\n    _this.minSpanX = configs.minSpanX || 10;\n    /** @member {Number}   - 起点终点在 y 方向最小的跨度 */\n    _this.minSpanY = configs.minSpanY || 10;\n    /** @member {Number}    - 虚线数组 */\n    _this.lineDash = configs.lineDash;\n    /** @member {Number}    - 双向箭头 */\n    _this.doubleLink = configs.doubleLink;\n    /** @member {Number}    - 连线上的文字字体 */\n    _this.fontFamily = configs.fontFamily = \'-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Tahoma,Arial,Noto Sans,PingFang SC,Microsoft YaHei,Hiragino Sans GB,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji\';\n    /** @member {Number}    - 连线上的文字大小 */\n    _this.fontSize = configs.fontSize || \'12px\';\n    /** @member {Number}    - 连线上的文字 */\n    _this.content = configs.content || \'\';\n    /** @member {Number}    - 是否为自连接 */\n    _this.isSelf = !!configs.isSelf;\n    _this.noArrow = !!configs.noArrow;\n    _this._cacheAngle = [];\n    _this._cachePoints = [];\n    _this._cacheBoundingbox = {\n      from: [],\n      to: []\n    };\n    return _this;\n  }\n  poly_link_createClass(PolyLink, [{\n    key: "_calculateAnchorPoints",\n    value: function _calculateAnchorPoints() {\n      var dmsfrom = this.from.getIntersectionsInFourDimension();\n      var dmsto = this.to.getIntersectionsInFourDimension();\n      var _cacheAngle = this._cacheAngle;\n      if (this.isSelf) {\n        polylinePoints(this._cachePoints, dmsfrom[this.fromDir], dmsto[DIRECTION.SELF], this.fromDir, this.toDir, this.minSpanX, this.minSpanY, true);\n        _cacheAngle[0] = this.fromDir;\n        _cacheAngle[1] = this.toDir;\n      } else if (this.fromDir !== undefined && this.toDir !== undefined) {\n        polylinePoints(this._cachePoints, dmsfrom[this.fromDir], dmsto[this.toDir], this.fromDir, this.toDir, this.minSpanX, this.minSpanY);\n        _cacheAngle[0] = this.fromDir;\n        _cacheAngle[1] = this.toDir;\n      } else {\n        var meta = minIntersectionBetweenNodes(dmsfrom, dmsto);\n        polylinePoints(this._cachePoints, meta.fromP, meta.toP, meta.fromDir, meta.toDir, this.minSpanX, this.minSpanY);\n        _cacheAngle[0] = meta.fromDir;\n        _cacheAngle[1] = meta.toDir;\n      }\n    }\n  }, {\n    key: "isInViewBox",\n    value: function isInViewBox(br) {\n      if (this._static) {\n        return true;\n      }\n      this._calculateAnchorPoints();\n      return isPolyLineIntersectionRectange(this._cachePoints, br);\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      var _this2 = this;\n      // this._calculateAnchorPoints();\n      var radius = this.radius;\n      var points = this._cachePoints;\n      var p = points[0];\n      var pEnd = points[points.length - 1];\n      var angleEnd = (this._cacheAngle[1] + 2) % 4 * 90 * PIINRATIO;\n      ctx.fillStyle = ctx.strokeStyle = this.backgroundColor;\n      if (this.doubleLink) {\n        var beginAngle = (this._cacheAngle[0] + 2) % 4 * 90 * PIINRATIO;\n        ctx.beginPath();\n        ctx.translate(p[0], p[1]);\n        ctx.rotate(beginAngle);\n        ctx.moveTo(5, 0);\n        ctx.lineTo(0, -4);\n        ctx.lineTo(0, 4);\n        ctx.lineTo(5, 0);\n        ctx.fill();\n        ctx.rotate(-beginAngle);\n        ctx.translate(-p[0], -p[1]);\n      }\n      ctx.beginPath();\n      ctx.moveTo(p[0], p[1]);\n      points.slice(1, points.length - 1).forEach(function (p, idx) {\n        if (_this2.radius) {\n          var pLast = points[idx];\n          var pNext = points[idx + 2];\n          var _makeRadiusFromVector = makeRadiusFromVector(pLast, p, pNext, radius),\n            p1 = _makeRadiusFromVector.p1,\n            p2 = _makeRadiusFromVector.p2;\n          if (p1 && p2) {\n            ctx.lineTo(p1[0], p1[1]);\n            ctx.quadraticCurveTo(p[0], p[1], p2[0], p2[1]);\n          } else {\n            ctx.lineTo(p[0], p[1]);\n          }\n        } else {\n          ctx.lineTo(p[0], p[1]);\n        }\n      });\n      ctx.lineTo(pEnd[0], pEnd[1]);\n      if (this.lineDash) {\n        ctx.save();\n        ctx.setLineDash(this.lineDash);\n      }\n      ctx.stroke();\n      if (this.lineDash) {\n        ctx.restore();\n      }\n      if (!this.noArrow) {\n        ctx.beginPath();\n        ctx.translate(pEnd[0], pEnd[1]);\n        ctx.rotate(angleEnd);\n        ctx.moveTo(0, 0);\n        ctx.lineTo(-5, -4);\n        ctx.lineTo(-5, 4);\n        ctx.lineTo(0, 0);\n        ctx.fill();\n        ctx.rotate(-angleEnd);\n        ctx.translate(-pEnd[0], -pEnd[1]);\n      }\n      if (this.content) {\n        ctx.beginPath();\n        ctx.font = "".concat(this.fontSize, " ").concat(this.fontFamily);\n        switch (this.fromDir) {\n          case DIRECTION.BOTTOM:\n            ctx.textAlign = \'left\';\n            ctx.fillText(this.content, p[0] + 2, p[1] + 10);\n            break;\n          case DIRECTION.RIGHT:\n            ctx.textAlign = \'left\';\n            ctx.fillText(this.content, p[0] + 10, p[1] - 2);\n            break;\n          default:\n            break;\n        }\n      }\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      if (this._static) {\n        return false;\n      }\n      if (!this._cachePoints) {\n        return false;\n      }\n      var points = this._cachePoints;\n      var lastP = points[0];\n      var remainPoints = points.slice(1);\n      do {\n        var currentP = remainPoints.shift();\n        if (currentP) {\n          var dist = distToSegmentSquared(point, lastP, currentP);\n          if (dist < this.approximate) {\n            return true;\n          }\n        }\n        lastP = currentP;\n      } while (lastP);\n      return false;\n    }\n  }, {\n    key: "cloneStatic",\n    value: function cloneStatic() {\n      var _Object$assign;\n      var t = new PolyLink({});\n      Object.assign(t, (_Object$assign = {\n        radius: this.radius,\n        _cachePoints: this._cachePoints,\n        _cacheAngle: this._cacheAngle,\n        backgroundColor: this.backgroundColor,\n        doubleLink: this.doubleLink\n      }, poly_link_defineProperty(_Object$assign, "radius", this.radius), poly_link_defineProperty(_Object$assign, "lineDash", this.lineDash), poly_link_defineProperty(_Object$assign, "noArrow", this.noArrow), poly_link_defineProperty(_Object$assign, "content", this.content), poly_link_defineProperty(_Object$assign, "fontSize", this.fontSize), poly_link_defineProperty(_Object$assign, "fontFamily", this.fontFamily), poly_link_defineProperty(_Object$assign, "fromDir", this.fromDir), poly_link_defineProperty(_Object$assign, "_static", true), _Object$assign));\n      return t;\n    }\n  }]);\n  return PolyLink;\n}(base_link);\n/* harmony default export */ const poly_link = (PolyLink);\n;// CONCATENATED MODULE: ./src/core/instance/bezier-link.js\nfunction bezier_link_typeof(obj) { "@babel/helpers - typeof"; return bezier_link_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, bezier_link_typeof(obj); }\nfunction bezier_link_slicedToArray(arr, i) { return bezier_link_arrayWithHoles(arr) || bezier_link_iterableToArrayLimit(arr, i) || bezier_link_unsupportedIterableToArray(arr, i) || bezier_link_nonIterableRest(); }\nfunction bezier_link_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction bezier_link_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction bezier_link_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction bezier_link_toConsumableArray(arr) { return bezier_link_arrayWithoutHoles(arr) || bezier_link_iterableToArray(arr) || bezier_link_unsupportedIterableToArray(arr) || bezier_link_nonIterableSpread(); }\nfunction bezier_link_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction bezier_link_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return bezier_link_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return bezier_link_arrayLikeToArray(o, minLen); }\nfunction bezier_link_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\nfunction bezier_link_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return bezier_link_arrayLikeToArray(arr); }\nfunction bezier_link_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction bezier_link_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction bezier_link_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, bezier_link_toPropertyKey(descriptor.key), descriptor); } }\nfunction bezier_link_createClass(Constructor, protoProps, staticProps) { if (protoProps) bezier_link_defineProperties(Constructor.prototype, protoProps); if (staticProps) bezier_link_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction bezier_link_toPropertyKey(arg) { var key = bezier_link_toPrimitive(arg, "string"); return bezier_link_typeof(key) === "symbol" ? key : String(key); }\nfunction bezier_link_toPrimitive(input, hint) { if (bezier_link_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (bezier_link_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction bezier_link_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) bezier_link_setPrototypeOf(subClass, superClass); }\nfunction bezier_link_setPrototypeOf(o, p) { bezier_link_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return bezier_link_setPrototypeOf(o, p); }\nfunction bezier_link_createSuper(Derived) { var hasNativeReflectConstruct = bezier_link_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = bezier_link_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = bezier_link_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return bezier_link_possibleConstructorReturn(this, result); }; }\nfunction bezier_link_possibleConstructorReturn(self, call) { if (call && (bezier_link_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return bezier_link_assertThisInitialized(self); }\nfunction bezier_link_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction bezier_link_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction bezier_link_getPrototypeOf(o) { bezier_link_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return bezier_link_getPrototypeOf(o); }\n\n\n\n\nvar bezier_link_PIINRATIO = Math.PI / 180;\n/**\n * @typedef {BaseLink~Configs} BezierLink~Configs\n * @property {Number} approximate   - 点击响应范围\n * @property {Number} minSpanX      - 起点终点在 x 方向最小的跨度\n * @property {Number} minSpanY      - 起点终点在 y 方向最小的跨度\n * @property {Number[]} lineDash    - 虚线数组\n * @property {Boolean} doubleLink   - 双向箭头\n * @property {String} fontFamily    - 连线上的文字字体\n * @property {Number} fontSize      - 连线上的文字大小\n * @property {String} content       - 连线上的文字\n * @property {Boolean} isSelf        - 是否为自连接\n */\n/**\n * 贝塞尔曲线\n * @constructor BezierLink\n * @extends BaseLink\n * @param {BezierLink~Configs} configs - 配置\n */\nvar BezierLink = /*#__PURE__*/function (_BaseLink) {\n  bezier_link_inherits(BezierLink, _BaseLink);\n  var _super = bezier_link_createSuper(BezierLink);\n  /**\n  * 创建贝塞尔曲线.\n  * @param {BezierLink~Configs} configs - 配置\n  **/\n  function BezierLink(configs) {\n    var _this;\n    bezier_link_classCallCheck(this, BezierLink);\n    _this = _super.call(this, configs);\n    /** @member {Number}      - 点击响应范围 */\n    _this.approximate = configs.approximate || APPROXIMATE;\n    /** @member {Number}      - 起点终点在 x 方向最小的跨度 */\n    _this.minSpanX = configs.minSpanX || 0;\n    /** @member {Number}      - 起点终点在 y 方向最小的跨度 */\n    _this.minSpanY = configs.minSpanY || 0;\n    /** @member {Number[]}      - 虚线数组 */\n    _this.lineDash = configs.lineDash;\n    _this.lineWidth = configs.lineWidth || 1;\n    /** @member {Boolean}      - 双向箭头 */\n    _this.doubleLink = configs.doubleLink;\n    /** @member {String}      - 连线上的文字字体 */\n    _this.fontFamily = configs.fontFamily = \'-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Tahoma,Arial,Noto Sans,PingFang SC,Microsoft YaHei,Hiragino Sans GB,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji\';\n    /** @member {Number}      - 连线上的文字大小 */\n    _this.fontSize = configs.fontSize || \'12px\';\n    /** @member {String}      - 连线上的文字 */\n    _this.content = configs.content || \'\';\n    /** @member {Boolean}      - 是否为自连接 */\n    _this.isSelf = !!configs.isSelf;\n    return _this;\n  }\n\n  // getColor() {\n  //     if(this._isTargeting) {\n  //         return this.hoverStyle;\n  //     }\n  //     return this.defaultStyle;\n  // }\n\n  // _calculateAnchorPoints() {\n  //     let start;\n  //     let end;\n  //     if(this.fromDir !== undefined) {\n  //         start = {\n  //             dir: this.fromDir,\n  //             p: this.from.getIntersectionsInFourDimension()[this.fromDir],\n  //         }\n  //     } else {\n  //         start = this.from.calculateIntersectionInFourDimension(this.to.getCenter(), \'from\');\n  //     }\n  //     if(this.toDir !== undefined) {\n  //         end = {\n  //             dir: this.toDir,\n  //             p: this.to.getIntersectionsInFourDimension()[this.toDir],\n  //         }\n  //     } else {\n  //         end = this.to.calculateIntersectionInFourDimension(this.from.getCenter(), \'to\');\n  //     }\n\n  //     // const start = this.from.calculateIntersectionInFourDimension(this.to.getCenter(), \'from\');\n  //     // const end = this.to.calculateIntersectionInFourDimension(this.from.getCenter(), \'to\');\n  //     const p1 = start.p;\n  //     const p2 = end.p;\n  //     const points = bezierPoints(p1, p2, start.dir, end.dir, this.anticlock);\n\n  //     this._cachePoints = [...p1, ...points]\n  // }\n  bezier_link_createClass(BezierLink, [{\n    key: "_calculateAnchorPoints",\n    value: function _calculateAnchorPoints() {\n      var dmsfrom = this.from.getIntersectionsInFourDimension();\n      var dmsto = this.to.getIntersectionsInFourDimension();\n      if (this.isSelf) {\n        var points = bezierPoints(dmsfrom[this.fromDir], dmsto[DIRECTION.SELF], this.fromDir, DIRECTION.BOTTOM, this.minSpanX, this.minSpanY);\n        this._cachePoints = [].concat(bezier_link_toConsumableArray(dmsfrom[this.fromDir]), bezier_link_toConsumableArray(points));\n        this._cacheAngle = [this.fromDir, DIRECTION.BOTTOM];\n      } else if (this.fromDir !== undefined && this.toDir !== undefined) {\n        var _points = bezierPoints(dmsfrom[this.fromDir], dmsto[this.toDir], this.fromDir, this.toDir, this.minSpanX, this.minSpanY);\n        this._cachePoints = [].concat(bezier_link_toConsumableArray(dmsfrom[this.fromDir]), bezier_link_toConsumableArray(_points));\n        this._cacheAngle = [this.fromDir, this.toDir];\n      } else {\n        var meta = minIntersectionBetweenNodes(dmsfrom, dmsto);\n        var _points2 = bezierPoints(meta.fromP, meta.toP, meta.fromDir, meta.toDir);\n        this._cachePoints = [].concat(bezier_link_toConsumableArray(meta.fromP), bezier_link_toConsumableArray(_points2));\n        this._cacheAngle = [meta.fromDir, meta.toDir];\n      }\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      this._calculateAnchorPoints();\n      var points = this._cachePoints;\n      var angle = getBezierAngle.apply(null, [1].concat(bezier_link_toConsumableArray(points)));\n      ctx.fillStyle = ctx.strokeStyle = this.backgroundColor;\n      ctx.lineWidth = this.lineWidth;\n      if (this.doubleLink) {\n        var beginAngle = (this._cacheAngle[0] + 2) % 4 * 90 * bezier_link_PIINRATIO;\n        ctx.beginPath();\n        ctx.translate(points[0], points[1]);\n        ctx.rotate(beginAngle);\n        ctx.moveTo(5, 0);\n        ctx.lineTo(0, -4);\n        ctx.lineTo(0, 4);\n        ctx.lineTo(5, 0);\n        ctx.fill();\n        ctx.rotate(-beginAngle);\n        ctx.translate(-points[0], -points[1]);\n      }\n      ctx.beginPath();\n      ctx.moveTo(points[0], points[1]);\n      ctx.bezierCurveTo.apply(ctx, bezier_link_toConsumableArray(points.slice(2)));\n      if (this.lineDash) {\n        ctx.save();\n        ctx.setLineDash(this.lineDash);\n      }\n      ctx.stroke();\n      if (this.lineDash) {\n        ctx.restore();\n      }\n      ctx.beginPath();\n      ctx.translate(points[6], points[7]);\n      ctx.rotate(angle);\n      ctx.moveTo(5, 0);\n      ctx.lineTo(0, -4);\n      ctx.lineTo(0, 4);\n      ctx.lineTo(5, 0);\n      ctx.fill();\n      ctx.rotate(-angle);\n      ctx.translate(-points[6], -points[7]);\n      if (this.content) {\n        ctx.beginPath();\n        var hasFlip = points[0] > points[6];\n        var _bezierPoint = bezierPoint(0.5, points),\n          _bezierPoint2 = bezier_link_slicedToArray(_bezierPoint, 3),\n          x = _bezierPoint2[0],\n          y = _bezierPoint2[1],\n          _angle = _bezierPoint2[2];\n        ctx.translate(x, y);\n        ctx.rotate(_angle);\n        if (hasFlip) {\n          ctx.rotate(Math.PI);\n        }\n        ctx.font = "".concat(this.fontSize, " ").concat(this.fontFamily);\n        ctx.textAlign = \'center\';\n        ctx.fillText(this.content, 0, -(parseInt(this.fontSize) || 12) / 4);\n        if (hasFlip) {\n          ctx.rotate(Math.PI);\n        }\n        ctx.rotate(-_angle);\n        ctx.translate(-x, -y);\n      }\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point) {\n      if (!this._cachePoints) return false;\n      var points = this._cachePoints;\n      var dist = distToBezierSegmentSquared(point, points);\n      return dist < this.approximate;\n    }\n  }]);\n  return BezierLink;\n}(base_link);\n/* harmony default export */ const bezier_link = (BezierLink);\n;// CONCATENATED MODULE: ./src/core/layout/linear-layout.js\nfunction linear_layout_typeof(obj) { "@babel/helpers - typeof"; return linear_layout_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, linear_layout_typeof(obj); }\nfunction linear_layout_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction linear_layout_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, linear_layout_toPropertyKey(descriptor.key), descriptor); } }\nfunction linear_layout_createClass(Constructor, protoProps, staticProps) { if (protoProps) linear_layout_defineProperties(Constructor.prototype, protoProps); if (staticProps) linear_layout_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction linear_layout_toPropertyKey(arg) { var key = linear_layout_toPrimitive(arg, "string"); return linear_layout_typeof(key) === "symbol" ? key : String(key); }\nfunction linear_layout_toPrimitive(input, hint) { if (linear_layout_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (linear_layout_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n/**\n * 线性布局配置\n * @typedef {Object} LinearLayout~Configs\n * @property {string} direction     - 排列方向 默认 vertical\n * @property {number} gap           - 边距, 默认是 5\n * @property {string} alignment     - 垂直排列方向对齐方式 默认 center\n * @property {string} justify       - 排列方向对齐方式 默认 center\n */\n/**\n    线性布局\n\n    排列方向\n    direction:\n        + vertical 从上至下排布\n        + horizontal 从左至右排布\n    \n    不重叠，中线对齐\n    只针对当前的 group\n\n    对齐方式\n    alignment: \n        + start 主轴左侧对齐\n        + center 主轴对齐\n        + end   主轴右侧对齐\n    justify: \n        + start 开始时对齐\n        + center 居中对齐\n        + end   末尾对齐\n        + space-between 平均分配空间对齐\n\n * @constructor LinearLayout\n * @implements {Layout}\n * @param {LinearLayout~Configs} configs - 配置\n */\nvar LinearLayout = /*#__PURE__*/function () {\n  function LinearLayout() {\n    var _configs$gap;\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    linear_layout_classCallCheck(this, LinearLayout);\n    /** @member {string}  - 排列方向 默认 vertical */\n    this.direction = configs.direction || \'vertical\';\n    /** @member {number}  - 边距, 默认是 5 */\n    this.gap = (_configs$gap = configs.gap) !== null && _configs$gap !== void 0 ? _configs$gap : 5;\n    /** @member {string}  - 垂直排列方向对齐方式 默认 center */\n    this.alignment = configs.alignment || \'center\';\n    /** @member {string}  - 排列方向对齐方式 默认 center */\n    this.justify = configs.justify || \'center\';\n    // this.widthSetByParent =  configs.width === \'100%\'\n    this._rawConfigs = configs;\n  }\n  linear_layout_createClass(LinearLayout, [{\n    key: "reflow",\n    value: function reflow(group) {\n      var _this = this;\n      var stack = group._stack.filter(function (instance) {\n        return instance.visible && !instance.absolutePosition;\n      });\n      var absoluteStack = group._stack.filter(function (instance) {\n        return instance.visible && instance.absolutePosition;\n      });\n      var groupWidth = group.width - group.padding.left - group.padding.right;\n      if (this.direction === \'vertical\') {\n        var reduceHeight = 0;\n        var lastInstanceHeight = 0;\n        var maxWidth = 0;\n        var allHeight = 0;\n        var childAll = stack.concat(absoluteStack);\n        childAll.forEach(function (instance, idx) {\n          if (instance.display === \'block\') {\n            instance.width = 0;\n            // instance.definedWidth = maxWidth;\n            instance.resetChildrenPosition();\n            instance.reflow();\n            instance._getBoundingGroupRect();\n          }\n        });\n        stack.forEach(function (instance, idx) {\n          var _instance$getBounding = instance.getBoundingDimension(),\n            width = _instance$getBounding.width,\n            height = _instance$getBounding.height;\n          // console.log(height, instance.type);\n          var gap = idx > 0 ? _this.gap : 0;\n          if (instance.display !== \'outstretch\') {\n            maxWidth = Math.max(width, maxWidth);\n          }\n          allHeight += height + gap;\n          reduceHeight += height / 2 + gap + lastInstanceHeight;\n          lastInstanceHeight = height / 2;\n          instance.anchor = [0, reduceHeight];\n        });\n        childAll.forEach(function (instance, idx) {\n          if (instance.display === \'block\') {\n            // instance.definedWidth = maxWidth;\n            instance.resetChildrenPosition();\n            instance.width = maxWidth;\n            instance.reflow();\n            // instance._getBoundingGroupRect();\n          } else if (instance.display === \'outstretch\') {\n            var w = group._belongs.width - group._belongs.padding.left - group._belongs.padding.right;\n            instance.resetChildrenPosition();\n            instance.width = Math.max(w, maxWidth);\n            instance.reflow();\n          }\n        });\n        maxWidth = Math.max(groupWidth, maxWidth);\n        allHeight = allHeight / 2;\n        if (this.alignment === \'start\') {\n          stack.forEach(function (instance, idx) {\n            var _instance$getBounding2 = instance.getBoundingDimension(),\n              width = _instance$getBounding2.width;\n            instance.anchor[0] = -(maxWidth - width) / 2;\n            instance.anchor[1] -= allHeight;\n            // console.log(maxWidth, width, instance.anchor[0])\n          });\n        }\n\n        if (this.alignment === \'end\') {\n          stack.forEach(function (instance, idx) {\n            var _instance$getBounding3 = instance.getBoundingDimension(),\n              width = _instance$getBounding3.width;\n            instance.anchor[0] = (maxWidth - width) / 2;\n            instance.anchor[1] -= allHeight;\n          });\n        }\n        if (this.alignment === \'center\') {\n          stack.forEach(function (instance, idx) {\n            var _instance$getBounding4 = instance.getBoundingDimension(),\n              width = _instance$getBounding4.width;\n            instance.anchor[1] -= allHeight;\n          });\n        }\n      }\n      if (this.direction === \'horizontal\') {\n        var reduceWidth = 0;\n        var lastInstanceWidth = 0;\n        var maxHeight = 0;\n        var allWidth = 0;\n        var allPureWidth = 0;\n        stack.forEach(function (instance, idx) {\n          var _instance$getBounding5 = instance.getBoundingDimension(),\n            width = _instance$getBounding5.width,\n            height = _instance$getBounding5.height;\n          var gap = idx > 0 ? _this.gap : 0;\n          maxHeight = Math.max(height, maxHeight);\n          allWidth += width + gap;\n          allPureWidth += width;\n          reduceWidth += width / 2 + gap + lastInstanceWidth;\n          lastInstanceWidth = width / 2;\n          instance.anchor = [reduceWidth, 0];\n        });\n        if (this.justify === \'start\') {\n          var withdraw = groupWidth / 2;\n          stack.forEach(function (instance, idx) {\n            instance.anchor[0] -= withdraw;\n          });\n        }\n        if (this.justify === \'end\') {\n          var _withdraw = groupWidth / 2 - allWidth;\n          stack.forEach(function (instance, idx) {\n            instance.anchor[0] += _withdraw;\n          });\n        }\n        if (this.justify === \'center\') {\n          var _withdraw2 = allWidth / 2;\n          stack.forEach(function (instance, idx) {\n            instance.anchor[0] -= _withdraw2;\n          });\n        }\n        if (this.justify === \'space-between\' && stack.length > 1) {\n          var width = Math.max(groupWidth, allWidth);\n          var gapAverage = (width - allWidth) / (stack.length - 1);\n          var _withdraw3 = width / 2;\n          stack.forEach(function (instance, idx) {\n            instance.anchor[0] += gapAverage * idx - _withdraw3;\n          });\n        }\n        if (this.alignment === \'start\') {\n          stack.forEach(function (instance, idx) {\n            var _instance$getBounding6 = instance.getBoundingDimension(),\n              height = _instance$getBounding6.height;\n            instance.anchor[1] = -(maxHeight - height) / 2;\n          });\n        }\n        if (this.alignment === \'end\') {\n          stack.forEach(function (instance, idx) {\n            var _instance$getBounding7 = instance.getBoundingDimension(),\n              height = _instance$getBounding7.height;\n            instance.anchor[1] = (maxHeight - height) / 2;\n          });\n        }\n      }\n      if (absoluteStack.length) {\n        if (group.display === \'block\') {\n          group.getBoundingDimension();\n        } else {\n          group._getBoundingGroupRect();\n        }\n        var WIDTH = group.width / 2;\n        var HEIGHT = group.height / 2;\n        var shifty = (group.padding.top - group.padding.bottom) / 2;\n        var shiftx = (group.padding.left - group.padding.right) / 2;\n        absoluteStack.forEach(function (instance) {\n          instance.anchor = _this._resolveAbsoluteAnchor(instance.absolutePosition, instance, WIDTH, HEIGHT, shiftx, shifty);\n        });\n      }\n    }\n  }, {\n    key: "_resolveAbsoluteAnchor",\n    value: function _resolveAbsoluteAnchor(config, instance, w, h, shiftx, shifty) {\n      var top = config.top,\n        right = config.right,\n        bottom = config.bottom,\n        left = config.left,\n        centerX = config.centerX,\n        centerY = config.centerY;\n      var _instance$getBounding8 = instance.getBoundingDimension(),\n        width = _instance$getBounding8.width,\n        height = _instance$getBounding8.height;\n      var hw = width / 2;\n      var hh = height / 2;\n      var y = 0;\n      var x = 0;\n      if (typeof top === \'number\') {\n        y = top + hh - h - shifty;\n      }\n      if (typeof right === \'number\') {\n        x = w - right - hw - shiftx;\n      }\n      if (typeof bottom === \'number\') {\n        y = h - bottom - hh - shifty;\n      }\n      if (typeof left === \'number\') {\n        x = left + hw - w - shiftx;\n      }\n      if (typeof centerX === \'number\') {\n        x = centerX;\n      }\n      if (typeof centerY === \'number\') {\n        y = centerY;\n      }\n      return [x, y];\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new LinearLayout(this._rawConfigs);\n    }\n  }]);\n  return LinearLayout;\n}();\n/* harmony default export */ const linear_layout = (LinearLayout);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/base/constants.js\nvar EDITOR_EVENTS = {\n  INPUT: \'input\',\n  CONTROL_CMD: \'control\'\n};\nvar KEYBOARD_INPUT = {\n  INPUT: \'input\',\n  COMPOSITION_START: \'compositionstart\',\n  COMPOSITION_UPDATE: \'compositionupdate\',\n  COMPOSITION_END: \'compositionend\',\n  ENTER: \'enter\',\n  DELETE: \'delete\',\n  BACKSPACE: \'backspace\'\n};\nvar KEYBOARD_COMMANDS = {\n  ARROW_LEFT: \'arrowLeft\',\n  ARROW_RIGHT: \'arrowRight\',\n  ARROW_UP: \'arrowUp\',\n  ARROW_DOWN: \'arrowDown\',\n  UNDO: \'undo\',\n  REDO: \'redo\',\n  SHIFT_DOWN: \'shift_down\',\n  SHIFT_UP: \'shift_up\',\n  CTRLA: \'ctrla\',\n  COPY: \'copy\',\n  CUT: \'cut\',\n  PASTE: \'paste\'\n};\nvar MOUSE_COMMANDS = {\n  START_EDIT: \'startedit\',\n  EDIT_CLICK: \'editclick\',\n  SHIFT_ON_CLICK: \'shiftonclick\',\n  DOUBLE_CLICK: \'doubleclick\'\n};\nvar OPERRATION = {\n  PLAININPUT: \'plaininput\',\n  SPACEINPUT: \'spaceinput\',\n  RETURNINPUT: \'returninput\',\n  CARETMOVEMENT: \'caretmovement\',\n  DELETE_IN_LINE: \'deleteinline\',\n  DELETE_IN_EDITAREA: \'deleteineditarea\',\n  ENSURE_DELETE: \'ensuredelete\',\n  SELECTION_DELETE: \'selectiondelete\',\n  SELECTION_INPUT: \'selectioninput\',\n  COMPOSITE_INSERT: \'compositeinsert\'\n};\n;// CONCATENATED MODULE: ./src/core/instance/text-group/base/shadow-input.js\nfunction shadow_input_typeof(obj) { "@babel/helpers - typeof"; return shadow_input_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, shadow_input_typeof(obj); }\nfunction shadow_input_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction shadow_input_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, shadow_input_toPropertyKey(descriptor.key), descriptor); } }\nfunction shadow_input_createClass(Constructor, protoProps, staticProps) { if (protoProps) shadow_input_defineProperties(Constructor.prototype, protoProps); if (staticProps) shadow_input_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction shadow_input_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) shadow_input_setPrototypeOf(subClass, superClass); }\nfunction shadow_input_createSuper(Derived) { var hasNativeReflectConstruct = shadow_input_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = shadow_input_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = shadow_input_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return shadow_input_possibleConstructorReturn(this, result); }; }\nfunction shadow_input_possibleConstructorReturn(self, call) { if (call && (shadow_input_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return shadow_input_assertThisInitialized(self); }\nfunction shadow_input_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction shadow_input_wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; shadow_input_wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !shadow_input_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return shadow_input_construct(Class, arguments, shadow_input_getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return shadow_input_setPrototypeOf(Wrapper, Class); }; return shadow_input_wrapNativeSuper(Class); }\nfunction shadow_input_construct(Parent, args, Class) { if (shadow_input_isNativeReflectConstruct()) { shadow_input_construct = Reflect.construct.bind(); } else { shadow_input_construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) shadow_input_setPrototypeOf(instance, Class.prototype); return instance; }; } return shadow_input_construct.apply(null, arguments); }\nfunction shadow_input_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction shadow_input_isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }\nfunction shadow_input_setPrototypeOf(o, p) { shadow_input_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return shadow_input_setPrototypeOf(o, p); }\nfunction shadow_input_getPrototypeOf(o) { shadow_input_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return shadow_input_getPrototypeOf(o); }\nfunction shadow_input_defineProperty(obj, key, value) { key = shadow_input_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction shadow_input_toPropertyKey(arg) { var key = shadow_input_toPrimitive(arg, "string"); return shadow_input_typeof(key) === "symbol" ? key : String(key); }\nfunction shadow_input_toPrimitive(input, hint) { if (shadow_input_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (shadow_input_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\nvar ShadowInput = /*#__PURE__*/function (_EventTarget) {\n  shadow_input_inherits(ShadowInput, _EventTarget);\n  var _super = shadow_input_createSuper(ShadowInput);\n  function ShadowInput(wrapper) {\n    var _this;\n    shadow_input_classCallCheck(this, ShadowInput);\n    _this = _super.call(this);\n    shadow_input_defineProperty(shadow_input_assertThisInitialized(_this), "_inputElement", null);\n    _this._inputElement = shadow_input_createInputElement(_this.controlCallback.bind(shadow_input_assertThisInitialized(_this)));\n    wrapper.append(_this._inputElement);\n    _this._inputElement.focus();\n    return _this;\n  }\n  shadow_input_createClass(ShadowInput, [{\n    key: "controlCallback",\n    value: function controlCallback(kind, data) {\n      switch (kind) {\n        case KEYBOARD_INPUT.INPUT:\n        case KEYBOARD_INPUT.COMPOSITION_START:\n        case KEYBOARD_INPUT.COMPOSITION_UPDATE:\n        case KEYBOARD_INPUT.COMPOSITION_END:\n        case KEYBOARD_INPUT.ENTER:\n        case KEYBOARD_INPUT.BACKSPACE:\n        case KEYBOARD_INPUT.DELETE:\n          this.dispatchEvent(new CustomEvent(EDITOR_EVENTS.INPUT, {\n            detail: {\n              kind: kind,\n              data: data\n            }\n          }));\n          break;\n        case KEYBOARD_COMMANDS.ARROW_LEFT:\n        case KEYBOARD_COMMANDS.ARROW_RIGHT:\n        case KEYBOARD_COMMANDS.ARROW_UP:\n        case KEYBOARD_COMMANDS.ARROW_DOWN:\n        case KEYBOARD_COMMANDS.CTRLA:\n        case KEYBOARD_COMMANDS.SHIFT_DOWN:\n        case KEYBOARD_COMMANDS.SHIFT_UP:\n        case KEYBOARD_COMMANDS.UNDO:\n        case KEYBOARD_COMMANDS.REDO:\n        case KEYBOARD_COMMANDS.COPY:\n        case KEYBOARD_COMMANDS.CUT:\n        case KEYBOARD_COMMANDS.PASTE:\n          this.dispatchEvent(new CustomEvent(EDITOR_EVENTS.CONTROL_CMD, {\n            detail: {\n              kind: kind,\n              data: data\n            }\n          }));\n          break;\n      }\n    }\n  }, {\n    key: "focus",\n    value: function focus() {\n      this._inputElement.focus({\n        preventScroll: true\n      });\n    }\n  }, {\n    key: "syncPosition",\n    value: function syncPosition(x, y) {\n      this._inputElement.style.transform = "translate(".concat(x, "px, ").concat(y, "px)");\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      if (this.removeLisenter) {\n        this.removeLisenter();\n      }\n      this._inputElement.remove();\n    }\n  }]);\n  return ShadowInput;\n}( /*#__PURE__*/shadow_input_wrapNativeSuper(EventTarget));\n/* harmony default export */ const shadow_input = (ShadowInput);\nfunction shadow_input_createInputElement(controlCallback) {\n  var input = document.createElement(\'input\');\n  input.setAttribute(\'style\', "\\n        width: 100px;\\n        position: absolute;\\n        left: 0;\\n        top: 0;\\n        border:none;\\n        opacity: 0;\\n        z-index: -1;\\n        contain: strict;");\n  input.setAttribute(\'tabindex\', -1);\n  input.setAttribute(\'spellcheck\', false);\n  input.setAttribute(\'autocorrect\', \'off\');\n  var stopInput = false;\n  var status = {\n    ctrlOn: false,\n    shiftOn: false\n  };\n  input.addEventListener(\'beforeinput\', function (e) {\n    e.preventDefault();\n    if (e.data) {\n      // content += e.data;\n      // renderContent();\n      if (!stopInput) {\n        controlCallback(KEYBOARD_INPUT.INPUT, e.data);\n      }\n    }\n  });\n  input.addEventListener(\'paste\', function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    var pasteContent = (e.clipboardData || window.clipboardData).getData("text");\n    controlCallback(KEYBOARD_COMMANDS.PASTE, pasteContent);\n  });\n  input.addEventListener(\'copy\', function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    controlCallback(KEYBOARD_COMMANDS.COPY, e);\n  });\n  input.addEventListener(\'cut\', function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    controlCallback(KEYBOARD_COMMANDS.CUT, e);\n  });\n  input.addEventListener(\'compositionstart\', function (e) {\n    controlCallback(KEYBOARD_INPUT.COMPOSITION_START);\n    stopInput = true;\n  });\n  input.addEventListener(\'compositionupdate\', function (e) {\n    controlCallback(KEYBOARD_INPUT.COMPOSITION_UPDATE, e.data);\n  });\n  input.addEventListener(\'compositionend\', function (e) {\n    controlCallback(KEYBOARD_INPUT.COMPOSITION_END, e.data);\n    input.value = \'\';\n    stopInput = false;\n  });\n  input.addEventListener(\'keyup\', function (event) {\n    if (stopInput) {\n      return;\n    }\n    switch (event.key) {\n      case "Shift":\n        controlCallback(KEYBOARD_COMMANDS.SHIFT_UP);\n        status.shiftOn = false;\n        break;\n      case "Meta":\n      case "Control":\n        status.ctrlOn = false;\n        break;\n    }\n  });\n  input.addEventListener(\'keydown\', function (event) {\n    if (stopInput) {\n      return;\n    }\n    switch (event.code) {\n      case "Enter":\n        controlCallback(KEYBOARD_INPUT.ENTER);\n        break;\n      case "Backspace":\n        controlCallback(KEYBOARD_INPUT.BACKSPACE);\n        break;\n      case "Delete":\n        controlCallback(KEYBOARD_INPUT.DELETE);\n        break;\n      case "ArrowLeft":\n        controlCallback(KEYBOARD_COMMANDS.ARROW_LEFT);\n        break;\n      case "ArrowRight":\n        controlCallback(KEYBOARD_COMMANDS.ARROW_RIGHT);\n        break;\n      case "ArrowDown":\n        controlCallback(KEYBOARD_COMMANDS.ARROW_DOWN);\n        break;\n      case "ArrowUp":\n        controlCallback(KEYBOARD_COMMANDS.ARROW_UP);\n        break;\n    }\n    switch (event.key) {\n      case "Shift":\n        controlCallback(KEYBOARD_COMMANDS.SHIFT_DOWN);\n        status.shiftOn = true;\n        break;\n      case "Meta":\n      case "Control":\n        status.ctrlOn = true;\n        break;\n      case \'a\':\n        if (status.ctrlOn) {\n          controlCallback(KEYBOARD_COMMANDS.CTRLA);\n        }\n        break;\n      // case \'c\':\n      //     if(status.ctrlOn) {\n      //         controlCallback(KEYBOARD_COMMANDS.CTRLC);\n      //     }\n      //     break; \n      // case \'v\':\n      //     if(status.ctrlOn) {\n      //         controlCallback(KEYBOARD_COMMANDS.CTRLV);\n      //     }\n      //     break;   \n      // case \'x\':\n      //     if(status.ctrlOn) {\n      //         controlCallback(KEYBOARD_COMMANDS.CTRLX);\n      //     }\n      //     break;\n      case \'y\':\n        if (status.ctrlOn) {\n          event.preventDefault();\n          controlCallback(KEYBOARD_COMMANDS.REDO);\n        }\n        break;\n      case \'z\':\n        if (status.ctrlOn && status.shiftOn) {\n          controlCallback(KEYBOARD_COMMANDS.REDO);\n        } else if (status.ctrlOn) {\n          controlCallback(KEYBOARD_COMMANDS.UNDO);\n        }\n        break;\n    }\n  });\n  return input;\n}\n;// CONCATENATED MODULE: ./src/core/instance/text-group/base/caret.js\nfunction caret_typeof(obj) { "@babel/helpers - typeof"; return caret_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, caret_typeof(obj); }\nfunction caret_toConsumableArray(arr) { return caret_arrayWithoutHoles(arr) || caret_iterableToArray(arr) || caret_unsupportedIterableToArray(arr) || caret_nonIterableSpread(); }\nfunction caret_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction caret_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return caret_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return caret_arrayLikeToArray(o, minLen); }\nfunction caret_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\nfunction caret_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return caret_arrayLikeToArray(arr); }\nfunction caret_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction caret_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction caret_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, caret_toPropertyKey(descriptor.key), descriptor); } }\nfunction caret_createClass(Constructor, protoProps, staticProps) { if (protoProps) caret_defineProperties(Constructor.prototype, protoProps); if (staticProps) caret_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction caret_defineProperty(obj, key, value) { key = caret_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction caret_toPropertyKey(arg) { var key = caret_toPrimitive(arg, "string"); return caret_typeof(key) === "symbol" ? key : String(key); }\nfunction caret_toPrimitive(input, hint) { if (caret_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (caret_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nvar Caret = /*#__PURE__*/function () {\n  function Caret() {\n    caret_classCallCheck(this, Caret);\n    caret_defineProperty(this, "_row", 0);\n    caret_defineProperty(this, "_column", [0, 0]);\n    caret_defineProperty(this, "_status", {\n      show: true,\n      anime: null,\n      lastElapsed: 0,\n      refreshElapsed: false\n    });\n  }\n  caret_createClass(Caret, [{\n    key: "setRow",\n    value: function setRow(row) {\n      this._row = row;\n    }\n  }, {\n    key: "setColumn",\n    value: function setColumn(columnoridx, column) {\n      if (column !== undefined) {\n        this._column[columnoridx] = column;\n      } else {\n        this._column = columnoridx;\n      }\n    }\n  }, {\n    key: "getRow",\n    value: function getRow() {\n      return this._row;\n    }\n  }, {\n    key: "getColumn",\n    value: function getColumn(idx) {\n      if (idx !== undefined) {\n        return this._column[idx];\n      }\n      return this._column;\n    }\n  }, {\n    key: "animate",\n    value: function animate(jflow) {\n      var _this = this;\n      this._status.anime = jflow.requestJFlowAnime(function (elapsed) {\n        var lastElapsed = _this._status.lastElapsed;\n        if (_this._status.refreshElapsed) {\n          _this._status.lastElapsed = elapsed;\n          _this._status.refreshElapsed = false;\n        }\n        if (elapsed - lastElapsed > 500) {\n          _this._status.show = !_this._status.show;\n          _this._status.lastElapsed = elapsed;\n        }\n      });\n    }\n  }, {\n    key: "cancelAnimate",\n    value: function cancelAnimate() {\n      this._status.anime.cancel();\n      Object.assign(this._status, {\n        show: true,\n        anime: null,\n        lastElapsed: 0\n      });\n    }\n  }, {\n    key: "isShow",\n    value: function isShow() {\n      return this._status.show;\n    }\n  }, {\n    key: "refresh",\n    value: function refresh() {\n      Object.assign(this._status, {\n        show: true,\n        refreshElapsed: true\n      });\n    }\n  }, {\n    key: "toRange",\n    value: function toRange() {\n      return [this._row].concat(caret_toConsumableArray(this._column));\n    }\n  }, {\n    key: "fromRange",\n    value: function fromRange(range) {\n      this._row = range[0];\n      this._column = range.slice(1);\n    }\n  }]);\n  return Caret;\n}();\n/* harmony default export */ const caret = (Caret);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/utils.js\n\nfunction calculateOffsetByWidth(offx, textmeta, fontSize, fontFamily, spaceHolder) {\n  var content = textmeta.getRenderSource(spaceHolder);\n  var maxL = content.length - 1;\n  if (textmeta.width === 0) {\n    return 0;\n  }\n  var allwidth = textmeta.width;\n  var idx = Math.floor(offx / allwidth * maxL);\n  requestCacheCanvas(function (ctx) {\n    ctx.font = "".concat(fontSize, " ").concat(fontFamily);\n    var g1, g2;\n    var lastidx;\n    var c = content.substring(0, idx);\n    var c1 = content.substring(idx - 1, idx);\n    var c2 = content.substring(idx, idx + 1);\n    var w = ctx.measureText(c).width;\n    var w1 = ctx.measureText(c1).width;\n    var w2 = ctx.measureText(c2).width;\n    g1 = w - w1 / 2;\n    g2 = w + w2 / 2;\n    do {\n      if (g1 <= offx && g2 >= offx) {\n        break;\n      }\n      if (g1 > offx) {\n        // 左侧少了\n        var spanw = g2 - offx;\n        lastidx = idx;\n        if (spanw < 100) {\n          idx -= 1;\n        } else {\n          idx -= Math.floor(spanw / g2 * lastidx);\n        }\n        c = content.substring(idx, lastidx);\n        w -= ctx.measureText(c).width;\n      } else if (g2 < offx) {\n        // 右侧少了\n        var _spanw = offx - g1;\n        lastidx = idx;\n        if (_spanw < 100) {\n          idx += 1;\n        } else {\n          idx += Math.floor(_spanw / (allwidth - g1) * (maxL - lastidx));\n        }\n        c = content.substring(lastidx, idx);\n        w += ctx.measureText(c).width;\n      }\n      c1 = content.substring(idx - 1, idx);\n      c2 = content.substring(idx, idx + 1);\n      w1 = ctx.measureText(c1).width;\n      w2 = ctx.measureText(c2).width;\n      g1 = w - w1 / 2;\n      g2 = w + w2 / 2;\n    } while (idx >= 0 && idx <= maxL);\n  });\n  return idx;\n}\n;// CONCATENATED MODULE: ./src/core/instance/text-group/storage/index.js\nfunction storage_typeof(obj) { "@babel/helpers - typeof"; return storage_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, storage_typeof(obj); }\nfunction storage_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction storage_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, storage_toPropertyKey(descriptor.key), descriptor); } }\nfunction storage_createClass(Constructor, protoProps, staticProps) { if (protoProps) storage_defineProperties(Constructor.prototype, protoProps); if (staticProps) storage_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction storage_defineProperty(obj, key, value) { key = storage_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction storage_toPropertyKey(arg) { var key = storage_toPrimitive(arg, "string"); return storage_typeof(key) === "symbol" ? key : String(key); }\nfunction storage_toPrimitive(input, hint) { if (storage_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (storage_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\nvar Area = /*#__PURE__*/function () {\n  function Area() {\n    storage_classCallCheck(this, Area);\n    storage_defineProperty(this, "_lines", []);\n  }\n  storage_createClass(Area, [{\n    key: "get",\n    value: function get(idx) {\n      return this._lines[idx];\n    }\n  }, {\n    key: "getLineAbove",\n    value: function getLineAbove(offsetY) {\n      var row = 0;\n      var lines = this._lines;\n      while (row < lines.length) {\n        if (lines[row].reduceHeight > offsetY) {\n          break;\n        }\n        row++;\n      }\n      return Math.min(row, lines.length - 1);\n    }\n  }, {\n    key: "truncate",\n    value: function truncate(configs) {\n      var l = Line.create(configs);\n      this._lines = [l];\n      return l;\n    }\n  }, {\n    key: "push",\n    value: function push(line) {\n      this._lines.push(line);\n    }\n  }, {\n    key: "forEach",\n    value: function forEach(callback) {\n      this._lines.forEach(callback);\n    }\n  }, {\n    key: "length",\n    value: function length() {\n      return this._lines.length;\n    }\n  }]);\n  return Area;\n}();\nvar Line = /*#__PURE__*/function () {\n  function Line() {\n    var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    storage_classCallCheck(this, Line);\n    storage_defineProperty(this, "width", 0);\n    storage_defineProperty(this, "anchorY", 0);\n    storage_defineProperty(this, "height", 0);\n    storage_defineProperty(this, "reduceHeight", 0);\n    storage_defineProperty(this, "_elements", []);\n    storage_defineProperty(this, "_elements", []);\n    Object.assign(this, configs);\n  }\n  storage_createClass(Line, [{\n    key: "get",\n    value: function get(idx) {\n      return this._elements[idx];\n    }\n  }, {\n    key: "length",\n    value: function length() {\n      return this._elements.length;\n    }\n  }, {\n    key: "insert",\n    value: function insert(idx, elem) {\n      this._elements.splice(idx, 0, elem);\n    }\n  }, {\n    key: "push",\n    value: function push(elem) {\n      this._elements.push(elem);\n    }\n  }, {\n    key: "tail",\n    value: function tail() {\n      return this._elements[this._elements.length - 1];\n    }\n  }, {\n    key: "copy",\n    value: function copy() {\n      return this._elements.slice();\n    }\n  }, {\n    key: "getColumnNearest",\n    value: function getColumnNearest(offsetX, elementSpace, fontSize, fontFamily, editor) {\n      var elements = this._elements;\n      if (offsetX >= this.width) {\n        var c = elements.length - 1;\n        var elem = elements[c];\n        var q = 0;\n        if (elem.type === \'text\') {\n          q = elem.source.length;\n        }\n        return [c, q];\n      } else {\n        var elem_idx = 0;\n        var last_c = 0;\n        var _c = 0;\n        var lastel = null;\n        while (elem_idx < elements.length - 1) {\n          last_c = _c;\n          var el = elements[elem_idx];\n          if (el.type !== \'text\') {\n            var doubleMargin = lastel && lastel.type === \'text\';\n            var margin = doubleMargin ? elementSpace * 2 : elementSpace;\n            _c += el.width + margin;\n          } else {\n            _c += el.width;\n          }\n          if (_c > offsetX) {\n            lastel = el;\n            break;\n          }\n          lastel = el;\n          elem_idx++;\n        }\n        if (_c <= offsetX) {\n          last_c = _c;\n        }\n        var textmeta = elements[elem_idx];\n        if (textmeta.type === \'text\') {\n          var offx = offsetX - last_c;\n          var idx = calculateOffsetByWidth(offx, textmeta, fontSize, fontFamily, editor.spaceHolder);\n          return [elem_idx, idx];\n        } else {\n          var _offx = offsetX - last_c;\n          if (_offx > lastel.width / 2) {\n            return [elem_idx + 1, 0];\n          } else {\n            return [elem_idx, 0];\n          }\n        }\n      }\n    }\n  }, {\n    key: "forEach",\n    value: function forEach(callback) {\n      this._elements.forEach(callback);\n    }\n  }], [{\n    key: "create",\n    value: function create(configs) {\n      var l = new Line(configs);\n      return l;\n    }\n  }]);\n  return Line;\n}();\nvar FlattenTextElements = /*#__PURE__*/function () {\n  function FlattenTextElements() {\n    storage_classCallCheck(this, FlattenTextElements);\n    storage_defineProperty(this, "_textElements", []);\n    storage_defineProperty(this, "_records", []);\n    storage_defineProperty(this, "_caretRecord", null);\n  }\n  storage_createClass(FlattenTextElements, [{\n    key: "insertBefore",\n    value: function insertBefore(anchor, elem) {\n      var idx = this.findIndex(anchor);\n      this.inersetAt(idx, elem);\n    }\n  }, {\n    key: "insertAfter",\n    value: function insertAfter(anchor, elem, needWrap) {\n      var idx = this.findIndex(anchor);\n      // const next = this.get(idx+1);\n      if (needWrap) {\n        elem.setNeedWrap(true);\n      }\n      this.inersetAt(idx + 1, elem);\n    }\n  }, {\n    key: "findIndex",\n    value: function findIndex(elem) {\n      return this._textElements.findIndex(function (el) {\n        return el === elem;\n      });\n    }\n  }, {\n    key: "get",\n    value: function get(idx) {\n      return this._textElements[idx];\n    }\n  }, {\n    key: "from",\n    value: function from(elements) {\n      this._textElements = elements;\n    }\n  }, {\n    key: "inersetAt",\n    value: function inersetAt(idx, elem) {\n      this.splice(idx, 0, elem);\n    }\n  }, {\n    key: "push",\n    value: function push(elem) {\n      this.splice(this.length(), 0, elem);\n    }\n  }, {\n    key: "remove",\n    value: function remove(idx) {\n      this.splice(idx, 1);\n    }\n  }, {\n    key: "splice",\n    value: function splice() {\n      var _this$_textElements;\n      var removed = (_this$_textElements = this._textElements).splice.apply(_this$_textElements, arguments);\n      this._records.push({\n        op: \'splice\',\n        args: arguments,\n        removed: removed\n      });\n    }\n  }, {\n    key: "slice",\n    value: function slice() {\n      var _this$_textElements2;\n      return (_this$_textElements2 = this._textElements).slice.apply(_this$_textElements2, arguments);\n    }\n  }, {\n    key: "copy",\n    value: function copy() {\n      return this._textElements.slice();\n    }\n  }, {\n    key: "isEmpty",\n    value: function isEmpty() {\n      return this._textElements.length === 1 && this._textElements[0].source === \'\';\n    }\n  }, {\n    key: "forEach",\n    value: function forEach(callback) {\n      this._textElements.forEach(callback);\n    }\n  }, {\n    key: "tail",\n    value: function tail() {\n      return this._textElements[this._textElements.length - 1];\n    }\n  }, {\n    key: "filter",\n    value: function filter(callback) {\n      return this._textElements.filter(callback);\n    }\n  }, {\n    key: "length",\n    value: function length() {\n      return this._textElements.length;\n    }\n  }, {\n    key: "startRecord",\n    value: function startRecord() {\n      this._caretRecord = {\n        before: null,\n        after: null\n      };\n      this._records = [];\n      return this._records;\n    }\n  }, {\n    key: "getRecord",\n    value: function getRecord() {\n      return this._records;\n    }\n  }, {\n    key: "recordBeforeCaret",\n    value: function recordBeforeCaret(caret) {\n      this._caretRecord.before = caret.toRange();\n    }\n  }, {\n    key: "recordAfterCaret",\n    value: function recordAfterCaret(caret) {\n      this._caretRecord.after = caret.toRange();\n    }\n  }, {\n    key: "getCaretRecord",\n    value: function getCaretRecord() {\n      return this._caretRecord;\n    }\n  }, {\n    key: "collectRecords",\n    value: function collectRecords() {\n      return this._records;\n    }\n  }], [{\n    key: "create",\n    value: function create(elements) {\n      var _e = new FlattenTextElements();\n      _e.from(elements);\n      return _e;\n    }\n  }]);\n  return FlattenTextElements;\n}();\nvar TextElement = /*#__PURE__*/function () {\n  function TextElement(type, source) {\n    storage_classCallCheck(this, TextElement);\n    storage_defineProperty(this, "needWrap", false);\n    storage_defineProperty(this, "width", 0);\n    storage_defineProperty(this, "reduceWidth", 0);\n    storage_defineProperty(this, "height", 0);\n    storage_defineProperty(this, "anchorX", 0);\n    storage_defineProperty(this, "anchorY", 0);\n    storage_defineProperty(this, "dirty", true);\n    storage_defineProperty(this, "isTail", false);\n    storage_defineProperty(this, "_spaceRecords", []);\n    storage_defineProperty(this, "_spacedContentSegmnent", []);\n    storage_defineProperty(this, "_returnSymbol", {\n      symbol: \'↲\',\n      width: 0\n    });\n    this.type = type;\n    this.source = source;\n  }\n  storage_createClass(TextElement, [{\n    key: "getRenderSource",\n    value: function getRenderSource(spaceHolder) {\n      var content = this.source;\n      if (spaceHolder.enable) {\n        return content.replace(/\\s/g, spaceHolder.spacePlaceholder);\n      }\n      return content;\n    }\n  }, {\n    key: "setSourceWithRecord",\n    value: function setSourceWithRecord(source, spaceHolder, records) {\n      var lastSource = this.source;\n      this.setSource(source, spaceHolder);\n      if (records) {\n        records.push({\n          op: \'setSource\',\n          args: [this, source, lastSource]\n        });\n      }\n    }\n  }, {\n    key: "setSource",\n    value: function setSource(source, spaceHolder) {\n      this.source = source;\n      this.dirty = true;\n      if (spaceHolder.enable) {\n        var r = this._spaceRecords;\n        var p = spaceHolder.spacePlaceholder;\n        r.length = 0;\n        var lastOffset;\n        source.replace(/\\s/g, function (_, offset) {\n          if (lastOffset === undefined) {\n            lastOffset = offset;\n            r.push(offset);\n          }\n          if (offset - lastOffset > 1) {\n            r.push(lastOffset);\n            r.push(offset);\n          }\n          lastOffset = offset;\n          return p;\n        });\n        if (lastOffset !== undefined) {\n          r.push(lastOffset);\n        }\n      }\n    }\n  }, {\n    key: "setNeedWrap",\n    value: function setNeedWrap(needWrap, records) {\n      var lastWrap = this.needWrap;\n      this.needWrap = needWrap;\n      if (lastWrap !== needWrap && records) {\n        records.push({\n          op: \'setNeedWrap\',\n          args: [this, needWrap, lastWrap]\n        });\n      }\n    }\n  }, {\n    key: "shift",\n    value: function shift(offset, step) {\n      if (this.type === \'text\') {\n        var content = this.source;\n        var l = content.length;\n        var nextOffset = offset + step;\n        if (nextOffset < 0) {\n          return \'prev\';\n        }\n        if (nextOffset > l) {\n          //- ((isTail || this.needWrap) ? 0 : 1)) {\n          return \'next\';\n        }\n        return \'self\';\n      } else {\n        if (step > 0) {\n          return \'next\';\n        }\n        if (step < 0) {\n          return \'prev\';\n        }\n      }\n    }\n  }, {\n    key: "tailOffset",\n    value: function tailOffset() {\n      if (this.type === \'text\') {\n        if (this.needWrap || this.isTail) {\n          return this.source.length;\n        } else {\n          return Math.max(0, this.source.length - 1);\n        }\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: "headOffset",\n    value: function headOffset() {\n      return 0;\n    }\n  }, {\n    key: "preCalculateText",\n    value: function preCalculateText(ctx, spaceHolder) {\n      var content = this.getRenderSource(spaceHolder);\n      this.width = ctx.measureText(content).width;\n      this.dirty = false;\n      if (spaceHolder.enable) {\n        var s_width = ctx.measureText(spaceHolder.spacePlaceholder).width;\n        this._returnSymbol.width = ctx.measureText(this._returnSymbol.symbol).width;\n        var r2 = this._spacedContentSegmnent;\n        var lastOffset = 0;\n        r2.length = 0;\n        if (this._spaceRecords.length) {\n          var r = this._spaceRecords;\n          var l = r.length;\n          var i = 0;\n          while (i < l) {\n            var f = r[i++];\n            var t = r[i++];\n            var q = content.substring(lastOffset, f);\n            r2.push([q, ctx.measureText(q).width, \'text\']);\n            r2.push([content.substring(f, t + 1), (t - f + 1) * s_width, \'placeholder\']);\n            lastOffset = t + 1;\n          }\n        }\n        if (lastOffset < content.length) {\n          var _q = content.substring(lastOffset);\n          r2.push([_q, ctx.measureText(_q).width, \'text\']);\n        }\n        if (this.needWrap) {\n          this.width += this._returnSymbol.width;\n        }\n      }\n    }\n  }, {\n    key: "render",\n    value: function render(ctx, spaceHolder, textColor) {\n      var _this = this;\n      if (spaceHolder.enable) {\n        var hw = this.width / 2;\n        var _w = -hw + this.anchorX;\n        var spacePlaceholderColor = spaceHolder.spacePlaceholderColor;\n        this._spacedContentSegmnent.forEach(function (seg) {\n          ctx.fillStyle = seg[2] === \'text\' ? textColor : spacePlaceholderColor;\n          var t = seg[1] / 2;\n          _w += t;\n          ctx.fillText(seg[0], _w, _this.anchorY);\n          _w += t;\n        });\n        if (this.needWrap) {\n          ctx.save();\n          ctx.font = spaceHolder.returnFont;\n          ctx.fillStyle = spacePlaceholderColor;\n          ctx.fillText(this._returnSymbol.symbol, _w + this._returnSymbol.width / 2, this.anchorY);\n          ctx.restore();\n        }\n        return;\n      }\n      ctx.fillText(this.source, this.anchorX, this.anchorY);\n    }\n  }]);\n  return TextElement;\n}();\n;// CONCATENATED MODULE: ./src/core/instance/text-group/base/range.js\nfunction range_typeof(obj) { "@babel/helpers - typeof"; return range_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, range_typeof(obj); }\nfunction range_slicedToArray(arr, i) { return range_arrayWithHoles(arr) || range_iterableToArrayLimit(arr, i) || range_unsupportedIterableToArray(arr, i) || range_nonIterableRest(); }\nfunction range_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction range_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return range_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return range_arrayLikeToArray(o, minLen); }\nfunction range_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction range_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction range_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction range_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction range_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, range_toPropertyKey(descriptor.key), descriptor); } }\nfunction range_createClass(Constructor, protoProps, staticProps) { if (protoProps) range_defineProperties(Constructor.prototype, protoProps); if (staticProps) range_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction range_defineProperty(obj, key, value) { key = range_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction range_toPropertyKey(arg) { var key = range_toPrimitive(arg, "string"); return range_typeof(key) === "symbol" ? key : String(key); }\nfunction range_toPrimitive(input, hint) { if (range_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (range_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\nvar Range = /*#__PURE__*/function () {\n  function Range() {\n    range_classCallCheck(this, Range);\n    range_defineProperty(this, "_enable", false);\n    range_defineProperty(this, "_rangeFrom", null);\n    // [row, elem_idx, offset]\n    range_defineProperty(this, "_rangeTo", null);\n    // [row, elem_idx, offset]\n    range_defineProperty(this, "_initialRange", null);\n  }\n  range_createClass(Range, [{\n    key: "setInitialRange",\n    value: function setInitialRange(initialRange) {\n      this._initialRange = initialRange;\n    }\n  }, {\n    key: "getRangeFrom",\n    value: function getRangeFrom() {\n      return this._rangeFrom;\n    }\n  }, {\n    key: "getRangeTo",\n    value: function getRangeTo() {\n      return this._rangeTo;\n    }\n  }, {\n    key: "isEnable",\n    value: function isEnable() {\n      return this._enable;\n    }\n  }, {\n    key: "enable",\n    value: function enable() {\n      this._enable = true;\n    }\n  }, {\n    key: "disable",\n    value: function disable() {\n      this._enable = false;\n    }\n  }, {\n    key: "handleCaret",\n    value: function handleCaret(caret) {\n      var _this$_rangeTo = range_slicedToArray(this._rangeTo, 3),\n        a = _this$_rangeTo[0],\n        b = _this$_rangeTo[1],\n        c = _this$_rangeTo[2];\n      caret.setRow(a);\n      caret.setColumn([b, c]);\n    }\n  }, {\n    key: "setRange",\n    value: function setRange(another) {\n      var a = this._initialRange;\n      if (this._compareRange(a, another)) {\n        this._rangeFrom = a;\n        this._rangeTo = another;\n      } else {\n        this._rangeFrom = another;\n        this._rangeTo = a;\n      }\n    }\n  }, {\n    key: "_compareRange",\n    value: function _compareRange(r1, r2) {\n      if (r1[0] > r2[0]) {\n        return false;\n      }\n      if (r1[0] === r2[0] && r1[1] > r2[1]) {\n        return false;\n      }\n      if (r1[0] === r2[0] && r1[1] === r2[1] && r1[2] > r2[2]) {\n        return false;\n      }\n      return true;\n    }\n\n    // TODO \n  }, {\n    key: "getRangeCopy",\n    value: function getRangeCopy(editor) {\n      if (this._enable) {\n        var area = editor._area;\n        var caret = editor._caret;\n        var rangeFrom = this._rangeFrom;\n        var rangeTo = this._rangeTo;\n        var elemFrom = area.get(rangeFrom[0]).get(rangeFrom[1]);\n        var elemTo = area.get(rangeTo[0]).get(rangeTo[1]);\n        if (elemFrom === elemTo) {\n          var c = elemFrom.source;\n          return c.substring(rangeFrom[2], rangeTo[2]);\n        }\n        var flattenTxtElem = editor._flattenTxtElem;\n        var preContent = \'\';\n        var afterContent = \'\';\n        var fromIdx = flattenTxtElem.findIndex(elemFrom);\n        var toIdx = flattenTxtElem.findIndex(elemTo);\n        var elems = flattenTxtElem.slice(fromIdx, toIdx + 1);\n        var elements = elems.slice(1, elems.length - 1).filter(function (el) {\n          return el.type === \'text\';\n        });\n        preContent = elemFrom.source.substring(rangeFrom[2]);\n        afterContent = elemTo.source.substring(0, rangeTo[2]);\n        var content = preContent;\n        if (elemFrom.needWrap) {\n          content += \'\\n\';\n        }\n        elements.forEach(function (el) {\n          content += el.source;\n          if (el.needWrap) {\n            content += \'\\n\';\n          }\n        });\n        return content + afterContent;\n      }\n    }\n  }, {\n    key: "delete",\n    value: function _delete(editor, records) {\n      if (this._enable) {\n        var area = editor._area;\n        var caret = editor._caret;\n        var rangeFrom = this._rangeFrom;\n        var rangeTo = this._rangeTo;\n        var elemFrom = area.get(rangeFrom[0]).get(rangeFrom[1]);\n        var elemTo = area.get(rangeTo[0]).get(rangeTo[1]);\n        var _rangeFrom = range_slicedToArray(rangeFrom, 3),\n          row = _rangeFrom[0],\n          elem_idx = _rangeFrom[1],\n          offset = _rangeFrom[2];\n        records.push({\n          op: \'range\',\n          args: [rangeFrom.slice(), rangeTo.slice()]\n        });\n        if (elemFrom === elemTo) {\n          var c = elemFrom.source;\n          elemFrom.setSourceWithRecord(c.substring(0, rangeFrom[2]) + c.substring(rangeTo[2]), editor.spaceHolder, records);\n        } else {\n          var flattenTxtElem = editor._flattenTxtElem;\n          var preContent = \'\';\n          var afterContent = \'\';\n          var preElement;\n          var afterElement;\n          var fromIdx = flattenTxtElem.findIndex(elemFrom);\n          var toIdx = flattenTxtElem.findIndex(elemTo);\n          var endTextNeedWrap = false;\n          if (elemFrom.type === \'text\') {\n            preContent = elemFrom.source.substring(0, rangeFrom[2]);\n          } else {\n            preElement = flattenTxtElem.get(fromIdx - 1);\n          }\n          if (elemTo.type === \'text\') {\n            afterContent = elemTo.source.substring(rangeTo[2]);\n            endTextNeedWrap = elemTo.needWrap;\n          } else {\n            afterElement = flattenTxtElem.get(toIdx - 1);\n          }\n          if (preElement) {\n            flattenTxtElem.splice(fromIdx, toIdx - fromIdx + 1);\n            if (preElement.type === \'text\') {\n              if (preElement.needWrap) {\n                row -= 1;\n              } else {\n                elem_idx -= 1;\n              }\n              offset = preElement.source.length;\n              preElement.setSourceWithRecord(preElement.source + afterContent, editor.spaceHolder, records);\n              preElement.setNeedWrap(endTextNeedWrap, records);\n            } else {\n              var t = new TextElement(\'text\', preContent + afterContent);\n              t.setNeedWrap(endTextNeedWrap, records);\n              flattenTxtElem.splice(fromIdx, 0, t);\n            }\n          } else {\n            flattenTxtElem.splice(fromIdx, toIdx - fromIdx);\n            if (afterElement) {\n              var _t = new TextElement(\'text\', preContent);\n              flattenTxtElem.splice(fromIdx, 0, _t);\n            } else {\n              elemTo.setSourceWithRecord(preContent + afterContent, editor.spaceHolder, records);\n            }\n          }\n          if (flattenTxtElem.length() === 0) {\n            // elem_idx = 0;\n            flattenTxtElem.push(new TextElement(\'text\', \'\'));\n          }\n        }\n        this.disable();\n        caret.setRow(row);\n        caret.setColumn([elem_idx, offset]);\n      }\n    }\n  }]);\n  return Range;\n}();\n/* harmony default export */ const range = (Range);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/undoredo.js\nfunction undoredo_toConsumableArray(arr) { return undoredo_arrayWithoutHoles(arr) || undoredo_iterableToArray(arr) || undoredo_unsupportedIterableToArray(arr) || undoredo_nonIterableSpread(); }\nfunction undoredo_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction undoredo_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return undoredo_arrayLikeToArray(arr); }\nfunction _toArray(arr) { return undoredo_arrayWithHoles(arr) || undoredo_iterableToArray(arr) || undoredo_unsupportedIterableToArray(arr) || undoredo_nonIterableRest(); }\nfunction undoredo_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\nfunction undoredo_slicedToArray(arr, i) { return undoredo_arrayWithHoles(arr) || undoredo_iterableToArrayLimit(arr, i) || undoredo_unsupportedIterableToArray(arr, i) || undoredo_nonIterableRest(); }\nfunction undoredo_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction undoredo_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return undoredo_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return undoredo_arrayLikeToArray(o, minLen); }\nfunction undoredo_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction undoredo_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction undoredo_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction undoredo_typeof(obj) { "@babel/helpers - typeof"; return undoredo_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, undoredo_typeof(obj); }\nfunction undoredo_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction undoredo_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, undoredo_toPropertyKey(descriptor.key), descriptor); } }\nfunction undoredo_createClass(Constructor, protoProps, staticProps) { if (protoProps) undoredo_defineProperties(Constructor.prototype, protoProps); if (staticProps) undoredo_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction undoredo_defineProperty(obj, key, value) { key = undoredo_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction undoredo_toPropertyKey(arg) { var key = undoredo_toPrimitive(arg, "string"); return undoredo_typeof(key) === "symbol" ? key : String(key); }\nfunction undoredo_toPrimitive(input, hint) { if (undoredo_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (undoredo_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction isSetSourceBatch(x) {\n  return x.length === 1 && x[0].op === \'setSource\';\n}\nvar UndoRedo = /*#__PURE__*/function () {\n  function UndoRedo() {\n    undoredo_classCallCheck(this, UndoRedo);\n    undoredo_defineProperty(this, "_undo", []);\n    undoredo_defineProperty(this, "_redo", []);\n    undoredo_defineProperty(this, "_editor", null);\n  }\n  undoredo_createClass(UndoRedo, [{\n    key: "write",\n    value: function write(x, caretRecord) {\n      if (x.length === 0) {\n        return;\n      }\n      if (isSetSourceBatch(x)) {\n        var t = x[0];\n        var lastUndo = this.getLastUndo();\n        if (lastUndo && isSetSourceBatch(lastUndo._batch)) {\n          var q = lastUndo._batch[0];\n          if (q.args[0] === t.args[0]) {\n            q.args[1] = t.args[1];\n            lastUndo._caretMetaTo = caretRecord.after;\n            return;\n          }\n        }\n      }\n      var r = new BatchAction(x);\n      r._caretMetaFrom = caretRecord.before;\n      r._caretMetaTo = caretRecord.after;\n      this._undo.push(r);\n      if (this._undo.length > UndoRedo._length) {\n        this._undo.splice(0, 1);\n      }\n      if (this._redo.length) {\n        this._redo = [];\n      }\n    }\n  }, {\n    key: "getLastUndo",\n    value: function getLastUndo() {\n      return this._undo[this._undo.length - 1];\n    }\n  }, {\n    key: "undo",\n    value: function undo() {\n      var x = this._undo.pop();\n      if (x) {\n        x.undo(this._editor);\n        this._redo.push(x);\n      }\n      return x;\n    }\n  }, {\n    key: "redo",\n    value: function redo() {\n      var x = this._redo.pop();\n      while (x && x.SKIP_REDO) {\n        x = this._redo.pop();\n      }\n      if (x) {\n        x.redo(this._editor);\n        this._undo.push(x);\n      }\n      return x;\n    }\n  }]);\n  return UndoRedo;\n}();\nundoredo_defineProperty(UndoRedo, "_length", 50);\n\nvar BatchAction = /*#__PURE__*/function () {\n  function BatchAction(batch) {\n    undoredo_classCallCheck(this, BatchAction);\n    undoredo_defineProperty(this, "_batch", []);\n    undoredo_defineProperty(this, "_caretMetaFrom", null);\n    undoredo_defineProperty(this, "_caretMetaTo", null);\n    this._batch = batch;\n  }\n  undoredo_createClass(BatchAction, [{\n    key: "updateCaretMetaTo",\n    value: function updateCaretMetaTo(meta) {\n      this._caretMetaTo = meta;\n    }\n  }, {\n    key: "undo",\n    value: function undo(editor) {\n      this._batch.slice().reverse().forEach(function (action) {\n        switch (action.op) {\n          case \'range\':\n            var _action$args = undoredo_slicedToArray(action.args, 2),\n              rangeFrom = _action$args[0],\n              rangeTo = _action$args[1];\n            var range = editor._range;\n            range.setInitialRange(rangeFrom);\n            range.setRange(rangeTo);\n            range.enable();\n            break;\n          case \'setSource\':\n            var _action$args2 = undoredo_slicedToArray(action.args, 3),\n              elem = _action$args2[0],\n              s = _action$args2[1],\n              ls = _action$args2[2];\n            elem.setSource(ls, editor.spaceHolder);\n            break;\n          case \'setNeedWrap\':\n            var _action$args3 = undoredo_slicedToArray(action.args, 3),\n              o = _action$args3[0],\n              p = _action$args3[1],\n              q = _action$args3[2];\n            o.needWrap = q;\n            o.dirty = true;\n            break;\n          case \'splice\':\n            var flattenTxtElem = editor._flattenTxtElem;\n            var _action$args4 = _toArray(action.args),\n              a = _action$args4[0],\n              b = _action$args4[1],\n              c = _action$args4.slice(2);\n            var removed = action.removed;\n            var i = 0;\n            if (c) {\n              i = c.length;\n            }\n            flattenTxtElem.splice.apply(flattenTxtElem, [a, i].concat(undoredo_toConsumableArray(removed)));\n            break;\n        }\n      });\n      editor._caret.fromRange(this._caretMetaFrom);\n    }\n  }, {\n    key: "redo",\n    value: function redo(editor) {\n      this._batch.forEach(function (action) {\n        switch (action.op) {\n          case \'setSource\':\n            var _action$args5 = undoredo_slicedToArray(action.args, 3),\n              elem = _action$args5[0],\n              s = _action$args5[1],\n              ls = _action$args5[2];\n            elem.setSource(s, editor.spaceHolder);\n            break;\n          case \'setNeedWrap\':\n            var _action$args6 = undoredo_slicedToArray(action.args, 3),\n              o = _action$args6[0],\n              p = _action$args6[1],\n              q = _action$args6[2];\n            o.needWrap = p;\n            o.dirty = true;\n            break;\n          case \'splice\':\n            var flattenTxtElem = editor._flattenTxtElem;\n            flattenTxtElem.splice.apply(flattenTxtElem, undoredo_toConsumableArray(action.args));\n            break;\n        }\n      });\n      editor._caret.fromRange(this._caretMetaTo);\n    }\n  }]);\n  return BatchAction;\n}();\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/base.js\nfunction base_typeof(obj) { "@babel/helpers - typeof"; return base_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, base_typeof(obj); }\nfunction base_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction base_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, base_toPropertyKey(descriptor.key), descriptor); } }\nfunction base_createClass(Constructor, protoProps, staticProps) { if (protoProps) base_defineProperties(Constructor.prototype, protoProps); if (staticProps) base_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction base_toPropertyKey(arg) { var key = base_toPrimitive(arg, "string"); return base_typeof(key) === "symbol" ? key : String(key); }\nfunction base_toPrimitive(input, hint) { if (base_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (base_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nvar Command = /*#__PURE__*/function () {\n  function Command(editor) {\n    base_classCallCheck(this, Command);\n    this._editor = editor;\n  }\n  base_createClass(Command, [{\n    key: "exec",\n    value: function exec() {}\n  }], [{\n    key: "create",\n    value: function create(editor) {\n      return new this(editor);\n    }\n  }]);\n  return Command;\n}();\n/* harmony default export */ const base = (Command);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/movement.js\nfunction movement_typeof(obj) { "@babel/helpers - typeof"; return movement_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, movement_typeof(obj); }\nfunction movement_slicedToArray(arr, i) { return movement_arrayWithHoles(arr) || movement_iterableToArrayLimit(arr, i) || movement_unsupportedIterableToArray(arr, i) || movement_nonIterableRest(); }\nfunction movement_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction movement_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return movement_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return movement_arrayLikeToArray(o, minLen); }\nfunction movement_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction movement_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction movement_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction movement_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction movement_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, movement_toPropertyKey(descriptor.key), descriptor); } }\nfunction movement_createClass(Constructor, protoProps, staticProps) { if (protoProps) movement_defineProperties(Constructor.prototype, protoProps); if (staticProps) movement_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction movement_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) movement_setPrototypeOf(subClass, superClass); }\nfunction movement_setPrototypeOf(o, p) { movement_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return movement_setPrototypeOf(o, p); }\nfunction movement_createSuper(Derived) { var hasNativeReflectConstruct = movement_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = movement_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = movement_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return movement_possibleConstructorReturn(this, result); }; }\nfunction movement_possibleConstructorReturn(self, call) { if (call && (movement_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return movement_assertThisInitialized(self); }\nfunction movement_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction movement_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction movement_getPrototypeOf(o) { movement_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return movement_getPrototypeOf(o); }\nfunction movement_defineProperty(obj, key, value) { key = movement_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction movement_toPropertyKey(arg) { var key = movement_toPrimitive(arg, "string"); return movement_typeof(key) === "symbol" ? key : String(key); }\nfunction movement_toPrimitive(input, hint) { if (movement_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (movement_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\nvar ArrowLeftCommand = /*#__PURE__*/function (_Command) {\n  movement_inherits(ArrowLeftCommand, _Command);\n  var _super = movement_createSuper(ArrowLeftCommand);\n  function ArrowLeftCommand() {\n    movement_classCallCheck(this, ArrowLeftCommand);\n    return _super.apply(this, arguments);\n  }\n  movement_createClass(ArrowLeftCommand, [{\n    key: "exec",\n    value: function exec() {\n      var editor = this._editor;\n      editor._range.disable();\n      var flattenTxtElem = editor._flattenTxtElem;\n      var caret = editor._caret;\n      var row = caret.getRow();\n      var column = caret.getColumn();\n      var _column = movement_slicedToArray(column, 2),\n        elemidx = _column[0],\n        offset = _column[1];\n      var line = editor._area.get(row);\n      var element = line.get(elemidx);\n      var idx = flattenTxtElem.findIndex(element);\n      var result = element.shift(offset, -1);\n      switch (result) {\n        case \'prev\':\n          if (elemidx > 0) {\n            var el = line.get(elemidx - 1);\n            caret.setColumn([elemidx - 1, el.tailOffset()]);\n          } else if (idx > 0) {\n            var preRow = row - 1;\n            var preElemidx = editor._area.get(preRow).length() - 1;\n            var _offset = flattenTxtElem.get(idx - 1).tailOffset();\n            caret.setRow(preRow);\n            caret.setColumn([preElemidx, _offset]);\n          }\n          break;\n        case \'self\':\n          caret.setColumn(1, offset - 1);\n          break;\n      }\n      caret.refresh();\n      editor.syncShadowInputPosition();\n      editor._jflow._render();\n    }\n  }]);\n  return ArrowLeftCommand;\n}(base);\nmovement_defineProperty(ArrowLeftCommand, "_name", KEYBOARD_COMMANDS.ARROW_LEFT);\nvar ArrowRightCommand = /*#__PURE__*/function (_Command2) {\n  movement_inherits(ArrowRightCommand, _Command2);\n  var _super2 = movement_createSuper(ArrowRightCommand);\n  function ArrowRightCommand() {\n    movement_classCallCheck(this, ArrowRightCommand);\n    return _super2.apply(this, arguments);\n  }\n  movement_createClass(ArrowRightCommand, [{\n    key: "exec",\n    value: function exec() {\n      var editor = this._editor;\n      editor._range.disable();\n      var flattenTxtElem = editor._flattenTxtElem;\n      var caret = editor._caret;\n      var row = caret.getRow();\n      var column = caret.getColumn();\n      var _column2 = movement_slicedToArray(column, 2),\n        elemidx = _column2[0],\n        offset = _column2[1];\n      var line = editor._area.get(row);\n      var element = line.get(elemidx);\n      var idx = flattenTxtElem.findIndex(element);\n      var result = element.shift(offset, 1, idx === flattenTxtElem.length() - 1);\n      switch (result) {\n        case \'next\':\n          if (elemidx < line.length() - 1) {\n            var el = line.get(elemidx + 1);\n            if (element.type === \'text\' && el.type !== \'text\') {\n              caret.setColumn([elemidx + 2, el.headOffset()]);\n            } else {\n              caret.setColumn([elemidx + 1, el.headOffset()]);\n            }\n          } else if (idx < flattenTxtElem.length() - 1) {\n            var afterRow = row + 1;\n            var _offset2 = flattenTxtElem.get(idx + 1).headOffset();\n            caret.setRow(afterRow);\n            caret.setColumn([0, _offset2]);\n          }\n          break;\n        case \'self\':\n          caret.setColumn(1, offset + 1);\n          break;\n      }\n      caret.refresh();\n      editor.syncShadowInputPosition();\n      editor._jflow._render();\n    }\n  }]);\n  return ArrowRightCommand;\n}(base);\nmovement_defineProperty(ArrowRightCommand, "_name", KEYBOARD_COMMANDS.ARROW_RIGHT);\nvar ArrowUpCommand = /*#__PURE__*/function (_Command3) {\n  movement_inherits(ArrowUpCommand, _Command3);\n  var _super3 = movement_createSuper(ArrowUpCommand);\n  function ArrowUpCommand() {\n    movement_classCallCheck(this, ArrowUpCommand);\n    return _super3.apply(this, arguments);\n  }\n  movement_createClass(ArrowUpCommand, [{\n    key: "exec",\n    value: function exec() {\n      this._editor._range.disable();\n      var nextRow = this._editor._caret.getRow() - 1;\n      if (nextRow > -1) {\n        this._handler(nextRow);\n      }\n    }\n  }]);\n  return ArrowUpCommand;\n}(base);\nmovement_defineProperty(ArrowUpCommand, "_name", KEYBOARD_COMMANDS.ARROW_UP);\nvar ArrowDownCommand = /*#__PURE__*/function (_Command4) {\n  movement_inherits(ArrowDownCommand, _Command4);\n  var _super4 = movement_createSuper(ArrowDownCommand);\n  function ArrowDownCommand() {\n    movement_classCallCheck(this, ArrowDownCommand);\n    return _super4.apply(this, arguments);\n  }\n  movement_createClass(ArrowDownCommand, [{\n    key: "exec",\n    value: function exec() {\n      this._editor._range.disable();\n      var nextRow = this._editor._caret.getRow() + 1;\n      if (nextRow < this._editor._area.length()) {\n        this._handler(nextRow);\n      }\n    }\n  }]);\n  return ArrowDownCommand;\n}(base);\nmovement_defineProperty(ArrowDownCommand, "_name", KEYBOARD_COMMANDS.ARROW_DOWN);\nvar _mixin = {\n  _handler: function _handler(nextRow) {\n    var editor = this._editor;\n    var caret = editor._caret;\n    var row = caret.getRow();\n    var column = caret.getColumn();\n    var _column3 = movement_slicedToArray(column, 2),\n      elemidx = _column3[0],\n      offset = _column3[1];\n    var area = editor._area;\n    var line = area.get(row);\n    var currElem = line.get(elemidx);\n    var currElemReduceWidth = currElem.reduceWidth;\n    if (offset > 0) {\n      currElemReduceWidth += editor.measureTextWidth(currElem.getRenderSource(editor.spaceHolder).substring(0, offset));\n    }\n    var nextLine = area.get(nextRow);\n    var nextColumn = nextLine.getColumnNearest(currElemReduceWidth, editor.elementSpace, editor.fontSize, editor.fontFamily, editor);\n    caret.setRow(nextRow);\n    caret.setColumn(nextColumn);\n    caret.refresh();\n    editor.syncShadowInputPosition();\n    editor._jflow._render();\n  }\n};\nObject.assign(ArrowUpCommand.prototype, _mixin);\nObject.assign(ArrowDownCommand.prototype, _mixin);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/input.js\nfunction input_typeof(obj) { "@babel/helpers - typeof"; return input_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, input_typeof(obj); }\nfunction input_slicedToArray(arr, i) { return input_arrayWithHoles(arr) || input_iterableToArrayLimit(arr, i) || input_unsupportedIterableToArray(arr, i) || input_nonIterableRest(); }\nfunction input_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction input_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return input_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return input_arrayLikeToArray(o, minLen); }\nfunction input_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction input_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction input_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction input_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction input_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, input_toPropertyKey(descriptor.key), descriptor); } }\nfunction input_createClass(Constructor, protoProps, staticProps) { if (protoProps) input_defineProperties(Constructor.prototype, protoProps); if (staticProps) input_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction input_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) input_setPrototypeOf(subClass, superClass); }\nfunction input_setPrototypeOf(o, p) { input_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return input_setPrototypeOf(o, p); }\nfunction input_createSuper(Derived) { var hasNativeReflectConstruct = input_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = input_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = input_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return input_possibleConstructorReturn(this, result); }; }\nfunction input_possibleConstructorReturn(self, call) { if (call && (input_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return input_assertThisInitialized(self); }\nfunction input_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction input_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction input_getPrototypeOf(o) { input_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return input_getPrototypeOf(o); }\nfunction input_defineProperty(obj, key, value) { key = input_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction input_toPropertyKey(arg) { var key = input_toPrimitive(arg, "string"); return input_typeof(key) === "symbol" ? key : String(key); }\nfunction input_toPrimitive(input, hint) { if (input_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (input_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n\nfunction _blandAdjacentElement(editor, elem1, elem2, defaultOffset, records) {\n  if (!elem1) {\n    return [defaultOffset, false];\n  }\n  if (elem1.type === \'text\' && elem2.type === \'text\') {\n    var offset = elem1.source.length;\n    elem1.setSourceWithRecord(elem1.source + elem2.source, editor.spaceHolder, records);\n    elem1.setNeedWrap(elem2.needWrap, records);\n    return [offset, true];\n  }\n  return [defaultOffset, false];\n}\nvar Input = /*#__PURE__*/function (_Command) {\n  input_inherits(Input, _Command);\n  var _super = input_createSuper(Input);\n  function Input() {\n    var _this;\n    input_classCallCheck(this, Input);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    input_defineProperty(input_assertThisInitialized(_this), "cacheIdx", null);\n    return _this;\n  }\n  input_createClass(Input, [{\n    key: "exec",\n    value: function exec(kind, data) {\n      var editor = this._editor;\n      var range = editor._range;\n      var caret = editor._caret;\n      var flattenTxtElem = editor._flattenTxtElem;\n      var undoredo = editor._undoredo;\n      var records = flattenTxtElem.startRecord();\n      flattenTxtElem.recordBeforeCaret(caret);\n      // let _afterRangeDelete = false;\n      if (range.isEnable()) {\n        range["delete"](editor, records);\n        if (kind === KEYBOARD_INPUT.BACKSPACE || kind === KEYBOARD_INPUT.DELETE) {\n          flattenTxtElem.collectRecords();\n          flattenTxtElem.recordAfterCaret(caret);\n          this._editor.refresh();\n          undoredo.write(records, flattenTxtElem.getCaretRecord());\n          return;\n        } else {\n          this._editor.refresh();\n          // _afterRangeDelete = true;\n        }\n      }\n\n      var row = caret.getRow();\n      var _caret$getColumn = caret.getColumn(),\n        _caret$getColumn2 = input_slicedToArray(_caret$getColumn, 2),\n        elem_idx = _caret$getColumn2[0],\n        offset = _caret$getColumn2[1];\n      var area = editor._area;\n      var line = area.get(row);\n      var element = line.get(elem_idx);\n      var preElem = line.get(elem_idx - 1);\n      var content = \'\';\n      if (element.type === \'text\') {\n        content = element.source;\n      } else if ((preElem === null || preElem === void 0 ? void 0 : preElem.type) === \'text\') {\n        content = preElem.source;\n        element = preElem;\n        offset = content.length;\n        elem_idx -= 1;\n        caret.setColumn([elem_idx, content.length]);\n      } else {\n        var newElement = new TextElement(\'text\', \'\');\n        flattenTxtElem.insertBefore(element, newElement);\n        element = newElement;\n      }\n      var preContent = content.substring(0, offset);\n      var afterContent;\n      if (this.cacheIdx) {\n        afterContent = content.substring(this.cacheIdx[1]);\n      } else {\n        afterContent = content.substring(offset);\n      }\n      switch (kind) {\n        case KEYBOARD_INPUT.INPUT:\n          // if(_afterRangeDelete) {\n          //     element = flattenTxtElem.get(0);\n          //     afterContent = \'\';\n          //     preContent = \'\';\n          // }\n          if (/\\r?[\\n\\t]/.test(data)) {\n            var rows = data.split(/\\r?[\\n\\t]/) || \'\';\n            // source = source.replace(/\\t/, \'\');\n            var idx = flattenTxtElem.findIndex(element);\n            var _lastNeedWrap = element.needWrap;\n            element.setSourceWithRecord(preContent + rows.shift(), editor.spaceHolder, records);\n            element.setNeedWrap(true, records);\n            var temp = [];\n            var tn;\n            var _row = row;\n            var col;\n            while (rows.length) {\n              tn = new TextElement(\'text\', rows.shift());\n              tn.needWrap = true;\n              temp.push(tn);\n              _row++;\n            }\n            col = tn.source.length;\n            tn.source += afterContent;\n            tn.needWrap = _lastNeedWrap;\n            temp.forEach(function (t, i) {\n              flattenTxtElem.inersetAt(idx + 1 + i, t);\n            });\n            caret.setRow(_row);\n            caret.setColumn([0, col]);\n          } else {\n            preContent += data;\n            caret.setColumn(1, caret.getColumn(1) + data.length);\n            element.setSourceWithRecord(preContent + afterContent, editor.spaceHolder, records);\n          }\n          break;\n        case KEYBOARD_INPUT.COMPOSITION_START:\n          this.cacheIdx = [preContent.length, preContent.length];\n          break;\n        case KEYBOARD_INPUT.COMPOSITION_UPDATE:\n          preContent = preContent.substring(0, this.cacheIdx[0]);\n          preContent += data;\n          element.setSourceWithRecord(preContent + afterContent, editor.spaceHolder, records);\n          var _t = this.cacheIdx[0] + data.length;\n          caret.setColumn(1, _t);\n          this.cacheIdx[1] = _t;\n          break;\n        case KEYBOARD_INPUT.COMPOSITION_END:\n          preContent = preContent.substring(0, this.cacheIdx[0]);\n          caret.setColumn(1, this.cacheIdx[0] + data.length);\n          this.cacheIdx = null;\n          preContent += data;\n          element.setSourceWithRecord(preContent + afterContent, editor.spaceHolder, records);\n          break;\n        case KEYBOARD_INPUT.ENTER:\n          var lastNeedWrap = element.needWrap;\n          element.setSourceWithRecord(preContent, editor.spaceHolder, records);\n          element.setNeedWrap(true, records);\n          var t = new TextElement(\'text\', afterContent);\n          flattenTxtElem.insertAfter(element, t, lastNeedWrap);\n          caret.setRow(row + 1);\n          caret.setColumn([0, 0]);\n          break;\n        case KEYBOARD_INPUT.BACKSPACE:\n          var result = element.shift(offset, -1);\n          switch (result) {\n            case \'prev\':\n              var _idx = flattenTxtElem.findIndex(element);\n              if (elem_idx > 0) {\n                // 行内\n                flattenTxtElem.splice(_idx - 1, 1);\n                _idx -= 1;\n                // element.setSource(afterContent, records);\n                // element.dirty = true;\n                var _blandAdjacentElement2 = _blandAdjacentElement(editor, flattenTxtElem.get(_idx - 1), element, 0, records),\n                  _blandAdjacentElement3 = input_slicedToArray(_blandAdjacentElement2, 2),\n                  _offset = _blandAdjacentElement3[0],\n                  deleteop = _blandAdjacentElement3[1];\n                if (deleteop) {\n                  flattenTxtElem.remove(_idx);\n                }\n                caret.setColumn([elem_idx - (_offset > 0 || deleteop ? 2 : 1), _offset]);\n              } else if (_idx > 0) {\n                // 换行了\n                var preRow = row - 1;\n                var preElemidx = area.get(preRow).length() - 1;\n                var _blandAdjacentElement4 = _blandAdjacentElement(editor, flattenTxtElem.get(_idx - 1), element, 0, records),\n                  _blandAdjacentElement5 = input_slicedToArray(_blandAdjacentElement4, 2),\n                  _offset2 = _blandAdjacentElement5[0],\n                  _deleteop = _blandAdjacentElement5[1];\n                if (_deleteop) {\n                  flattenTxtElem.remove(_idx);\n                }\n                caret.setRow(preRow);\n                caret.setColumn([preElemidx, _offset2]);\n              }\n              break;\n            case \'self\':\n              preContent = preContent.substring(0, preContent.length - 1);\n              caret.setColumn(1, caret.getColumn(1) - 1);\n              element.setSourceWithRecord(preContent + afterContent, editor.spaceHolder, records);\n              break;\n          }\n          break;\n        case KEYBOARD_INPUT.DELETE:\n          var shiftresult = element.shift(offset, 1);\n          switch (shiftresult) {\n            case \'next\':\n              var _idx2 = flattenTxtElem.findIndex(element);\n              if (elem_idx < line.length() - 1) {\n                // 行内\n                flattenTxtElem.splice(_idx2 + 1, 1);\n                var nextElem = flattenTxtElem.get(_idx2 + 1);\n                var _blandAdjacentElement6 = _blandAdjacentElement(element, nextElem, element.source.length, records),\n                  _blandAdjacentElement7 = input_slicedToArray(_blandAdjacentElement6, 2),\n                  _offset3 = _blandAdjacentElement7[0],\n                  _deleteop2 = _blandAdjacentElement7[1];\n                if (_deleteop2) {\n                  flattenTxtElem.remove(_idx2 + 1);\n                }\n                caret.setColumn([elem_idx, _offset3]);\n              } else if (_idx2 < flattenTxtElem.length() - 1) {\n                // 换行了\n                var _nextElem = flattenTxtElem.get(_idx2 + 1);\n                var _blandAdjacentElement8 = _blandAdjacentElement(element, _nextElem, element.source.length, records),\n                  _blandAdjacentElement9 = input_slicedToArray(_blandAdjacentElement8, 2),\n                  _offset4 = _blandAdjacentElement9[0],\n                  _deleteop3 = _blandAdjacentElement9[1];\n                if (_deleteop3) {\n                  flattenTxtElem.remove(_idx2 + 1);\n                }\n                caret.setColumn([elem_idx, _offset4]);\n              }\n              break;\n            case \'self\':\n              afterContent = afterContent.substring(1);\n              element.setSourceWithRecord(preContent + afterContent, editor.spaceHolder, records);\n              break;\n          }\n          break;\n      }\n      flattenTxtElem.collectRecords();\n      flattenTxtElem.recordAfterCaret(caret);\n      undoredo.write(records, flattenTxtElem.getCaretRecord());\n      this._editor.refresh();\n    }\n  }]);\n  return Input;\n}(base);\ninput_defineProperty(Input, "_name", EDITOR_EVENTS.INPUT);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/mouse.js\nfunction mouse_typeof(obj) { "@babel/helpers - typeof"; return mouse_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, mouse_typeof(obj); }\nfunction mouse_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction mouse_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, mouse_toPropertyKey(descriptor.key), descriptor); } }\nfunction mouse_createClass(Constructor, protoProps, staticProps) { if (protoProps) mouse_defineProperties(Constructor.prototype, protoProps); if (staticProps) mouse_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction mouse_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) mouse_setPrototypeOf(subClass, superClass); }\nfunction mouse_setPrototypeOf(o, p) { mouse_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return mouse_setPrototypeOf(o, p); }\nfunction mouse_createSuper(Derived) { var hasNativeReflectConstruct = mouse_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = mouse_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = mouse_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return mouse_possibleConstructorReturn(this, result); }; }\nfunction mouse_possibleConstructorReturn(self, call) { if (call && (mouse_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return mouse_assertThisInitialized(self); }\nfunction mouse_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction mouse_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction mouse_getPrototypeOf(o) { mouse_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return mouse_getPrototypeOf(o); }\nfunction mouse_defineProperty(obj, key, value) { key = mouse_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction mouse_toPropertyKey(arg) { var key = mouse_toPrimitive(arg, "string"); return mouse_typeof(key) === "symbol" ? key : String(key); }\nfunction mouse_toPrimitive(input, hint) { if (mouse_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (mouse_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n\nvar StartEditCommand = /*#__PURE__*/function (_Command) {\n  mouse_inherits(StartEditCommand, _Command);\n  var _super = mouse_createSuper(StartEditCommand);\n  function StartEditCommand() {\n    mouse_classCallCheck(this, StartEditCommand);\n    return _super.apply(this, arguments);\n  }\n  mouse_createClass(StartEditCommand, [{\n    key: "exec",\n    value: function exec() {\n      var editor = this._editor;\n      if (!this._startEdit()) {\n        return;\n      }\n      var jflow = editor._jflow;\n      editor.moveCaretByHitPoint();\n      editor.createShadowInput();\n      editor._caret.animate(jflow);\n      editor.syncShadowInputPosition();\n    }\n  }, {\n    key: "_startEdit",\n    value: function _startEdit() {\n      var flag = true;\n      var editor = this._editor;\n      editor.dispatchEvent(new events(\'edit\', {\n        target: editor,\n        preventDefault: function preventDefault() {\n          flag = false;\n        }\n      }));\n      return flag;\n    }\n  }]);\n  return StartEditCommand;\n}(base);\nmouse_defineProperty(StartEditCommand, "_name", MOUSE_COMMANDS.START_EDIT);\nvar EditClickCommand = /*#__PURE__*/function (_Command2) {\n  mouse_inherits(EditClickCommand, _Command2);\n  var _super2 = mouse_createSuper(EditClickCommand);\n  function EditClickCommand() {\n    mouse_classCallCheck(this, EditClickCommand);\n    return _super2.apply(this, arguments);\n  }\n  mouse_createClass(EditClickCommand, [{\n    key: "exec",\n    value: function exec() {\n      var editor = this._editor;\n      editor.moveCaretByHitPoint();\n      editor._caret.refresh();\n      editor.syncShadowInputPosition();\n      editor._range.disable();\n    }\n  }]);\n  return EditClickCommand;\n}(base);\nmouse_defineProperty(EditClickCommand, "_name", MOUSE_COMMANDS.EDIT_CLICK);\nvar DoubleClickCommand = /*#__PURE__*/function (_Command3) {\n  mouse_inherits(DoubleClickCommand, _Command3);\n  var _super3 = mouse_createSuper(DoubleClickCommand);\n  function DoubleClickCommand() {\n    mouse_classCallCheck(this, DoubleClickCommand);\n    return _super3.apply(this, arguments);\n  }\n  mouse_createClass(DoubleClickCommand, [{\n    key: "exec",\n    value: function exec() {\n      var editor = this._editor;\n      editor.moveCaretByHitPoint();\n      var caret = editor._caret;\n      var range = editor._range;\n      var area = editor._area;\n      var row = caret.getRow();\n      var line = area.get(row);\n      var elem_idx = line.length() - 1;\n      range.setInitialRange([row, 0, 0]);\n      range.setRange([row, elem_idx, line.tail().tailOffset()]);\n      range.handleCaret(caret);\n      range.enable();\n      editor.syncShadowInputPosition();\n    }\n  }]);\n  return DoubleClickCommand;\n}(base);\nmouse_defineProperty(DoubleClickCommand, "_name", MOUSE_COMMANDS.DOUBLE_CLICK);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/shift.js\nfunction shift_typeof(obj) { "@babel/helpers - typeof"; return shift_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, shift_typeof(obj); }\nfunction shift_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction shift_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, shift_toPropertyKey(descriptor.key), descriptor); } }\nfunction shift_createClass(Constructor, protoProps, staticProps) { if (protoProps) shift_defineProperties(Constructor.prototype, protoProps); if (staticProps) shift_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction shift_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) shift_setPrototypeOf(subClass, superClass); }\nfunction shift_setPrototypeOf(o, p) { shift_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return shift_setPrototypeOf(o, p); }\nfunction shift_createSuper(Derived) { var hasNativeReflectConstruct = shift_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = shift_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = shift_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return shift_possibleConstructorReturn(this, result); }; }\nfunction shift_possibleConstructorReturn(self, call) { if (call && (shift_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return shift_assertThisInitialized(self); }\nfunction shift_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction shift_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction shift_getPrototypeOf(o) { shift_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return shift_getPrototypeOf(o); }\nfunction shift_defineProperty(obj, key, value) { key = shift_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction shift_toPropertyKey(arg) { var key = shift_toPrimitive(arg, "string"); return shift_typeof(key) === "symbol" ? key : String(key); }\nfunction shift_toPrimitive(input, hint) { if (shift_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (shift_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\nvar ShiftUpCommand = /*#__PURE__*/function (_Command) {\n  shift_inherits(ShiftUpCommand, _Command);\n  var _super = shift_createSuper(ShiftUpCommand);\n  function ShiftUpCommand() {\n    shift_classCallCheck(this, ShiftUpCommand);\n    return _super.apply(this, arguments);\n  }\n  shift_createClass(ShiftUpCommand, [{\n    key: "exec",\n    value: function exec() {\n      var range = this._editor._range;\n      range.setInitialRange(null);\n      this._editor.toggleShift(false);\n    }\n  }]);\n  return ShiftUpCommand;\n}(base);\nshift_defineProperty(ShiftUpCommand, "_name", KEYBOARD_COMMANDS.SHIFT_UP);\nvar ShiftDownCommand = /*#__PURE__*/function (_Command2) {\n  shift_inherits(ShiftDownCommand, _Command2);\n  var _super2 = shift_createSuper(ShiftDownCommand);\n  function ShiftDownCommand() {\n    shift_classCallCheck(this, ShiftDownCommand);\n    return _super2.apply(this, arguments);\n  }\n  shift_createClass(ShiftDownCommand, [{\n    key: "exec",\n    value: function exec() {\n      var range = this._editor._range;\n      var caret = this._editor._caret;\n      range.setInitialRange(caret.toRange());\n      this._editor.toggleShift(true);\n    }\n  }]);\n  return ShiftDownCommand;\n}(base);\nshift_defineProperty(ShiftDownCommand, "_name", KEYBOARD_COMMANDS.SHIFT_DOWN);\nvar ShiftOnClickCommand = /*#__PURE__*/function (_Command3) {\n  shift_inherits(ShiftOnClickCommand, _Command3);\n  var _super3 = shift_createSuper(ShiftOnClickCommand);\n  function ShiftOnClickCommand() {\n    shift_classCallCheck(this, ShiftOnClickCommand);\n    return _super3.apply(this, arguments);\n  }\n  shift_createClass(ShiftOnClickCommand, [{\n    key: "exec",\n    value: function exec() {\n      var editor = this._editor;\n      editor.moveCaretByHitPoint();\n      var caret = this._editor._caret;\n      var range = this._editor._range;\n      range.setRange(caret.toRange());\n      range.enable();\n      range.handleCaret(caret);\n      caret.refresh();\n      editor.syncShadowInputPosition();\n    }\n  }]);\n  return ShiftOnClickCommand;\n}(base);\nshift_defineProperty(ShiftOnClickCommand, "_name", MOUSE_COMMANDS.SHIFT_ON_CLICK);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/ctrl.js\nfunction ctrl_typeof(obj) { "@babel/helpers - typeof"; return ctrl_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, ctrl_typeof(obj); }\nfunction ctrl_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction ctrl_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, ctrl_toPropertyKey(descriptor.key), descriptor); } }\nfunction ctrl_createClass(Constructor, protoProps, staticProps) { if (protoProps) ctrl_defineProperties(Constructor.prototype, protoProps); if (staticProps) ctrl_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction ctrl_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) ctrl_setPrototypeOf(subClass, superClass); }\nfunction ctrl_setPrototypeOf(o, p) { ctrl_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return ctrl_setPrototypeOf(o, p); }\nfunction ctrl_createSuper(Derived) { var hasNativeReflectConstruct = ctrl_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = ctrl_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = ctrl_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return ctrl_possibleConstructorReturn(this, result); }; }\nfunction ctrl_possibleConstructorReturn(self, call) { if (call && (ctrl_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return ctrl_assertThisInitialized(self); }\nfunction ctrl_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction ctrl_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction ctrl_getPrototypeOf(o) { ctrl_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return ctrl_getPrototypeOf(o); }\nfunction ctrl_defineProperty(obj, key, value) { key = ctrl_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction ctrl_toPropertyKey(arg) { var key = ctrl_toPrimitive(arg, "string"); return ctrl_typeof(key) === "symbol" ? key : String(key); }\nfunction ctrl_toPrimitive(input, hint) { if (ctrl_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (ctrl_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\nvar CtrlACommand = /*#__PURE__*/function (_Command) {\n  ctrl_inherits(CtrlACommand, _Command);\n  var _super = ctrl_createSuper(CtrlACommand);\n  function CtrlACommand() {\n    ctrl_classCallCheck(this, CtrlACommand);\n    return _super.apply(this, arguments);\n  }\n  ctrl_createClass(CtrlACommand, [{\n    key: "exec",\n    value: function exec() {\n      var editor = this._editor;\n      var caret = editor._caret;\n      var range = editor._range;\n      var area = editor._area;\n      var row = area.length() - 1;\n      var line = area.get(row);\n      var elem_idx = line.length() - 1;\n      range.setInitialRange([0, 0, 0]);\n      range.setRange([row, elem_idx, line.tail().tailOffset()]);\n      range.handleCaret(caret);\n      range.enable();\n      editor.syncShadowInputPosition();\n    }\n  }]);\n  return CtrlACommand;\n}(base);\nctrl_defineProperty(CtrlACommand, "_name", KEYBOARD_COMMANDS.CTRLA);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/undoredo.js\nfunction command_undoredo_typeof(obj) { "@babel/helpers - typeof"; return command_undoredo_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, command_undoredo_typeof(obj); }\nfunction command_undoredo_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction command_undoredo_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, command_undoredo_toPropertyKey(descriptor.key), descriptor); } }\nfunction command_undoredo_createClass(Constructor, protoProps, staticProps) { if (protoProps) command_undoredo_defineProperties(Constructor.prototype, protoProps); if (staticProps) command_undoredo_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction undoredo_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) undoredo_setPrototypeOf(subClass, superClass); }\nfunction undoredo_setPrototypeOf(o, p) { undoredo_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return undoredo_setPrototypeOf(o, p); }\nfunction undoredo_createSuper(Derived) { var hasNativeReflectConstruct = undoredo_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = undoredo_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = undoredo_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return undoredo_possibleConstructorReturn(this, result); }; }\nfunction undoredo_possibleConstructorReturn(self, call) { if (call && (command_undoredo_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return undoredo_assertThisInitialized(self); }\nfunction undoredo_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction undoredo_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction undoredo_getPrototypeOf(o) { undoredo_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return undoredo_getPrototypeOf(o); }\nfunction command_undoredo_defineProperty(obj, key, value) { key = command_undoredo_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction command_undoredo_toPropertyKey(arg) { var key = command_undoredo_toPrimitive(arg, "string"); return command_undoredo_typeof(key) === "symbol" ? key : String(key); }\nfunction command_undoredo_toPrimitive(input, hint) { if (command_undoredo_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (command_undoredo_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\nvar UndoCommand = /*#__PURE__*/function (_Command) {\n  undoredo_inherits(UndoCommand, _Command);\n  var _super = undoredo_createSuper(UndoCommand);\n  function UndoCommand() {\n    command_undoredo_classCallCheck(this, UndoCommand);\n    return _super.apply(this, arguments);\n  }\n  command_undoredo_createClass(UndoCommand, [{\n    key: "exec",\n    value: function exec() {\n      this._editor._range.disable();\n      this._editor._undoredo.undo();\n      this._editor.refresh();\n    }\n  }]);\n  return UndoCommand;\n}(base);\ncommand_undoredo_defineProperty(UndoCommand, "_name", KEYBOARD_COMMANDS.UNDO);\nvar RedoCommand = /*#__PURE__*/function (_Command2) {\n  undoredo_inherits(RedoCommand, _Command2);\n  var _super2 = undoredo_createSuper(RedoCommand);\n  function RedoCommand() {\n    command_undoredo_classCallCheck(this, RedoCommand);\n    return _super2.apply(this, arguments);\n  }\n  command_undoredo_createClass(RedoCommand, [{\n    key: "exec",\n    value: function exec() {\n      this._editor._range.disable();\n      this._editor._undoredo.redo();\n      this._editor.refresh();\n    }\n  }]);\n  return RedoCommand;\n}(base);\ncommand_undoredo_defineProperty(RedoCommand, "_name", KEYBOARD_COMMANDS.REDO);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/clipboard.js\nfunction clipboard_typeof(obj) { "@babel/helpers - typeof"; return clipboard_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, clipboard_typeof(obj); }\nfunction clipboard_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction clipboard_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, clipboard_toPropertyKey(descriptor.key), descriptor); } }\nfunction clipboard_createClass(Constructor, protoProps, staticProps) { if (protoProps) clipboard_defineProperties(Constructor.prototype, protoProps); if (staticProps) clipboard_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction clipboard_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) clipboard_setPrototypeOf(subClass, superClass); }\nfunction clipboard_setPrototypeOf(o, p) { clipboard_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return clipboard_setPrototypeOf(o, p); }\nfunction clipboard_createSuper(Derived) { var hasNativeReflectConstruct = clipboard_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = clipboard_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = clipboard_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return clipboard_possibleConstructorReturn(this, result); }; }\nfunction clipboard_possibleConstructorReturn(self, call) { if (call && (clipboard_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return clipboard_assertThisInitialized(self); }\nfunction clipboard_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction clipboard_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction clipboard_getPrototypeOf(o) { clipboard_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return clipboard_getPrototypeOf(o); }\nfunction clipboard_defineProperty(obj, key, value) { key = clipboard_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction clipboard_toPropertyKey(arg) { var key = clipboard_toPrimitive(arg, "string"); return clipboard_typeof(key) === "symbol" ? key : String(key); }\nfunction clipboard_toPrimitive(input, hint) { if (clipboard_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (clipboard_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n\nvar CopyCommand = /*#__PURE__*/function (_Command) {\n  clipboard_inherits(CopyCommand, _Command);\n  var _super = clipboard_createSuper(CopyCommand);\n  function CopyCommand() {\n    clipboard_classCallCheck(this, CopyCommand);\n    return _super.apply(this, arguments);\n  }\n  clipboard_createClass(CopyCommand, [{\n    key: "exec",\n    value: function exec(event) {\n      var editor = this._editor;\n      var range = editor._range;\n      var content = range.getRangeCopy(editor);\n      if (content) {\n        event.clipboardData.setData("text/plain", content);\n      }\n    }\n  }]);\n  return CopyCommand;\n}(base);\nclipboard_defineProperty(CopyCommand, "_name", KEYBOARD_COMMANDS.COPY);\nvar CutCommand = /*#__PURE__*/function (_Command2) {\n  clipboard_inherits(CutCommand, _Command2);\n  var _super2 = clipboard_createSuper(CutCommand);\n  function CutCommand() {\n    clipboard_classCallCheck(this, CutCommand);\n    return _super2.apply(this, arguments);\n  }\n  clipboard_createClass(CutCommand, [{\n    key: "exec",\n    value: function exec(event) {\n      var editor = this._editor;\n      var range = editor._range;\n      var content = range.getRangeCopy(editor);\n      if (content) {\n        event.clipboardData.setData("text/plain", content);\n      }\n      if (range.isEnable()) {\n        var cmd = editor.commands.get(EDITOR_EVENTS.INPUT);\n        cmd.exec(KEYBOARD_INPUT.BACKSPACE);\n      }\n    }\n  }]);\n  return CutCommand;\n}(base);\nclipboard_defineProperty(CutCommand, "_name", KEYBOARD_COMMANDS.CUT);\nvar PasteCommand = /*#__PURE__*/function (_Command3) {\n  clipboard_inherits(PasteCommand, _Command3);\n  var _super3 = clipboard_createSuper(PasteCommand);\n  function PasteCommand() {\n    clipboard_classCallCheck(this, PasteCommand);\n    return _super3.apply(this, arguments);\n  }\n  clipboard_createClass(PasteCommand, [{\n    key: "exec",\n    value: function exec(pasteContent) {\n      var editor = this._editor;\n      if (pasteContent) {\n        var _preventDefault = false;\n        editor.dispatchEvent(new events(\'paste\', {\n          content: pasteContent,\n          preventDefault: function preventDefault() {\n            _preventDefault = true;\n          }\n        }));\n        if (!_preventDefault) {\n          var cmd = editor.commands.get(EDITOR_EVENTS.INPUT);\n          cmd.exec(KEYBOARD_INPUT.INPUT, pasteContent);\n        }\n      }\n    }\n  }]);\n  return PasteCommand;\n}(base);\nclipboard_defineProperty(PasteCommand, "_name", KEYBOARD_COMMANDS.PASTE);\n;// CONCATENATED MODULE: ./src/core/instance/text-group/command/index.js\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./src/core/instance/text-group/text-group.js\nfunction text_group_typeof(obj) { "@babel/helpers - typeof"; return text_group_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, text_group_typeof(obj); }\nfunction text_group_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction text_group_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? text_group_ownKeys(Object(source), !0).forEach(function (key) { text_group_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : text_group_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction text_group_defineProperty(obj, key, value) { key = text_group_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction text_group_slicedToArray(arr, i) { return text_group_arrayWithHoles(arr) || text_group_iterableToArrayLimit(arr, i) || text_group_unsupportedIterableToArray(arr, i) || text_group_nonIterableRest(); }\nfunction text_group_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction text_group_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction text_group_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction text_group_toConsumableArray(arr) { return text_group_arrayWithoutHoles(arr) || text_group_iterableToArray(arr) || text_group_unsupportedIterableToArray(arr) || text_group_nonIterableSpread(); }\nfunction text_group_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction text_group_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return text_group_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return text_group_arrayLikeToArray(o, minLen); }\nfunction text_group_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\nfunction text_group_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return text_group_arrayLikeToArray(arr); }\nfunction text_group_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction text_group_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction text_group_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, text_group_toPropertyKey(descriptor.key), descriptor); } }\nfunction text_group_createClass(Constructor, protoProps, staticProps) { if (protoProps) text_group_defineProperties(Constructor.prototype, protoProps); if (staticProps) text_group_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction text_group_toPropertyKey(arg) { var key = text_group_toPrimitive(arg, "string"); return text_group_typeof(key) === "symbol" ? key : String(key); }\nfunction text_group_toPrimitive(input, hint) { if (text_group_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (text_group_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction text_group_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) text_group_setPrototypeOf(subClass, superClass); }\nfunction text_group_setPrototypeOf(o, p) { text_group_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return text_group_setPrototypeOf(o, p); }\nfunction text_group_createSuper(Derived) { var hasNativeReflectConstruct = text_group_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = text_group_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = text_group_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return text_group_possibleConstructorReturn(this, result); }; }\nfunction text_group_possibleConstructorReturn(self, call) { if (call && (text_group_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return text_group_assertThisInitialized(self); }\nfunction text_group_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction text_group_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction text_group_getPrototypeOf(o) { text_group_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return text_group_getPrototypeOf(o); }\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar TextGroup = /*#__PURE__*/function (_Node) {\n  text_group_inherits(TextGroup, _Node);\n  var _super = text_group_createSuper(TextGroup);\n  function TextGroup(configs) {\n    var _this;\n    text_group_classCallCheck(this, TextGroup);\n    _this = _super.call(this, configs);\n    _this.type = \'TextGroup\';\n    _this.initStack(configs);\n    _this.initLayout(configs);\n    _this._undoredo = new UndoRedo();\n    _this._undoredo._editor = text_group_assertThisInitialized(_this);\n    _this._caret = new caret();\n    _this._range = new range();\n    _this._shadowInput = undefined;\n    _this.textColor = configs.textColor || \'transparent\';\n    _this.fontFamily = configs.fontFamily || \'-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Tahoma,Arial,Noto Sans,PingFang SC,Microsoft YaHei,Hiragino Sans GB,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji\';\n    _this.fontSize = configs.fontSize || \'28px\';\n    _this.fontWeight = configs.fontWeight || \'\';\n    _this.elementSpace = configs.elementSpace || 5;\n    _this.lineSpace = configs.lineSpace || 5;\n    _this.placeholder = configs.placeholder || \'请输入\';\n    _this.placeholderColor = configs.placeholderColor || \'#eee\';\n    _this.cursorColor = configs.cursorColor || \'#60CFC4\';\n    _this.textRangeColor = configs.textRangeColor || \'#4E75EC1A\';\n    _this.minWidth = configs.minWidth || 0;\n    _this.spaceHolder = {\n      enable: false\n    };\n    if (configs.spacePlaceholder) {\n      Object.assign(_this.spaceHolder, {\n        enable: true,\n        spacePlaceholder: configs.spacePlaceholder,\n        spacePlaceholderColor: configs.spacePlaceholderColor,\n        returnFont: configs.returnFont\n      });\n    }\n    _this.resolver = function () {\n      var elements = configs.resolver();\n      if (elements.length === 0 || elements[elements.length - 1].type !== \'text\') {\n        elements.push(new TextElement(\'text\', \'\'));\n      }\n      elements.forEach(function (el) {\n        if (el.type === \'text\') {\n          el.setSource(el.source, _this.spaceHolder);\n        }\n      });\n      return elements;\n    };\n\n    // this._lines = [];\n    _this._area = new Area();\n    _this._flattenTxtElem = FlattenTextElements.create(_this.resolver());\n    _this._status = {\n      editing: false,\n      dragover: false\n    };\n    _this.commands = new Map();\n    _this.registCommand(StartEditCommand);\n    _this.registCommand(EditClickCommand);\n    _this.registCommand(ShiftUpCommand);\n    _this.registCommand(ShiftDownCommand);\n    _this.registCommand(ShiftOnClickCommand);\n    _this.registCommand(Input);\n    _this.registCommand(ArrowLeftCommand);\n    _this.registCommand(ArrowRightCommand);\n    _this.registCommand(ArrowUpCommand);\n    _this.registCommand(ArrowDownCommand);\n    _this.registCommand(CtrlACommand);\n    _this.registCommand(DoubleClickCommand);\n    // this.registCommand(ReturnCommand);\n    // this.registCommand(DeleteCommand);\n    _this.registCommand(UndoCommand);\n    _this.registCommand(RedoCommand);\n    _this.registCommand(CopyCommand);\n    _this.registCommand(CutCommand);\n    _this.registCommand(PasteCommand);\n    _this._makeFunctional();\n    _this._cacheViewBox = [];\n    return _this;\n  }\n  text_group_createClass(TextGroup, [{\n    key: "currentLineHeight",\n    get: function get() {\n      return this.lineHeight || parseInt(this.fontSize);\n    }\n  }, {\n    key: "registCommand",\n    value: function registCommand(cmd) {\n      if (!this.commands.has(cmd._name)) {\n        this.commands.set(cmd._name, cmd.create(this));\n      }\n    }\n  }, {\n    key: "_makeFunctional",\n    value: function _makeFunctional() {\n      var _this2 = this;\n      this.addEventListener(\'dblclick\', function (event) {\n        if (event.currentTarget !== _this2) {\n          return;\n        }\n        event.detail.bubbles = false;\n        if (_this2._status.editing) {\n          _this2.execCommand(MOUSE_COMMANDS.DOUBLE_CLICK);\n        }\n      });\n      this.addEventListener(\'click\', function (event) {\n        if (event.currentTarget !== _this2) {\n          return;\n        }\n        event.detail.bubbles = false;\n        var commnd;\n        if (_this2._status.editing) {\n          if (_this2._status.shiftOn) {\n            commnd = MOUSE_COMMANDS.SHIFT_ON_CLICK;\n          } else {\n            commnd = MOUSE_COMMANDS.EDIT_CLICK;\n          }\n        } else {\n          commnd = MOUSE_COMMANDS.START_EDIT;\n        }\n        _this2.execCommand(commnd);\n      });\n      this.addEventListener(\'blur\', function (event) {\n        _this2._status.editing = false;\n        if (_this2._shadowInput) {\n          // this._shadowInput.releaseEventListenr();\n          _this2._shadowInput.destroy();\n          _this2._shadowInput = undefined;\n        }\n        if (_this2._belongs) {\n          _this2._jflow._render();\n        }\n        _this2.dispatchEvent(new events(\'change\', {\n          target: _this2,\n          textElements: _this2._flattenTxtElem.copy()\n        }));\n        _this2._range.disable();\n        _this2._caret.cancelAnimate();\n      });\n      this.addEventListener(\'instancePressStart\', function (event) {\n        if (_this2._status.editing && !_this2._status.shiftOn) {\n          event.detail.bubbles = false;\n          event.detail.preventDefault();\n          // event.detail.jflow.setMovingTargets(null);\n          var point = _this2._currentp;\n          var c = _this2._positionToCursorOffset(point);\n          // this._cursor = c;\n          var range = _this2._range;\n          range.setInitialRange([c.row].concat(text_group_toConsumableArray(c.column)));\n          var jflow = event.detail.jflow;\n          var moved = false;\n          var t = function (e) {\n            _this2._status.editing = false;\n            moved = true;\n            var offsetX = e.offsetX,\n              offsetY = e.offsetY;\n            var p = jflow._calculatePointBack([offsetX, offsetY]);\n            jflow._stack.checkHit(p);\n            var point = _this2._currentp;\n            var c = _this2._positionToCursorOffset(point);\n            // this._cursor = c;\n            range.setRange([c.row].concat(text_group_toConsumableArray(c.column)));\n            range.enable();\n          }.bind(_this2);\n          document.addEventListener(\'pointermove\', t);\n          document.addEventListener(\'pointerup\', function (e) {\n            document.removeEventListener(\'pointermove\', t);\n            range.setInitialRange(null);\n            if (!moved) {\n              return;\n            }\n            range.handleCaret(_this2._caret);\n            _this2._status.editing = true;\n            _this2._shadowInput.focus();\n          }, {\n            once: true\n          });\n        }\n      });\n      this.addEventListener(\'dragenter\', function () {\n        _this2.moveCaretByHitPoint();\n        _this2._status.dragover = true;\n      });\n      this.addEventListener(\'dragover\', function () {\n        _this2.moveCaretByHitPoint();\n      });\n      this.addEventListener(\'dragleave\', function () {\n        _this2._status.dragover = false;\n      });\n      var onDrop = function (event) {\n        if (!_this2._status.dragover) {\n          return;\n        }\n        event.detail.bubbles = false;\n        _this2._status.dragover = false;\n        var caret = _this2._caret;\n        var row = caret.getRow();\n        var column = caret.getColumn();\n        var line = _this2._area.get(row);\n        var _column = text_group_slicedToArray(column, 2),\n          elemidx = _column[0],\n          offset = _column[1];\n        var element = line.get(elemidx);\n        var preElem = line.get(elemidx - 1);\n        var flattenTxtElem = _this2._flattenTxtElem;\n        var idx = flattenTxtElem.findIndex(element);\n        if (element.type !== \'text\' && (preElem === null || preElem === void 0 ? void 0 : preElem.type) === \'text\') {\n          offset = preElem.source.length;\n          idx = flattenTxtElem.findIndex(preElem);\n        }\n        var lastLength = flattenTxtElem.length();\n        _this2.dispatchEvent(new events(\'insert\', text_group_objectSpread(text_group_objectSpread({}, event.detail), {}, {\n          type: event.type,\n          textElements: flattenTxtElem.copy(),\n          idx: idx,\n          offset: offset\n        })));\n        // after insert\n        flattenTxtElem = _this2._flattenTxtElem;\n        if (_this2._status.editing) {\n          if (flattenTxtElem.length() > lastLength) {\n            caret.setColumn([elemidx + flattenTxtElem.length() - lastLength, 0]);\n          }\n          _this2._shadowInput.focus();\n        }\n        if (_this2._status.editing) {\n          _this2._caret.refresh();\n        }\n        _this2.syncShadowInputPosition();\n        _this2._range.disable();\n      }.bind(this);\n      this.addEventListener(\'pressEnd\', onDrop);\n      this.addEventListener(\'drop\', onDrop);\n    }\n  }, {\n    key: "toggleShift",\n    value: function toggleShift(val) {\n      this._status.shiftOn = val;\n    }\n  }, {\n    key: "execCommand",\n    value: function execCommand(kind, data) {\n      var cmd = this.commands.get(kind);\n      cmd.exec(data);\n    }\n  }, {\n    key: "createShadowInput",\n    value: function createShadowInput() {\n      var _this3 = this;\n      var jflow = this._jflow;\n      var shadowInput = new shadow_input(jflow.DOMwrapper);\n      var _a = function _a(e) {\n        var kind = e.detail.kind;\n        var data = e.detail.data;\n        _this3.execCommand(kind, data);\n      };\n      var _b = function _b(e) {\n        var kind = e.detail.kind;\n        var data = e.detail.data;\n        var cmd = _this3.commands.get(EDITOR_EVENTS.INPUT);\n        cmd.exec(kind, data);\n      };\n      shadowInput.addEventListener(EDITOR_EVENTS.CONTROL_CMD, _a);\n      shadowInput.addEventListener(EDITOR_EVENTS.INPUT, _b);\n      shadowInput.removeLisenter = function () {\n        shadowInput.removeEventListener(EDITOR_EVENTS.CONTROL_CMD, _a);\n        shadowInput.removeEventListener(EDITOR_EVENTS.INPUT, _b);\n        shadowInput.removeLisenter = null;\n      };\n      this._shadowInput = shadowInput;\n      this._status.editing = true;\n      jflow.setFocusInstance(this);\n    }\n  }, {\n    key: "moveCaretByHitPoint",\n    value: function moveCaretByHitPoint() {\n      var point = this._currentp;\n      var caret = this._caret;\n      var _this$_positionToCurs = this._positionToCursorOffset(point),\n        row = _this$_positionToCurs.row,\n        column = _this$_positionToCurs.column;\n      caret.setRow(row);\n      caret.setColumn(column);\n    }\n  }, {\n    key: "refresh",\n    value: function refresh() {\n      this.recalculateUp();\n      this.syncShadowInputPosition();\n      this._jflow._render();\n    }\n  }, {\n    key: "refreshTextElements",\n    value: function refreshTextElements() {\n      this._flattenTxtElem = FlattenTextElements.create(this.resolver());\n    }\n  }, {\n    key: "_positionToCursorOffset",\n    value: function _positionToCursorOffset(point) {\n      var _point = text_group_slicedToArray(point, 2),\n        x = _point[0],\n        y = _point[1];\n      // const [x0, y0] = this.anchor;\n      var area = this._area;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var offsetX = x + w;\n      var offsetY = y + h;\n      var row = area.getLineAbove(offsetY);\n      var currLine = area.get(row);\n      var column = currLine.getColumnNearest(offsetX, this.elementSpace, this.fontSize, this.fontFamily, this);\n      return {\n        row: row,\n        column: column\n      };\n    }\n  }, {\n    key: "_caretToPosition",\n    value: function _caretToPosition() {\n      var _this4 = this;\n      var row = this._caret.getRow();\n      var column = this._caret.getColumn();\n      var line = this._area.get(row);\n      var _column2 = text_group_slicedToArray(column, 2),\n        elemidx = _column2[0],\n        offset = _column2[1];\n      var meta = line.get(elemidx);\n      var idx = this._flattenTxtElem.findIndex(meta);\n      var preElem = this._flattenTxtElem.get(idx - 1);\n      var cw;\n      var c_len = this.currentLineHeight / 2;\n      if (meta.type === \'text\') {\n        var c = meta.getRenderSource(this.spaceHolder).substring(0, offset);\n        requestCacheCanvas(function (ctx) {\n          ctx.beginPath();\n          ctx.font = "".concat(_this4.fontSize, " ").concat(_this4.fontFamily);\n          cw = meta.anchorX - meta.width / 2 + ctx.measureText(c).width;\n        });\n      } else {\n        cw = meta.anchorX - meta.width / 2;\n        c_len = Math.max(c_len, meta.height / 2);\n      }\n      if (offset === 0 && preElem && preElem.type !== \'text\') {\n        c_len = Math.max(c_len, preElem.height / 2);\n      }\n      return [cw, c_len, line.anchorY, preElem, meta];\n    }\n  }, {\n    key: "syncShadowInputPosition",\n    value: function syncShadowInputPosition() {\n      if (this._status.editing) {\n        var _this$_caretToPositio = this._caretToPosition(),\n          _this$_caretToPositio2 = text_group_slicedToArray(_this$_caretToPositio, 3),\n          cw = _this$_caretToPositio2[0],\n          c_len = _this$_caretToPositio2[1],\n          anchorY = _this$_caretToPositio2[2];\n        var point = this.calculateToRealWorld([cw, anchorY + c_len]);\n        var canvasMeta = this._jflow.canvasMeta;\n        var px = Math.min(canvasMeta.actual_width - 120, point[0]);\n        // return [px, point[1]];\n        this._shadowInput.syncPosition(px, point[1]);\n        this._shadowInput.focus();\n      }\n    }\n  }, {\n    key: "render",\n    value: function render(ctx) {\n      var _this5 = this;\n      ctx.save();\n      if (this._isMoving) {\n        ctx.globalAlpha = 0.6;\n      } else if (this.opacity !== 1) {\n        ctx.globalAlpha = this.opacity;\n      }\n      var _this$anchor = text_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor[0],\n        cy = _this$anchor[1];\n      var jflow = this._jflow;\n      var area = this._area;\n      ctx.translate(cx, cy);\n      // ctx.beginPath();\n      // ctx.rect(-width/2, -height/2, width, height);\n      // ctx.stroke();\n      var flattenTxtElem = this._flattenTxtElem;\n      if (flattenTxtElem.isEmpty()) {\n        ctx.beginPath();\n        ctx.font = "".concat(this.fontWeight, " ").concat(this.fontSize, " ").concat(this.fontFamily);\n        ctx.textAlign = \'center\';\n        ctx.textBaseline = \'middle\';\n        ctx.fillStyle = this.placeholderColor;\n        ctx.fillText(this.placeholder, 0, 0);\n        this._randerCursor(ctx);\n        ctx.translate(-cx, -cy);\n        ctx.restore();\n        return;\n      }\n      ctx.beginPath();\n      ctx.font = "".concat(this.fontWeight, " ").concat(this.fontSize, " ").concat(this.fontFamily);\n      ctx.textAlign = \'center\';\n      ctx.textBaseline = \'middle\';\n      ctx.fillStyle = this.textColor;\n      area.forEach(function (line) {\n        line.forEach(function (el) {\n          if (el.type === \'text\') {\n            el.render(ctx, _this5.spaceHolder, _this5.textColor);\n            // ctx.fillText(el.source, el.anchorX, el.anchorY)\n          }\n        });\n      });\n\n      flattenTxtElem.forEach(function (elem) {\n        if (elem.type !== \'text\') {\n          var instance = jflow.getRenderNodeBySource(elem.source);\n          if (instance && instance.visible) {\n            ctx.save();\n            instance.render(ctx);\n            ctx.restore();\n          }\n        }\n      });\n      this._randerCursor(ctx);\n      this._renderRange(ctx);\n      ctx.translate(-cx, -cy);\n      ctx.restore();\n    }\n  }, {\n    key: "_randerCursor",\n    value: function _randerCursor(ctx) {\n      if (this._caret.isShow() && (this._status.editing || this._status.dragover)) {\n        var _this$_caretToPositio3 = this._caretToPosition(),\n          _this$_caretToPositio4 = text_group_slicedToArray(_this$_caretToPositio3, 3),\n          cw = _this$_caretToPositio4[0],\n          c_len = _this$_caretToPositio4[1],\n          anchorY = _this$_caretToPositio4[2];\n        ctx.beginPath();\n        ctx.moveTo(cw, anchorY - c_len);\n        ctx.lineTo(cw, anchorY + c_len);\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = this.cursorColor;\n        ctx.stroke();\n      }\n    }\n  }, {\n    key: "_renderRange",\n    value: function _renderRange(ctx) {\n      var range = this._range;\n      if (range.isEnable()) {\n        var area = this._area;\n        var textRangeColor = this.textRangeColor;\n        var blockheight = this.height;\n        var blockwidth = this.width;\n        var lineSpace = this.lineSpace;\n        var _range$getRangeFrom = range.getRangeFrom(),\n          _range$getRangeFrom2 = text_group_slicedToArray(_range$getRangeFrom, 3),\n          r_f = _range$getRangeFrom2[0],\n          idx_f = _range$getRangeFrom2[1],\n          offset_f = _range$getRangeFrom2[2];\n        var _range$getRangeTo = range.getRangeTo(),\n          _range$getRangeTo2 = text_group_slicedToArray(_range$getRangeTo, 3),\n          r_t = _range$getRangeTo2[0],\n          idx_t = _range$getRangeTo2[1],\n          offset_t = _range$getRangeTo2[2];\n        if (r_f === r_t) {\n          if (idx_f === idx_t && offset_f == offset_t) {\n            return;\n          }\n          var line = area.get(r_f);\n          var space = r_f === area.length() - 1 ? 0 : lineSpace;\n          var lty = line.reduceHeight - space - line.height - blockheight / 2;\n          var height = line.height;\n          var x1 = this._measureElementOffsetX(line.get(idx_f), offset_f, ctx);\n          var x2 = this._measureElementOffsetX(line.get(idx_t), offset_t, ctx);\n          ctx.beginPath();\n          ctx.rect(x1, lty, x2 - x1, height);\n          ctx.fillStyle = textRangeColor;\n          ctx.fill();\n        } else {\n          var _r = r_f;\n          var beginning = true;\n          while (_r <= r_t) {\n            var _line = area.get(_r);\n            var _space = _r === area.length() - 1 ? 0 : lineSpace;\n            var _lty = _line.reduceHeight - _space - _line.height - blockheight / 2;\n            var _height = _line.height;\n            if (beginning) {\n              var elem = _line.get(idx_f);\n              var x = this._measureElementOffsetX(elem, offset_f, ctx);\n              var lastElem = _line.tail();\n              var t = lastElem.anchorX + lastElem.width / 2;\n              ctx.beginPath();\n              ctx.rect(x, _lty, t - x, _height);\n              ctx.fillStyle = textRangeColor;\n              ctx.fill();\n            } else if (_r === r_t) {\n              var _elem = _line.get(idx_t);\n              var _x2 = this._measureElementOffsetX(_elem, offset_t, ctx);\n              ctx.beginPath();\n              ctx.rect(-blockwidth / 2, _lty, _elem.reduceWidth + (_x2 - _elem.anchorX + _elem.width / 2), _height);\n              ctx.fillStyle = textRangeColor;\n              ctx.fill();\n            } else {\n              ctx.beginPath();\n              ctx.rect(-blockwidth / 2, _lty, _line.width, _height);\n              ctx.fillStyle = textRangeColor;\n              ctx.fill();\n            }\n            beginning = false;\n            _r++;\n          }\n        }\n      }\n    }\n  }, {\n    key: "_measureElementOffsetX",\n    value: function _measureElementOffsetX(element, offset, ctx) {\n      if (element.type !== \'text\' || offset === 0) {\n        return element.anchorX - element.width / 2;\n      }\n      return element.anchorX - element.width / 2 + ctx.measureText(element.getRenderSource(this.spaceHolder).substring(0, offset)).width;\n    }\n  }, {\n    key: "measureTextWidth",\n    value: function measureTextWidth(content) {\n      var _this6 = this;\n      var t;\n      requestCacheCanvas(function (ctx) {\n        ctx.font = "".concat(_this6.fontSize, " ").concat(_this6.fontFamily);\n        t = ctx.measureText(content).width;\n      });\n      return t;\n    }\n  }, {\n    key: "getBoundingDimension",\n    value: function getBoundingDimension() {\n      return {\n        width: this.width,\n        height: this.height\n      };\n    }\n  }, {\n    key: "getBoundingRect",\n    value: function getBoundingRect() {\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      var ltx = anchor[0] - w;\n      var lty = anchor[1] - h;\n      var rbx = anchor[0] + w;\n      var rby = anchor[1] + h;\n      var br = this._boundingrect;\n      br[0] = ltx;\n      br[1] = lty;\n      br[2] = rbx;\n      br[3] = rby;\n      return br;\n    }\n  }, {\n    key: "_getViewBox",\n    value: function _getViewBox() {\n      var belongs_vbox = this._belongs.getCacheViewBox();\n      var cacheViewBox = this._cacheViewBox;\n      this._calculatePointBackWithPoint(belongs_vbox[0], belongs_vbox[1], cacheViewBox, 0, 1);\n      this._calculatePointBackWithPoint(belongs_vbox[2], belongs_vbox[3], cacheViewBox, 2, 3);\n      return this._cacheViewBox;\n    }\n  }, {\n    key: "getCacheViewBox",\n    value: function getCacheViewBox() {\n      return this._cacheViewBox;\n    }\n  }, {\n    key: "calculateToCoordination",\n    value: function calculateToCoordination(point) {\n      var _point2 = text_group_slicedToArray(point, 2),\n        gx = _point2[0],\n        gy = _point2[1];\n      var _this$anchor2 = text_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor2[0],\n        cy = _this$anchor2[1];\n      // const p = [cx + anchor[0] - spanH, cy + anchor[1] - spanV];\n      var p = [gx + cx, gy + cy];\n      if (this._belongs && this._belongs.calculateToCoordination) {\n        return this._belongs.calculateToCoordination(p);\n      } else {\n        return p;\n      }\n    }\n  }, {\n    key: "calculateToRealWorld",\n    value: function calculateToRealWorld(point) {\n      var _point3 = text_group_slicedToArray(point, 2),\n        gx = _point3[0],\n        gy = _point3[1];\n      var _this$anchor3 = text_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor3[0],\n        cy = _this$anchor3[1];\n      var p = [gx + cx, gy + cy];\n      if (this._belongs && this._belongs.calculateToRealWorld) {\n        return this._belongs.calculateToRealWorld(p);\n      }\n    }\n  }, {\n    key: "calculateToRealWorldWithPointer",\n    value: function calculateToRealWorldWithPointer(outpoint, inpoint) {\n      outpoint[0] = inpoint[0] + this.anchor[0];\n      outpoint[1] = inpoint[1] + this.anchor[1];\n      if (this._belongs && this._belongs.calculateToRealWorldWithPointer) {\n        return this._belongs.calculateToRealWorldWithPointer(outpoint, outpoint);\n      }\n    }\n  }, {\n    key: "_calculatePointBack",\n    value: function _calculatePointBack(point) {\n      var _point4 = text_group_slicedToArray(point, 2),\n        gx = _point4[0],\n        gy = _point4[1];\n      var _this$anchor4 = text_group_slicedToArray(this.anchor, 2),\n        cx = _this$anchor4[0],\n        cy = _this$anchor4[1];\n      var p = [gx - cx, gy - cy];\n      return p;\n    }\n  }, {\n    key: "_calculatePointBackWithPoint",\n    value: function _calculatePointBackWithPoint(a, b, arr, idx1, idx2) {\n      arr[idx1] = a - this.anchor[0];\n      arr[idx2] = b - this.anchor[1];\n    }\n  }, {\n    key: "isHit",\n    value: function isHit(point, condition) {\n      var p = this._calculatePointBack(point);\n      var jflow = this._jflow;\n      this._currentp = p; // 暂存，为了后续计算别的位置\n      var validInstance = [];\n      var flattenTxtElem = this._flattenTxtElem;\n      flattenTxtElem.forEach(function (elem) {\n        if (elem.type !== \'text\') {\n          var instance = jflow.getRenderNodeBySource(elem.source);\n          if (instance.visible) {\n            validInstance.push(instance);\n          }\n        }\n      });\n      var target = this._stack.checkHit(p, condition, function (i) {\n        return validInstance.includes(i);\n      });\n      if (target) return target;\n      var anchor = this.anchor;\n      var w = this.width / 2;\n      var h = this.height / 2;\n      return point[0] > anchor[0] - w && point[0] < anchor[0] + w && point[1] > anchor[1] - h && point[1] < anchor[1] + h;\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      var _this7 = this;\n      var t = new shadow_cache({\n        width: this.width,\n        height: this.height,\n        cache: function cache(ctx) {\n          var _this7$anchor = text_group_slicedToArray(_this7.anchor, 2),\n            cx = _this7$anchor[0],\n            cy = _this7$anchor[1];\n          ctx.translate(-cx + _this7.width / 2, -cy + _this7.height / 2);\n          _this7.render(ctx);\n        }\n      });\n      return t;\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      if (this._jflow._focus.instance === this) {\n        this._jflow.blur();\n      }\n    }\n  }]);\n  return TextGroup;\n}(node);\nObject.assign(TextGroup.prototype, stackMixin);\nObject.assign(TextGroup.prototype, layoutMixin);\nObject.assign(TextGroup.prototype, {\n  // 屏蔽这两个方法，只根据reflow重算\n  _getBoundingGroupRect: function _getBoundingGroupRect() {},\n  resetChildrenPosition: function resetChildrenPosition() {},\n  reflow: function reflow() {\n    var _this8 = this;\n    var lineHeight = this.currentLineHeight;\n    var flattenTxtElem = this._flattenTxtElem;\n    var area = this._area;\n    if (flattenTxtElem.isEmpty()) {\n      var width = 0;\n      var t = flattenTxtElem.get(0);\n      requestCacheCanvas(function (ctx) {\n        ctx.font = "".concat(_this8.fontSize, " ").concat(_this8.fontFamily);\n        width = ctx.measureText(_this8.placeholder).width;\n      });\n      var _line2 = area.truncate({\n        height: lineHeight,\n        reduceHeight: lineHeight\n      });\n      _line2.insert(0, t);\n      Object.assign(t, {\n        anchorX: -width / 2,\n        height: lineHeight,\n        isTail: true\n      });\n      this.width = width;\n      this.height = lineHeight;\n      return;\n    }\n    var jflow = this._jflow;\n    var spaceHolder = this.spaceHolder;\n    requestCacheCanvas(function (ctx) {\n      ctx.font = "".concat(_this8.fontSize, " ").concat(_this8.fontFamily);\n      flattenTxtElem.forEach(function (element) {\n        if (element.type === \'text\' && element.dirty) {\n          element.preCalculateText(ctx, spaceHolder);\n        }\n      });\n    });\n    var nextArea = new Area();\n    nextArea.truncate({\n      height: lineHeight\n    });\n    var line = nextArea.get(0);\n    var allHeight = 0;\n    var allWidth = 0;\n    var lastElem = null;\n    var lineSpace = this.lineSpace;\n    var elementSpace = this.elementSpace;\n    flattenTxtElem.forEach(function (element) {\n      line.push(element);\n      element.reduceWidth = line.width;\n      if (element.type === \'text\') {\n        element.height = lineHeight;\n        line.width += element.width;\n        if (element.needWrap) {\n          allHeight += line.height + lineSpace;\n          line.reduceHeight = allHeight;\n          allWidth = Math.max(line.width, allWidth);\n          line = Line.create({\n            height: lineHeight\n          });\n          nextArea.push(line);\n        }\n      } else {\n        var node = jflow.getRenderNodeBySource(element.source);\n        element.height = node.height;\n        line.height = Math.max(line.height, node.height);\n        var margin = !lastElem || lastElem.type === \'text\' ? elementSpace * 2 : elementSpace;\n        line.width += node.width + margin;\n      }\n      lastElem = element;\n    });\n    flattenTxtElem.tail().isTail = true;\n    allHeight += line.height;\n    line.reduceHeight = allHeight;\n    allWidth = Math.max(this.minWidth, Math.max(line.width, allWidth));\n    var hh = allHeight / 2;\n    var hw = allWidth / 2;\n    var ty = -hh;\n    var lastReduceY = 0;\n    nextArea.forEach(function (l) {\n      var height = l.height,\n        reduceHeight = l.reduceHeight;\n      var anchorY = ty + lastReduceY + height / 2;\n      l.anchorY = anchorY;\n      var reduceX = -hw;\n      var lastel = null;\n      l.forEach(function (el) {\n        if (el.type === \'text\') {\n          el.anchorY = anchorY;\n          el.anchorX = reduceX + el.width / 2;\n          reduceX += el.width;\n        } else {\n          var renderNode = jflow.getRenderNodeBySource(el.source);\n          var doubleMargin = !lastel || lastel.type === \'text\';\n          var margin = doubleMargin ? elementSpace * 2 : elementSpace;\n          el.width = renderNode.width;\n          el.anchorY = anchorY;\n          el.anchorX = reduceX + el.width / 2 + (doubleMargin ? margin / 2 : 0);\n          renderNode.anchor = [el.anchorX, el.anchorY];\n          reduceX += el.width + margin;\n        }\n        lastel = el;\n      });\n      lastReduceY = reduceHeight;\n    });\n    this._area = nextArea;\n    this.width = allWidth;\n    this.height = allHeight;\n  },\n  doRecalculate: function doRecalculate() {\n    if (this.__mounted__) {\n      this.recalculateUp();\n    } else {\n      this.recalculate();\n      this.__mounted__ = true;\n    }\n  }\n});\n/* harmony default export */ const text_group = (TextGroup);\n;// CONCATENATED MODULE: ./src/core/instance/node-placeholder.js\nfunction node_placeholder_typeof(obj) { "@babel/helpers - typeof"; return node_placeholder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, node_placeholder_typeof(obj); }\nfunction node_placeholder_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, node_placeholder_toPropertyKey(descriptor.key), descriptor); } }\nfunction node_placeholder_createClass(Constructor, protoProps, staticProps) { if (protoProps) node_placeholder_defineProperties(Constructor.prototype, protoProps); if (staticProps) node_placeholder_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction node_placeholder_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction node_placeholder_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) node_placeholder_setPrototypeOf(subClass, superClass); }\nfunction node_placeholder_setPrototypeOf(o, p) { node_placeholder_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return node_placeholder_setPrototypeOf(o, p); }\nfunction node_placeholder_createSuper(Derived) { var hasNativeReflectConstruct = node_placeholder_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = node_placeholder_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = node_placeholder_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return node_placeholder_possibleConstructorReturn(this, result); }; }\nfunction node_placeholder_possibleConstructorReturn(self, call) { if (call && (node_placeholder_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return node_placeholder_assertThisInitialized(self); }\nfunction node_placeholder_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction node_placeholder_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction node_placeholder_getPrototypeOf(o) { node_placeholder_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return node_placeholder_getPrototypeOf(o); }\nfunction node_placeholder_defineProperty(obj, key, value) { key = node_placeholder_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction node_placeholder_toPropertyKey(arg) { var key = node_placeholder_toPrimitive(arg, "string"); return node_placeholder_typeof(key) === "symbol" ? key : String(key); }\nfunction node_placeholder_toPrimitive(input, hint) { if (node_placeholder_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (node_placeholder_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n// export const PLACEHOLDER_SYMBOL = Symbol(\'PLACEHOLDER_SYMBOL\');\n\nvar NodePlaceholder = /*#__PURE__*/function (_Node) {\n  node_placeholder_inherits(NodePlaceholder, _Node);\n  var _super = node_placeholder_createSuper(NodePlaceholder);\n  function NodePlaceholder() {\n    var _this;\n    node_placeholder_classCallCheck(this, NodePlaceholder);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    node_placeholder_defineProperty(node_placeholder_assertThisInitialized(_this), "type", \'NODE_PLACEHOLDER\');\n    return _this;\n  }\n  return node_placeholder_createClass(NodePlaceholder);\n}(node);\n;// CONCATENATED MODULE: ./src/core/flow/index.js\nfunction flow_typeof(obj) { "@babel/helpers - typeof"; return flow_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, flow_typeof(obj); }\nfunction flow_slicedToArray(arr, i) { return flow_arrayWithHoles(arr) || flow_iterableToArrayLimit(arr, i) || flow_unsupportedIterableToArray(arr, i) || flow_nonIterableRest(); }\nfunction flow_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction flow_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return flow_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return flow_arrayLikeToArray(o, minLen); }\nfunction flow_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction flow_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction flow_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction flow_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction flow_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, flow_toPropertyKey(descriptor.key), descriptor); } }\nfunction flow_createClass(Constructor, protoProps, staticProps) { if (protoProps) flow_defineProperties(Constructor.prototype, protoProps); if (staticProps) flow_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction flow_toPropertyKey(arg) { var key = flow_toPrimitive(arg, "string"); return flow_typeof(key) === "symbol" ? key : String(key); }\nfunction flow_toPrimitive(input, hint) { if (flow_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (flow_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction flow_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) flow_setPrototypeOf(subClass, superClass); }\nfunction flow_createSuper(Derived) { var hasNativeReflectConstruct = flow_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = flow_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = flow_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return flow_possibleConstructorReturn(this, result); }; }\nfunction flow_possibleConstructorReturn(self, call) { if (call && (flow_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return flow_assertThisInitialized(self); }\nfunction flow_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction flow_wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; flow_wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !flow_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return flow_construct(Class, arguments, flow_getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return flow_setPrototypeOf(Wrapper, Class); }; return flow_wrapNativeSuper(Class); }\nfunction flow_construct(Parent, args, Class) { if (flow_isNativeReflectConstruct()) { flow_construct = Reflect.construct.bind(); } else { flow_construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) flow_setPrototypeOf(instance, Class.prototype); return instance; }; } return flow_construct.apply(null, arguments); }\nfunction flow_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction flow_isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }\nfunction flow_setPrototypeOf(o, p) { flow_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return flow_setPrototypeOf(o, p); }\nfunction flow_getPrototypeOf(o) { flow_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return flow_getPrototypeOf(o); }\n\n\n\n\n\n\n\n\n\n\n\n\n// import { setUniqueId, getUniqueId } from \'../utils/functions\';\n\n\n\n\n\n\n\n\n\n\n// import { createInputTextStyle } from \'../instance/text\';\n// createInputTextStyle();\n/**\n * @funtion setInitialPosition\n * @param {Number} RealboxX - 内容映射到canvas上的 X\n * @param {Number} RealboxY - 内容映射到canvas上的 Y \n * @param {Number} RealboxW - 内容映射到canvas上的宽度\n * @param {Number} RealboxH - 内容映射到canvas上的高度 \n * @param {Number} CanvasWidth  - 视窗宽度\n * @param {Number} CanvasHeight  - 视窗高度\n * @return {Object} - 初始位置 { x, y }\n */\n\n/**\n * @funtion linkGen\n * @param {Node} from - 出发绘图节点\n * @param {Node} to - 临时节点，当前鼠标指的地方\n * @return {BaseeLink} - 连线对象\n */\n\n/** \n * @class Group\n * @classdesc 矩形组单元 由 {@link GroupFactory} 通过 {@link Rectangle} 生成\n * @groupfrom Rectangle\n * @augments GroupTemplate\n * @augments Rectangle\n * @param {(Rectangle~RectangleConfigs|GroupTemplate~GroupConfigs)} configs - 配置\n */\nvar Group = groupFactory(rectangle);\n/** \n * @class CapsuleGroup\n * @classdesc 胶囊组单元 由 {@link GroupFactory} 通过 {@link Capsule} 生成\n * @groupfrom Capsule\n * @augments GroupTemplate\n * @augments Capsule\n * @param {(Capsule~CapsuleConfigs|GroupTemplate~GroupConfigs)} configs - 配置\n */\nvar CapsuleGroup = groupFactory(capsule);\n/** \n * @class RhombusGroup\n * @classdesc 菱形组单元 由 {@link GroupFactory} 通过 {@link Rhombus} 生成\n * @augments GroupTemplate\n * @augments Rhombus\n * @groupfrom Rhombus\n * @param {(Rhombus~RhombusConfigs|GroupTemplate~GroupConfigs)} configs - 配置\n */\nvar RhombusGroup = groupFactory(rhombus);\n/** \n * @class DiamondGroup\n * @classdesc 钻石形组单元 由 {@link GroupFactory} 通过 {@link Diamond} 生成\n * @groupfrom Diamond\n * @augments GroupTemplate\n * @augments Diamond\n * @param {(Diamond~DiamondConfigs|GroupTemplate~GroupConfigs)} configs - 配置\n */\nvar DiamondGroup = groupFactory(diamond, {\n  shapeShift: function shapeShift(width, height) {\n    return [width + height * 0.28865, height];\n  }\n});\n/** \n * @class DiamondVerticalGroup\n * @classdesc 垂直钻石形组单元 由 {@link GroupFactory} 通过 {@link DiamondVertical} 生成\n * @groupfrom DiamondVertical\n * @augments GroupTemplate\n * @augments DiamondVertical\n * @param {(Diamond~DiamondConfigs|GroupTemplate~GroupConfigs)} configs - 配置\n */\nvar DiamondVerticalGroup = groupFactory(diamond_vertical, {\n  shapeShift: function shapeShift(width, height) {\n    return [width, height + width * 0.5773];\n  }\n});\n/** \n * @class CapsuleVerticalGroup\n * @classdesc 垂直钻石形组单元 由 {@link GroupFactory} 通过 {@link CapsuleVertical} 生成\n * @groupfrom CapsuleVertical\n * @augments GroupTemplate\n * @augments CapsuleVertical\n * @param {(Capsule~CapsuleConfigs|GroupTemplate~GroupConfigs)} configs - 配置\n */\nvar CapsuleVerticalGroup = groupFactory(capsule_vertical);\nvar PointGroup = groupFactory(point, {\n  shapeShift: function shapeShift(width, height, p) {\n    var r = Math.ceil(Math.sqrt(width * width + height * height) / 2);\n    p.radius = r;\n    var w = r * 2;\n    return [w, w];\n  }\n});\n\n/**\n * @typedef JFlow~JFlowConfigs\n * @type {object}\n * @property {Boolean} allowDrop      - 是否允许 dragdrop\n * @property {Number} maxZoom         - 最大缩放\n * @property {Number} minZoom         - 最小缩放\n * @property {number} initialZoom     - 初始缩放比\n * @property {EventAdapter~pluginDef} eventAdapter\n */\n\n/**\n * @typedef {JFlow~JFlowConfigs | LayoutMixin~LayoutConfigs} JFlow~JFlowLayoutConfigs\n */\n/** \n * JFlow 对象\n * JFlow 是 canvas 上面封装的一个顶层对象，具有处理事件和绘制的功能\n * @constructor JFlow\n * @param {JFlow~JFlowLayoutConfigs} configs - 配置项\n * @mixes LayoutMixin\n * @mixes StackMixin\n * @mixes MessageMixin\n */\nvar JFlow = /*#__PURE__*/function (_EventTarget) {\n  flow_inherits(JFlow, _EventTarget);\n  var _super = flow_createSuper(JFlow);\n  function JFlow(configs) {\n    var _this;\n    flow_classCallCheck(this, JFlow);\n    _this = _super.call(this);\n    _this.uniqueName = \'jflow\';\n    /**\n     * @member {EventAdapter} eventAdapter    - eventAdapter 对象\n     **/\n    _this.eventAdapter = new adapter(configs.eventAdapter);\n    _this.initNodeWeakMap();\n    _this.initAnime();\n    _this.initStack(configs);\n    _this.initLayout(configs);\n    /** @member {Context2d}     - Context2d 对象 */\n    _this.ctx = null;\n    /** @member {Element}       - canvas 元素 */\n    _this.canvas = null;\n    /** @member {number}       - 设备DPR */\n    _this.dpr = 1;\n    /** @member {number}       - 内边距 */\n    _this.padding = 20;\n    _this.position = null;\n    /** @member {number}     - 缩放 */\n    _this.scale = null;\n    /** @member {number}     - 初始缩放 */\n    _this.initialZoom = configs.initialZoom;\n    /** @member {setInitialPosition} - 初始位置计算 */\n    _this.initialPosition = configs.setInitialPosition;\n    /** @member {number}     - 最大缩放 */\n    _this.maxZoom = configs.maxZoom || 3;\n    /** @member {number}     - 最小缩放 */\n    _this.minZoom = configs.minZoom || .5;\n    _this.NodeRenderTop = !!configs.NodeRenderTop;\n    _this.worldMargin = configs.worldMargin;\n    _this.draggingbehavior = Object.assign({\n      panInBorder: {\n        enable: true,\n        padding: 20,\n        deltamovement: 8,\n        allowMovingTargetInPan: true\n      }\n    }, configs.draggingbehavior || {});\n    _this.scrollBarBehavior = Object.assign({\n      enable: true\n    }, configs.scrollBarBehavior || {});\n    // this.initScale = 1;\n    // this.initPosition = null\n    _this.offeset = null;\n    _this._lastState = {\n      x: null,\n      y: null,\n      dragging: false,\n      processing: false\n    };\n    _this._lastDragState = {\n      target: null,\n      targetLink: null,\n      processing: false\n    };\n    _this._target = {\n      instance: null,\n      link: null,\n      moving: null,\n      isInstanceDirty: false,\n      isLinkDirty: false,\n      // isMovingDirty: false, \n      cache: {\n        stack: null,\n        belongs: null,\n        point: null\n      },\n      meta: {\n        x: undefined,\n        y: undefined,\n        initialX: undefined,\n        initialY: undefined\n      },\n      status: {\n        dragovering: false,\n        dragging: false,\n        processing: false,\n        movingState: false\n      }\n    };\n    _this._focus = {\n      instance: null\n    };\n    _this._dragOverTarget = null;\n    // this.lock = configs.lock;\n\n    _this.allowDrop = configs.allowDrop;\n    // 临时绘制的对象\n    _this._tempNode = null;\n    _this._tempLink = null;\n    _this.mode = JFLOW_MODE.DEFAULT;\n    _this._allowMovingTarget = true;\n    _this.canvasMeta = {};\n    _this._cacheViewBox = [];\n    _this.__mounted__ = false;\n\n    // this._allowZoom = true;\n    return _this;\n  }\n\n  // allowZoom() {\n  //     this._allowZoom = true;\n  // }\n\n  // abandonZoom() {\n  //     this._allowZoom = false;\n  // }\n  /**\n   * 设置当前拖动的 JFlow 对象\n   * @param {Object[]} targets - 具有 anchor 属性的对象\n   */\n  flow_createClass(JFlow, [{\n    key: "setMovingTargets",\n    value: function setMovingTargets(targets) {\n      Object.assign(this._target, {\n        moving: targets\n      });\n    }\n\n    /**\n     * 设置当前拖动的 JFlow 对象\n     * @param {Instance} instance - JFlow 对象\n     */\n  }, {\n    key: "setTempDraggingInstance",\n    value: function setTempDraggingInstance(instance) {\n      instance._belongs = this;\n      this._tempNode = instance;\n      Object.assign(this._target, {\n        moving: [this._tempNode],\n        dragging: true\n      });\n    }\n\n    /**\n     * 取消当前拖动的 JFlow 对象\n     * @return {number[]} point - JFlow 坐标\n     */\n  }, {\n    key: "removeTempDraggingInstance",\n    value: function removeTempDraggingInstance() {\n      if (this._tempNode) {\n        // this.removeFromStack(this._tempNode);\n        var anchor = this._tempNode.anchor;\n        this._tempNode = null;\n        return anchor;\n      }\n    }\n    /**\n     * 关闭默认对象拖动效果\n     */\n  }, {\n    key: "preventDefaultDragging",\n    value: function preventDefaultDragging() {\n      this._allowMovingTarget = false;\n    }\n    /**\n     * 开启默认对象拖动效果\n     */\n  }, {\n    key: "allowDefaultDragging",\n    value: function allowDefaultDragging() {\n      this._allowMovingTarget = true;\n    }\n    /**\n     * 在 Document 元素上初始化实例\n     * @param {Element} dom \n     */\n  }, {\n    key: "$mount",\n    value: function $mount(dom) {\n      var _this2 = this;\n      var _createCanvas = createCanvas(dom),\n        canvas = _createCanvas.canvas,\n        ctx = _createCanvas.ctx,\n        dpr = _createCanvas.scale,\n        c_width = _createCanvas.width,\n        c_height = _createCanvas.height,\n        raw_width = _createCanvas.raw_width,\n        raw_height = _createCanvas.raw_height,\n        left = _createCanvas.left,\n        top = _createCanvas.top;\n      this.reflow();\n      this.ctx = ctx; //new CanvasContext2d(ctx, dpr);\n      this.DOMwrapper = dom;\n      this.canvas = canvas;\n      this.canvas.setAttribute(\'data-jflow\', true);\n      this.canvas.$jflow = this;\n      this.canvasMeta = {\n        width: raw_width,\n        height: raw_height,\n        actual_width: c_width,\n        actual_height: c_height\n      };\n      this.dpr = dpr;\n      this._getBoundingGroupRect();\n      var padding = this.padding;\n      var _this$bounding_box = this.bounding_box,\n        p_width = _this$bounding_box.width,\n        p_height = _this$bounding_box.height,\n        p_x = _this$bounding_box.x,\n        p_y = _this$bounding_box.y;\n      var contentBox = {\n        x: padding,\n        y: padding,\n        width: c_width - padding * 2,\n        height: c_height - padding * 2\n      };\n      var position = {\n        x: 0,\n        y: 0,\n        offsetX: 0,\n        offsetY: 0\n      };\n      var w_ratio = contentBox.width / p_width;\n      var h_ratio = contentBox.height / p_height;\n      var align = w_ratio <= h_ratio ? \'x\' : \'y\';\n      var scaleRatio;\n      if (this.initialZoom) {\n        scaleRatio = this.initialZoom;\n      } else {\n        scaleRatio = Math.min(w_ratio, h_ratio);\n      }\n      this.scale = scaleRatio;\n      if (scaleRatio > this.maxZoom) {\n        this.maxZoom = scaleRatio;\n      }\n      if (scaleRatio < this.minZoom) {\n        this.minZoom = scaleRatio;\n      }\n      var realboxX = p_x * scaleRatio;\n      var realboxY = p_y * scaleRatio;\n      var realboxW = contentBox.width;\n      var realboxH = contentBox.height;\n      if (this.initialPosition) {\n        var _this$initialPosition = this.initialPosition(realboxX, realboxY, realboxW, realboxH, contentBox.x, contentBox.y, c_width, c_height, p_x, p_y, p_width, p_height),\n          x = _this$initialPosition.x,\n          y = _this$initialPosition.y;\n        position.x = x;\n        position.y = y;\n      } else {\n        position.x = align === \'x\' ? contentBox.x : (realboxW - p_width * scaleRatio) / 2 + padding;\n        position.y = align === \'y\' ? contentBox.y : (realboxH - p_height * scaleRatio) / 2 + padding;\n      }\n      position.offsetX = position.x - realboxX;\n      position.offsetY = position.y - realboxY;\n      this.position = position;\n      this._readyToRender = true;\n      if (this.scrollBarBehavior.enable) {\n        this.initScrollBar(this.scrollBarBehavior);\n      }\n      // this.initSchedule();\n      // this.scheduleRender(() => {\n      //     this._createEventHandler();\n      // });\n      this.__render();\n      this._createEventHandler();\n      listenOnDevicePixelRatio(function (dpr) {\n        _this2.dpr = dpr;\n        // this.ctx.setDPR(dpr)\n        _this2.resizeCanvas();\n        _this2.scheduleRender();\n      }, function (handler) {\n        _this2.destroyDprListener = handler;\n      });\n      this.__mounted__ = true;\n    }\n\n    /**\n     * 设置Jflow进入连线模式\n     * @param {Object} source - 当前连线的出发原始数据\n     * @param {linkGen} linkGen - 生成连线单元的方法\n     */\n  }, {\n    key: "setLinkingMode",\n    value: function setLinkingMode(source, linkGen, isTail) {\n      var renderNode = this.getRenderNodeBySource(source);\n      this._tempNode = new ghostNode();\n      if (isTail) {\n        this._tempLink = linkGen({\n          from: this._tempNode,\n          to: renderNode\n        });\n      } else {\n        this._tempLink = linkGen({\n          from: renderNode,\n          to: this._tempNode\n        });\n      }\n      this.sendMessage({\n        instance: source\n      });\n      this.mode = JFLOW_MODE.LINKING;\n    }\n  }, {\n    key: "isInLinkingMode",\n    value: function isInLinkingMode() {\n      return this.mode === JFLOW_MODE.LINKING;\n    }\n\n    /**\n     * 连线模式下，设置当前临时连线的属性\n     * @param {BaseLink~Configs} configs - 当前连线的出发原始数据\n     */\n  }, {\n    key: "setLinkingLink",\n    value: function setLinkingLink(configs) {\n      if (this.mode === JFLOW_MODE.LINKING) {\n        this._tempLink.setConfig(configs);\n      }\n    }\n    /**\n     * 连线模式下，重连回临时鼠标节点\n     */\n  }, {\n    key: "resetLinkingLink",\n    value: function resetLinkingLink() {\n      if (this.mode === JFLOW_MODE.LINKING) {\n        this._tempLink.setConfig({\n          to: this._tempNode\n        });\n      }\n    }\n  }, {\n    key: "clearTemp",\n    value: function clearTemp() {\n      if (this._tempNode) {\n        this._tempNode.destroy();\n        this._tempNode = null;\n      }\n      if (this._tempLink) {\n        this._tempLink.destroy();\n        this._tempLink = null;\n      }\n      this._render();\n    }\n  }, {\n    key: "preventClearTemp",\n    value: function preventClearTemp() {\n      this._preventClearTemp = true;\n    }\n\n    /**\n     * 外层容器大小变化后，调用此方法可以改变当前canvas的状态\n     */\n  }, {\n    key: "resizeCanvas",\n    value: function resizeCanvas() {\n      if (this.canvas && this.DOMwrapper) {\n        var _resizeCanvas2 = canvas_resizeCanvas(this.canvas, this.DOMwrapper),\n          c_width = _resizeCanvas2.width,\n          c_height = _resizeCanvas2.height,\n          raw_width = _resizeCanvas2.raw_width,\n          raw_height = _resizeCanvas2.raw_height;\n        this.canvasMeta = {\n          width: raw_width,\n          height: raw_height,\n          actual_width: c_width,\n          actual_height: c_height\n        };\n      }\n    }\n  }, {\n    key: "setFocusInstance",\n    value: function setFocusInstance(node) {\n      this._focus.instance = node;\n    }\n\n    /**\n     * 移动画布到以目标绘图节点为中心的位置上\n     * @param {Node} node - 绘图节点\n     */\n  }, {\n    key: "focusOn",\n    value: function focusOn(node) {\n      var center = this._calculatePointBack([this.canvasMeta.actual_width / 2, this.canvasMeta.actual_height / 2]);\n      var offset = node.anchor;\n      if (node._belongs.calculateToCoordination) {\n        offset = node._belongs.calculateToCoordination(offset);\n      }\n      var deltaX = (center[0] - offset[0]) * this.scale;\n      var deltaY = (center[1] - offset[1]) * this.scale;\n      this._recalculatePosition(deltaX, deltaY);\n      this._render();\n    }\n  }, {\n    key: "_getBoundingGroupRect",\n    value: function _getBoundingGroupRect() {\n      var points = this._stack.getBoundingRectPoints();\n      if (this.bounding_box) {\n        this.bounding_box = bounding_box(points);\n        var _this$bounding_box2 = this.bounding_box,\n          nowx = _this$bounding_box2.x,\n          nowy = _this$bounding_box2.y;\n        var scale = this.scale;\n        this.position.x = this.position.offsetX + nowx * scale;\n        this.position.y = this.position.offsetY + nowy * scale;\n      } else {\n        this.bounding_box = bounding_box(points);\n      }\n    }\n  }, {\n    key: "_createEventHandler",\n    value: function _createEventHandler() {\n      var _this3 = this;\n      var canvas = this.canvas;\n      var destroyListener;\n      this.eventAdapter.apply(this);\n      var destroyPlainEventListener = function destroyPlainEventListener() {\n        _this3.eventAdapter.unload(_this3);\n        _this3.destroyDprListener();\n      };\n      destroyListener = destroyPlainEventListener;\n      if (this.allowDrop) {\n        var dragoverHandler = this._onDragover.bind(this);\n        var dropHandler = this._onDrop.bind(this);\n        var dragleaveHanlder = this._onDragLeave.bind(this);\n        canvas.addEventListener(\'dragstart\', function (e) {\n          e.preventDefault();\n        });\n        canvas.addEventListener(\'dragover\', dragoverHandler);\n        canvas.addEventListener(\'drop\', dropHandler);\n        canvas.addEventListener(\'dragleave\', dragleaveHanlder);\n        destroyListener = function destroyListener() {\n          destroyPlainEventListener();\n          canvas.removeEventListener(\'dragover\', dragoverHandler);\n          canvas.removeEventListener(\'drop\', dropHandler);\n          canvas.removeEventListener(\'dragleave\', dragleaveHanlder);\n        };\n      }\n      this.destroy = destroyListener;\n    }\n  }, {\n    key: "_targetLockOn",\n    value: function _targetLockOn(offsetPoint, event) {\n      var _this4 = this;\n      var point = this._calculatePointBack(offsetPoint);\n      var topLayerPoint = point;\n      this._currentp = point;\n      var stack = this._stack;\n      var br = this._getViewBox();\n      var target = stack.checkHit(point,\n      // 应用于所有\n      function (instance) {\n        return _this4._target.status.dragging && instance === _this4._getMovingTarget();\n      },\n      // 仅对于本层过滤\n      function (instance) {\n        return doOverlap(br, instance.getBoundingRect());\n      });\n      var linkStack = this._linkStack;\n      var belongs = this;\n      /*\n      if(target) {\n          linkStack = target._belongs._linkStack;\n          point = target._belongs._currentp;\n          stack = target._belongs._stack;\n          belongs = target._belongs\n      }*/\n      // 暂时设定只有顶层有连线\n      var targetLink;\n      if (!target || target._belongs === this) {\n        targetLink = linkStack.checkHit(point, function (link) {\n          if (!_this4._target.status.dragging) {\n            return false;\n          }\n          var movingtarget = _this4._getMovingTarget();\n          return link.from === movingtarget || link.to === movingtarget;\n        });\n      }\n      if (!targetLink) {\n        targetLink = linkStack.checkHit(point, function (link) {\n          return !link.ON_TOP;\n        });\n      }\n      Object.assign(this._target, {\n        instance: target,\n        link: targetLink,\n        isInstanceDirty: target === this._target.instance,\n        isLinkDirty: targetLink === this._target.link\n      });\n      Object.assign(this._target.cache, {\n        stack: stack,\n        belongs: belongs,\n        point: point,\n        topLayerPoint: topLayerPoint\n      });\n      Object.assign(this._target.meta, {\n        x: offsetPoint[0],\n        y: offsetPoint[1]\n      });\n      if (event === \'pressStart\' && !this._target.status.dragging && !this._target.status.dragovering) {\n        var movingtarget = target;\n        while (movingtarget && movingtarget._belongs.lock && movingtarget !== this) {\n          movingtarget = movingtarget._belongs;\n        }\n        this.setMovingTargets(movingtarget && [movingtarget]);\n        if (movingtarget) {\n          /**\n           * \n           * 开始拖拽时，拖拽对象设置之前\n           * @event Node#afterResolveMovingTarget\n           * @type {object}\n           * @property {Event} event           - 原始事件 \n           * @property {JFlow} jflow           - 当前JFlow对象 \n           * @property {Node} target           - 目标节点\n           */\n          target.bubbleEvent(new events(\'afterResolveMovingTarget\', {\n            event: event,\n            target: movingtarget,\n            jflow: this,\n            bubbles: true\n          }));\n        }\n      }\n      if ([\'pressStart\', \'click\', \'dblclick\', \'contextclick\'].includes(event)) {\n        if (this._focus.instance && this._focus.instance !== target) {\n          this._focus.instance.dispatchEvent(new events(\'blur\', {\n            relatedTarget: target\n          }));\n          this._focus.instance = null;\n        }\n      }\n      return this._target;\n    }\n  }, {\n    key: "blur",\n    value: function blur() {\n      if (this._focus.instance) {\n        this._focus.instance.dispatchEvent(new events(\'blur\', {\n          relatedTarget: null\n        }));\n        this._focus.instance = null;\n      }\n    }\n  }, {\n    key: "_getMovingTarget",\n    value: function _getMovingTarget() {\n      return this._target.moving && this._target.moving[0];\n    }\n  }, {\n    key: "_processDragOver",\n    value: function _processDragOver(instance, event) {\n      if (this._dragOverTarget !== instance) {\n        var _this$readMessage;\n        var target = (_this$readMessage = this.readMessage()) === null || _this$readMessage === void 0 ? void 0 : _this$readMessage.instance;\n        this._dragCurrentData = target;\n        var point = this._target.cache.point;\n        // console.log(\'_processDragOver\', this._dragOverTarget)\n        if (this._dragOverTarget) {\n          var oldIns = this._dragOverTarget;\n          /**\n          * dragleave 退出事件\n          * @event Instance#dragleave\n          * @type {object}\n          * @property {Event} event           - 原始事件 \n          * @property {Object} instance       - dragleave的对象 \n          * @property {target} target         - drag 携带的对象（特指从外面拖进canvas的对象） \n          */\n          oldIns.dispatchEvent(new events(\'dragleave\', {\n            event: event,\n            instance: oldIns,\n            target: target,\n            jflow: this,\n            point: point\n          }));\n        }\n        if (instance) {\n          /**\n          * dragenter 进入事件\n          * @event Instance#dragenter\n          * @type {object}\n          * @property {Event} event           - 原始事件 \n          * @property {Object} instance       - dragenter的对象 \n          * @property {target} target         - drag 携带的对象（特指从外面拖进canvas的对象） \n          */\n          instance.dispatchEvent(new events(\'dragenter\', {\n            event: event,\n            instance: instance,\n            target: target,\n            jflow: this,\n            point: point\n          }));\n        }\n        this._dragOverTarget = instance;\n      } else if (this._dragOverTarget) {\n        /**\n        * dragover 进入事件\n        * @event Instance#dragover\n        * @type {object}\n        * @property {Event} event           - 原始事件 \n        * @property {Object} instance       - dragover的对象 \n        * @property {target} target         - drag 携带的对象（特指从外面拖进canvas的对象） \n        */\n        this._dragOverTarget.dispatchEvent(new events(\'dragover\', {\n          event: event,\n          instance: instance,\n          jflow: this,\n          target: this._dragCurrentData\n        }));\n      }\n      this._processPanInBorder();\n    }\n  }, {\n    key: "_processPanInBorder",\n    value: function _processPanInBorder() {\n      var _this$draggingbehavio,\n        _this5 = this;\n      if ((_this$draggingbehavio = this.draggingbehavior) !== null && _this$draggingbehavio !== void 0 && (_this$draggingbehavio = _this$draggingbehavio.panInBorder) !== null && _this$draggingbehavio !== void 0 && _this$draggingbehavio.enable) {\n        if (!this.draggingbehavior.panInBorder.timer) {\n          this.draggingbehavior.panInBorder.timer = Date.now();\n        }\n        if (Date.now() - this.draggingbehavior.panInBorder.timer > 500) {\n          var _this$_cacheViewBox = flow_slicedToArray(this._cacheViewBox, 4),\n            x = _this$_cacheViewBox[0],\n            y = _this$_cacheViewBox[1],\n            w = _this$_cacheViewBox[2],\n            h = _this$_cacheViewBox[3];\n          var _this$_currentp = flow_slicedToArray(this._currentp, 2),\n            px = _this$_currentp[0],\n            py = _this$_currentp[1];\n          var _this$draggingbehavio2 = this.draggingbehavior.panInBorder,\n            padding = _this$draggingbehavio2.padding,\n            deltamovement = _this$draggingbehavio2.deltamovement;\n          var deltaX = 0;\n          var deltaY = 0;\n          if (px < x + padding) {\n            deltaX = deltamovement;\n          }\n          if (px > w - padding) {\n            deltaX = -deltamovement;\n          }\n          if (py < y + padding) {\n            deltaY = deltamovement;\n          }\n          if (py > h - padding) {\n            deltaY = -deltamovement;\n          }\n          if (this.__processOverAnime) {\n            this.__processOverAnime.cancel();\n          }\n          if (deltaX || deltaY) {\n            this.__processOverAnime = this.requestJFlowAnime(function () {\n              _this5.panHandler(deltaX, deltaY);\n            });\n          } else {\n            this.draggingbehavior.panInBorder.timer = null;\n          }\n        }\n      }\n    }\n  }, {\n    key: "_onDragover",\n    value: function _onDragover(event) {\n      var _this6 = this;\n      event.preventDefault();\n      event.stopPropagation();\n      if (this._lastDragState.processing) return;\n      this._lastDragState.processing = true;\n      var offsetX = event.offsetX,\n        offsetY = event.offsetY;\n      Object.assign(this._target.status, {\n        dragovering: true\n      });\n      this._targetLockOn([offsetX, offsetY]);\n      var instance = this._target.instance || this._target.link;\n      this._processDragOver(instance, event);\n      if (this._target.isLinkDirty || this._target.isInstanceDirty) {\n        Promise.resolve().then(function () {\n          // this._render();    \n          _this6._target.isLinkDirty = false;\n          _this6._target.isInstanceDirty = false;\n          _this6._lastDragState.processing = false;\n        });\n      } else {\n        this._lastDragState.processing = false;\n      }\n    }\n  }, {\n    key: "_cancelPanInBorder",\n    value: function _cancelPanInBorder() {\n      var _this$draggingbehavio3;\n      if (this.__processOverAnime) {\n        this.__processOverAnime.cancel();\n      }\n      if ((_this$draggingbehavio3 = this.draggingbehavior) !== null && _this$draggingbehavio3 !== void 0 && _this$draggingbehavio3.panInBorder) {\n        this.draggingbehavior.panInBorder.timer = null;\n      }\n    }\n  }, {\n    key: "_onDragLeave",\n    value: function _onDragLeave() {\n      this._cancelPanInBorder();\n    }\n  }, {\n    key: "_onDrop",\n    value: function _onDrop(event) {\n      var _this7 = this;\n      this._cancelPanInBorder();\n      var payload = this.consumeMessage();\n      var instance = payload === null || payload === void 0 ? void 0 : payload.instance;\n      if (this._dragOverTarget) {\n        var oldIns = this._dragOverTarget;\n        oldIns.dispatchEvent(new events(\'dragoverend\', {\n          event: event,\n          instance: oldIns\n        }));\n        this._dragOverTarget = null;\n      }\n      var _this$_target = this._target,\n        link = _this$_target.link,\n        target = _this$_target.instance;\n      var _this$_target$cache = this._target.cache,\n        point = _this$_target$cache.point,\n        belongs = _this$_target$cache.belongs;\n      if (link) {\n        /**\n         * 丢在线上事件\n         *\n         * @event BaseLink#drop\n         * @type {object}\n         * @property {Event} event           - 原始事件 \n         * @property {Object} instance       - 拖动的对象 \n         * @property {BaseLink} link         - 目标连线 \n         * @property {JFlow} jflow           - 当前JFlow对象 \n         * @property {Group|JFlow} belongs   - 连线所在的绘图栈的对象\n         * @property {number[]} point        - 已经计算到绘图栈对应坐标系下的坐标\n         */\n        // instance.anchor = point;\n        link.dispatchEvent(new events(\'drop\', {\n          event: event,\n          instance: instance,\n          link: link,\n          jflow: this,\n          belongs: belongs,\n          point: point\n        }));\n      } else if (target) {\n        /**\n         * 丢在节点上事件\n         *\n         * @event Node#drop\n         * @type {object}\n         * @property {Event} event           - 原始事件 \n         * @property {Object} instance       - 拖动的对象 \n         * @property {JFlow} jflow           - 当前JFlow对象 \n         * @property {Node} target           - 目标节点\n         * @property {number[]} point        - 已经计算到绘图栈对应坐标系下的坐标\n         */\n        target.bubbleEvent(new events(\'drop\', {\n          event: event,\n          instance: instance,\n          jflow: this,\n          target: target,\n          point: point,\n          bubbles: true\n        }));\n      } else {\n        /**\n        * 丢在主图上事件\n        *\n        * @event JFlow#drop\n        * @type {object}\n        * @property {Event} event           - 原始事件 \n        * @property {Object} instance       - 拖动的对象 \n        * @property {JFlow} jflow           - 当前JFlow对象 \n        * @property {number[]} point        - 已经计算到绘图栈对应坐标系下的坐标\n        */\n        this.dispatchEvent(new events(\'drop\', {\n          event: event,\n          instance: instance,\n          jflow: this,\n          target: target,\n          point: point\n        }));\n      }\n      requestAnimationFrame(function () {\n        _this7.cancelDrop();\n      });\n    }\n  }, {\n    key: "cancelDrop",\n    value: function cancelDrop() {\n      this._target.instance = null;\n      this._target.link = null;\n      Object.assign(this._target.status, {\n        dragovering: false\n      });\n    }\n\n    /**\n     * 缩放操作处理函数\n     * @param {Number} offsetX - 事件对象与canvas的内填充边（padding edge）在 X 轴方向上的偏移量。\n     * @param {Number} offsetY - 事件对象与canvas的内填充边（padding edge）在 Y 轴方向上的偏移量。 \n     * @param {Number} deltaX  - 水平滚动量\n     * @param {Number} deltaY  - 垂直滚动量\n     * @param {Number} event - 原生事件\n     */\n  }, {\n    key: "zoomHandler",\n    value: function zoomHandler(offsetX, offsetY, deltaX, deltaY, event) {\n      var _this8 = this;\n      // if(!this._allowZoom) return;\n      if (this._zooming) return;\n      this._zooming = true;\n      var _this$bounding_box3 = this.bounding_box,\n        p_width = _this$bounding_box3.width,\n        p_height = _this$bounding_box3.height,\n        x = _this$bounding_box3.x,\n        y = _this$bounding_box3.y;\n      var _this$canvasMeta = this.canvasMeta,\n        cw = _this$canvasMeta.actual_width,\n        ch = _this$canvasMeta.actual_height;\n      var minZoom = this.minZoom;\n      if (this.worldMargin) {\n        var m = this.worldMargin;\n        var maxWidth = p_width + m * 2;\n        var maxHeight = p_height + m * 2;\n        minZoom = Math.max(minZoom, Math.max(cw / maxWidth, ch / maxHeight));\n      }\n      var newScale = this.scale;\n      var amount = deltaY > 0 ? 1.05 : 1 / 1.05;\n      newScale *= amount;\n      newScale = Math.min(this.maxZoom, Math.max(minZoom, newScale));\n      // console.log(newScale);\n      // if (this.maxZoom && newScale > this.maxZoom){\n      //     // could just return but then won\'t stop exactly at maxZoom\n      //     newScale = this.maxZoom;\n      // }\n\n      // if(this.minZoom && newScale < this.minZoom) {\n      //     newScale = this.minZoom;\n      // }\n\n      var deltaScale = newScale - this.scale;\n      var currentWidth = p_width * this.scale;\n      var currentHeight = p_height * this.scale;\n      var deltaWidth = p_width * deltaScale;\n      var deltaHeight = p_height * deltaScale;\n      var tX = offsetX - this.position.x;\n      var tY = offsetY - this.position.y;\n      var pX = -tX / currentWidth;\n      var pY = -tY / currentHeight;\n      this.scale = newScale;\n      this._recalculatePosition(pX * deltaWidth, pY * deltaHeight);\n\n      // this.position.x += pX * deltaWidth;\n      // this.position.y += pY * deltaHeight;\n      // this.position.offsetX = this.position.x - x * newScale;\n      // this.position.offsetY = this.position.y - y * newScale;\n      this.dispatchEvent(new events(\'zoompan\', {\n        deltaX: 0,\n        deltaY: 0\n      }));\n      // this.setAnimeClock()\n      this.scheduleRender(function () {\n        _this8._zooming = false;\n      });\n      // requestAnimationFrame((timestamp) => {\n      //     this.setAnimeClock(timestamp);\n      //     this._render();\n      //     this._zooming = false;\n      // })\n    }\n    /**\n     * 平移画布操作处理函数\n     * @param {Number} deltaX  - 水平滚动量\n     * @param {Number} deltaY  - 垂直滚动量\n     * @param {Number} event - 原生事件\n     */\n  }, {\n    key: "panHandler",\n    value: function panHandler(deltaX, deltaY, event) {\n      var _this9 = this;\n      if (this._panning) return;\n      this._panning = true;\n      var dragging = this._target.status.dragging;\n      if (dragging) {\n        var movingtarget = this._target.moving;\n        if (movingtarget) {\n          if (this.draggingbehavior.panInBorder.allowMovingTargetInPan) {\n            movingtarget.forEach(function (t) {\n              t.anchor[0] += -deltaX / _this9.scale;\n              t.anchor[1] += -deltaY / _this9.scale;\n            });\n          }\n        }\n      }\n      this._recalculatePosition(deltaX, deltaY);\n      /**\n       * 缩放平移事件\n       *\n       * @event JFlow#zoompan\n      */\n      this.dispatchEvent(new events(\'zoompan\', {\n        deltaX: deltaX,\n        deltaY: deltaY\n      }));\n      this.scheduleRender(function () {\n        _this9._panning = false;\n      });\n      // requestAnimationFrame((timestamp) => {\n      //     this.setAnimeClock(timestamp);\n      //     this._render();\n      //     this._panning = false;\n      // })\n    }\n    /**\n     * 开始按压处理函数\n     * @param {Number} offsetX - 事件对象与canvas的内填充边（padding edge）在 X 轴方向上的偏移量。\n     * @param {Number} offsetY - 事件对象与canvas的内填充边（padding edge）在 Y 轴方向上的偏移量。 \n     * @param {Number} event - 原生事件\n     */\n  }, {\n    key: "pressStartHandler",\n    value: function pressStartHandler(offsetX, offsetY, event) {\n      var _this10 = this;\n      if (this.checkScrollDragging()) {\n        return;\n      }\n      Object.assign(this._target.meta, {\n        initialX: offsetX,\n        initialY: offsetY\n      });\n      var _this$_targetLockOn = this._targetLockOn([offsetX, offsetY], \'pressStart\'),\n        link = _this$_targetLockOn.link,\n        instance = _this$_targetLockOn.instance;\n      // 后续只支持 click 动作\n      if (this.mode === JFLOW_MODE.LINKING) return;\n      Object.assign(this._target.status, {\n        dragging: true,\n        processing: false\n      });\n      if (this._target.moving) {\n        var moving = this._getMovingTarget();\n        /**\n         * 开始拖动组的事件（特指lock的顶层组）\n         *\n         * @event Node#pressStart\n         * @type {object}\n         * @property {Event} event           - 原始事件 \n         * @property {Node} instance       - 拖动的对象 \n         * @property {JFlow} jflow           - 当前JFlow对象 \n         */\n        moving.dispatchEvent(new events(\'pressStart\', {\n          event: event,\n          instance: moving,\n          jflow: this\n        }));\n      }\n      var t = this._resolveLockOnTarget(link, instance);\n      if (t) {\n        /**\n         * 开始拖动对象事件（就是目标对象的拖动事件，事件支持冒泡）\n         *\n         * @event Node#instancePressStart\n         * @type {object}\n         * @property {Event} event           - 原始事件 \n         * @property {Node} instance     - 拖动的对象 \n         * @property {JFlow} jflow           - 当前JFlow对象 \n         * @property {Boolean} bubbles       - 冒泡\n         */\n        // const t = this._target.instance;\n        t.bubbleEvent(new events(\'instancePressStart\', {\n          event: event,\n          target: t,\n          jflow: this,\n          bubbles: true,\n          preventDefault: function preventDefault() {\n            _this10._preventPressSequeence = true;\n            _this10._clearTarget();\n            document.addEventListener(\'pointerup\', function (e) {\n              e.preventDefault();\n              e.stopPropagation();\n              _this10._preventPressSequeence = false;\n            }, {\n              once: true\n            });\n          }\n        }));\n      }\n      if (!this._preventPressSequeence) {\n        this.dispatchEvent(new events(\'jflowPressStart\', {\n          event: event,\n          jflow: this\n        }));\n      }\n    }\n    /**\n     * 按压中处理函数\n     * @param {Number} offsetX - 事件对象与canvas的内填充边（padding edge）在 X 轴方向上的偏移量。\n     * @param {Number} offsetY - 事件对象与canvas的内填充边（padding edge）在 Y 轴方向上的偏移量。 \n     * @param {Number} event - 原生事件\n     */\n  }, {\n    key: "pressMoveHandler",\n    value: function pressMoveHandler(offsetX, offsetY, event) {\n      var _this11 = this;\n      if (this._preventPressSequeence) {\n        return;\n      }\n      if (this.checkScrollDragging()) {\n        return;\n      }\n      var _this$_target$status = this._target.status,\n        dragging = _this$_target$status.dragging,\n        processing = _this$_target$status.processing;\n      var _this$_target$meta = this._target.meta,\n        x = _this$_target$meta.x,\n        y = _this$_target$meta.y;\n      // this.canvas.style.cursor = \'default\';\n      if (!dragging) {\n        if (this.checkScrollBarHover(offsetX, offsetY)) {\n          return;\n        } else {\n          this.resetScrollBarHover();\n        }\n      }\n      if (!dragging && !processing) {\n        var _this$_targetLockOn2 = this._targetLockOn([offsetX, offsetY]),\n          _link = _this$_targetLockOn2.link,\n          _instance = _this$_targetLockOn2.instance;\n        var t = this._resolveLockOnTarget(_link, _instance);\n        if (t) {\n          /**\n          * instance mousemove 原生事件，仅在无拖拽时触发\n          *\n          * @event Node#instancemousemove\n          * @type {object}\n          * @property {Event} event           - 原始事件\n          * @property {Node} instance           - 原始事件\n          * @property {JFlow} jflow           - 当前JFlow对象 \n          */\n          // instance.dispatchEvent(new JFlowEvent(\'instancemousemove\', {\n          //     event,\n          //     instance,\n          //     jflow: this,\n          // }))\n          t.bubbleEvent(new events(\'instancemousemove\', {\n            event: event,\n            instance: t,\n            jflow: this,\n            bubbles: true\n          }));\n        } else {\n          this.dispatchEvent(new events(\'instancemousemove\', {\n            event: event,\n            instance: null,\n            jflow: this\n          }));\n        }\n        if (this.mode === JFLOW_MODE.LINKING) {\n          // if(instance) {\n          //     instance.bubbleEvent(new JFlowEvent(\'linking\', {\n          //         event,\n          //         target: instance,\n          //         jflow: this,\n          //         bubbles: true,\n          //         callback: (p) => {\n          //             this._currentp = p;\n          //         }\n          //     }))\n          // }\n\n          this._tempNode.anchor = this._currentp;\n          this.scheduleRender(function () {\n            _this11._target.isLinkDirty = false;\n            _this11._target.isInstanceDirty = false;\n            _this11._target.status.processing = false;\n          });\n          this._processPanInBorder();\n          // requestAnimationFrame((timestamp) => {\n          //     this.setAnimeClock(timestamp);\n          //     this._render();\n          //     this._target.isLinkDirty = false; \n          //     this._target.isInstanceDirty = false;\n          //     this._target.status.processing = false;\n          // })\n          return;\n        }\n      }\n\n      /**\n       * canvas mousemove 原生事件\n       *\n       * @event JFlow#canvasmousemove\n       * @type {object}\n       * @property {Event} event           - 原始事件\n       * @property {JFlow} jflow           - 当前JFlow对象 \n       */\n      this.dispatchEvent(new events(\'canvasmousemove\', {\n        event: event,\n        jflow: this\n      }));\n      if (!dragging) return;\n      // this.canvas.style.cursor = \'grabbing\';\n      if (processing) return;\n      var movingtarget = this._target.moving; // this._tempNode ? [this._tempNode] : this._target.moving;\n      this._target.status.movingState = true;\n      this._target.status.processing = true;\n      var deltaX = offsetX - x;\n      var deltaY = offsetY - y;\n      if (movingtarget) {\n        if (this._allowMovingTarget) {\n          movingtarget.forEach(function (t) {\n            t.anchor[0] += deltaX / _this11.scale;\n            t.anchor[1] += deltaY / _this11.scale;\n          });\n        }\n      } else {\n        this._recalculatePosition(deltaX, deltaY);\n        this.dispatchEvent(new events(\'zoompan\', {\n          deltaX: deltaX,\n          deltaY: deltaY\n        }));\n      }\n      var _this$_targetLockOn3 = this._targetLockOn([offsetX, offsetY]),\n        instance = _this$_targetLockOn3.instance,\n        link = _this$_targetLockOn3.link;\n      this._processDragOver(instance || link, event);\n      this.scheduleRender(function () {\n        _this11._target.isLinkDirty = false;\n        _this11._target.isInstanceDirty = false;\n        _this11._target.status.processing = false;\n      });\n      // requestAnimationFrame((timestamp) => {\n      //     this._render();\n      //     this._target.isLinkDirty = false; \n      //     this._target.isInstanceDirty = false;\n      //     this._target.status.processing = false;\n      // })\n    }\n    /**\n     * 按压结束处理函数\n     * @param {Boolean} isDocument - 是否为 document 触发\n     * @param {Number} event - 原生事件\n     */\n  }, {\n    key: "pressUpHanlder",\n    value: function pressUpHanlder(isDocument, event) {\n      if (this._preventPressSequeence) {\n        return;\n      }\n      if (this.__processOverAnime) {\n        this.__processOverAnime.cancel();\n      }\n      this._dragOverTarget = null;\n      this._cancelPanInBorder();\n      // this.resetScollBarStatus();\n      var meta = this._target.meta;\n      if (this.mode === JFLOW_MODE.LINKING) {\n        var t = this._target.instance;\n        var payload = this.consumeMessage();\n        // console.log(payload)\n        var _preventDefault = false;\n        var preventDefault = function preventDefault() {\n          _preventDefault = true;\n        };\n        if (t) {\n          /**\n           * canvas mousemove 原生事件\n           *\n           * @event Node#link\n           * @type {object}\n           * @property {Event} event           - 原始事件\n           * @property {Node} target           - 原始事件\n           * @property {object} payload        - 传入的消息\n           * @property {JFlow} jflow           - 当前JFlow对象       - 当前JFlow对象 \n           */\n          t.bubbleEvent(new events(\'link\', {\n            event: event,\n            target: t,\n            jflow: this,\n            payload: payload,\n            bubbles: true,\n            link: this._tempLink,\n            preventDefault: preventDefault\n          }));\n        } else {\n          var offsetX = event.offsetX,\n            offsetY = event.offsetY;\n          this.dispatchEvent(new events(\'link\', {\n            event: event,\n            jflow: this,\n            payload: payload,\n            anchor: this._calculatePointBack([offsetX, offsetY]),\n            link: this._tempLink,\n            preventDefault: preventDefault\n          }));\n        }\n        if (_preventDefault) {\n          return;\n        }\n        this._clearTarget();\n        if (!this._preventClearTemp) {\n          if (this._tempNode) {\n            this._tempNode.destroy();\n            this._tempNode = null;\n          }\n          if (this._tempLink) {\n            this._tempLink.destroy();\n            this._tempLink = null;\n          }\n        }\n        this._preventClearTemp = false;\n        this.mode = JFLOW_MODE.DEFAULT;\n        this._render();\n        return;\n      }\n      if (this._target.moving) {\n        var checkresult = false;\n        if (this._layout["static"]) {\n          checkresult = this.staticCheck(this._getMovingTarget());\n        }\n        if (!checkresult && this._target.link) {\n          var _this$_target$cache2 = this._target.cache,\n            point = _this$_target$cache2.point,\n            belongs = _this$_target$cache2.belongs;\n          var link = this._target.link;\n          var instance = this._getMovingTarget();\n          /**\n           * 拖动到线上事件\n           *\n           * @event BaseLink#drop\n           * @type {object}\n           * @property {Event} event           - 原始事件 \n           * @property {Object} instance     - 拖动的对象 \n           * @property {BaseLink} link         - 目标连线 \n           * @property {JFlow} jflow           - 当前JFlow对象 \n           * @property {Group|JFlow} belongs   - 连线所在的绘图栈的对象\n           */\n          link.dispatchEvent(new events(\'drop\', {\n            event: event,\n            instance: instance,\n            link: link,\n            jflow: this,\n            belongs: belongs\n          }));\n          this._target.link = null;\n          this._target.instance = null;\n        } else if (this._target.moving) {\n          if (this._target.instance) {\n            /**\n             * 拖动后放置到 Instance 上的事件，由被拖动到的对象触发\n             *\n             * @event Node#pressEnd\n             * @type {object}\n             * @property {Event} event           - 原始事件 \n             * @property {Node} instance         - 拖动的对象 \n             * @property {JFlow} jflow           - 当前JFlow对象 \n             * @property {Instance} target       - 拖动到的对象\n             * @property {boolean} bubbles       - 冒泡\n             */\n            //  console.log(\'pressEnd\', this._target.instance)\n            this._target.instance.bubbleEvent(new events(\'pressEnd\', {\n              event: event,\n              instance: this._getMovingTarget(),\n              jflow: this,\n              target: this._target.instance,\n              bubbles: true\n            }));\n          } else {\n            /**\n             * 拖动后放置到主图上的事件\n             *\n             * @event JFlow#pressEnd\n             * @type {object}\n             * @property {Event} event           - 原始事件 \n             * @property {Instance} instance       - 拖动的对象 \n             * @property {JFlow} jflow           - 当前JFlow对象 \n             */\n            this.dispatchEvent(new events(\'pressEnd\', {\n              event: event,\n              instance: this._getMovingTarget(),\n              jflow: this\n            }));\n          }\n        }\n        this._target.moving = null;\n        this.removeTempDraggingInstance();\n        // this._target.isMovingDirty = false;\n        this._render();\n      }\n      this._clearTarget();\n    }\n    /**\n    * 菜单弹出处理函数\n    * @param {Number} offsetX - 事件对象与canvas的内填充边（padding edge）在 X 轴方向上的偏移量。\n    * @param {Number} offsetY - 事件对象与canvas的内填充边（padding edge）在 Y 轴方向上的偏移量。 \n    * @param {Number} event - 原生事件\n    */\n  }, {\n    key: "clickHanlder",\n    value: function clickHanlder(offsetX, offsetY, event) {\n      var _this$_targetLockOn4 = this._targetLockOn([offsetX, offsetY], \'click\'),\n        link = _this$_targetLockOn4.link,\n        instance = _this$_targetLockOn4.instance,\n        meta = _this$_targetLockOn4.meta;\n      if (Math.abs(meta.initialX - meta.x) < 1 && Math.abs(meta.initialY - meta.y) < 1) {\n        if (event.target !== this.canvas) {\n          this._clearTarget();\n          Object.assign(this._target.meta, {\n            initialX: undefined,\n            initialY: undefined\n          });\n          return;\n        }\n        var topLayerPoint = this._target.cache.topLayerPoint;\n        var t = this._resolveLockOnTarget(link, instance);\n        if (t) {\n          var target = t;\n          /**\n           * 点击事件（冒泡）\n           *\n           * @event Instance#contextclick\n           * @type {object}\n           * @property {Event} event           - 原始事件 \n           * @property {Instance} target       - 右键对象 \n           * @property {JFlow} jflow           - 当前JFlow对象\n           * @property {number[]} topLayerPoint  - jflow坐标系上的位置\n           * @property {Boolean} bubbles       - 冒泡\n           */\n          target.bubbleEvent(new events(\'click\', {\n            event: event,\n            jflow: this,\n            target: target,\n            topLayerPoint: topLayerPoint,\n            bubbles: true\n          }));\n        } else {\n          /**\n           * 点击事件\n           *\n           * @event JFlow#contextclick\n           * @type {object}\n           * @property {Event} event           - 原始事件 \n           * @property {JFlow} jflow           - 当前JFlow对象\n           * @property {number[]} topLayerPoint  - jflow坐标系上的位置\n           */\n          this.dispatchEvent(new events(\'click\', {\n            event: event,\n            jflow: this,\n            topLayerPoint: topLayerPoint\n          }));\n        }\n        this._clearTarget();\n        Object.assign(this._target.meta, {\n          initialX: undefined,\n          initialY: undefined\n        });\n      }\n    }\n    /**\n     * 菜单弹出处理函数\n     * @param {Number} offsetX - 事件对象与canvas的内填充边（padding edge）在 X 轴方向上的偏移量。\n     * @param {Number} offsetY - 事件对象与canvas的内填充边（padding edge）在 Y 轴方向上的偏移量。 \n     * @param {Number} event - 原生事件\n     */\n  }, {\n    key: "contextMenuHanlder",\n    value: function contextMenuHanlder(offsetX, offsetY, event) {\n      var _this$_targetLockOn5 = this._targetLockOn([offsetX, offsetY], \'contextclick\'),\n        link = _this$_targetLockOn5.link,\n        instance = _this$_targetLockOn5.instance;\n      var topLayerPoint = this._target.cache.topLayerPoint;\n      var t = this._resolveLockOnTarget(link, instance);\n      if (t) {\n        var target = t;\n        /**\n         * 右键事件（冒泡）\n         *\n         * @event Instance#contextclick\n         * @type {object}\n         * @property {Event} event           - 原始事件 \n         * @property {Instance} target       - 右键对象 \n         * @property {JFlow} jflow           - 当前JFlow对象\n         * @property {number[]} topLayerPoint  - jflow坐标系上的位置\n         * @property {Boolean} bubbles       - 冒泡\n         */\n        target.bubbleEvent(new events(\'contextclick\', {\n          event: event,\n          jflow: this,\n          target: target,\n          topLayerPoint: topLayerPoint,\n          bubbles: true\n        }));\n      } else {\n        /**\n         * 右键事件\n         *\n         * @event JFlow#contextclick\n         * @type {object}\n         * @property {Event} event           - 原始事件 \n         * @property {JFlow} jflow           - 当前JFlow对象\n         * @property {number[]} topLayerPoint  - jflow坐标系上的位置\n         */\n        this.dispatchEvent(new events(\'contextclick\', {\n          event: event,\n          jflow: this,\n          topLayerPoint: topLayerPoint\n        }));\n      }\n    }\n  }, {\n    key: "dblclickHandler",\n    value: function dblclickHandler(offsetX, offsetY, event) {\n      var _this$_targetLockOn6 = this._targetLockOn([offsetX, offsetY], \'dblclick\'),\n        link = _this$_targetLockOn6.link,\n        instance = _this$_targetLockOn6.instance;\n      var topLayerPoint = this._target.cache.topLayerPoint;\n      var t = this._resolveLockOnTarget(link, instance);\n      if (t) {\n        var target = t;\n        /**\n         * 右键事件\n         *\n         * @event Instance#dblclick\n         * @type {object}\n         * @property {Event} event           - 原始事件 \n         * @property {Instance} target       - 右键对象 \n         * @property {JFlow} jflow           - 当前JFlow对象\n         * @property {number[]} topLayerPoint  - jflow坐标系上的位置\n         * @property {Boolean} bubbles       - 冒泡\n         */\n        target.bubbleEvent(new events(\'dblclick\', {\n          event: event,\n          jflow: this,\n          target: target,\n          topLayerPoint: topLayerPoint,\n          bubbles: true\n        }));\n      } else {\n        this.dispatchEvent(new events(\'dblclick\', {\n          event: event,\n          jflow: this,\n          topLayerPoint: topLayerPoint\n        }));\n      }\n    }\n\n    /*_onZoom(event) {\n        event.preventDefault();\n        let { offsetX, offsetY, deltaX, deltaY } = event\n        if(event.ctrlKey) { \n            deltaY = -deltaY;\n            this.zoomHandler(offsetX, offsetY, deltaX, deltaY);\n        } else {\n            this.panHandler(-deltaX, -deltaY);\n        }\n    }\n     _onPressStart(event) { \n        const { offsetX, offsetY, deltaY, button } = event\n        if(button !== 0) return;\n        this.pressStartHandler(offsetX, offsetY);\n    }\n     _onPressMove(event) {\n        const { offsetX, offsetY } = event\n        this.pressMoveHandler(offsetX, offsetY);\n    }\n     _onPressUp(event, isDocument) {\n        event.preventDefault();\n        event.stopPropagation();\n        const { button } = event\n        if(button !== 0) return;\n        this.pressUpHanlder(isDocument)\n    }\n     _onPressUpDocument(event) {\n        this._onPressUp(event, true);\n    }\n     _onContextMenu(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        const { offsetX, offsetY } = event;\n        this.contextMenuHanlder(offsetX, offsetY);\n    }*/\n  }, {\n    key: "_resolveLockOnTarget",\n    value: function _resolveLockOnTarget(link, instance) {\n      return link !== null && link !== void 0 && link.ON_TOP ? link : instance || link;\n    }\n  }, {\n    key: "_clearTarget",\n    value: function _clearTarget() {\n      Object.assign(this._target.meta, {\n        x: undefined,\n        y: undefined\n        // initialX: undefined,\n        // initialY: undefined, \n      });\n\n      Object.assign(this._target.status, {\n        dragging: false,\n        processing: false,\n        movingState: false\n      });\n      Object.assign(this._target, {\n        instance: null,\n        link: null,\n        moving: null\n      });\n    }\n  }, {\n    key: "_recalculatePosition",\n    value: function _recalculatePosition(deltaX, deltaY, scale) {\n      var _this$bounding_box4 = this.bounding_box,\n        x = _this$bounding_box4.x,\n        y = _this$bounding_box4.y,\n        width = _this$bounding_box4.width,\n        height = _this$bounding_box4.height;\n      var _this$canvasMeta2 = this.canvasMeta,\n        cw = _this$canvasMeta2.actual_width,\n        ch = _this$canvasMeta2.actual_height;\n      if (scale === undefined) {\n        scale = this.scale;\n      }\n      if (this.worldMargin) {\n        // console.log(scale)\n        var m = this.worldMargin;\n        var bx1 = (x + width + m) * scale - cw;\n        var bx2 = (x - m) * scale;\n        // console.log(bx1, bx2)\n        var sx = x * scale;\n        var px = this.position.x + deltaX;\n        var cx = px - sx;\n        this.position.offsetX = Math.min(Math.max(-bx1, cx), -bx2);\n        // console.log(this.position.offsetX)\n        // this.position.offsetX = Math.max(Math.min(-bx2, cx), -bx1);\n        this.position.x = this.position.offsetX + sx;\n        // console.log(this.position.x, deltaX)\n        // console.log(this.position.offsetX)\n\n        var by1 = (y + height + m) * scale - ch;\n        var by2 = (y - m) * scale;\n        // console.log(by1, by2)\n        var sy = y * scale;\n        var py = this.position.y + deltaY;\n        var cy = py - sy;\n        this.position.offsetY = Math.min(Math.max(-by1, cy), -by2);\n        // this.position.offsetY = Math.max(Math.min(-by2, cy), -by1);\n        this.position.y = this.position.offsetY + sy;\n      } else {\n        this.position.x += deltaX;\n        this.position.y += deltaY;\n        this.position.offsetX = this.position.x - x * scale;\n        this.position.offsetY = this.position.y - y * scale;\n      }\n    }\n  }, {\n    key: "calculateToRealWorld",\n    value: function calculateToRealWorld(p) {\n      var scale = this.scale;\n      var position = this.position;\n      return [p[0] * scale + position.offsetX, p[1] * scale + position.offsetY];\n    }\n  }, {\n    key: "_calculatePointBack",\n    value: function _calculatePointBack(p) {\n      var scale = this.scale;\n      var position = this.position;\n      return [(p[0] - position.offsetX) / scale, (p[1] - position.offsetY) / scale];\n    }\n  }, {\n    key: "_calculatePointBackWithPoint",\n    value: function _calculatePointBackWithPoint(a, b, arr, idx1, idx2) {\n      var scale = this.scale;\n      var position = this.position;\n      arr[idx1] = (a - position.offsetX) / scale;\n      arr[idx2] = (b - position.offsetY) / scale;\n    }\n  }, {\n    key: "_calculateDistance",\n    value: function _calculateDistance(l) {\n      return this.scale * l;\n    }\n  }, {\n    key: "_resetTransform",\n    value: function _resetTransform() {\n      var _this$canvasMeta3 = this.canvasMeta,\n        c_width = _this$canvasMeta3.width,\n        c_height = _this$canvasMeta3.height;\n      var position = this.position;\n      var scale = this.scale;\n      var ctx = this.ctx;\n      ctx.setTransform();\n      ctx.clearRect(0, 0, c_width, c_height);\n      ctx.scale(this.dpr, this.dpr);\n      ctx.transform(scale, 0, 0, scale, position.offsetX, position.offsetY);\n      // ctx._ctx.setTransform();\n      // ctx._ctx.clearRect(0, 0, c_width, c_height);\n      // ctx._ctx.scale(this.dpr, this.dpr);\n      // ctx.transform(scale, position.offsetX, position.offsetY);\n    }\n  }, {\n    key: "resetTransform",\n    value: function resetTransform(ctx) {\n      var position = this.position;\n      var scale = this.scale;\n      ctx.setTransform();\n      ctx.scale(this.dpr, this.dpr);\n      ctx.transform(scale, 0, 0, scale, position.offsetX, position.offsetY);\n    }\n  }, {\n    key: "_getViewBox",\n    value: function _getViewBox() {\n      // const cacheViewBox = [\n      //     ...this._calculatePointBack([0,0]),\n      //     ...this._calculatePointBack([this.canvasMeta.actual_width,this.canvasMeta.actual_height]),\n      // ];\n      var cacheViewBox = this._cacheViewBox;\n      this._calculatePointBackWithPoint(0, 0, cacheViewBox, 0, 1);\n      this._calculatePointBackWithPoint(this.canvasMeta.actual_width, this.canvasMeta.actual_height, cacheViewBox, 2, 3);\n      return cacheViewBox;\n    }\n  }, {\n    key: "setNodeToTopLayer",\n    value: function setNodeToTopLayer(node) {\n      var index = this._stack.findIndex(function (n) {\n        return n === node;\n      });\n      if (index !== -1) {\n        var _this$_stack$splice = this._stack.splice(index, 1),\n          _this$_stack$splice2 = flow_slicedToArray(_this$_stack$splice, 1),\n          renderNode = _this$_stack$splice2[0];\n        this._stack.push(renderNode);\n      }\n    }\n  }, {\n    key: "getCacheViewBox",\n    value: function getCacheViewBox() {\n      return this._cacheViewBox;\n    }\n  }, {\n    key: "_render",\n    value: function _render() {\n      this.scheduleRender();\n    }\n\n    /**\n    * 绘制画布\n    */\n  }, {\n    key: "__render",\n    value: function __render() {\n      if (!this._readyToRender) return;\n      // if(this.hasAnimeAndFrameRendered()) return;\n      this.runAnimeFrame();\n      this._resetTransform();\n      var ctx = this.ctx;\n      this.dispatchEvent(new events(\'beforeJflowRender\', {\n        ctx: ctx\n      }));\n      var br = this._getViewBox();\n      if (this.NodeRenderTop) {\n        this._linkStack.render(ctx, function (link) {\n          return !link.ON_TOP && link.isInViewBox(br);\n        });\n        this._stack.render(ctx, function (instance) {\n          var result = doOverlap(br, instance.getBoundingRect());\n          instance._isInViewBox = result;\n          return result;\n        });\n        this._linkStack.render(ctx, function (link) {\n          return link.ON_TOP && link.isInViewBox(br);\n        });\n      } else {\n        this._stack.render(ctx, function (instance) {\n          var result = doOverlap(br, instance.getBoundingRect());\n          // console.log(instance._layoutNode.type, result)\n          instance._isInViewBox = result;\n          return result;\n        });\n        this._linkStack.render(ctx, function (link) {\n          return link.isInViewBox(br);\n        });\n      }\n      // ctx.save();\n      // for(let i =0;i<2000;i++) {\n      //     ctx.beginPath();\n      //     ctx.fillStyle = `rgb(${parseInt(Math.random()*255)},${parseInt(Math.random()*255)},${parseInt(Math.random()*255)})`\n      //     ctx.fillRect(\n      //         Math.random()*250, \n      //         Math.random()*240, \n      //         Math.random()*200, \n      //         Math.random()*300)\n      // }\n\n      // ctx.restore();\n\n      if (this._tempNode) {\n        ctx.save();\n        this._tempNode.render(ctx);\n        ctx.restore();\n      }\n      if (this._tempLink) {\n        ctx.save();\n        this._tempLink.isInViewBox(br);\n        this._tempLink.render(ctx);\n        ctx.restore();\n      }\n      this.dispatchEvent(new events(\'afterJflowRender\', {\n        ctx: ctx\n      }));\n      this.renderScrollBar(ctx);\n      // this.setFrameRendered();\n    }\n  }]);\n  return JFlow;\n}( /*#__PURE__*/flow_wrapNativeSuper(EventTarget));\nObject.assign(JFlow.prototype, messageMixin);\nObject.assign(JFlow.prototype, stackMixin);\nObject.assign(JFlow.prototype, layoutMixin);\nObject.assign(JFlow.prototype, {\n  recalculateUp: function recalculateUp() {\n    if (this.__mounted__) {\n      this.reflow();\n    }\n  }\n});\nObject.assign(JFlow.prototype, NodeWeakMapMixin);\nObject.assign(JFlow.prototype, animeMixin);\nObject.assign(JFlow.prototype, minimap_mixin);\nObject.assign(JFlow.prototype, schedule);\nObject.assign(JFlow.prototype, scrollbarMixin);\n/* harmony default export */ const flow = (JFlow);\n\n\n\n\n\n\n\n\n// export { default as Group } from \'../instance/shapes/rectangle-group\';\n\n\n// export { default as CapsuleGroup } from \'../instance/shapes/capsule-group\';\n// export { default as CapsuleVerticalGroup } from \'../instance/shapes/capsule-vertical-group\';\n\n// export { default as DiamondGroup } from \'../instance/shapes/diamond-group\';\n// export { default as DiamondVerticalGroup } from \'../instance/shapes/diamond-vertical-group\';\n\n// export { default as RhombusGroup } from \'../instance/shapes/rhombus-group\';\n\n\n\n\n\n\n\n\n// export { default as TreeLayout } from \'../ler-layouta;yout/tree-layout\';\n// export { default as Lowcodelayout } from \'../layout/low-code-layout\';\n// export { default as ERLayout } from \'../layout/er-layout/er-layout\';\n// export { default as Orange } from \'../instance/nodeWrapper/orange/orange\'\n// export { default as TextEditor } from \'../instance/text-editor\';\n// export { default as TextGroup} from \'../instance/text-group\';\n\n\n// export { JFlowPath2D } from \'../utils/path-2d\';\n\n\n\n;// CONCATENATED MODULE: ./src/index.js\n\n\n/* harmony default export */ const src = (flow);\n\n// export { default as JFlowVuePlugin, JFlowLinkGroup } from \'./vue-plugin/JFlowPlugin.js\';\nflow.$jflow_version = package_namespaceObject.i8;\n// console.log(`jflow version@${packageJson.version}`)//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGFBQWE7QUFDYixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsV0FBVyxxREFBcUQ7QUFDaEUsV0FBVyxxREFBcUQ7QUFDaEU7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHFCQUFxQixNQUFNLFlBQVksUUFBUTs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FB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LENBQUMsR0FBRyxDQUFDLEdBQUNDLENBQUMsR0FBQ0EsQ0FBQyxHQUFDNUMsQ0FBQyxHQUFDMkMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBQ0MsQ0FBQyxHQUFDNUMsQ0FBQyxHQUFDQSxDQUFDLEdBQUMyQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUczQyxDQUFDLEdBQUNBLENBQUMsR0FBQ0EsQ0FBQyxHQUFDMkMsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUMvRCxJQUFNRSxDQUFDLEdBQUdELENBQUMsR0FBQ0EsQ0FBQyxJQUFFRCxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUNBLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBQzNDLENBQUMsR0FBQzRDLENBQUMsSUFBRUQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFDQSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRzNDLENBQUMsR0FBQ0EsQ0FBQyxJQUFFMkMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFDQSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDL0QsSUFBTWhELENBQUMsR0FBR2lELENBQUMsR0FBQ0EsQ0FBQyxJQUFFRCxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUNBLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBQzNDLENBQUMsR0FBQzRDLENBQUMsSUFBRUQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFDQSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRzNDLENBQUMsR0FBQ0EsQ0FBQyxJQUFFMkMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFDQSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDL0QsSUFBSUcsS0FBSyxHQUFHakgsSUFBSSxDQUFDa0gsS0FBSyxDQUFDcEQsQ0FBQyxFQUFFa0QsQ0FBQyxDQUFDO0VBQzVCO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsT0FBTyxDQUFDOUQsQ0FBQyxFQUFFQyxDQUFDLEVBQUU4RCxLQUFLLENBQUM7QUFDeEI7O0FBRUE7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YXMuanM/Y2ZhMSIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vbm9kZV9tb2R1bGVzL2Jlemllci1qcy9zcmMvdXRpbHMuanM/MDBmYSIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vbm9kZV9tb2R1bGVzL2Jlemllci1qcy9zcmMvcG9seS1iZXppZXIuanM/ZDgxOCIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vbm9kZV9tb2R1bGVzL2Jlemllci1qcy9zcmMvYmV6aWVyLmpzPzM1ZDEiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL3V0aWxzL2NvbnN0YW5jZS5qcz9lMjdkIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS91dGlscy9mdW5jdGlvbnMuanM/Y2U1ZiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvaW5zdGFuY2UuanM/YWQ2MCIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvZGlydHktd29yay9kaXJ0eS13b3JrLmpzPzQxMDYiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL25vZGUuanM/MmJhOSIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvZ2hvc3ROb2RlLmpzPzcwNjAiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL25vZGVXZWFrTWFwLmpzPzQ0YjEiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3N0YWNrLmpzP2I0YjUiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3N0YWNrTWl4aW4uanM/ODAxNiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvbGF5b3V0TWl4aW4uanM/N2ZkNyIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvbWVzc2FnZU1peGluLmpzP2Q2YmMiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2FuaW1lL2FuaW1lTWl4aW4uanM/NzA1YyIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvbWluaU1hcC9taW5pbWFwLW1peGluLmpzPzBlZTYiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2V2ZW50cy9pbmRleC5qcz9mM2NmIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9zY3JvbGxiYXIvc2Nyb2xsYmFyTWl4aW4uanM/ZDQ1ZSIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvZmxvdy9zY2hlZHVsZS5qcz9lNzFmIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9ldmVudHMvYWRhcHRlci5qcz82YjQzIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS9ncm91cEZhY3RvcnkuanM/MTdkNiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2Uvc2hhcGVzL3BvaW50LmpzPzE3MTYiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3NoYXBlcy9yZWN0YW5nbGUuanM/YWM1ZSIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2Uvc2hhcGVzL2NhcHN1bGUuanM/Y2Q3MCIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2Uvc2hhcGVzL2NhcHN1bGUtdmVydGljYWwuanM/M2EyMCIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2Uvc2hhcGVzL3Job21idXMuanM/Yzg0YiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2Uvc2hhcGVzL2RpYW1vbmQuanM/YzU1ZiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2Uvc2hhcGVzL2RpYW1vbmQtdmVydGljYWwuanM/MzNlZiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvZ3JvdXBzL3Njcm9sbC1ncm91cC5qcz8zNGJlIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9ldmVudHMvY29tbW9uQWRhcHRlci5qcz9mODUxIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS9iYXNlLWxpbmsuanM/OGY4MiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2Uvc2hhcGVzL3NoYWRvdy1jYWNoZS5qcz8yNzhmIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS9lbGVtZW50cy90ZXh0LmpzPzdjODIiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL2ltYWdlLmpzPzc4YjYiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3NoYWRvd0RvbS5qcz9hZmE5Iiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS9saW5rLmpzPzMxZDMiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3BvbHktbGluay5qcz9mMWQzIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS9iZXppZXItbGluay5qcz9kOGVmIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9sYXlvdXQvbGluZWFyLWxheW91dC5qcz85YzhhIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS90ZXh0LWdyb3VwL2Jhc2UvY29uc3RhbnRzLmpzP2ZjYjkiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3RleHQtZ3JvdXAvYmFzZS9zaGFkb3ctaW5wdXQuanM/ODAwNiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvdGV4dC1ncm91cC9iYXNlL2NhcmV0LmpzPzFjOWMiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3RleHQtZ3JvdXAvdXRpbHMuanM/MWI1NiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvdGV4dC1ncm91cC9zdG9yYWdlL2luZGV4LmpzPzRhNGIiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3RleHQtZ3JvdXAvYmFzZS9yYW5nZS5qcz9kZDFhIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS90ZXh0LWdyb3VwL3VuZG9yZWRvLmpzP2YzZGQiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3RleHQtZ3JvdXAvY29tbWFuZC9iYXNlLmpzP2JiYmIiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3RleHQtZ3JvdXAvY29tbWFuZC9tb3ZlbWVudC5qcz81YTZmIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS90ZXh0LWdyb3VwL2NvbW1hbmQvaW5wdXQuanM/ZmExMSIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvdGV4dC1ncm91cC9jb21tYW5kL21vdXNlLmpzPzg3OGIiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL3RleHQtZ3JvdXAvY29tbWFuZC9zaGlmdC5qcz8zMTA2Iiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS90ZXh0LWdyb3VwL2NvbW1hbmQvY3RybC5qcz8yMDZiIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS90ZXh0LWdyb3VwL2NvbW1hbmQvdW5kb3JlZG8uanM/OWU5MiIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvdGV4dC1ncm91cC9jb21tYW5kL2NsaXBib2FyZC5qcz85ZTZiIiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvY29yZS9pbnN0YW5jZS90ZXh0LWdyb3VwL2NvbW1hbmQvaW5kZXguanM/NzgwZSIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvaW5zdGFuY2UvdGV4dC1ncm91cC90ZXh0LWdyb3VwLmpzPzRmYzEiLCJ3ZWJwYWNrOi8vQGpvc2tpaS9qZmxvdy8uL3NyYy9jb3JlL2luc3RhbmNlL25vZGUtcGxhY2Vob2xkZXIuanM/ODgyYSIsIndlYnBhY2s6Ly9Aam9za2lpL2pmbG93Ly4vc3JjL2NvcmUvZmxvdy9pbmRleC5qcz85MzA3Iiwid2VicGFjazovL0Bqb3NraWkvamZsb3cvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ2FudmFzTWV0YVxuICogQHByb3BlcnR5IHtFbGVtZW50fSBjYW52YXMgLSBjYW52YXMg5YWD57SgXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggLSDnlLvluIPlrr3luqZcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSDnlLvluIPpq5jluqZcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByYXdfd2lkdGggLSDnlLvluIPlhYPntKDlrr3luqZcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByYXdfaGVpZ2h0IC0g55S75biD5YWD57Sg6auY5bqmXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGVmdCAtIOeUu+W4g+i3neemu+W3puerr+i3neemu1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHRvcCAtIOeUu+W4g+i3neemu+mhtuerr+i3neemu1xuICogQHByb3BlcnR5IHtDb250ZXh0MmR9IGN0eCAtIENvbnRleHQyZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNjYWxlIC0g5b2T5YmN55qE5YOP57Sg6K6+5aSH5q+UXG4gKi9cbi8qKlxuICog5Yib5bu65LiA5LiqIGNhbnZhcyDlhYPntKBcbiAqIEBwYXJhbSAge0VsZW1lbnR9IHdyYXBwZXIgLSBkb23lhYPntKBcbiAqIEByZXR1cm4ge0NhbnZhc01ldGF9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDYW52YXMod3JhcHBlcikge1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgbGVmdCwgdG9wIH0gPSB3cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gICAgY2FudmFzLnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgY29uc3Qgc2NhbGUgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICBjYW52YXMud2lkdGggPSBNYXRoLmZsb29yKHdpZHRoICogc2NhbGUpO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBNYXRoLmZsb29yKGhlaWdodCAqIHNjYWxlKTtcblxuICAgIGlmKHdyYXBwZXIpIHtcbiAgICAgICAgd3JhcHBlci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgIHdyYXBwZXIuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgd3JhcHBlci5hcHBlbmQoY2FudmFzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2FudmFzLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICByYXdfd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgICAgcmF3X2hlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgICAgbGVmdCxcbiAgICAgICAgdG9wLFxuICAgICAgICBjdHgsXG4gICAgICAgIHNjYWxlLFxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc2l6ZUNhbnZhcyhjYW52YXMsIHdyYXBwZXIpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIGxlZnQsIHRvcCB9ID0gd3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgIGNvbnN0IHNjYWxlID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgY2FudmFzLndpZHRoID0gTWF0aC5mbG9vcih3aWR0aCAqIHNjYWxlKTtcbiAgICBjYW52YXMuaGVpZ2h0ID0gTWF0aC5mbG9vcihoZWlnaHQgKiBzY2FsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgcmF3X3dpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICAgIHJhd19oZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgfVxufVxuXG5jb25zdCBjYWhlQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5jYWhlQ2FudmFzLndpZHRoID0gMTtcbmNhaGVDYW52YXMuaGVpZ2h0ID0gMTtcbmNvbnN0IGNhaGVDYW52YXNjdHggPSBjYWhlQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5jb25zdCBzY2FsZSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuY2FoZUNhbnZhc2N0eC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuXG4vKipcbiAqIOWcqOemu+e6v2NhbnZhc+S4iue7mOWItuWFg+e0oFxuICogQHBhcmFtICB7cmVuZGVyfSByZW5kZXIgLSDnu5jlm77lh73mlbBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcXVlc3RDYWNoZUNhbnZhcyhyZW5kZXIpIHtcbiAgICBjYWhlQ2FudmFzY3R4LmNsZWFyUmVjdCgwLDAsNSw1KTtcbiAgICBjYWhlQ2FudmFzY3R4LnNhdmUoKTtcbiAgICByZW5kZXIoY2FoZUNhbnZhc2N0eCk7XG4gICAgY2FoZUNhbnZhc2N0eC5yZXN0b3JlKCk7XG4gICAgY2FoZUNhbnZhc2N0eC5jbGVhclJlY3QoMCwwLDUsNSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5PbkRldmljZVBpeGVsUmF0aW8oY2FsbGJhY2ssIGRlc3Ryb3lIYW5kbGVyKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gbWF0Y2hNZWRpYShcbiAgICAgICAgYChyZXNvbHV0aW9uOiAke3dpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfWRwcHgpYFxuICAgICk7XG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImRldmljZVBpeGVsUmF0aW8gY2hhbmdlZDogXCIgKyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgICBjYWxsYmFjayh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgICBsaXN0ZW5PbkRldmljZVBpeGVsUmF0aW8oY2FsbGJhY2ssIGRlc3Ryb3lIYW5kbGVyKTtcbiAgICB9XG4gICAgZGVzdHJveUhhbmRsZXIoKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygncmVtb3ZlIGRldmljZVBpeGVsUmF0aW8gZXZlbnQgaGFuZGxlcicpXG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIG9uQ2hhbmdlLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfSlcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBvbkNoYW5nZSwgeyBvbmNlOiB0cnVlIH0pO1xufSIsImltcG9ydCB7IEJlemllciB9IGZyb20gXCIuL2Jlemllci5qc1wiO1xuXG4vLyBtYXRoLWlubGluaW5nLlxuY29uc3QgeyBhYnMsIGNvcywgc2luLCBhY29zLCBhdGFuMiwgc3FydCwgcG93IH0gPSBNYXRoO1xuXG4vLyBjdWJlIHJvb3QgZnVuY3Rpb24geWllbGRpbmcgcmVhbCByb290c1xuZnVuY3Rpb24gY3J0KHYpIHtcbiAgcmV0dXJuIHYgPCAwID8gLXBvdygtdiwgMSAvIDMpIDogcG93KHYsIDEgLyAzKTtcbn1cblxuLy8gdHJpZyBjb25zdGFudHNcbmNvbnN0IHBpID0gTWF0aC5QSSxcbiAgdGF1ID0gMiAqIHBpLFxuICBxdWFydCA9IHBpIC8gMixcbiAgLy8gZmxvYXQgcHJlY2lzaW9uIHNpZ25pZmljYW50IGRlY2ltYWxcbiAgZXBzaWxvbiA9IDAuMDAwMDAxLFxuICAvLyBleHRyZW1hcyB1c2VkIGluIGJib3ggY2FsY3VsYXRpb24gYW5kIHNpbWlsYXIgYWxnb3JpdGhtc1xuICBuTWF4ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MSxcbiAgbk1pbiA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSIHx8IC05MDA3MTk5MjU0NzQwOTkxLFxuICAvLyBhIHplcm8gY29vcmRpbmF0ZSwgd2hpY2ggaXMgc3VycHJpc2luZ2x5IHVzZWZ1bFxuICBaRVJPID0geyB4OiAwLCB5OiAwLCB6OiAwIH07XG5cbi8vIEJlemllciB1dGlsaXR5IGZ1bmN0aW9uc1xuY29uc3QgdXRpbHMgPSB7XG4gIC8vIExlZ2VuZHJlLUdhdXNzIGFic2Npc3NhZSB3aXRoIG49MjQgKHhfaSB2YWx1ZXMsIGRlZmluZWQgYXQgaT1uIGFzIHRoZSByb290cyBvZiB0aGUgbnRoIG9yZGVyIExlZ2VuZHJlIHBvbHlub21pYWwgUG4oeCkpXG4gIFR2YWx1ZXM6IFtcbiAgICAtMC4wNjQwNTY4OTI4NjI2MDU2MjYwODUwNDMwODI2MjQ3NDUwMzg1OTA5LFxuICAgIDAuMDY0MDU2ODkyODYyNjA1NjI2MDg1MDQzMDgyNjI0NzQ1MDM4NTkwOSxcbiAgICAtMC4xOTExMTg4Njc0NzM2MTYzMDkxNTg2Mzk4MjA3NTcwNjk2MzE4NDA0LFxuICAgIDAuMTkxMTE4ODY3NDczNjE2MzA5MTU4NjM5ODIwNzU3MDY5NjMxODQwNCxcbiAgICAtMC4zMTUwNDI2Nzk2OTYxNjMzNzQzODY3OTMyOTEzMTk4MTAyNDA3ODY0LFxuICAgIDAuMzE1MDQyNjc5Njk2MTYzMzc0Mzg2NzkzMjkxMzE5ODEwMjQwNzg2NCxcbiAgICAtMC40MzM3OTM1MDc2MjYwNDUxMzg0ODcwODQyMzE5MTMzNDk3MTI0NTI0LFxuICAgIDAuNDMzNzkzNTA3NjI2MDQ1MTM4NDg3MDg0MjMxOTEzMzQ5NzEyNDUyNCxcbiAgICAtMC41NDU0MjE0NzEzODg4Mzk1MzU2NTgzNzU2MTcyMTgzNzIzNzAwMTA3LFxuICAgIDAuNTQ1NDIxNDcxMzg4ODM5NTM1NjU4Mzc1NjE3MjE4MzcyMzcwMDEwNyxcbiAgICAtMC42NDgwOTM2NTE5MzY5NzU1NjkyNTI0OTU3ODY5MTA3NDc2MjY2Njk2LFxuICAgIDAuNjQ4MDkzNjUxOTM2OTc1NTY5MjUyNDk1Nzg2OTEwNzQ3NjI2NjY5NixcbiAgICAtMC43NDAxMjQxOTE1Nzg1NTQzNjQyNDM4MjgxMDMwOTk5Nzg0MjU1MjMyLFxuICAgIDAuNzQwMTI0MTkxNTc4NTU0MzY0MjQzODI4MTAzMDk5OTc4NDI1NTIzMixcbiAgICAtMC44MjAwMDE5ODU5NzM5MDI5MjE5NTM5NDk4NzI2Njk3NDUyMDgwNzYxLFxuICAgIDAuODIwMDAxOTg1OTczOTAyOTIxOTUzOTQ5ODcyNjY5NzQ1MjA4MDc2MSxcbiAgICAtMC44ODY0MTU1MjcwMDQ0MDEwMzQyMTMxNTQzNDE5ODIxOTY3NTUwODczLFxuICAgIDAuODg2NDE1NTI3MDA0NDAxMDM0MjEzMTU0MzQxOTgyMTk2NzU1MDg3MyxcbiAgICAtMC45MzgyNzQ1NTIwMDI3MzI3NTg1MjM2NDkwMDE3MDg3MjE0NDk2NTQ4LFxuICAgIDAuOTM4Mjc0NTUyMDAyNzMyNzU4NTIzNjQ5MDAxNzA4NzIxNDQ5NjU0OCxcbiAgICAtMC45NzQ3Mjg1NTU5NzEzMDk0OTgxOTgzOTE5OTMwMDgxNjkwNjE3NDExLFxuICAgIDAuOTc0NzI4NTU1OTcxMzA5NDk4MTk4MzkxOTkzMDA4MTY5MDYxNzQxMSxcbiAgICAtMC45OTUxODcyMTk5OTcwMjEzNjAxNzk5OTc0MDk3MDA3MzY4MTE4NzQ1LFxuICAgIDAuOTk1MTg3MjE5OTk3MDIxMzYwMTc5OTk3NDA5NzAwNzM2ODExODc0NSxcbiAgXSxcblxuICAvLyBMZWdlbmRyZS1HYXVzcyB3ZWlnaHRzIHdpdGggbj0yNCAod19pIHZhbHVlcywgZGVmaW5lZCBieSBhIGZ1bmN0aW9uIGxpbmtlZCB0byBpbiB0aGUgQmV6aWVyIHByaW1lciBhcnRpY2xlKVxuICBDdmFsdWVzOiBbXG4gICAgMC4xMjc5MzgxOTUzNDY3NTIxNTY5NzQwNTYxNjUyMjQ2OTUzNzE4NTE3LFxuICAgIDAuMTI3OTM4MTk1MzQ2NzUyMTU2OTc0MDU2MTY1MjI0Njk1MzcxODUxNyxcbiAgICAwLjEyNTgzNzQ1NjM0NjgyODI5NjEyMTM3NTM4MjUxMTE4MzY4ODcyNjQsXG4gICAgMC4xMjU4Mzc0NTYzNDY4MjgyOTYxMjEzNzUzODI1MTExODM2ODg3MjY0LFxuICAgIDAuMTIxNjcwNDcyOTI3ODAzMzkxMjA0NDYzMTUzNDc2MjYyNDI1NjA3LFxuICAgIDAuMTIxNjcwNDcyOTI3ODAzMzkxMjA0NDYzMTUzNDc2MjYyNDI1NjA3LFxuICAgIDAuMTE1NTA1NjY4MDUzNzI1NjAxMzUzMzQ0NDgzOTA2NzgzNTU5ODYyMixcbiAgICAwLjExNTUwNTY2ODA1MzcyNTYwMTM1MzM0NDQ4MzkwNjc4MzU1OTg2MjIsXG4gICAgMC4xMDc0NDQyNzAxMTU5NjU2MzQ3ODI1NzczNDI0NDY2MDYyMjI3OTQ2LFxuICAgIDAuMTA3NDQ0MjcwMTE1OTY1NjM0NzgyNTc3MzQyNDQ2NjA2MjIyNzk0NixcbiAgICAwLjA5NzYxODY1MjEwNDExMzg4ODI2OTg4MDY2NDQ2NDI0NzE1NDQyNzksXG4gICAgMC4wOTc2MTg2NTIxMDQxMTM4ODgyNjk4ODA2NjQ0NjQyNDcxNTQ0Mjc5LFxuICAgIDAuMDg2MTkwMTYxNTMxOTUzMjc1OTE3MTg1MjAyOTgzNzQyNjY3MTg1LFxuICAgIDAuMDg2MTkwMTYxNTMxOTUzMjc1OTE3MTg1MjAyOTgzNzQyNjY3MTg1LFxuICAgIDAuMDczMzQ2NDgxNDExMDgwMzA1NzM0MDMzNjE1MjUzMTE2NTE4MTE5MyxcbiAgICAwLjA3MzM0NjQ4MTQxMTA4MDMwNTczNDAzMzYxNTI1MzExNjUxODExOTMsXG4gICAgMC4wNTkyOTg1ODQ5MTU0MzY3ODA3NDYzNjc3NTg1MDAxMDg1ODQ1NDEyLFxuICAgIDAuMDU5Mjk4NTg0OTE1NDM2NzgwNzQ2MzY3NzU4NTAwMTA4NTg0NTQxMixcbiAgICAwLjA0NDI3NzQzODgxNzQxOTgwNjE2ODYwMjc0ODIxMTMzODIyODg1OTMsXG4gICAgMC4wNDQyNzc0Mzg4MTc0MTk4MDYxNjg2MDI3NDgyMTEzMzgyMjg4NTkzLFxuICAgIDAuMDI4NTMxMzg4NjI4OTMzNjYzMTgxMzA3ODE1OTUxODc4Mjg2NDQ5MSxcbiAgICAwLjAyODUzMTM4ODYyODkzMzY2MzE4MTMwNzgxNTk1MTg3ODI4NjQ0OTEsXG4gICAgMC4wMTIzNDEyMjk3OTk5ODcxOTk1NDY4MDU2NjcwNzAwMzcyOTE1NzU5LFxuICAgIDAuMDEyMzQxMjI5Nzk5OTg3MTk5NTQ2ODA1NjY3MDcwMDM3MjkxNTc1OSxcbiAgXSxcblxuICBhcmNmbjogZnVuY3Rpb24gKHQsIGRlcml2YXRpdmVGbikge1xuICAgIGNvbnN0IGQgPSBkZXJpdmF0aXZlRm4odCk7XG4gICAgbGV0IGwgPSBkLnggKiBkLnggKyBkLnkgKiBkLnk7XG4gICAgaWYgKHR5cGVvZiBkLnogIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGwgKz0gZC56ICogZC56O1xuICAgIH1cbiAgICByZXR1cm4gc3FydChsKTtcbiAgfSxcblxuICBjb21wdXRlOiBmdW5jdGlvbiAodCwgcG9pbnRzLCBfM2QpIHtcbiAgICAvLyBzaG9ydGN1dHNcbiAgICBpZiAodCA9PT0gMCkge1xuICAgICAgcG9pbnRzWzBdLnQgPSAwO1xuICAgICAgcmV0dXJuIHBvaW50c1swXTtcbiAgICB9XG5cbiAgICBjb25zdCBvcmRlciA9IHBvaW50cy5sZW5ndGggLSAxO1xuXG4gICAgaWYgKHQgPT09IDEpIHtcbiAgICAgIHBvaW50c1tvcmRlcl0udCA9IDE7XG4gICAgICByZXR1cm4gcG9pbnRzW29yZGVyXTtcbiAgICB9XG5cbiAgICBjb25zdCBtdCA9IDEgLSB0O1xuICAgIGxldCBwID0gcG9pbnRzO1xuXG4gICAgLy8gY29uc3RhbnQ/XG4gICAgaWYgKG9yZGVyID09PSAwKSB7XG4gICAgICBwb2ludHNbMF0udCA9IHQ7XG4gICAgICByZXR1cm4gcG9pbnRzWzBdO1xuICAgIH1cblxuICAgIC8vIGxpbmVhcj9cbiAgICBpZiAob3JkZXIgPT09IDEpIHtcbiAgICAgIGNvbnN0IHJldCA9IHtcbiAgICAgICAgeDogbXQgKiBwWzBdLnggKyB0ICogcFsxXS54LFxuICAgICAgICB5OiBtdCAqIHBbMF0ueSArIHQgKiBwWzFdLnksXG4gICAgICAgIHQ6IHQsXG4gICAgICB9O1xuICAgICAgaWYgKF8zZCkge1xuICAgICAgICByZXQueiA9IG10ICogcFswXS56ICsgdCAqIHBbMV0uejtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLy8gcXVhZHJhdGljL2N1YmljIGN1cnZlP1xuICAgIGlmIChvcmRlciA8IDQpIHtcbiAgICAgIGxldCBtdDIgPSBtdCAqIG10LFxuICAgICAgICB0MiA9IHQgKiB0LFxuICAgICAgICBhLFxuICAgICAgICBiLFxuICAgICAgICBjLFxuICAgICAgICBkID0gMDtcbiAgICAgIGlmIChvcmRlciA9PT0gMikge1xuICAgICAgICBwID0gW3BbMF0sIHBbMV0sIHBbMl0sIFpFUk9dO1xuICAgICAgICBhID0gbXQyO1xuICAgICAgICBiID0gbXQgKiB0ICogMjtcbiAgICAgICAgYyA9IHQyO1xuICAgICAgfSBlbHNlIGlmIChvcmRlciA9PT0gMykge1xuICAgICAgICBhID0gbXQyICogbXQ7XG4gICAgICAgIGIgPSBtdDIgKiB0ICogMztcbiAgICAgICAgYyA9IG10ICogdDIgKiAzO1xuICAgICAgICBkID0gdCAqIHQyO1xuICAgICAgfVxuICAgICAgY29uc3QgcmV0ID0ge1xuICAgICAgICB4OiBhICogcFswXS54ICsgYiAqIHBbMV0ueCArIGMgKiBwWzJdLnggKyBkICogcFszXS54LFxuICAgICAgICB5OiBhICogcFswXS55ICsgYiAqIHBbMV0ueSArIGMgKiBwWzJdLnkgKyBkICogcFszXS55LFxuICAgICAgICB0OiB0LFxuICAgICAgfTtcbiAgICAgIGlmIChfM2QpIHtcbiAgICAgICAgcmV0LnogPSBhICogcFswXS56ICsgYiAqIHBbMV0ueiArIGMgKiBwWzJdLnogKyBkICogcFszXS56O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvLyBoaWdoZXIgb3JkZXIgY3VydmVzOiB1c2UgZGUgQ2FzdGVsamF1J3MgY29tcHV0YXRpb25cbiAgICBjb25zdCBkQ3B0cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocG9pbnRzKSk7XG4gICAgd2hpbGUgKGRDcHRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZENwdHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGRDcHRzW2ldID0ge1xuICAgICAgICAgIHg6IGRDcHRzW2ldLnggKyAoZENwdHNbaSArIDFdLnggLSBkQ3B0c1tpXS54KSAqIHQsXG4gICAgICAgICAgeTogZENwdHNbaV0ueSArIChkQ3B0c1tpICsgMV0ueSAtIGRDcHRzW2ldLnkpICogdCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBkQ3B0c1tpXS56ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgZENwdHNbaV0gPSBkQ3B0c1tpXS56ICsgKGRDcHRzW2kgKyAxXS56IC0gZENwdHNbaV0ueikgKiB0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkQ3B0cy5zcGxpY2UoZENwdHMubGVuZ3RoIC0gMSwgMSk7XG4gICAgfVxuICAgIGRDcHRzWzBdLnQgPSB0O1xuICAgIHJldHVybiBkQ3B0c1swXTtcbiAgfSxcblxuICBjb21wdXRlV2l0aFJhdGlvczogZnVuY3Rpb24gKHQsIHBvaW50cywgcmF0aW9zLCBfM2QpIHtcbiAgICBjb25zdCBtdCA9IDEgLSB0LFxuICAgICAgciA9IHJhdGlvcyxcbiAgICAgIHAgPSBwb2ludHM7XG5cbiAgICBsZXQgZjEgPSByWzBdLFxuICAgICAgZjIgPSByWzFdLFxuICAgICAgZjMgPSByWzJdLFxuICAgICAgZjQgPSByWzNdLFxuICAgICAgZDtcblxuICAgIC8vIHNwZWMgZm9yIGxpbmVhclxuICAgIGYxICo9IG10O1xuICAgIGYyICo9IHQ7XG5cbiAgICBpZiAocC5sZW5ndGggPT09IDIpIHtcbiAgICAgIGQgPSBmMSArIGYyO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogKGYxICogcFswXS54ICsgZjIgKiBwWzFdLngpIC8gZCxcbiAgICAgICAgeTogKGYxICogcFswXS55ICsgZjIgKiBwWzFdLnkpIC8gZCxcbiAgICAgICAgejogIV8zZCA/IGZhbHNlIDogKGYxICogcFswXS56ICsgZjIgKiBwWzFdLnopIC8gZCxcbiAgICAgICAgdDogdCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gdXBncmFkZSB0byBxdWFkcmF0aWNcbiAgICBmMSAqPSBtdDtcbiAgICBmMiAqPSAyICogbXQ7XG4gICAgZjMgKj0gdCAqIHQ7XG5cbiAgICBpZiAocC5sZW5ndGggPT09IDMpIHtcbiAgICAgIGQgPSBmMSArIGYyICsgZjM7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAoZjEgKiBwWzBdLnggKyBmMiAqIHBbMV0ueCArIGYzICogcFsyXS54KSAvIGQsXG4gICAgICAgIHk6IChmMSAqIHBbMF0ueSArIGYyICogcFsxXS55ICsgZjMgKiBwWzJdLnkpIC8gZCxcbiAgICAgICAgejogIV8zZCA/IGZhbHNlIDogKGYxICogcFswXS56ICsgZjIgKiBwWzFdLnogKyBmMyAqIHBbMl0ueikgLyBkLFxuICAgICAgICB0OiB0LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB1cGdyYWRlIHRvIGN1YmljXG4gICAgZjEgKj0gbXQ7XG4gICAgZjIgKj0gMS41ICogbXQ7XG4gICAgZjMgKj0gMyAqIG10O1xuICAgIGY0ICo9IHQgKiB0ICogdDtcblxuICAgIGlmIChwLmxlbmd0aCA9PT0gNCkge1xuICAgICAgZCA9IGYxICsgZjIgKyBmMyArIGY0O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogKGYxICogcFswXS54ICsgZjIgKiBwWzFdLnggKyBmMyAqIHBbMl0ueCArIGY0ICogcFszXS54KSAvIGQsXG4gICAgICAgIHk6IChmMSAqIHBbMF0ueSArIGYyICogcFsxXS55ICsgZjMgKiBwWzJdLnkgKyBmNCAqIHBbM10ueSkgLyBkLFxuICAgICAgICB6OiAhXzNkXG4gICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgIDogKGYxICogcFswXS56ICsgZjIgKiBwWzFdLnogKyBmMyAqIHBbMl0ueiArIGY0ICogcFszXS56KSAvIGQsXG4gICAgICAgIHQ6IHQsXG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICBkZXJpdmU6IGZ1bmN0aW9uIChwb2ludHMsIF8zZCkge1xuICAgIGNvbnN0IGRwb2ludHMgPSBbXTtcbiAgICBmb3IgKGxldCBwID0gcG9pbnRzLCBkID0gcC5sZW5ndGgsIGMgPSBkIC0gMTsgZCA+IDE7IGQtLSwgYy0tKSB7XG4gICAgICBjb25zdCBsaXN0ID0gW107XG4gICAgICBmb3IgKGxldCBqID0gMCwgZHB0OyBqIDwgYzsgaisrKSB7XG4gICAgICAgIGRwdCA9IHtcbiAgICAgICAgICB4OiBjICogKHBbaiArIDFdLnggLSBwW2pdLngpLFxuICAgICAgICAgIHk6IGMgKiAocFtqICsgMV0ueSAtIHBbal0ueSksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChfM2QpIHtcbiAgICAgICAgICBkcHQueiA9IGMgKiAocFtqICsgMV0ueiAtIHBbal0ueik7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdC5wdXNoKGRwdCk7XG4gICAgICB9XG4gICAgICBkcG9pbnRzLnB1c2gobGlzdCk7XG4gICAgICBwID0gbGlzdDtcbiAgICB9XG4gICAgcmV0dXJuIGRwb2ludHM7XG4gIH0sXG5cbiAgYmV0d2VlbjogZnVuY3Rpb24gKHYsIG0sIE0pIHtcbiAgICByZXR1cm4gKFxuICAgICAgKG0gPD0gdiAmJiB2IDw9IE0pIHx8XG4gICAgICB1dGlscy5hcHByb3hpbWF0ZWx5KHYsIG0pIHx8XG4gICAgICB1dGlscy5hcHByb3hpbWF0ZWx5KHYsIE0pXG4gICAgKTtcbiAgfSxcblxuICBhcHByb3hpbWF0ZWx5OiBmdW5jdGlvbiAoYSwgYiwgcHJlY2lzaW9uKSB7XG4gICAgcmV0dXJuIGFicyhhIC0gYikgPD0gKHByZWNpc2lvbiB8fCBlcHNpbG9uKTtcbiAgfSxcblxuICBsZW5ndGg6IGZ1bmN0aW9uIChkZXJpdmF0aXZlRm4pIHtcbiAgICBjb25zdCB6ID0gMC41LFxuICAgICAgbGVuID0gdXRpbHMuVHZhbHVlcy5sZW5ndGg7XG5cbiAgICBsZXQgc3VtID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwLCB0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHQgPSB6ICogdXRpbHMuVHZhbHVlc1tpXSArIHo7XG4gICAgICBzdW0gKz0gdXRpbHMuQ3ZhbHVlc1tpXSAqIHV0aWxzLmFyY2ZuKHQsIGRlcml2YXRpdmVGbik7XG4gICAgfVxuICAgIHJldHVybiB6ICogc3VtO1xuICB9LFxuXG4gIG1hcDogZnVuY3Rpb24gKHYsIGRzLCBkZSwgdHMsIHRlKSB7XG4gICAgY29uc3QgZDEgPSBkZSAtIGRzLFxuICAgICAgZDIgPSB0ZSAtIHRzLFxuICAgICAgdjIgPSB2IC0gZHMsXG4gICAgICByID0gdjIgLyBkMTtcbiAgICByZXR1cm4gdHMgKyBkMiAqIHI7XG4gIH0sXG5cbiAgbGVycDogZnVuY3Rpb24gKHIsIHYxLCB2Mikge1xuICAgIGNvbnN0IHJldCA9IHtcbiAgICAgIHg6IHYxLnggKyByICogKHYyLnggLSB2MS54KSxcbiAgICAgIHk6IHYxLnkgKyByICogKHYyLnkgLSB2MS55KSxcbiAgICB9O1xuICAgIGlmICh2MS56ICE9PSB1bmRlZmluZWQgJiYgdjIueiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXQueiA9IHYxLnogKyByICogKHYyLnogLSB2MS56KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICBwb2ludFRvU3RyaW5nOiBmdW5jdGlvbiAocCkge1xuICAgIGxldCBzID0gcC54ICsgXCIvXCIgKyBwLnk7XG4gICAgaWYgKHR5cGVvZiBwLnogIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHMgKz0gXCIvXCIgKyBwLno7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9LFxuXG4gIHBvaW50c1RvU3RyaW5nOiBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgcmV0dXJuIFwiW1wiICsgcG9pbnRzLm1hcCh1dGlscy5wb2ludFRvU3RyaW5nKS5qb2luKFwiLCBcIikgKyBcIl1cIjtcbiAgfSxcblxuICBjb3B5OiBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gIH0sXG5cbiAgYW5nbGU6IGZ1bmN0aW9uIChvLCB2MSwgdjIpIHtcbiAgICBjb25zdCBkeDEgPSB2MS54IC0gby54LFxuICAgICAgZHkxID0gdjEueSAtIG8ueSxcbiAgICAgIGR4MiA9IHYyLnggLSBvLngsXG4gICAgICBkeTIgPSB2Mi55IC0gby55LFxuICAgICAgY3Jvc3MgPSBkeDEgKiBkeTIgLSBkeTEgKiBkeDIsXG4gICAgICBkb3QgPSBkeDEgKiBkeDIgKyBkeTEgKiBkeTI7XG4gICAgcmV0dXJuIGF0YW4yKGNyb3NzLCBkb3QpO1xuICB9LFxuXG4gIC8vIHJvdW5kIGFzIHN0cmluZywgdG8gYXZvaWQgcm91bmRpbmcgZXJyb3JzXG4gIHJvdW5kOiBmdW5jdGlvbiAodiwgZCkge1xuICAgIGNvbnN0IHMgPSBcIlwiICsgdjtcbiAgICBjb25zdCBwb3MgPSBzLmluZGV4T2YoXCIuXCIpO1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHMuc3Vic3RyaW5nKDAsIHBvcyArIDEgKyBkKSk7XG4gIH0sXG5cbiAgZGlzdDogZnVuY3Rpb24gKHAxLCBwMikge1xuICAgIGNvbnN0IGR4ID0gcDEueCAtIHAyLngsXG4gICAgICBkeSA9IHAxLnkgLSBwMi55O1xuICAgIHJldHVybiBzcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgfSxcblxuICBjbG9zZXN0OiBmdW5jdGlvbiAoTFVULCBwb2ludCkge1xuICAgIGxldCBtZGlzdCA9IHBvdygyLCA2MyksXG4gICAgICBtcG9zLFxuICAgICAgZDtcbiAgICBMVVQuZm9yRWFjaChmdW5jdGlvbiAocCwgaWR4KSB7XG4gICAgICBkID0gdXRpbHMuZGlzdChwb2ludCwgcCk7XG4gICAgICBpZiAoZCA8IG1kaXN0KSB7XG4gICAgICAgIG1kaXN0ID0gZDtcbiAgICAgICAgbXBvcyA9IGlkeDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4geyBtZGlzdDogbWRpc3QsIG1wb3M6IG1wb3MgfTtcbiAgfSxcblxuICBhYmNyYXRpbzogZnVuY3Rpb24gKHQsIG4pIHtcbiAgICAvLyBzZWUgcmF0aW8odCkgbm90ZSBvbiBodHRwOi8vcG9tYXguZ2l0aHViLmlvL2JlemllcmluZm8vI2FiY1xuICAgIGlmIChuICE9PSAyICYmIG4gIT09IDMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0ID0gMC41O1xuICAgIH0gZWxzZSBpZiAodCA9PT0gMCB8fCB0ID09PSAxKSB7XG4gICAgICByZXR1cm4gdDtcbiAgICB9XG4gICAgY29uc3QgYm90dG9tID0gcG93KHQsIG4pICsgcG93KDEgLSB0LCBuKSxcbiAgICAgIHRvcCA9IGJvdHRvbSAtIDE7XG4gICAgcmV0dXJuIGFicyh0b3AgLyBib3R0b20pO1xuICB9LFxuXG4gIHByb2plY3Rpb25yYXRpbzogZnVuY3Rpb24gKHQsIG4pIHtcbiAgICAvLyBzZWUgdSh0KSBub3RlIG9uIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby8jYWJjXG4gICAgaWYgKG4gIT09IDIgJiYgbiAhPT0gMykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHQgPSAwLjU7XG4gICAgfSBlbHNlIGlmICh0ID09PSAwIHx8IHQgPT09IDEpIHtcbiAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgICBjb25zdCB0b3AgPSBwb3coMSAtIHQsIG4pLFxuICAgICAgYm90dG9tID0gcG93KHQsIG4pICsgdG9wO1xuICAgIHJldHVybiB0b3AgLyBib3R0b207XG4gIH0sXG5cbiAgbGxpODogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCkge1xuICAgIGNvbnN0IG54ID1cbiAgICAgICAgKHgxICogeTIgLSB5MSAqIHgyKSAqICh4MyAtIHg0KSAtICh4MSAtIHgyKSAqICh4MyAqIHk0IC0geTMgKiB4NCksXG4gICAgICBueSA9ICh4MSAqIHkyIC0geTEgKiB4MikgKiAoeTMgLSB5NCkgLSAoeTEgLSB5MikgKiAoeDMgKiB5NCAtIHkzICogeDQpLFxuICAgICAgZCA9ICh4MSAtIHgyKSAqICh5MyAtIHk0KSAtICh5MSAtIHkyKSAqICh4MyAtIHg0KTtcbiAgICBpZiAoZCA9PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB7IHg6IG54IC8gZCwgeTogbnkgLyBkIH07XG4gIH0sXG5cbiAgbGxpNDogZnVuY3Rpb24gKHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgY29uc3QgeDEgPSBwMS54LFxuICAgICAgeTEgPSBwMS55LFxuICAgICAgeDIgPSBwMi54LFxuICAgICAgeTIgPSBwMi55LFxuICAgICAgeDMgPSBwMy54LFxuICAgICAgeTMgPSBwMy55LFxuICAgICAgeDQgPSBwNC54LFxuICAgICAgeTQgPSBwNC55O1xuICAgIHJldHVybiB1dGlscy5sbGk4KHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCk7XG4gIH0sXG5cbiAgbGxpOiBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxsaTQodjEsIHYxLmMsIHYyLCB2Mi5jKTtcbiAgfSxcblxuICBtYWtlbGluZTogZnVuY3Rpb24gKHAxLCBwMikge1xuICAgIGNvbnN0IHgxID0gcDEueCxcbiAgICAgIHkxID0gcDEueSxcbiAgICAgIHgyID0gcDIueCxcbiAgICAgIHkyID0gcDIueSxcbiAgICAgIGR4ID0gKHgyIC0geDEpIC8gMyxcbiAgICAgIGR5ID0gKHkyIC0geTEpIC8gMztcbiAgICByZXR1cm4gbmV3IEJlemllcihcbiAgICAgIHgxLFxuICAgICAgeTEsXG4gICAgICB4MSArIGR4LFxuICAgICAgeTEgKyBkeSxcbiAgICAgIHgxICsgMiAqIGR4LFxuICAgICAgeTEgKyAyICogZHksXG4gICAgICB4MixcbiAgICAgIHkyXG4gICAgKTtcbiAgfSxcblxuICBmaW5kYmJveDogZnVuY3Rpb24gKHNlY3Rpb25zKSB7XG4gICAgbGV0IG14ID0gbk1heCxcbiAgICAgIG15ID0gbk1heCxcbiAgICAgIE1YID0gbk1pbixcbiAgICAgIE1ZID0gbk1pbjtcbiAgICBzZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICBjb25zdCBiYm94ID0gcy5iYm94KCk7XG4gICAgICBpZiAobXggPiBiYm94LngubWluKSBteCA9IGJib3gueC5taW47XG4gICAgICBpZiAobXkgPiBiYm94LnkubWluKSBteSA9IGJib3gueS5taW47XG4gICAgICBpZiAoTVggPCBiYm94LngubWF4KSBNWCA9IGJib3gueC5tYXg7XG4gICAgICBpZiAoTVkgPCBiYm94LnkubWF4KSBNWSA9IGJib3gueS5tYXg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHsgbWluOiBteCwgbWlkOiAobXggKyBNWCkgLyAyLCBtYXg6IE1YLCBzaXplOiBNWCAtIG14IH0sXG4gICAgICB5OiB7IG1pbjogbXksIG1pZDogKG15ICsgTVkpIC8gMiwgbWF4OiBNWSwgc2l6ZTogTVkgLSBteSB9LFxuICAgIH07XG4gIH0sXG5cbiAgc2hhcGVpbnRlcnNlY3Rpb25zOiBmdW5jdGlvbiAoXG4gICAgczEsXG4gICAgYmJveDEsXG4gICAgczIsXG4gICAgYmJveDIsXG4gICAgY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGRcbiAgKSB7XG4gICAgaWYgKCF1dGlscy5iYm94b3ZlcmxhcChiYm94MSwgYmJveDIpKSByZXR1cm4gW107XG4gICAgY29uc3QgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICAgIGNvbnN0IGExID0gW3MxLnN0YXJ0Y2FwLCBzMS5mb3J3YXJkLCBzMS5iYWNrLCBzMS5lbmRjYXBdO1xuICAgIGNvbnN0IGEyID0gW3MyLnN0YXJ0Y2FwLCBzMi5mb3J3YXJkLCBzMi5iYWNrLCBzMi5lbmRjYXBdO1xuICAgIGExLmZvckVhY2goZnVuY3Rpb24gKGwxKSB7XG4gICAgICBpZiAobDEudmlydHVhbCkgcmV0dXJuO1xuICAgICAgYTIuZm9yRWFjaChmdW5jdGlvbiAobDIpIHtcbiAgICAgICAgaWYgKGwyLnZpcnR1YWwpIHJldHVybjtcbiAgICAgICAgY29uc3QgaXNzID0gbDEuaW50ZXJzZWN0cyhsMiwgY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGQpO1xuICAgICAgICBpZiAoaXNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpc3MuYzEgPSBsMTtcbiAgICAgICAgICBpc3MuYzIgPSBsMjtcbiAgICAgICAgICBpc3MuczEgPSBzMTtcbiAgICAgICAgICBpc3MuczIgPSBzMjtcbiAgICAgICAgICBpbnRlcnNlY3Rpb25zLnB1c2goaXNzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH0sXG5cbiAgbWFrZXNoYXBlOiBmdW5jdGlvbiAoZm9yd2FyZCwgYmFjaywgY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGQpIHtcbiAgICBjb25zdCBicGwgPSBiYWNrLnBvaW50cy5sZW5ndGg7XG4gICAgY29uc3QgZnBsID0gZm9yd2FyZC5wb2ludHMubGVuZ3RoO1xuICAgIGNvbnN0IHN0YXJ0ID0gdXRpbHMubWFrZWxpbmUoYmFjay5wb2ludHNbYnBsIC0gMV0sIGZvcndhcmQucG9pbnRzWzBdKTtcbiAgICBjb25zdCBlbmQgPSB1dGlscy5tYWtlbGluZShmb3J3YXJkLnBvaW50c1tmcGwgLSAxXSwgYmFjay5wb2ludHNbMF0pO1xuICAgIGNvbnN0IHNoYXBlID0ge1xuICAgICAgc3RhcnRjYXA6IHN0YXJ0LFxuICAgICAgZm9yd2FyZDogZm9yd2FyZCxcbiAgICAgIGJhY2s6IGJhY2ssXG4gICAgICBlbmRjYXA6IGVuZCxcbiAgICAgIGJib3g6IHV0aWxzLmZpbmRiYm94KFtzdGFydCwgZm9yd2FyZCwgYmFjaywgZW5kXSksXG4gICAgfTtcbiAgICBzaGFwZS5pbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gKHMyKSB7XG4gICAgICByZXR1cm4gdXRpbHMuc2hhcGVpbnRlcnNlY3Rpb25zKFxuICAgICAgICBzaGFwZSxcbiAgICAgICAgc2hhcGUuYmJveCxcbiAgICAgICAgczIsXG4gICAgICAgIHMyLmJib3gsXG4gICAgICAgIGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkXG4gICAgICApO1xuICAgIH07XG4gICAgcmV0dXJuIHNoYXBlO1xuICB9LFxuXG4gIGdldG1pbm1heDogZnVuY3Rpb24gKGN1cnZlLCBkLCBsaXN0KSB7XG4gICAgaWYgKCFsaXN0KSByZXR1cm4geyBtaW46IDAsIG1heDogMCB9O1xuICAgIGxldCBtaW4gPSBuTWF4LFxuICAgICAgbWF4ID0gbk1pbixcbiAgICAgIHQsXG4gICAgICBjO1xuICAgIGlmIChsaXN0LmluZGV4T2YoMCkgPT09IC0xKSB7XG4gICAgICBsaXN0ID0gWzBdLmNvbmNhdChsaXN0KTtcbiAgICB9XG4gICAgaWYgKGxpc3QuaW5kZXhPZigxKSA9PT0gLTEpIHtcbiAgICAgIGxpc3QucHVzaCgxKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHQgPSBsaXN0W2ldO1xuICAgICAgYyA9IGN1cnZlLmdldCh0KTtcbiAgICAgIGlmIChjW2RdIDwgbWluKSB7XG4gICAgICAgIG1pbiA9IGNbZF07XG4gICAgICB9XG4gICAgICBpZiAoY1tkXSA+IG1heCkge1xuICAgICAgICBtYXggPSBjW2RdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBtaW46IG1pbiwgbWlkOiAobWluICsgbWF4KSAvIDIsIG1heDogbWF4LCBzaXplOiBtYXggLSBtaW4gfTtcbiAgfSxcblxuICBhbGlnbjogZnVuY3Rpb24gKHBvaW50cywgbGluZSkge1xuICAgIGNvbnN0IHR4ID0gbGluZS5wMS54LFxuICAgICAgdHkgPSBsaW5lLnAxLnksXG4gICAgICBhID0gLWF0YW4yKGxpbmUucDIueSAtIHR5LCBsaW5lLnAyLnggLSB0eCksXG4gICAgICBkID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiAodi54IC0gdHgpICogY29zKGEpIC0gKHYueSAtIHR5KSAqIHNpbihhKSxcbiAgICAgICAgICB5OiAodi54IC0gdHgpICogc2luKGEpICsgKHYueSAtIHR5KSAqIGNvcyhhKSxcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgcmV0dXJuIHBvaW50cy5tYXAoZCk7XG4gIH0sXG5cbiAgcm9vdHM6IGZ1bmN0aW9uIChwb2ludHMsIGxpbmUpIHtcbiAgICBsaW5lID0gbGluZSB8fCB7IHAxOiB7IHg6IDAsIHk6IDAgfSwgcDI6IHsgeDogMSwgeTogMCB9IH07XG5cbiAgICBjb25zdCBvcmRlciA9IHBvaW50cy5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGFsaWduZWQgPSB1dGlscy5hbGlnbihwb2ludHMsIGxpbmUpO1xuICAgIGNvbnN0IHJlZHVjZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gMCA8PSB0ICYmIHQgPD0gMTtcbiAgICB9O1xuXG4gICAgaWYgKG9yZGVyID09PSAyKSB7XG4gICAgICBjb25zdCBhID0gYWxpZ25lZFswXS55LFxuICAgICAgICBiID0gYWxpZ25lZFsxXS55LFxuICAgICAgICBjID0gYWxpZ25lZFsyXS55LFxuICAgICAgICBkID0gYSAtIDIgKiBiICsgYztcbiAgICAgIGlmIChkICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IG0xID0gLXNxcnQoYiAqIGIgLSBhICogYyksXG4gICAgICAgICAgbTIgPSAtYSArIGIsXG4gICAgICAgICAgdjEgPSAtKG0xICsgbTIpIC8gZCxcbiAgICAgICAgICB2MiA9IC0oLW0xICsgbTIpIC8gZDtcbiAgICAgICAgcmV0dXJuIFt2MSwgdjJdLmZpbHRlcihyZWR1Y2UpO1xuICAgICAgfSBlbHNlIGlmIChiICE9PSBjICYmIGQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFsoMiAqIGIgLSBjKSAvICgyICogYiAtIDIgKiBjKV0uZmlsdGVyKHJlZHVjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gc2VlIGh0dHA6Ly93d3cudHJhbnM0bWluZC5jb20vcGVyc29uYWxfZGV2ZWxvcG1lbnQvbWF0aGVtYXRpY3MvcG9seW5vbWlhbHMvY3ViaWNBbGdlYnJhLmh0bVxuICAgIGNvbnN0IHBhID0gYWxpZ25lZFswXS55LFxuICAgICAgcGIgPSBhbGlnbmVkWzFdLnksXG4gICAgICBwYyA9IGFsaWduZWRbMl0ueSxcbiAgICAgIHBkID0gYWxpZ25lZFszXS55O1xuXG4gICAgbGV0IGQgPSAtcGEgKyAzICogcGIgLSAzICogcGMgKyBwZCxcbiAgICAgIGEgPSAzICogcGEgLSA2ICogcGIgKyAzICogcGMsXG4gICAgICBiID0gLTMgKiBwYSArIDMgKiBwYixcbiAgICAgIGMgPSBwYTtcblxuICAgIGlmICh1dGlscy5hcHByb3hpbWF0ZWx5KGQsIDApKSB7XG4gICAgICAvLyB0aGlzIGlzIG5vdCBhIGN1YmljIGN1cnZlLlxuICAgICAgaWYgKHV0aWxzLmFwcHJveGltYXRlbHkoYSwgMCkpIHtcbiAgICAgICAgLy8gaW4gZmFjdCwgdGhpcyBpcyBub3QgYSBxdWFkcmF0aWMgY3VydmUgZWl0aGVyLlxuICAgICAgICBpZiAodXRpbHMuYXBwcm94aW1hdGVseShiLCAwKSkge1xuICAgICAgICAgIC8vIGluIGZhY3QgaW4gZmFjdCwgdGhlcmUgYXJlIG5vIHNvbHV0aW9ucy5cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGluZWFyIHNvbHV0aW9uOlxuICAgICAgICByZXR1cm4gWy1jIC8gYl0uZmlsdGVyKHJlZHVjZSk7XG4gICAgICB9XG4gICAgICAvLyBxdWFkcmF0aWMgc29sdXRpb246XG4gICAgICBjb25zdCBxID0gc3FydChiICogYiAtIDQgKiBhICogYyksXG4gICAgICAgIGEyID0gMiAqIGE7XG4gICAgICByZXR1cm4gWyhxIC0gYikgLyBhMiwgKC1iIC0gcSkgLyBhMl0uZmlsdGVyKHJlZHVjZSk7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgd2Uga25vdyB3ZSBuZWVkIGEgY3ViaWMgc29sdXRpb246XG5cbiAgICBhIC89IGQ7XG4gICAgYiAvPSBkO1xuICAgIGMgLz0gZDtcblxuICAgIGNvbnN0IHAgPSAoMyAqIGIgLSBhICogYSkgLyAzLFxuICAgICAgcDMgPSBwIC8gMyxcbiAgICAgIHEgPSAoMiAqIGEgKiBhICogYSAtIDkgKiBhICogYiArIDI3ICogYykgLyAyNyxcbiAgICAgIHEyID0gcSAvIDIsXG4gICAgICBkaXNjcmltaW5hbnQgPSBxMiAqIHEyICsgcDMgKiBwMyAqIHAzO1xuXG4gICAgbGV0IHUxLCB2MSwgeDEsIHgyLCB4MztcbiAgICBpZiAoZGlzY3JpbWluYW50IDwgMCkge1xuICAgICAgY29uc3QgbXAzID0gLXAgLyAzLFxuICAgICAgICBtcDMzID0gbXAzICogbXAzICogbXAzLFxuICAgICAgICByID0gc3FydChtcDMzKSxcbiAgICAgICAgdCA9IC1xIC8gKDIgKiByKSxcbiAgICAgICAgY29zcGhpID0gdCA8IC0xID8gLTEgOiB0ID4gMSA/IDEgOiB0LFxuICAgICAgICBwaGkgPSBhY29zKGNvc3BoaSksXG4gICAgICAgIGNydHIgPSBjcnQociksXG4gICAgICAgIHQxID0gMiAqIGNydHI7XG4gICAgICB4MSA9IHQxICogY29zKHBoaSAvIDMpIC0gYSAvIDM7XG4gICAgICB4MiA9IHQxICogY29zKChwaGkgKyB0YXUpIC8gMykgLSBhIC8gMztcbiAgICAgIHgzID0gdDEgKiBjb3MoKHBoaSArIDIgKiB0YXUpIC8gMykgLSBhIC8gMztcbiAgICAgIHJldHVybiBbeDEsIHgyLCB4M10uZmlsdGVyKHJlZHVjZSk7XG4gICAgfSBlbHNlIGlmIChkaXNjcmltaW5hbnQgPT09IDApIHtcbiAgICAgIHUxID0gcTIgPCAwID8gY3J0KC1xMikgOiAtY3J0KHEyKTtcbiAgICAgIHgxID0gMiAqIHUxIC0gYSAvIDM7XG4gICAgICB4MiA9IC11MSAtIGEgLyAzO1xuICAgICAgcmV0dXJuIFt4MSwgeDJdLmZpbHRlcihyZWR1Y2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzZCA9IHNxcnQoZGlzY3JpbWluYW50KTtcbiAgICAgIHUxID0gY3J0KC1xMiArIHNkKTtcbiAgICAgIHYxID0gY3J0KHEyICsgc2QpO1xuICAgICAgcmV0dXJuIFt1MSAtIHYxIC0gYSAvIDNdLmZpbHRlcihyZWR1Y2UpO1xuICAgIH1cbiAgfSxcblxuICBkcm9vdHM6IGZ1bmN0aW9uIChwKSB7XG4gICAgLy8gcXVhZHJhdGljIHJvb3RzIGFyZSBlYXN5XG4gICAgaWYgKHAubGVuZ3RoID09PSAzKSB7XG4gICAgICBjb25zdCBhID0gcFswXSxcbiAgICAgICAgYiA9IHBbMV0sXG4gICAgICAgIGMgPSBwWzJdLFxuICAgICAgICBkID0gYSAtIDIgKiBiICsgYztcbiAgICAgIGlmIChkICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IG0xID0gLXNxcnQoYiAqIGIgLSBhICogYyksXG4gICAgICAgICAgbTIgPSAtYSArIGIsXG4gICAgICAgICAgdjEgPSAtKG0xICsgbTIpIC8gZCxcbiAgICAgICAgICB2MiA9IC0oLW0xICsgbTIpIC8gZDtcbiAgICAgICAgcmV0dXJuIFt2MSwgdjJdO1xuICAgICAgfSBlbHNlIGlmIChiICE9PSBjICYmIGQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFsoMiAqIGIgLSBjKSAvICgyICogKGIgLSBjKSldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8vIGxpbmVhciByb290cyBhcmUgZXZlbiBlYXNpZXJcbiAgICBpZiAocC5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IGEgPSBwWzBdLFxuICAgICAgICBiID0gcFsxXTtcbiAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgIHJldHVybiBbYSAvIChhIC0gYildO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbiAgfSxcblxuICBjdXJ2YXR1cmU6IGZ1bmN0aW9uICh0LCBkMSwgZDIsIF8zZCwga09ubHkpIHtcbiAgICBsZXQgbnVtLFxuICAgICAgZG5tLFxuICAgICAgYWRrLFxuICAgICAgZGssXG4gICAgICBrID0gMCxcbiAgICAgIHIgPSAwO1xuXG4gICAgLy9cbiAgICAvLyBXZSdyZSB1c2luZyB0aGUgZm9sbG93aW5nIGZvcm11bGEgZm9yIGN1cnZhdHVyZTpcbiAgICAvL1xuICAgIC8vICAgICAgICAgICAgICB4J3lcIiAtIHkneFwiXG4gICAgLy8gICBrKHQpID0gLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gICAgICAgICAgICh4J8KyICsgeSfCsileKDMvMilcbiAgICAvL1xuICAgIC8vIGZyb20gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFkaXVzX29mX2N1cnZhdHVyZSNEZWZpbml0aW9uXG4gICAgLy9cbiAgICAvLyBXaXRoIGl0IGNvcnJlc3BvbmRpbmcgM0QgY291bnRlcnBhcnQ6XG4gICAgLy9cbiAgICAvLyAgICAgICAgICBzcXJ0KCAoeSd6XCIgLSB5XCJ6JynCsiArICh6J3hcIiAtIHpcIngnKcKyICsgKHgneVwiIC0geFwieScpwrIpXG4gICAgLy8gICBrKHQpID0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgKHgnwrIgKyB5J8KyICsgeifCsileKDMvMilcbiAgICAvL1xuXG4gICAgY29uc3QgZCA9IHV0aWxzLmNvbXB1dGUodCwgZDEpO1xuICAgIGNvbnN0IGRkID0gdXRpbHMuY29tcHV0ZSh0LCBkMik7XG4gICAgY29uc3QgcWRzdW0gPSBkLnggKiBkLnggKyBkLnkgKiBkLnk7XG5cbiAgICBpZiAoXzNkKSB7XG4gICAgICBudW0gPSBzcXJ0KFxuICAgICAgICBwb3coZC55ICogZGQueiAtIGRkLnkgKiBkLnosIDIpICtcbiAgICAgICAgICBwb3coZC56ICogZGQueCAtIGRkLnogKiBkLngsIDIpICtcbiAgICAgICAgICBwb3coZC54ICogZGQueSAtIGRkLnggKiBkLnksIDIpXG4gICAgICApO1xuICAgICAgZG5tID0gcG93KHFkc3VtICsgZC56ICogZC56LCAzIC8gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bSA9IGQueCAqIGRkLnkgLSBkLnkgKiBkZC54O1xuICAgICAgZG5tID0gcG93KHFkc3VtLCAzIC8gMik7XG4gICAgfVxuXG4gICAgaWYgKG51bSA9PT0gMCB8fCBkbm0gPT09IDApIHtcbiAgICAgIHJldHVybiB7IGs6IDAsIHI6IDAgfTtcbiAgICB9XG5cbiAgICBrID0gbnVtIC8gZG5tO1xuICAgIHIgPSBkbm0gLyBudW07XG5cbiAgICAvLyBXZSdyZSBhbHNvIGNvbXB1dGluZyB0aGUgZGVyaXZhdGl2ZSBvZiBrYXBwYSwgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIHZhbHVlIGluIGtub3dpbmcgdGhlIHJhdGUgb2YgY2hhbmdlIGZvciB0aGVcbiAgICAvLyBjdXJ2YXR1cmUgYWxvbmcgdGhlIGN1cnZlLiBBbmQgd2UncmUganVzdCBnb2luZyB0b1xuICAgIC8vIGJhbGxwYXJrIGl0IGJhc2VkIG9uIGFuIGVwc2lsb24uXG4gICAgaWYgKCFrT25seSkge1xuICAgICAgLy8gY29tcHV0ZSBrJyh0KSBiYXNlZCBvbiB0aGUgaW50ZXJ2YWwgYmVmb3JlLCBhbmQgYWZ0ZXIgaXQsXG4gICAgICAvLyB0byBhdCBsZWFzdCB0cnkgdG8gbm90IGludHJvZHVjZSBmb3J3YXJkL2JhY2t3YXJkIHBhc3MgYmlhcy5cbiAgICAgIGNvbnN0IHBrID0gdXRpbHMuY3VydmF0dXJlKHQgLSAwLjAwMSwgZDEsIGQyLCBfM2QsIHRydWUpLms7XG4gICAgICBjb25zdCBuayA9IHV0aWxzLmN1cnZhdHVyZSh0ICsgMC4wMDEsIGQxLCBkMiwgXzNkLCB0cnVlKS5rO1xuICAgICAgZGsgPSAobmsgLSBrICsgKGsgLSBwaykpIC8gMjtcbiAgICAgIGFkayA9IChhYnMobmsgLSBrKSArIGFicyhrIC0gcGspKSAvIDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgazogaywgcjogciwgZGs6IGRrLCBhZGs6IGFkayB9O1xuICB9LFxuXG4gIGluZmxlY3Rpb25zOiBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPCA0KSByZXR1cm4gW107XG5cbiAgICAvLyBGSVhNRTogVE9ETzogYWRkIGluIGluZmxlY3Rpb24gYWJzdHJhY3Rpb24gZm9yIHF1YXJ0aWMrIGN1cnZlcz9cblxuICAgIGNvbnN0IHAgPSB1dGlscy5hbGlnbihwb2ludHMsIHsgcDE6IHBvaW50c1swXSwgcDI6IHBvaW50cy5zbGljZSgtMSlbMF0gfSksXG4gICAgICBhID0gcFsyXS54ICogcFsxXS55LFxuICAgICAgYiA9IHBbM10ueCAqIHBbMV0ueSxcbiAgICAgIGMgPSBwWzFdLnggKiBwWzJdLnksXG4gICAgICBkID0gcFszXS54ICogcFsyXS55LFxuICAgICAgdjEgPSAxOCAqICgtMyAqIGEgKyAyICogYiArIDMgKiBjIC0gZCksXG4gICAgICB2MiA9IDE4ICogKDMgKiBhIC0gYiAtIDMgKiBjKSxcbiAgICAgIHYzID0gMTggKiAoYyAtIGEpO1xuXG4gICAgaWYgKHV0aWxzLmFwcHJveGltYXRlbHkodjEsIDApKSB7XG4gICAgICBpZiAoIXV0aWxzLmFwcHJveGltYXRlbHkodjIsIDApKSB7XG4gICAgICAgIGxldCB0ID0gLXYzIC8gdjI7XG4gICAgICAgIGlmICgwIDw9IHQgJiYgdCA8PSAxKSByZXR1cm4gW3RdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IHRybSA9IHYyICogdjIgLSA0ICogdjEgKiB2MyxcbiAgICAgIHNxID0gTWF0aC5zcXJ0KHRybSksXG4gICAgICBkMiA9IDIgKiB2MTtcblxuICAgIGlmICh1dGlscy5hcHByb3hpbWF0ZWx5KGQyLCAwKSkgcmV0dXJuIFtdO1xuXG4gICAgcmV0dXJuIFsoc3EgLSB2MikgLyBkMiwgLSh2MiArIHNxKSAvIGQyXS5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiAwIDw9IHIgJiYgciA8PSAxO1xuICAgIH0pO1xuICB9LFxuXG4gIGJib3hvdmVybGFwOiBmdW5jdGlvbiAoYjEsIGIyKSB7XG4gICAgY29uc3QgZGltcyA9IFtcInhcIiwgXCJ5XCJdLFxuICAgICAgbGVuID0gZGltcy5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgZGltLCBsLCB0LCBkOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRpbSA9IGRpbXNbaV07XG4gICAgICBsID0gYjFbZGltXS5taWQ7XG4gICAgICB0ID0gYjJbZGltXS5taWQ7XG4gICAgICBkID0gKGIxW2RpbV0uc2l6ZSArIGIyW2RpbV0uc2l6ZSkgLyAyO1xuICAgICAgaWYgKGFicyhsIC0gdCkgPj0gZCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBleHBhbmRib3g6IGZ1bmN0aW9uIChiYm94LCBfYmJveCkge1xuICAgIGlmIChfYmJveC54Lm1pbiA8IGJib3gueC5taW4pIHtcbiAgICAgIGJib3gueC5taW4gPSBfYmJveC54Lm1pbjtcbiAgICB9XG4gICAgaWYgKF9iYm94LnkubWluIDwgYmJveC55Lm1pbikge1xuICAgICAgYmJveC55Lm1pbiA9IF9iYm94LnkubWluO1xuICAgIH1cbiAgICBpZiAoX2Jib3gueiAmJiBfYmJveC56Lm1pbiA8IGJib3guei5taW4pIHtcbiAgICAgIGJib3guei5taW4gPSBfYmJveC56Lm1pbjtcbiAgICB9XG4gICAgaWYgKF9iYm94LngubWF4ID4gYmJveC54Lm1heCkge1xuICAgICAgYmJveC54Lm1heCA9IF9iYm94LngubWF4O1xuICAgIH1cbiAgICBpZiAoX2Jib3gueS5tYXggPiBiYm94LnkubWF4KSB7XG4gICAgICBiYm94LnkubWF4ID0gX2Jib3gueS5tYXg7XG4gICAgfVxuICAgIGlmIChfYmJveC56ICYmIF9iYm94LnoubWF4ID4gYmJveC56Lm1heCkge1xuICAgICAgYmJveC56Lm1heCA9IF9iYm94LnoubWF4O1xuICAgIH1cbiAgICBiYm94LngubWlkID0gKGJib3gueC5taW4gKyBiYm94LngubWF4KSAvIDI7XG4gICAgYmJveC55Lm1pZCA9IChiYm94LnkubWluICsgYmJveC55Lm1heCkgLyAyO1xuICAgIGlmIChiYm94LnopIHtcbiAgICAgIGJib3guei5taWQgPSAoYmJveC56Lm1pbiArIGJib3guei5tYXgpIC8gMjtcbiAgICB9XG4gICAgYmJveC54LnNpemUgPSBiYm94LngubWF4IC0gYmJveC54Lm1pbjtcbiAgICBiYm94Lnkuc2l6ZSA9IGJib3gueS5tYXggLSBiYm94LnkubWluO1xuICAgIGlmIChiYm94LnopIHtcbiAgICAgIGJib3guei5zaXplID0gYmJveC56Lm1heCAtIGJib3guei5taW47XG4gICAgfVxuICB9LFxuXG4gIHBhaXJpdGVyYXRpb246IGZ1bmN0aW9uIChjMSwgYzIsIGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkKSB7XG4gICAgY29uc3QgYzFiID0gYzEuYmJveCgpLFxuICAgICAgYzJiID0gYzIuYmJveCgpLFxuICAgICAgciA9IDEwMDAwMCxcbiAgICAgIHRocmVzaG9sZCA9IGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkIHx8IDAuNTtcblxuICAgIGlmIChcbiAgICAgIGMxYi54LnNpemUgKyBjMWIueS5zaXplIDwgdGhyZXNob2xkICYmXG4gICAgICBjMmIueC5zaXplICsgYzJiLnkuc2l6ZSA8IHRocmVzaG9sZFxuICAgICkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgKCgociAqIChjMS5fdDEgKyBjMS5fdDIpKSAvIDIpIHwgMCkgLyByICtcbiAgICAgICAgICBcIi9cIiArXG4gICAgICAgICAgKCgociAqIChjMi5fdDEgKyBjMi5fdDIpKSAvIDIpIHwgMCkgLyByLFxuICAgICAgXTtcbiAgICB9XG5cbiAgICBsZXQgY2MxID0gYzEuc3BsaXQoMC41KSxcbiAgICAgIGNjMiA9IGMyLnNwbGl0KDAuNSksXG4gICAgICBwYWlycyA9IFtcbiAgICAgICAgeyBsZWZ0OiBjYzEubGVmdCwgcmlnaHQ6IGNjMi5sZWZ0IH0sXG4gICAgICAgIHsgbGVmdDogY2MxLmxlZnQsIHJpZ2h0OiBjYzIucmlnaHQgfSxcbiAgICAgICAgeyBsZWZ0OiBjYzEucmlnaHQsIHJpZ2h0OiBjYzIucmlnaHQgfSxcbiAgICAgICAgeyBsZWZ0OiBjYzEucmlnaHQsIHJpZ2h0OiBjYzIubGVmdCB9LFxuICAgICAgXTtcblxuICAgIHBhaXJzID0gcGFpcnMuZmlsdGVyKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICByZXR1cm4gdXRpbHMuYmJveG92ZXJsYXAocGFpci5sZWZ0LmJib3goKSwgcGFpci5yaWdodC5iYm94KCkpO1xuICAgIH0pO1xuXG4gICAgbGV0IHJlc3VsdHMgPSBbXTtcblxuICAgIGlmIChwYWlycy5sZW5ndGggPT09IDApIHJldHVybiByZXN1bHRzO1xuXG4gICAgcGFpcnMuZm9yRWFjaChmdW5jdGlvbiAocGFpcikge1xuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KFxuICAgICAgICB1dGlscy5wYWlyaXRlcmF0aW9uKHBhaXIubGVmdCwgcGFpci5yaWdodCwgdGhyZXNob2xkKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHJlc3VsdHMgPSByZXN1bHRzLmZpbHRlcihmdW5jdGlvbiAodiwgaSkge1xuICAgICAgcmV0dXJuIHJlc3VsdHMuaW5kZXhPZih2KSA9PT0gaTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9LFxuXG4gIGdldGNjZW50ZXI6IGZ1bmN0aW9uIChwMSwgcDIsIHAzKSB7XG4gICAgY29uc3QgZHgxID0gcDIueCAtIHAxLngsXG4gICAgICBkeTEgPSBwMi55IC0gcDEueSxcbiAgICAgIGR4MiA9IHAzLnggLSBwMi54LFxuICAgICAgZHkyID0gcDMueSAtIHAyLnksXG4gICAgICBkeDFwID0gZHgxICogY29zKHF1YXJ0KSAtIGR5MSAqIHNpbihxdWFydCksXG4gICAgICBkeTFwID0gZHgxICogc2luKHF1YXJ0KSArIGR5MSAqIGNvcyhxdWFydCksXG4gICAgICBkeDJwID0gZHgyICogY29zKHF1YXJ0KSAtIGR5MiAqIHNpbihxdWFydCksXG4gICAgICBkeTJwID0gZHgyICogc2luKHF1YXJ0KSArIGR5MiAqIGNvcyhxdWFydCksXG4gICAgICAvLyBjaG9yZCBtaWRwb2ludHNcbiAgICAgIG14MSA9IChwMS54ICsgcDIueCkgLyAyLFxuICAgICAgbXkxID0gKHAxLnkgKyBwMi55KSAvIDIsXG4gICAgICBteDIgPSAocDIueCArIHAzLngpIC8gMixcbiAgICAgIG15MiA9IChwMi55ICsgcDMueSkgLyAyLFxuICAgICAgLy8gbWlkcG9pbnQgb2Zmc2V0c1xuICAgICAgbXgxbiA9IG14MSArIGR4MXAsXG4gICAgICBteTFuID0gbXkxICsgZHkxcCxcbiAgICAgIG14Mm4gPSBteDIgKyBkeDJwLFxuICAgICAgbXkybiA9IG15MiArIGR5MnAsXG4gICAgICAvLyBpbnRlcnNlY3Rpb24gb2YgdGhlc2UgbGluZXM6XG4gICAgICBhcmMgPSB1dGlscy5sbGk4KG14MSwgbXkxLCBteDFuLCBteTFuLCBteDIsIG15MiwgbXgybiwgbXkybiksXG4gICAgICByID0gdXRpbHMuZGlzdChhcmMsIHAxKTtcblxuICAgIC8vIGFyYyBzdGFydC9lbmQgdmFsdWVzLCBvdmVyIG1pZCBwb2ludDpcbiAgICBsZXQgcyA9IGF0YW4yKHAxLnkgLSBhcmMueSwgcDEueCAtIGFyYy54KSxcbiAgICAgIG0gPSBhdGFuMihwMi55IC0gYXJjLnksIHAyLnggLSBhcmMueCksXG4gICAgICBlID0gYXRhbjIocDMueSAtIGFyYy55LCBwMy54IC0gYXJjLngpLFxuICAgICAgXztcblxuICAgIC8vIGRldGVybWluZSBhcmMgZGlyZWN0aW9uIChjdy9jY3cgY29ycmVjdGlvbilcbiAgICBpZiAocyA8IGUpIHtcbiAgICAgIC8vIGlmIHM8bTxlLCBhcmMocywgZSlcbiAgICAgIC8vIGlmIG08czxlLCBhcmMoZSwgcyArIHRhdSlcbiAgICAgIC8vIGlmIHM8ZTxtLCBhcmMoZSwgcyArIHRhdSlcbiAgICAgIGlmIChzID4gbSB8fCBtID4gZSkge1xuICAgICAgICBzICs9IHRhdTtcbiAgICAgIH1cbiAgICAgIGlmIChzID4gZSkge1xuICAgICAgICBfID0gZTtcbiAgICAgICAgZSA9IHM7XG4gICAgICAgIHMgPSBfO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBlPG08cywgYXJjKGUsIHMpXG4gICAgICAvLyBpZiBtPGU8cywgYXJjKHMsIGUgKyB0YXUpXG4gICAgICAvLyBpZiBlPHM8bSwgYXJjKHMsIGUgKyB0YXUpXG4gICAgICBpZiAoZSA8IG0gJiYgbSA8IHMpIHtcbiAgICAgICAgXyA9IGU7XG4gICAgICAgIGUgPSBzO1xuICAgICAgICBzID0gXztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGUgKz0gdGF1O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBhc3NpZ24gYW5kIGRvbmUuXG4gICAgYXJjLnMgPSBzO1xuICAgIGFyYy5lID0gZTtcbiAgICBhcmMuciA9IHI7XG4gICAgcmV0dXJuIGFyYztcbiAgfSxcblxuICBudW1iZXJTb3J0OiBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhIC0gYjtcbiAgfSxcbn07XG5cbmV4cG9ydCB7IHV0aWxzIH07XG4iLCJpbXBvcnQgeyB1dGlscyB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5cbi8qKlxuICogUG9seSBCZXppZXJcbiAqIEBwYXJhbSB7W3R5cGVdfSBjdXJ2ZXMgW2Rlc2NyaXB0aW9uXVxuICovXG5jbGFzcyBQb2x5QmV6aWVyIHtcbiAgY29uc3RydWN0b3IoY3VydmVzKSB7XG4gICAgdGhpcy5jdXJ2ZXMgPSBbXTtcbiAgICB0aGlzLl8zZCA9IGZhbHNlO1xuICAgIGlmICghIWN1cnZlcykge1xuICAgICAgdGhpcy5jdXJ2ZXMgPSBjdXJ2ZXM7XG4gICAgICB0aGlzLl8zZCA9IHRoaXMuY3VydmVzWzBdLl8zZDtcbiAgICB9XG4gIH1cblxuICB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gKFxuICAgICAgXCJbXCIgK1xuICAgICAgdGhpcy5jdXJ2ZXNcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoY3VydmUpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbHMucG9pbnRzVG9TdHJpbmcoY3VydmUucG9pbnRzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oXCIsIFwiKSArXG4gICAgICBcIl1cIlxuICAgICk7XG4gIH1cblxuICBhZGRDdXJ2ZShjdXJ2ZSkge1xuICAgIHRoaXMuY3VydmVzLnB1c2goY3VydmUpO1xuICAgIHRoaXMuXzNkID0gdGhpcy5fM2QgfHwgY3VydmUuXzNkO1xuICB9XG5cbiAgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnZlc1xuICAgICAgLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdi5sZW5ndGgoKTtcbiAgICAgIH0pXG4gICAgICAucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhICsgYjtcbiAgICAgIH0pO1xuICB9XG5cbiAgY3VydmUoaWR4KSB7XG4gICAgcmV0dXJuIHRoaXMuY3VydmVzW2lkeF07XG4gIH1cblxuICBiYm94KCkge1xuICAgIGNvbnN0IGMgPSB0aGlzLmN1cnZlcztcbiAgICB2YXIgYmJveCA9IGNbMF0uYmJveCgpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYy5sZW5ndGg7IGkrKykge1xuICAgICAgdXRpbHMuZXhwYW5kYm94KGJib3gsIGNbaV0uYmJveCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJib3g7XG4gIH1cblxuICBvZmZzZXQoZCkge1xuICAgIGNvbnN0IG9mZnNldCA9IFtdO1xuICAgIHRoaXMuY3VydmVzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgIG9mZnNldC5wdXNoKC4uLnYub2Zmc2V0KGQpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFBvbHlCZXppZXIob2Zmc2V0KTtcbiAgfVxufVxuXG5leHBvcnQgeyBQb2x5QmV6aWVyIH07XG4iLCIvKipcbiAgQSBqYXZhc2NyaXB0IEJlemllciBjdXJ2ZSBsaWJyYXJ5IGJ5IFBvbWF4LlxuXG4gIEJhc2VkIG9uIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mb1xuXG4gIFRoaXMgY29kZSBpcyBNSVQgbGljZW5zZWQuXG4qKi9cblxuaW1wb3J0IHsgdXRpbHMgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgUG9seUJlemllciB9IGZyb20gXCIuL3BvbHktYmV6aWVyLmpzXCI7XG5cbi8vIG1hdGgtaW5saW5pbmcuXG5jb25zdCB7IGFicywgbWluLCBtYXgsIGNvcywgc2luLCBhY29zLCBzcXJ0IH0gPSBNYXRoO1xuY29uc3QgcGkgPSBNYXRoLlBJO1xuLy8gYSB6ZXJvIGNvb3JkaW5hdGUsIHdoaWNoIGlzIHN1cnByaXNpbmdseSB1c2VmdWxcbmNvbnN0IFpFUk8gPSB7IHg6IDAsIHk6IDAsIHo6IDAgfTtcblxuLyoqXG4gKiBCZXppZXIgY3VydmUgY29uc3RydWN0b3IuXG4gKlxuICogLi4uZG9jcyBwZW5kaW5nLi4uXG4gKi9cbmNsYXNzIEJlemllciB7XG4gIGNvbnN0cnVjdG9yKGNvb3Jkcykge1xuICAgIGxldCBhcmdzID1cbiAgICAgIGNvb3JkcyAmJiBjb29yZHMuZm9yRWFjaCA/IGNvb3JkcyA6IEFycmF5LmZyb20oYXJndW1lbnRzKS5zbGljZSgpO1xuICAgIGxldCBjb29yZGxlbiA9IGZhbHNlO1xuXG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb29yZGxlbiA9IGFyZ3MubGVuZ3RoO1xuICAgICAgY29uc3QgbmV3YXJncyA9IFtdO1xuICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICBbXCJ4XCIsIFwieVwiLCBcInpcIl0uZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnRbZF0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG5ld2FyZ3MucHVzaChwb2ludFtkXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgYXJncyA9IG5ld2FyZ3M7XG4gICAgfVxuXG4gICAgbGV0IGhpZ2hlciA9IGZhbHNlO1xuICAgIGNvbnN0IGxlbiA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgaWYgKGNvb3JkbGVuKSB7XG4gICAgICBpZiAoY29vcmRsZW4gPiA0KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJPbmx5IG5ldyBCZXppZXIocG9pbnRbXSkgaXMgYWNjZXB0ZWQgZm9yIDR0aCBhbmQgaGlnaGVyIG9yZGVyIGN1cnZlc1wiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBoaWdoZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobGVuICE9PSA2ICYmIGxlbiAhPT0gOCAmJiBsZW4gIT09IDkgJiYgbGVuICE9PSAxMikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiT25seSBuZXcgQmV6aWVyKHBvaW50W10pIGlzIGFjY2VwdGVkIGZvciA0dGggYW5kIGhpZ2hlciBvcmRlciBjdXJ2ZXNcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBfM2QgPSAodGhpcy5fM2QgPVxuICAgICAgKCFoaWdoZXIgJiYgKGxlbiA9PT0gOSB8fCBsZW4gPT09IDEyKSkgfHxcbiAgICAgIChjb29yZHMgJiYgY29vcmRzWzBdICYmIHR5cGVvZiBjb29yZHNbMF0ueiAhPT0gXCJ1bmRlZmluZWRcIikpO1xuXG4gICAgY29uc3QgcG9pbnRzID0gKHRoaXMucG9pbnRzID0gW10pO1xuICAgIGZvciAobGV0IGlkeCA9IDAsIHN0ZXAgPSBfM2QgPyAzIDogMjsgaWR4IDwgbGVuOyBpZHggKz0gc3RlcCkge1xuICAgICAgdmFyIHBvaW50ID0ge1xuICAgICAgICB4OiBhcmdzW2lkeF0sXG4gICAgICAgIHk6IGFyZ3NbaWR4ICsgMV0sXG4gICAgICB9O1xuICAgICAgaWYgKF8zZCkge1xuICAgICAgICBwb2ludC56ID0gYXJnc1tpZHggKyAyXTtcbiAgICAgIH1cbiAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICB9XG4gICAgY29uc3Qgb3JkZXIgPSAodGhpcy5vcmRlciA9IHBvaW50cy5sZW5ndGggLSAxKTtcblxuICAgIGNvbnN0IGRpbXMgPSAodGhpcy5kaW1zID0gW1wieFwiLCBcInlcIl0pO1xuICAgIGlmIChfM2QpIGRpbXMucHVzaChcInpcIik7XG4gICAgdGhpcy5kaW1sZW4gPSBkaW1zLmxlbmd0aDtcblxuICAgIGNvbnN0IGFsaWduZWQgPSB1dGlscy5hbGlnbihwb2ludHMsIHsgcDE6IHBvaW50c1swXSwgcDI6IHBvaW50c1tvcmRlcl0gfSk7XG4gICAgdGhpcy5fbGluZWFyID0gIWFsaWduZWQuc29tZSgocCkgPT4gYWJzKHAueSkgPiAwLjAwMDEpO1xuXG4gICAgdGhpcy5fbHV0ID0gW107XG5cbiAgICB0aGlzLl90MSA9IDA7XG4gICAgdGhpcy5fdDIgPSAxO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBzdGF0aWMgcXVhZHJhdGljRnJvbVBvaW50cyhwMSwgcDIsIHAzLCB0KSB7XG4gICAgaWYgKHR5cGVvZiB0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0ID0gMC41O1xuICAgIH1cbiAgICAvLyBzaG9ydGN1dHMsIGFsdGhvdWdoIHRoZXkncmUgcmVhbGx5IGR1bWJcbiAgICBpZiAodCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBCZXppZXIocDIsIHAyLCBwMyk7XG4gICAgfVxuICAgIGlmICh0ID09PSAxKSB7XG4gICAgICByZXR1cm4gbmV3IEJlemllcihwMSwgcDIsIHAyKTtcbiAgICB9XG4gICAgLy8gcmVhbCBmaXR0aW5nLlxuICAgIGNvbnN0IGFiYyA9IEJlemllci5nZXRBQkMoMiwgcDEsIHAyLCBwMywgdCk7XG4gICAgcmV0dXJuIG5ldyBCZXppZXIocDEsIGFiYy5BLCBwMyk7XG4gIH1cblxuICBzdGF0aWMgY3ViaWNGcm9tUG9pbnRzKFMsIEIsIEUsIHQsIGQxKSB7XG4gICAgaWYgKHR5cGVvZiB0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0ID0gMC41O1xuICAgIH1cbiAgICBjb25zdCBhYmMgPSBCZXppZXIuZ2V0QUJDKDMsIFMsIEIsIEUsIHQpO1xuICAgIGlmICh0eXBlb2YgZDEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGQxID0gdXRpbHMuZGlzdChCLCBhYmMuQyk7XG4gICAgfVxuICAgIGNvbnN0IGQyID0gKGQxICogKDEgLSB0KSkgLyB0O1xuXG4gICAgY29uc3Qgc2VsZW4gPSB1dGlscy5kaXN0KFMsIEUpLFxuICAgICAgbHggPSAoRS54IC0gUy54KSAvIHNlbGVuLFxuICAgICAgbHkgPSAoRS55IC0gUy55KSAvIHNlbGVuLFxuICAgICAgYngxID0gZDEgKiBseCxcbiAgICAgIGJ5MSA9IGQxICogbHksXG4gICAgICBieDIgPSBkMiAqIGx4LFxuICAgICAgYnkyID0gZDIgKiBseTtcbiAgICAvLyBkZXJpdmF0aW9uIG9mIG5ldyBodWxsIGNvb3JkaW5hdGVzXG4gICAgY29uc3QgZTEgPSB7IHg6IEIueCAtIGJ4MSwgeTogQi55IC0gYnkxIH0sXG4gICAgICBlMiA9IHsgeDogQi54ICsgYngyLCB5OiBCLnkgKyBieTIgfSxcbiAgICAgIEEgPSBhYmMuQSxcbiAgICAgIHYxID0geyB4OiBBLnggKyAoZTEueCAtIEEueCkgLyAoMSAtIHQpLCB5OiBBLnkgKyAoZTEueSAtIEEueSkgLyAoMSAtIHQpIH0sXG4gICAgICB2MiA9IHsgeDogQS54ICsgKGUyLnggLSBBLngpIC8gdCwgeTogQS55ICsgKGUyLnkgLSBBLnkpIC8gdCB9LFxuICAgICAgbmMxID0geyB4OiBTLnggKyAodjEueCAtIFMueCkgLyB0LCB5OiBTLnkgKyAodjEueSAtIFMueSkgLyB0IH0sXG4gICAgICBuYzIgPSB7XG4gICAgICAgIHg6IEUueCArICh2Mi54IC0gRS54KSAvICgxIC0gdCksXG4gICAgICAgIHk6IEUueSArICh2Mi55IC0gRS55KSAvICgxIC0gdCksXG4gICAgICB9O1xuICAgIC8vIC4uLmRvbmVcbiAgICByZXR1cm4gbmV3IEJlemllcihTLCBuYzEsIG5jMiwgRSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0VXRpbHMoKSB7XG4gICAgcmV0dXJuIHV0aWxzO1xuICB9XG5cbiAgZ2V0VXRpbHMoKSB7XG4gICAgcmV0dXJuIEJlemllci5nZXRVdGlscygpO1xuICB9XG5cbiAgc3RhdGljIGdldCBQb2x5QmV6aWVyKCkge1xuICAgIHJldHVybiBQb2x5QmV6aWVyO1xuICB9XG5cbiAgdmFsdWVPZigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHV0aWxzLnBvaW50c1RvU3RyaW5nKHRoaXMucG9pbnRzKTtcbiAgfVxuXG4gIHRvU1ZHKCkge1xuICAgIGlmICh0aGlzLl8zZCkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHAgPSB0aGlzLnBvaW50cyxcbiAgICAgIHggPSBwWzBdLngsXG4gICAgICB5ID0gcFswXS55LFxuICAgICAgcyA9IFtcIk1cIiwgeCwgeSwgdGhpcy5vcmRlciA9PT0gMiA/IFwiUVwiIDogXCJDXCJdO1xuICAgIGZvciAobGV0IGkgPSAxLCBsYXN0ID0gcC5sZW5ndGg7IGkgPCBsYXN0OyBpKyspIHtcbiAgICAgIHMucHVzaChwW2ldLngpO1xuICAgICAgcy5wdXNoKHBbaV0ueSk7XG4gICAgfVxuICAgIHJldHVybiBzLmpvaW4oXCIgXCIpO1xuICB9XG5cbiAgc2V0UmF0aW9zKHJhdGlvcykge1xuICAgIGlmIChyYXRpb3MubGVuZ3RoICE9PSB0aGlzLnBvaW50cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImluY29ycmVjdCBudW1iZXIgb2YgcmF0aW8gdmFsdWVzXCIpO1xuICAgIH1cbiAgICB0aGlzLnJhdGlvcyA9IHJhdGlvcztcbiAgICB0aGlzLl9sdXQgPSBbXTsgLy8gIGludmFsaWRhdGUgYW55IHByZWNvbXB1dGVkIExVVFxuICB9XG5cbiAgdmVyaWZ5KCkge1xuICAgIGNvbnN0IHByaW50ID0gdGhpcy5jb29yZERpZ2VzdCgpO1xuICAgIGlmIChwcmludCAhPT0gdGhpcy5fcHJpbnQpIHtcbiAgICAgIHRoaXMuX3ByaW50ID0gcHJpbnQ7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGNvb3JkRGlnZXN0KCkge1xuICAgIHJldHVybiB0aGlzLnBvaW50c1xuICAgICAgLm1hcChmdW5jdGlvbiAoYywgcG9zKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgcG9zICsgYy54ICsgYy55ICsgKGMueiA/IGMueiA6IDApO1xuICAgICAgfSlcbiAgICAgIC5qb2luKFwiXCIpO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIC8vIGludmFsaWRhdGUgYW55IHByZWNvbXB1dGVkIExVVFxuICAgIHRoaXMuX2x1dCA9IFtdO1xuICAgIHRoaXMuZHBvaW50cyA9IHV0aWxzLmRlcml2ZSh0aGlzLnBvaW50cywgdGhpcy5fM2QpO1xuICAgIHRoaXMuY29tcHV0ZWRpcmVjdGlvbigpO1xuICB9XG5cbiAgY29tcHV0ZWRpcmVjdGlvbigpIHtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCBhbmdsZSA9IHV0aWxzLmFuZ2xlKHBvaW50c1swXSwgcG9pbnRzW3RoaXMub3JkZXJdLCBwb2ludHNbMV0pO1xuICAgIHRoaXMuY2xvY2t3aXNlID0gYW5nbGUgPiAwO1xuICB9XG5cbiAgbGVuZ3RoKCkge1xuICAgIHJldHVybiB1dGlscy5sZW5ndGgodGhpcy5kZXJpdmF0aXZlLmJpbmQodGhpcykpO1xuICB9XG5cbiAgc3RhdGljIGdldEFCQyhvcmRlciA9IDIsIFMsIEIsIEUsIHQgPSAwLjUpIHtcbiAgICBjb25zdCB1ID0gdXRpbHMucHJvamVjdGlvbnJhdGlvKHQsIG9yZGVyKSxcbiAgICAgIHVtID0gMSAtIHUsXG4gICAgICBDID0ge1xuICAgICAgICB4OiB1ICogUy54ICsgdW0gKiBFLngsXG4gICAgICAgIHk6IHUgKiBTLnkgKyB1bSAqIEUueSxcbiAgICAgIH0sXG4gICAgICBzID0gdXRpbHMuYWJjcmF0aW8odCwgb3JkZXIpLFxuICAgICAgQSA9IHtcbiAgICAgICAgeDogQi54ICsgKEIueCAtIEMueCkgLyBzLFxuICAgICAgICB5OiBCLnkgKyAoQi55IC0gQy55KSAvIHMsXG4gICAgICB9O1xuICAgIHJldHVybiB7IEEsIEIsIEMsIFMsIEUgfTtcbiAgfVxuXG4gIGdldEFCQyh0LCBCKSB7XG4gICAgQiA9IEIgfHwgdGhpcy5nZXQodCk7XG4gICAgbGV0IFMgPSB0aGlzLnBvaW50c1swXTtcbiAgICBsZXQgRSA9IHRoaXMucG9pbnRzW3RoaXMub3JkZXJdO1xuICAgIHJldHVybiBCZXppZXIuZ2V0QUJDKHRoaXMub3JkZXIsIFMsIEIsIEUsIHQpO1xuICB9XG5cbiAgZ2V0TFVUKHN0ZXBzKSB7XG4gICAgdGhpcy52ZXJpZnkoKTtcbiAgICBzdGVwcyA9IHN0ZXBzIHx8IDEwMDtcbiAgICBpZiAodGhpcy5fbHV0Lmxlbmd0aCA9PT0gc3RlcHMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sdXQ7XG4gICAgfVxuICAgIHRoaXMuX2x1dCA9IFtdO1xuICAgIC8vIFdlIHdhbnQgYSByYW5nZSBmcm9tIDAgdG8gMSBpbmNsdXNpdmUsIHNvXG4gICAgLy8gd2UgZGVjcmVtZW50IGFuZCB0aGVuIHVzZSA8PSByYXRoZXIgdGhhbiA8OlxuICAgIHN0ZXBzLS07XG4gICAgZm9yIChsZXQgaSA9IDAsIHAsIHQ7IGkgPCBzdGVwczsgaSsrKSB7XG4gICAgICB0ID0gaSAvIChzdGVwcyAtIDEpO1xuICAgICAgcCA9IHRoaXMuY29tcHV0ZSh0KTtcbiAgICAgIHAudCA9IHQ7XG4gICAgICB0aGlzLl9sdXQucHVzaChwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2x1dDtcbiAgfVxuXG4gIG9uKHBvaW50LCBlcnJvcikge1xuICAgIGVycm9yID0gZXJyb3IgfHwgNTtcbiAgICBjb25zdCBsdXQgPSB0aGlzLmdldExVVCgpLFxuICAgICAgaGl0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBjLCB0ID0gMDsgaSA8IGx1dC5sZW5ndGg7IGkrKykge1xuICAgICAgYyA9IGx1dFtpXTtcbiAgICAgIGlmICh1dGlscy5kaXN0KGMsIHBvaW50KSA8IGVycm9yKSB7XG4gICAgICAgIGhpdHMucHVzaChjKTtcbiAgICAgICAgdCArPSBpIC8gbHV0Lmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFoaXRzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAodCAvPSBoaXRzLmxlbmd0aCk7XG4gIH1cblxuICBwcm9qZWN0KHBvaW50KSB7XG4gICAgLy8gc3RlcCAxOiBjb2Fyc2UgY2hlY2tcbiAgICBjb25zdCBMVVQgPSB0aGlzLmdldExVVCgpLFxuICAgICAgbCA9IExVVC5sZW5ndGggLSAxLFxuICAgICAgY2xvc2VzdCA9IHV0aWxzLmNsb3Nlc3QoTFVULCBwb2ludCksXG4gICAgICBtcG9zID0gY2xvc2VzdC5tcG9zLFxuICAgICAgdDEgPSAobXBvcyAtIDEpIC8gbCxcbiAgICAgIHQyID0gKG1wb3MgKyAxKSAvIGwsXG4gICAgICBzdGVwID0gMC4xIC8gbDtcblxuICAgIC8vIHN0ZXAgMjogZmluZSBjaGVja1xuICAgIGxldCBtZGlzdCA9IGNsb3Nlc3QubWRpc3QsXG4gICAgICB0ID0gdDEsXG4gICAgICBmdCA9IHQsXG4gICAgICBwO1xuICAgIG1kaXN0ICs9IDE7XG4gICAgZm9yIChsZXQgZDsgdCA8IHQyICsgc3RlcDsgdCArPSBzdGVwKSB7XG4gICAgICBwID0gdGhpcy5jb21wdXRlKHQpO1xuICAgICAgZCA9IHV0aWxzLmRpc3QocG9pbnQsIHApO1xuICAgICAgaWYgKGQgPCBtZGlzdCkge1xuICAgICAgICBtZGlzdCA9IGQ7XG4gICAgICAgIGZ0ID0gdDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnQgPSBmdCA8IDAgPyAwIDogZnQgPiAxID8gMSA6IGZ0O1xuICAgIHAgPSB0aGlzLmNvbXB1dGUoZnQpO1xuICAgIHAudCA9IGZ0O1xuICAgIHAuZCA9IG1kaXN0O1xuICAgIHJldHVybiBwO1xuICB9XG5cbiAgZ2V0KHQpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wdXRlKHQpO1xuICB9XG5cbiAgcG9pbnQoaWR4KSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRzW2lkeF07XG4gIH1cblxuICBjb21wdXRlKHQpIHtcbiAgICBpZiAodGhpcy5yYXRpb3MpIHtcbiAgICAgIHJldHVybiB1dGlscy5jb21wdXRlV2l0aFJhdGlvcyh0LCB0aGlzLnBvaW50cywgdGhpcy5yYXRpb3MsIHRoaXMuXzNkKTtcbiAgICB9XG4gICAgcmV0dXJuIHV0aWxzLmNvbXB1dGUodCwgdGhpcy5wb2ludHMsIHRoaXMuXzNkLCB0aGlzLnJhdGlvcyk7XG4gIH1cblxuICByYWlzZSgpIHtcbiAgICBjb25zdCBwID0gdGhpcy5wb2ludHMsXG4gICAgICBucCA9IFtwWzBdXSxcbiAgICAgIGsgPSBwLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMSwgcGksIHBpbTsgaSA8IGs7IGkrKykge1xuICAgICAgcGkgPSBwW2ldO1xuICAgICAgcGltID0gcFtpIC0gMV07XG4gICAgICBucFtpXSA9IHtcbiAgICAgICAgeDogKChrIC0gaSkgLyBrKSAqIHBpLnggKyAoaSAvIGspICogcGltLngsXG4gICAgICAgIHk6ICgoayAtIGkpIC8gaykgKiBwaS55ICsgKGkgLyBrKSAqIHBpbS55LFxuICAgICAgfTtcbiAgICB9XG4gICAgbnBba10gPSBwW2sgLSAxXTtcbiAgICByZXR1cm4gbmV3IEJlemllcihucCk7XG4gIH1cblxuICBkZXJpdmF0aXZlKHQpIHtcbiAgICByZXR1cm4gdXRpbHMuY29tcHV0ZSh0LCB0aGlzLmRwb2ludHNbMF0sIHRoaXMuXzNkKTtcbiAgfVxuXG4gIGRkZXJpdmF0aXZlKHQpIHtcbiAgICByZXR1cm4gdXRpbHMuY29tcHV0ZSh0LCB0aGlzLmRwb2ludHNbMV0sIHRoaXMuXzNkKTtcbiAgfVxuXG4gIGFsaWduKCkge1xuICAgIGxldCBwID0gdGhpcy5wb2ludHM7XG4gICAgcmV0dXJuIG5ldyBCZXppZXIodXRpbHMuYWxpZ24ocCwgeyBwMTogcFswXSwgcDI6IHBbcC5sZW5ndGggLSAxXSB9KSk7XG4gIH1cblxuICBjdXJ2YXR1cmUodCkge1xuICAgIHJldHVybiB1dGlscy5jdXJ2YXR1cmUodCwgdGhpcy5kcG9pbnRzWzBdLCB0aGlzLmRwb2ludHNbMV0sIHRoaXMuXzNkKTtcbiAgfVxuXG4gIGluZmxlY3Rpb25zKCkge1xuICAgIHJldHVybiB1dGlscy5pbmZsZWN0aW9ucyh0aGlzLnBvaW50cyk7XG4gIH1cblxuICBub3JtYWwodCkge1xuICAgIHJldHVybiB0aGlzLl8zZCA/IHRoaXMuX19ub3JtYWwzKHQpIDogdGhpcy5fX25vcm1hbDIodCk7XG4gIH1cblxuICBfX25vcm1hbDIodCkge1xuICAgIGNvbnN0IGQgPSB0aGlzLmRlcml2YXRpdmUodCk7XG4gICAgY29uc3QgcSA9IHNxcnQoZC54ICogZC54ICsgZC55ICogZC55KTtcbiAgICByZXR1cm4geyB4OiAtZC55IC8gcSwgeTogZC54IC8gcSB9O1xuICB9XG5cbiAgX19ub3JtYWwzKHQpIHtcbiAgICAvLyBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNTQ1MzE1OVxuICAgIGNvbnN0IHIxID0gdGhpcy5kZXJpdmF0aXZlKHQpLFxuICAgICAgcjIgPSB0aGlzLmRlcml2YXRpdmUodCArIDAuMDEpLFxuICAgICAgcTEgPSBzcXJ0KHIxLnggKiByMS54ICsgcjEueSAqIHIxLnkgKyByMS56ICogcjEueiksXG4gICAgICBxMiA9IHNxcnQocjIueCAqIHIyLnggKyByMi55ICogcjIueSArIHIyLnogKiByMi56KTtcbiAgICByMS54IC89IHExO1xuICAgIHIxLnkgLz0gcTE7XG4gICAgcjEueiAvPSBxMTtcbiAgICByMi54IC89IHEyO1xuICAgIHIyLnkgLz0gcTI7XG4gICAgcjIueiAvPSBxMjtcbiAgICAvLyBjcm9zcyBwcm9kdWN0XG4gICAgY29uc3QgYyA9IHtcbiAgICAgIHg6IHIyLnkgKiByMS56IC0gcjIueiAqIHIxLnksXG4gICAgICB5OiByMi56ICogcjEueCAtIHIyLnggKiByMS56LFxuICAgICAgejogcjIueCAqIHIxLnkgLSByMi55ICogcjEueCxcbiAgICB9O1xuICAgIGNvbnN0IG0gPSBzcXJ0KGMueCAqIGMueCArIGMueSAqIGMueSArIGMueiAqIGMueik7XG4gICAgYy54IC89IG07XG4gICAgYy55IC89IG07XG4gICAgYy56IC89IG07XG4gICAgLy8gcm90YXRpb24gbWF0cml4XG4gICAgY29uc3QgUiA9IFtcbiAgICAgIGMueCAqIGMueCxcbiAgICAgIGMueCAqIGMueSAtIGMueixcbiAgICAgIGMueCAqIGMueiArIGMueSxcbiAgICAgIGMueCAqIGMueSArIGMueixcbiAgICAgIGMueSAqIGMueSxcbiAgICAgIGMueSAqIGMueiAtIGMueCxcbiAgICAgIGMueCAqIGMueiAtIGMueSxcbiAgICAgIGMueSAqIGMueiArIGMueCxcbiAgICAgIGMueiAqIGMueixcbiAgICBdO1xuICAgIC8vIG5vcm1hbCB2ZWN0b3I6XG4gICAgY29uc3QgbiA9IHtcbiAgICAgIHg6IFJbMF0gKiByMS54ICsgUlsxXSAqIHIxLnkgKyBSWzJdICogcjEueixcbiAgICAgIHk6IFJbM10gKiByMS54ICsgUls0XSAqIHIxLnkgKyBSWzVdICogcjEueixcbiAgICAgIHo6IFJbNl0gKiByMS54ICsgUls3XSAqIHIxLnkgKyBSWzhdICogcjEueixcbiAgICB9O1xuICAgIHJldHVybiBuO1xuICB9XG5cbiAgaHVsbCh0KSB7XG4gICAgbGV0IHAgPSB0aGlzLnBvaW50cyxcbiAgICAgIF9wID0gW10sXG4gICAgICBxID0gW10sXG4gICAgICBpZHggPSAwO1xuICAgIHFbaWR4KytdID0gcFswXTtcbiAgICBxW2lkeCsrXSA9IHBbMV07XG4gICAgcVtpZHgrK10gPSBwWzJdO1xuICAgIGlmICh0aGlzLm9yZGVyID09PSAzKSB7XG4gICAgICBxW2lkeCsrXSA9IHBbM107XG4gICAgfVxuICAgIC8vIHdlIGxlcnAgYmV0d2VlbiBhbGwgcG9pbnRzIGF0IGVhY2ggaXRlcmF0aW9uLCB1bnRpbCB3ZSBoYXZlIDEgcG9pbnQgbGVmdC5cbiAgICB3aGlsZSAocC5sZW5ndGggPiAxKSB7XG4gICAgICBfcCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIHB0LCBsID0gcC5sZW5ndGggLSAxOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHB0ID0gdXRpbHMubGVycCh0LCBwW2ldLCBwW2kgKyAxXSk7XG4gICAgICAgIHFbaWR4KytdID0gcHQ7XG4gICAgICAgIF9wLnB1c2gocHQpO1xuICAgICAgfVxuICAgICAgcCA9IF9wO1xuICAgIH1cbiAgICByZXR1cm4gcTtcbiAgfVxuXG4gIHNwbGl0KHQxLCB0Mikge1xuICAgIC8vIHNob3J0Y3V0c1xuICAgIGlmICh0MSA9PT0gMCAmJiAhIXQyKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGxpdCh0MikubGVmdDtcbiAgICB9XG4gICAgaWYgKHQyID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGxpdCh0MSkucmlnaHQ7XG4gICAgfVxuXG4gICAgLy8gbm8gc2hvcnRjdXQ6IHVzZSBcImRlIENhc3RlbGphdVwiIGl0ZXJhdGlvbi5cbiAgICBjb25zdCBxID0gdGhpcy5odWxsKHQxKTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBsZWZ0OlxuICAgICAgICB0aGlzLm9yZGVyID09PSAyXG4gICAgICAgICAgPyBuZXcgQmV6aWVyKFtxWzBdLCBxWzNdLCBxWzVdXSlcbiAgICAgICAgICA6IG5ldyBCZXppZXIoW3FbMF0sIHFbNF0sIHFbN10sIHFbOV1dKSxcbiAgICAgIHJpZ2h0OlxuICAgICAgICB0aGlzLm9yZGVyID09PSAyXG4gICAgICAgICAgPyBuZXcgQmV6aWVyKFtxWzVdLCBxWzRdLCBxWzJdXSlcbiAgICAgICAgICA6IG5ldyBCZXppZXIoW3FbOV0sIHFbOF0sIHFbNl0sIHFbM11dKSxcbiAgICAgIHNwYW46IHEsXG4gICAgfTtcblxuICAgIC8vIG1ha2Ugc3VyZSB3ZSBiaW5kIF90MS9fdDIgaW5mb3JtYXRpb24hXG4gICAgcmVzdWx0LmxlZnQuX3QxID0gdXRpbHMubWFwKDAsIDAsIDEsIHRoaXMuX3QxLCB0aGlzLl90Mik7XG4gICAgcmVzdWx0LmxlZnQuX3QyID0gdXRpbHMubWFwKHQxLCAwLCAxLCB0aGlzLl90MSwgdGhpcy5fdDIpO1xuICAgIHJlc3VsdC5yaWdodC5fdDEgPSB1dGlscy5tYXAodDEsIDAsIDEsIHRoaXMuX3QxLCB0aGlzLl90Mik7XG4gICAgcmVzdWx0LnJpZ2h0Ll90MiA9IHV0aWxzLm1hcCgxLCAwLCAxLCB0aGlzLl90MSwgdGhpcy5fdDIpO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBubyB0Miwgd2UncmUgZG9uZVxuICAgIGlmICghdDIpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBhIHQyLCBzcGxpdCBhZ2FpbjpcbiAgICB0MiA9IHV0aWxzLm1hcCh0MiwgdDEsIDEsIDAsIDEpO1xuICAgIHJldHVybiByZXN1bHQucmlnaHQuc3BsaXQodDIpLmxlZnQ7XG4gIH1cblxuICBleHRyZW1hKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGxldCByb290cyA9IFtdO1xuXG4gICAgdGhpcy5kaW1zLmZvckVhY2goXG4gICAgICBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgIGxldCBtZm4gPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgIHJldHVybiB2W2RpbV07XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwID0gdGhpcy5kcG9pbnRzWzBdLm1hcChtZm4pO1xuICAgICAgICByZXN1bHRbZGltXSA9IHV0aWxzLmRyb290cyhwKTtcbiAgICAgICAgaWYgKHRoaXMub3JkZXIgPT09IDMpIHtcbiAgICAgICAgICBwID0gdGhpcy5kcG9pbnRzWzFdLm1hcChtZm4pO1xuICAgICAgICAgIHJlc3VsdFtkaW1dID0gcmVzdWx0W2RpbV0uY29uY2F0KHV0aWxzLmRyb290cyhwKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2RpbV0gPSByZXN1bHRbZGltXS5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdCA+PSAwICYmIHQgPD0gMTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJvb3RzID0gcm9vdHMuY29uY2F0KHJlc3VsdFtkaW1dLnNvcnQodXRpbHMubnVtYmVyU29ydCkpO1xuICAgICAgfS5iaW5kKHRoaXMpXG4gICAgKTtcblxuICAgIHJlc3VsdC52YWx1ZXMgPSByb290cy5zb3J0KHV0aWxzLm51bWJlclNvcnQpLmZpbHRlcihmdW5jdGlvbiAodiwgaWR4KSB7XG4gICAgICByZXR1cm4gcm9vdHMuaW5kZXhPZih2KSA9PT0gaWR4O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGJib3goKSB7XG4gICAgY29uc3QgZXh0cmVtYSA9IHRoaXMuZXh0cmVtYSgpLFxuICAgICAgcmVzdWx0ID0ge307XG4gICAgdGhpcy5kaW1zLmZvckVhY2goXG4gICAgICBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXN1bHRbZF0gPSB1dGlscy5nZXRtaW5tYXgodGhpcywgZCwgZXh0cmVtYVtkXSk7XG4gICAgICB9LmJpbmQodGhpcylcbiAgICApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBvdmVybGFwcyhjdXJ2ZSkge1xuICAgIGNvbnN0IGxiYm94ID0gdGhpcy5iYm94KCksXG4gICAgICB0YmJveCA9IGN1cnZlLmJib3goKTtcbiAgICByZXR1cm4gdXRpbHMuYmJveG92ZXJsYXAobGJib3gsIHRiYm94KTtcbiAgfVxuXG4gIG9mZnNldCh0LCBkKSB7XG4gICAgaWYgKHR5cGVvZiBkICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjb25zdCBjID0gdGhpcy5nZXQodCksXG4gICAgICAgIG4gPSB0aGlzLm5vcm1hbCh0KTtcbiAgICAgIGNvbnN0IHJldCA9IHtcbiAgICAgICAgYzogYyxcbiAgICAgICAgbjogbixcbiAgICAgICAgeDogYy54ICsgbi54ICogZCxcbiAgICAgICAgeTogYy55ICsgbi55ICogZCxcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5fM2QpIHtcbiAgICAgICAgcmV0LnogPSBjLnogKyBuLnogKiBkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpbmVhcikge1xuICAgICAgY29uc3QgbnYgPSB0aGlzLm5vcm1hbCgwKSxcbiAgICAgICAgY29vcmRzID0gdGhpcy5wb2ludHMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgY29uc3QgcmV0ID0ge1xuICAgICAgICAgICAgeDogcC54ICsgdCAqIG52LngsXG4gICAgICAgICAgICB5OiBwLnkgKyB0ICogbnYueSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChwLnogJiYgbnYueikge1xuICAgICAgICAgICAgcmV0LnogPSBwLnogKyB0ICogbnYuejtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSk7XG4gICAgICByZXR1cm4gW25ldyBCZXppZXIoY29vcmRzKV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlZHVjZSgpLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgaWYgKHMuX2xpbmVhcikge1xuICAgICAgICByZXR1cm4gcy5vZmZzZXQodClbMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcy5zY2FsZSh0KTtcbiAgICB9KTtcbiAgfVxuXG4gIHNpbXBsZSgpIHtcbiAgICBpZiAodGhpcy5vcmRlciA9PT0gMykge1xuICAgICAgY29uc3QgYTEgPSB1dGlscy5hbmdsZSh0aGlzLnBvaW50c1swXSwgdGhpcy5wb2ludHNbM10sIHRoaXMucG9pbnRzWzFdKTtcbiAgICAgIGNvbnN0IGEyID0gdXRpbHMuYW5nbGUodGhpcy5wb2ludHNbMF0sIHRoaXMucG9pbnRzWzNdLCB0aGlzLnBvaW50c1syXSk7XG4gICAgICBpZiAoKGExID4gMCAmJiBhMiA8IDApIHx8IChhMSA8IDAgJiYgYTIgPiAwKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBuMSA9IHRoaXMubm9ybWFsKDApO1xuICAgIGNvbnN0IG4yID0gdGhpcy5ub3JtYWwoMSk7XG4gICAgbGV0IHMgPSBuMS54ICogbjIueCArIG4xLnkgKiBuMi55O1xuICAgIGlmICh0aGlzLl8zZCkge1xuICAgICAgcyArPSBuMS56ICogbjIuejtcbiAgICB9XG4gICAgcmV0dXJuIGFicyhhY29zKHMpKSA8IHBpIC8gMztcbiAgfVxuXG4gIHJlZHVjZSgpIHtcbiAgICAvLyBUT0RPOiBleGFtaW5lIHRoZXNlIHZhciB0eXBlcyBpbiBtb3JlIGRldGFpbC4uLlxuICAgIGxldCBpLFxuICAgICAgdDEgPSAwLFxuICAgICAgdDIgPSAwLFxuICAgICAgc3RlcCA9IDAuMDEsXG4gICAgICBzZWdtZW50LFxuICAgICAgcGFzczEgPSBbXSxcbiAgICAgIHBhc3MyID0gW107XG4gICAgLy8gZmlyc3QgcGFzczogc3BsaXQgb24gZXh0cmVtYVxuICAgIGxldCBleHRyZW1hID0gdGhpcy5leHRyZW1hKCkudmFsdWVzO1xuICAgIGlmIChleHRyZW1hLmluZGV4T2YoMCkgPT09IC0xKSB7XG4gICAgICBleHRyZW1hID0gWzBdLmNvbmNhdChleHRyZW1hKTtcbiAgICB9XG4gICAgaWYgKGV4dHJlbWEuaW5kZXhPZigxKSA9PT0gLTEpIHtcbiAgICAgIGV4dHJlbWEucHVzaCgxKTtcbiAgICB9XG5cbiAgICBmb3IgKHQxID0gZXh0cmVtYVswXSwgaSA9IDE7IGkgPCBleHRyZW1hLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0MiA9IGV4dHJlbWFbaV07XG4gICAgICBzZWdtZW50ID0gdGhpcy5zcGxpdCh0MSwgdDIpO1xuICAgICAgc2VnbWVudC5fdDEgPSB0MTtcbiAgICAgIHNlZ21lbnQuX3QyID0gdDI7XG4gICAgICBwYXNzMS5wdXNoKHNlZ21lbnQpO1xuICAgICAgdDEgPSB0MjtcbiAgICB9XG5cbiAgICAvLyBzZWNvbmQgcGFzczogZnVydGhlciByZWR1Y2UgdGhlc2Ugc2VnbWVudHMgdG8gc2ltcGxlIHNlZ21lbnRzXG4gICAgcGFzczEuZm9yRWFjaChmdW5jdGlvbiAocDEpIHtcbiAgICAgIHQxID0gMDtcbiAgICAgIHQyID0gMDtcbiAgICAgIHdoaWxlICh0MiA8PSAxKSB7XG4gICAgICAgIGZvciAodDIgPSB0MSArIHN0ZXA7IHQyIDw9IDEgKyBzdGVwOyB0MiArPSBzdGVwKSB7XG4gICAgICAgICAgc2VnbWVudCA9IHAxLnNwbGl0KHQxLCB0Mik7XG4gICAgICAgICAgaWYgKCFzZWdtZW50LnNpbXBsZSgpKSB7XG4gICAgICAgICAgICB0MiAtPSBzdGVwO1xuICAgICAgICAgICAgaWYgKGFicyh0MSAtIHQyKSA8IHN0ZXApIHtcbiAgICAgICAgICAgICAgLy8gd2UgY2FuIG5ldmVyIGZvcm0gYSByZWR1Y3Rpb25cbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VnbWVudCA9IHAxLnNwbGl0KHQxLCB0Mik7XG4gICAgICAgICAgICBzZWdtZW50Ll90MSA9IHV0aWxzLm1hcCh0MSwgMCwgMSwgcDEuX3QxLCBwMS5fdDIpO1xuICAgICAgICAgICAgc2VnbWVudC5fdDIgPSB1dGlscy5tYXAodDIsIDAsIDEsIHAxLl90MSwgcDEuX3QyKTtcbiAgICAgICAgICAgIHBhc3MyLnB1c2goc2VnbWVudCk7XG4gICAgICAgICAgICB0MSA9IHQyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodDEgPCAxKSB7XG4gICAgICAgIHNlZ21lbnQgPSBwMS5zcGxpdCh0MSwgMSk7XG4gICAgICAgIHNlZ21lbnQuX3QxID0gdXRpbHMubWFwKHQxLCAwLCAxLCBwMS5fdDEsIHAxLl90Mik7XG4gICAgICAgIHNlZ21lbnQuX3QyID0gcDEuX3QyO1xuICAgICAgICBwYXNzMi5wdXNoKHNlZ21lbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwYXNzMjtcbiAgfVxuXG4gIHNjYWxlKGQpIHtcbiAgICBjb25zdCBvcmRlciA9IHRoaXMub3JkZXI7XG4gICAgbGV0IGRpc3RhbmNlRm4gPSBmYWxzZTtcbiAgICBpZiAodHlwZW9mIGQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZGlzdGFuY2VGbiA9IGQ7XG4gICAgfVxuICAgIGlmIChkaXN0YW5jZUZuICYmIG9yZGVyID09PSAyKSB7XG4gICAgICByZXR1cm4gdGhpcy5yYWlzZSgpLnNjYWxlKGRpc3RhbmNlRm4pO1xuICAgIH1cblxuICAgIC8vIFRPRE86IGFkZCBzcGVjaWFsIGhhbmRsaW5nIGZvciBkZWdlbmVyYXRlICg9bGluZWFyKSBjdXJ2ZXMuXG4gICAgY29uc3QgY2xvY2t3aXNlID0gdGhpcy5jbG9ja3dpc2U7XG4gICAgY29uc3QgcjEgPSBkaXN0YW5jZUZuID8gZGlzdGFuY2VGbigwKSA6IGQ7XG4gICAgY29uc3QgcjIgPSBkaXN0YW5jZUZuID8gZGlzdGFuY2VGbigxKSA6IGQ7XG4gICAgY29uc3QgdiA9IFt0aGlzLm9mZnNldCgwLCAxMCksIHRoaXMub2Zmc2V0KDEsIDEwKV07XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgY29uc3QgbnAgPSBbXTtcbiAgICBjb25zdCBvID0gdXRpbHMubGxpNCh2WzBdLCB2WzBdLmMsIHZbMV0sIHZbMV0uYyk7XG5cbiAgICBpZiAoIW8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBzY2FsZSB0aGlzIGN1cnZlLiBUcnkgcmVkdWNpbmcgaXQgZmlyc3QuXCIpO1xuICAgIH1cbiAgICAvLyBtb3ZlIGFsbCBwb2ludHMgYnkgZGlzdGFuY2UgJ2QnIHdydCB0aGUgb3JpZ2luICdvJ1xuXG4gICAgLy8gbW92ZSBlbmQgcG9pbnRzIGJ5IGZpeGVkIGRpc3RhbmNlIGFsb25nIG5vcm1hbC5cbiAgICBbMCwgMV0uZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgY29uc3QgcCA9IChucFt0ICogb3JkZXJdID0gdXRpbHMuY29weShwb2ludHNbdCAqIG9yZGVyXSkpO1xuICAgICAgcC54ICs9ICh0ID8gcjIgOiByMSkgKiB2W3RdLm4ueDtcbiAgICAgIHAueSArPSAodCA/IHIyIDogcjEpICogdlt0XS5uLnk7XG4gICAgfSk7XG5cbiAgICBpZiAoIWRpc3RhbmNlRm4pIHtcbiAgICAgIC8vIG1vdmUgY29udHJvbCBwb2ludHMgdG8gbGllIG9uIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIG9mZnNldFxuICAgICAgLy8gZGVyaXZhdGl2ZSB2ZWN0b3IsIGFuZCB0aGUgb3JpZ2luLXRocm91Z2gtY29udHJvbCB2ZWN0b3JcbiAgICAgIFswLCAxXS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgIGlmIChvcmRlciA9PT0gMiAmJiAhIXQpIHJldHVybjtcbiAgICAgICAgY29uc3QgcCA9IG5wW3QgKiBvcmRlcl07XG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmRlcml2YXRpdmUodCk7XG4gICAgICAgIGNvbnN0IHAyID0geyB4OiBwLnggKyBkLngsIHk6IHAueSArIGQueSB9O1xuICAgICAgICBucFt0ICsgMV0gPSB1dGlscy5sbGk0KHAsIHAyLCBvLCBwb2ludHNbdCArIDFdKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBCZXppZXIobnApO1xuICAgIH1cblxuICAgIC8vIG1vdmUgY29udHJvbCBwb2ludHMgYnkgXCJob3dldmVyIG11Y2ggbmVjZXNzYXJ5IHRvXG4gICAgLy8gZW5zdXJlIHRoZSBjb3JyZWN0IHRhbmdlbnQgdG8gZW5kcG9pbnRcIi5cbiAgICBbMCwgMV0uZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKG9yZGVyID09PSAyICYmICEhdCkgcmV0dXJuO1xuICAgICAgdmFyIHAgPSBwb2ludHNbdCArIDFdO1xuICAgICAgdmFyIG92ID0ge1xuICAgICAgICB4OiBwLnggLSBvLngsXG4gICAgICAgIHk6IHAueSAtIG8ueSxcbiAgICAgIH07XG4gICAgICB2YXIgcmMgPSBkaXN0YW5jZUZuID8gZGlzdGFuY2VGbigodCArIDEpIC8gb3JkZXIpIDogZDtcbiAgICAgIGlmIChkaXN0YW5jZUZuICYmICFjbG9ja3dpc2UpIHJjID0gLXJjO1xuICAgICAgdmFyIG0gPSBzcXJ0KG92LnggKiBvdi54ICsgb3YueSAqIG92LnkpO1xuICAgICAgb3YueCAvPSBtO1xuICAgICAgb3YueSAvPSBtO1xuICAgICAgbnBbdCArIDFdID0ge1xuICAgICAgICB4OiBwLnggKyByYyAqIG92LngsXG4gICAgICAgIHk6IHAueSArIHJjICogb3YueSxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBCZXppZXIobnApO1xuICB9XG5cbiAgb3V0bGluZShkMSwgZDIsIGQzLCBkNCkge1xuICAgIGQyID0gdHlwZW9mIGQyID09PSBcInVuZGVmaW5lZFwiID8gZDEgOiBkMjtcbiAgICBjb25zdCByZWR1Y2VkID0gdGhpcy5yZWR1Y2UoKSxcbiAgICAgIGxlbiA9IHJlZHVjZWQubGVuZ3RoLFxuICAgICAgZmN1cnZlcyA9IFtdO1xuXG4gICAgbGV0IGJjdXJ2ZXMgPSBbXSxcbiAgICAgIHAsXG4gICAgICBhbGVuID0gMCxcbiAgICAgIHRsZW4gPSB0aGlzLmxlbmd0aCgpO1xuXG4gICAgY29uc3QgZ3JhZHVhdGVkID0gdHlwZW9mIGQzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBkNCAhPT0gXCJ1bmRlZmluZWRcIjtcblxuICAgIGZ1bmN0aW9uIGxpbmVhckRpc3RhbmNlRnVuY3Rpb24ocywgZSwgdGxlbiwgYWxlbiwgc2xlbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGNvbnN0IGYxID0gYWxlbiAvIHRsZW4sXG4gICAgICAgICAgZjIgPSAoYWxlbiArIHNsZW4pIC8gdGxlbixcbiAgICAgICAgICBkID0gZSAtIHM7XG4gICAgICAgIHJldHVybiB1dGlscy5tYXAodiwgMCwgMSwgcyArIGYxICogZCwgcyArIGYyICogZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGZvcm0gY3VydmUgb3VsaW5lc1xuICAgIHJlZHVjZWQuZm9yRWFjaChmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgICAgY29uc3Qgc2xlbiA9IHNlZ21lbnQubGVuZ3RoKCk7XG4gICAgICBpZiAoZ3JhZHVhdGVkKSB7XG4gICAgICAgIGZjdXJ2ZXMucHVzaChcbiAgICAgICAgICBzZWdtZW50LnNjYWxlKGxpbmVhckRpc3RhbmNlRnVuY3Rpb24oZDEsIGQzLCB0bGVuLCBhbGVuLCBzbGVuKSlcbiAgICAgICAgKTtcbiAgICAgICAgYmN1cnZlcy5wdXNoKFxuICAgICAgICAgIHNlZ21lbnQuc2NhbGUobGluZWFyRGlzdGFuY2VGdW5jdGlvbigtZDIsIC1kNCwgdGxlbiwgYWxlbiwgc2xlbikpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmY3VydmVzLnB1c2goc2VnbWVudC5zY2FsZShkMSkpO1xuICAgICAgICBiY3VydmVzLnB1c2goc2VnbWVudC5zY2FsZSgtZDIpKTtcbiAgICAgIH1cbiAgICAgIGFsZW4gKz0gc2xlbjtcbiAgICB9KTtcblxuICAgIC8vIHJldmVyc2UgdGhlIFwicmV0dXJuXCIgb3V0bGluZVxuICAgIGJjdXJ2ZXMgPSBiY3VydmVzXG4gICAgICAubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHAgPSBzLnBvaW50cztcbiAgICAgICAgaWYgKHBbM10pIHtcbiAgICAgICAgICBzLnBvaW50cyA9IFtwWzNdLCBwWzJdLCBwWzFdLCBwWzBdXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzLnBvaW50cyA9IFtwWzJdLCBwWzFdLCBwWzBdXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICAgIH0pXG4gICAgICAucmV2ZXJzZSgpO1xuXG4gICAgLy8gZm9ybSB0aGUgZW5kY2FwcyBhcyBsaW5lc1xuICAgIGNvbnN0IGZzID0gZmN1cnZlc1swXS5wb2ludHNbMF0sXG4gICAgICBmZSA9IGZjdXJ2ZXNbbGVuIC0gMV0ucG9pbnRzW2ZjdXJ2ZXNbbGVuIC0gMV0ucG9pbnRzLmxlbmd0aCAtIDFdLFxuICAgICAgYnMgPSBiY3VydmVzW2xlbiAtIDFdLnBvaW50c1tiY3VydmVzW2xlbiAtIDFdLnBvaW50cy5sZW5ndGggLSAxXSxcbiAgICAgIGJlID0gYmN1cnZlc1swXS5wb2ludHNbMF0sXG4gICAgICBscyA9IHV0aWxzLm1ha2VsaW5lKGJzLCBmcyksXG4gICAgICBsZSA9IHV0aWxzLm1ha2VsaW5lKGZlLCBiZSksXG4gICAgICBzZWdtZW50cyA9IFtsc10uY29uY2F0KGZjdXJ2ZXMpLmNvbmNhdChbbGVdKS5jb25jYXQoYmN1cnZlcyksXG4gICAgICBzbGVuID0gc2VnbWVudHMubGVuZ3RoO1xuXG4gICAgcmV0dXJuIG5ldyBQb2x5QmV6aWVyKHNlZ21lbnRzKTtcbiAgfVxuXG4gIG91dGxpbmVzaGFwZXMoZDEsIGQyLCBjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZCkge1xuICAgIGQyID0gZDIgfHwgZDE7XG4gICAgY29uc3Qgb3V0bGluZSA9IHRoaXMub3V0bGluZShkMSwgZDIpLmN1cnZlcztcbiAgICBjb25zdCBzaGFwZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMSwgbGVuID0gb3V0bGluZS5sZW5ndGg7IGkgPCBsZW4gLyAyOyBpKyspIHtcbiAgICAgIGNvbnN0IHNoYXBlID0gdXRpbHMubWFrZXNoYXBlKFxuICAgICAgICBvdXRsaW5lW2ldLFxuICAgICAgICBvdXRsaW5lW2xlbiAtIGldLFxuICAgICAgICBjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZFxuICAgICAgKTtcbiAgICAgIHNoYXBlLnN0YXJ0Y2FwLnZpcnR1YWwgPSBpID4gMTtcbiAgICAgIHNoYXBlLmVuZGNhcC52aXJ0dWFsID0gaSA8IGxlbiAvIDIgLSAxO1xuICAgICAgc2hhcGVzLnB1c2goc2hhcGUpO1xuICAgIH1cbiAgICByZXR1cm4gc2hhcGVzO1xuICB9XG5cbiAgaW50ZXJzZWN0cyhjdXJ2ZSwgY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGQpIHtcbiAgICBpZiAoIWN1cnZlKSByZXR1cm4gdGhpcy5zZWxmaW50ZXJzZWN0cyhjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZCk7XG4gICAgaWYgKGN1cnZlLnAxICYmIGN1cnZlLnAyKSB7XG4gICAgICByZXR1cm4gdGhpcy5saW5lSW50ZXJzZWN0cyhjdXJ2ZSk7XG4gICAgfVxuICAgIGlmIChjdXJ2ZSBpbnN0YW5jZW9mIEJlemllcikge1xuICAgICAgY3VydmUgPSBjdXJ2ZS5yZWR1Y2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3VydmVpbnRlcnNlY3RzKFxuICAgICAgdGhpcy5yZWR1Y2UoKSxcbiAgICAgIGN1cnZlLFxuICAgICAgY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGRcbiAgICApO1xuICB9XG5cbiAgbGluZUludGVyc2VjdHMobGluZSkge1xuICAgIGNvbnN0IG14ID0gbWluKGxpbmUucDEueCwgbGluZS5wMi54KSxcbiAgICAgIG15ID0gbWluKGxpbmUucDEueSwgbGluZS5wMi55KSxcbiAgICAgIE1YID0gbWF4KGxpbmUucDEueCwgbGluZS5wMi54KSxcbiAgICAgIE1ZID0gbWF4KGxpbmUucDEueSwgbGluZS5wMi55KTtcbiAgICByZXR1cm4gdXRpbHMucm9vdHModGhpcy5wb2ludHMsIGxpbmUpLmZpbHRlcigodCkgPT4ge1xuICAgICAgdmFyIHAgPSB0aGlzLmdldCh0KTtcbiAgICAgIHJldHVybiB1dGlscy5iZXR3ZWVuKHAueCwgbXgsIE1YKSAmJiB1dGlscy5iZXR3ZWVuKHAueSwgbXksIE1ZKTtcbiAgICB9KTtcbiAgfVxuXG4gIHNlbGZpbnRlcnNlY3RzKGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkKSB7XG4gICAgLy8gXCJzaW1wbGVcIiBjdXJ2ZXMgY2Fubm90IGludGVyc2VjdCB3aXRoIHRoZWlyIGRpcmVjdFxuICAgIC8vIG5laWdoYm91ciwgc28gZm9yIGVhY2ggc2VnbWVudCBYIHdlIGNoZWNrIHdoZXRoZXJcbiAgICAvLyBpdCBpbnRlcnNlY3RzIFswOngtMl1beCsyOmxhc3RdLlxuXG4gICAgY29uc3QgcmVkdWNlZCA9IHRoaXMucmVkdWNlKCksXG4gICAgICBsZW4gPSByZWR1Y2VkLmxlbmd0aCAtIDIsXG4gICAgICByZXN1bHRzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMCwgcmVzdWx0LCBsZWZ0LCByaWdodDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBsZWZ0ID0gcmVkdWNlZC5zbGljZShpLCBpICsgMSk7XG4gICAgICByaWdodCA9IHJlZHVjZWQuc2xpY2UoaSArIDIpO1xuICAgICAgcmVzdWx0ID0gdGhpcy5jdXJ2ZWludGVyc2VjdHMobGVmdCwgcmlnaHQsIGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkKTtcbiAgICAgIHJlc3VsdHMucHVzaCguLi5yZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIGN1cnZlaW50ZXJzZWN0cyhjMSwgYzIsIGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkKSB7XG4gICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICAvLyBzdGVwIDE6IHBhaXIgb2ZmIGFueSBvdmVybGFwcGluZyBzZWdtZW50c1xuICAgIGMxLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcbiAgICAgIGMyLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgaWYgKGwub3ZlcmxhcHMocikpIHtcbiAgICAgICAgICBwYWlycy5wdXNoKHsgbGVmdDogbCwgcmlnaHQ6IHIgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIHN0ZXAgMjogZm9yIGVhY2ggcGFpcmluZywgcnVuIHRocm91Z2ggdGhlIGNvbnZlcmdlbmNlIGFsZ29yaXRobS5cbiAgICBsZXQgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICAgIHBhaXJzLmZvckVhY2goZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHV0aWxzLnBhaXJpdGVyYXRpb24oXG4gICAgICAgIHBhaXIubGVmdCxcbiAgICAgICAgcGFpci5yaWdodCxcbiAgICAgICAgY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGRcbiAgICAgICk7XG4gICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgaW50ZXJzZWN0aW9ucyA9IGludGVyc2VjdGlvbnMuY29uY2F0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH1cblxuICBhcmNzKGVycm9yVGhyZXNob2xkKSB7XG4gICAgZXJyb3JUaHJlc2hvbGQgPSBlcnJvclRocmVzaG9sZCB8fCAwLjU7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZXJhdGUoZXJyb3JUaHJlc2hvbGQsIFtdKTtcbiAgfVxuXG4gIF9lcnJvcihwYywgbnAxLCBzLCBlKSB7XG4gICAgY29uc3QgcSA9IChlIC0gcykgLyA0LFxuICAgICAgYzEgPSB0aGlzLmdldChzICsgcSksXG4gICAgICBjMiA9IHRoaXMuZ2V0KGUgLSBxKSxcbiAgICAgIHJlZiA9IHV0aWxzLmRpc3QocGMsIG5wMSksXG4gICAgICBkMSA9IHV0aWxzLmRpc3QocGMsIGMxKSxcbiAgICAgIGQyID0gdXRpbHMuZGlzdChwYywgYzIpO1xuICAgIHJldHVybiBhYnMoZDEgLSByZWYpICsgYWJzKGQyIC0gcmVmKTtcbiAgfVxuXG4gIF9pdGVyYXRlKGVycm9yVGhyZXNob2xkLCBjaXJjbGVzKSB7XG4gICAgbGV0IHRfcyA9IDAsXG4gICAgICB0X2UgPSAxLFxuICAgICAgc2FmZXR5O1xuICAgIC8vIHdlIGRvIGEgYmluYXJ5IHNlYXJjaCB0byBmaW5kIHRoZSBcImdvb2QgYHRgIGNsb3Nlc3QgdG8gbm8tbG9uZ2VyLWdvb2RcIlxuICAgIGRvIHtcbiAgICAgIHNhZmV0eSA9IDA7XG5cbiAgICAgIC8vIHN0ZXAgMTogc3RhcnQgd2l0aCB0aGUgbWF4aW11bSBwb3NzaWJsZSBhcmNcbiAgICAgIHRfZSA9IDE7XG5cbiAgICAgIC8vIHBvaW50czpcbiAgICAgIGxldCBucDEgPSB0aGlzLmdldCh0X3MpLFxuICAgICAgICBucDIsXG4gICAgICAgIG5wMyxcbiAgICAgICAgYXJjLFxuICAgICAgICBwcmV2X2FyYztcblxuICAgICAgLy8gYm9vbGVhbnM6XG4gICAgICBsZXQgY3Vycl9nb29kID0gZmFsc2UsXG4gICAgICAgIHByZXZfZ29vZCA9IGZhbHNlLFxuICAgICAgICBkb25lO1xuXG4gICAgICAvLyBudW1iZXJzOlxuICAgICAgbGV0IHRfbSA9IHRfZSxcbiAgICAgICAgcHJldl9lID0gMSxcbiAgICAgICAgc3RlcCA9IDA7XG5cbiAgICAgIC8vIHN0ZXAgMjogZmluZCB0aGUgYmVzdCBwb3NzaWJsZSBhcmNcbiAgICAgIGRvIHtcbiAgICAgICAgcHJldl9nb29kID0gY3Vycl9nb29kO1xuICAgICAgICBwcmV2X2FyYyA9IGFyYztcbiAgICAgICAgdF9tID0gKHRfcyArIHRfZSkgLyAyO1xuICAgICAgICBzdGVwKys7XG5cbiAgICAgICAgbnAyID0gdGhpcy5nZXQodF9tKTtcbiAgICAgICAgbnAzID0gdGhpcy5nZXQodF9lKTtcblxuICAgICAgICBhcmMgPSB1dGlscy5nZXRjY2VudGVyKG5wMSwgbnAyLCBucDMpO1xuXG4gICAgICAgIC8vYWxzbyBzYXZlIHRoZSB0IHZhbHVlc1xuICAgICAgICBhcmMuaW50ZXJ2YWwgPSB7XG4gICAgICAgICAgc3RhcnQ6IHRfcyxcbiAgICAgICAgICBlbmQ6IHRfZSxcbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgZXJyb3IgPSB0aGlzLl9lcnJvcihhcmMsIG5wMSwgdF9zLCB0X2UpO1xuICAgICAgICBjdXJyX2dvb2QgPSBlcnJvciA8PSBlcnJvclRocmVzaG9sZDtcblxuICAgICAgICBkb25lID0gcHJldl9nb29kICYmICFjdXJyX2dvb2Q7XG4gICAgICAgIGlmICghZG9uZSkgcHJldl9lID0gdF9lO1xuXG4gICAgICAgIC8vIHRoaXMgYXJjIGlzIGZpbmU6IHdlIGNhbiBtb3ZlICdlJyB1cCB0byBzZWUgaWYgd2UgY2FuIGZpbmQgYSB3aWRlciBhcmNcbiAgICAgICAgaWYgKGN1cnJfZ29vZCkge1xuICAgICAgICAgIC8vIGlmIGUgaXMgYWxyZWFkeSBhdCBtYXgsIHRoZW4gd2UncmUgZG9uZSBmb3IgdGhpcyBhcmMuXG4gICAgICAgICAgaWYgKHRfZSA+PSAxKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgY2FwIGF0IHQ9MVxuICAgICAgICAgICAgYXJjLmludGVydmFsLmVuZCA9IHByZXZfZSA9IDE7XG4gICAgICAgICAgICBwcmV2X2FyYyA9IGFyYztcbiAgICAgICAgICAgIC8vIGlmIHdlIGNhcHBlZCB0aGUgYXJjIHNlZ21lbnQgdG8gdD0xIHdlIGFsc28gbmVlZCB0byBtYWtlIHN1cmUgdGhhdFxuICAgICAgICAgICAgLy8gdGhlIGFyYydzIGVuZCBhbmdsZSBpcyBjb3JyZWN0IHdpdGggcmVzcGVjdCB0byB0aGUgYmV6aWVyIGVuZCBwb2ludC5cbiAgICAgICAgICAgIGlmICh0X2UgPiAxKSB7XG4gICAgICAgICAgICAgIGxldCBkID0ge1xuICAgICAgICAgICAgICAgIHg6IGFyYy54ICsgYXJjLnIgKiBjb3MoYXJjLmUpLFxuICAgICAgICAgICAgICAgIHk6IGFyYy55ICsgYXJjLnIgKiBzaW4oYXJjLmUpLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBhcmMuZSArPSB1dGlscy5hbmdsZSh7IHg6IGFyYy54LCB5OiBhcmMueSB9LCBkLCB0aGlzLmdldCgxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaWYgbm90LCBtb3ZlIGl0IHVwIGJ5IGhhbGYgdGhlIGl0ZXJhdGlvbiBkaXN0YW5jZVxuICAgICAgICAgIHRfZSA9IHRfZSArICh0X2UgLSB0X3MpIC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0aGlzIGlzIGEgYmFkIGFyYzogd2UgbmVlZCB0byBtb3ZlICdlJyBkb3duIHRvIGZpbmQgYSBnb29kIGFyY1xuICAgICAgICAgIHRfZSA9IHRfbTtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoIWRvbmUgJiYgc2FmZXR5KysgPCAxMDApO1xuXG4gICAgICBpZiAoc2FmZXR5ID49IDEwMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gY29uc29sZS5sb2coXCJMODM1OiBbRl0gYXJjIGZvdW5kXCIsIHRfcywgcHJldl9lLCBwcmV2X2FyYy54LCBwcmV2X2FyYy55LCBwcmV2X2FyYy5zLCBwcmV2X2FyYy5lKTtcblxuICAgICAgcHJldl9hcmMgPSBwcmV2X2FyYyA/IHByZXZfYXJjIDogYXJjO1xuICAgICAgY2lyY2xlcy5wdXNoKHByZXZfYXJjKTtcbiAgICAgIHRfcyA9IHByZXZfZTtcbiAgICB9IHdoaWxlICh0X2UgPCAxKTtcbiAgICByZXR1cm4gY2lyY2xlcztcbiAgfVxufVxuXG5leHBvcnQgeyBCZXppZXIgfTtcbiIsIi8qKlxuICog5pa55ZCRXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBESVJFQ1RJT04gPSB7XG4gICAgLyoqIFJJR0hUICovXG4gICAgUklHSFQ6IDAsXG4gICAgLyoqIEJPVFRPTSAqL1xuICAgIEJPVFRPTTogMSxcbiAgICAvKiogTEVGVCAqL1xuICAgIExFRlQ6IDIsXG4gICAgLyoqIFRPUCAqL1xuICAgIFRPUDogMyxcbiAgICAvKiogU0VMRiAqL1xuICAgIFNFTEY6IDEwMCxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5leHREaXJlY3Rpb24oZGlyZWN0aW9uLCBjbG9ja3dpc2UpIHtcbiAgICBjb25zdCBuZXh0RGlyID0gKGRpcmVjdGlvbiArIChjbG9ja3dpc2UgPyAxIDogLTEpKSAlIDQ7XG4gICAgcmV0dXJuIG5leHREaXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvcHBvc2l0ZURpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gKGRpcmVjdGlvbiArIDIpICUgNFxufVxuXG5leHBvcnQgY29uc3QgQVBQUk9YSU1BVEUgPSA2O1xuXG5leHBvcnQgY29uc3QgSkZMT1dfTU9ERSA9IHtcbiAgICBERUZBVUxUOiAnREVGQVVMVCcsXG4gICAgTElOS0lORzogJ0xJTktJTkcnLFxufVxuXG5leHBvcnQgY29uc3QgTElORV9ESVIgPSB7XG4gICAgRlJPTTogJ2Zyb20nLFxuICAgIFRPOiAndG8nLFxufSIsImltcG9ydCB7XG4gICAgQmV6aWVyLFxufSBmcm9tICdiZXppZXItanMnO1xuaW1wb3J0IHsgRElSRUNUSU9OIH0gZnJvbSAnLi9jb25zdGFuY2UnO1xuXG4vKipcbiAqIOagueaNrueCueiuoeeul+acgOWwj+WkluaOpeefqeW9olxuICogQHBhcmFtIHtudW1iZXJbXVtdfSBwb2ludHMgLSDngrnpm4blkIhcbiAqIEByZXR1cm4ge09iamVjdH0gZGVtZW5zaW9uIOWuvemrmO+8jOWdkOagh1xuICovXG5leHBvcnQgZnVuY3Rpb24gYm91bmRpbmdfYm94KHBvaW50cykge1xuICAgIGlmKHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG1pbl94ID0gSW5maW5pdHk7IFxuICAgIGxldCBtaW5feSA9IEluZmluaXR5OyBcbiAgICBsZXQgbWF4X3ggPSAtSW5maW5pdHk7IFxuICAgIGxldCBtYXhfeSA9IC1JbmZpbml0eTsgXG4gICAgZm9yKGxldCBpZHggaW4gcG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBwb2ludHNbaWR4XTtcbiAgICAgICAgaWYoaXRlbVswXSA8IG1pbl94KXtcbiAgICAgICAgICAgIG1pbl94ID0gaXRlbVswXVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW1bMF0gPiBtYXhfeCkge1xuICAgICAgICAgICAgbWF4X3ggPSBpdGVtWzBdXG4gICAgICAgIH0gXG5cbiAgICAgICAgaWYgKGl0ZW1bMV0gPCBtaW5feSkge1xuICAgICAgICAgICAgbWluX3kgPSBpdGVtWzFdXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbVsxXSA+IG1heF95KSB7XG4gICAgICAgICAgICBtYXhfeSA9IGl0ZW1bMV1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBwb2ludHM6IFsobWluX3gsbWluX3kpLChtYXhfeCxtaW5feSksKG1heF94LG1heF95KSwobWluX3gsbWF4X3kpXSxcbiAgICAgICAgd2lkdGg6IE1hdGgubWF4KG1heF94IC0gbWluX3gsIDEwKSxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLm1heChtYXhfeSAtIG1pbl95LCAxMCksXG4gICAgICAgIHg6IG1pbl94LFxuICAgICAgICB5OiBtaW5feSxcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNxcih4KSB7XG4gICAgcmV0dXJuIHggKiB4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRpc3QyKHYsIHcpIHtcbiAgICByZXR1cm4gc3FyKHZbMF0gLSB3WzBdKSArIHNxcih2WzFdIC0gd1sxXSk7XG59XG5cbi8vIHAgLSBwb2ludFxuLy8gdiAtIHN0YXJ0IHBvaW50IG9mIHNlZ21lbnRcbi8vIHcgLSBlbmQgcG9pbnQgb2Ygc2VnbWVudFxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RUb1NlZ21lbnRTcXVhcmVkKHAsIHYsIHcpIHtcbiAgICBjb25zdCBsMiA9IGRpc3QyKHYsIHcpO1xuICAgIGlmIChsMiA9PT0gMCkgcmV0dXJuIGRpc3QyKHAsIHYpO1xuICAgIGxldCB0ID0gKChwWzBdIC0gdlswXSkgKiAod1swXSAtIHZbMF0pICsgKHBbMV0gLSB2WzFdKSAqICh3WzFdIC0gdlsxXSkpIC8gbDI7XG4gICAgdCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHQpKTtcbiAgICByZXR1cm4gZGlzdDIocCwgWyB2WzBdICsgdCAqICh3WzBdIC0gdlswXSksIHZbMV0gKyB0ICogKHdbMV0gLSB2WzFdKSBdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1pbkludGVyc2VjdGlvbkJldHdlZW5Ob2RlcyhkbXNmcm9tLCBkbXN0bykge1xuICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgIGZyb21EaXI6IG51bGwsXG4gICAgICAgIGZyb21QOiBudWxsLFxuICAgICAgICB0b0RpcjogbnVsbCxcbiAgICAgICAgdG9QOiBudWxsLFxuICAgICAgICBkaXN0TWluOiBJbmZpbml0eVxuICAgIH1cbiAgICBPYmplY3Qua2V5cyhkbXNmcm9tKS5mb3JFYWNoKGRmID0+IHtcbiAgICAgICAgaWYoKCtkZikgPT09IERJUkVDVElPTi5TRUxGKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBmID0gZG1zZnJvbVtkZl07XG4gICAgICAgIE9iamVjdC5rZXlzKGRtc3RvKS5mb3JFYWNoKGR0ID0+IHtcbiAgICAgICAgICAgIGlmKCgrZHQpID09PSBESVJFQ1RJT04uU0VMRikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwdCA9IGRtc3RvW2R0XTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBkaXN0MihwZiwgcHQpO1xuICAgICAgICAgICAgaWYoZGlzdCA8IG1ldGEuZGlzdE1pbikge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWV0YSwge1xuICAgICAgICAgICAgICAgICAgICBkaXN0TWluOiBkaXN0LFxuICAgICAgICAgICAgICAgICAgICBmcm9tRGlyOiArZGYsXG4gICAgICAgICAgICAgICAgICAgIGZyb21QOiBwZixcbiAgICAgICAgICAgICAgICAgICAgdG9EaXI6ICtkdCxcbiAgICAgICAgICAgICAgICAgICAgdG9QOiBwdCxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH0pO1xuICAgIHJldHVybiBtZXRhO1xufVxuXG4vLyBleHBvcnQgZnVuY3Rpb24gYmV6aWVyUG9pbnRzKHAxLCBwMiwgc3RhcnRfZGlyID0gRElSRUNUSU9OLlRPUCwgZW5kX2RpciA9IERJUkVDVElPTi5UT1AsIGFudGljbG9jayA9IGZhbHNlKSB7XG4vLyAgICAgY29uc3QgaXNTYW1lRGlyZWN0aW9uID0gc3RhcnRfZGlyID09PSBlbmRfZGlyO1xuLy8gICAgIGNvbnN0IGlzVmVydGljYWxTdGFydCA9IFtESVJFQ1RJT04uVE9QLCBESVJFQ1RJT04uQk9UVE9NXS5pbmNsdWRlcyhzdGFydF9kaXIpOyAgIFxuLy8gICAgIGNvbnN0IGlzVmVydGljYWxFbmQgPSBbRElSRUNUSU9OLlRPUCwgRElSRUNUSU9OLkJPVFRPTV0uaW5jbHVkZXMoZW5kX2Rpcik7XG4vLyAgICAgY29uc3QgYXJyb3dzcGFuID0gW0RJUkVDVElPTi5UT1AsIERJUkVDVElPTi5MRUZUXS5pbmNsdWRlcyhlbmRfZGlyKSA/IC01IDogNTtcbi8vICAgICBjb25zdCBlbmRYID0gaXNWZXJ0aWNhbEVuZCA/IHAyWzBdIDogcDJbMF0gKyBhcnJvd3NwYW47XG4vLyAgICAgY29uc3QgZW5kWSA9IGlzVmVydGljYWxFbmQgPyBwMlsxXSArIGFycm93c3BhbiA6IHAyWzFdO1xuLy8gICAgIGlmKGlzU2FtZURpcmVjdGlvbikge1xuLy8gICAgICAgICBsZXQgc3BhbiA9IE1hdGguYWJzKGlzVmVydGljYWxTdGFydCA/IChlbmRZIC0gcDFbMV0pIDogKGVuZFggLSBwMVswXSkpXG4vLyAgICAgICAgIHNwYW4gPSBNYXRoLm1pbihzcGFuLCA1MCk7XG4vLyAgICAgICAgIGNvbnN0IHN5bWIgPSBbRElSRUNUSU9OLlJJR0hULCBESVJFQ1RJT04uQk9UVE9NXS5pbmNsdWRlcyhlbmRfZGlyKVxuLy8gICAgICAgICBzcGFuID0gc3ltYiA/IHNwYW4gOiAtIHNwYW47XG4vLyAgICAgICAgIGNvbnN0IGNwMSA9IGlzVmVydGljYWxTdGFydCA/IFtwMVswXSwgcDFbMV0gKyBzcGFuXSA6IFtwMVswXSArIHNwYW4sIHAxWzFdXTtcbi8vICAgICAgICAgY29uc3QgY3AyID0gaXNWZXJ0aWNhbEVuZCA/IFtlbmRYLCBlbmRZICsgc3Bhbl0gOiBbZW5kWCArIHNwYW4sIGVuZFldO1xuLy8gICAgICAgICByZXR1cm4gWyBcbi8vICAgICAgICAgICAgIC4uLmNwMSxcbi8vICAgICAgICAgICAgIC4uLmNwMixcbi8vICAgICAgICAgICAgIGVuZFgsIGVuZFkgXTtcbi8vICAgICB9XG4vLyAgICAgbGV0IHNwYW5TdGFydCA9IChhbnRpY2xvY2sgPyAtNSA6IDEpICogKGlzVmVydGljYWxTdGFydCA/IChlbmRZIC0gcDFbMV0pIC8gMiA6IChlbmRYIC0gcDFbMF0pIC8gMilcbi8vICAgICBsZXQgc3BhbkVuZCA9IChhbnRpY2xvY2sgPyAtNCA6IDEpICogKGlzVmVydGljYWxFbmQgPyAocDFbMV0gLSBlbmRZKSAvIDIgOiAocDFbMF0gLSBlbmRYKSAvIDIpXG4vLyAgICAgbGV0IHUxID0gc3BhblN0YXJ0IC8gTWF0aC5hYnMoc3BhblN0YXJ0KTtcbi8vICAgICBzcGFuU3RhcnQgPSB1MSAqIE1hdGgubWluKE1hdGguYWJzKHNwYW5TdGFydCksIDUwKTtcbi8vICAgICBsZXQgdTIgPSBzcGFuRW5kIC8gTWF0aC5hYnMoc3BhbkVuZCk7XG4vLyAgICAgc3BhbkVuZCA9IHUyICogTWF0aC5taW4oTWF0aC5hYnMoc3BhbkVuZCksIDUwKTtcbi8vICAgICBjb25zdCBjcDEgPSBpc1ZlcnRpY2FsU3RhcnQgPyBbcDFbMF0sIHAxWzFdICsgc3BhblN0YXJ0XSA6IFtwMVswXSArIHNwYW5TdGFydCwgcDFbMV1dO1xuLy8gICAgIGNvbnN0IGNwMiA9IGlzVmVydGljYWxFbmQgPyBbZW5kWCwgZW5kWSArIHNwYW5FbmRdIDogW2VuZFggKyBzcGFuRW5kLCBlbmRZXTtcbi8vICAgICByZXR1cm4gWyBcbi8vICAgICAgICAgLi4uY3AxLFxuLy8gICAgICAgICAuLi5jcDIsXG4vLyAgICAgICAgIGVuZFgsIGVuZFkgXTtcbi8vIH1cbmZ1bmN0aW9uIF9yZXNvbHZlQ29udHJvbFBvaW50KHAsIGRpciwgc3BhbngsIHNwYW55KXtcbiAgICBpZihkaXIgPT09IERJUkVDVElPTi5UT1Ape1xuICAgICAgICByZXR1cm4gW3BbMF0sIHBbMV0tc3BhbnldXG4gICAgfVxuICAgIGlmKGRpciA9PT0gRElSRUNUSU9OLkJPVFRPTSl7XG4gICAgICAgIHJldHVybiBbcFswXSwgcFsxXStzcGFueV1cbiAgICB9XG4gICAgaWYoZGlyID09PSBESVJFQ1RJT04uTEVGVCl7XG4gICAgICAgIHJldHVybiBbcFswXS1zcGFueCwgcFsxXV1cbiAgICB9XG4gICAgaWYoZGlyID09PSBESVJFQ1RJT04uUklHSFQpe1xuICAgICAgICByZXR1cm4gW3BbMF0rc3BhbngsIHBbMV1dXG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYmV6aWVyUG9pbnRzKHAxLCBwMiwgc3RhcnRfZGlyID0gRElSRUNUSU9OLlRPUCwgZW5kX2RpciA9IERJUkVDVElPTi5UT1AsIG1pblNwYW5YID0gMCwgbWluU3BhblkgPSAwKSB7XG4gICAgY29uc3Qgc3BhbnggPSBNYXRoLm1heChNYXRoLmFicygocDFbMF0gLSBwMlswXSkvMiksIG1pblNwYW5YKTtcbiAgICBjb25zdCBzcGFueSA9IE1hdGgubWF4KE1hdGguYWJzKChwMVsxXSAtIHAyWzFdKS8yKSwgbWluU3BhblkpO1xuICAgIGNvbnN0IGNwMSA9IF9yZXNvbHZlQ29udHJvbFBvaW50KHAxLCBzdGFydF9kaXIsIHNwYW54LCBzcGFueSk7XG4gICAgY29uc3QgY3AyID0gX3Jlc29sdmVDb250cm9sUG9pbnQocDIsIGVuZF9kaXIsIHNwYW54LCBzcGFueSk7XG4gICAgY29uc3QgYXJyb3dzcGFuID0gW0RJUkVDVElPTi5UT1AsIERJUkVDVElPTi5MRUZUXS5pbmNsdWRlcyhlbmRfZGlyKSA/IC01IDogNTtcbiAgICBjb25zdCBpc1ZlcnRpY2FsRW5kID0gW0RJUkVDVElPTi5UT1AsIERJUkVDVElPTi5CT1RUT01dLmluY2x1ZGVzKGVuZF9kaXIpO1xuICAgIGNvbnN0IGVuZFggPSBpc1ZlcnRpY2FsRW5kID8gcDJbMF0gOiBwMlswXSArIGFycm93c3BhbjtcbiAgICBjb25zdCBlbmRZID0gaXNWZXJ0aWNhbEVuZCA/IHAyWzFdICsgYXJyb3dzcGFuIDogcDJbMV07XG4gICAgcmV0dXJuIFsgXG4gICAgICAgIC4uLmNwMSxcbiAgICAgICAgLi4uY3AyLFxuICAgICAgICBlbmRYLCBlbmRZXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJlemllclBvaW50KHQsIFApIHtcbiAgICBjb25zdCBxID0gMS10O1xuICAgIGNvbnN0IHggPSBxKnEqcSpQWzBdICsgMypxKnEqdCpQWzJdICsgMypxKnQqdCpQWzRdICsgdCp0KnQqUFs2XTtcbiAgICBjb25zdCB5ID0gcSpxKnEqUFsxXSArIDMqcSpxKnQqUFszXSArIDMqcSp0KnQqUFs1XSArIHQqdCp0KlBbN107XG4gICAgY29uc3QgdSA9IHEqcSooUFsyXS1QWzBdKSArIDIqdCpxKihQWzRdLVBbMl0pICsgdCp0KihQWzZdLVBbNF0pO1xuICAgIGNvbnN0IHYgPSBxKnEqKFBbM10tUFsxXSkgKyAyKnQqcSooUFs1XS1QWzNdKSArIHQqdCooUFs3XS1QWzVdKTtcbiAgICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKHYsIHUpO1xuICAgIC8vIGNvbnNvbGUubG9nKGFuZ2xlICogMTgwKVxuICAgIC8vIGlmKGFuZ2xlIDwgMCkge1xuICAgIC8vICAgICBhbmdsZSA9IE1hdGguUEkgKyBhbmdsZTtcbiAgICAvLyB9XG4gICAgcmV0dXJuIFt4LCB5LCBhbmdsZV07XG59XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBiZXppZXJQb2ludHMocDEsIHAyLCBzdGFydF92ZWMsIGVuZF92ZWMpIHtcblxuLy8gfVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzdFRvQmV6aWVyU2VnbWVudFNxdWFyZWQocCwgcG9pbnRzKSB7XG4gICAgY29uc3QgYiA9IG5ldyBCZXppZXIoLi4ucG9pbnRzKTtcblxuICAgIGNvbnN0IHBvaW50ID0gYi5wcm9qZWN0KHsgeDogcFswXSwgeTogcFsxXSB9KTtcbiAgICBjb25zdCBkID0gZGlzdDIocCwgWyBwb2ludC54LCBwb2ludC55IF0pO1xuICAgIHJldHVybiBkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmV6aWVyQW5nbGUodCwgc3gsIHN5LCBjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCBleCwgZXkpIHtcbiAgdmFyIGR4ID0gTWF0aC5wb3coMS10LCAyKSooY3AxeC1zeCkgKyAyKnQqKDEtdCkqKGNwMngtY3AxeCkgKyB0ICogdCAqIChleCAtIGNwMngpO1xuICB2YXIgZHkgPSBNYXRoLnBvdygxLXQsIDIpKihjcDF5LXN5KSArIDIqdCooMS10KSooY3AyeS1jcDF5KSArIHQgKiB0ICogKGV5IC0gY3AyeSk7XG4gIHJldHVybiAtTWF0aC5hdGFuMihkeCwgZHkpICsgMC41Kk1hdGguUEk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEluc3RhbmNlSGVpZ2h0KGluc3RhbmNlKSB7XG4gICAgY29uc3QgcmVjdCA9IGluc3RhbmNlLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIC8vIGxldCBtaW5feSA9IEluZmluaXR5O1xuICAgIC8vIGxldCBtYXhfeSA9IC1JbmZpbml0eTtcbiAgICAvLyBsZXQgbWluX3ggPSBJbmZpbml0eTtcbiAgICAvLyBsZXQgbWF4X3ggPSAtSW5maW5pdHk7XG4gICAgLy8gcmVjdC5mb3JFYWNoKHBvaW50ID0+IHtcbiAgICAvLyAgICAgbWF4X3kgPSBNYXRoLm1heChtYXhfeSwgcG9pbnRbMV0pO1xuICAgIC8vICAgICBtaW5feSA9IE1hdGgubWluKG1pbl95LCBwb2ludFsxXSk7XG4gICAgLy8gICAgIG1heF94ID0gTWF0aC5tYXgobWF4X3gsIHBvaW50WzBdKTtcbiAgICAvLyAgICAgbWluX3ggPSBNYXRoLm1pbihtaW5feCwgcG9pbnRbMF0pO1xuICAgIC8vIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGhlaWdodDogcmVjdFszXSAtIHJlY3RbMV0sXG4gICAgICAgIHdpZHRoOiByZWN0WzJdIC0gcmVjdFswXSxcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2x5bGluZVBvaW50cyhwb2ludHMsIHAxLCBwMiwgc3RhcnRfZGlyID0gRElSRUNUSU9OLlRPUCwgZW5kX2RpciA9IERJUkVDVElPTi5UT1AsIG1pblNwYW5YID0gMTAsIG1pblNwYW5ZID0gMTAsIGlzU2VsZikge1xuICAgIGNvbnN0IGRpclNwYW4gPSBNYXRoLmFicyhzdGFydF9kaXIgLSBlbmRfZGlyKTtcbiAgICAvLyBjb25zdCBzcGFueCA9IE1hdGgubWF4KE1hdGguYWJzKChwMVswXSAtIHAyWzBdKS8yKSwgbWluU3BhblgpO1xuICAgIC8vIGNvbnN0IHNwYW55ID0gTWF0aC5tYXgoTWF0aC5hYnMoKHAxWzFdIC0gcDJbMV0pLzIpLCBtaW5TcGFuWSk7XG4gICAgY29uc3QgaXNWZXJ0aWNhbFN0YXJ0ID0gKHN0YXJ0X2RpciA9PT0gRElSRUNUSU9OLlRPUCB8fCBzdGFydF9kaXIgPT09IERJUkVDVElPTi5CT1RUT00pO1xuICAgIHBvaW50cy5sZW5ndGggPSAwO1xuICAgIHN3aXRjaCAoZGlyU3Bhbikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAvLyDpg73mjInlkJHlj7Plpb3kuoZcbiAgICAgICAgICAgIGlmKHN0YXJ0X2RpciA9PT0gRElSRUNUSU9OLlRPUCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLm1pbihwMVsxXSwgcDJbMV0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHlwID0geSAtIG1pblNwYW5ZO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFtwMVswXSwgeXBdKTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChbcDJbMF0sIHlwXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihzdGFydF9kaXIgPT09IERJUkVDVElPTi5CT1RUT00pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5tYXgocDFbMV0sIHAyWzFdKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5cCA9IHkgKyBtaW5TcGFuWTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChbcDFbMF0sIHlwXSk7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goW3AyWzBdLCB5cF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoc3RhcnRfZGlyID09PSBESVJFQ1RJT04uTEVGVCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLm1pbihwMVswXSwgcDJbMF0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHhwID0geCAtIG1pblNwYW5YO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFt4cCwgcDFbMV1dKTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChbeHAsIHAyWzFdXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihzdGFydF9kaXIgPT09IERJUkVDVElPTi5SSUdIVCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLm1heChwMVswXSwgcDJbMF0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHhwID0geCArIG1pblNwYW5YO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFt4cCwgcDFbMV1dKTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChbeHAsIHAyWzFdXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIDM6ICBcbiAgICAgICAgICAgIGlmKGlzU2VsZikge1xuICAgICAgICAgICAgICAgIGlmKCFpc1ZlcnRpY2FsU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goW3AxWzBdICsgbWluU3BhblgsIHAxWzFdXSk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFtwMVswXSArIG1pblNwYW5YLCBwMlsxXSArIG1pblNwYW5ZXSk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFtwMlswXSwgcDJbMV0gKyBtaW5TcGFuWV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFtwMVswXSwgcDFbMV0gKyBtaW5TcGFuWV0pO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChbcDJbMF0gKyBtaW5TcGFuWCwgcDFbMV0gKyBtaW5TcGFuWV0pO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChbcDJbMF0gKyBtaW5TcGFuWCwgcDJbMV1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gaXNWZXJ0aWNhbFN0YXJ0ID8gW3AxWzBdLCBwMlsxXV06IFtwMlswXSwgcDFbMV1dXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNvbnN0IHBtaWRkbGUgPSBbXG4gICAgICAgICAgICAgICAgKHAxWzBdIC0gcDJbMF0pLzIgKyBwMlswXSxcbiAgICAgICAgICAgICAgICAocDFbMV0gLSBwMlsxXSkvMiArIHAyWzFdXG4gICAgICAgICAgICBdOyBcbiAgICAgICAgICAgIGlmKGlzVmVydGljYWxTdGFydCkge1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFtwMVswXSwgcG1pZGRsZVsxXV0pXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goW3AyWzBdLCBwbWlkZGxlWzFdXSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goW3BtaWRkbGVbMF0sIHAxWzFdXSlcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChbcG1pZGRsZVswXSwgcDJbMV1dKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcG9pbnRzLnVuc2hpZnQocDEpO1xuICAgIHBvaW50cy5wdXNoKHAyKTtcbn1cblxuZnVuY3Rpb24gbWludXNWZWMocDEsIHAyKSB7XG4gICAgcmV0dXJuIFtwMVswXSAtIHAyWzBdLCBwMVsxXSAtIHAyWzFdXVxufVxuXG5mdW5jdGlvbiBhYnNWZWModmVjKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh2ZWNbMF0gKiB2ZWNbMF0gKyB2ZWNbMV0gKiB2ZWNbMV0pO1xufVxuXG5mdW5jdGlvbiBzY2FsZVZlYyh2ZWMsIHNjYWxlKSB7XG4gICAgcmV0dXJuIFt2ZWNbMF0gKiBzY2FsZSwgdmVjWzFdICogc2NhbGVdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZVJhZGl1c0Zyb21WZWN0b3IocGJlZm9yZSwgcCwgcG5leHQsIHJhZGl1cykge1xuICAgIGNvbnN0IHZlYzEgPSBtaW51c1ZlYyhwLCBwYmVmb3JlKTtcbiAgICBjb25zdCB2ZWMyID0gbWludXNWZWMocCwgcG5leHQpO1xuICAgIGNvbnN0IGFic1ZlYzEgPSBhYnNWZWModmVjMSk7XG4gICAgY29uc3QgYWJzVmVjMiA9IGFic1ZlYyh2ZWMyKTtcbiAgICBpZighYWJzVmVjMSB8fCAhYWJzVmVjMikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcDE6IG51bGwsXG4gICAgICAgICAgICBwMjogbnVsbCxcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByMSA9IHNjYWxlVmVjKHZlYzEsIHJhZGl1cy9hYnNWZWMxKTtcbiAgICBjb25zdCByMiA9IHNjYWxlVmVjKHZlYzIsIHJhZGl1cy9hYnNWZWMyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwMTogbWludXNWZWMocCwgcjEpLFxuICAgICAgICBwMjogbWludXNWZWMocCwgcjIpLFxuICAgIH1cbn1cbi8vIOefqeW9oumHjeWPoOiuoeeul1xuZXhwb3J0IGZ1bmN0aW9uIGRvT3ZlcmxhcChyZWMxLCByZWMyKSB7XG4gICAgaWYgKHJlYzFbMF0gPT0gcmVjMVsyXSB8fCByZWMxWzFdID09IHJlYzFbM10gfHxcbiAgICAgICAgcmVjMlswXSA9PSByZWMyWzJdIHx8IHJlYzJbMV0gPT0gcmVjMlszXSkge1xuICAgICAgICAvLyB0aGUgbGluZSBjYW5ub3QgaGF2ZSBwb3NpdGl2ZSBvdmVybGFwXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gIShyZWMxWzJdIDw9IHJlYzJbMF0gfHwgICAvLyBsZWZ0XG4gICAgICAgICAgICAgICAgcmVjMVszXSA8PSByZWMyWzFdIHx8ICAgLy8gYm90dG9tXG4gICAgICAgICAgICAgICAgcmVjMVswXSA+PSByZWMyWzJdIHx8ICAgLy8gcmlnaHRcbiAgICAgICAgICAgICAgICByZWMxWzFdID49IHJlYzJbM10pOyAgICAvLyB0b3Bcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUG9seUxpbmVJbnRlcnNlY3Rpb25SZWN0YW5nZShwb2x5bGluZSwgcmVjdCkge1xuICAgIGxldCBwID0gcG9seWxpbmVbMF07XG4gICAgbGV0IGwgPSBwb2x5bGluZS5sZW5ndGg7XG4gICAgbGV0IGkgPSAxO1xuICAgIGNvbnN0IFtsMCwgbDEsIHIwLCByMV0gPSByZWN0O1xuICAgIHdoaWxlIChpIDwgbCkge1xuICAgICAgICBjb25zdCBjcCA9IHBvbHlsaW5lW2ldO1xuICAgICAgICBpZihwWzBdID09PSBjcFswXSkge1xuICAgICAgICAgICAgLy8gdmVydGljYWxcbiAgICAgICAgICAgIGlmKHBbMF0gPCByMCAmJiBwWzBdID4gbDAgXG4gICAgICAgICAgICAgICAgJiYgISgocFsxXSA+IHIxICYmIGNwWzFdID4gcjEpIHx8IChwWzFdIDwgbDEgJiYgY3BbMV0gPCBsMSkpKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhvcml6b250YWxcbiAgICAgICAgICAgIGlmKHBbMV0gPCByMSAmJiBwWzFdID4gbDFcbiAgICAgICAgICAgICAgICAmJiAhKChwWzBdID4gcjAgJiYgY3BbMF0gPiByMCkgfHwgKHBbMF0gPCBsMCAmJiBjcFswXSA8IGwwKSkpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICB9XG4gICAgICAgIHAgPSBjcDtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB0aW1lb3V0ID0gMzAwKXtcbiAgICBsZXQgdGltZXI7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4geyBmdW5jLmNhbGwodGhpcyk7IH0sIHRpbWVvdXQpO1xuICAgIH07XG4gIH1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVCb3VuZGluZ2JveChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM107XG59XG5leHBvcnQgZnVuY3Rpb24gY29weUJvdW5kaW5nYm94KGEsIGIpIHtcbiAgICBhWzBdID0gYlswXTtcbiAgICBhWzFdID0gYlsxXTtcbiAgICBhWzJdID0gYlsyXTtcbiAgICBhWzNdID0gYlszXTtcbn0iLCIvLyBpbXBvcnQgeyBzZXRVbmlxdWVJZCwgZ2V0VW5pcXVlSWQgfSBmcm9tICcuLi91dGlscy9mdW5jdGlvbnMnO1xuLy8gaW1wb3J0IHsgbmV4dERpcmVjdGlvbiB9IGZyb20gJy4uL3V0aWxzL2NvbnN0YW5jZSc7XG4vLyBjb25zdCBtYXJnaW4gPSA1O1xuY29uc3QgaXNoaXRLZXkgPSBTeW1ib2woJ2lzaGl0Jyk7XG5jb25zdCBpc0luVmlld0JveCA9IFN5bWJvbCgnaXNJblZpZXdCb3gnKTtcbi8qKlxuICogQHR5cGVkZWYgSW5zdGFuY2V+Q29uZmlnc1xuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBib3JkZXJXaWR0aCAgICAgIC0g6L6555qE5a695bqmIOm7mOiupOaYryAyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYm9yZGVyQ29sb3IgICAgICAtIOi+ueahhuminOiJsiDpu5jorqQgYmxhY2tcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2xvciAgICAgICAgICAgIC0g5aGr5YWF6aKc6ImyIOm7mOiupCB3aGl0ZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNoYWRvd0NvbG9yICAgICAgLSDpmLTlvbHpopzoibJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzaGFkb3dCbHVyICAgICAgIC0g6Zi05b2x5omp5pWj6IyD5Zu0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gc2hhZG93T2Zmc2V0WCAgICAtIOmYtOW9seWBj+enuyBYXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc2hhZG93T2Zmc2V0WCAgICAtIOmYtOW9seWBj+enuyBZXG4gKi9cblxuLyoqIFxuICog5Zu+5Lit55qE5pyA5bCP5Y2V5YWDXG4gKiBAY29uc3RydWN0b3IgSW5zdGFuY2VcbiAqIEBleHRlbmRzIEV2ZW50VGFyZ2V0XG4gKiBAcGFyYW0ge0luc3RhbmNlfkNvbmZpZ3N9IGNvbmZpZ3MgLSDmnIDlsI/ljZXlhYPnmoTkuIDkupvpgJrnlKjlsZ7mgKfphY3nva5cbiAqL1xuY2xhc3MgSW5zdGFuY2UgZXh0ZW5kcyBFdmVudFRhcmdldHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjb25maWdzKTtcbiAgICAgICAgLy8gdGhpcy5hbmNob3IgPSBjb25maWdzLmFuY2hvciB8fCBbMCwgMF07XG4gICAgICAgIC8vIHRoaXMuYmVsb25ncyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqIEBtZW1iZXIge2Jvb2xlYW59ICAgICAgLSDlhYPntKDlj6/op4Eg6buY6K6kIHRydWUgKi9cbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgLy8gdGhpcy5famZsb3cgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2JlbG9uZ3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXNbaXNoaXRLZXldID0gZmFsc2U7IFxuXG4gICAgICAgIC8qKiBAbWVtYmVyIHtudW1iZXJ9ICAgICAgLSDovrnnmoTlrr3luqYg6buY6K6k5pivIDAgKi9cbiAgICAgICAgdGhpcy5ib3JkZXJXaWR0aCA9ICAgICAgY29uZmlncy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgICAgICAvKiogQG1lbWJlciB7c3RyaW5nfSAgICAgLSDovrnmoYbpopzoibIg6buY6K6kIHRyYW5zcGFyZW50ICovXG4gICAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSAgICAgIGNvbmZpZ3MuYm9yZGVyQ29sb3IgfHwgJ3RyYW5zcGFyZW50JztcbiAgICAgICAgLyoqIEBtZW1iZXIge3N0cmluZ30gICAgIC0g5aGr5YWF6aKc6ImyIOm7mOiupCB0cmFuc3BhcmVudCAqL1xuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9ICBjb25maWdzLmJhY2tncm91bmRDb2xvciB8fCAndHJhbnNwYXJlbnQnO1xuICAgICAgICAvKiogQG1lbWJlciB7c3RyaW5nfSAgICAgLSDpmLTlvbHpopzoibIg56m65bCx5LiN5pi+56S66Zi05b2xICovXG4gICAgICAgIHRoaXMuc2hhZG93Q29sb3IgPSAgICAgIGNvbmZpZ3Muc2hhZG93Q29sb3I7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtzdHJpbmd9ICAgICAtIOmYtOW9seaJqeaVo+iMg+WbtCDpu5jorqQgNSAqL1xuICAgICAgICB0aGlzLnNoYWRvd0JsdXIgID0gICAgICBjb25maWdzLnNoYWRvd0JsdXIgfHwgNTtcbiAgICAgICAgLyoqIEBtZW1iZXIge3N0cmluZ30gICAgIC0g6Zi05b2x5YGP56e7IFggKi9cbiAgICAgICAgdGhpcy5zaGFkb3dPZmZzZXRYID0gICAgY29uZmlncy5zaGFkb3dPZmZzZXRYIHx8IDA7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtzdHJpbmd9ICAgICAtIOmYtOW9seWBj+enuyBZICovXG4gICAgICAgIHRoaXMuc2hhZG93T2Zmc2V0WSA9ICAgIGNvbmZpZ3Muc2hhZG93T2Zmc2V0WSB8fCAwO1xuICAgICAgICAvKiogQG1lbWJlciB7bnVtYmVyfSAgICAgLSDpgI/mmI7luqYgKi9cbiAgICAgICAgdGhpcy5vcGFjaXR5ICA9ICAgICAgICAgY29uZmlncy5vcGFjaXR5IHx8IDFcblxuICAgICAgICB0aGlzLl9ib3VuZGluZ3JlY3QgPSBbMCwwLDAsMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IC0g5b2T5YmN5Y2V5YWD6YCJ5Lit54q25oCBXG4gICAgICovXG4gICAgZ2V0IF9pc1RhcmdldGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT09ICh0aGlzLl9qZmxvdy5fdGFyZ2V0Lmluc3RhbmNlIHx8IHRoaXMuX2pmbG93Ll90YXJnZXQubGluayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IC0g5b2T5YmN5Y2V5YWD56e75Yqo54q25oCBXG4gICAgICovXG4gICAgZ2V0IF9pc01vdmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT09IHRoaXMuX2pmbG93Ll9nZXRNb3ZpbmdUYXJnZXQoKSAmJiB0aGlzLl9qZmxvdy5fdGFyZ2V0LnN0YXR1cy5tb3ZpbmdTdGF0ZTsgLy8g56e75Yqo5LqG5LmL5ZCO5omN6IO96KKr5b2T5YGa56e75Yqo54q25oCBXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59ICAtIOW9k+WJjeWNleWFg+eisOaSnuajgOa1i+eKtuaAgVxuICAgICAqL1xuICAgIGdldCBfaXNIaXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2lzaGl0S2V5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7SkZsb3d9ICAtIGNhbnZhc+S4iiBqZmxvdyDlrp7kvZNcbiAgICAgKi9cbiAgICBnZXQgX2pmbG93KCkge1xuICAgICAgICBpZih0aGlzLl9qZmxvd1Jvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9qZmxvd1Jvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIXRoaXMuX2JlbG9uZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYmVsb25ncy51bmlxdWVOYW1lID09PSAnamZsb3cnID8gdGhpcy5fYmVsb25ncyA6IHRoaXMuX2JlbG9uZ3MuX2pmbG93O1xuICAgIH1cblxuICAgIHNldCBfaXNIaXQoaXNoaXQpIHtcbiAgICAgICAgaWYodGhpc1tpc2hpdEtleV0gIT09IGlzaGl0KSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOm8oOagh+enu+WFpeS6i+S7tlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBldmVudCBJbnN0YW5jZSNtb3VzZWVudGVyXG4gICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtJbnN0YW5jZX0gaW5zdGFuY2UgICAgICAtIOenu+WFpeeahOWvueixoSBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDpvKDmoIfnp7vlh7rkuovku7ZcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXZlbnQgSW5zdGFuY2UjbW91c2VsZWF2ZVxuICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SW5zdGFuY2V9IGluc3RhbmNlICAgICAgLSDnp7vlhaXnmoTlr7nosaEgXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoaXNoaXQgPyAnbW91c2VlbnRlcic6ICdtb3VzZWxlYXZlJyAsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLl9qZmxvd1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW2lzaGl0S2V5XSA9IGlzaGl0OyAvLyB2YWxpZGF0aW9uIGNvdWxkIGJlIGNoZWNrZWQgaGVyZSBzdWNoIGFzIG9ubHkgYWxsb3dpbmcgbm9uIG51bWVyaWNhbCB2YWx1ZXNcbiAgICB9XG5cbiAgICBnZXQgaXNJblZpZXdCb3goKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2lzSW5WaWV3Qm94XTtcbiAgICB9XG5cbiAgICBzZXQgX2lzSW5WaWV3Qm94KHZhbCkge1xuICAgICAgICBjb25zdCBvbGR2YWwgPSB0aGlzW2lzSW5WaWV3Qm94XTtcbiAgICAgICAgaWYodmFsICE9PSBvbGR2YWwpIHtcbiAgICAgICAgICAgIGlmKHZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25FbnRlclZpZXdib3goKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkxlYXZlVmlld2JveCgpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgfSAgICBcbiAgICAgICAgdGhpc1tpc0luVmlld0JveF0gPSB2YWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5b2T6IqC54K556a75byA5Y+v6KeG5Yy65Z+f55qE5Zue6LCDXG4gICAgICovXG4gICAgb25FbnRlclZpZXdib3goKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlvZPoioLngrnnprvlvIDlj6/op4bljLrln5/nmoTlm57osINcbiAgICAgKi9cbiAgICBvbkxlYXZlVmlld2JveCgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaUueWPmOW9k+WJjemFjee9rlxuICAgICAqIEBwYXJhbSB7Q29uZmlnc30gY29uZmlncyAtIFRoZSBzdHJpbmcgY29udGFpbmluZyB0d28gY29tbWEtc2VwYXJhdGVkIG51bWJlcnMuXG4gICAgICovXG4gICAgc2V0Q29uZmlnKGNvbmZpZ3MpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoY29uZmlncykuZm9yRWFjaChrID0+IHtcbiAgICAgICAgICAgIGlmKGNvbmZpZ3Nba10gIT09IHVuZGVmaW5lZCAmJiBjb25maWdzW2tdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trXSA9IGNvbmZpZ3Nba11cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG4gICAgLyoqXG4gICAgICog57uY5Yi25Y2V5YWDXG4gICAgICogQHBhcmFtIHtDb250ZXh0MmR9IGN0eCBcbiAgICAgKi9cbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIHRocm93ICdyZXF1aXJlIHJlbmRlciBpbXBsZW1lbnQnXG4gICAgfVxuICAgIC8qKlxuICAgICAqIOWIpOaWreW9k+WJjeWNleWFg+aYr+WQpuiiq+WRveS4rVxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHBvaW50IFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNIaXQocG9pbnQpIHtcbiAgICAgICAgdGhyb3cgJ3JlcXVpcmUgaXNIaXQgaW1wbGVtZW50J1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDorqHnrpflvZPliY3nmoTmnIDlpKflpJbmjqXnn6nlvaLnmoRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJbXX0gW2xlZnR4LCBsZWZ0eSwgcmlnaHR4LCByaWdodHldXG4gICAgICovXG4gICAgZ2V0Qm91bmRpbmdSZWN0KCkge1xuICAgICAgICB0aHJvdyAncmVxdWlyZSBnZXRCb3VuZGluZ1JlY3QgaW1wbGVtZW50J1xuICAgIH1cbiAgICBjYWxjdWxhdGVJbnRlcnNlY3Rpb24oKSB7XG4gICAgICAgIHRocm93ICdyZXF1aXJlIGNhbGN1bGF0ZUludGVyc2VjdGlvbiBpbXBsZW1lbnQnXG4gICAgfVxuICAgIC8qKlxuICAgICAqIOiuoeeul+W9k+WJjei/nue6v+aOpeWFpeeCueeahOS9jee9rlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gaW50ZXJzZWN0aW9uIOS6pOWPieeCuVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gaW50ZXJzZWN0aW9uW0RJUkVDVElPTi5UT1BdIOS4ilxuICAgICAqIEByZXR1cm4ge251bWJlcn0gaW50ZXJzZWN0aW9uW0RJUkVDVElPTi5CT1RUT01dIOS4i1xuICAgICAqIEByZXR1cm4ge251bWJlcn0gaW50ZXJzZWN0aW9uW0RJUkVDVElPTi5MRUZUXSDkuIpcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IGludGVyc2VjdGlvbltESVJFQ1RJT04uUklHSFRdIOWPs1xuICAgICAqL1xuICAgIGdldEludGVyc2VjdGlvbnNJbkZvdXJEaW1lbnNpb24oKSB7XG4gICAgICAgIHRocm93ICdyZXF1aXJlIGdldEludGVyc2VjdGlvbnNJbkZvdXJEaW1lbnNpb24gaW1wbGVtZW50J1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICog6I635Y+W5b2T5YmN5omA5Zyo5bGC57qn55qE5Z2Q5qCHXG4gICAgICogQHJldHVybiB7TnVtYmVyW119IOWdkOagh1xuICAgICAqL1xuICAgIGdldENlbnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5jaG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDojrflj5blrr3pq5hcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGRlbWVuc2lvbiDlrr3pq5hcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IGRlbWVuc2lvbi53aWR0aCDlrr1cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IGRlbWVuc2lvbi5oZWlnaHQg6auYXG4gICAgICovXG4gICAgZ2V0Qm91bmRpbmdEaW1lbnNpb24oKSB7XG4gICAgICAgIGNvbnN0IHJlY3QgPSBpbnN0YW5jZS5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgbGV0IG1pbl95ID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBtYXhfeSA9IC1JbmZpbml0eTtcbiAgICAgICAgbGV0IG1pbl94ID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBtYXhfeCA9IC1JbmZpbml0eTtcbiAgICAgICAgcmVjdC5mb3JFYWNoKHBvaW50ID0+IHtcbiAgICAgICAgICAgIG1heF95ID0gTWF0aC5tYXgobWF4X3ksIHBvaW50WzFdKTtcbiAgICAgICAgICAgIG1pbl95ID0gTWF0aC5taW4obWluX3ksIHBvaW50WzFdKTtcbiAgICAgICAgICAgIG1heF94ID0gTWF0aC5tYXgobWF4X3gsIHBvaW50WzBdKTtcbiAgICAgICAgICAgIG1pbl94ID0gTWF0aC5taW4obWluX3gsIHBvaW50WzBdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWlnaHQ6IG1heF95IC0gbWluX3ksXG4gICAgICAgICAgICB3aWR0aDogbWF4X3ggLSBtaW5feCxcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiDlhpLms6Hkuovku7ZcbiAgICAgKiBAcGFyYW0ge0pGbG93RXZlbnR9IGN1c3RvbUV2ZW50IOiHquWumuS5ieS6i+S7tlxuICAgICAqL1xuICAgIGJ1YmJsZUV2ZW50KGN1c3RvbUV2ZW50KXtcbiAgICAgICAgY3VzdG9tRXZlbnQuZGV0YWlsLmN1cnJlbnRUYXJnZXQgPSB0aGlzO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoY3VzdG9tRXZlbnQpO1xuICAgICAgICBpZihjdXN0b21FdmVudC5kZXRhaWwuYnViYmxlcyl7XG4gICAgICAgICAgICBpZih0aGlzLl9iZWxvbmdzLmJ1YmJsZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmVsb25ncy5idWJibGVFdmVudChjdXN0b21FdmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JlbG9uZ3MuZGlzcGF0Y2hFdmVudChjdXN0b21FdmVudCk7IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICog5Y+N566X5Zue6aG16Z2i55qE5YOP57Sg5Z2Q5qCHXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJbXX0g5LiW55WM5Z2Q5qCHXG4gICAgICovXG4gICAgY2FsY3VsYXRlVG9SZWFsV29ybGQocG9pbnQpIHtcbiAgICAgICAgaWYodGhpcy5fYmVsb25ncyAmJiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvUmVhbFdvcmxkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb1JlYWxXb3JsZChwb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxjdWxhdGVUb1JlYWxXb3JsZFdpdGhQb2ludGVyKG91dHBvaW50LCBpbnBvaW50KSB7XG4gICAgICAgIGlmKHRoaXMuX2JlbG9uZ3MgJiYgdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb1JlYWxXb3JsZFdpdGhQb2ludGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvUmVhbFdvcmxkV2l0aFBvaW50ZXIob3V0cG9pbnQsIGlucG9pbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlVG9SZWFsV29ybGRXaXRoU2NhbGFyKGxlbmd0aCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9qZmxvdy5zY2FsZSAqIGxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDku47lvZPliY3luIPlsYDkuK3liKDpmaTomZrmi5/luIPlsYDoioLngrlcbiAgICAgKi9cbiAgICAvLyByZW1vdmVGcm9tTGF5b3V0U291cmNlKCkge1xuICAgIC8vICAgICBpZih0aGlzLl9sYXlvdXROb2RlKSB7XG4gICAgLy8gICAgICAgICB0aGlzLl9sYXlvdXROb2RlLnJlbW92ZSgpO1xuICAgIC8vICAgICB9XG4gICAgLy8gfVxuXG4gICAgcmVjYWxjdWxhdGVVcCgpIHtcbiAgICAgICAgaWYodGhpcy5fYmVsb25ncykge1xuICAgICAgICAgICAgdGhpcy5fYmVsb25ncy5yZWNhbGN1bGF0ZVVwKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICAvLyB0aGlzLl9iZWxvbmdzID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEluc3RhbmNlOyIsImNvbnN0IHF1ZXVlID0gW107XG5jb25zdCBjbGVhclF1ZXVlID0gW107XG5sZXQgcXVldWVTZXQgPSBuZXcgV2Vha1NldCgpO1xuXG5jb25zdCBjaGVja1dvcmsgPSAodGFyZ2V0KSA9PiB7XG4gICAgcmV0dXJuIHF1ZXVlU2V0Lmhhcyh0YXJnZXQpO1xufSAgXG5cbmNvbnN0IGdldFN0YWNrUGF0aCA9IChub2RlKSA9PiB7XG4gICAgbGV0IHQgPSBub2RlO1xuICAgIGxldCBleHAgPSAxO1xuICAgIGxldCBwID0gJyc7XG4gICAgd2hpbGUodCAmJiB0Ll9iZWxvbmdzKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHQuX2JlbG9uZ3MuX3N0YWNrLmZpbmRJbmRleChuID0+IG4gPT09IHQpO1xuICAgICAgICBwID0gaWR4ICsgKHAgJiYgKCcuJyArIHApKVxuICAgICAgICB0ID0gdC5fYmVsb25ncztcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5cbmNvbnN0IHNvcnRCeVBhdGggPSAoKSA9PiB7XG4gICAgY29uc3QgbWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICBxdWV1ZS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIGxldCBhcGF0aCA9IG1hcC5nZXQoYSk7XG4gICAgICAgIGlmKGFwYXRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFwYXRoID0gZ2V0U3RhY2tQYXRoKGEpO1xuICAgICAgICAgICAgbWFwLnNldChhLCBhcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJwYXRoID0gbWFwLmdldChiKTtcbiAgICAgICAgaWYoYnBhdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYnBhdGggPSBnZXRTdGFja1BhdGgoYik7XG4gICAgICAgICAgICBtYXAuc2V0KGIsIGJwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBfYSA9IGFwYXRoLnNwbGl0KCcuJylcbiAgICAgICAgY29uc3QgX2IgPSBicGF0aC5zcGxpdCgnLicpXG4gICAgICAgIGlmKF9hLmxlbmd0aCA8IF9iLmxlbmd0aCkgeyBcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IFxuICAgICAgICBpZihfYS5sZW5ndGggPiBfYi5sZW5ndGgpIHsgXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gXG4gICAgICAgIGZvcihsZXQgaT0wO2k8X2EubGVuZ3RoO2krKykge1xuICAgICAgICAgICAgY29uc3QgX3AgPSArX2FbaV07XG4gICAgICAgICAgICBjb25zdCBfcSA9ICtfYltpXTtcbiAgICAgICAgICAgIGlmKF9wIDwgX3EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKF9wID4gX3EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSlcbn1cblxuXG5leHBvcnQgY29uc3QgYWRkQ2xlYXJTb3VyY2VXb3JrID0gKGpmbG93LCBzb3VyY2UpID0+IHtcbiAgICBjbGVhclF1ZXVlLnB1c2goW2pmbG93LCBzb3VyY2VdKTtcbn1cblxuLy8gd29yayBpcyBzeW5jIGZ1bmN0aW9uISFcbmV4cG9ydCBjb25zdCBhZGRSZWZsb3dXb3JrID0gKHRhcmdldCwgcGFyZW50KSA9PiB7XG4gICAgXG4gICAgaWYodGFyZ2V0LmRvUmVjYWxjdWxhdGUpIHtcbiAgICAgICAgaWYoIXF1ZXVlU2V0Lmhhcyh0YXJnZXQpKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKHRhcmdldCk7XG4gICAgICAgICAgICBxdWV1ZVNldC5hZGQodGFyZ2V0KVxuICAgICAgICB9XG4gICAgfSBcbiAgICBpZihwYXJlbnQgJiYgcGFyZW50LmRvUmVjYWxjdWxhdGUgJiYgIXF1ZXVlU2V0LmhhcyhwYXJlbnQpKSB7XG4gICAgICAgIHF1ZXVlLnB1c2gocGFyZW50KTtcbiAgICAgICAgcXVldWVTZXQuYWRkKHBhcmVudClcbiAgICB9XG4gICBcbiAgICAvLyBpZih0YXJnZXQuZG9SZWNhbGN1bGF0ZSkge1xuICAgIC8vICAgICBpZighY2hlY2tXb3JrKHRhcmdldCkpIHtcbiAgICAvLyAgICAgICAgIHF1ZXVlLnB1c2godGFyZ2V0KTtcbiAgICAvLyAgICAgICAgIHF1ZXVlU2V0LmFkZCh0YXJnZXQpO1xuICAgIC8vICAgICB9XG4gICAgLy8gfSAgXG4gICAgLy8gaWYocGFyZW50KSB7XG4gICAgLy8gICAgIGlmKGNoZWNrV29yayhwYXJlbnQpKSB7XG4gICAgLy8gICAgICAgICBjb25zdCBpZHggPSBxdWV1ZS5maW5kSW5kZXgocCA9PiBwID09PSBwYXJlbnQpO1xuICAgIC8vICAgICAgICAgcXVldWUuc3BsaWNlKGlkeCwgMSk7XG4gICAgLy8gICAgICAgICBxdWV1ZS5wdXNoKHBhcmVudCk7XG4gICAgLy8gICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgICBxdWV1ZS5wdXNoKHBhcmVudCk7XG4gICAgLy8gICAgICAgICBxdWV1ZVNldC5hZGQocGFyZW50KTtcbiAgICAvLyAgICAgfVxuXG4gICAgLy8gfVxuICAgIGZsdXNoKCk7XG59XG5sZXQgaW5GbHVzaCA9IGZhbHNlO1xuY29uc3QgZmx1c2ggPSAoKSA9PiB7XG4gICAgaWYoaW5GbHVzaCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGluRmx1c2ggPSB0cnVlO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJvb3RzID0gbmV3IFNldCgpO1xuICAgICAgICBzb3J0QnlQYXRoKCk7XG4gICAgICAgIHdoaWxlKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmKHRhcmdldC5kb1JlY2FsY3VsYXRlICYmIHRhcmdldC5famZsb3cpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuZG9SZWNhbGN1bGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJvb3RzLmFkZCh0YXJnZXQuX2pmbG93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRhcmdldC53aWR0aCwgdGFyZ2V0LmhlaWdodClcbiAgICAgICAgfVxuICAgICAgICB3aGlsZShjbGVhclF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgW2pmbG93LCBzb3VyY2VdID0gY2xlYXJRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgaWYoIWpmbG93LmdldFJlbmRlck5vZGVCeVNvdXJjZShzb3VyY2UpKXtcbiAgICAgICAgICAgICAgICBqZmxvdy5jbGVhclNvdXJjZShzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLWRpcnR5LS0tZmx1c2gtLS0tLScpXG4gICAgICAgIHF1ZXVlU2V0ID0gbmV3IFdlYWtTZXQoKTtcbiAgICAgICAgaW5GbHVzaCA9IGZhbHNlXG4gICAgICAgIEFycmF5LmZyb20ocm9vdHMpLmZvckVhY2goamZsb3cgPT4ge1xuICAgICAgICAgICAgamZsb3cuX3JlbmRlcigpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0iLCJpbXBvcnQgSW5zdGFuY2UgZnJvbSAnLi9pbnN0YW5jZSc7XG5pbXBvcnQgeyBkb092ZXJsYXAgfSBmcm9tICcuLi91dGlscy9mdW5jdGlvbnMnO1xuaW1wb3J0IHsgYWRkUmVmbG93V29yayB9IGZyb20gJy4uL2RpcnR5LXdvcmsvZGlydHktd29yaydcblxuLyoqXG4gKiDnu53lr7nlrprkvY0g6YWN572u77yMIOe7neWvueWumuS9jeS4jeWPl+W4g+WxgOW9seWTje+8jOebuOWvueS6juW9k+WJjee7hOadpeWumuS9jVxuICogQHR5cGVkZWYge29iamVjdH0gTm9kZX5BYnNvbHV0ZVBvc2l0aW9uIFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRvcCAgICAgICAtIOS4iui3neemu1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGJvdHRvbSAgICAtIOS4i+i3neemu1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHJpZ2h0ICAgICAtIOWPs+i3neemu1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGxlZnQgICAgICAtIOW3pui3neemu1xuICovXG4vKipcbiAqIE5vZGUg6YWN572uXG4gKiBAdHlwZWRlZiB7SW5zdGFuY2V+Q29uZmlnc30gTm9kZX5Db25maWdzIFxuICogQHByb3BlcnR5IHtudW1iZXJbXX0gYW5jaG9yIC0g5Z2Q5qCHXG4gKiBAcHJvcGVydHkge05vZGV+QWJzb2x1dGVQb3NpdGlvbn0gYWJzb2x1dGVQb3NpdGlvbiAtIOe7neWvueWumuS9jeS9jee9rlxuICovXG4vKipcbiAqIOiKgueCueWfuuexu1xuICogQGNvbnN0cnVjdG9yIE5vZGVcbiAqIEBleHRlbmRzIEluc3RhbmNlXG4gKiBAcGFyYW0ge05vZGV+Q29uZmlnc30gY29uZmlncyAtIOiKgueCuemFjee9rlxuICovXG5jbGFzcyBOb2RlIGV4dGVuZHMgSW5zdGFuY2Uge1xuICAgIElOU1RBTkNFX1RZUEUgPSAnTk9ERSdcbiAgICBnZXQgbmV4dFNpYmxpbmcoKSB7XG4gICAgICAgIGlmKCF0aGlzLl9iZWxvbmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFjayA9IHRoaXMuX2JlbG9uZ3MuX3N0YWNrXG4gICAgICAgIGNvbnN0IGlkeCA9IHN0YWNrLmZpbmRJbmRleChzID0+IHMgPT09IHRoaXMpO1xuICAgICAgICBpZihpZHggIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tbaWR4KzFdO1xuICAgICAgICB9IFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzID0ge30pIHtcbiAgICAgICAgc3VwZXIoY29uZmlncyk7XG4gICAgICAgIHRoaXMuX3Jhd0NvbmZpZ3MgPSBjb25maWdzO1xuICAgICAgICAvLyBmb3IgbGF5b3V0XG4gICAgICAgIC8qKiBAbWVtYmVyIHtudW1iZXJbXX0gKi9cbiAgICAgICAgdGhpcy5hbmNob3IgPSAgICAgICAgICAgY29uZmlncy5hbmNob3IgfHwgWzAsIDBdO1xuICAgICAgICAvKiogQG1lbWJlciB7Tm9kZX5BYnNvbHV0ZVBvc2l0aW9ufSAqL1xuICAgICAgICB0aGlzLmFic29sdXRlUG9zaXRpb24gPSBjb25maWdzLmFic29sdXRlUG9zaXRpb247XG4gICAgfVxuXG4gICAgc2V0Q29uZmlnKGNvbmZpZ3MpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoY29uZmlncykuZm9yRWFjaChrID0+IHtcbiAgICAgICAgICAgIGlmKGNvbmZpZ3Nba10gIT09IHVuZGVmaW5lZCAmJiBjb25maWdzW2tdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trXSA9IGNvbmZpZ3Nba11cbiAgICAgICAgICAgICAgICB0aGlzLl9yYXdDb25maWdzW2tdID0gY29uZmlnc1trXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldEFuY2hvclgoeCkge1xuICAgICAgICB0aGlzLmFuY2hvclswXSA9IHg7XG4gICAgfVxuICAgIHNldEFuY2hvclkoeSkge1xuICAgICAgICB0aGlzLmFuY2hvclsxXSA9IHk7XG4gICAgfVxuICAgIHNldEFuY2hvcih4LCB5KSB7XG4gICAgICAgIHRoaXMuYW5jaG9yWzBdID0geDtcbiAgICAgICAgdGhpcy5hbmNob3JbMV0gPSB5O1xuICAgIH1cblxuICAgIGJlZm9yZVJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIGRvT3ZlcmxhcCh0aGlzLl9iZWxvbmdzLl9nZXRWaWV3Qm94KCksIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkpXG4gICAgfVxuXG4gICAgYWRkUmVmbG93V29yaygpIHtcbiAgICAgICAgYWRkUmVmbG93V29yayh0aGlzLCB0aGlzLl9iZWxvbmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlhYvpmoblvZPliY3oioLngrkuXG4gICAgICogQHJldHVybiB7Tm9kZX0g5b2T5YmN6IqC54K555qE5Ymv5pysXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IEMgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICBjb25zdCB0ID0gbmV3IEModGhpcy5fcmF3Q29uZmlncyk7XG4gICAgICAgIHQudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOb2RlOyIsImltcG9ydCBOb2RlIGZyb20gJy4vbm9kZSc7XG5pbXBvcnQgeyBESVJFQ1RJT04gfSBmcm9tICcuLi91dGlscy9jb25zdGFuY2UnO1xuXG5jbGFzcyBHaG9zdE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3MpO1xuICAgIH1cblxuICAgIHJlbmRlcihjdHgpIHt9XG5cbiAgICBpc0hpdChwb2ludCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNhbGN1bGF0ZUludGVyc2VjdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmNob3I7XG4gICAgfVxuXG4gICAgZ2V0Qm91bmRpbmdSZWN0KCkge1xuICAgICAgICBjb25zdCBbeDIsIHkyXSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICByZXR1cm4gW3gyLCB5MiwgeDIsIHkyXVxuICAgIH1cblxuICAgIGdldEJvdW5kaW5nRGltZW5zaW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IDAsIGhlaWdodDogMFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0SW50ZXJzZWN0aW9uc0luRm91ckRpbWVuc2lvbigpIHtcbiAgICAgICAgY29uc3QgW3gyLCB5Ml0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtESVJFQ1RJT04uUklHSFRdOiAgW3gyKzEsIHkyXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uTEVGVF06ICAgW3gyLTEsIHkyXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uQk9UVE9NXTogW3gyLCB5MisxXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uVE9QXTogICAgW3gyLCB5Mi0xXSxcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgR2hvc3ROb2RlOyIsImZ1bmN0aW9uIGdldE1hcE9iamVjdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsYXlvdXROb2RlOiB1bmRlZmluZWQsXG4gICAgICAgIGpmbG93Tm9kZTogdW5kZWZpbmVkLFxuICAgICAgICBqZmxvd2xpbmtzOiBbXSxcbiAgICAgICAgamZsb3dGcm9tTGlua3M6IG5ldyBTZXQoKSxcbiAgICAgICAgamZsb3dUb0xpbmtzOiBuZXcgU2V0KCksXG4gICAgfVxufVxuY2xhc3MgTm9kZVdlYWtNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgZ2V0KHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmdldChzb3VyY2UpO1xuICAgIH1cblxuICAgIHNldChzb3VyY2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gZ2V0TWFwT2JqZWN0KCk7XG4gICAgICAgIHRoaXMuX21hcC5zZXQoc291cmNlLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGhhcyhzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoc291cmNlKTtcbiAgICB9XG5cbiAgICBkZWxldGUoc291cmNlKSB7XG4gICAgICAgIHRoaXMuX21hcC5kZWxldGUoc291cmNlKTtcbiAgICB9XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fbWFwLmNsZWFyKCk7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgTm9kZVdlYWtNYXBNaXhpbiA9IHtcbiAgICBpbml0Tm9kZVdlYWtNYXAoKSB7XG4gICAgICAgIHRoaXMuc291cmNlX0xheW91dF9SZW5kZXJfTm9kZU1hcCA9IG5ldyBOb2RlV2Vha01hcCgpO1xuICAgIH0sXG4gICAgZ2V0UmVuZGVyTm9kZUJ5U291cmNlKHNvdXJjZSkge1xuICAgICAgICBjb25zdCBtYXBwaW5nID0gdGhpcy5zb3VyY2VfTGF5b3V0X1JlbmRlcl9Ob2RlTWFwLmdldChzb3VyY2UpO1xuICAgICAgICBpZihtYXBwaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwcGluZy5qZmxvd05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LCBcbiAgICByZW1vdmVSZW5kZXJOb2RlQnlTb3VyY2Uoc291cmNlLCBpbnN0YW5jZSkge1xuICAgICAgICBjb25zdCBtYXAgPSB0aGlzLnNvdXJjZV9MYXlvdXRfUmVuZGVyX05vZGVNYXA7XG4gICAgICAgIGxldCBvYmogPSBtYXAuZ2V0KHNvdXJjZSk7XG4gICAgICAgIGlmKG9iaiAmJiBvYmouamZsb3dOb2RlID09PSBpbnN0YW5jZSkge1xuICAgICAgICAgICAgb2JqLmpmbG93Tm9kZSA9IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICAgIGlmKG9iaiAmJiBvYmouamZsb3dGcm9tTGlua3Muc2l6ZSA9PT0gMCAmJiBvYmouamZsb3dUb0xpbmtzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlX0xheW91dF9SZW5kZXJfTm9kZU1hcC5kZWxldGUoc291cmNlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZ2V0TGF5b3V0Tm9kZUJ5U291cmNlKHNvdXJjZSkge1xuICAgICAgICBjb25zdCBtYXBwaW5nID0gdGhpcy5zb3VyY2VfTGF5b3V0X1JlbmRlcl9Ob2RlTWFwLmdldChzb3VyY2UpO1xuICAgICAgICBpZihtYXBwaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwcGluZy5sYXlvdXROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBnZXRTb3VyY2VSZW5kZXJNZXRhKHNvdXJjZSkge1xuICAgICAgICBjb25zdCBtYXAgPSB0aGlzLnNvdXJjZV9MYXlvdXRfUmVuZGVyX05vZGVNYXA7XG4gICAgICAgIGNvbnN0IF9tZXRhID0gbWFwLmdldChzb3VyY2UpO1xuICAgICAgICBpZighX21ldGEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAgIFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5fbWV0YSxcbiAgICAgICAgICAgIGpmbG93RnJvbUxpbmtzOiBBcnJheS5mcm9tKF9tZXRhLmpmbG93RnJvbUxpbmtzKSxcbiAgICAgICAgICAgIGpmbG93VG9MaW5rczogQXJyYXkuZnJvbShfbWV0YS5qZmxvd1RvTGlua3MpLFxuICAgICAgICB9XG4gICAgfSxcbiAgICBfZ2V0TWFwKHNvdXJjZSkge1xuICAgICAgICBpZighc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXAgPSB0aGlzLnNvdXJjZV9MYXlvdXRfUmVuZGVyX05vZGVNYXA7XG4gICAgICAgIGxldCBvYmo7XG4gICAgICAgIGlmKG1hcC5oYXMoc291cmNlKSkge1xuICAgICAgICAgICAgb2JqID0gbWFwLmdldChzb3VyY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqID0gbWFwLnNldChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmpcbiAgICB9LFxuICAgIHNldExheW91dE5vZGVCeVNvdXJjZShzb3VyY2UsIGxheW91dE5vZGUpIHtcbiAgICAgICAgbGV0IG9iaiA9IHRoaXMuX2dldE1hcChzb3VyY2UpO1xuICAgICAgICBvYmoubGF5b3V0Tm9kZSA9IGxheW91dE5vZGU7XG4gICAgfSxcbiAgICBzZXRSZW5kZXJOb2RlQnlTb3VyY2Uoc291cmNlLCBpbnN0YW5jZSkge1xuICAgICAgICBsZXQgb2JqID0gdGhpcy5fZ2V0TWFwKHNvdXJjZSk7XG4gICAgICAgIG9iai5qZmxvd05vZGUgPSBpbnN0YW5jZTtcblxuICAgICAgICBpZihvYmouamZsb3dGcm9tTGlua3Muc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIG9iai5qZmxvd0Zyb21MaW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xuICAgICAgICAgICAgICAgIGxpbmsuZnJvbSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYob2JqLmpmbG93VG9MaW5rcy5zaXplID4gMCkge1xuICAgICAgICAgICAgb2JqLmpmbG93VG9MaW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xuICAgICAgICAgICAgICAgIGxpbmsudG89IGluc3RhbmNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGFkZExpbmtOb2RlQnlTb3VyY2Uoc291cmNlRnJvbSwgc291cmNlVG8sIGxpbmspIHtcbiAgICAgICAgbGV0IG9iaiA9IHRoaXMuX2dldE1hcChzb3VyY2VGcm9tKTtcbiAgICAgICAgb2JqLmpmbG93RnJvbUxpbmtzLmFkZChsaW5rKTtcblxuICAgICAgICBvYmogPSB0aGlzLl9nZXRNYXAoc291cmNlVG8pO1xuICAgICAgICBvYmouamZsb3dUb0xpbmtzLmFkZChsaW5rKTtcbiAgICB9LFxuICAgIHJlbW92ZUxpbmtOb2RlQnlTb3VyY2Uoc291cmNlRnJvbSwgc291cmNlVG8sIGxpbmspIHtcbiAgICAgICAgY29uc3QgbWFwID0gdGhpcy5zb3VyY2VfTGF5b3V0X1JlbmRlcl9Ob2RlTWFwO1xuICAgICAgICBsZXQgb2JqID0gbWFwLmdldChzb3VyY2VGcm9tKTtcbiAgICAgICAgaWYob2JqKSB7XG4gICAgICAgICAgICBvYmouamZsb3dGcm9tTGlua3MuZGVsZXRlKGxpbmspO1xuICAgICAgICAgICAgaWYob2JqLmpmbG93RnJvbUxpbmtzLnNpemUgPT09IDAgJiYgb2JqLmpmbG93VG9MaW5rcy5zaXplID09PSAwICYmICFvYmouamZsb3dOb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VfTGF5b3V0X1JlbmRlcl9Ob2RlTWFwLmRlbGV0ZShzb3VyY2VGcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvYmogPSBtYXAuZ2V0KHNvdXJjZVRvKTtcbiAgICAgICAgaWYob2JqKSB7XG4gICAgICAgICAgICBvYmouamZsb3dUb0xpbmtzLmRlbGV0ZShsaW5rKTtcbiAgICAgICAgICAgIGlmKG9iai5qZmxvd0Zyb21MaW5rcy5zaXplID09PSAwICYmIG9iai5qZmxvd1RvTGlua3Muc2l6ZSA9PT0gMCAmJiAhb2JqLmpmbG93Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlX0xheW91dF9SZW5kZXJfTm9kZU1hcC5kZWxldGUoc291cmNlVG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjaGFuZ2VMaW5rTm9kZUJ5U291cmNlKHByZXZTb3VyY2UsIG5leHRTb3VyY2UsIGxpbmssIGRpcikge1xuICAgICAgICBsZXQgb2JqID0gdGhpcy5fZ2V0TWFwKHByZXZTb3VyY2UpO1xuICAgICAgICBpZihvYmopIHtcbiAgICAgICAgICAgIGlmKGRpciA9PT0gJ2Zyb20nKSB7XG4gICAgICAgICAgICAgICAgb2JqLmpmbG93RnJvbUxpbmtzLmRlbGV0ZShsaW5rKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZGlyID09PSAndG8nKSB7XG4gICAgICAgICAgICAgICAgb2JqLmpmbG93VG9MaW5rcy5kZWxldGUobGluaylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvYmogPSB0aGlzLl9nZXRNYXAobmV4dFNvdXJjZSk7XG4gICAgICAgIGlmKG9iaikge1xuICAgICAgICAgICAgaWYoZGlyID09PSAnZnJvbScpIHtcbiAgICAgICAgICAgICAgICBvYmouamZsb3dGcm9tTGlua3MuYWRkKGxpbmspO1xuICAgICAgICAgICAgICAgIGlmKG9iai5qZmxvd05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluay5mcm9tID0gb2JqLmpmbG93Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkaXIgPT09ICd0bycpIHtcbiAgICAgICAgICAgICAgICBvYmouamZsb3dUb0xpbmtzLmFkZChsaW5rKTtcbiAgICAgICAgICAgICAgICBpZihvYmouamZsb3dOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmsudG8gPSBvYmouamZsb3dOb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgY2hhbmdlTm9kZUJ5U291cmNlKHByZXZTb3VyY2UsIG5leHRTb3VyY2UsIGluc3RhbmNlKSB7XG4gICAgICAgIGlmKHByZXZTb3VyY2UgJiYgbmV4dFNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3Qgb2xkb2JqID0gdGhpcy5fZ2V0TWFwKHByZXZTb3VyY2UpO1xuICAgICAgICAgICAgY29uc3QgbmV3b2JqID0gdGhpcy5fZ2V0TWFwKG5leHRTb3VyY2UpO1xuICAgICAgICAgICAgbmV3b2JqLmpmbG93Tm9kZSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgb2xkb2JqLmpmbG93RnJvbUxpbmtzLmZvckVhY2gobGluayA9PiB7XG4gICAgICAgICAgICAgICAgbmV3b2JqLmpmbG93RnJvbUxpbmtzLmFkZChsaW5rKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb2xkb2JqLmpmbG93VG9MaW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xuICAgICAgICAgICAgICAgIG5ld29iai5qZmxvd0Zyb21MaW5rcy5hZGQobGluayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5ld29iai5qZmxvd0Zyb21MaW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xuICAgICAgICAgICAgICAgIGxpbmsuZnJvbSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuZXdvYmouamZsb3dUb0xpbmtzLmZvckVhY2gobGluayA9PiB7XG4gICAgICAgICAgICAgICAgbGluay50byA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZV9MYXlvdXRfUmVuZGVyX05vZGVNYXAuZGVsZXRlKHByZXZTb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOb2RlV2Vha01hcDtcblxuIiwiLy8gaW1wb3J0IHsgTm9kZVBsYWNlaG9sZGVyIH0gZnJvbSAnLi9ub2RlLXBsYWNlaG9sZGVyJztcbi8qKlxuICog57uY5Zu+5qCIXG4gKiBAZXh0ZW5kcyBBcnJheVxuICovXG5jbGFzcyBJbnN0YW5jZVN0YWNrIGV4dGVuZHMgQXJyYXkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9jdXJyZW50SGl0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBmb3JFYWNoKGNiKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5mb3JFYWNoKChpLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGlmKGkudHlwZSA9PT0gJ05PREVfUExBQ0VIT0xERVInKSB7IFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNiKGksIGlkeCk7XG4gICAgICAgIH0pXG4gICAgfVxuICAgIGZpbHRlcihjYikge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShzdXBlci5maWx0ZXIoKGksIGlkeCkgPT4ge1xuICAgICAgICAgICAgaWYoaS50eXBlID09PSAnTk9ERV9QTEFDRUhPTERFUicpIHsgXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNiKGksIGlkeCk7XG4gICAgICAgIH0pKVxuICAgIH1cbiAgICBzbGljZSgpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oc3VwZXIuZmlsdGVyKChpLCBpZHgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpLnR5cGUgIT09ICdOT0RFX1BMQUNFSE9MREVSJ1xuICAgICAgICB9KSlcbiAgICB9XG4gICAgc3VwZXJmaWx0ZXIoY2IpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmZpbHRlcigoaSwgaWR4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2IoaSwgaWR4KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOe7mOWItuW9k+WJjeagiFxuICAgICAqIEBwYXJhbSB7Q29udGV4dDJkfSBjdHggLSBjYW52YXMgY29udGV4dDJkXG4gICAgICovXG4gICAgcmVuZGVyKGN0eCwgY29uZGl0aW9uKSB7XG4gICAgICAgIGxldCBtb3ZpbmdUYXJnZXQ7XG4gICAgICAgIHRoaXMuZm9yRWFjaChpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICBpZihpbnN0YW5jZS5faXNNb3ZpbmcpIHtcbiAgICAgICAgICAgICAgICBtb3ZpbmdUYXJnZXQgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihpbnN0YW5jZS52aXNpYmxlICYmICghY29uZGl0aW9uIHx8IGNvbmRpdGlvbihpbnN0YW5jZSkpKSB7XG4gICAgICAgICAgICAgICAgaWYoaW5zdGFuY2UuYmVmb3JlUmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKCFpbnN0YW5jZS5iZWZvcmVSZW5kZXIoY3R4KSl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5yZW5kZXIoY3R4KTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYobW92aW5nVGFyZ2V0KSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgLy8gaWYobW92aW5nVGFyZ2V0LnJlZmxvdyAmJiAhbW92aW5nVGFyZ2V0Ll9yZWZsb3dlZCkge1xuICAgICAgICAgICAgLy8gICAgIG1vdmluZ1RhcmdldC5yZWZsb3coKTtcbiAgICAgICAgICAgIC8vICAgICBtb3ZpbmdUYXJnZXQuX3JlZmxvd2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIG1vdmluZ1RhcmdldC5yZW5kZXIoY3R4KTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldEhpdFN0YXR1cygpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEhpdCA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9yRWFjaChpID0+IHtcbiAgICAgICAgICAgIGlmKGkuX3N0YWNrKSB7XG4gICAgICAgICAgICAgICAgaS5fc3RhY2sucmVzZXRIaXRTdGF0dXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkuX2lzSGl0ID0gZmFsc2U7XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog56Kw5pKe5a+56LGh6L+H5ruk5p2h5Lu2XG4gICAgICogQG5hbWUgSW5zdGFuY2VTdGFja35JbnN0YW5jZUZpbHRlclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7SW5zdGFuY2V9IGluc3RhbmNlIC0g5b2T5YmN5a+56LGhXG4gICAgKi9cbiAgICAvKipcbiAgICAgKiDnorDmkp7mo4DmtYtcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBwb2ludCAtIOeisOaSnueCuVxuICAgICAqIEBwYXJhbSB7SW5zdGFuY2VTdGFja35JbnN0YW5jZUZpbHRlcn0gY29uZGl0aW9uIC0g56Kw5pKe5a+56LGh6L+H5ruk5p2h5Lu2XG4gICAgICogQHJldHVybiB7SW5zdGFuY2V9XG4gICAgICovXG4gICAgY2hlY2tIaXQocG9pbnQsIGNvbmRpdGlvbiwgY3VycmVudENvbnN0cmFpbnQpe1xuICAgICAgICBsZXQgaSA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUoaSA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXNbaV07XG4gICAgICAgICAgICBpZihpbnN0YW5jZS50eXBlID09PSAnTk9ERV9QTEFDRUhPTERFUicpIHsgXG4gICAgICAgICAgICAgICAgaS0tXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihpbnN0YW5jZS52aXNpYmxlICYmICFpbnN0YW5jZS5pZ25vcmVIaXQpIHtcbiAgICAgICAgICAgICAgICBpZihjb25kaXRpb24gJiYgY29uZGl0aW9uKGluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICBpLS1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRDb25zdHJhaW50ICYmICFjdXJyZW50Q29uc3RyYWludChpbnN0YW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaS0tXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzaGl0ID0gaW5zdGFuY2UuaXNIaXQocG9pbnQsIGNvbmRpdGlvbik7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoaXNoaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5fY3VycmVudEhpdCAhPT0gaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuX2N1cnJlbnRIaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50SGl0Ll9pc0hpdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuX2lzSGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRIaXQgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgaXNoaXQgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzaGl0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5faXNIaXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpLS1cbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLl9jdXJyZW50SGl0KSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SGl0Ll9pc0hpdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnRIaXQgPSBudWxsO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICog6I635Y+W5b2T5YmN5bGC5qCI55qE5pyA5bCP5aSW5o6l55+p5b2iXG4gICAgICogQHJldHVybiB7bnVtYmVyW11bXX0gLSDlpJbmjqXnn6nlvaLlnZDmoIdcbiAgICAgKi9cbiAgICBnZXRCb3VuZGluZ1JlY3RQb2ludHMoKSB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2goaW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgaWYoaW5zdGFuY2UudmlzaWJsZSAmJiAhaW5zdGFuY2UuYWJzb2x1dGVQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBpbnN0YW5jZS5nZXRCb3VuZGluZ1JlY3QoKVxuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFtyZWN0WzBdLCByZWN0WzFdXSk7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goW3JlY3RbMl0sIHJlY3RbM11dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6I635Y+W5b2T5YmN5bGC5qCI55qE6ZSa54K555+p5b2iXG4gICAgICogQHJldHVybiB7bnVtYmVyW11bXX0gLSDplJrngrnnn6nlvaLlnZDmoIdcbiAgICAgKi9cbiAgICBnZXRBbmNob3JSZWN0UG9pbnRzKCkge1xuICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGluc3RhbmNlID0+IHtcbiAgICAgICAgICAgIGlmKGluc3RhbmNlLnZpc2libGUgJiYgIWluc3RhbmNlLmFic29sdXRlUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChpbnN0YW5jZS5hbmNob3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEluc3RhbmNlU3RhY2s7XG4iLCJpbXBvcnQgSW5zdGFuY2VTdGFjayBmcm9tICcuL3N0YWNrJztcbmltcG9ydCB7IGFkZFJlZmxvd1dvcmsgfSBmcm9tICcuLi9kaXJ0eS13b3JrL2RpcnR5LXdvcmsnO1xuXG4vLyBpbXBvcnQgeyBzZXRVbmlxdWVJZCwgZ2V0VW5pcXVlSWQgfSBmcm9tICcuLi91dGlscy9mdW5jdGlvbnMnO1xuLyoqXG4gKiDlr7nosaHmoIggbWl4aW4g55So5LqO5pa55L6/5o6n5Yi26IqC54K55qCI5ZKM6L+e57q/5qCIXG4gKlxuICogQG1peGluXG4gKi9cbmNvbnN0IFN0YWNrTWl4aW4gPSB7XG4gICAgLyoqIEBwcm9wZXJ0eSB7Tm9kZVtdfSAgICAgICAgICAtIOWvueixoeaVsOe7hCAqL1xuICAgIGluc3RhbmNlczogW10sXG4gICAgLyoqIEBwcm9wZXJ0eSB7QmFzZUxpbmtbXX0gICAgICAtIOi/nue6v+aVsOe7hCAqL1xuICAgIGxpbmtzOiBbXSxcbiAgICAvKiogQHByb3BlcnR5IHtJbnN0YW5jZVN0YWNrfSAgICAgICAtIOWvueixoeagiCAqL1xuICAgIF9zdGFjazogbnVsbCxcbiAgICAvKiogQHByb3BlcnR5IHtJbnN0YW5jZVN0YWNrfSAgICAgICAtIOi/nue6v+agiCAqL1xuICAgIF9saW5rU3RhY2s6IG51bGwsXG4gICAgLyoqXG4gICAgICog5Yid5aeL5YyW5a+56LGh5qCIXG4gICAgICogQHBhcmFtIHtKZmxvd0NvbmZpZ3N9IGNvbmZpZ3MgLSDphY3nva5cbiAgICAgKi9cbiAgICBpbml0U3RhY2soeyBkYXRhIH0gPSB7fSkge1xuICAgICAgICB0aGlzLl9zdGFjayA9IG5ldyBJbnN0YW5jZVN0YWNrKCk7XG4gICAgICAgIHRoaXMuX2xpbmtTdGFjayA9IG5ldyBJbnN0YW5jZVN0YWNrKCk7XG4gICAgICAgIGlmKCFkYXRhKSByZXR1cm47XG4gICAgICAgIHRoaXMuaW5zdGFuY2VzID0gZGF0YS5pbnN0YW5jZXM7XG4gICAgICAgIHRoaXMubGlua3MgPSBkYXRhLmxpbmtzO1xuICAgICAgICB0aGlzLmluc3RhbmNlcy5mb3JFYWNoKGkgPT4geyBcbiAgICAgICAgICAgIHRoaXMuX3N0YWNrLnB1c2goaSk7XG4gICAgICAgICAgICBpLl9iZWxvbmdzID0gdGhpcztcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5saW5rcy5mb3JFYWNoKChsaW5rKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9saW5rU3RhY2sucHVzaChsaW5rKTtcbiAgICAgICAgICAgIGxpbmsuX2JlbG9uZ3MgPSB0aGlzO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIOWKoOWFpeiKgueCueWvueixoVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gaW5zdGFuY2UgLSDoioLngrnlr7nosaFcbiAgICAgKi9cbiAgICBhZGRUb1N0YWNrKGluc3RhbmNlKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLWFkZFRvU3RhY2stLS0tJywgaW5zdGFuY2UpXG4gICAgICAgIGluc3RhbmNlLl9iZWxvbmdzID0gdGhpcztcbiAgICAgICAgdGhpcy5fc3RhY2sucHVzaChpbnN0YW5jZSk7XG4gICAgICAgIGFkZFJlZmxvd1dvcmsoaW5zdGFuY2UsIHRoaXMpO1xuICAgICAgICAvLyB0aGlzLnJlY2FsY3VsYXRlKClcbiAgICB9LFxuXG4gICAgaW5zZXJ0VG9TdGFja0JlZm9yZShpbnN0YW5jZSwgYW5jaG9yTm9kZSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLS1pbnNlcnRUb1N0YWNrQmVmb3JlLS0tLScpXG4gICAgICAgIGlmKGluc3RhbmNlLl9iZWxvbmdzKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5fYmVsb25ncy5yZW1vdmVGcm9tU3RhY2soaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLl9iZWxvbmdzID0gdGhpcztcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5fc3RhY2suZmluZEluZGV4KHMgPT4gcyA9PT0gYW5jaG9yTm9kZSk7XG4gICAgICAgIGlmKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YWNrLnNwbGljZShpZHgsIDAsIGluc3RhbmNlKVxuICAgICAgICAgICAgYWRkUmVmbG93V29yayhpbnN0YW5jZSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkZFRvU3RhY2soaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiDmm7/mjaLlr7nosaFcbiAgICAgKiBAcGFyYW0ge0luc3RhbmNlfSB0YXJnZXQgLSDooqvmm7/mjaLnmoTlr7nosaFcbiAgICAgKiBAcGFyYW0ge0luc3RhbmNlfSBpbnN0YW5jZSAtIOabv+aNouWvueixoVxuICAgICAqL1xuICAgIHJlcGxhY2VGcm9tU3RhY2sodGFyZ2V0LCBpbnN0YW5jZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX3N0YWNrLmZpbmRJbmRleChpID0+IGkgPT09IHRhcmdldCk7XG4gICAgICAgIHRoaXMuX3N0YWNrLnNwbGljZShpbmRleCwgMSwgaW5zdGFuY2UpO1xuICAgICAgICB0YXJnZXQuX2JlbG9uZ3MgPSBudWxsO1xuICAgICAgICBpbnN0YW5jZS5fYmVsb25ncyA9IHRoaXM7XG4gICAgICAgIC8vIHRoaXMucmVjYWxjdWxhdGUoKVxuICAgIH0sXG4gICAgLyoqXG4gICAgICog5Yqg5YWl6L+e57q/5a+56LGhXG4gICAgICogQHBhcmFtIHtCYXNlTGlua30gaW5zdGFuY2UgLSDov57nur/lr7nosaFcbiAgICAgKi9cbiAgICBhZGRUb0xpbmtTdGFjayhsaW5rKSB7XG4gICAgICAgIGlmKHRoaXMuX2xpbmtTdGFjay5maW5kKGwgPT4gbCA9PT0gbGluaykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsaW5rLl9iZWxvbmdzID0gdGhpcztcbiAgICAgICAgdGhpcy5fbGlua1N0YWNrLnB1c2gobGluayk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiDliKDpmaToioLngrnlr7nosaFcbiAgICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldCAtIOiKgueCueWvueixoVxuICAgICAqL1xuICAgIHJlbW92ZUZyb21TdGFjayh0YXJnZXQpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0tcmVtb3ZlRnJvbVN0YWNrLS0tLScpXG4gICAgICAgIC8vIHRoaXMucmVtb3ZlTGlua09uSW5zdGFuY2UodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9zdGFjay5maW5kSW5kZXgoaSA9PiBpID09PSB0YXJnZXQpO1xuICAgICAgICBpZihpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YWNrLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBhZGRSZWZsb3dXb3JrKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMucmVjYWxjdWxhdGUoKVxuICAgIH0sXG4gICAgLyoqXG4gICAgICog5Yig6Zmk6L+e57q/5a+56LGhXG4gICAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXQgLSDov57nur/lr7nosaFcbiAgICAgKi9cbiAgICByZW1vdmVGcm9tTGlua1N0YWNrKHRhcmdldCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2xpbmtTdGFjay5maW5kSW5kZXgoaSA9PiBpID09PSB0YXJnZXQpO1xuICAgICAgICBpZihpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmtTdGFjay5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfSxcbiAgIFxuICAgIGVtcHR5TGluaygpIHtcbiAgICAgICAgdGhpcy5fbGlua1N0YWNrID0gbmV3IEluc3RhbmNlU3RhY2soKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIOmHjee9ruW9k+WJjeagiOS4reWvueixoeeahOS9jee9rlxuICAgICAqL1xuICAgIHJlc2V0Q2hpbGRyZW5Qb3NpdGlvbigpIHtcbiAgICAgICAgdGhpcy5fc3RhY2suZm9yRWFjaChpID0+IHtcbiAgICAgICAgICAgIGkuYW5jaG9yID0gWzAsMF1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGFkZEluc3RhbmNlVG9MaW5rKHRhcmdldExpbmssIGluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuYWRkVG9TdGFjayhpbnN0YW5jZSk7XG4gICAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHRhcmdldExpbms7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbGlua1N0YWNrLmZpbmRJbmRleChsID0+IGwgPT09IHRhcmdldExpbmspO1xuICAgICAgICBjb25zdCBfY29uc3R1Y3RvciA9IHRhcmdldExpbmsuX19wcm90b19fLmNvbnN0cnVjdG9yO1xuICAgICAgICBjb25zdCBsMSA9IG5ldyBfY29uc3R1Y3Rvcih7XG4gICAgICAgICAgICBmcm9tLCBcbiAgICAgICAgICAgIHRvOiBpbnN0YW5jZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGwxLl9iZWxvbmdzID0gdGhpcztcbiAgICAgICAgY29uc3QgbDIgPSBuZXcgX2NvbnN0dWN0b3Ioe1xuICAgICAgICAgICAgZnJvbTogaW5zdGFuY2UsIFxuICAgICAgICAgICAgdG8sXG4gICAgICAgIH0pO1xuICAgICAgICBsMi5fYmVsb25ncyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5fbGlua1N0YWNrLnNwbGljZShpbmRleCwgMSwgbDEsIGwyKTtcbiAgICB9LFxuICAgIFxuICAgIC8qKlxuICAgICAqIOW+queOr+W9k+WJjeagiOS4reiKgueCuVxuICAgICAqIEBwcm9wZXJ0eSB7c3RhY2tJdGVyYXRvckNhbGxiYWNrfSDlvqrnjq/orr/pl67moIjkuK3mr4/kuKroioLngrlcbiAgICAgKi9cbiAgICBpbnRlcmF0ZU5vZGVTdGFjayhjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9zdGFjay5mb3JFYWNoKGluc3RhbmNlID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGluc3RhbmNlKTtcbiAgICAgICAgfSlcbiAgICB9ICAgXG4gICAgLyoqXG4gICAgKiDlvqrnjq/orr/pl67moIjkuK3mr4/kuKroioLngrlcbiAgICAqIEBjYWxsYmFjayBzdGFja0l0ZXJhdG9yQ2FsbGJhY2tcbiAgICAqIEBwYXJhbSB7Tm9kZX0gaW5zdGFuY2Ug5qCI5Lit6IqC54K5XG4gICAgKi9cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3RhY2tNaXhpbjsiLCIvKipcbiAqIExheW91dCBtaXhpbiDphY3nva5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IExheW91dE1peGlufkxheW91dENvbmZpZ3NcbiAqIEBwcm9wZXJ0eSB7TGF5b3V0fSBsYXlvdXQgICAgICAgICAgICAgLSDluIPlsYDlr7nosaEgXG4gKi9cbi8qKlxuICog5biD5bGAIG1peGluIOeUqOS6juazqOWGjOWSjOaWueS+v+aOp+WItuW4g+WxgFxuICpcbiAqIEBtaXhpblxuICovXG5jb25zdCBMYXlvdXRNaXhpbiA9IHtcbiAgICAvKiogQHByb3BlcnR5IHtMYXlvdXR9ICAgICAgLSDluIPlsYDlr7nosaEgKi9cbiAgICBfbGF5b3V0OiBudWxsLFxuICAgIC8qKlxuICAgICAqIOWIneWni+WMluW4g+WxgFxuICAgICAqIEBwYXJhbSB7TGF5b3V0TWl4aW5+TGF5b3V0Q29uZmlnc30gY29uZmlncyAtIOmFjee9rlxuICAgICAqL1xuICAgIGluaXRMYXlvdXQoY29uZmlncyA9IHt9KSB7XG4gICAgICAgIHRoaXMuX2xheW91dCA9IGNvbmZpZ3MubGF5b3V0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICog5LuO5b2T5YmN5bGC5Ye65Y+R77yM5ZCR5LiK5bGC6YCS5b2S6YeN5o6SXG4gICAgICovXG4gICAgcmVjYWxjdWxhdGVVcCgpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS1yZWNhbGN1bGF0ZVVwLS0tLScpXG4gICAgICAgIGxldCBkaXJ0eSA9IHRydWU7XG4gICAgICAgIGlmKHRoaXMuZ2V0Qm91bmRpbmdEaW1lbnNpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGg6IHdvbGQsIGhlaWdodDogaG9sZCB9ID0gdGhpcy5nZXRCb3VuZGluZ0RpbWVuc2lvbigpO1xuICAgICAgICAgICAgaWYodGhpcy5yZXNldENoaWxkcmVuUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Q2hpbGRyZW5Qb3NpdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5fZ2V0Qm91bmRpbmdHcm91cFJlY3Qpe1xuICAgICAgICAgICAgICAgIHRoaXMuX2dldEJvdW5kaW5nR3JvdXBSZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlZmxvdygpO1xuICAgICAgICAgICAgaWYodGhpcy5fZ2V0Qm91bmRpbmdHcm91cFJlY3Qpe1xuICAgICAgICAgICAgICAgIHRoaXMuX2dldEJvdW5kaW5nR3JvdXBSZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHdpZHRoOiB3bm93LCBoZWlnaHQ6IGhub3cgfSA9IHRoaXMuZ2V0Qm91bmRpbmdEaW1lbnNpb24oKTtcbiAgICAgICAgICAgIGRpcnR5ID0gKHdvbGQgIT09IHdub3cgfHwgaG9sZCAhPT0gaG5vdylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVmbG93KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5fYmVsb25ncyAmJiBkaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5fYmVsb25ncy5yZWNhbGN1bGF0ZVVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIWRpcnR5IHx8IHRoaXMuX2JlbG9uZ3M/LnVuaXF1ZU5hbWUgPT09ICdqZmxvdycpIHtcbiAgICAgICAgICAgIHRoaXMucmVjYWxjdWxhdGVEb3duKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlY2FsY3VsYXRlRG93bigpIHtcbiAgICAgICAgaWYodGhpcy5fbGF5b3V0ICYmIHRoaXMuX2xheW91dC5yZWZsb3dBZnRlcikge1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0LnJlZmxvd0FmdGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YWNrLmZvckVhY2goaW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgaWYoaW5zdGFuY2UucmVjYWxjdWxhdGVEb3duKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UucmVjYWxjdWxhdGVEb3duKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiDph43mlrDorqHnrpfluIPlsYDvvIznm7jlvZPkuo7mtY/op4jlmajph4zpnaLph43mjpLvvIzlubbph43nrpflvZPliY3luIPlsYDkuIvnmoTmnIDlsI/lpJbmjqXnn6nlvaJcbiAgICAgKi9cbiAgICByZWNhbGN1bGF0ZSgpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS1yZWNhbGN1bGF0ZS0tLS0nKVxuICAgICAgICB0aGlzLnJlZmxvdygpO1xuICAgICAgICBpZih0aGlzLl9nZXRCb3VuZGluZ0dyb3VwUmVjdCl7XG4gICAgICAgICAgICB0aGlzLl9nZXRCb3VuZGluZ0dyb3VwUmVjdCgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiDluIPlsYDpnZnmgIHmo4Dmn6VcbiAgICAgKiBAcGFyYW0ge0luc3RhbmNlfSBpbnN0YW5jZSAtIOajgOafpeWNleWFg1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IC0g5qOA5p+l57uT5p6cIFxuICAgICAqL1xuICAgIHN0YXRpY0NoZWNrKGluc3RhbmNlKSB7XG4gICAgICAgIGlmKHRoaXMuX2xheW91dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dC5zdGF0aWNDaGVjayhpbnN0YW5jZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICog6YeN5paw6K6h566X5biD5bGA77yM55u45b2T5LqO5rWP6KeI5Zmo6YeM6Z2i6YeN5o6SXG4gICAgICovXG4gICAgcmVmbG93KCkge1xuICAgICAgICBpZih0aGlzLl9sYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheW91dC5yZWZsb3codGhpcyk7XG4gICAgICAgIH1cbiAgICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBMYXlvdXRNaXhpbjsiLCIvKipcbiAqIOa2iOaBryBtaXhpbiDnlKjkuo7nu5lKZmxvd+S8oOmAkua2iOaBr1xuICpcbiAqIEBtaXhpblxuICovXG5jb25zdCBNZXNzYWdlTWl4aW4gPSB7XG4gICAgX21lc3NhZ2U6IG51bGwsXG4gICAgLyoqXG4gICAgICog5Y+R6YCB5raI5oGvXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1zZyAtIOa2iOaBr+S9k1xuICAgICAqL1xuICAgIHNlbmRNZXNzYWdlKG1zZykge1xuICAgICAgICB0aGlzLl9tZXNzYWdlID0gbXNnO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICog5o6l5pS25raI5oGvXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBtc2cgLSDmtojmga/kvZNcbiAgICAgKi9cbiAgICBjb25zdW1lTWVzc2FnZSgpIHtcbiAgICAgICAgY29uc3QgbXNnID0gdGhpcy5fbWVzc2FnZTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfSxcbiAgICByZWFkTWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2U7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNZXNzYWdlTWl4aW47IiwiXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgaW5pdEFuaW1lKCkge1xuICAgICAgICB0aGlzLmFuaW1lX3F1ZXVlID0gW107XG4gICAgICAgIHRoaXMuX19hbmltZUNsb2NrX18gPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIHRoaXMuYW5pbWVjbG9jayA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gdGhpcy5mcmFtZVJlbmRlcmVkID0gZmFsc2U7XG4gICAgfSxcbiAgICAvLyBzZXRBbmltZUNsb2NrKHRpbWUpIHtcbiAgICAvLyAgICAgaWYodGltZSAhPT0gdGhpcy5hbmltZWNsb2NrKSB7XG4gICAgLy8gICAgICAgICB0aGlzLmZyYW1lUmVuZGVyZWQgPSBmYWxzZTtcbiAgICAvLyAgICAgICAgIHRoaXMuYW5pbWVjbG9jayA9IHRpbWU7XG4gICAgLy8gICAgIH1cbiAgICAvLyB9LFxuXG4gICAgLy8gaGFzQW5pbWVBbmRGcmFtZVJlbmRlcmVkKCkge1xuICAgIC8vICAgICByZXR1cm4gdGhpcy5hbmltZV9xdWV1ZS5sZW5ndGggJiYgdGhpcy5mcmFtZVJlbmRlcmVkO1xuICAgIC8vIH0sXG5cbiAgICAvLyBzZXRGcmFtZVJlbmRlcmVkKCkge1xuICAgIC8vICAgICBpZih0aGlzLmFuaW1lX3F1ZXVlLmxlbmd0aCkge1xuICAgIC8vICAgICAgICAgdGhpcy5mcmFtZVJlbmRlcmVkID0gdHJ1ZTtcbiAgICAvLyAgICAgfVxuICAgIC8vIH0sXG5cbiAgICByZXF1ZXN0SkZsb3dBbmltZShmcmFtZUNhbGxCYWNrKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmVucXVldWVBbmltZShmcmFtZUNhbGxCYWNrKTtcbiAgICAgICAgdGhpcy5fcnVuQW5pbWUoKTtcbiAgICAgICAgcmV0dXJuIG1ldGE7XG4gICAgfSxcblxuICAgIGVucXVldWVBbmltZShjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBhbmltZU1ldGEgPSB7XG4gICAgICAgICAgICBzdGFydDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW5jZWxBbmltZShhbmltZU1ldGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYW5pbWVfcXVldWUucHVzaChhbmltZU1ldGEpO1xuICAgICAgICByZXR1cm4gYW5pbWVNZXRhO1xuICAgIH0sXG5cbiAgICBfY2FuY2VsQW5pbWUobWV0YSkge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmFuaW1lX3F1ZXVlLmZpbmRJbmRleChtID0+IG0gPT09IG1ldGEpO1xuICAgICAgICB+aWR4ICYmIHRoaXMuYW5pbWVfcXVldWUuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIFxuICAgIH0sXG5cbiAgICBydW5BbmltZSgpIHtcbiAgICAgICAgdGhpcy5fcnVuQW5pbWUoKTtcbiAgICAgICAgLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3J1bkFuaW1lLmJpbmQodGhpcykpO1xuICAgIH0sXG4gICAgX3J1bkFuaW1lKCkge1xuICAgICAgICBpZiAodGhpcy5hbmltZV9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3J1bkFuaW1lKCk7XG4gICAgICAgICAgICB9KSAgXG4gICAgICAgICAgICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fcnVuQW5pbWUuYmluZCh0aGlzKSlcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBydW5BbmltZUZyYW1lKCkge1xuICAgICAgICB0aGlzLmFuaW1lX3F1ZXVlLmZvckVhY2gobWV0YSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgaWYoIW1ldGEuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBtZXRhLnN0YXJ0ID0gdGltZXN0YW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZWxhcHNlZCA9IHRpbWVzdGFtcCAtIG1ldGEuc3RhcnQ7XG4gICAgICAgICAgICBtZXRhLmNhbGxiYWNrKGVsYXBzZWQpO1xuICAgICAgICB9KTtcbiAgICB9XG59IiwiaW1wb3J0IHsgY3JlYXRlQ2FudmFzIH0gZnJvbSAnLi4vdXRpbHMvY2FudmFzJztcbmV4cG9ydCBkZWZhdWx0IHtcbiAgICAvLyDkvKDlhaXkuIDkuKrliKvnmoQgY29udGV4dDJkIOadpee7mOWItlxuICAgIGNhcHR1cmVNYXAod3JhcHBlciwge1xuICAgICAgICBwYWRkaW5nID0gMCxcbiAgICAgICAgcGxhY2VtZW50ID0gJ25vcm1hbCcsXG4gICAgfSkge1xuXG4gICAgICAgIHRoaXMuX2dldEJvdW5kaW5nR3JvdXBSZWN0KCk7XG4gICAgICAgIGNvbnN0IHsgXG4gICAgICAgICAgICB3aWR0aDogcF93aWR0aCwgXG4gICAgICAgICAgICBoZWlnaHQ6IHBfaGVpZ2h0LCBcbiAgICAgICAgICAgIHg6IHBfeCwgXG4gICAgICAgICAgICB5OiBwX3kgXG4gICAgICAgIH0gPSB0aGlzLmJvdW5kaW5nX2JveDtcbiAgICAgICAgbGV0IG1pbmlNYXAgPSB0aGlzLm1pbmlNYXA7XG4gICAgICAgIGlmKCFtaW5pTWFwKSB7XG4gICAgICAgICAgICB0aGlzLm1pbmlNYXAgPSBjcmVhdGVDYW52YXMod3JhcHBlcik7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICAgICAgICByYXdfd2lkdGgsXG4gICAgICAgICAgICAgICAgcmF3X2hlaWdodCxcbiAgICAgICAgICAgIH0gPSB0aGlzLm1pbmlNYXA7XG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3pvb21wYW4nLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyTWFwICYmIHRoaXMuX3JlbmRlck1hcCgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGxldCBwcmVzc0Rvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubWluaU1hcC5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgeyBvZmZzZXRYLCBvZmZzZXRZLCBkZWx0YVgsIGRlbHRhWSB9ID0gZXZlbnRcbiAgICAgICAgICAgICAgICBwcmVzc0Rvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uTW92ZU1hcCAmJiB0aGlzLl9vbk1vdmVNYXAob2Zmc2V0WCwgb2Zmc2V0WSkgIFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHRoaXMubWluaU1hcC5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgeyBvZmZzZXRYLCBvZmZzZXRZLCBkZWx0YVgsIGRlbHRhWSB9ID0gZXZlbnRcbiAgICAgICAgICAgICAgICBpZihwcmVzc0Rvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25Nb3ZlTWFwICYmIHRoaXMuX29uTW92ZU1hcChvZmZzZXRYLCBvZmZzZXRZKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihvZmZzZXRZIDwgNSB8fCBvZmZzZXRYIDwgNSB8fCBvZmZzZXRYID4gd2lkdGgtNSB8fCBvZmZzZXRZID4gaGVpZ2h0LTUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NEb3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHRoaXMubWluaU1hcC5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHByZXNzRG93biA9IGZhbHNlO1xuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgY29uc3QgY2FoZUNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgY2FoZUNhbnZhcy53aWR0aCA9IHJhd193aWR0aDtcbiAgICAgICAgICAgIGNhaGVDYW52YXMuaGVpZ2h0ID0gcmF3X2hlaWdodDtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVNaW5pbWFwQ3R4ID0gY2FoZUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHJhd193aWR0aCxcbiAgICAgICAgICAgIHJhd19oZWlnaHQsXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgc2NhbGUsXG4gICAgICAgICAgICBjdHhcbiAgICAgICAgfSA9IHRoaXMubWluaU1hcFxuICAgICAgICBjb25zdCBwYWQyID0gcGFkZGluZyAqIDI7XG4gICAgICAgIGNvbnN0IHBhZCA9IHBhZGRpbmc7XG4gICAgICAgIGNvbnN0IHIxID0gKHdpZHRoIC0gcGFkMikgLyBwX3dpZHRoO1xuICAgICAgICBjb25zdCByMiA9IChoZWlnaHQgLSBwYWQyKSAvIHBfaGVpZ2h0O1xuICAgICAgICBjb25zdCByID0gTWF0aC5taW4ocjEsIHIyKTtcbiAgICAgICAgXG4gICAgICAgIGxldCBtX3ggPSAwO1xuICAgICAgICBsZXQgbV95ID0gMDtcblxuICAgICAgICBpZihwbGFjZW1lbnQgPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICBtX3kgPSAoaGVpZ2h0IC0gcF9oZWlnaHQgKiByKSAvIDIgLSBwX3kgKiByO1xuICAgICAgICAgICAgbV94ID0gKHdpZHRoIC0gcF93aWR0aCAqIHIpIC8gMiAtIHBfeCAqIHI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZihyMSA8IHIyKSB7XG4gICAgICAgICAgICAgICAgbV95ID0gKGhlaWdodCAtIHBfaGVpZ2h0ICogcikgLyAyIC0gcF95ICogcjtcbiAgICAgICAgICAgICAgICBtX3ggPSBwYWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1feCA9ICh3aWR0aCAtIHBfd2lkdGggKiByKSAvIDIgLSBwX3ggKiByO1xuICAgICAgICAgICAgICAgIG1feSA9IHBhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWNoZWN0eCA9IHRoaXMuY2FjaGVNaW5pbWFwQ3R4O1xuICAgICAgICBjYWNoZWN0eC5zZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgY2FjaGVjdHguY2xlYXJSZWN0KDAsIDAsIHJhd193aWR0aCwgcmF3X2hlaWdodCk7XG4gICAgICAgIGNhY2hlY3R4LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgICAgIGNhY2hlY3R4LnRyYW5zZm9ybShyLCAwLCAwLCByLCBtX3gsIG1feSk7XG4gICAgICAgIC8vIGN0eC5maWxsU3R5bGUgPSAncmVkJztcbiAgICAgICAgLy8gY3R4LmFyYyggMzAsIDMwLCAxMDAsIDAsIDIqTWF0aC5QSSk7XG4gICAgICAgIC8vIGN0eC5maWxsKClcbiAgICAgICAgLy8gZGVidWdnZXJcbiAgICAgICAgY29uc3QgYnIgPSBbMCwwLDAsMF1cbiAgICAgICAgaWYodGhpcy5Ob2RlUmVuZGVyVG9wKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5rU3RhY2sucmVuZGVyKGNhY2hlY3R4LCAobGluaykgPT4geyBsaW5rLmlzSW5WaWV3Qm94KGJyKTsgcmV0dXJuIHRydWU7IH0pO1xuICAgICAgICAgICAgLy8gdGhpcy5fbGlua1N0YWNrLnJlbmRlcihjYWNoZWN0eCk7XG4gICAgICAgICAgICB0aGlzLl9zdGFjay5yZW5kZXIoY2FjaGVjdHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3RhY2sucmVuZGVyKGNhY2hlY3R4KTtcbiAgICAgICAgICAgIHRoaXMuX2xpbmtTdGFjay5yZW5kZXIoY2FjaGVjdHgsIChsaW5rKSA9PiB7IGxpbmsuaXNJblZpZXdCb3goYnIpOyByZXR1cm4gdHJ1ZTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX2NhY2hlTWFwSW1hZ2VEYXRhID0gY2FjaGVjdHguZ2V0SW1hZ2VEYXRhKDAsIDAscmF3X3dpZHRoLCByYXdfaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyTWFwID0gKCkgPT4ge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgcmF3X3dpZHRoLCByYXdfaGVpZ2h0KTtcbiAgICAgICAgICAgIC8vIGlmKCFpKSB7XG4gICAgICAgICAgICBjdHguc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICAgICAgICAgIGN0eC5wdXRJbWFnZURhdGEoX2NhY2hlTWFwSW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2Zvcm0ociwgMCwgMCwgciwgbV94LCBtX3kpO1xuICAgICAgICAgICAgY29uc3QgW3gsIHksIHQsIGRdID0gdGhpcy5fZ2V0Vmlld0JveCgpO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnJlY3QoeCwgeSwgIHQteCwgZC15KTtcbiAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIGN0eC5yZWN0KDAsIDAsIHJhd193aWR0aCwgcmF3X2hlaWdodCk7XG4gICAgICAgICAgICBjdHguY2xpcChcImV2ZW5vZGRcIik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwLjQpJztcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCByYXdfd2lkdGgsIHJhd19oZWlnaHQpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW5kZXJNYXAoKTtcblxuICAgICAgICB0aGlzLl9vbk1vdmVNYXAgPSAob2Zmc2V0WCwgb2Zmc2V0WSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3gsIHksIHQsIGRdID0gdGhpcy5fZ2V0Vmlld0JveCgpO1xuICAgICAgICAgICAgLy8gY29uc3QgdyA9IHQteDtcbiAgICAgICAgICAgIGNvbnN0IGEgPSAodC14KS8yICsgeDtcbiAgICAgICAgICAgIGNvbnN0IGIgPSAoZC15KS8yICsgeTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgcCA9IFthICogciArIG1feCwgYiAqIHIgKyBtX3ldXG4gICAgICAgICAgICB0aGlzLl9yZWNhbGN1bGF0ZVBvc2l0aW9uKChwWzBdIC0gb2Zmc2V0WCkvIHIgKiB0aGlzLnNjYWxlLCAocFsxXSAtIG9mZnNldFkpLyByICogdGhpcy5zY2FsZSk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlck1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMuX3JlbmRlcihjdHgpO1xuICAgIH1cblxuXG59IiwiLyoqXG4gKiBKRmxvdyDmipvlh7rkuovku7ZcbiAqIEBleHRlbmRzIEN1c3RvbUV2ZW50XG4gKiBAcHJvcGVydHkge0V2ZW50fSAgb3JpZ2luRXZlbnQgICAgICAtIOWOn+Wni+S6i+S7tlxuICogQHByb3BlcnR5IHtJbnN0YW5jZX0gdGFyZ2V0ICAgICAgICAgLSDkuovku7bop6blj5Hlr7nosaFcbiAqIEBwcm9wZXJ0eSB7SkZsb3d9IGpmbG93ICAgICAgICAgICAgIC0gSkZsb3cg5a+56LGhXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGJ1YmJsZXMgICAgICAgICAtIOWGkuazoeagh+ivhlxuICovXG5jbGFzcyBKRmxvd0V2ZW50IGV4dGVuZHMgQ3VzdG9tRXZlbnR7XG4gICAgY29uc3RydWN0b3IoZXZlbnQsIGNvbmZpZ3MgPSB7fSkge1xuICAgICAgICBjb25zdCBkZXRhaWwgPSB7XG4gICAgICAgICAgICAuLi5jb25maWdzLFxuICAgICAgICAgICAgb3JpZ2luRXZlbnQ6IGNvbmZpZ3MuZXZlbnQsXG4gICAgICAgICAgICB0YXJnZXQ6IGNvbmZpZ3MudGFyZ2V0LFxuICAgICAgICAgICAgamZsb3c6IGNvbmZpZ3MuamZsb3csXG4gICAgICAgICAgICBidWJibGVzOiBjb25maWdzLmJ1YmJsZXMgfHwgZmFsc2UsICAgIFxuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGV2ZW50LCB7XG4gICAgICAgICAgICBkZXRhaWxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBKRmxvd0V2ZW50OyIsImltcG9ydCBKRmxvd0V2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5leHBvcnQgY2xhc3MgU2Nyb2xsQmFyIHtcbiAgICBjb25zdHJ1Y3RvcihkaXIsIGNvbmZpZ3MgPSB7fSkge1xuICAgICAgICB0aGlzLmFuY2hvciA9IFswLDBdO1xuICAgICAgICB0aGlzLndpZHRoID0gY29uZmlncy5iYXJXaWR0aCB8fCA0O1xuICAgICAgICB0aGlzLmhlaWdodCA9IGNvbmZpZ3MuYmFyV2lkdGggfHwgNDsgIFxuICAgICAgICB0aGlzLmJhck1hcmdpblggPSAwO1xuICAgICAgICB0aGlzLmJhck1hcmdpblkgPSAwXG4gICAgICAgIHRoaXMuZGlyID0gZGlyO1xuICAgICAgICB0aGlzLnBsYWluQ29sb3IgPSBjb25maWdzLnBsYWluQ29sb3IgfHwgJ3JnYmEoMCwgMCwgMCwgMC4xNSknO1xuICAgICAgICB0aGlzLmZvY3VzQ29sb3IgPSBjb25maWdzLmZvY3VzQ29sb3IgfHwgJ3JnYmEoMCwgMCwgMCwgMC4yNSknO1xuICAgICAgICB0aGlzLmlzRm9jdXMgPSBmYWxzZTtcbiAgICB9XG4gICAgcmVuZGVyKGN0eCkge1xuICAgICAgICBjb25zdCBbeCwgeV0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBpZih0aGlzLmRpciA9PT0gJ3gnKSB7XG4gICAgICAgICAgICBjb25zdCByYWRpdXMgPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgICAgICBjb25zdCBjeSA9IHkgKyByYWRpdXM7XG4gICAgICAgICAgICBjb25zdCBieSA9IHkgKyB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHJjID0geCArIHRoaXMud2lkdGggLSB0aGlzLmJhck1hcmdpblgqMiAtIHJhZGl1cztcbiAgICAgICAgICAgIGNvbnN0IGxjID0geCArIHRoaXMuYmFyTWFyZ2luWCArIHJhZGl1c1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhsYywgYnkpO1xuICAgICAgICAgICAgY3R4LmFyYyhsYywgY3ksIHJhZGl1cywgTWF0aC5QSS8yLCBNYXRoLlBJLzIqMyk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHJjLCB5KTtcbiAgICAgICAgICAgIGN0eC5hcmMocmMsIGN5LCByYWRpdXMsICAtTWF0aC5QSS8yLCBNYXRoLlBJLzIpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IHRoaXMud2lkdGggLyAyO1xuICAgICAgICAgICAgY29uc3QgdGMgPSB5ICsgdGhpcy5iYXJNYXJnaW5ZICsgcmFkaXVzO1xuICAgICAgICAgICAgY29uc3QgYmMgPSB5ICsgdGhpcy5oZWlnaHQgLSB0aGlzLmJhck1hcmdpblkqMiAtIHJhZGl1c1xuICAgICAgICAgICAgY29uc3QgY3ggPSB4ICsgcmFkaXVzO1xuICAgICAgICAgICAgY29uc3QgcnggPSB4ICsgdGhpcy53aWR0aDtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgdGMpO1xuICAgICAgICAgICAgY3R4LmFyYyhjeCwgdGMsIHJhZGl1cywgLU1hdGguUEksIDApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhyeCwgYmMpO1xuICAgICAgICAgICAgY3R4LmFyYyhjeCwgYmMsIHJhZGl1cywgMCwgTWF0aC5QSSk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgY3R4LnJlY3QoXG4gICAgICAgICAgICAgICAgLy8geCArIHRoaXMuYmFyTWFyZ2luWCxcbiAgICAgICAgICAgICAgICAvLyB5ICsgdGhpcy5iYXJNYXJnaW5ZLFxuICAgICAgICAgICAgICAgIC8vIHRoaXMud2lkdGggLSB0aGlzLmJhck1hcmdpblgqMixcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmhlaWdodCAtIHRoaXMuYmFyTWFyZ2luWSoyKTtcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5pc0ZvY3VzID8gdGhpcy5mb2N1c0NvbG9yIDogdGhpcy5wbGFpbkNvbG9yO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICBpc0hpdChwb2ludCkge1xuICAgICAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGg7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodDtcbiAgICAgICAgcmV0dXJuIHBvaW50WzBdID4gYW5jaG9yWzBdIC0gNVxuICAgICAgICAgICAgJiYgcG9pbnRbMF0gPCBhbmNob3JbMF0gKyB3ICsgNVxuICAgICAgICAgICAgJiYgcG9pbnRbMV0gPiBhbmNob3JbMV0gLSA1XG4gICAgICAgICAgICAmJiBwb2ludFsxXSA8IGFuY2hvclsxXSArIGggKyA1O1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBpbml0U2Nyb2xsQmFyKGNvbmZpZ3MgPSB7fSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBiYXJDb2xvcixcbiAgICAgICAgICAgIGJhckZvY3VzQ29sb3IsXG4gICAgICAgICAgICBiYXJNYXJnaW5YLFxuICAgICAgICAgICAgYmFyTWFyZ2luWSxcbiAgICAgICAgICAgIGJhcldpZHRoLFxuICAgICAgICB9ID0gY29uZmlncztcbiAgICAgICAgdGhpcy5fc2Nyb2xsYmFyRW5hYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWCA9IG5ldyBTY3JvbGxCYXIoJ3gnLCB7XG4gICAgICAgICAgICBwbGFpbkNvbG9yOiBiYXJDb2xvcixcbiAgICAgICAgICAgIGZvY3VzQ29sb3I6IGJhckZvY3VzQ29sb3IsXG4gICAgICAgICAgICBiYXJXaWR0aCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3Njcm9sbGJhclguYmFyTWFyZ2luWCA9IGJhck1hcmdpblggfHwgNTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX3Njcm9sbGJhclkgPSBuZXcgU2Nyb2xsQmFyKCd5Jywge1xuICAgICAgICAgICAgcGxhaW5Db2xvcjogYmFyQ29sb3IsXG4gICAgICAgICAgICBmb2N1c0NvbG9yOiBiYXJGb2N1c0NvbG9yLFxuICAgICAgICAgICAgYmFyV2lkdGhcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3Njcm9sbGJhclkuYmFyTWFyZ2luWSA9IGJhck1hcmdpblkgfHwgNTtcblxuICAgICAgICB0aGlzLl9zY3JvbGxCYXJTdGF0dXMgPSB7XG4gICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgICAgICB4c2NhbGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHlzY2FsZTogdW5kZWZpbmVkLFxuXG4gICAgICAgICAgICBiYXJJbml0WDogMCxcbiAgICAgICAgICAgIGJhckluaXRZOiAwLFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RvcFpvb21wYW5XYXRjaCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3pvb21wYW4nLCAoKSA9PiB7XG4gICAgICAgICAgICBpZighdGhpcy5zdG9wWm9vbXBhbldhdGNoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxCYXJPblBhbkFuZFpvb20oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIHRoaXMuc2Nyb2xsQmFyT25QYW5BbmRab29tKCk7XG5cbiAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSwgY2xpZW50WCwgY2xpZW50WSB9ID0gZTtcbiAgICAgICAgICAgIHRoaXMub25TY3JvbGxiYXJQcmVzc1N0YXJ0KG9mZnNldFgsIG9mZnNldFksIGNsaWVudFgsIGNsaWVudFkpXG4gICAgICAgIH0pXG4gICAgfSxcbiAgICBjaGVja1Njcm9sbERyYWdnaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsQmFyU3RhdHVzICYmIHRoaXMuX3Njcm9sbEJhclN0YXR1cy5kcmFnZ2luZztcbiAgICB9LFxuICAgIG9uU2Nyb2xsYmFyUHJlc3NTdGFydChvZmZzZXRYLCBvZmZzZXRZLCBjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgICAgIHRoaXMuc3RvcFpvb21wYW5XYXRjaCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHhoaXQgPSB0aGlzLl9zY3JvbGxiYXJYLmlzSGl0KFtvZmZzZXRYLCBvZmZzZXRZXSk7XG4gICAgICAgIGlmKHhoaXQpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fc2Nyb2xsQmFyU3RhdHVzLCB7XG4gICAgICAgICAgICAgICAgZHJhZ2dpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLl9zY3JvbGxiYXJYLFxuICAgICAgICAgICAgICAgIGJhclN0YXJ0WDogdGhpcy5fc2Nyb2xsYmFyWC5hbmNob3JbMF0sXG4gICAgICAgICAgICAgICAgYmFySW5pdFg6IGNsaWVudFgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB5aGl0ID0gdGhpcy5fc2Nyb2xsYmFyWS5pc0hpdChbb2Zmc2V0WCwgb2Zmc2V0WV0pO1xuICAgICAgICBpZih5aGl0KSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3Njcm9sbEJhclN0YXR1cywge1xuICAgICAgICAgICAgICAgIGRyYWdnaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy5fc2Nyb2xsYmFyWSxcbiAgICAgICAgICAgICAgICBiYXJTdGFydFk6IHRoaXMuX3Njcm9sbGJhclkuYW5jaG9yWzFdLFxuICAgICAgICAgICAgICAgIGJhckluaXRZOiBjbGllbnRZLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZiA9IChlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSwgY2xpZW50WCwgY2xpZW50WSB9ID0gZTtcbiAgICAgICAgICAgIHRoaXMub25EcmFnZ2luZ1Njcm9sbGJhcihvZmZzZXRYLCBvZmZzZXRZLCBjbGllbnRYLCBjbGllbnRZKVxuICAgICAgICAgICAgXG4gICAgICAgIH0pLmJpbmQodGhpcyk7XG4gICAgICAgIFxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIGYpO1xuICAgICAgICBjb25zdCB0ID0gKGUgPT4ge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9zY3JvbGxCYXJTdGF0dXMsIHtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICAgICAgICAgIHg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgZik7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCB0KTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHQpO1xuICAgICAgICAgICAgdGhpcy5zdG9wWm9vbXBhbldhdGNoID0gZmFsc2U7XG4gICAgICAgIH0pLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHQsIHtcbiAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSlcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdCwge1xuICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICB9KVxuICAgIH0sXG4gICAgb25EcmFnZ2luZ1Njcm9sbGJhcihvZmZzZXRYLCBvZmZzZXRZLCBjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgICAgIGlmKHRoaXMuX3Njcm9sbGJhckVuYWJsZSAmJiB0aGlzLl9zY3JvbGxCYXJTdGF0dXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgYmFySW5pdFgsXG4gICAgICAgICAgICAgICAgYmFyU3RhcnRYLFxuICAgICAgICAgICAgICAgIGJhckluaXRZLFxuICAgICAgICAgICAgICAgIGJhclN0YXJ0WSxcbiAgICAgICAgICAgICAgICB4c2NhbGUsXG4gICAgICAgICAgICAgICAgeXNjYWxlLFxuICAgICAgICAgICAgICAgIHNjb2xsYmFySGVpZ2h0LFxuICAgICAgICAgICAgICAgIHNjb2xsYmFyV2lkdGgsXG4gICAgICAgICAgICAgICAgcmVhbFIsXG4gICAgICAgICAgICAgICAgcmVhbEwsXG4gICAgICAgICAgICAgICAgcmVhbFQsXG4gICAgICAgICAgICAgICAgcmVhbEIsXG4gICAgICAgICAgICB9ID0gdGhpcy5fc2Nyb2xsQmFyU3RhdHVzO1xuICAgICAgICAgICAgY29uc3QgeyBhY3R1YWxfd2lkdGgsIGFjdHVhbF9oZWlnaHQgfSA9IHRoaXMuY2FudmFzTWV0YTtcbiAgICAgICAgICAgIGNvbnN0IHsgXG4gICAgICAgICAgICAgICAgeDogcF94LCBcbiAgICAgICAgICAgICAgICB5OiBwX3kgXG4gICAgICAgICAgICB9ID0gdGhpcy5ib3VuZGluZ19ib3g7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0YXJnZXQuZGlyLCByZWFsVCwgcmVhbEIpXG4gICAgICAgICAgICBsZXQgZGVsdGFYID0gMCwgZGVsdGFZID0gMDtcbiAgICAgICAgICAgIGlmKHRhcmdldC5kaXIgPT09ICd4Jykge1xuICAgICAgICAgICAgICAgIGRlbHRhWCA9IGNsaWVudFggLSBiYXJJbml0WDtcbiAgICAgICAgICAgICAgICBjb25zdCB4bmV3ID0gYmFyU3RhcnRYICsgZGVsdGFYO1xuICAgICAgICAgICAgICAgIGNvbnN0IHEgPSB0YXJnZXQuYW5jaG9yWzBdID0gTWF0aC5tYXgoTWF0aC5taW4oeG5ldywgYWN0dWFsX3dpZHRoIC0gc2NvbGxiYXJXaWR0aCksIDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhdGlvSW5YID0gcSAvIGFjdHVhbF93aWR0aDtcbiAgICAgICAgICAgICAgICAvLyBjb25zdCB5ID0gKHJlYWxCIC0gKHJlYWxCIC0gcmVhbFQpICogcmF0aW9JblkpICogdGhpcy5zY2FsZVxuICAgICAgICAgICAgICAgIGNvbnN0IHJhdGlvWCA9IChyZWFsUiAtIHJlYWxMKSAqIHJhdGlvSW5YICsgcmVhbExcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gKHBfeCAtIHJhdGlvWCkgKiB0aGlzLnNjYWxlXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnBvc2l0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFg6IHggLSBwX3ggKiB0aGlzLnNjYWxlLFxuICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih0YXJnZXQuZGlyID09PSAneScpIHsgICAgICBcbiAgICAgICAgICAgICAgICBkZWx0YVkgPSBjbGllbnRZIC0gYmFySW5pdFk7XG4gICAgICAgICAgICAgICAgY29uc3QgeW5ldyA9IGJhclN0YXJ0WSArIGRlbHRhWTtcbiAgICAgICAgICAgICAgICBjb25zdCBxID0gdGFyZ2V0LmFuY2hvclsxXSA9IE1hdGgubWF4KE1hdGgubWluKHluZXcsIGFjdHVhbF9oZWlnaHQgLSBzY29sbGJhckhlaWdodCksIDApOztcbiAgICAgICAgICAgICAgICBjb25zdCByYXRpb0luWSA9IHEgLyBhY3R1YWxfaGVpZ2h0O1xuICAgICAgICAgICAgICAgIC8vIGNvbnN0IHkgPSAocmVhbEIgLSAocmVhbEIgLSByZWFsVCkgKiByYXRpb0luWSkgKiB0aGlzLnNjYWxlXG4gICAgICAgICAgICAgICAgY29uc3QgcmF0aW9ZID0gKHJlYWxCIC0gcmVhbFQpICogcmF0aW9JblkgKyByZWFsVFxuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSAocF95IC0gcmF0aW9ZKSAqIHRoaXMuc2NhbGVcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMucG9zaXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WTogeSAtIHBfeSAqIHRoaXMuc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ3pvb21wYW4nLCB7XG4gICAgICAgICAgICAgICAgZGVsdGFYLFxuICAgICAgICAgICAgICAgIGRlbHRhWVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBjaGVja1Njcm9sbEJhckhvdmVyKG9mZnNldFgsIG9mZnNldFkpIHtcbiAgICAgICAgaWYodGhpcy5fc2Nyb2xsYmFyRW5hYmxlKSB7XG4gICAgICAgICAgICBjb25zdCB4aGl0ID0gdGhpcy5fc2Nyb2xsYmFyWC5pc0hpdChbb2Zmc2V0WCwgb2Zmc2V0WV0pO1xuICAgICAgICAgICAgaWYoeGhpdCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuX3Njcm9sbEJhclN0YXR1cy5ob3ZlclRhcmdldCA9IHRoaXMuX3Njcm9sbGJhclg7XG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuX3Njcm9sbGJhclguaXNGb2N1cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxiYXJYLmlzRm9jdXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHloaXQgPSB0aGlzLl9zY3JvbGxiYXJZLmlzSGl0KFtvZmZzZXRYLCBvZmZzZXRZXSk7XG4gICAgICAgICAgICBpZih5aGl0KSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5fc2Nyb2xsQmFyU3RhdHVzLmhvdmVyVGFyZ2V0ID0gdGhpcy5fc2Nyb2xsYmFyWTtcbiAgICAgICAgICAgICAgICBpZighdGhpcy5fc2Nyb2xsYmFyWS5pc0ZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbGJhclkuaXNGb2N1cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIHJlc2V0U2Nyb2xsQmFySG92ZXIoKSB7XG4gICAgICAgIGlmKHRoaXMuX3Njcm9sbGJhckVuYWJsZSkge1xuICAgICAgICAgICAgaWYodGhpcy5fc2Nyb2xsYmFyWS5pc0ZvY3VzIHx8IHRoaXMuX3Njcm9sbGJhclguaXNGb2N1cykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbGJhclkuaXNGb2N1cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbGJhclguaXNGb2N1cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgX2dldFNjcm9sbFZpZXdCb3VuZGluZ2JveCgpIHtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IDEyMDtcbiAgICAgICAgY29uc3QgeyBcbiAgICAgICAgICAgIHdpZHRoOiBwX3dpZHRoLCBcbiAgICAgICAgICAgIGhlaWdodDogcF9oZWlnaHQsIFxuICAgICAgICAgICAgeDogcF94LCBcbiAgICAgICAgICAgIHk6IHBfeSBcbiAgICAgICAgfSA9IHRoaXMuYm91bmRpbmdfYm94O1xuICAgICAgICBjb25zdCBwID0gcGFkZGluZztcbiAgICAgICAgY29uc3QgcDIgPSBwYWRkaW5nICogMjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBwX3dpZHRoICsgcDIsXG4gICAgICAgICAgICBoZWlnaHQ6IHBfaGVpZ2h0ICsgcDIsXG4gICAgICAgICAgICB4OiBwX3ggLSBwLFxuICAgICAgICAgICAgeTogcF95IC0gcFxuICAgICAgICB9XG4gICAgfSxcbiAgICBzY3JvbGxCYXJPblBhbkFuZFpvb20oKSB7XG4gICAgICAgIGlmKCF0aGlzLl9zY3JvbGxiYXJFbmFibGUgfHwgdGhpcy5fc2Nyb2xsQmFyU3RhdHVzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBcbiAgICAgICAgICAgIHdpZHRoOiBwX3dpZHRoLCBcbiAgICAgICAgICAgIGhlaWdodDogcF9oZWlnaHQsIFxuICAgICAgICAgICAgeDogcF94LCBcbiAgICAgICAgICAgIHk6IHBfeSBcbiAgICAgICAgfSA9IHRoaXMuX2dldFNjcm9sbFZpZXdCb3VuZGluZ2JveCgpO1xuICAgICAgICBcbiAgICAgICAgbGV0IFt4LCB5LCByLCBiXSA9IHRoaXMuX2dldFZpZXdCb3goKTtcbiAgICAgICAgY29uc3QgcmVhbFIgPSBNYXRoLm1heChyLCBwX3ggKyBwX3dpZHRoKTtcbiAgICAgICAgY29uc3QgcmVhbEwgPSBNYXRoLm1pbih4LCBwX3gpO1xuICAgICAgICBjb25zdCByZWFsVCA9IE1hdGgubWluKHksIHBfeSk7XG4gICAgICAgIGNvbnN0IHJlYWxCID0gTWF0aC5tYXgoYiwgcF95ICsgcF9oZWlnaHQpO1xuICAgICAgICBjb25zdCB2dyA9IHIgLSB4O1xuICAgICAgICBjb25zdCB2aCA9IGIgLSB5O1xuICAgICAgICBjb25zdCB7IGFjdHVhbF93aWR0aCwgYWN0dWFsX2hlaWdodCB9ID0gdGhpcy5jYW52YXNNZXRhO1xuICAgICAgICBjb25zdCB4c2NhbGUgPSB2dyAvIChyZWFsUiAtIHJlYWxMKVxuICAgICAgICBpZih4c2NhbGUgPCAxKSAge1xuICAgICAgICAgICAgY29uc3Qgc2NvbGxiYXJXaWR0aCA9IGFjdHVhbF93aWR0aCAqIHhzY2FsZTtcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvclggPSAoeCAtIHJlYWxMKSAqIHhzY2FsZSAqIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxiYXJYLmFuY2hvciA9IFthbmNob3JYLCBhY3R1YWxfaGVpZ2h0IC0gMTBdO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWC53aWR0aCA9IHNjb2xsYmFyV2lkdGg7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxCYXJTdGF0dXMuc2NvbGxiYXJXaWR0aCA9IHNjb2xsYmFyV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHlzY2FsZSA9IHZoIC8gKHJlYWxCIC0gcmVhbFQpO1xuICAgICAgICBpZih5c2NhbGUgPCAxKSAge1xuICAgICAgICAgICAgY29uc3Qgc2NvbGxiYXJIZWlnaHQgPSBhY3R1YWxfaGVpZ2h0ICogeXNjYWxlO1xuICAgICAgICAgICAgY29uc3QgYW5jaG9yWSA9ICh5IC0gcmVhbFQpICogeXNjYWxlICogdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbGJhclkuYW5jaG9yID0gW2FjdHVhbF93aWR0aCAtIDEwLCBhbmNob3JZXTtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbGJhclkuaGVpZ2h0ID0gc2NvbGxiYXJIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxCYXJTdGF0dXMuc2NvbGxiYXJIZWlnaHQgPSBzY29sbGJhckhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fc2Nyb2xsQmFyU3RhdHVzLCB7XG4gICAgICAgICAgICB5c2NhbGUsXG4gICAgICAgICAgICB4c2NhbGUsXG4gICAgICAgICAgICByZWFsUixcbiAgICAgICAgICAgIHJlYWxMLFxuICAgICAgICAgICAgcmVhbFQsXG4gICAgICAgICAgICByZWFsQixcbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgfSxcbiAgICByZXNldFNjb2xsQmFyU3RhdHVzKCkge1xuICAgICAgICBpZih0aGlzLl9zY3JvbGxiYXJFbmFibGUpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fc2Nyb2xsQmFyU3RhdHVzLCB7XG4gICAgICAgICAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICAgICAgICAgICB4OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgeTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlclNjcm9sbEJhcihjdHgpIHtcbiAgICAgICAgaWYodGhpcy5fc2Nyb2xsYmFyRW5hYmxlKSB7XG4gICAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKCk7XG4gICAgICAgICAgICBjdHguc2NhbGUodGhpcy5kcHIsIHRoaXMuZHByKTtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICB4c2NhbGUsXG4gICAgICAgICAgICAgICAgeXNjYWxlXG4gICAgICAgICAgICB9ID0gdGhpcy5fc2Nyb2xsQmFyU3RhdHVzO1xuICAgICAgICAgICAgaWYoeHNjYWxlIDwgMSkgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxiYXJYLnJlbmRlcihjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoeXNjYWxlIDwgMSkgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxiYXJZLnJlbmRlcihjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSIsIlxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgdG9nZ2xlUmVuZGVyKHZhbCkge1xuICAgICAgICB0aGlzLl9fcmVuZGVyc3RvcF9fID0gIXZhbDtcbiAgICB9LFxuICAgIGluaXRTY2hlZHVsZSgpIHtcbiAgICAgICAgdGhpcy5fX2Nsb2NrX18gPSB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBzY2hlZHVsZVJlbmRlcihjYWxsYmFjaykge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHRpbWVzdGFtcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNGaXJzdFRpbWUgPSB0aGlzLl9fY2xvY2tfXyAhPT0gdGltZXN0YW1wXG4gICAgICAgICAgICBpZighdGhpcy5fX3JlbmRlcnN0b3BfXyAmJiBpc0ZpcnN0VGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19yZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodGltZXN0YW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX19jbG9ja19fID0gdGltZXN0YW1wO1xuICAgICAgICB9KVxuICAgIH1cbn0iLCIvKipcbiAqIOS6i+S7tuWkhOeQhuWHveaVsFxuICogQG5hbWUgRXZlbnRBZGFwdGVyfkhhbmRsZXJcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSDljp/nlJ/kuovku7ZcbiAqIEBwYXJhbSB7SkZsb3d9IGpmbG93IC0g5b2T5YmNamZsb3cg5a+56LGhXG4gKi9cblxuLyoqXG4gKiBFdmVudEFkYXB0ZXIg5a+56LGhIHBsdWdpbiDphY3nva5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IEV2ZW50QWRhcHRlcn5wbHVnaW5EZWZcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBjYW52YXMgLSBjYW52YXMg55u45YWz55qE5LqL5Lu2XG4gKiBAcHJvcGVydHkge0V2ZW50QWRhcHRlcn5IYW5kbGVyfSBjYW52YXMuZXZlbnROYW1lIC0g5rOo5YaMIGNhbnZhcyDkuIrnmoTkuovku7blpITnkIZcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkb2N1bWVudCAtIGRvY3VtZW50IOebuOWFs+eahOS6i+S7tlxuICogQHByb3BlcnR5IHtFdmVudEFkYXB0ZXJ+SGFuZGxlcn0gZG9jdW1lbnQuZXZlbnROYW1lIC0g5rOo5YaMIGRvY3VtZW50IOS4iueahOS6i+S7tuWkhOeQhlxuICovXG5cbmZ1bmN0aW9uIGdldERlZmF1bHRQbHVnaW4oKSB7XG4gICAgbGV0IF9tb3VzZVN0YXR1cyA9IHtcbiAgICAgICAgLy8geDogdW5kZWZpbmVkLFxuICAgICAgICAvLyB5OiB1bmRlZmluZWQsXG4gICAgICAgIC8vIGVuYWJsZUNsaWNrOiBmYWxzZSxcbiAgICAgICAgcG9pbnRlckRvd246IGZhbHNlLFxuICAgICAgICBkaXJ0eTogZmFsc2UsXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNhbnZhczoge1xuICAgICAgICAgICAgd2hlZWw6IGZ1bmN0aW9uIChldmVudCwgamZsb3cpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGxldCB7IG9mZnNldFgsIG9mZnNldFksIGRlbHRhWCwgZGVsdGFZIH0gPSBldmVudFxuICAgICAgICAgICAgICAgIGlmKGV2ZW50LmN0cmxLZXkpIHsgXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhWSA9IC1kZWx0YVk7XG4gICAgICAgICAgICAgICAgICAgIGpmbG93Lnpvb21IYW5kbGVyKG9mZnNldFgsIG9mZnNldFksIGRlbHRhWCwgZGVsdGFZLCBldmVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgamZsb3cucGFuSGFuZGxlcigtZGVsdGFYLCAtZGVsdGFZLCBldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvaW50ZXJkb3duOiBmdW5jdGlvbiAoZXZlbnQsIGpmbG93KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZLCBkZWx0YVksIGJ1dHRvbiB9ID0gZXZlbnRcbiAgICAgICAgICAgICAgICBpZihidXR0b24gIT09IDApIHJldHVybjtcbiAgICAgICAgICAgICAgICBfbW91c2VTdGF0dXMucG9pbnRlckRvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGpmbG93LnByZXNzU3RhcnRIYW5kbGVyKG9mZnNldFgsIG9mZnNldFksIGV2ZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb2ludGVybW92ZTogZnVuY3Rpb24gKGV2ZW50LCBqZmxvdykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnRcbiAgICAgICAgICAgICAgICBpZihfbW91c2VTdGF0dXMucG9pbnRlckRvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgX21vdXNlU3RhdHVzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgamZsb3cucHJlc3NNb3ZlSGFuZGxlcihvZmZzZXRYLCBvZmZzZXRZLCBldmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9pbnRlcnVwOiBmdW5jdGlvbiAoZXZlbnQsIGpmbG93KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAvLyBldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgQUxXQVlTIEVOQUJMRSBQUk9QQUdBVElPTiBcbiAgICAgICAgICAgICAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFksIGJ1dHRvbiB9ID0gZXZlbnRcbiAgICAgICAgICAgICAgICBpZihidXR0b24gIT09IDApIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZihfbW91c2VTdGF0dXMucG9pbnRlckRvd24gJiYgX21vdXNlU3RhdHVzLmRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIF9tb3VzZVN0YXR1cy5wb2ludGVyRG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfbW91c2VTdGF0dXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgamZsb3cucHJlc3NVcEhhbmxkZXIoZmFsc2UsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGV4dG1lbnU6IGZ1bmN0aW9uIChldmVudCwgamZsb3cpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgamZsb3cuY29udGV4dE1lbnVIYW5sZGVyKG9mZnNldFgsIG9mZnNldFksIGV2ZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYmxjbGljazogZnVuY3Rpb24gKGV2ZW50LCBqZmxvdykge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcbiAgICAgICAgICAgICAgICBqZmxvdy5kYmxjbGlja0hhbmRsZXIob2Zmc2V0WCwgb2Zmc2V0WSwgZXZlbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbihldmVudCwgamZsb3cpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgaWYoIV9tb3VzZVN0YXR1cy5kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBfbW91c2VTdGF0dXMucG9pbnRlckRvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX21vdXNlU3RhdHVzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGpmbG93LmNsaWNrSGFubGRlcihvZmZzZXRYLCBvZmZzZXRZLCBldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkb2N1bWVudDoge1xuICAgICAgICAgICAgcG9pbnRlcnVwOiBmdW5jdGlvbihldmVudCwgamZsb3cpIHtcbiAgICAgICAgICAgICAgICBqZmxvdy5wcmVzc1VwSGFubGRlcih0cnVlLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKiBcbiAqIEV2ZW50QWRhcHRlciDlr7nosaFcbiAqIEV2ZW50QWRhcHRlciDpgJrov4cgcGx1Z2luIOeahOW9ouW8j+WunueOsOWkmuenjeS6pOS6kuaWueW8j+eahOaYoOWwhFxuICogQGNvbnN0cnVjdG9yIEV2ZW50QWRhcHRlclxuICovXG5jbGFzcyBFdmVudEFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHBsdWdpbiA9IHt9KSB7XG4gICAgICAgIHRoaXMucGx1Z2luID0gZ2V0RGVmYXVsdFBsdWdpbigpO1xuICAgICAgICB0aGlzLnVzZShwbHVnaW4pO1xuICAgICAgICB0aGlzLmNhbnZhc0hhbmRsZXJzID0gW107XG4gICAgICAgIHRoaXMuZG9jdW1lbnRIYW5kbGVycyA9IFtdO1xuICAgIH1cbiAgICB1c2UocGx1Z2luID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBjYW52YXM6IGNhLCBkb2N1bWVudDogZG9jT2JqIH0gPSBwbHVnaW47XG4gICAgICAgIGlmKGNhKSB7XG4gICAgICAgICAgICBmb3IobGV0IGV2ZW50TmFtZSBpbiBjYSl7XG4gICAgICAgICAgICAgICAgaWYgKGNhLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uY2FudmFzW2V2ZW50TmFtZV0gPSBjYVtldmVudE5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZihkb2NPYmopIHtcbiAgICAgICAgICAgIGZvcihsZXQgZXZlbnROYW1lIGluIGRvY09iail7XG4gICAgICAgICAgICAgICAgaWYgKGRvY09iai5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLmRvY3VtZW50W2V2ZW50TmFtZV0gPSBkb2NPYmpbZXZlbnROYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhcHBseShqZmxvdykge1xuICAgICAgICBjb25zdCB7IGNhbnZhczogY2EsIGRvY3VtZW50OiBkb2NPYmogfSA9IHRoaXMucGx1Z2luO1xuICAgICAgICBjb25zdCBjYW52YXMgPSBqZmxvdy5jYW52YXM7XG4gICAgICAgIGZvcihsZXQgZXZlbnROYW1lIGluIGNhKXtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBjYVtldmVudE5hbWVdO1xuICAgICAgICAgICAgZnVuY3Rpb24gaGFuZGxlcldyYXBwZXJkIChlKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcihlLCBqZmxvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXJXcmFwcGVyZClcbiAgICAgICAgICAgIHRoaXMuY2FudmFzSGFuZGxlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgZXZlbnROYW1lLFxuICAgICAgICAgICAgICAgIGhhbmRsZXJXcmFwcGVyZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGxldCBldmVudE5hbWUgaW4gZG9jT2JqKXtcbiAgICAgICAgICAgIGxldCBoYW5kbGVyO1xuICAgICAgICAgICAgbGV0IG9wdGlvbnMgPSB7fVxuICAgICAgICAgICAgaWYodHlwZW9mIGRvY09ialtldmVudE5hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IGRvY09ialtldmVudE5hbWVdXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBkb2NPYmpbZXZlbnROYW1lXS5oYW5kbGVyO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgZG9jT2JqW2V2ZW50TmFtZV0ub3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVyV3JhcHBlcmQgKGUpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGUsIGpmbG93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyV3JhcHBlcmQsIG9wdGlvbnMpXG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50SGFuZGxlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgZXZlbnROYW1lLFxuICAgICAgICAgICAgICAgIGhhbmRsZXJXcmFwcGVyZCxcbiAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVubG9hZChqZmxvdykge1xuICAgICAgICBjb25zdCBjYW52YXMgPSBqZmxvdy5jYW52YXM7XG4gICAgICAgIHRoaXMuY2FudmFzSGFuZGxlcnMuZm9yRWFjaCgoeyBldmVudE5hbWUsIGhhbmRsZXJXcmFwcGVyZCB9KSA9PiB7XG4gICAgICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXJXcmFwcGVyZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRvY3VtZW50SGFuZGxlcnMuZm9yRWFjaCgoeyBldmVudE5hbWUsIGhhbmRsZXJXcmFwcGVyZCwgb3B0aW9ucyB9KSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygndW5sb2FkJywgZXZlbnROYW1lKVxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXJXcmFwcGVyZCwgb3B0aW9ucyk7XG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFdmVudEFkYXB0ZXI7XG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuL25vZGUnO1xuaW1wb3J0IFN0YWNrTWl4aW4gZnJvbSAnLi9zdGFja01peGluJztcbmltcG9ydCBMYXlvdXRNaXhpbiBmcm9tICcuL2xheW91dE1peGluJztcbmltcG9ydCB7IGJvdW5kaW5nX2JveCB9IGZyb20gJy4uL3V0aWxzL2Z1bmN0aW9ucyc7XG5pbXBvcnQgeyBESVJFQ1RJT04gfSBmcm9tICcuLi91dGlscy9jb25zdGFuY2UnO1xuY29uc3QgR3JvdXBNaXhpbiA9IHtcbiAgICAuLi5TdGFja01peGluLFxuICAgIC4uLkxheW91dE1peGluLFxuICAgIF9zZXRQYWRkaW5nKGNvbmZpZ3MpIHtcbiAgICAgICAgdGhpcy5wYWRkaW5nID0ge1xuICAgICAgICAgICAgdG9wOiBjb25maWdzLnBhZGRpbmdUb3AgfHwgY29uZmlncy5wYWRkaW5nIHx8IDAsXG4gICAgICAgICAgICByaWdodDogY29uZmlncy5wYWRkaW5nUmlnaHQgfHwgY29uZmlncy5wYWRkaW5nIHx8IDAsXG4gICAgICAgICAgICBib3R0b206IGNvbmZpZ3MucGFkZGluZ0JvdHRvbSB8fCBjb25maWdzLnBhZGRpbmcgfHwgMCxcbiAgICAgICAgICAgIGxlZnQ6IGNvbmZpZ3MucGFkZGluZ0xlZnQgfHwgY29uZmlncy5wYWRkaW5nIHx8IDAsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBfc2V0TWFyZ2luKGNvbmZpZ3MpICB7XG4gICAgICAgIHRoaXMubWFyZ2luID0ge1xuICAgICAgICAgICAgdG9wOiBjb25maWdzLm1hcmdpblRvcCB8fCBjb25maWdzLm1hcmdpbiB8fCAwLFxuICAgICAgICAgICAgcmlnaHQ6IGNvbmZpZ3MubWFyZ2luUmlnaHQgfHwgY29uZmlncy5tYXJnaW4gfHwgMCxcbiAgICAgICAgICAgIGJvdHRvbTogY29uZmlncy5tYXJnaW5Cb3R0b20gfHwgY29uZmlncy5tYXJnaW4gfHwgMCxcbiAgICAgICAgICAgIGxlZnQ6IGNvbmZpZ3MubWFyZ2luTGVmdCB8fCBjb25maWdzLm1hcmdpbiB8fCAwLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgX2dldENlbnRlcigpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLnBhZGRpbmc7XG4gICAgICAgIGNvbnN0IG1hcmdpbiA9IHRoaXMubWFyZ2luO1xuICAgICAgICBjb25zdCBteCA9IChtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCkvMjtcbiAgICAgICAgY29uc3QgbXkgPSAobWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20pLzI7XG4gICAgICAgIGNvbnN0IGNlbnRlclggPSAocGFkZGluZy5sZWZ0IC0gcGFkZGluZy5yaWdodCkvMiArIG14O1xuICAgICAgICBjb25zdCBjZW50ZXJZID0gKHBhZGRpbmcudG9wIC0gcGFkZGluZy5ib3R0b20pLzIgKyBteTtcbiAgICAgICAgdGhpcy5fc2hhcGUuYW5jaG9yID0gW2FuY2hvclswXSArIG14LCBhbmNob3JbMV0gKyBteV07XG4gICAgICAgIHRoaXMuX2NlbnRlclswXSA9IGFuY2hvclswXSArIGNlbnRlclg7XG4gICAgICAgIHRoaXMuX2NlbnRlclsxXSA9IGFuY2hvclsxXSArIGNlbnRlclk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jZW50ZXI7XG4gICAgfSxcbiAgICBzZXRBbmNob3JYKHgpIHtcbiAgICAgICAgdGhpcy5hbmNob3JbMF0gPSB4O1xuICAgICAgICB0aGlzLl9nZXRDZW50ZXIoKTsgXG4gICAgfSxcbiAgICBzZXRBbmNob3JZKHkpIHtcbiAgICAgICAgdGhpcy5hbmNob3JbMV0gPSB5O1xuICAgICAgICB0aGlzLl9nZXRDZW50ZXIoKTsgXG4gICAgfSxcbiAgICBzZXRBbmNob3IoeCwgeSkge1xuICAgICAgICB0aGlzLmFuY2hvclswXSA9IHg7XG4gICAgICAgIHRoaXMuYW5jaG9yWzFdID0geTtcbiAgICAgICAgdGhpcy5fZ2V0Q2VudGVyKCk7IFxuICAgIH0sXG4gICAgX2NhbGN1bGF0ZVBvaW50QmFjayhwb2ludCkge1xuICAgICAgICBjb25zdCBbZ3gsIGd5XSA9IHBvaW50O1xuICAgICAgICBjb25zdCBbY3gsIGN5XSA9IHRoaXMuX2dldENlbnRlcigpOyBcbiAgICAgICAgY29uc3QgcCA9IFtneCAtIGN4LCBneSAtIGN5XVxuICAgICAgICByZXR1cm4gcFxuICAgIH0sXG4gICAgX2NhbGN1bGF0ZVBvaW50QmFja1dpdGhQb2ludChhLCBiLCBhcnIsIGlkeDEsIGlkeDIpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLnBhZGRpbmc7XG4gICAgICAgIGNvbnN0IG1hcmdpbiA9IHRoaXMubWFyZ2luO1xuICAgICAgICBhcnJbaWR4MV0gPSBhIC0gKCBhbmNob3JbMF0gKyAocGFkZGluZy5sZWZ0IC0gcGFkZGluZy5yaWdodCkvMiArIChtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCkvMiApO1xuICAgICAgICBhcnJbaWR4Ml0gPSBiIC0gKCBhbmNob3JbMV0gKyAocGFkZGluZy50b3AgLSBwYWRkaW5nLmJvdHRvbSkvMiArIChtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSkvMiApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICog5Y+N566X5ZueIGNhbnZhcyDpobblsYLlnZDmoIdcbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBwb2ludFxuICAgICAqIEByZXR1cm4ge051bWJlcltdfSDkuJbnlYzlnZDmoIdcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbihwb2ludCkge1xuICAgICAgICBjb25zdCBbZ3gsIGd5XSA9IHBvaW50O1xuICAgICAgICBjb25zdCBbY3gsIGN5XSA9IHRoaXMuX2dldENlbnRlcigpOyBcbiAgICAgICAgLy8gY29uc3QgcCA9IFtjeCArIGFuY2hvclswXSAtIHNwYW5ILCBjeSArIGFuY2hvclsxXSAtIHNwYW5WXTtcbiAgICAgICAgY29uc3QgcCA9IFtneCArIGN4LCBneSArIGN5XVxuICAgICAgICBpZih0aGlzLl9iZWxvbmdzICYmIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKHApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIOWPjeeul+WbnumhtemdoueahOWDj+e0oOWdkOagh++8jOmHjei9vSB7QGxpbmsgSW5zdGFuY2UjY2FsY3VsYXRlVG9SZWFsV29ybGR9XG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJbXX0g5LiW55WM5Z2Q5qCHXG4gICAgICovXG4gICAgY2FsY3VsYXRlVG9SZWFsV29ybGQocG9pbnQpIHtcbiAgICAgICAgY29uc3QgW2d4LCBneV0gPSBwb2ludDtcbiAgICAgICAgY29uc3QgW2N4LCBjeV0gPSB0aGlzLl9nZXRDZW50ZXIoKTsgXG4gICAgICAgIGNvbnN0IHAgPSBbZ3ggKyBjeCwgZ3kgKyBjeV1cbiAgICAgICAgaWYodGhpcy5fYmVsb25ncyAmJiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvUmVhbFdvcmxkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb1JlYWxXb3JsZChwKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjYWxjdWxhdGVUb1JlYWxXb3JsZFdpdGhQb2ludGVyKG91dHBvaW50LCBpbnBvaW50KSB7XG4gICAgICAgIG91dHBvaW50WzBdID0gaW5wb2ludFswXSArIHRoaXMuX2NlbnRlclswXTtcbiAgICAgICAgb3V0cG9pbnRbMV0gPSBpbnBvaW50WzFdICsgdGhpcy5fY2VudGVyWzFdO1xuICAgICAgICBpZih0aGlzLl9iZWxvbmdzICYmIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9SZWFsV29ybGRXaXRoUG9pbnRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9SZWFsV29ybGRXaXRoUG9pbnRlcihvdXRwb2ludCwgb3V0cG9pbnQpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgQyA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIGNvbnN0IGNvbmZpZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9yYXdDb25maWdzLCB7XG4gICAgICAgICAgICBsYXlvdXQ6IHRoaXMuX2xheW91dCAmJiB0aGlzLl9sYXlvdXQuY2xvbmUoKSxcbiAgICAgICAgfSlcbiAgICAgICAgY29uc3QgdCA9IG5ldyBDKGNvbmZpZ3MpO1xuICAgICAgICB0aGlzLmludGVyYXRlTm9kZVN0YWNrKChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgICAgdC5hZGRUb1N0YWNrKGluc3RhbmNlLmNsb25lKCkpO1xuICAgICAgICB9KVxuICAgICAgICB0LnJlY2FsY3VsYXRlKCk7XG4gICAgICAgIHQudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfSxcbiAgICBnZXRCb3VuZGluZ0RpbWVuc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZ2V0Qm91bmRpbmdSZWN0KCkge1xuICAgICAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGggLzI7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICBjb25zdCBsdHggPSBhbmNob3JbMF0gLSB3O1xuICAgICAgICBjb25zdCBsdHkgPSBhbmNob3JbMV0gLSBoO1xuICAgICAgICBjb25zdCByYnggPSBhbmNob3JbMF0gKyB3O1xuICAgICAgICBjb25zdCByYnkgPSBhbmNob3JbMV0gKyBoO1xuICAgICAgICBjb25zdCBiciA9IHRoaXMuX2JvdW5kaW5ncmVjdDtcbiAgICAgICAgYnJbMF0gPSBsdHg7XG4gICAgICAgIGJyWzFdID0gbHR5O1xuICAgICAgICBiclsyXSA9IHJieDtcbiAgICAgICAgYnJbM10gPSByYnk7XG4gICAgICAgIHJldHVybiBiclxuICAgIH0sXG4gICAgZ2V0SW50ZXJzZWN0aW9uc0luRm91ckRpbWVuc2lvbigpIHtcbiAgICAgICAgbGV0IHAyID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGlmKHRoaXMuX2JlbG9uZ3MgJiYgdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbikge1xuICAgICAgICAgICAgcDIgPSB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKHAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IFt4MiwgeTJdID0gcDI7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoLzI7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW0RJUkVDVElPTi5SSUdIVF06ICBbeDIrdywgeTJdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5MRUZUXTogICBbeDItdywgeTJdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5CT1RUT01dOiBbeDIsIHkyK2hdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5UT1BdOiAgICBbeDIsIHkyLWhdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5TRUxGXTogICBbeDIrdyowLjYxOCwgeTIraCowLjYxOF1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgY2FsY3VsYXRlSW50ZXJzZWN0aW9uKHBvaW50KSB7XG4gICAgICAgIGNvbnN0IFt4MSwgeTFdID0gcG9pbnQ7XG4gICAgICAgIGNvbnN0IFt4MiwgeTJdID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoLzI7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICBjb25zdCB2ZWN4ID0geDIgLSB4MTtcbiAgICAgICAgY29uc3QgdmVjeSA9IHkyIC0geTE7XG4gICAgICAgIGNvbnN0IHRoZXRhMSA9IGgvdztcbiAgICAgICAgY29uc3QgdGhldGEyID0gTWF0aC5hYnModmVjeS92ZWN4KTtcbiAgICAgICAgY29uc3QgZGlyeCA9IHgxID4geDI7XG4gICAgICAgIGNvbnN0IGRpcnkgPSB5MSA+IHkyO1xuICAgICAgICBsZXQgeCwgeTtcbiAgICAgICAgaWYodGhldGEyIDwgdGhldGExKSB7XG4gICAgICAgICAgICB4ID0geDIgKyAoZGlyeD93Oi13KTtcbiAgICAgICAgICAgIHkgPSB3ICogKGRpcnk/dGhldGEyOi10aGV0YTIpICsgeTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5ID0geTIgKyAoZGlyeT9oOi1oKTtcbiAgICAgICAgICAgIHggPSBoIC8gKGRpcng/dGhldGEyOi10aGV0YTIpICsgeDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9LFxuICAgIG9uRW50ZXJWaWV3Ym94KCkge1xuICAgICAgICB0aGlzLmludGVyYXRlTm9kZVN0YWNrKChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgICAgaW5zdGFuY2Uub25FbnRlclZpZXdib3goKTtcbiAgICAgICAgfSlcbiAgICB9LFxuICAgIG9uTGVhdmVWaWV3Ym94KCkge1xuICAgICAgICB0aGlzLmludGVyYXRlTm9kZVN0YWNrKChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgICAgaW5zdGFuY2Uub25MZWF2ZVZpZXdib3goKTtcbiAgICAgICAgfSlcbiAgICB9LFxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3NoYXBlLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pbnRlcmF0ZU5vZGVTdGFjaygoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICAgIGluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgICAgfSlcbiAgICB9LFxuICAgIFxuICAgIGRvUmVjYWxjdWxhdGUoKSB7XG4gICAgICAgIGlmKHRoaXMuX19tb3VudGVkX18pIHtcbiAgICAgICAgICAgIHRoaXMucmVjYWxjdWxhdGVVcCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9fbW91bnRlZF9fID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0U2hpZnQod2lkdGgsIGhlaWdodCkge1xuICAgIHJldHVybiBbd2lkdGgsIGhlaWdodF07XG59XG5cbi8qKlxuICog5qC55o2ucGFkZGluZ2JveOWuvemrmOadpeiuoeeul3NoYXBlc2hpZnRib3jnmoTlrr3pq5hcbiAqIEBmdW5jdGlvbiBzaGFwZVNoaWZ0XG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggICAgICAgICAgICAtIHBhZGRpbmdCb3jlrr1cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgICAgICAgICAgIC0gcGFkZGluZ0JveOmrmFxuICogQHJldHVybiB7bnVtYmVyW119XG4gKi9cblxuLyoqXG4gKiDnu4Tlt6XljoLlh73mlbDvvIznlKjkuo7pgJrov4dKRmxvdyDnu5jlm77oioLngrnmnaXliJvlu7rkuI3lkIznmoTnu4RcbiAqIEBnbG9iYWwgXG4gKiBAZnVuY3Rpb24gR3JvdXBGYWN0b3J5XG4gKiBAcGFyYW0ge05vZGV9IGpmbG93Tm9kZUNvbnN0cnVjdG9yIC0g57uY5Zu+6IqC54K55p6E6YCg5ZmoXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgICAgICAgICAgIC0g6YWN572u6aG5XG4gKiBAcGFyYW0ge3NoYXBlU2hpZnR9IG9wdGlvbnMuc2hhcGVTaGlmdCAtIHNoaWZ05bGC6YCC6YWN5pa55rOVXG4gKiBAcmV0dXJuIHtHcm91cH0gLSDnu5jlm77oioLngrnmnoTpgKDlmahcbiAqL1xuZnVuY3Rpb24gR3JvdXBGYWN0b3J5KGpmbG93Tm9kZUNvbnN0cnVjdG9yLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBzaGFwZVNoaWZ0ID0gdHlwZW9mIG9wdGlvbnMuc2hhcGVTaGlmdCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuc2hhcGVTaGlmdCA6IGRlZmF1bHRTaGlmdDtcblxuICAgIC8qKlxuICAgICAqIEdyb3VwIOmFjee9rlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IEdyb3VwVGVtcGxhdGV+R3JvdXBDb25maWdzXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoICAgICAgICAgICAgIC0g6K6+5a6a5a695bqmXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1pbldpZHRoICAgICAgICAgIC0g5pyA5bCP5a695bqmXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAgICAgICAgICAgIC0g6K6+5a6a6auY5bqmXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHBhZGRpbmcgICAgICAgICAgLSDlhoXovrnot51cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcGFkZGluZ1RvcCAgICAgICAgICAtIOWGheS4iui+uei3nVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwYWRkaW5nUmlnaHQgICAgICAgICAtIOWGheWPs+i+uei3nVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwYWRkaW5nQm90dG9tICAgICAgICAtIOWGheS4i+i+uei3nVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwYWRkaW5nTGVmdCAgICAgICAgICAtIOWGheW3pui+uei3nVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXJnaW4gICAgICAgICAgICAtIOWklui+uei3nVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXJnaW5Ub3AgICAgICAgICAgLSDlpJbkuIrovrnot51cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWFyZ2luUmlnaHQgICAgICAgICAtIOWkluWPs+i+uei3nVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXJnaW5Cb3R0b20gICAgICAgIC0g5aSW5LiL6L656LedXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1hcmdpbkxlZnQgICAgICAgICAgLSDlpJblt6bovrnot51cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGxvY2sgICAgICAgICAgICAtIOW4g+WxgOmUgeWumueKtuaAgSDpu5jorqQgdHJ1ZVxuICAgICAqL1xuICAgIGNsYXNzIHQgZXh0ZW5kcyBOb2RlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICogQGNvbnN0cnVjdHMgR3JvdXBUZW1wbGF0ZVxuICAgICAgICAqIEBwYXJhbSB7R3JvdXBUZW1wbGF0ZX5Hcm91cENvbmZpZ3N9IGNvbmZpZ3MgLSDnu4TphY3nva5cbiAgICAgICAgKiBAbWl4ZXMgTGF5b3V0TWl4aW5cbiAgICAgICAgKiBAbWl4ZXMgU3RhY2tNaXhpbiBcbiAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoY29uZmlncykge1xuICAgICAgICAgICAgc3VwZXIoY29uZmlncyk7XG4gICAgICAgICAgICB0aGlzLmluaXRTdGFjayhjb25maWdzKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdExheW91dChjb25maWdzKTtcbiAgICAgICAgICAgIC8qKiBAbWVtYmVyIHtOb2RlfSAgICAgIC0g5aOz57uY5Zu+5Y2V5YWDICovXG4gICAgICAgICAgICB0aGlzLl9zaGFwZSA9IG5ldyBqZmxvd05vZGVDb25zdHJ1Y3Rvcihjb25maWdzKTtcbiAgICAgICAgICAgIHRoaXMuX3NoYXBlLmFuY2hvciA9IFswLCAwXTtcbiAgICAgICAgICAgIHRoaXMuX3NoYXBlLl9iZWxvbmdzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX2NlbnRlciA9IFswLDBdO1xuICAgICAgICAgICAgdGhpcy5fc2V0UGFkZGluZyhjb25maWdzKTtcbiAgICAgICAgICAgIHRoaXMuX3NldE1hcmdpbihjb25maWdzKTsgIFxuICAgICAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgICAtIOiuvuWumuWuveW6piAqL1xuICAgICAgICAgICAgdGhpcy5kZWZpbmVkV2lkdGggPSAgICAgY29uZmlncy53aWR0aDtcbiAgICAgICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgICAgLSDmnIDlsI/lrr3luqYgKi9cbiAgICAgICAgICAgIHRoaXMubWluV2lkdGggPSAgICAgICAgIGNvbmZpZ3MubWluV2lkdGg7XG4gICAgICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAgIC0g6K6+5a6a55qE6auY5bqmICovXG4gICAgICAgICAgICB0aGlzLmRlZmluZWRIZWlnaHQgPSAgICBjb25maWdzLmhlaWdodDtcbiAgICAgICAgICAgIC8qKiBAbWVtYmVyIHtCb29sZWFufSAgICAgIC0g57uE5YaF5YWD57Sg5piv5ZCm6ZSB5a6a77yMIOm7mOiupHRydWUgKi9cbiAgICAgICAgICAgIHRoaXMubG9jayA9ICAgICAgICAgICAgIGNvbmZpZ3MubG9jayA/PyB0cnVlIDtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9ICAgICAgICAgIGNvbmZpZ3MuZGlzcGxheSB8fCAnZGVmYXVsdCc7XG4gICAgICAgICAgICAvKiogQG1lbWJlciB7Qm9vbGVhbn0gICAgICAtIOe7hOacrOi6q+aYr+WQpui/m+WFpeW9oueKtuWIpOWumuiMg+WbtCAqL1xuICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVudCA9ICAgICAgY29uZmlncy50cmFuc3BhcmVudCA/PyBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2dldEJvdW5kaW5nR3JvdXBSZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnJlZmxvdygpO1xuICAgICAgICAgICAgdGhpcy5fZ2V0Qm91bmRpbmdHcm91cFJlY3QoKTsgIFxuICAgICAgICAgICAgdGhpcy5fY2FjaGVWaWV3Qm94ID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih0LnByb3RvdHlwZSwgR3JvdXBNaXhpbik7XG4gICAgT2JqZWN0LmFzc2lnbih0LnByb3RvdHlwZSwgeyBcbiAgICAgICAgcmVmbG93KCkge1xuICAgICAgICAgICAgR3JvdXBNaXhpbi5yZWZsb3cuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IG1hcmdpbiA9IHRoaXMubWFyZ2luO1xuICAgICAgICAgICAgY29uc3QgW3NoYXBlV2lkdGgsIHNoYXBlSGVpZ2h0XSA9IHNoYXBlU2hpZnQoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSwgdGhpcy5fc2hhcGUpO1xuICAgICAgICAgICAgdGhpcy5fc2hhcGUud2lkdGggPSBzaGFwZVdpZHRoO1xuICAgICAgICAgICAgdGhpcy5fc2hhcGUuaGVpZ2h0ID0gc2hhcGVIZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldENvbmZpZyhjb25maWdzKSB7XG4gICAgICAgICAgICB0aGlzLl9zaGFwZS5zZXRDb25maWcoY29uZmlncyk7XG4gICAgICAgICAgICB0aGlzLl9zZXRQYWRkaW5nKGNvbmZpZ3MpO1xuICAgICAgICAgICAgdGhpcy5fc2V0TWFyZ2luKGNvbmZpZ3MpOyAgXG4gICAgICAgICAgICBpZignb3BhY2l0eScgaW4gY29uZmlncykge1xuICAgICAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IGNvbmZpZ3Mub3BhY2l0eVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihjb25maWdzLmxheW91dCAmJiB0aGlzLl9sYXlvdXQgIT09IGNvbmZpZ3MubGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0ID0gY29uZmlncy5sYXlvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRCb3VuZGluZ0dyb3VwUmVjdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX3N0YWNrLmdldEJvdW5kaW5nUmVjdFBvaW50cygpO1xuICAgICAgICAgICAgLy8gY29udGVudCBib3ggXG4gICAgICAgICAgICBjb25zdCBiYm94ID0gYm91bmRpbmdfYm94KHBvaW50cyk7XG5cbiAgICAgICAgICAgICAvLyBwYWRkaW5nIGJveCBcbiAgICAgICAgICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLnBhZGRpbmc7XG4gICAgICAgICAgICBjb25zdCBtaW5XaWR0aCA9IHRoaXMubWluV2lkdGgvLyAtIHBhZGRpbmcubGVmdCAtIHBhZGRpbmcucmlnaHQ7XG4gICAgICAgICAgICBjb25zdCBkZWZpbmVkV2lkdGggPSB0aGlzLmRlZmluZWRXaWR0aC8vIC0gcGFkZGluZy5sZWZ0IC0gcGFkZGluZy5yaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHcgPSBiYm94LndpZHRoICsgcGFkZGluZy5sZWZ0ICsgcGFkZGluZy5yaWdodDtcbiAgICAgICAgICAgIGNvbnN0IGggPSBiYm94LmhlaWdodCArIHBhZGRpbmcudG9wICsgcGFkZGluZy5ib3R0b207XG4gICAgICAgICAgICBjb25zdCBwYWRkaW5nV2lkdGggPSBtaW5XaWR0aCA/IE1hdGgubWF4KG1pbldpZHRoLCB3KSA6IGRlZmluZWRXaWR0aCB8fCB3O1xuICAgICAgICAgICAgY29uc3QgcGFkZGluZ0hlaWdodCA9IHRoaXMuZGVmaW5lZEhlaWdodCB8fCBoO1xuICAgICAgICAgICAgdGhpcy5fcGFkZGluZ1dpZHRoID0gcGFkZGluZ1dpZHRoO1xuICAgICAgICAgICAgdGhpcy5fcGFkZGluZ0hlaWdodCA9IHBhZGRpbmdIZWlnaHQ7XG5cbiAgICAgICAgICAgIC8vIHNoYXBlQm94XG4gICAgICAgICAgICBjb25zdCBbc2hhcGVXaWR0aCwgc2hhcGVIZWlnaHRdID0gc2hhcGVTaGlmdChwYWRkaW5nV2lkdGgsIHBhZGRpbmdIZWlnaHQsIHRoaXMuX3NoYXBlKVxuICAgICAgICAgICAgdGhpcy5fc2hhcGUud2lkdGggPSBzaGFwZVdpZHRoO1xuICAgICAgICAgICAgdGhpcy5fc2hhcGUuaGVpZ2h0ID0gc2hhcGVIZWlnaHQ7XG4gICAgICAgICAgICAvLyBtYXJnaW5Cb3hcbiAgICAgICAgICAgIGNvbnN0IG1hcmdpbiA9IHRoaXMubWFyZ2luO1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHNoYXBlV2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gc2hhcGVIZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0Vmlld0JveCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJlbG9uZ3NfdmJveCA9IHRoaXMuX2JlbG9uZ3MuZ2V0Q2FjaGVWaWV3Qm94KCk7XG4gICAgICAgICAgICBjb25zdCBjYWNoZVZpZXdCb3ggPSB0aGlzLl9jYWNoZVZpZXdCb3g7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZVBvaW50QmFja1dpdGhQb2ludChiZWxvbmdzX3Zib3hbMF0sIGJlbG9uZ3NfdmJveFsxXSwgY2FjaGVWaWV3Qm94LCAwLCAxKTtcbiAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZVBvaW50QmFja1dpdGhQb2ludChiZWxvbmdzX3Zib3hbMl0sIGJlbG9uZ3NfdmJveFszXSwgY2FjaGVWaWV3Qm94LCAyLCAzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZVZpZXdCb3g7XG4gICAgICAgIH0sXG4gICAgICAgIGdldENhY2hlVmlld0JveCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZVZpZXdCb3g7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgaWYodGhpcy5faXNNb3Zpbmcpe1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNlxuICAgICAgICAgICAgfSBlbHNlIGlmKHRoaXMub3BhY2l0eSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMub3BhY2l0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFtjeCwgY3ldID0gdGhpcy5fZ2V0Q2VudGVyKCk7IFxuICAgICAgICAgICAgdGhpcy5fc2hhcGUucmVuZGVyKGN0eCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgICAgICB0aGlzLl9zdGFjay5yZW5kZXIoY3R4KTtcbiAgICAgICAgICAgIC8vIHRoaXMuX2xpbmtTdGFjay5yZW5kZXIoY3R4KTsgICAgXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1jeCwgLWN5KTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgICAgIC8vIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAvLyBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAvLyBjdHguYXJjKGN4LCBjeSwgNSwgMCwgTWF0aC5QSSoyKTtcbiAgICAgICAgICAgIC8vIGN0eC5maWxsU3R5bGUgPSAncmdiKDAsMCwwKSdcbiAgICAgICAgICAgIC8vIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAvLyBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9LFxuICAgICAgICBpc0hpdChwb2ludCwgY29uZGl0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy5fY2FsY3VsYXRlUG9pbnRCYWNrKHBvaW50KTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRwID0gcDsgLy8g5pqC5a2Y77yM5Li65LqG5ZCO57ut6K6h566X5Yir55qE5L2N572uXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl9zdGFjay5jaGVja0hpdChwLCBjb25kaXRpb24pO1xuICAgICAgICAgICAgaWYodGFyZ2V0KSByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgaWYoIXRoaXMudHJhbnNwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2hhcGUuaXNIaXQocG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LCAgICBcbiAgICB9KTtcbiAgICByZXR1cm4gdFxufVxuXG5leHBvcnQgZGVmYXVsdCBHcm91cEZhY3Rvcnk7XG5cbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL25vZGUnO1xuaW1wb3J0IHsgRElSRUNUSU9OIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uc3RhbmNlJztcbi8qKlxuICog5ZyG5b2i5Y2V5YWDIOmFjee9rlxuICogQHR5cGVkZWYge05vZGV+Q29uZmlnc30gUG9pbnR+UG9pbnRDb25maWdzXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmFkaXVzICAtIOWNiuW+hFxuICovXG4vKipcbiAqIOWchuW9ouiKgueCuVxuICogQGNvbnN0cnVjdG9yIFBvaW50XG4gKiBAZXh0ZW5kcyBOb2RlXG4gKiBAcGFyYW0ge1BvaW50flBvaW50Q29uZmlnc30gY29uZmlncyAtIOmFjee9rlxuICovXG5jbGFzcyBQb2ludCBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3MpIHtcbiAgICAgICAgc3VwZXIoY29uZmlncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICAgICAgICAgICAgICdQb2ludCc7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgICAgLSDljYrlvoQgKi9cbiAgICAgICAgdGhpcy5yYWRpdXMgPSAgICAgICAgICAgY29uZmlncy5yYWRpdXMgfHwgMTA7XG4gICAgICAgIHRoaXMuX2RvQ2FjaGUoKTtcbiAgICB9XG5cbiAgICBzZXRDb25maWcoY29uZmlncykge1xuICAgICAgICBPYmplY3Qua2V5cyhjb25maWdzKS5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAgICAgaWYoY29uZmlnc1trXSAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZ3Nba10gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tdID0gY29uZmlnc1trXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXdDb25maWdzW2tdID0gY29uZmlnc1trXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RvQ2FjaGUoKTtcbiAgICB9XG4gICAgX2RvQ2FjaGUoKSB7XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLnJhZGl1cyAqIDI7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5yYWRpdXMgKiAyO1xuICAgIH1cblxuICAgIHJlbmRlcihjdHgpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgaWYodGhpcy5faXNNb3Zpbmcpe1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC42XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguYXJjKHRoaXMuYW5jaG9yWzBdLCB0aGlzLmFuY2hvclsxXSwgdGhpcy5yYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBpZih0aGlzLmJvcmRlcldpZHRoKSB7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5ib3JkZXJXaWR0aDtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYodGhpcy5faXNUYXJnZXRpbmcpIHtcbiAgICAgICAgLy8gICAgIHRoaXMucmVuZGVyRm9jdXMoY3R4KTtcbiAgICAgICAgLy8gfVxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGlzSGl0KHBvaW50KSB7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgICByZXR1cm4gTWF0aC5wb3cocG9pbnRbMF0gLSBhbmNob3JbMF0sIDIpICsgTWF0aC5wb3cocG9pbnRbMV0gLSBhbmNob3JbMV0sIDIpIDwgdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1c1xuICAgIH1cblxuICAgIGdldEJvdW5kaW5nUmVjdCgpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLnJhZGl1cztcbiAgICAgICAgY29uc3QgbHR4ID0gYW5jaG9yWzBdIC0gcjtcbiAgICAgICAgY29uc3QgbHR5ID0gYW5jaG9yWzFdIC0gcjtcbiAgICAgICAgY29uc3QgcmJ4ID0gYW5jaG9yWzBdICsgcjtcbiAgICAgICAgY29uc3QgcmJ5ID0gYW5jaG9yWzFdICsgcjtcbiAgICAgICAgY29uc3QgYnIgPSB0aGlzLl9ib3VuZGluZ3JlY3Q7XG4gICAgICAgIGJyWzBdID0gbHR4O1xuICAgICAgICBiclsxXSA9IGx0eTtcbiAgICAgICAgYnJbMl0gPSByYng7XG4gICAgICAgIGJyWzNdID0gcmJ5O1xuICAgICAgICByZXR1cm4gYnJcbiAgICB9XG5cbiAgICBjYWxjdWxhdGVJbnRlcnNlY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgY29uc3QgW3gxLCB5MV0gPSBwb2ludDtcbiAgICAgICAgY29uc3QgW3gyLCB5Ml0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgdmVjeCA9IHgyIC0geDE7XG4gICAgICAgIGNvbnN0IHZlY3kgPSB5MiAtIHkxO1xuICAgICAgICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KHZlY3ggKiB2ZWN4ICsgdmVjeSAqIHZlY3kpO1xuXG4gICAgICAgIGNvbnN0IHJhdGlvID0gdGhpcy5yYWRpdXMgLyBkaXN0O1xuICAgICAgICByZXR1cm4gW3gyIC0gcmF0aW8gKiB2ZWN4LCB5MiAtIHJhdGlvICogdmVjeV07XG4gICAgfVxuXG4gICAgZ2V0SW50ZXJzZWN0aW9uc0luRm91ckRpbWVuc2lvbigpIHtcbiAgICAgICAgY29uc3QgW3gyLCB5Ml0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgciA9IHRoaXMucmFkaXVzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW0RJUkVDVElPTi5SSUdIVF06ICBbeDIgKyByLCB5Ml0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLkxFRlRdOiAgIFt4MiAtIHIsIHkyXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uQk9UVE9NXTogW3gyLCB5MityXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uVE9QXTogICAgW3gyLCB5Mi1yXSxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhbGN1bGF0ZUludGVyc2VjdGlvbkluRm91ckRpbWVuc2lvbihwb2ludCwgZW5kKSB7XG4gICAgICAgIGNvbnN0IFt4MSwgeTFdID0gcG9pbnQ7XG4gICAgICAgIGNvbnN0IFt4MiwgeTJdID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLnJhZGl1cztcbiAgICAgICAgY29uc3QgdmVjeCA9IHgyIC0geDE7XG4gICAgICAgIGNvbnN0IHZlY3kgPSB5MiAtIHkxO1xuICAgICAgICBjb25zdCBhbGxJbnRlcnNlY3Rpb25zID0ge1xuICAgICAgICAgICAgW0RJUkVDVElPTi5SSUdIVF06ICBbeDIgKyByLCB5Ml0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLkxFRlRdOiAgIFt4MiAtIHIsIHkyXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uQk9UVE9NXTogW3gyLCB5MityXSxcbiAgICAgICAgICAgIFtESVJFQ1RJT04uVE9QXTogICAgW3gyLCB5Mi1yXSxcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhNYXRoLmFicyh2ZWN4KSA+IE1hdGguYWJzKHZlY3kpLCB2ZWN4LCByKVxuICAgICAgICAvLyBpZigpIHtcbiAgICAgICAgLy8gICAgIHJldHVybiB7XG4gICAgICAgIC8vICAgICAgICAgcDogW3gyICsgKHZlY3g8MD9yOi1yKSwgeTJdLFxuICAgICAgICAvLyAgICAgICAgIGRpcjogdmVjeDwwID8gRElSRUNUSU9OLlJJR0hUIDogRElSRUNUSU9OLkxFRlQsXG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vICAgICByZXR1cm4ge1xuICAgICAgICAvLyAgICAgICAgIHA6IFt4MiwgeTIrKHZlY3k8MD9yOi1yKV0sXG4gICAgICAgIC8vICAgICAgICAgZGlyOiB2ZWN5PDAgPyBESVJFQ1RJT04uQk9UVE9NIDogRElSRUNUSU9OLlRPUCxcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuICAgICAgICBsZXQgaW50ZXJEaXIgPSAoTWF0aC5hYnModmVjeSkgPiBNYXRoLmFicyh2ZWN4KVxuICAgICAgICAgICAgPyAodmVjeSA8IDAgPyBESVJFQ1RJT04uQk9UVE9NIDogRElSRUNUSU9OLlRPUClcbiAgICAgICAgICAgIDogKHZlY3ggPCAwID8gRElSRUNUSU9OLlJJR0hUIDogRElSRUNUSU9OLkxFRlQpKTtcblxuICAgICAgICAvLyBpbnRlckRpciA9IHRoaXMuY2hlY2tMaW5rZWQoaW50ZXJEaXIsIGVuZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwOiBhbGxJbnRlcnNlY3Rpb25zW2ludGVyRGlyXSxcbiAgICAgICAgICAgIGRpcjogaW50ZXJEaXIsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRCb3VuZGluZ0RpbWVuc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgICB9XG4gICAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFBvaW50OyIsImltcG9ydCBOb2RlIGZyb20gJy4uL25vZGUnO1xuaW1wb3J0IHsgRElSRUNUSU9OLCBvcHBvc2l0ZURpcmVjdGlvbiB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbnN0YW5jZSc7XG4vKipcbiAqIEB0eXBlZGVmIFJlY3RhbmdsZX5ib3JkZXJcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvcGVydHkge251bWJlcn0gYm9yZGVyQ29sb3IgICAgICAtIOi+ueahhuWuveW6piwg6buY6K6kIDBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBib3JkZXJXaWR0aCAgICAgIC0g6L655qGG6aKc6ImyLCDpu5jorqQgdHJhbnNwYXJlbnRcbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiBSZWN0YW5nbGV+Ym9yZGVyc1xuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7UmVjdGFuZ2xlfmJvcmRlcn0gdG9wICAgICAgLSDkuIrovrnmoYZcbiAqIEBwcm9wZXJ0eSB7UmVjdGFuZ2xlfmJvcmRlcn0gcmlnaHQgICAgICAtIOWPs+i+ueahhlxuICogQHByb3BlcnR5IHtSZWN0YW5nbGV+Ym9yZGVyfSBib3R0b20gICAgICAtIOS4i+i+ueahhlxuICogQHByb3BlcnR5IHtSZWN0YW5nbGV+Ym9yZGVyfSBsZWZ0ICAgICAgLSDlt6bovrnmoYZcbiAqL1xuXG4vKipcbiAqIOefqeW9ouWNleWFgyDphY3nva5cbiAqIEB0eXBlZGVmIHtOb2RlfkNvbmZpZ3N9IFJlY3RhbmdsZX5SZWN0YW5nbGVDb25maWdzXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggLSDlrr1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSDpq5hcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBib3JkZXJSYWRpdXMgLSDlnIbop5Lnn6nlvaLljYrlvoRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBib3JkZXJDb2xvciAtIOi+ueahhuminOiJsiwg6buY6K6kIHRyYW5zcGFyZW50XG4gKiBAcHJvcGVydHkge3N0cmluZ30gYm9yZGVyV2lkdGggLSDovrnmoYblrr3luqYsIOm7mOiupCAwXG4gKiBAcHJvcGVydHkge1JlY3RhbmdsZX5ib3JkZXJzfSBib3JkZXIgICAgICAtIOi+ueahhuiuvue9rlxuICovXG4vKipcbiAqIOefqeW9ouWNleWFg1xuICogQGNvbnN0cnVjdG9yIFJlY3RhbmdsZVxuICogQGV4dGVuZHMgTm9kZVxuICogQHBhcmFtIHtSZWN0YW5nbGV+UmVjdGFuZ2xlQ29uZmlnc30gY29uZmlnc1xuICovXG5jbGFzcyBSZWN0YW5nbGUgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzID0ge30pIHtcbiAgICAgICAgc3VwZXIoY29uZmlncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICAgICAgICAgICAgICdSZWN0YW5nbGUnO1xuICAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgICAtIOWuvSAqL1xuICAgICAgICB0aGlzLndpZHRoID0gICAgICAgICAgICBjb25maWdzLndpZHRoIHx8IDEwO1xuICAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgICAtIOmrmCAqL1xuICAgICAgICB0aGlzLmhlaWdodCA9ICAgICAgICAgICBjb25maWdzLmhlaWdodCB8fCAxMDtcbiAgICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgICAgLSDlnIbop5Lnn6nlvaLljYrlvoQgKi9cbiAgICAgICAgdGhpcy5ib3JkZXJSYWRpdXMgPSAgICAgY29uZmlncy5ib3JkZXJSYWRpdXMgfHwgMDtcbiAgICAgICAgdGhpcy5fc2V0Qm9yZGVyKGNvbmZpZ3MpO1xuICAgIH1cblxuICAgIF9zZXRCb3JkZXIoY29uZmlncyl7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtSZWN0YW5nbGV+Ym9yZGVyc30gICAgICAtIOi+ueahhuiuvue9ru+8jOS8mOWFiOe6p+mrmOS6jiBib3JkZXJXaWR0aO+8jGJvcmRlckNvbG9yICovXG4gICAgICAgIHRoaXMuYm9yZGVyID0ge1xuICAgICAgICAgICAgdG9wOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbmZpZ3MuYm9yZGVyPy50b3A/LmJvcmRlckNvbG9yIHx8IGNvbmZpZ3MuYm9yZGVyQ29sb3IgfHwgJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgICB3aWR0aDogY29uZmlncy5ib3JkZXI/LnRvcD8uYm9yZGVyV2lkdGggfHwgY29uZmlncy5ib3JkZXJXaWR0aCB8fCAwLFxuICAgICAgICAgICAgICAgIGVuYWJsZTogY29uZmlncy5ib3JkZXI/LnRvcD8uYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmlnaHQ6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogY29uZmlncy5ib3JkZXI/LnJpZ2h0Py5ib3JkZXJDb2xvciB8fCBjb25maWdzLmJvcmRlckNvbG9yIHx8ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGNvbmZpZ3MuYm9yZGVyPy5yaWdodD8uYm9yZGVyV2lkdGggfHwgY29uZmlncy5ib3JkZXJXaWR0aCB8fCAwLFxuICAgICAgICAgICAgICAgIGVuYWJsZTogY29uZmlncy5ib3JkZXI/LnJpZ2h0Py5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib3R0b206IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogY29uZmlncy5ib3JkZXI/LmJvdHRvbT8uYm9yZGVyQ29sb3IgfHwgY29uZmlncy5ib3JkZXJDb2xvciB8fCAndHJhbnNwYXJlbnQnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBjb25maWdzLmJvcmRlcj8uYm90dG9tPy5ib3JkZXJXaWR0aCB8fCBjb25maWdzLmJvcmRlcldpZHRoIHx8IDAsXG4gICAgICAgICAgICAgICAgZW5hYmxlOiBjb25maWdzLmJvcmRlcj8uYm90dG9tPy5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZWZ0OiB7XG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbmZpZ3MuYm9yZGVyPy5sZWZ0Py5ib3JkZXJDb2xvciB8fCBjb25maWdzLmJvcmRlckNvbG9yIHx8ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGNvbmZpZ3MuYm9yZGVyPy5sZWZ0Py5ib3JkZXJXaWR0aCB8fCBjb25maWdzLmJvcmRlcldpZHRoIHx8IDAsXG4gICAgICAgICAgICAgICAgZW5hYmxlOiBjb25maWdzLmJvcmRlcj8ubGVmdD8uYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSBjb25maWdzLmJvcmRlckNvbG9yIHx8ICd0cmFuc3BhcmVudCc7XG4gICAgICAgIHRoaXMuYm9yZGVyV2lkdGggPSBjb25maWdzLmJvcmRlcldpZHRoIHx8IDA7XG4gICAgfVxuXG4gICAgc2V0Q29uZmlnKGNvbmZpZ3MpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoY29uZmlncykuZm9yRWFjaChrID0+IHtcbiAgICAgICAgICAgIGlmKGNvbmZpZ3Nba10gIT09IHVuZGVmaW5lZCAmJiBjb25maWdzW2tdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trXSA9IGNvbmZpZ3Nba107XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF3Q29uZmlnc1trXSA9IGNvbmZpZ3Nba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zZXRCb3JkZXIoY29uZmlncyk7XG4gICAgfVxuXG4gICAgcmVuZGVyKGN0eCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBpZih0aGlzLl9pc01vdmluZyl7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjZcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogcmFkaXVzLCBhbmNob3IsIHdpZHRoLCBoZWlnaHRcbiAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLmFuY2hvclswXSAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5hbmNob3JbMV0gLSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgIGNvbnN0IHh0ID0gdGhpcy5hbmNob3JbMF0gKyB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgY29uc3QgeXQgPSB0aGlzLmFuY2hvclsxXSArIHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgaWYodGhpcy5ib3JkZXJSYWRpdXMpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIHJhZGl1cywgeSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHJhZGl1cywgeSk7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHJhZGl1cyk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkgKyByYWRpdXMpO1xuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJhZGl1cywgeSk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7IFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnJlY3QodGhpcy5hbmNob3JbMF0gLSB0aGlzLndpZHRoIC8gMiwgdGhpcy5hbmNob3JbMV0gLSB0aGlzLmhlaWdodCAvIDIsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLmJvcmRlcldpZHRoKSB7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5ib3JkZXJXaWR0aDtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYm9yZGVyQ29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKHRoaXMuc2hhZG93Q29sb3IgJiYgdGhpcy5zaGFkb3dDb2xvciAhPT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gdGhpcy5zaGFkb3dDb2xvcjtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5famZsb3cuc2NhbGU7XG4gICAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IHRoaXMuc2hhZG93Qmx1ciAqIHNjYWxlO1xuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSB0aGlzLnNoYWRvd09mZnNldFggKiBzY2FsZTtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gdGhpcy5zaGFkb3dPZmZzZXRZICogc2NhbGU7XG4gICAgICAgICAgICBsZXQgc3dpdGNoUGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgICAgIGlmKHRoaXMuYm9yZGVyUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoUGF0aC5tb3ZlVG8oeCArIHJhZGl1cywgeSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoUGF0aC5saW5lVG8oeCArIHdpZHRoIC0gcmFkaXVzLCB5KTtcbiAgICAgICAgICAgICAgICBzd2l0Y2hQYXRoLnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByYWRpdXMpO1xuICAgICAgICAgICAgICAgIHN3aXRjaFBhdGgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgICAgICAgICAgICAgc3dpdGNoUGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcmFkaXVzLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBzd2l0Y2hQYXRoLmxpbmVUbyh4ICsgcmFkaXVzLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBzd2l0Y2hQYXRoLnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgICAgICAgICAgICAgc3dpdGNoUGF0aC5saW5lVG8oeCwgeSArIHJhZGl1cyk7XG4gICAgICAgICAgICAgICAgc3dpdGNoUGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByYWRpdXMsIHkpO1xuICAgICAgICAgICAgICAgIHN3aXRjaFBhdGguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaFBhdGgucmVjdCh0aGlzLmFuY2hvclswXSAtIHRoaXMud2lkdGggLyAyLCB0aGlzLmFuY2hvclsxXSAtIHRoaXMuaGVpZ2h0IC8gMiwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoUGF0aC5yZWN0KHggLSAxMCwgeSAtIDEwLCB0aGlzLndpZHRoKyAyMCwgdGhpcy5oZWlnaHQrIDIwKTtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguY2xpcChzd2l0Y2hQYXRoLCBcImV2ZW5vZGRcIik7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9ICBcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBpZih0aGlzLmJvcmRlclJhZGl1cyAmJiB0aGlzLmJvcmRlcldpZHRoKSB7XG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSAndHJhbnNwYXJlbnQnXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKHRoaXMuYm9yZGVyUmFkaXVzKSB7XG4gICAgICAgICAgICBpZih0aGlzLmJvcmRlci50b3AuZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHkgPSB5IC0gdGhpcy5ib3JkZXIudG9wLndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmJvcmRlci50b3Aud2lkdGgpXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGxldCB0b3BQYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICAgICAgICAgIHRvcFBhdGgubW92ZVRvKHgsIHR5ICsgcmFkaXVzKTtcbiAgICAgICAgICAgICAgICB0b3BQYXRoLnF1YWRyYXRpY0N1cnZlVG8oeCwgdHksIHggKyByYWRpdXMsIHR5KTtcbiAgICAgICAgICAgICAgICB0b3BQYXRoLmxpbmVUbyh4ICsgd2lkdGggLSByYWRpdXMsIHR5KTtcbiAgICAgICAgICAgICAgICB0b3BQYXRoLnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB0eSwgeCArIHdpZHRoLCB0eSArIHJhZGl1cyk7XG4gICAgICAgICAgICAgICAgdG9wUGF0aC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguY2xpcCh0b3BQYXRoKTsgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSAndHJhbnNwYXJlbnQnO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJvcmRlci50b3AuY29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LnJlY3QoeCwgdHksIHRoaXMud2lkdGgsIHRoaXMuYm9yZGVyLnRvcC53aWR0aCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIC8vIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgLy8gY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIC8vIGN0eC5tb3ZlVG8oeCwgdHkgKyByYWRpdXMpO1xuICAgICAgICAgICAgICAgIC8vIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHR5LCB4ICsgcmFkaXVzLCB0eSk7XG4gICAgICAgICAgICAgICAgLy8gY3R4LmxpbmVUbyh4ICsgd2lkdGggLSByYWRpdXMsIHR5KTtcbiAgICAgICAgICAgICAgICAvLyBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHR5LCB4ICsgd2lkdGgsIHR5ICsgcmFkaXVzKTtcbiAgICAgICAgICAgICAgICAvLyBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgICAgICAgICAvLyAvLyBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIC8vIGN0eC5jbGlwKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgLy8gY3R4LnJlY3QoeCwgdHksIHRoaXMud2lkdGgsIHRoaXMuYm9yZGVyLnRvcC53aWR0aCk7XG4gICAgICAgICAgICAgICAgLy8gY3R4LmZpbGxTdHlsZSA9IHRoaXMuYm9yZGVyLnRvcC5jb2xvcjtcbiAgICAgICAgICAgICAgICAvLyBjdHguc2hhZG93Q29sb3IgPSAndHJhbnNwYXJlbnQnO1xuICAgICAgICAgICAgICAgIC8vIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgLy8gY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKHRoaXMuYm9yZGVyLnRvcC53aWR0aCkge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeHQsIHkpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYm9yZGVyLnRvcC5jb2xvcjtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5ib3JkZXIudG9wLndpZHRoO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodGhpcy5ib3JkZXIucmlnaHQud2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4dCwgeSk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4dCwgeXQpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYm9yZGVyLnJpZ2h0LmNvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmJvcmRlci5yaWdodC53aWR0aDtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHRoaXMuYm9yZGVyLmJvdHRvbS53aWR0aCkge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHh0LCB5dCk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5dCk7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5ib3JkZXIuYm90dG9tLmNvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmJvcmRlci5ib3R0b20ud2lkdGg7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih0aGlzLmJvcmRlci5sZWZ0LndpZHRoKSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeXQpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5ib3JkZXIubGVmdC5jb2xvcjtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5ib3JkZXIubGVmdC53aWR0aDtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBpc0hpdChwb2ludCkge1xuICAgICAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGggLzI7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICByZXR1cm4gcG9pbnRbMF0gPiBhbmNob3JbMF0gLSB3XG4gICAgICAgICAgICAmJiBwb2ludFswXSA8IGFuY2hvclswXSArIHdcbiAgICAgICAgICAgICYmIHBvaW50WzFdID4gYW5jaG9yWzFdIC0gaFxuICAgICAgICAgICAgJiYgcG9pbnRbMV0gPCBhbmNob3JbMV0gKyBoO1xuICAgIH1cblxuICAgIGdldEJvdW5kaW5nUmVjdCgpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoIC8yO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgY29uc3QgbHR4ID0gYW5jaG9yWzBdIC0gdztcbiAgICAgICAgY29uc3QgbHR5ID0gYW5jaG9yWzFdIC0gaDtcbiAgICAgICAgY29uc3QgcmJ4ID0gYW5jaG9yWzBdICsgdztcbiAgICAgICAgY29uc3QgcmJ5ID0gYW5jaG9yWzFdICsgaDtcbiAgICAgICAgY29uc3QgYnIgPSB0aGlzLl9ib3VuZGluZ3JlY3Q7XG4gICAgICAgIGJyWzBdID0gbHR4O1xuICAgICAgICBiclsxXSA9IGx0eTtcbiAgICAgICAgYnJbMl0gPSByYng7XG4gICAgICAgIGJyWzNdID0gcmJ5O1xuICAgICAgICByZXR1cm4gYnJcbiAgICB9XG5cbiAgICBnZXRCb3VuZGluZ0RpbWVuc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhbGN1bGF0ZUludGVyc2VjdGlvbihwb2ludCkge1xuICAgICAgICBjb25zdCBbeDEsIHkxXSA9IHBvaW50O1xuICAgICAgICBjb25zdCBbeDIsIHkyXSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aC8yO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgY29uc3QgdmVjeCA9IHgyIC0geDE7XG4gICAgICAgIGNvbnN0IHZlY3kgPSB5MiAtIHkxO1xuICAgICAgICBjb25zdCB0aGV0YTEgPSBoL3c7XG4gICAgICAgIGNvbnN0IHRoZXRhMiA9IE1hdGguYWJzKHZlY3kvdmVjeCk7XG4gICAgICAgIGNvbnN0IGRpcnggPSB4MSA+IHgyO1xuICAgICAgICBjb25zdCBkaXJ5ID0geTEgPiB5MjtcbiAgICAgICAgbGV0IHgsIHk7XG4gICAgICAgIGlmKHRoZXRhMiA8IHRoZXRhMSkge1xuICAgICAgICAgICAgeCA9IHgyICsgKGRpcng/dzotdyk7XG4gICAgICAgICAgICB5ID0gdyAqIChkaXJ5P3RoZXRhMjotdGhldGEyKSArIHkyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeSA9IHkyICsgKGRpcnk/aDotaCk7XG4gICAgICAgICAgICB4ID0gaCAvIChkaXJ4P3RoZXRhMjotdGhldGEyKSArIHgyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuXG4gICAgZ2V0SW50ZXJzZWN0aW9uc0luRm91ckRpbWVuc2lvbigpIHtcbiAgICAgICAgbGV0IHAyID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGlmKHRoaXMuX2JlbG9uZ3MgJiYgdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbikge1xuICAgICAgICAgICAgcDIgPSB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKHAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IFt4MiwgeTJdID0gcDI7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoLzI7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW0RJUkVDVElPTi5SSUdIVF06ICBbeDIrdywgeTJdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5MRUZUXTogICBbeDItdywgeTJdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5CT1RUT01dOiBbeDIsIHkyK2hdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5UT1BdOiAgICBbeDIsIHkyLWhdLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlSW50ZXJzZWN0aW9uSW5Gb3VyRGltZW5zaW9uKHBvaW50LCBlbmQpIHtcbiAgICAgICAgY29uc3QgW3gxLCB5MV0gPSBwb2ludDtcbiAgICAgICAgbGV0IHAyID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGlmKHRoaXMuX2JlbG9uZ3MgJiYgdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbikge1xuICAgICAgICAgICAgcDIgPSB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKHAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IFt4MiwgeTJdID0gcDI7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoLzI7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICBjb25zdCBhbGxJbnRlcnNlY3Rpb25zID0ge1xuICAgICAgICAgICAgW0RJUkVDVElPTi5SSUdIVF06ICBbeDIrdywgeTJdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5MRUZUXTogICBbeDItdywgeTJdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5CT1RUT01dOiBbeDIsIHkyK2hdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5UT1BdOiAgICBbeDIsIHkyLWhdLFxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZlY3ggPSB4MiAtIHgxO1xuICAgICAgICBjb25zdCB2ZWN5ID0geTIgLSB5MTtcbiAgICAgICAgY29uc3QgdGhldGExID0gaC93O1xuICAgICAgICBjb25zdCB0aGV0YTIgPSBNYXRoLmFicyh2ZWN5L3ZlY3gpO1xuICAgICAgICBjb25zdCBkaXJ4ID0geDEgPiB4MjtcbiAgICAgICAgY29uc3QgZGlyeSA9IHkxID4geTI7XG4gICAgICAgIGxldCBpbnRlckRpciA9ICh0aGV0YTIgPiB0aGV0YTFcbiAgICAgICAgICAgID8gKGRpcnkgPyBESVJFQ1RJT04uQk9UVE9NIDogRElSRUNUSU9OLlRPUClcbiAgICAgICAgICAgIDogKGRpcnggPyBESVJFQ1RJT04uUklHSFQgOiBESVJFQ1RJT04uTEVGVCkpO1xuXG4gICAgICAgIC8vIGlmKHRoaXMuX2JlbG9uZ3MgJiYgdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbikge1xuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkodGhpcy5faW50ZXJzZWN0aW9ucykpO1xuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coaW50ZXJEaXIpXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gaW50ZXJEaXIgPSB0aGlzLmNoZWNrTGlua2VkKGludGVyRGlyLCBlbmQpO1xuICAgICAgICAvLyBpZih0aGlzLl9iZWxvbmdzICYmIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24pIHtcbiAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKGludGVyRGlyKVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gaWYoIWludGVyRGlyKSB7XG4gICAgICAgIC8vICAgICBkZWJ1Z2dlclxuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGxldCBlbmREaXIgPSBpbnRlckRpcjtcbiAgICAgICAgLy8gaWYoZW5kID09PSAndG8nKSB7XG4gICAgICAgIC8vICAgICBlbmREaXIgPSBvcHBvc2l0ZURpcmVjdGlvbihlbmREaXIpXG4gICAgICAgIC8vIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHA6IGFsbEludGVyc2VjdGlvbnNbaW50ZXJEaXJdLFxuICAgICAgICAgICAgZGlyOiBpbnRlckRpcixcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVjdGFuZ2xlOyIsImltcG9ydCBOb2RlIGZyb20gJy4uL25vZGUnO1xuaW1wb3J0IHsgRElSRUNUSU9OLCBvcHBvc2l0ZURpcmVjdGlvbiB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbnN0YW5jZSc7XG4vKipcbiAqIOiDtuWbiuWNleWFgyDphY3nva5cbiAqIEB0eXBlZGVmIHtOb2RlfkNvbmZpZ3N9IENhcHN1bGV+Q2Fwc3VsZUNvbmZpZ3NcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aCAgLSDlhoXpg6jnn6nlvaLlrr1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSDlhoXpg6jnn6nlvaLpq5hcbiAqL1xuLyoqXG4gKiDog7blm4rljZXlhYNcbiAqIEBjb25zdHJ1Y3RvciBDYXBzdWxlXG4gKiBAZXh0ZW5kcyBOb2RlXG4gKiBAcGFyYW0ge0NhcHN1bGV+Q2Fwc3VsZUNvbmZpZ3N9IGNvbmZpZ3MgLSDphY3nva5cbiAqL1xuY2xhc3MgQ2Fwc3VsZSBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3MgPSB7fSkge1xuICAgICAgICBzdXBlcihjb25maWdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gICAgICAgICAgICAgJ0NhcHN1bGUnO1xuICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAgIC0g5YaF6YOo55+p5b2i5a69ICovXG4gICAgICAgIHRoaXMud2lkdGggPSAgICAgICAgICAgIGNvbmZpZ3Mud2lkdGggfHwgMjA7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgICAgLSDlhoXpg6jnn6nlvaLpq5ggKi9cbiAgICAgICAgdGhpcy5oZWlnaHQgPSAgICAgICAgICAgY29uZmlncy5oZWlnaHQgfHwgMTA7XG4gICAgfVxuXG4gICAgcmVuZGVyKGN0eCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBpZih0aGlzLl9pc01vdmluZyl7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjZcbiAgICAgICAgfVxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnN0IFt4LCB5XSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCBodyA9IHRoaXMud2lkdGgvMjtcbiAgICAgICAgY29uc3QgaGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICBjb25zdCBsZWZ0Q2VudGVyID0geCAtIGh3ICsgaGg7XG4gICAgICAgIGNvbnN0IHJpZ2h0Q2VudGVyID0geCArIGh3IC0gaGg7XG4gICAgICAgIGNvbnN0IHRvcCA9IHkgLSBoaDtcbiAgICAgICAgY29uc3QgYm90dG9tID0geSArIGhoO1xuXG4gICAgICAgIGN0eC5tb3ZlVG8obGVmdENlbnRlciwgdG9wKTtcbiAgICAgICAgY3R4LmxpbmVUbyhyaWdodENlbnRlciwgdG9wKTtcbiAgICAgICAgY3R4LmFyYyhyaWdodENlbnRlciwgeSwgaGgsIC1NYXRoLlBJLzIsIE1hdGguUEkvMik7XG4gICAgICAgIGN0eC5saW5lVG8obGVmdENlbnRlciwgYm90dG9tKTtcbiAgICAgICAgY3R4LmFyYyhsZWZ0Q2VudGVyLCB5LCBoaCwgTWF0aC5QSS8yLCBNYXRoLlBJLzIqMyk7XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBpZiAodGhpcy5zaGFkb3dDb2xvcikge1xuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gdGhpcy5zaGFkb3dDb2xvcjtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gdGhpcy5zaGFkb3dCbHVyO1xuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSB0aGlzLnNoYWRvd09mZnNldFg7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHRoaXMuc2hhZG93T2Zmc2V0WTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBpZih0aGlzLmJvcmRlcldpZHRoKSB7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5ib3JkZXJXaWR0aDtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDAuMyknO1xuICAgICAgICAvLyBjdHguZmlsbFJlY3QoeC1odywgeS1oaCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXG5cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBpc0hpdChwb2ludCkge1xuICAgICAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgaHcgPSB0aGlzLndpZHRoLzI7XG4gICAgICAgIGNvbnN0IGhoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgY29uc3Qgd3cgPSAgTWF0aC5hYnMoaHcgLSBoaCk7XG4gICAgICAgIGNvbnN0IGxlZnRDZW50ZXIgPSBhbmNob3JbMF0gLSBodyArIGhoO1xuICAgICAgICBjb25zdCByaWdodENlbnRlciA9IGFuY2hvclswXSArIGh3IC0gaGg7XG4gICAgICAgIGNvbnN0IHJyID0gaGggKiBoaDtcbiAgICAgICAgcmV0dXJuIChwb2ludFswXSA+IGFuY2hvclswXSAtIHd3XG4gICAgICAgICAgICAmJiBwb2ludFswXSA8IGFuY2hvclswXSArIHd3XG4gICAgICAgICAgICAmJiBwb2ludFsxXSA+IGFuY2hvclsxXSAtIGhoXG4gICAgICAgICAgICAmJiBwb2ludFsxXSA8IGFuY2hvclsxXSArIGhoKVxuICAgICAgICAgICAgfHwgKCBNYXRoLnBvdyhwb2ludFswXSAtIGxlZnRDZW50ZXIsIDIpICsgTWF0aC5wb3cocG9pbnRbMV0gLSBhbmNob3JbMV0sIDIpIDwgcnIpXG4gICAgICAgICAgICB8fCAoIE1hdGgucG93KHBvaW50WzBdIC0gcmlnaHRDZW50ZXIsIDIpICsgTWF0aC5wb3cocG9pbnRbMV0gLSBhbmNob3JbMV0sIDIpIDwgcnIpXG4gICAgfVxuXG4gICAgZ2V0Qm91bmRpbmdSZWN0KCkge1xuICAgICAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGggLzI7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICBjb25zdCBsdHggPSBhbmNob3JbMF0gLSB3O1xuICAgICAgICBjb25zdCBsdHkgPSBhbmNob3JbMV0gLSBoO1xuICAgICAgICBjb25zdCByYnggPSBhbmNob3JbMF0gKyB3O1xuICAgICAgICBjb25zdCByYnkgPSBhbmNob3JbMV0gKyBoO1xuICAgICAgICBjb25zdCBiciA9IHRoaXMuX2JvdW5kaW5ncmVjdDtcbiAgICAgICAgYnJbMF0gPSBsdHg7XG4gICAgICAgIGJyWzFdID0gbHR5O1xuICAgICAgICBiclsyXSA9IHJieDtcbiAgICAgICAgYnJbM10gPSByYnk7XG4gICAgICAgIHJldHVybiBiclxuICAgIH1cblxuICAgIGdldEJvdW5kaW5nRGltZW5zaW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0SW50ZXJzZWN0aW9uc0luRm91ckRpbWVuc2lvbigpIHtcbiAgICAgICAgbGV0IHAyID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGlmKHRoaXMuX2JlbG9uZ3MgJiYgdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbikge1xuICAgICAgICAgICAgcDIgPSB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKHAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IFt4MiwgeTJdID0gcDI7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoLzI7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW0RJUkVDVElPTi5SSUdIVF06ICBbeDIrdywgeTJdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5MRUZUXTogICBbeDItdywgeTJdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5CT1RUT01dOiBbeDIsIHkyK2hdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5UT1BdOiAgICBbeDIsIHkyLWhdLFxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYXBzdWxlOyIsImltcG9ydCBDYXBzdWxlIGZyb20gJy4vY2Fwc3VsZSc7XG4vKipcbiAqIOWeguebtOiDtuWbiuWNleWFg1xuICogQGNvbnN0cnVjdG9yIENhcHN1bGVWZXJ0aWNhbFxuICogQGV4dGVuZHMgQ2Fwc3VsZVxuICogQHBhcmFtIHtDYXBzdWxlfkNhcHN1bGVDb25maWdzfSBjb25maWdzIC0g6YWN572uXG4gKi9cbmNsYXNzIENhcHN1bGVWZXJ0aWNhbCBleHRlbmRzIENhcHN1bGUge1xuICAgIHJlbmRlcihjdHgpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgaWYodGhpcy5faXNNb3Zpbmcpe1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC42XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb25zdCBbeCwgeV0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgaHcgPSB0aGlzLndpZHRoLzI7XG4gICAgICAgIGNvbnN0IGhoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgY29uc3QgdG9wQ2VudGVyID0geSAtIGhoICsgaHc7XG4gICAgICAgIGNvbnN0IGJvdHRvbUNlbnRlciA9IHkgKyBoaCAtIGh3O1xuICAgICAgICBjb25zdCBsZWZ0ID0geCAtIGh3O1xuICAgICAgICBjb25zdCByaWdodCA9IHggKyBodztcblxuICAgICAgICBjdHgubW92ZVRvKGxlZnQsIHRvcENlbnRlcik7XG4gICAgICAgIGN0eC5hcmMoeCwgdG9wQ2VudGVyLCBodywgLU1hdGguUEksIDApO1xuICAgICAgICBjdHgubGluZVRvKHJpZ2h0LCBib3R0b21DZW50ZXIpO1xuICAgICAgICBjdHguYXJjKHgsIGJvdHRvbUNlbnRlciwgaHcsIDAsIE1hdGguUEkpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBpZiAodGhpcy5zaGFkb3dDb2xvcikge1xuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gdGhpcy5zaGFkb3dDb2xvcjtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gdGhpcy5zaGFkb3dCbHVyO1xuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSB0aGlzLnNoYWRvd09mZnNldFg7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHRoaXMuc2hhZG93T2Zmc2V0WTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBpZih0aGlzLmJvcmRlcldpZHRoKSB7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5ib3JkZXJXaWR0aDtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDAuMyknO1xuICAgICAgICAvLyBjdHguZmlsbFJlY3QoeC1odywgeS1oaCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXG5cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBpc0hpdChwb2ludCwgY29uZGl0aW9uKSB7XG4gICAgICAgIGNvbnN0IFt4LCB5XSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCBodyA9IHRoaXMud2lkdGgvMjtcbiAgICAgICAgY29uc3QgaGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICBjb25zdCB5eSA9ICBNYXRoLmFicyhoaCAtIGh3KTtcbiAgICAgICAgY29uc3QgdG9wQ2VudGVyID0geSAtIGhoICsgaHc7XG4gICAgICAgIGNvbnN0IGJvdHRvbUNlbnRlciA9IHkgKyBoaCAtIGh3O1xuICAgICAgICBjb25zdCByciA9IGh3ICogaHc7XG4gICAgICAgIHJldHVybiAocG9pbnRbMF0gPiB4IC0gaHdcbiAgICAgICAgICAgICYmIHBvaW50WzBdIDwgeCArIGh3XG4gICAgICAgICAgICAmJiBwb2ludFsxXSA+IHkgLSB5eVxuICAgICAgICAgICAgJiYgcG9pbnRbMV0gPCB5ICsgeXkpXG4gICAgICAgICAgICB8fCAoIE1hdGgucG93KHBvaW50WzBdIC0geCwgMikgKyBNYXRoLnBvdyhwb2ludFsxXSAtIHRvcENlbnRlciwgMikgPCBycilcbiAgICAgICAgICAgIHx8ICggTWF0aC5wb3cocG9pbnRbMF0gLSB4LCAyKSArIE1hdGgucG93KHBvaW50WzFdIC0gYm90dG9tQ2VudGVyLCAyKSA8IHJyKVxuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IENhcHN1bGVWZXJ0aWNhbDsiLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9ub2RlJztcbmltcG9ydCB7IERJUkVDVElPTiB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbnN0YW5jZSc7XG4vKipcbiAqIOiPseW9ouWNleWFgyDphY3nva5cbiAqIEB0eXBlZGVmIHtOb2RlfkNvbmZpZ3N9IFJob21idXN+UmhvbWJ1c0NvbmZpZ3NcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkaWFnb25hbHNWICAtIOWGheWNgeWtl+mrmOW6plxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRpYWdvbmFsc0ggIC0g5YaF5Y2B5a2X5a695bqmXG4gKi9cbi8qKlxuICog6I+x5b2i5Y2V5YWDXG4gKiBAY29uc3RydWN0b3IgUmhvbWJ1c1xuICogQHBhcmFtIHtSaG9tYnVzflJob21idXNDb25maWdzfSBjb25maWdzIC0g6YWN572uXG4gKiBAZXh0ZW5kcyBOb2RlXG4gKi9cbmNsYXNzIFJob21idXMgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzID0ge30pIHtcbiAgICAgICAgc3VwZXIoY29uZmlncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICAgICAgICAgICAgICdSaG9tYnVzJztcbiAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgICAtIOWGheWNgeWtl+mrmOW6piAqL1xuICAgICAgICB0aGlzLmhlaWdodCA9ICAgICAgICAgICBjb25maWdzLmRpYWdvbmFsc1YgfHwgMTA7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgICAgLSDlhoXljYHlrZflrr3luqYgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9ICAgICAgICAgICAgY29uZmlncy5kaWFnb25hbHNIIHx8IDIwO1xuICAgIH1cblxuICAgIHJlbmRlcihjdHgpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgaWYodGhpcy5faXNNb3Zpbmcpe1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC42XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGggLyAyO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgICBjb25zdCBjZW50ZXIgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShjZW50ZXJbMF0sIGNlbnRlclsxXSlcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKDAsIC1oKTtcbiAgICAgICAgY3R4LmxpbmVUbyh3LCAwKTtcbiAgICAgICAgY3R4LmxpbmVUbygwLCBoKTtcbiAgICAgICAgY3R4LmxpbmVUbygtdywgMCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgaWYodGhpcy5ib3JkZXJXaWR0aCkge1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuYm9yZGVyV2lkdGg7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmJvcmRlckNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgXG4gICAgICAgIGlmKHRoaXMuc2hhZG93Q29sb3IpIHtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHRoaXMuc2hhZG93Q29sb3I7XG4gICAgICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2pmbG93LnNjYWxlO1xuICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSB0aGlzLnNoYWRvd0JsdXIgKiBzY2FsZTtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gdGhpcy5zaGFkb3dPZmZzZXRYICogc2NhbGU7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHRoaXMuc2hhZG93T2Zmc2V0WSAqIHNjYWxlO1xuICAgICAgICAgICAgbGV0IHN3aXRjaFBhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgICAgICBzd2l0Y2hQYXRoLm1vdmVUbygwLCAtaCk7XG4gICAgICAgICAgICBzd2l0Y2hQYXRoLmxpbmVUbyh3LCAwKTtcbiAgICAgICAgICAgIHN3aXRjaFBhdGgubGluZVRvKDAsIGgpO1xuICAgICAgICAgICAgc3dpdGNoUGF0aC5saW5lVG8oLXcsIDApO1xuICAgICAgICAgICAgc3dpdGNoUGF0aC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHN3aXRjaFBhdGgucmVjdCgtdyAtIDEwLCAgLWggLSAxMCwgdGhpcy53aWR0aCArIDIwLCB0aGlzLmhlaWdodCsgMjApO1xuICAgICAgICAgICAgLy8gc3dpdGNoUGF0aC5tb3ZlVG8oeCwgeS1oKTtcbiAgICAgICAgICAgIC8vIHN3aXRjaFBhdGgubGluZVRvKHggKyB3LCB5KTtcbiAgICAgICAgICAgIC8vIHN3aXRjaFBhdGgubGluZVRvKHgsIHkgKyBoKTtcbiAgICAgICAgICAgIC8vIHN3aXRjaFBhdGgubGluZVRvKHgtdywgeSk7XG4gICAgICAgICAgICAvLyBzd2l0Y2hQYXRoLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgLy8gc3dpdGNoUGF0aC5yZWN0KHggLSB3IC0gMTAsIHkgLSBoIC0gMTAsIHRoaXMud2lkdGgrIDIwLCB0aGlzLmhlaWdodCsgMjApO1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC5jbGlwKHN3aXRjaFBhdGgsIFwiZXZlbm9kZFwiKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBpZiAodGhpcy5ib3JkZXJXaWR0aCkge1xuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gJ3RyYW5zcGFyZW50J1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICAgXG4gICAgICAgIGN0eC50cmFuc2xhdGUoLWNlbnRlclswXSwgLWNlbnRlclsxXSlcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBpc0hpdChwb2ludCkge1xuICAgICAgICBjb25zdCB2ID0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgICBjb25zdCBoID0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCB4ID0gTWF0aC5hYnMocG9pbnRbMF0gLSBhbmNob3JbMF0pO1xuICAgICAgICBjb25zdCB5ID0gTWF0aC5hYnMocG9pbnRbMV0gLSBhbmNob3JbMV0pO1xuICAgICAgICByZXR1cm4gKHggLyBoICsgeSAvIHYpIDw9IDE7XG4gICAgfVxuXG4gICAgZ2V0Qm91bmRpbmdSZWN0KCkge1xuICAgICAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGggLzI7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodCAvMjtcbiAgICAgICAgY29uc3QgbHR4ID0gYW5jaG9yWzBdIC0gdztcbiAgICAgICAgY29uc3QgbHR5ID0gYW5jaG9yWzFdIC0gaDtcbiAgICAgICAgY29uc3QgcmJ4ID0gYW5jaG9yWzBdICsgdztcbiAgICAgICAgY29uc3QgcmJ5ID0gYW5jaG9yWzFdICsgaDtcbiAgICAgICAgY29uc3QgYnIgPSB0aGlzLl9ib3VuZGluZ3JlY3Q7XG4gICAgICAgIGJyWzBdID0gbHR4O1xuICAgICAgICBiclsxXSA9IGx0eTtcbiAgICAgICAgYnJbMl0gPSByYng7XG4gICAgICAgIGJyWzNdID0gcmJ5O1xuICAgICAgICByZXR1cm4gYnJcbiAgICB9XG5cbiAgICBnZXRCb3VuZGluZ0RpbWVuc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEludGVyc2VjdGlvbnNJbkZvdXJEaW1lbnNpb24oKSB7XG4gICAgICAgIGxldCBwMiA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBpZih0aGlzLl9iZWxvbmdzICYmIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24pIHtcbiAgICAgICAgICAgIHAyID0gdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbihwMik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBbeDIsIHkyXSA9IHAyO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aC8yO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQvMjtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW0RJUkVDVElPTi5SSUdIVF06ICBbeDIrdywgeTJdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5MRUZUXTogICBbeDItdywgeTJdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5CT1RUT01dOiBbeDIsIHkyK2hdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5UT1BdOiAgICBbeDIsIHkyLWhdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5TRUxGXTogICBbeDIrdyowLjYxOCwgeTIraCowLjYxOF1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmhvbWJ1cztcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL25vZGUnO1xuaW1wb3J0IHsgRElSRUNUSU9OLCBvcHBvc2l0ZURpcmVjdGlvbiB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbnN0YW5jZSc7XG4vLyBpbXBvcnQgeyBtYWtlQmV6aWVyUG9pbnRzIH0gZnJvbSAnLi4vLi4vdXRpbHMvZnVuY3Rpb25zJztcbi8qKlxuICog6ZK755+z5b2i5Y2V5YWDIOmFjee9rlxuICogQHR5cGVkZWYge05vZGV+Q29uZmlnc30gRGlhbW9uZH5EaWFtb25kQ29uZmlnc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoICAtIOWGhemDqOefqeW9ouWuvVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAtIOWGhemDqOefqeW9oumrmFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpZGUgICAtIOS4pOS+p+S4ieinkuW9oueahOWuvVxuICovXG4vKipcbiAqIOmSu+efs+W9ouWNleWFg1xuICogQGNvbnN0cnVjdG9yIERpYW1vbmRcbiAqIEBwYXJhbSB7RGlhbW9uZH5EaWFtb25kQ29uZmlnc30gY29uZmlncyAtIOmFjee9rlxuICogQGV4dGVuZHMgTm9kZVxuICovXG5cbmNsYXNzIERpYW1vbmQgZXh0ZW5kcyBOb2RlIHtcblxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3MgPSB7fSkge1xuICAgICAgICBzdXBlcihjb25maWdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gICAgICAgICAgICAgJ0RpYW1vbmQnO1xuICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAgIC0g5YaF6YOo55+p5b2i5a69ICovXG4gICAgICAgIHRoaXMud2lkdGggPSAgICAgICAgICAgIGNvbmZpZ3Mud2lkdGggfHwgMjA7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgICAgLSDlhoXpg6jnn6nlvaLpq5ggKi9cbiAgICAgICAgdGhpcy5oZWlnaHQgPSAgICAgICAgICAgY29uZmlncy5oZWlnaHQgfHwgMTA7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgICAgLSDkuKTkvqfkuInop5LlvaLnmoTlrr0gKi9cbiAgICAgICAgdGhpcy5zaWRlID0gICAgICAgICAgICAgY29uZmlncy5zaWRlIHx8IDY7XG4gICAgICAgIHRoaXMuX2RvQ2FjaGUoKTtcbiAgICB9XG5cbiAgICBzZXRDb25maWcoY29uZmlncykge1xuICAgICAgICBPYmplY3Qua2V5cyhjb25maWdzKS5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAgICAgaWYoY29uZmlnc1trXSAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZ3Nba10gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tdID0gY29uZmlnc1trXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXdDb25maWdzW2tdID0gY29uZmlnc1trXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RvQ2FjaGUoKTtcbiAgICB9XG5cbiAgICBfZG9DYWNoZSgpIHtcbiAgICAgICAgdGhpcy5zaW5TSURFID0gTWF0aC5zaW4oTWF0aC5QSS8zKSAqIHRoaXMuc2lkZTtcbiAgICAgICAgdGhpcy5jb3NTSURFID0gTWF0aC5jb3MoTWF0aC5QSS8zKSAqIHRoaXMuc2lkZTtcbiAgICB9XG5cbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIGNvbnN0IFt4LCB5XSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCBodyA9IHRoaXMud2lkdGgvMjtcbiAgICAgICAgY29uc3QgaGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICBjb25zdCB4eCA9IGhoIC8gMS43MzJcbiAgICAgICAgY29uc3QgbGVmdENlbnRlciA9IHggLSBodyArIHh4O1xuICAgICAgICBjb25zdCByaWdodENlbnRlciA9IHggKyBodyAtIHh4O1xuICAgICAgICBjb25zdCByaWdodCA9IHggKyBodztcbiAgICAgICAgY29uc3QgbGVmdCA9IHggLSBodztcbiAgICAgICAgY29uc3QgdG9wID0geSAtIGhoO1xuICAgICAgICBjb25zdCBib3R0b20gPSB5ICsgaGg7XG5cbiAgICAgICAgdGhpcy5fY2FjaGVQb2ludHMgPSBbXG4gICAgICAgICAgICBbcmlnaHRDZW50ZXIsIHRvcF0sXG4gICAgICAgICAgICBbcmlnaHQsIHldLFxuICAgICAgICAgICAgW3JpZ2h0Q2VudGVyLCBib3R0b21dLFxuICAgICAgICAgICAgW2xlZnRDZW50ZXIsIGJvdHRvbV0sXG4gICAgICAgICAgICBbbGVmdCwgeV0sXG4gICAgICAgICAgICBbbGVmdENlbnRlciwgdG9wXVxuICAgICAgICBdO1xuXG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGlmKHRoaXMuX2lzTW92aW5nKXtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNlxuICAgICAgICB9XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgc2lkZSwgc2luU0lERSwgY29zU0lERVxuICAgICAgICB9ID0gdGhpcztcbiAgICAgICAgY3R4Lm1vdmVUbyh4LCB0b3ApO1xuICAgICAgICBjdHgubGluZVRvKHJpZ2h0Q2VudGVyIC0gc2lkZSwgdG9wKTtcbiAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8ocmlnaHRDZW50ZXIsIHRvcCwgcmlnaHRDZW50ZXIgKyBjb3NTSURFLCB0b3AgKyBzaW5TSURFKTtcbiAgICAgICAgY3R4LmxpbmVUbyhyaWdodCAtIGNvc1NJREUsIHkgLSBzaW5TSURFKTtcbiAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8ocmlnaHQsIHksIHJpZ2h0IC0gY29zU0lERSwgeSArIHNpblNJREUpO1xuICAgICAgICBjdHgubGluZVRvKHJpZ2h0Q2VudGVyICsgY29zU0lERSwgYm90dG9tIC0gc2luU0lERSk7XG4gICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHJpZ2h0Q2VudGVyLCBib3R0b20sIHJpZ2h0Q2VudGVyIC0gc2lkZSwgYm90dG9tKTtcblxuICAgICAgICBjdHgubGluZVRvKGxlZnRDZW50ZXIgKyBzaWRlLCBib3R0b20pO1xuICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhsZWZ0Q2VudGVyLCBib3R0b20sIGxlZnRDZW50ZXIgLSBjb3NTSURFLCBib3R0b20gLSBzaW5TSURFKTtcbiAgICAgICAgY3R4LmxpbmVUbyhsZWZ0ICsgY29zU0lERSwgeSArIHNpblNJREUpO1xuICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhsZWZ0LCB5LCBsZWZ0ICsgY29zU0lERSwgeSAtIHNpblNJREUpO1xuICAgICAgICBjdHgubGluZVRvKGxlZnRDZW50ZXIgLSBjb3NTSURFLCB0b3AgKyBzaW5TSURFKTtcbiAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8obGVmdENlbnRlciwgdG9wLCBsZWZ0Q2VudGVyICsgc2lkZSwgdG9wKTtcblxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBpZiAodGhpcy5zaGFkb3dDb2xvcikge1xuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gdGhpcy5zaGFkb3dDb2xvcjtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gdGhpcy5zaGFkb3dCbHVyO1xuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSB0aGlzLnNoYWRvd09mZnNldFg7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHRoaXMuc2hhZG93T2Zmc2V0WTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBpZih0aGlzLmJvcmRlcldpZHRoKSB7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5ib3JkZXJXaWR0aDtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZih0aGlzLl9pc1RhcmdldGluZykge1xuICAgICAgICAvLyAgICAgdGhpcy5yZW5kZXJGb2N1cyhjdHgpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwLjMpJztcbiAgICAgICAgLy8gY3R4LmZpbGxSZWN0KHgtaHcsIHktaGgsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KVxuXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cblxuICAgIH1cblxuICAgIGlzSGl0KHBvaW50KSB7XG4gICAgICAgIGlmKCF0aGlzLl9jYWNoZVBvaW50cykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBwb2x5Z29uID0gdGhpcy5fY2FjaGVQb2ludHM7XG4gICAgICAgIGxldCBvZGQgPSBmYWxzZTtcbiAgICAgICAgLy8gRm9yIGVhY2ggZWRnZSAoSW4gdGhpcyBjYXNlIGZvciBlYWNoIHBvaW50IG9mIHRoZSBwb2x5Z29uIGFuZCB0aGUgcHJldmlvdXMgb25lKVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IHBvbHlnb24ubGVuZ3RoIC0gMTsgaSA8IHBvbHlnb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIElmIGEgbGluZSBmcm9tIHRoZSBwb2ludCBpbnRvIGluZmluaXR5IGNyb3NzZXMgdGhpcyBlZGdlXG4gICAgICAgICAgICBpZiAoKChwb2x5Z29uW2ldWzFdID4gcG9pbnRbMV0pICE9PSAocG9seWdvbltqXVsxXSA+IHBvaW50WzFdKSkgLy8gT25lIHBvaW50IG5lZWRzIHRvIGJlIGFib3ZlLCBvbmUgYmVsb3cgb3VyIHkgY29vcmRpbmF0ZVxuICAgICAgICAgICAgICAgIC8vIC4uLmFuZCB0aGUgZWRnZSBkb2Vzbid0IGNyb3NzIG91ciBZIGNvcnJkaW5hdGUgYmVmb3JlIG91ciB4IGNvb3JkaW5hdGUgKGJ1dCBiZXR3ZWVuIG91ciB4IGNvb3JkaW5hdGUgYW5kIGluZmluaXR5KVxuICAgICAgICAgICAgICAgICYmIChwb2ludFswXSA8ICgocG9seWdvbltqXVswXSAtIHBvbHlnb25baV1bMF0pICogKHBvaW50WzFdIC0gcG9seWdvbltpXVsxXSkgLyAocG9seWdvbltqXVsxXSAtIHBvbHlnb25baV1bMV0pICsgcG9seWdvbltpXVswXSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gSW52ZXJ0IG9kZFxuICAgICAgICAgICAgICAgIG9kZCA9ICFvZGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqID0gaTtcblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZGQ7XG4gICAgfVxuXG4gICAgZ2V0Qm91bmRpbmdSZWN0KCkge1xuICAgICAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGggLzI7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICBjb25zdCBsdHggPSBhbmNob3JbMF0gLSB3O1xuICAgICAgICBjb25zdCBsdHkgPSBhbmNob3JbMV0gLSBoO1xuICAgICAgICBjb25zdCByYnggPSBhbmNob3JbMF0gKyB3O1xuICAgICAgICBjb25zdCByYnkgPSBhbmNob3JbMV0gKyBoO1xuICAgICAgICBjb25zdCBiciA9IHRoaXMuX2JvdW5kaW5ncmVjdDtcbiAgICAgICAgYnJbMF0gPSBsdHg7XG4gICAgICAgIGJyWzFdID0gbHR5O1xuICAgICAgICBiclsyXSA9IHJieDtcbiAgICAgICAgYnJbM10gPSByYnk7XG4gICAgICAgIHJldHVybiBiclxuICAgIH1cblxuICAgIGdldEJvdW5kaW5nRGltZW5zaW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0SW50ZXJzZWN0aW9uc0luRm91ckRpbWVuc2lvbigpIHtcbiAgICAgICAgbGV0IHAyID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGlmKHRoaXMuX2JlbG9uZ3MgJiYgdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbikge1xuICAgICAgICAgICAgcDIgPSB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKHAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IFt4MiwgeTJdID0gcDI7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoLzI7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW0RJUkVDVElPTi5SSUdIVF06ICBbeDIrdywgeTJdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5MRUZUXTogICBbeDItdywgeTJdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5CT1RUT01dOiBbeDIsIHkyK2hdLFxuICAgICAgICAgICAgW0RJUkVDVElPTi5UT1BdOiAgICBbeDIsIHkyLWhdLFxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEaWFtb25kOyIsImltcG9ydCBEaWFtb25kIGZyb20gJy4vZGlhbW9uZCc7XG5jb25zdCBiYWNrc3FydDMgPSAxL01hdGguc3FydCgzKVxuXG4vKipcbiAqIOWeguebtOmSu+efs+W9ouWNleWFg1xuICogQGNvbnN0cnVjdG9yIERpYW1vbmRWZXJ0aWNhbFxuICogQHBhcmFtIHtEaWFtb25kfkRpYW1vbmRDb25maWdzfSBjb25maWdzIC0g6YWN572uXG4gKiBAZXh0ZW5kcyBEaWFtb25kXG4gKi9cbmNsYXNzIERpYW1vbmRWZXJ0aWNhbCBleHRlbmRzIERpYW1vbmQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3MpIHtcbiAgICAgICAgc3VwZXIoY29uZmlncylcbiAgICB9XG5cbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGlmKHRoaXMuX2lzTW92aW5nKXtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNlxuICAgICAgICB9XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29uc3QgW3gsIHldID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IGh3ID0gdGhpcy53aWR0aC8yO1xuICAgICAgICBjb25zdCBoaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIGNvbnN0IHl5ID0gaHcgLyAxLjczMlxuXG4gICAgICAgIGNvbnN0IHRvcCA9IHkgLSBoaDtcbiAgICAgICAgY29uc3QgYm90dG9tID0geSArIGhoO1xuICAgICAgICBjb25zdCB0b3BtaWRkbGUgPSB5IC0gaGggKyB5eTtcbiAgICAgICAgY29uc3QgYm90dG9tbWlkZGxlID0geSArIGhoIC0geXk7XG4gICAgICAgIGNvbnN0IHhsZWZ0ID0geCAtIGh3O1xuICAgICAgICBjb25zdCB4cmlnaHQgPSB4ICsgaHc7XG5cbiAgICAgICAgY3R4Lm1vdmVUbyh4LCB0b3ApO1xuICAgICAgICBjdHgubGluZVRvKHhyaWdodCwgdG9wbWlkZGxlKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4cmlnaHQsIGJvdHRvbW1pZGRsZSk7XG4gICAgICAgIGN0eC5saW5lVG8oeCwgYm90dG9tKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4bGVmdCwgYm90dG9tbWlkZGxlKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4bGVmdCwgdG9wbWlkZGxlKTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGlmICh0aGlzLnNoYWRvd0NvbG9yKSB7XG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSB0aGlzLnNoYWRvd0NvbG9yO1xuICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSB0aGlzLnNoYWRvd0JsdXI7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHRoaXMuc2hhZG93T2Zmc2V0WDtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gdGhpcy5zaGFkb3dPZmZzZXRZO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGlmKHRoaXMuYm9yZGVyV2lkdGgpIHtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmJvcmRlcldpZHRoO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5ib3JkZXJDb2xvcjtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIHRoaXMuX2NhY2hlUG9pbnRzID0gW1xuICAgICAgICAgICAgW3gsIHRvcF0sXG4gICAgICAgICAgICBbeHJpZ2h0LCB0b3BtaWRkbGVdLFxuICAgICAgICAgICAgW3hyaWdodCwgYm90dG9tbWlkZGxlXSxcbiAgICAgICAgICAgIFt4LCBib3R0b21dLFxuICAgICAgICAgICAgW3hsZWZ0LCBib3R0b21taWRkbGVdLFxuICAgICAgICAgICAgW3hsZWZ0LCB0b3BtaWRkbGVdXG4gICAgICAgIF07XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgRGlhbW9uZFZlcnRpY2FsOyIsImltcG9ydCBOb2RlIGZyb20gJy4uL25vZGUnO1xuaW1wb3J0IFN0YWNrTWl4aW4gZnJvbSAnLi4vc3RhY2tNaXhpbic7XG5pbXBvcnQgTGF5b3V0TWl4aW4gZnJvbSAnLi4vbGF5b3V0TWl4aW4nO1xuaW1wb3J0IFJlY3RhbmdsZSBmcm9tICcuLi9zaGFwZXMvcmVjdGFuZ2xlJztcbmltcG9ydCB7IGJvdW5kaW5nX2JveCwgZG9PdmVybGFwIH0gZnJvbSAnLi4vLi4vdXRpbHMvZnVuY3Rpb25zJztcbmltcG9ydCB7IERJUkVDVElPTiB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbnN0YW5jZSc7XG5pbXBvcnQgeyBTY3JvbGxCYXIgfSBmcm9tICcuLi8uLi9zY3JvbGxiYXIvc2Nyb2xsYmFyTWl4aW4nO1xuY29uc3QgaXNoaXRLZXkgPSBTeW1ib2woJ2lzaGl0Jyk7XG5cbmNsYXNzIElubmVyU2Nyb2xsQmFyIGV4dGVuZHMgU2Nyb2xsQmFyIHtcbiAgICBjb25zdHJ1Y3RvcihkaXIsIGNvbmZpZ3MgPSB7fSkge1xuICAgICAgICBzdXBlcihkaXIsIGNvbmZpZ3MpO1xuICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICB9XG4gICAgcmVuZGVyKGN0eCkge1xuICAgICAgICBpZih0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgIHN1cGVyLnJlbmRlcihjdHgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0SGl0KGlzaGl0KSB7XG4gICAgICAgIGlmKHRoaXNbaXNoaXRLZXldICE9PSBpc2hpdCkge1xuICAgICAgICAgICAgdGhpcy5pc0ZvY3VzID0gaXNoaXRcbiAgICAgICAgICAgIHRoaXMub25IaXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW2lzaGl0S2V5XSA9IGlzaGl0O1xuICAgIH1cbn1cbiBcbmNsYXNzIFNjcm9sbEdyb3VwIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlncykge1xuICAgICAgICBzdXBlcihjb25maWdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ1Njcm9sbEdyb3VwJztcbiAgICAgICAgdGhpcy5pbml0U3RhY2soY29uZmlncyk7XG4gICAgICAgIHRoaXMuaW5pdExheW91dChjb25maWdzKTtcbiAgICAgICAgdGhpcy5pbml0U2Nyb2xsQmFyKGNvbmZpZ3MpO1xuICAgICAgICB0aGlzLl9zaGFwZSA9IG5ldyBSZWN0YW5nbGUoY29uZmlncyk7XG4gICAgICAgIHRoaXMuX3NoYXBlLmFuY2hvciA9IFswLCAwXTtcbiAgICAgICAgdGhpcy5fc2hhcGUuX2JlbG9uZ3MgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMubWF4V2lkdGggPSBjb25maWdzLm1heFdpZHRoIHx8IEluZmluaXR5O1xuICAgICAgICB0aGlzLmRlZmluZWRXaWR0aCA9IGNvbmZpZ3MuZGVmaW5lZFdpZHRoO1xuICAgICAgICB0aGlzLm1heEhlaWdodCA9IGNvbmZpZ3MubWF4SGVpZ2h0IHx8IEluZmluaXR5O1xuICAgICAgICB0aGlzLmRlZmluZWRIZWlnaHQgPSBjb25maWdzLmRlZmluZWRIZWlnaHQ7XG5cbiAgICAgICAgdGhpcy5sb2NrID0gY29uZmlncy5sb2NrID8/IHRydWUgO1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBbMCwgMF07XG5cbiAgICAgICAgdGhpcy5fZ2V0Qm91bmRpbmdHcm91cFJlY3QoKTtcbiAgICAgICAgdGhpcy5yZWZsb3coKTtcbiAgICAgICAgdGhpcy5fZ2V0Qm91bmRpbmdHcm91cFJlY3QoKTsgIFxuICAgICAgICB0aGlzLl9yZXNldE9mZnNldCgpO1xuICAgICAgICB0aGlzLl9jYWNoZVZpZXdCb3ggPSBbXVxuXG4gICAgfVxuXG4gICAgaW5pdFNjcm9sbEJhcihjb25maWdzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGJhckNvbG9yLFxuICAgICAgICAgICAgYmFyRm9jdXNDb2xvcixcbiAgICAgICAgICAgIGJhck1hcmdpblgsXG4gICAgICAgICAgICBiYXJNYXJnaW5ZLFxuICAgICAgICAgICAgYmFyV2lkdGgsXG4gICAgICAgIH0gPSBjb25maWdzO1xuICAgICAgICB0aGlzLl9zY3JvbGxiYXJYID0gbmV3IElubmVyU2Nyb2xsQmFyKCd4Jywge1xuICAgICAgICAgICAgcGxhaW5Db2xvcjogYmFyQ29sb3IsXG4gICAgICAgICAgICBmb2N1c0NvbG9yOiBiYXJGb2N1c0NvbG9yLFxuICAgICAgICAgICAgYmFyV2lkdGgsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zY3JvbGxiYXJZID0gbmV3IElubmVyU2Nyb2xsQmFyKCd5Jywge1xuICAgICAgICAgICAgcGxhaW5Db2xvcjogYmFyQ29sb3IsXG4gICAgICAgICAgICBmb2N1c0NvbG9yOiBiYXJGb2N1c0NvbG9yLFxuICAgICAgICAgICAgYmFyV2lkdGhcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3Njcm9sbGJhclguYmFyTWFyZ2luWCA9IGJhck1hcmdpblggfHwgMTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWS5iYXJNYXJnaW5ZID0gYmFyTWFyZ2luWSB8fCAxO1xuICAgICAgICBjb25zdCBfZiA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2pmbG93LnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWC5vbkhpdCA9IF9mO1xuICAgICAgICB0aGlzLl9zY3JvbGxiYXJZLm9uSGl0ID0gX2Y7XG5cbiAgICAgICAgdGhpcy5fc2Nyb2xsQmFyU3RhdHVzID0ge1xuICAgICAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAgICAgdGFyZ2V0OiBudWxsLFxuXG4gICAgICAgICAgICBiYXJJbml0WDogMCxcbiAgICAgICAgICAgIGJhckluaXRZOiAwLFxuICAgICAgICAgICAgYmFyU3RhcnRYOiAwLFxuICAgICAgICAgICAgYmFyU3RhcnRZOiAwLFxuXG4gICAgICAgICAgICBoaXRTY3JvbGxYOiBmYWxzZSxcbiAgICAgICAgICAgIGhpdFNjcm9sbFk6IGZhbHNlLFxuICAgICAgICB9XG4gICAgICAgIC8vIC8vIGNvbnN0IGpmbG93SW5zdGFuY2UgPSB0aGlzLl9qZmxvdztcbiAgICAgICAgLy8gdGhpcy5hZGRFdmVudExpc3RlbmVyKCdpbnN0YW5jZW1vdXNlbW92ZScsIGUgPT4ge1xuICAgICAgICAvLyAgICAgaWYodGhpcy5fc2Nyb2xsQmFyU3RhdHVzLmhpdFNjcm9sbFgpIHtcbiAgICAgICAgLy8gICAgICAgICBpZighdGhpcy5fc2Nyb2xsYmFyWC5pc0ZvY3VzKSB7XG4gICAgICAgIC8vICAgICAgICAgICAgIHRoaXMuX3Njcm9sbGJhclguaXNGb2N1cyA9IHRydWU7XG4gICAgICAgIC8vICAgICAgICAgICAgIGUuZGV0YWlsLmpmbG93LnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgIC8vICAgICAgICAgfVxuICAgICAgICAvLyAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gICAgIGlmKHRoaXMuX3Njcm9sbGJhclguaXNGb2N1cykge1xuICAgICAgICAvLyAgICAgICAgIHRoaXMuX3Njcm9sbGJhclguaXNGb2N1cyA9IGZhbHNlO1xuICAgICAgICAvLyAgICAgICAgIGUuZGV0YWlsLmpmbG93LnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyB9KVxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2luc3RhbmNlUHJlc3NTdGFydCcsIGUgPT4ge1xuICAgICAgICAgICAgaWYodGhpcy5fc2Nyb2xsQmFyU3RhdHVzLmhpdFNjcm9sbFgpIHtcbiAgICAgICAgICAgICAgICBlLmRldGFpbC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuZGV0YWlsLmJ1YmJsZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRYID0gZS5kZXRhaWwuZXZlbnQuY2xpZW50WDtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3Njcm9sbEJhclN0YXR1cywge1xuICAgICAgICAgICAgICAgICAgICBkcmFnZ2luZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLl9zY3JvbGxiYXJYLFxuICAgICAgICAgICAgICAgICAgICBiYXJTdGFydFg6IHRoaXMuX3Njcm9sbGJhclguYW5jaG9yWzBdLFxuICAgICAgICAgICAgICAgICAgICBiYXJJbml0WDogY2xpZW50WCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uU2Nyb2xsYmFyUHJlc3NTdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5fc2Nyb2xsQmFyU3RhdHVzLmhpdFNjcm9sbFkpIHtcbiAgICAgICAgICAgICAgICBlLmRldGFpbC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuZGV0YWlsLmJ1YmJsZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRZID0gZS5kZXRhaWwuZXZlbnQuY2xpZW50WTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3Njcm9sbEJhclN0YXR1cywge1xuICAgICAgICAgICAgICAgICAgICBkcmFnZ2luZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLl9zY3JvbGxiYXJZLFxuICAgICAgICAgICAgICAgICAgICBiYXJTdGFydFk6IHRoaXMuX3Njcm9sbGJhclkuYW5jaG9yWzFdLFxuICAgICAgICAgICAgICAgICAgICBiYXJJbml0WTogY2xpZW50WSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uU2Nyb2xsYmFyUHJlc3NTdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIG9uU2Nyb2xsYmFyUHJlc3NTdGFydCgpIHtcbiAgICAgICAgY29uc3QgamZsb3dJbnN0YW5jZSA9IHRoaXMuX2pmbG93O1xuICAgICAgICBjb25zdCBjYW52YXMgPSBqZmxvd0luc3RhbmNlLmNhbnZhcztcbiAgICAgICAgY29uc3QgZiA9IChlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gZTtcbiAgICAgICAgICAgIHRoaXMub25EcmFnZ2luZ1Njcm9sbGJhcihjbGllbnRYLCBjbGllbnRZKVxuICAgICAgICB9KS5iaW5kKHRoaXMpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIGYpO1xuICAgICAgICBjb25zdCB0ID0gKGUgPT4ge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9zY3JvbGxCYXJTdGF0dXMsIHtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICAgICAgICAgIGJhckluaXRYOiAwLFxuICAgICAgICAgICAgICAgIGJhckluaXRZOiAwLFxuICAgICAgICAgICAgICAgIGJhclN0YXJ0WDogMCxcbiAgICAgICAgICAgICAgICBiYXJTdGFydFk6IDAsXG4gICAgICAgICAgICAgICAgaGl0U2Nyb2xsWDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaGl0U2Nyb2xsWTogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgZik7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCB0KTtcbiAgICAgICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCB0KTtcbiAgICAgICAgfSkuYmluZCh0aGlzKTtcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHQsIHtcbiAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSlcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdCwge1xuICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIG9uRHJhZ2dpbmdTY3JvbGxiYXIoY2xpZW50WCwgY2xpZW50WSkge1xuICAgICAgICBpZih0aGlzLl9zY3JvbGxiYXJYLnZpc2libGUgJiYgdGhpcy5fc2Nyb2xsQmFyU3RhdHVzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBKRkxPVyA9IHRoaXMuX2pmbG93O1xuICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSBKRkxPVy5zY2FsZTtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgYmFySW5pdFgsXG4gICAgICAgICAgICAgICAgYmFyU3RhcnRYLFxuICAgICAgICAgICAgICAgIGJhckluaXRZLFxuICAgICAgICAgICAgICAgIGJhclN0YXJ0WVxuICAgICAgICAgICAgfSA9IHRoaXMuX3Njcm9sbEJhclN0YXR1cztcbiAgICAgICAgICAgIGlmKHRhcmdldC5kaXIgPT09ICd4Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9zY3JvbGxXaWR0aCA9IHRoaXMuX3Njcm9sbGJhclgud2lkdGg7XG4gICAgICAgICAgICAgICAgY29uc3QgX291dGVyV2lkdGggPSB0aGlzLl9vdXRlcldpZHRoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhWCA9IGNsaWVudFggLSBiYXJJbml0WDtcbiAgICAgICAgICAgICAgICBjb25zdCB4bmV3ID0gYmFyU3RhcnRYICsgZGVsdGFYIC8gc2NhbGU7XG4gICAgICAgICAgICAgICAgY29uc3QgcSA9IHRhcmdldC5hbmNob3JbMF0gPSBNYXRoLm1heChNYXRoLm1pbih4bmV3LCBfb3V0ZXJXaWR0aCAtIF9zY3JvbGxXaWR0aCksIDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhdGlvSW5YID0gcSAvIChfb3V0ZXJXaWR0aCAtIF9zY3JvbGxXaWR0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9ICh0aGlzLl9pbm5lcldpZHRoIC0gX291dGVyV2lkdGgpLzI7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0WzBdID0gcyAtICh0aGlzLl9pbm5lcldpZHRoIC0gX291dGVyV2lkdGgpICogcmF0aW9JblhcbiAgICAgICAgICAgICAgICBKRkxPVy5zY2hlZHVsZVJlbmRlcigpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHRhcmdldC5kaXIgPT09ICd5Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9zY3JvbGxIZWlnaHQgPSB0aGlzLl9zY3JvbGxiYXJZLmhlaWdodDtcbiAgICAgICAgICAgICAgICBjb25zdCBfb3V0ZXJIZWlnaHQgPSB0aGlzLl9vdXRlckhlaWdodDtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YVkgPSBjbGllbnRZIC0gYmFySW5pdFk7XG4gICAgICAgICAgICAgICAgY29uc3QgeW5ldyA9IGJhclN0YXJ0WSArIGRlbHRhWSAvIHNjYWxlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHEgPSB0YXJnZXQuYW5jaG9yWzFdID0gTWF0aC5tYXgoTWF0aC5taW4oeW5ldywgX291dGVySGVpZ2h0IC0gX3Njcm9sbEhlaWdodCksIDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhdGlvID0gcSAvIChfb3V0ZXJIZWlnaHQgLSBfc2Nyb2xsSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gKHRoaXMuX2lubmVySGVpZ2h0IC0gX291dGVySGVpZ2h0KS8yO1xuICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldFsxXSA9IHMgLSAodGhpcy5faW5uZXJIZWlnaHQgLSBfb3V0ZXJIZWlnaHQpICogcmF0aW9cbiAgICAgICAgICAgICAgICBKRkxPVy5zY2hlZHVsZVJlbmRlcigpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIHNldENvbmZpZyhjb25maWdzKSB7XG4gICAgICAgIHRoaXMuX3NoYXBlLnNldENvbmZpZyhjb25maWdzKTtcbiAgICB9XG5cbiAgICBfZ2V0Qm91bmRpbmdHcm91cFJlY3QoKSB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX3N0YWNrLmdldEJvdW5kaW5nUmVjdFBvaW50cygpO1xuICAgICAgICAvLyBjb250ZW50IGJveCBcbiAgICAgICAgY29uc3QgYmJveCA9IGJvdW5kaW5nX2JveChwb2ludHMpO1xuICAgICAgICBjb25zdCB3ID0gYmJveC53aWR0aDtcbiAgICAgICAgY29uc3QgaCA9IGJib3guaGVpZ2h0O1xuICAgICAgICBjb25zdCBvdXRlcldpZHRoID0gdGhpcy5kZWZpbmVkV2lkdGggfHwgTWF0aC5taW4odywgdGhpcy5tYXhXaWR0aCk7XG4gICAgICAgIGNvbnN0IG91dGVySGVpZ2h0ID0gdGhpcy5kZWZpbmVkSGVpZ2h0IHx8IE1hdGgubWluKGgsIHRoaXMubWF4SGVpZ2h0KTtcbiAgICAgICAgdGhpcy5faW5uZXJXaWR0aCA9IHc7XG4gICAgICAgIHRoaXMuX291dGVyV2lkdGggPSBvdXRlcldpZHRoO1xuICAgICAgICB0aGlzLl9pbm5lckhlaWdodCA9IGg7XG4gICAgICAgIHRoaXMuX291dGVySGVpZ2h0ID0gb3V0ZXJIZWlnaHQ7XG5cbiAgICAgICAgdGhpcy5fc2hhcGUud2lkdGggPSBvdXRlcldpZHRoO1xuICAgICAgICB0aGlzLl9zaGFwZS5oZWlnaHQgPSBvdXRlckhlaWdodDtcbiAgICAgICAgdGhpcy53aWR0aCA9IG91dGVyV2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gb3V0ZXJIZWlnaHQ7XG4gICAgfVxuXG4gICAgX2NhbGN1bGF0ZVBvaW50QmFjayhwb2ludCkge1xuICAgICAgICBjb25zdCBbZ3gsIGd5XSA9IHBvaW50O1xuICAgICAgICBjb25zdCBbdHgsIHR5XSA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgY29uc3QgW2N4LCBjeV0gPSB0aGlzLmFuY2hvcjsgXG4gICAgICAgIGNvbnN0IHAgPSBbZ3ggLSBjeCAtIHR4LCBneSAtIGN5IC0gdHldXG4gICAgICAgIHJldHVybiBwXG4gICAgfVxuXG4gICAgX2NhbGN1bGF0ZVBvaW50QmFja1dpdGhQb2ludChhLCBiLCBhcnIsIGlkeDEsIGlkeDIpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgYXJyW2lkeDFdID0gYSAtIGFuY2hvclswXSAtIG9mZnNldFswXTtcbiAgICAgICAgYXJyW2lkeDJdID0gYiAtIGFuY2hvclsxXSAtIG9mZnNldFsxXTtcbiAgICB9XG5cbiAgICBjYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbihwb2ludCkge1xuICAgICAgICBjb25zdCBbZ3gsIGd5XSA9IHBvaW50O1xuICAgICAgICBjb25zdCBbY3gsIGN5XSA9IHRoaXMuYW5jaG9yOyAgXG4gICAgICAgIGNvbnN0IFt0eCwgdHldID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgICBjb25zdCBwID0gW2d4ICsgY3ggLSB0eCwgZ3kgKyBjeSAtIHR5XVxuICAgICAgICBpZih0aGlzLl9iZWxvbmdzICYmIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKHApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxjdWxhdGVUb1JlYWxXb3JsZChwb2ludCkge1xuICAgICAgICBjb25zdCBbZ3gsIGd5XSA9IHBvaW50O1xuICAgICAgICBjb25zdCBbY3gsIGN5XSA9IHRoaXMuYW5jaG9yOyAgXG4gICAgICAgIGNvbnN0IFt0eCwgdHldID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgICBjb25zdCBwID0gW2d4ICsgY3ggLSB0eCwgZ3kgKyBjeSAtIHR5XVxuICAgICAgICBpZih0aGlzLl9iZWxvbmdzICYmIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9SZWFsV29ybGQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvUmVhbFdvcmxkKHApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlVG9SZWFsV29ybGRXaXRoUG9pbnRlcihvdXRwb2ludCwgaW5wb2ludCkge1xuICAgICAgICBvdXRwb2ludFswXSA9IGlucG9pbnRbMF0gKyB0aGlzLmFuY2hvclswXSAtIHRoaXMub2Zmc2V0WzBdO1xuICAgICAgICBvdXRwb2ludFsxXSA9IGlucG9pbnRbMV0gKyB0aGlzLmFuY2hvclsxXSAtIHRoaXMub2Zmc2V0WzFdO1xuICAgICAgICBpZih0aGlzLl9iZWxvbmdzICYmIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9SZWFsV29ybGRXaXRoUG9pbnRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9SZWFsV29ybGRXaXRoUG9pbnRlcihvdXRwb2ludCwgb3V0cG9pbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldFZpZXdCb3goKSB7XG4gICAgICAgIGNvbnN0IGJlbG9uZ3NfdmJveCA9IHRoaXMuX2JlbG9uZ3MuZ2V0Q2FjaGVWaWV3Qm94KCk7XG4gICAgICAgIGNvbnN0IGNhY2hlVmlld0JveCA9IHRoaXMuX2NhY2hlVmlld0JveDtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVBvaW50QmFja1dpdGhQb2ludChiZWxvbmdzX3Zib3hbMF0sIGJlbG9uZ3NfdmJveFsxXSwgY2FjaGVWaWV3Qm94LCAwLCAxKTtcbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlUG9pbnRCYWNrV2l0aFBvaW50KGJlbG9uZ3NfdmJveFsyXSwgYmVsb25nc192Ym94WzNdLCBjYWNoZVZpZXdCb3gsIDIsIDMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVWaWV3Qm94O1xuICAgIH1cblxuICAgIGdldENhY2hlVmlld0JveCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlVmlld0JveDtcbiAgICB9XG5cbiAgICBfcmVzZXRPZmZzZXQoKSB7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IFtcbiAgICAgICAgICAgIE1hdGgubWF4KCh0aGlzLl9pbm5lcldpZHRoIC0gdGhpcy5fb3V0ZXJXaWR0aCkvMiwgMCksXG4gICAgICAgICAgICBNYXRoLm1heCgodGhpcy5faW5uZXJIZWlnaHQgLSB0aGlzLl9vdXRlckhlaWdodCkvMiwgMCksXG4gICAgICAgIF07XG4gICAgICAgIGlmKHRoaXMuX2lubmVyV2lkdGggPiB0aGlzLl9vdXRlcldpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxiYXJYLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWC53aWR0aCA9IHRoaXMuX291dGVyV2lkdGggKiB0aGlzLl9vdXRlcldpZHRoIC8gdGhpcy5faW5uZXJXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbGJhclguYW5jaG9yID0gWzAsIHRoaXMuX291dGVySGVpZ2h0IC0gNF1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbGJhclgudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuX2lubmVySGVpZ2h0ID4gdGhpcy5fb3V0ZXJIZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbGJhclkudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxiYXJZLmhlaWdodCA9IHRoaXMuX291dGVySGVpZ2h0ICogdGhpcy5fb3V0ZXJIZWlnaHQgLyB0aGlzLl9pbm5lckhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbGJhclkuYW5jaG9yID0gW3RoaXMuX291dGVyV2lkdGggLSA0LCAwXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIGlmKHRoaXMuX2lzTW92aW5nKXtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNlxuICAgICAgICB9IGVsc2UgaWYodGhpcy5vcGFjaXR5ICE9PSAxKSB7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLm9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2N4LCBjeV0gPSB0aGlzLmFuY2hvcjsgXG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IHcyID0gdy8yO1xuICAgICAgICBjb25zdCBoMiA9IGgvMjtcbiAgICAgICAgLy8gaWYoKHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCkgKiB0aGlzLl9qZmxvdy5zY2FsZSA8IDE0NCkge1xuICAgICAgICAvLyAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgLy8gICAgIHJldHVybjtcbiAgICAgICAgLy8gfVxuICAgICAgICBjb25zdCBbdHgsIHR5XSA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShjeCwgY3kpO1xuICAgICAgICB0aGlzLl9zaGFwZS5yZW5kZXIoY3R4KTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgtdzIsIC1oMik7XG4gICAgICAgIGlmKHRoaXMuX3Njcm9sbGJhclgudmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWC5yZW5kZXIoY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLl9zY3JvbGxiYXJZLnZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbGJhclkucmVuZGVyKGN0eCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgudHJhbnNsYXRlKHcyLCBoMik7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnJlY3QoLXcyLCAtaDIsIHcsIGgpO1xuICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIHRoaXMuX3N0YWNrLnJlbmRlcihjdHgpO1xuICAgICAgICB0aGlzLl9saW5rU3RhY2sucmVuZGVyKGN0eCk7ICAgIFxuICAgICAgICBjdHgudHJhbnNsYXRlKC1jeC10eCwgLWN5LXR5KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBpc0hpdChwb2ludCwgY29uZGl0aW9uKSB7XG4gICAgICAgIGNvbnN0IFtneCwgZ3ldID0gcG9pbnQ7XG4gICAgICAgIGNvbnN0IFtjeCwgY3ldID0gdGhpcy5hbmNob3I7IFxuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aC8yO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgY29uc3Qgc3AgPSBbZ3ggLSBjeCArIHcsIGd5IC0gY3kgKyBoXVxuICAgICAgICB0aGlzLl9zY3JvbGxCYXJTdGF0dXMuaGl0U2Nyb2xsWCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zY3JvbGxCYXJTdGF0dXMuaGl0U2Nyb2xsWSA9IGZhbHNlO1xuICAgICAgICBpZih0aGlzLl9zY3JvbGxiYXJYLnZpc2libGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHhoaXQgPSB0aGlzLl9zY3JvbGxiYXJYLmlzSGl0KHNwKTtcbiAgICAgICAgICAgIGlmKHhoaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxCYXJTdGF0dXMuaGl0U2Nyb2xsWCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWC5zZXRIaXQodHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zY3JvbGxiYXJYLnNldEhpdChmYWxzZSlcblxuICAgICAgICBpZih0aGlzLl9zY3JvbGxiYXJZLnZpc2libGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHloaXQgPSB0aGlzLl9zY3JvbGxiYXJZLmlzSGl0KHNwKTtcbiAgICAgICAgICAgIGlmKHloaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxCYXJTdGF0dXMuaGl0U2Nyb2xsWSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYmFyWS5zZXRIaXQodHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zY3JvbGxiYXJZLnNldEhpdChmYWxzZSlcbiAgICAgICBcbiAgICAgICAgLy8gY29uc3QgYnIgPSB0aGlzLl9nZXRWaWV3Qm94KCk7XG4gICAgICAgIGNvbnN0IGlzSW5Cb3VuZCA9IHRoaXMuX3NoYXBlLmlzSGl0KFtneCAtIGN4LCBneSAtIGN5XSk7XG4gICAgICAgIGlmKGlzSW5Cb3VuZCkge1xuICAgICAgICAgICAgY29uc3QgW3R4LCB0eV0gPSB0aGlzLl9vZmZzZXQ7XG4gICAgICAgICAgICBjb25zdCBwID0gW2d4IC0gY3ggLSB0eCwgZ3kgLSBjeSAtIHR5XTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRwID0gcDsgLy8g5pqC5a2Y77yM5Li65LqG5ZCO57ut6K6h566X5Yir55qE5L2N572uXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl9zdGFjay5jaGVja0hpdChwLCBjb25kaXRpb24pOyBcbiAgICAgICAgICAgIGlmKHRhcmdldCkgcmV0dXJuIHRhcmdldDsgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFjay5yZXNldEhpdFN0YXR1cygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXRCb3VuZGluZ0RpbWVuc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEJvdW5kaW5nUmVjdCgpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoIC8yO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgY29uc3QgbHR4ID0gYW5jaG9yWzBdIC0gdztcbiAgICAgICAgY29uc3QgbHR5ID0gYW5jaG9yWzFdIC0gaDtcbiAgICAgICAgY29uc3QgcmJ4ID0gYW5jaG9yWzBdICsgdztcbiAgICAgICAgY29uc3QgcmJ5ID0gYW5jaG9yWzFdICsgaDtcbiAgICAgICAgY29uc3QgYnIgPSB0aGlzLl9ib3VuZGluZ3JlY3Q7XG4gICAgICAgIGJyWzBdID0gbHR4O1xuICAgICAgICBiclsxXSA9IGx0eTtcbiAgICAgICAgYnJbMl0gPSByYng7XG4gICAgICAgIGJyWzNdID0gcmJ5O1xuICAgICAgICByZXR1cm4gYnJcbiAgICB9XG5cbiAgICBnZXRJbnRlcnNlY3Rpb25zSW5Gb3VyRGltZW5zaW9uKCkge1xuICAgICAgICBsZXQgcDIgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgaWYodGhpcy5fYmVsb25ncyAmJiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvQ29vcmRpbmF0aW9uKSB7XG4gICAgICAgICAgICBwMiA9IHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24ocDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgW3gyLCB5Ml0gPSBwMjtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGgvMjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbRElSRUNUSU9OLlJJR0hUXTogIFt4Mit3LCB5Ml0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLkxFRlRdOiAgIFt4Mi13LCB5Ml0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLkJPVFRPTV06IFt4MiwgeTIraF0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLlRPUF06ICAgIFt4MiwgeTItaF0sXG4gICAgICAgICAgICBbRElSRUNUSU9OLlNFTEZdOiAgIFt4Mit3KjAuNjE4LCB5MitoKjAuNjE4XVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25FbnRlclZpZXdib3goKSB7XG4gICAgICAgIHRoaXMuaW50ZXJhdGVOb2RlU3RhY2soKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICBpbnN0YW5jZS5vbkVudGVyVmlld2JveCgpO1xuICAgICAgICB9KVxuICAgIH1cbiAgICBvbkxlYXZlVmlld2JveCgpIHtcbiAgICAgICAgdGhpcy5pbnRlcmF0ZU5vZGVTdGFjaygoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICAgIGluc3RhbmNlLm9uTGVhdmVWaWV3Ym94KCk7XG4gICAgICAgIH0pXG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3NoYXBlLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pbnRlcmF0ZU5vZGVTdGFjaygoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICAgIGluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgQyA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIGNvbnN0IGNvbmZpZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9yYXdDb25maWdzLCB7XG4gICAgICAgICAgICBsYXlvdXQ6IHRoaXMuX2xheW91dCAmJiB0aGlzLl9sYXlvdXQuY2xvbmUoKSxcbiAgICAgICAgfSlcbiAgICAgICAgY29uc3QgdCA9IG5ldyBDKGNvbmZpZ3MpO1xuICAgICAgICB0aGlzLmludGVyYXRlTm9kZVN0YWNrKChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgICAgdC5hZGRUb1N0YWNrKGluc3RhbmNlLmNsb25lKCkpO1xuICAgICAgICB9KVxuICAgICAgICB0LnJlY2FsY3VsYXRlKCk7XG4gICAgICAgIHQudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxufVxuXG5PYmplY3QuYXNzaWduKFNjcm9sbEdyb3VwLnByb3RvdHlwZSwgU3RhY2tNaXhpbik7XG5PYmplY3QuYXNzaWduKFNjcm9sbEdyb3VwLnByb3RvdHlwZSwgTGF5b3V0TWl4aW4pO1xuT2JqZWN0LmFzc2lnbihTY3JvbGxHcm91cC5wcm90b3R5cGUsIHtcbiAgICByZWNhbGN1bGF0ZVVwKCkge1xuICAgICAgICBsZXQgZGlydHkgPSB0cnVlO1xuICAgICAgICBcbiAgICAgICAgaWYodGhpcy5nZXRCb3VuZGluZ0RpbWVuc2lvbikge1xuICAgICAgICAgICAgLy8gY29uc3QgeyB3aWR0aDogd29sZCwgaGVpZ2h0OiBob2xkIH0gPSB0aGlzLmdldEJvdW5kaW5nRGltZW5zaW9uKCk7XG4gICAgICAgICAgICBjb25zdCB3b2xkID0gdGhpcy5faW5uZXJXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGhvbGQgPSB0aGlzLl9pbm5lckhlaWdodDtcbiAgICAgICAgICAgIGlmKHRoaXMucmVzZXRDaGlsZHJlblBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldENoaWxkcmVuUG9zaXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMuX2dldEJvdW5kaW5nR3JvdXBSZWN0KXtcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXRCb3VuZGluZ0dyb3VwUmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWZsb3coKTtcbiAgICAgICAgICAgIGlmKHRoaXMuX2dldEJvdW5kaW5nR3JvdXBSZWN0KXtcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXRCb3VuZGluZ0dyb3VwUmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd25vdyA9IHRoaXMuX2lubmVyV2lkdGg7XG4gICAgICAgICAgICBjb25zdCBobm93ID0gdGhpcy5faW5uZXJIZWlnaHQ7XG4gICAgICAgICAgICAvLyBjb25zdCB7IHdpZHRoOiB3bm93LCBoZWlnaHQ6IGhub3cgfSA9IHRoaXMuZ2V0Qm91bmRpbmdEaW1lbnNpb24oKTtcbiAgICAgICAgICAgIGRpcnR5ID0gKHdvbGQgIT09IHdub3cgfHwgaG9sZCAhPT0gaG5vdylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVmbG93KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5fYmVsb25ncyAmJiBkaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzZXRPZmZzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2JlbG9uZ3MucmVjYWxjdWxhdGVVcCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlY2FsY3VsYXRlKCkge1xuICAgICAgICBjb25zdCB7IHdpZHRoOiB3b2xkLCBoZWlnaHQ6IGhvbGQgfSA9IHRoaXMuZ2V0Qm91bmRpbmdEaW1lbnNpb24oKTtcbiAgICAgICAgdGhpcy5yZWZsb3coKTtcbiAgICAgICAgaWYodGhpcy5fZ2V0Qm91bmRpbmdHcm91cFJlY3Qpe1xuICAgICAgICAgICAgdGhpcy5fZ2V0Qm91bmRpbmdHcm91cFJlY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHdpZHRoOiB3bm93LCBoZWlnaHQ6IGhub3cgfSA9IHRoaXMuZ2V0Qm91bmRpbmdEaW1lbnNpb24oKTtcbiAgICAgICAgaWYgKHdvbGQgIT09IHdub3cgfHwgaG9sZCAhPT0gaG5vdykge1xuICAgICAgICAgICAgdGhpcy5fcmVzZXRPZmZzZXQoKTtcbiAgICAgICAgfVxuICAgIH0sXG59KVxuXG5cbmV4cG9ydCBkZWZhdWx0IFNjcm9sbEdyb3VwIiwiZXhwb3J0IGRlZmF1bHQge1xuICAgIGNhbnZhczoge1xuICAgICAgICB3aGVlbCAoZXZlbnQsIGpmbG93KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgbGV0IHsgb2Zmc2V0WCwgb2Zmc2V0WSwgZGVsdGFYLCBkZWx0YVkgfSA9IGV2ZW50IFxuICAgICAgICAgICAgaWYoZXZlbnQuY3RybEtleSkgeyBcbiAgICAgICAgICAgICAgICBkZWx0YVkgPSAtZGVsdGFZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgamZsb3cuem9vbUhhbmRsZXIob2Zmc2V0WCwgb2Zmc2V0WSwgZGVsdGFYLCBkZWx0YVksIGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICB9XG59IiwiaW1wb3J0IEluc3RhbmNlIGZyb20gJy4vaW5zdGFuY2UnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtJbnN0YW5jZX5Db25maWdzfSBCYXNlTGlua35Db25maWdzXG4gKiBAcHJvcGVydHkge0luc3RhbmNlfSBmcm9tICAgLSDotbflp4vljZXlhYNcbiAqIEBwcm9wZXJ0eSB7SW5zdGFuY2V9IHRvICAgICAtIOe7iOatouWNleWFg1xuICogQHByb3BlcnR5IHtTdHJpbmd9IGZyb21EaXIgIC0g6LW35aeL5pa55ZCRIFxuICogQHByb3BlcnR5IHtTdHJpbmd9IHRvRGlyICAgIC0g57uI5q2i5pa55ZCRIFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleSAgICAgIC0g6L+e57q/5ZSv5LiA6ZSu5YC8XG4gKiBAcHJvcGVydHkge1N0cmluZ30gYmFja2dyb3VuZENvbG9yICAgIC0g57q/5p2h6aKc6ImyIFxuICovXG4vKipcbiAqIOi/nue6v+Wfuuexu1xuICogQGNvbnN0cnVjdG9yIEJhc2VMaW5rXG4gKiBAZXh0ZW5kcyBJbnN0YW5jZVxuICogQHBhcmFtIHtCYXNlTGlua35Db25maWdzfSBjb25maWdzIC0g6YWN572uXG4gKi9cbmNsYXNzIEJhc2VMaW5rIGV4dGVuZHMgSW5zdGFuY2V7XG4gICAgSU5TVEFOQ0VfVFlQRSA9ICdMSU5LJ1xuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgaWYoIXRoaXMuX2JlbG9uZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YWNrID0gdGhpcy5fYmVsb25ncy5fbGlua1N0YWNrXG4gICAgICAgIGNvbnN0IGlkeCA9IHN0YWNrLmZpbmRJbmRleChzID0+IHMgPT09IHRoaXMpO1xuICAgICAgICBpZihpZHggIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tbaWR4KzFdO1xuICAgICAgICB9IFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoY29uZmlncyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtJbnN0YW5jZX0gICAgICAtIOi1t+Wni+WNleWFgyAqL1xuICAgICAgICB0aGlzLmZyb20gICAgID0gY29uZmlncy5mcm9tO1xuICAgICAgICAvKiogQG1lbWJlciB7SW5zdGFuY2V9ICAgICAgLSDnu4jmraLljZXlhYMgKi9cbiAgICAgICAgdGhpcy50byAgICAgICA9IGNvbmZpZ3MudG87XG4gICAgICAgIC8qKiBAbWVtYmVyIHtESVJFQ1RJT059ICAgICAgLSDotbflp4vmlrnlkJEgKi9cbiAgICAgICAgdGhpcy5mcm9tRGlyICA9IGNvbmZpZ3MuZnJvbURpcjtcbiAgICAgICAgLyoqIEBtZW1iZXIge0RJUkVDVElPTn0gICAgICAtIOe7iOatouaWueWQkSAqL1xuICAgICAgICB0aGlzLnRvRGlyICAgID0gY29uZmlncy50b0RpcjtcbiAgICAgICAgLyoqIEBtZW1iZXIge251bWJlcltdW119ICAgICAtIOi/nue6v+aOp+WItueCuee8k+WtmCAqL1xuICAgICAgICB0aGlzLl9jYWNoZVBvaW50cyA9IG51bGw7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtzdHJpbmd9ICAgICAtIOi/nue6v+minOiJsu+8jOm7mOiupOS4uiAjMDAwICovXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gY29uZmlncy5iYWNrZ3JvdW5kQ29sb3IgfHwgJyMwMDAnO1xuXG4gICAgICAgIHRoaXMuaXNTZWxmICAgICAgICA9ICEhY29uZmlncy5pc1NlbGZcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICog5piv5ZCm5Ye6546w5Zyo5b2T5YmN6KeG56qX5YaFXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gdmlld2JveFxuICAgICAqL1xuICAgIGlzSW5WaWV3Qm94KHZpZXdib3gpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBicmluZ1RvVG9wKCkge1xuICAgICAgICBjb25zdCBsaW5rU3RhY2sgPSB0aGlzLl9qZmxvdy5fbGlua1N0YWNrO1xuICAgICAgICBjb25zdCBpbmRleCA9IGxpbmtTdGFjay5maW5kSW5kZXgobCA9PiBsID09PSB0aGlzKTtcbiAgICAgICAgbGlua1N0YWNrLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGxpbmtTdGFjay5wdXNoKHRoaXMpO1xuICAgICAgICB0aGlzLl9qZmxvdy5fcmVuZGVyKCk7XG4gICAgfVxuXG4gICAgXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VMaW5rOyIsImltcG9ydCBOb2RlIGZyb20gJy4uL25vZGUnO1xuXG5jbGFzcyBTaGFkb3dDYWNoZSBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3MpIHtcbiAgICAgICAgc3VwZXIoY29uZmlncyk7XG4gICAgICAgIC8vIHRoaXMuaW1hZ2VEYXRhID0gY29uZmlncy5pbWFnZURhdGE7XG4gICAgICAgIHRoaXMud2lkdGggPSBjb25maWdzLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGNvbmZpZ3MuaGVpZ2h0O1xuICAgICAgICB0aGlzLmltYWdlQnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHRoaXMuaW1hZ2VCdWZmZXIud2lkdGggPSB0aGlzLndpZHRoICsgMjtcbiAgICAgICAgdGhpcy5pbWFnZUJ1ZmZlci5oZWlnaHQgPSB0aGlzLmhlaWdodCArIDI7XG4gICAgICAgIGNvbmZpZ3MuY2FjaGUodGhpcy5pbWFnZUJ1ZmZlci5nZXRDb250ZXh0KCcyZCcpKTtcbiAgICB9XG5cbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIGNvbnN0IFtjeCwgY3ldID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoY3gsIGN5KTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuaW1hZ2VCdWZmZXIsIC10aGlzLndpZHRoLzIsIC10aGlzLmhlaWdodC8yKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgZ2V0Qm91bmRpbmdEaW1lbnNpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWNhbGN1bGF0ZSgpe31cbiAgICBnZXRCb3VuZGluZ1JlY3QoKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aCAvMjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIGNvbnN0IGx0eCA9IGFuY2hvclswXSAtIHc7XG4gICAgICAgIGNvbnN0IGx0eSA9IGFuY2hvclsxXSAtIGg7XG4gICAgICAgIGNvbnN0IHJieCA9IGFuY2hvclswXSArIHc7XG4gICAgICAgIGNvbnN0IHJieSA9IGFuY2hvclsxXSArIGg7XG4gICAgICAgIGNvbnN0IGJyID0gdGhpcy5fYm91bmRpbmdyZWN0O1xuICAgICAgICBiclswXSA9IGx0eDtcbiAgICAgICAgYnJbMV0gPSBsdHk7XG4gICAgICAgIGJyWzJdID0gcmJ4O1xuICAgICAgICBiclszXSA9IHJieTtcbiAgICAgICAgcmV0dXJuIGJyXG4gICAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IFNoYWRvd0NhY2hlOyIsImltcG9ydCBSZWN0YW5nbGUgZnJvbSBcIi4uL3NoYXBlcy9yZWN0YW5nbGVcIjtcbmltcG9ydCB7IHJlcXVlc3RDYWNoZUNhbnZhcyB9IGZyb20gJy4uLy4uL3V0aWxzL2NhbnZhcyc7XG5pbXBvcnQgSkZsb3dFdmVudCBmcm9tICcuLi8uLi9ldmVudHMnXG5pbXBvcnQgU2hhZG93Q2FjaGUgZnJvbSAnLi4vc2hhcGVzL3NoYWRvdy1jYWNoZSc7XG5cbmNvbnN0IFRFWFRfQUxJR04gPSB7XG4gICAgQ0VOVEVSOiAnY2VudGVyJyxcbiAgICBMRUZUOiAnbGVmdCcsXG4gICAgUklHSFQ6ICdyaWdodCcsXG59O1xuY29uc3QgU1BBQ0VfUkVHID0gL1xccy9nO1xuXG5jbGFzcyBUZXh0IGV4dGVuZHMgUmVjdGFuZ2xlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAgICAgICAgICdUZXh0JztcbiAgICAgICAgdGhpcy5jb250ZW50ID0gICAgICBjb25maWdzLmNvbnRlbnQgfHwgJyc7XG4gICAgICAgIHRoaXMuZm9udEZhbWlseSA9ICAgICAgIGNvbmZpZ3MuZm9udEZhbWlseSB8fCAnLWFwcGxlLXN5c3RlbSxCbGlua01hY1N5c3RlbUZvbnQsU2Vnb2UgVUksUm9ib3RvLEhlbHZldGljYSBOZXVlLEhlbHZldGljYSxUYWhvbWEsQXJpYWwsTm90byBTYW5zLFBpbmdGYW5nIFNDLE1pY3Jvc29mdCBZYUhlaSxIaXJhZ2lubyBTYW5zIEdCLHNhbnMtc2VyaWYsQXBwbGUgQ29sb3IgRW1vamksU2Vnb2UgVUkgRW1vamksU2Vnb2UgVUkgU3ltYm9sLE5vdG8gQ29sb3IgRW1vamknXG4gICAgICAgIHRoaXMuZm9udFNpemUgPSAgICAgICAgIGNvbmZpZ3MuZm9udFNpemUgfHwgJzE0cHgnO1xuICAgICAgICB0aGlzLmZvbnRXZWlnaHQgPSAgICAgICBjb25maWdzLmZvbnRXZWlnaHQgfHwgJyc7XG4gICAgICAgIHRoaXMudGV4dENvbG9yID0gICAgICAgIGNvbmZpZ3MudGV4dENvbG9yIHx8ICd3aGl0ZSc7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJDb2xvciA9IGNvbmZpZ3MucGxhY2Vob2xkZXJDb2xvciB8fCAgY29uZmlncy50ZXh0Q29sb3IgfHwgJ3doaXRlJztcbiAgICAgICAgdGhpcy50ZXh0QWxpZ24gPSAgICAgICAgY29uZmlncy50ZXh0QWxpZ24gfHwgVEVYVF9BTElHTi5DRU5URVI7XG4gICAgICAgIHRoaXMudGV4dEJhc2VsaW5lID0gICAgIGNvbmZpZ3MudGV4dEJhc2VsaW5lIHx8ICdtaWRkbGUnO1xuICAgICAgICB0aGlzLmxpbmVIZWlnaHQgPSAgICAgICBjb25maWdzLmxpbmVIZWlnaHQgO1xuICAgICAgICB0aGlzLmluZGVudCA9ICAgICAgICAgICBjb25maWdzLmluZGVudCB8fCAwO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9ICBjb25maWdzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9ICAgICAgICAgY29uZmlncy5lZGl0YWJsZTtcbiAgICAgICAgdGhpcy5kZWZpbmVkV2lkdGggPSAgICAgY29uZmlncy5kZWZpbmVkV2lkdGg7XG4gICAgICAgIHRoaXMubWluV2lkdGggPSAgICAgICAgIGNvbmZpZ3MubWluV2lkdGggfHwgMDtcbiAgICAgICAgdGhpcy5tYXhXaWR0aCA9ICAgICAgICAgY29uZmlncy5tYXhXaWR0aDtcbiAgICAgICAgdGhpcy5lbGxpcHNpcyA9ICAgICAgICAgY29uZmlncy5lbGxpcHNpcztcblxuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gICAgICBjb25maWdzLnBsYWNlaG9sZGVyIHx8ICcnO1xuICAgICAgICB0aGlzLmVtcHR5V2hlbklucHV0ID0gICBjb25maWdzLmVtcHR5V2hlbklucHV0IHx8IGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5lZGl0dGluZyA9ICAgICAgICAgZmFsc2U7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSAgICAgICAgIGNvbmZpZ3MuZGlzYWJsZWQ7XG5cbiAgICAgICAgdGhpcy5jdXJzb3JDb2xvciA9ICAgICAgY29uZmlncy5jdXJzb3JDb2xvciB8fCAnIzYwQ0ZDNCc7XG4gICAgICAgIHRoaXMudGV4dFJhbmdlQ29sb3IgPSAgIGNvbmZpZ3MudGV4dFJhbmdlQ29sb3IgfHwgJyM0RTc1RUMxQSc7XG5cbiAgICAgICAgdGhpcy5zcGFjZVBsYWNlaG9sZGVyID0gY29uZmlncy5zcGFjZVBsYWNlaG9sZGVyO1xuICAgICAgICB0aGlzLnNwYWNlUGxhY2Vob2xkZXJDb2xvciA9IGNvbmZpZ3Muc3BhY2VQbGFjZWhvbGRlckNvbG9yO1xuICAgICAgICB0aGlzLnNwYWNlUmVjb3JkcyA9IFtdO1xuICAgICAgICB0aGlzLl9zcGFjZWRDb250ZW50U2VnbW5lbnQgPSBbXTtcblxuICAgICAgICB0aGlzLl9zdGF0dXMgPSB7XG4gICAgICAgICAgICBlZGl0aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGN1cnNvcnNob3c6IHRydWUsXG4gICAgICAgICAgICBjdXJzb3JhbmltZTogbnVsbCxcbiAgICAgICAgICAgIGxhc3RFbGFwc2VkOiAwLFxuICAgICAgICAgICAgcmVmcmVzaEVsYXBzZWQ6IGZhbHNlLFxuXG4gICAgICAgICAgICBjdXJzb3JEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICBzaGlmdE9uOiBmYWxzZSxcblxuICAgICAgICAgICAgb2xkVmFsOiAnJyxcbiAgICAgICAgICAgIGlucHV0RWxlbWVudDogbnVsbCxcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2N1cnNvck9mZnNldCA9IDA7XG5cbiAgICAgICAgdGhpcy5fdGV4dFJhbmdlID0ge1xuICAgICAgICAgICAgZW5hYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHJhbmdlZnJvbTogbnVsbCwgLy8gb2Zmc2V0ZnJvbVxuICAgICAgICAgICAgcmFuZ2VUbzogbnVsbCwgICAvLyBvZmZzZXR0b1xuICAgICAgICAgICAgaW5pdGlhbFJhbmdlOiBudWxsIC8vIG9mZnNldFxuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuZWRpdGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX21ha2VGdW5jdGlvbmFsKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByZUNhbGN1bGF0ZVRleHQoKTtcbiAgICAgICAgdGhpcy5zaGFkb3dDYWNoZSgpO1xuICAgICAgICBcbiAgICB9XG5cbiAgICByZXBsYWNlU3BhY2VIb2xkZXIoY29udGVudCwgdXNlQ2FjaGUgPSBmYWxzZSkge1xuICAgICAgICBpZih1c2VDYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZSgvXFxzL2csIHRoaXMuc3BhY2VQbGFjZWhvbGRlcilcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLnNwYWNlUmVjb3JkcztcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuc3BhY2VQbGFjZWhvbGRlclxuICAgICAgICByLmxlbmd0aCA9IDA7XG4gICAgICAgIGxldCBsYXN0T2Zmc2V0O1xuICAgICAgICBjb25zdCBjID0gY29udGVudC5yZXBsYWNlKC9cXHMvZywgKF8sIG9mZnNldCkgPT4ge1xuICAgICAgICAgICAgaWYobGFzdE9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICByLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKG9mZnNldCAtIGxhc3RPZmZzZXQgPiAxKSB7XG4gICAgICAgICAgICAgICAgci5wdXNoKGxhc3RPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHIucHVzaChvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSlcbiAgICAgICAgaWYobGFzdE9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByLnB1c2gobGFzdE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuXG4gICAgZ2V0IGN1cnJlbnRDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50IHx8IHRoaXMucGxhY2Vob2xkZXIgfHwgJyc7XG4gICAgfVxuXG4gICAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jb250ZW50O1xuICAgIH1cblxuICAgIHByZUNhbGN1bGF0ZVRleHQoKSB7XG4gICAgICAgIHJlcXVlc3RDYWNoZUNhbnZhcygoY3R4KSA9PiB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguZm9udCA9IGAke3RoaXMuZm9udFdlaWdodH0gJHt0aGlzLmZvbnRTaXplfSAke3RoaXMuZm9udEZhbWlseX1gO1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IHRoaXMudGV4dEFsaWduO1xuICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IHRoaXMudGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgY29uc3QgdF9oID0gcGFyc2VJbnQodGhpcy5mb250U2l6ZSk7XG4gICAgICAgICAgICBsZXQgY29udGVudCA9IHRoaXMuY3VycmVudENvbnRlbnQ7XG4gICAgICAgICAgICBpZih0aGlzLnNwYWNlUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gdGhpcy5yZXBsYWNlU3BhY2VIb2xkZXIoY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcblxuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIC8vIGFjdHVhbEJvdW5kaW5nQm94TGVmdCxcbiAgICAgICAgICAgICAgICAvLyBhY3R1YWxCb3VuZGluZ0JveFJpZ2h0LFxuICAgICAgICAgICAgICAgIGZvbnRCb3VuZGluZ0JveEFzY2VudCxcbiAgICAgICAgICAgICAgICBmb250Qm91bmRpbmdCb3hEZXNjZW50LFxuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgfSA9IGN0eC5tZWFzdXJlVGV4dChjb250ZW50KTtcblxuICAgICAgICAgICAgdGhpcy5fdGV4dFdpZHRoID0gdGhpcy5pbmRlbnQgKyB3aWR0aDtcbiAgICAgICAgICAgIGlmKHRoaXMuZGVmaW5lZFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5lbGxpcHNpcyAmJiAodGhpcy5fdGV4dFdpZHRoID4gdGhpcy5kZWZpbmVkV2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX2NhbGN1bGF0ZU9mZnNldCh0aGlzLmRlZmluZWRXaWR0aCAtIDEyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGxpcHNpc0NvbnRlbnQgPSBjb250ZW50LnN1YnN0cmluZygwLCBvZmZzZXQpICsgJy4uLic7IFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxsaXBzaXNDb250ZW50ID0gY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuZGVmaW5lZFdpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHRoaXMubWF4V2lkdGggJiYgdGhpcy5lbGxpcHNpcykge1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuX3RleHRXaWR0aCA+IHRoaXMubWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF0aW8gPXRoaXMubWF4V2lkdGggLyB0aGlzLl90ZXh0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGwgPSBNYXRoLmZsb29yKGNvbnRlbnQubGVuZ3RoICogcmF0aW8gLSAzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGxpcHNpc0NvbnRlbnQgPSBjb250ZW50LnN1YnN0cmluZygwLCBsKSArICcuLi4nOyBcbiAgICAgICAgICAgICAgICB9ICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGxpcHNpc0NvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gTWF0aC5taW4odGhpcy5tYXhXaWR0aCwgdGhpcy5fdGV4dFdpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZXsgXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IE1hdGgubWF4KHRoaXMubWluV2lkdGgsIHRoaXMuX3RleHRXaWR0aCk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgaWYodGhpcy5zcGFjZVBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogc193aWR0aCxcbiAgICAgICAgICAgICAgICB9ID0gY3R4Lm1lYXN1cmVUZXh0KHRoaXMuc3BhY2VQbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgcjIgPSB0aGlzLl9zcGFjZWRDb250ZW50U2VnbW5lbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dENvbG9yID0gdGhpcy50ZXh0Q29sb3I7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3RPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIHIyLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5zcGFjZVJlY29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLnNwYWNlUmVjb3JkcztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGNvbG9yID0gdGhpcy5zcGFjZVBsYWNlaG9sZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsID0gci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoaSA8IGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGYgPSByW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gcltpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcSA9IGNvbnRlbnQuc3Vic3RyaW5nKGxhc3RPZmZzZXQsIGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcjIucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubWVhc3VyZVRleHQocSkud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHIyLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuc3Vic3RyaW5nKGYsIHQrMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHQgLSBmICsgMSkgKiBzX3dpZHRoLCAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSB0KzFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihsYXN0T2Zmc2V0IDwgY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcSA9IGNvbnRlbnQuc3Vic3RyaW5nKGxhc3RPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByMi5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubWVhc3VyZVRleHQocSkud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IChNYXRoLmFicyhmb250Qm91bmRpbmdCb3hBc2NlbnQpICsgTWF0aC5hYnMoZm9udEJvdW5kaW5nQm94RGVzY2VudCkpIHx8IHRfaDtcbiAgICAgICAgICAgIHRoaXMuX3RleHRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICBpZih0aGlzLmxpbmVIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNoYWRvd0NhY2hlKCkge1xuICAgICAgICBjb25zdCBzY2FsZSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aCAqIHNjYWxlO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQgKiBzY2FsZTtcbiAgICAgICAgY29uc3QgaSA9IHRoaXMuaW5kZW50ICogc2NhbGU7XG4gICAgICAgIGNvbnN0IHNpemUgPSBwYXJzZUludCh0aGlzLmZvbnRTaXplKSAqIHNjYWxlO1xuICAgICAgICB0aGlzLl9zaGFkb3dDYWNoZSA9IG5ldyBTaGFkb3dDYWNoZSh7XG4gICAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICAgIGhlaWdodDogaCxcbiAgICAgICAgICAgIGNhY2hlOiAoY3R4KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgW2N4LCBjeV0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgICAgICAgICAvLyBjdHguc2NhbGUoNCwgNClcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHcvMiwgaC8yKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmb250ID0gYCR7dGhpcy5mb250V2VpZ2h0fSAke3NpemV9cHggJHt0aGlzLmZvbnRGYW1pbHl9YDtcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9IGZvbnRcbiAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gdGhpcy50ZXh0QWxpZ247XG4gICAgICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IHRoaXMudGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmlzRW1wdHkgPyB0aGlzLnBsYWNlaG9sZGVyQ29sb3IgOiB0aGlzLnRleHRDb2xvcjtcbiAgICAgICAgICAgICAgICBsZXQgY29udGVudCA9IHRoaXMuY3VycmVudENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5zcGFjZVBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMudGV4dEFsaWduID09PSBURVhUX0FMSUdOLkxFRlQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGh3ID0gdy8yO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF93ID0gIC1odyArIGkvMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NwYWNlZENvbnRlbnRTZWdtbmVudC5mb3JFYWNoKHNlZyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHNlZ1syXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoc2VnWzBdLCBfdywgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3cgKz0gc2VnWzFdICogc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZWxsaXBzaXNDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gdGhpcy5lbGxpcHNpc0NvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy50ZXh0QWxpZ24gPT09IFRFWFRfQUxJR04uTEVGVCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaHcgPSB3IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoY29udGVudCwgIC1odyArIGkgLyAyLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZih0aGlzLnRleHRBbGlnbiA9PT0gVEVYVF9BTElHTi5SSUdIVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGh3ID0gdyAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGNvbnRlbnQsIGh3LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGNvbnRlbnQsIGkgLyAyLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgfVxuXG4gICAgc2V0Q29uZmlnKGNvbmZpZ3MpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoY29uZmlncykuZm9yRWFjaChrID0+IHtcbiAgICAgICAgICAgIGlmKGNvbmZpZ3Nba10gIT09IHVuZGVmaW5lZCAmJiBjb25maWdzW2tdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trXSA9IGNvbmZpZ3Nba107XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF3Q29uZmlnc1trXSA9IGNvbmZpZ3Nba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByZUNhbGN1bGF0ZVRleHQoKTtcbiAgICAgICAgdGhpcy5zaGFkb3dDYWNoZSgpO1xuICAgIH1cblxuICAgIGNsaWNrKCkge1xuICAgICAgICBpZighdGhpcy5fc3RhdHVzLmVkaXRpbmcpIHtcbiAgICAgICAgICAgIGxldCBmbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnZWRpdCcsIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSkgIFxuICAgICAgICAgICAgaWYoIWZsYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy5fYmVsb25ncy5fY3VycmVudHA7XG4gICAgICAgICAgICBjb25zdCBqZmxvdyA9IHRoaXMuX2pmbG93OyBcbiAgICAgICAgICAgIGlmKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yT2Zmc2V0ID0gdGhpcy5fcG9zaXRpb25Ub0N1cnNvck9mZnNldChwb2ludCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvck9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGlucHV0RWxlbWVudCA9IGNyZWF0ZUlucHV0RWxlbWVudChcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250cm9sQ2FsbGJhY2suYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWZhdWx0Q2FsbGJhY2suYmluZCh0aGlzKSk7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVyID0gamZsb3cuRE9Nd3JhcHBlcjtcbiAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kKGlucHV0RWxlbWVudCk7ICBcbiAgICAgICAgICAgIGlucHV0RWxlbWVudC5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7ICAgICAgXG4gICAgICAgICAgICBqZmxvdy5zZXRGb2N1c0luc3RhbmNlKHRoaXMpO1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3N0YXR1cywge1xuICAgICAgICAgICAgICAgIGVkaXRpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgb2xkVmFsOiB0aGlzLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgaW5wdXRFbGVtZW50LFxuICAgICAgICAgICAgICAgIGN1cnNvcmFuaW1lOiBqZmxvdy5yZXF1ZXN0SkZsb3dBbmltZSgoZWxhcHNlZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0RWxhcHNlZCA9IHRoaXMuX3N0YXR1cy5sYXN0RWxhcHNlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5fc3RhdHVzLnJlZnJlc2hFbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMubGFzdEVsYXBzZWQgPSBlbGFwc2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzLnJlZnJlc2hFbGFwc2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoZWxhcHNlZCAtIGxhc3RFbGFwc2VkID4gNTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMuY3Vyc29yc2hvdyA9ICF0aGlzLl9zdGF0dXMuY3Vyc29yc2hvdztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5sYXN0RWxhcHNlZCA9IGVsYXBzZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYodGhpcy5lbXB0eVdoZW5JbnB1dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zeW5jU2hhZG93SW5wdXRQb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX21ha2VGdW5jdGlvbmFsKCkge1xuICAgICAgICBjb25zdCBibHVySGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc3RhdHVzLmVkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmKHRoaXMuX3N0YXR1cy5pbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMuaW5wdXRFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5fYmVsb25ncykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2pmbG93LnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICB9IFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZihldmVudC5jdXJyZW50VGFyZ2V0ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLl9zdGF0dXMuZWRpdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdEZ1bGxSYW5nZSgpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmKGV2ZW50LmN1cnJlbnRUYXJnZXQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGV2ZW50LmRldGFpbC5idWJibGVzID0gZmFsc2U7XG4gICAgICAgICAgICBpZih0aGlzLl9zdGF0dXMuZWRpdGluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy5fYmVsb25ncy5fY3VycmVudHA7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fcG9zaXRpb25Ub0N1cnNvck9mZnNldChwb2ludCk7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5fc3RhdHVzLnNoaWZ0T24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbFJhbmdlID0gdGhpcy5fdGV4dFJhbmdlLmluaXRpYWxSYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl90ZXh0UmFuZ2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlZnJvbTogTWF0aC5taW4ob2Zmc2V0LCBpbml0aWFsUmFuZ2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VUbzogTWF0aC5tYXgob2Zmc2V0LCBpbml0aWFsUmFuZ2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yT2Zmc2V0ID0gdGhpcy5fdGV4dFJhbmdlLnJhbmdlVG87XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5pbnB1dEVsZW1lbnQuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLl9yZWZyZXNoQ3Vyc29yKCk7ICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3JPZmZzZXQgPSBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzLmlucHV0RWxlbWVudC5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hDdXJzb3IoKTsgIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bmNTaGFkb3dJbnB1dFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIHRoaXMuY2xpY2soKTtcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBibHVySGFuZGxlcihldmVudCk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2NoYW5nZScsIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgb2xkVmFsOiB0aGlzLl9zdGF0dXMub2xkVmFsLFxuICAgICAgICAgICAgICAgIHZhbDogdGhpcy5jb250ZW50LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5fdGV4dFJhbmdlLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fc3RhdHVzLmN1cnNvcmFuaW1lPy5jYW5jZWwoKVxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9zdGF0dXMsIHtcbiAgICAgICAgICAgICAgICBlZGl0aW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjdXJzb3JzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgIGN1cnNvcmFuaW1lOiBudWxsLFxuICAgICAgICAgICAgICAgIGxhc3RFbGFwc2VkOiAwLFxuICAgICAgICAgICAgICAgIHJlZnJlc2hFbGFwc2VkOiBmYWxzZSxcblxuICAgICAgICAgICAgICAgIGN1cnNvckRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaGlmdE9uOiBmYWxzZSxcblxuICAgICAgICAgICAgICAgIG9sZFZhbDogJycsXG4gICAgICAgICAgICAgICAgaW5wdXRFbGVtZW50OiBudWxsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdpbnN0YW5jZVByZXNzU3RhcnQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmKHRoaXMuX3N0YXR1cy5lZGl0aW5nICYmICF0aGlzLl9zdGF0dXMuc2hpZnRPbikge1xuICAgICAgICAgICAgICAgIGV2ZW50LmRldGFpbC5idWJibGVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZXZlbnQuZGV0YWlsLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLl9iZWxvbmdzLl9jdXJyZW50cDtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gdGhpcy5fcG9zaXRpb25Ub0N1cnNvck9mZnNldChwb2ludCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0UmFuZ2UuaW5pdGlhbFJhbmdlID0gYztcbiAgICAgICAgICAgICAgICBjb25zdCBqZmxvdyA9IGV2ZW50LmRldGFpbC5qZmxvdztcbiAgICAgICAgICAgICAgICBsZXQgbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gKGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IGpmbG93Ll9jYWxjdWxhdGVQb2ludEJhY2soW29mZnNldFgsIG9mZnNldFldKTtcbiAgICAgICAgICAgICAgICAgICAgamZsb3cuX3N0YWNrLmNoZWNrSGl0KHApXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy5fYmVsb25ncy5fY3VycmVudHA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGMgPSB0aGlzLl9wb3NpdGlvblRvQ3Vyc29yT2Zmc2V0KHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbFJhbmdlID0gdGhpcy5fdGV4dFJhbmdlLmluaXRpYWxSYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzLmVkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl90ZXh0UmFuZ2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlZnJvbTogTWF0aC5taW4oYywgaW5pdGlhbFJhbmdlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlVG86IE1hdGgubWF4KGMsIGluaXRpYWxSYW5nZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHQpXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYoIW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0UmFuZ2UuaW5pdGlhbFJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByYW5nZVRvID0gdGhpcy5fdGV4dFJhbmdlLnJhbmdlVG87XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvck9mZnNldCA9IHJhbmdlVG87XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5lZGl0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzLmlucHV0RWxlbWVudC5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7ICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHRSYW5nZS5pbml0aWFsUmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfcG9zaXRpb25Ub0N1cnNvck9mZnNldChwb2ludCkge1xuICAgICAgICBjb25zdCBbeF0gPSBwb2ludDtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGgvMjtcbiAgICAgICAgY29uc3QgW294XSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCBvZmZzZXRYID0geCAtIChveCAtIHcpO1xuICAgICAgICBsZXQgY3Vyc29yT2Zmc2V0ID0gMDtcbiAgICAgICAgaWYob2Zmc2V0WCA+PSB0aGlzLl90ZXh0V2lkdGgpIHtcbiAgICAgICAgICAgIGN1cnNvck9mZnNldCA9IHRoaXMuY29udGVudC5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJzb3JPZmZzZXQgPSB0aGlzLl9jYWxjdWxhdGVPZmZzZXQob2Zmc2V0WCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3Vyc29yT2Zmc2V0O1xuICAgIH1cblxuICAgIF9jYWxjdWxhdGVPZmZzZXQob2ZmeCkge1xuICAgICAgICBsZXQgY29udGVudCA9IHRoaXMuY29udGVudDtcbiAgICAgICAgaWYodGhpcy5zcGFjZVBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gdGhpcy5yZXBsYWNlU3BhY2VIb2xkZXIoY29udGVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF4TCA9IGNvbnRlbnQubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgY29udGVudFdpZHRoID0gdGhpcy5fdGV4dFdpZHRoO1xuICAgICAgICBpZihjb250ZW50V2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsbHdpZHRoID0gY29udGVudFdpZHRoO1xuICAgICAgICBsZXQgaWR4ID0gTWF0aC5mbG9vcihvZmZ4IC8gYWxsd2lkdGggKiBtYXhMKSA7XG4gICAgICAgIHJlcXVlc3RDYWNoZUNhbnZhcygoY3R4KSA9PiB7XG4gICAgICAgICAgICBjdHguZm9udCA9IGAke3RoaXMuZm9udFNpemV9ICR7dGhpcy5mb250RmFtaWx5fWA7XG4gICAgICAgICAgICBsZXQgZzEsIGcyO1xuICAgICAgICAgICAgbGV0IGxhc3RpZHg7XG5cbiAgICAgICAgICAgIGxldCBjID0gY29udGVudC5zdWJzdHJpbmcoMCwgaWR4KTtcbiAgICAgICAgICAgIGxldCBjMSA9IGNvbnRlbnQuc3Vic3RyaW5nKGlkeC0xLCBpZHgpO1xuICAgICAgICAgICAgbGV0IGMyID0gY29udGVudC5zdWJzdHJpbmcoaWR4LCBpZHgrMSk7XG4gICAgICAgICAgICBsZXQgdyA9IGN0eC5tZWFzdXJlVGV4dChjKS53aWR0aDtcbiAgICAgICAgICAgIGxldCB3MSA9IGN0eC5tZWFzdXJlVGV4dChjMSkud2lkdGg7XG4gICAgICAgICAgICBsZXQgdzIgPSBjdHgubWVhc3VyZVRleHQoYzIpLndpZHRoO1xuICAgICAgICAgICAgZzEgPSB3IC0gdzEvMjtcbiAgICAgICAgICAgIGcyID0gdyArIHcyLzI7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZihnMSA8PSBvZmZ4ICYmIGcyID49IG9mZngpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSAgXG4gICAgICAgICAgICAgICAgaWYoZzEgPiBvZmZ4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOW3puS+p+WwkeS6hlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGFudyA9IGcyIC0gb2ZmeDtcbiAgICAgICAgICAgICAgICAgICAgbGFzdGlkeCA9IGlkeDtcbiAgICAgICAgICAgICAgICAgICAgaWYoc3BhbncgPCAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWR4IC09IE1hdGguZmxvb3Ioc3BhbncgLyBnMiAqIGxhc3RpZHgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYyA9IGNvbnRlbnQuc3Vic3RyaW5nKGlkeCwgbGFzdGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIHcgLT0gY3R4Lm1lYXN1cmVUZXh0KGMpLndpZHRoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihnMiA8IG9mZngpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5Y+z5L6n5bCR5LqGXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwYW53ID0gb2ZmeCAtIGcxO1xuICAgICAgICAgICAgICAgICAgICBsYXN0aWR4ID0gaWR4O1xuICAgICAgICAgICAgICAgICAgICBpZihzcGFudyA8IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHggKz0gTWF0aC5mbG9vcihzcGFudyAvIChhbGx3aWR0aCAtIGcxKSAqIChtYXhMIC0gbGFzdGlkeCkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYyA9IGNvbnRlbnQuc3Vic3RyaW5nKGxhc3RpZHgsIGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIHcgKz0gY3R4Lm1lYXN1cmVUZXh0KGMpLndpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjMSA9IGNvbnRlbnQuc3Vic3RyaW5nKGlkeC0xLCBpZHgpO1xuICAgICAgICAgICAgICAgIGMyID0gY29udGVudC5zdWJzdHJpbmcoaWR4LCBpZHgrMSk7XG4gICAgICAgICAgICAgICAgdzEgPSBjdHgubWVhc3VyZVRleHQoYzEpLndpZHRoO1xuICAgICAgICAgICAgICAgIHcyID0gY3R4Lm1lYXN1cmVUZXh0KGMyKS53aWR0aDtcbiAgICAgICAgICAgICAgICBnMSA9IHcgLSB3MS8yO1xuICAgICAgICAgICAgICAgIGcyID0gdyArIHcyLzI7XG4gICAgICAgICAgICB9IHdoaWxlKGlkeCA+PSAwICYmIGlkeCA8PSBtYXhMKVxuICAgICAgICAgICAgXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaWR4O1xuICAgIH1cblxuICAgIF9yZWZyZXNoQ3Vyc29yKCkge1xuICAgICAgICBpZih0aGlzLl9zdGF0dXMuZWRpdGluZykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9zdGF0dXMsIHtcbiAgICAgICAgICAgICAgICBjdXJzb3JzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgIHJlZnJlc2hFbGFwc2VkOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5fdGV4dFJhbmdlLmVuYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fdGV4dFJhbmdlLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKGN0eCkge1xuICAgICAgICBpZih0aGlzLl9pc01vdmluZyl7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjZcbiAgICAgICAgfVxuICAgICAgICBpZighY3R4LmRpc2FibGVDYWNoZSAmJiAhdGhpcy5fc3RhdHVzLmVkaXRpbmcgJiYgdGhpcy5famZsb3cuc2NhbGUgKiBwYXJzZUludCh0aGlzLmZvbnRTaXplKSA8IDgpIHtcbiAgICAgICAgICAgIGNvbnN0IFtjeCwgY3ldID0gdGhpcy5hbmNob3I7XG4gICAgICAgICAgICAvLyB0aGlzLl9zaGFkb3dDYWNoZS5yZW5kZXIoY3R4KTtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuX3NoYWRvd0NhY2hlLmltYWdlQnVmZmVyLCAtdGhpcy53aWR0aC8yLCAtdGhpcy5oZWlnaHQvMiwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZm9udCA9IGAke3RoaXMuZm9udFdlaWdodH0gJHt0aGlzLmZvbnRTaXplfSAke3RoaXMuZm9udEZhbWlseX1gO1xuICAgICAgICBpZihjdHguZm9udCAhPT0gZm9udCkge1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBmb250XG4gICAgICAgIH1cblxuICAgICAgICBpZihjdHgudGV4dEFsaWduICE9PSB0aGlzLnRleHRBbGlnbikge1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IHRoaXMudGV4dEFsaWduO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoY3R4LnRleHRCYXNlbGluZSAhPT0gdGhpcy50ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSB0aGlzLnRleHRCYXNlbGluZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmlzRW1wdHkgPyB0aGlzLnBsYWNlaG9sZGVyQ29sb3IgOiB0aGlzLnRleHRDb2xvcjtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLmN1cnJlbnRDb250ZW50O1xuICAgICAgICBpZih0aGlzLnNwYWNlUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIGlmKHRoaXMudGV4dEFsaWduID09PSBURVhUX0FMSUdOLkxFRlQpe1xuICAgICAgICAgICAgICAgIGNvbnN0IGh3ID0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgbGV0IHcgPSB0aGlzLmFuY2hvclswXSAtIGh3ICsgdGhpcy5pbmRlbnQgLyAyO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLmFuY2hvclsxXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGFjZWRDb250ZW50U2VnbW5lbnQuZm9yRWFjaChzZWcgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gc2VnWzJdO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoc2VnWzBdLCB3LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdyArPSBzZWdbMV07XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZih0aGlzLmVsbGlwc2lzQ29udGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLmVsbGlwc2lzQ29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnRleHRBbGlnbiA9PT0gVEVYVF9BTElHTi5MRUZUKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaHcgPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGNvbnRlbnQsIHRoaXMuYW5jaG9yWzBdIC0gaHcgKyB0aGlzLmluZGVudCAvIDIsIHRoaXMuYW5jaG9yWzFdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYodGhpcy50ZXh0QWxpZ24gPT09IFRFWFRfQUxJR04uUklHSFQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaHcgPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGNvbnRlbnQsIHRoaXMuYW5jaG9yWzBdICsgaHcsIHRoaXMuYW5jaG9yWzFdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoY29udGVudCwgdGhpcy5hbmNob3JbMF0gKyB0aGlzLmluZGVudCAvIDIsIHRoaXMuYW5jaG9yWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIGNvbnN0IGh3ID0gdGhpcy53aWR0aC8yO1xuICAgICAgICBjb25zdCB0ZXh0aGVpZ2h0ID0gdGhpcy5fdGV4dEhlaWdodFxuICAgICAgICBjb25zdCBbeCwgeV0gPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgY29uc3QgbHggPSB4IC0gaHc7XG4gICAgICAgIGNvbnN0IGx5ID0geSAtIHRleHRoZWlnaHQvMjtcblxuICAgICAgICBpZih0aGlzLl9zdGF0dXMuY3Vyc29yc2hvdyAmJiB0aGlzLl9zdGF0dXMuZWRpdGluZykge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fY3Vyc29yT2Zmc2V0O1xuICAgICAgICAgICAgbGV0IGMgPSBjb250ZW50LnN1YnN0cmluZygwLCBvZmZzZXQpO1xuICAgICAgICAgICAgaWYodGhpcy5zcGFjZVBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgYyA9IHRoaXMucmVwbGFjZVNwYWNlSG9sZGVyKGMsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3cgPSBseCArIGN0eC5tZWFzdXJlVGV4dChjKS53aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGNfbGVuID0gdGhpcy5fdGV4dEhlaWdodC8yO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhjdywgeSAtIGNfbGVuKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oY3csIHkgKyBjX2xlbik7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY3Vyc29yQ29sb3I7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLl90ZXh0UmFuZ2UuZW5hYmxlKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgcmFuZ2Vmcm9tLCByYW5nZVRvXG4gICAgICAgICAgICB9ID0gdGhpcy5fdGV4dFJhbmdlO1xuICAgICAgICAgICAgY29uc3QgYyA9IHRoaXMuY29udGVudC5zdWJzdHJpbmcoMCwgcmFuZ2Vmcm9tKTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5jb250ZW50LnN1YnN0cmluZyhyYW5nZWZyb20sIHJhbmdlVG8pXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHggPSBseCArIGN0eC5tZWFzdXJlVGV4dChjKS53aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IHcgPSBjdHgubWVhc3VyZVRleHQocmFuZ2UpLndpZHRoO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnJlY3QoeCwgbHksIHcsIHRleHRoZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMudGV4dFJhbmdlQ29sb3JcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH0gXG4gICAgfVxuXG4gICAgX2lucHV0Q29udHJvbChvcCwgZGF0YSkge1xuICAgICAgICBpZih0aGlzLl90ZXh0UmFuZ2UuZW5hYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclRleHRSYW5nZSgpO1xuICAgICAgICAgICAgaWYob3AgPT09ICdCYWNrc3BhY2UnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdpbnB1dCcsIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBvbGRWYWw6IHRoaXMuX3N0YXR1cy5vbGRWYWwsXG4gICAgICAgICAgICAgICAgICAgIHZhbDogdGhpcy5jb250ZW50LFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmNTaGFkb3dJbnB1dFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX2N1cnNvck9mZnNldDtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuY29udGVudDtcbiAgICAgICAgbGV0IHByZUNvbnRlbnQgPSBjb250ZW50LnN1YnN0cmluZygwLCBvZmZzZXQpO1xuICAgICAgICBsZXQgYWZ0ZXJDb250ZW50IFxuICAgICAgICBpZih0aGlzLmNhY2hlSWR4KSB7XG4gICAgICAgICAgICBhZnRlckNvbnRlbnQgPSBjb250ZW50LnN1YnN0cmluZyh0aGlzLmNhY2hlSWR4WzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFmdGVyQ29udGVudCA9IGNvbnRlbnQuc3Vic3RyaW5nKG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0b3BJbnB1dEV2ZW50ID0gZmFsc2U7XG4gICAgICAgIHN3aXRjaChvcCl7XG4gICAgICAgICAgICBjYXNlIFwiSW5wdXRcIjpcbiAgICAgICAgICAgICAgICBwcmVDb250ZW50ICs9IGRhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yT2Zmc2V0ICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudCA9IHByZUNvbnRlbnQgKyBhZnRlckNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY29tcG9zaXRpb25zdGFydFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVJZHggPSBbcHJlQ29udGVudC5sZW5ndGgsIHByZUNvbnRlbnQubGVuZ3RoXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjb21wb3NpdGlvbnVwZGF0ZVwiOlxuICAgICAgICAgICAgICAgIHByZUNvbnRlbnQgPSBwcmVDb250ZW50LnN1YnN0cmluZygwLCB0aGlzLmNhY2hlSWR4WzBdKTtcbiAgICAgICAgICAgICAgICBwcmVDb250ZW50ICs9IGRhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50ID0gcHJlQ29udGVudCArIGFmdGVyQ29udGVudDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvck9mZnNldCA9IHRoaXMuY2FjaGVJZHhbMF0gKyBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlSWR4WzFdID0gdGhpcy5jYWNoZUlkeFswXSArIGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNvbXBvc2l0aW9uZW5kXCI6XG4gICAgICAgICAgICAgICAgcHJlQ29udGVudCA9IHByZUNvbnRlbnQuc3Vic3RyaW5nKDAsIHRoaXMuY2FjaGVJZHhbMF0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvck9mZnNldCA9IHRoaXMuY2FjaGVJZHhbMF0gKyBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlSWR4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwcmVDb250ZW50ICs9IGRhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50ID0gcHJlQ29udGVudCArIGFmdGVyQ29udGVudDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJFbnRlclwiOlxuICAgICAgICAgICAgICAgIGlmKHRoaXMuY2FjaGVJZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZGVmYXVsdEFjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdlbnRlcmtleXByZXNzZWQnLCB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcjogKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEFjdCA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcElucHV0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcElucHV0RXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgaWYoZGVmYXVsdEFjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9qZmxvdy5ibHVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQmFja3NwYWNlXCI6XG4gICAgICAgICAgICAgICAgaWYodGhpcy5jYWNoZUlkeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZUNvbnRlbnQgPSBwcmVDb250ZW50LnN1YnN0cmluZygwLCBwcmVDb250ZW50Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvck9mZnNldCA9IE1hdGgubWF4KDAsIHRoaXMuX2N1cnNvck9mZnNldC0xKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSBwcmVDb250ZW50ICsgYWZ0ZXJDb250ZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICBpZighc3RvcElucHV0RXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnaW5wdXQnLCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICAgIG9sZFZhbDogdGhpcy5fc3RhdHVzLm9sZFZhbCxcbiAgICAgICAgICAgICAgICB2YWw6IHRoaXMuY29udGVudCxcbiAgICAgICAgICAgIH0pKTtcbiAgICBcbiAgICAgICAgfVxuICAgICAgIFxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgdGhpcy5zeW5jU2hhZG93SW5wdXRQb3NpdGlvbigpO1xuICAgIH1cblxuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIHRoaXMucHJlQ2FsY3VsYXRlVGV4dCgpO1xuICAgICAgICB0aGlzLl9iZWxvbmdzLnJlY2FsY3VsYXRlVXAoKTtcbiAgICAgICAgdGhpcy5famZsb3cuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICB9XG5cbiAgICBzeW5jU2hhZG93SW5wdXRQb3NpdGlvbigpIHtcbiAgICAgICAgaWYodGhpcy5fc3RhdHVzLmVkaXRpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGh3ID0gdGhpcy53aWR0aC8yO1xuICAgICAgICAgICAgY29uc3QgaGggPSB0aGlzLmhlaWdodC8yO1xuICAgICAgICAgICAgbGV0IGx4ID0gdGhpcy5hbmNob3JbMF0gLSBodztcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX2N1cnNvck9mZnNldDtcblxuICAgICAgICAgICAgcmVxdWVzdENhY2hlQ2FudmFzKChjdHgpID0+IHtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSBgJHt0aGlzLmZvbnRTaXplfSAke3RoaXMuZm9udEZhbWlseX1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSB0aGlzLmNvbnRlbnQuc3Vic3RyaW5nKDAsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgbHggKz0gY3R4Lm1lYXN1cmVUZXh0KGMpLndpZHRoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMuY2FsY3VsYXRlVG9SZWFsV29ybGQoW2x4LCBoaF0pO1xuICAgICAgICAgICAgY29uc3QgY2FudmFzTWV0YSA9IHRoaXMuX2pmbG93LmNhbnZhc01ldGE7XG4gICAgICAgICAgICBjb25zdCBweCA9IE1hdGgubWluKGNhbnZhc01ldGEuYWN0dWFsX3dpZHRoIC0gMTIwLCBwb2ludFswXSk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMuaW5wdXRFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtweH1weCwgJHtwb2ludFsxXX1weClgXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY29udHJvbENhbGxiYWNrKG9wLCBkYXRhLCBlKSB7XG4gICAgICAgIGlmKHRoaXMuX3N0YXR1cy5lZGl0aW5nKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3N0YXR1cywge1xuICAgICAgICAgICAgICAgIGN1cnNvcnNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgcmVmcmVzaEVsYXBzZWQ6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2gob3Ape1xuICAgICAgICAgICAgY2FzZSBcIklucHV0XCI6XG4gICAgICAgICAgICBjYXNlIFwiY29tcG9zaXRpb25zdGFydFwiOlxuICAgICAgICAgICAgY2FzZSBcImNvbXBvc2l0aW9udXBkYXRlXCI6XG4gICAgICAgICAgICBjYXNlIFwiY29tcG9zaXRpb25lbmRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJFbnRlclwiOlxuICAgICAgICAgICAgY2FzZSBcIkJhY2tzcGFjZVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX2lucHV0Q29udHJvbChvcCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6XG4gICAgICAgICAgICAgICAgaWYodGhpcy5fdGV4dFJhbmdlLmVuYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0UmFuZ2UuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX29uQXJyb3dMZWZ0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOlxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX3RleHRSYW5nZS5lbmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dFJhbmdlLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9vbkFycm93UmlnaHQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTaGlmdFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX29uU2hpZnRUb2dnbGUoZGF0YSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJDdHJsQVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdEZ1bGxSYW5nZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkNPUFlcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9jb3B5KGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkNVVFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX2N1dChlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJQQVNURVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX3Bhc3RlKGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBfb25BcnJvd0xlZnQoKSB7XG4gICAgICAgIHRoaXMuX2N1cnNvck9mZnNldCA9IE1hdGgubWF4KDAsIHRoaXMuX2N1cnNvck9mZnNldCAtIDEpO1xuICAgICAgICB0aGlzLl9qZmxvdy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICB0aGlzLnN5bmNTaGFkb3dJbnB1dFBvc2l0aW9uKCk7XG4gICAgfVxuXG4gICAgX29uQXJyb3dSaWdodCgpIHtcbiAgICAgICAgdGhpcy5fY3Vyc29yT2Zmc2V0ID0gTWF0aC5taW4odGhpcy5jb250ZW50Lmxlbmd0aCwgdGhpcy5fY3Vyc29yT2Zmc2V0ICsgMSk7XG4gICAgICAgIHRoaXMuX2pmbG93LnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgIHRoaXMuc3luY1NoYWRvd0lucHV0UG9zaXRpb24oKTtcbiAgICB9ICAgIFxuXG4gICAgX29uU2hpZnRUb2dnbGUodmFsKSB7XG4gICAgICAgIHRoaXMuX3N0YXR1cy5zaGlmdE9uID0gdmFsO1xuICAgICAgICBpZih2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHRSYW5nZS5pbml0aWFsUmFuZ2UgPSB0aGlzLl9jdXJzb3JPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0UmFuZ2UuaW5pdGlhbFJhbmdlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zZWxlY3RGdWxsUmFuZ2UoKSB7XG4gICAgICAgIHRoaXMuX3RleHRSYW5nZSA9IHtcbiAgICAgICAgICAgIGVuYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHJhbmdlZnJvbTogMCxcbiAgICAgICAgICAgIHJhbmdlVG86IHRoaXMuY29udGVudC5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJzb3JPZmZzZXQgPSB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICAgIH1cblxuICAgIF9jbGVhclRleHRSYW5nZSgpIHtcbiAgICAgICAgaWYodGhpcy5fdGV4dFJhbmdlLmVuYWJsZSkge1xuICAgICAgICAgICAgY29uc3QgeyByYW5nZWZyb20sIHJhbmdlVG8gfSA9IHRoaXMuX3RleHRSYW5nZTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQ7XG4gICAgICAgICAgICBjb25zdCBwcmVDb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcoMCwgcmFuZ2Vmcm9tKTtcbiAgICAgICAgICAgIGNvbnN0IGFmdGVyQ29udGVudCA9IGNvbnRlbnQuc3Vic3RyaW5nKHJhbmdlVG8pO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50ID0gcHJlQ29udGVudCArIGFmdGVyQ29udGVudDtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvck9mZnNldCA9IHByZUNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fdGV4dFJhbmdlLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldFNlbGVjdGlvbigpIHtcbiAgICAgICAgaWYodGhpcy5fdGV4dFJhbmdlLmVuYWJsZSkge1xuICAgICAgICAgICAgY29uc3QgeyByYW5nZWZyb20sIHJhbmdlVG8gfSA9IHRoaXMuX3RleHRSYW5nZTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQ7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudC5zdWJzdHJpbmcocmFuZ2Vmcm9tLCByYW5nZVRvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBfY29weShldmVudCkge1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLl9nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBldmVudC5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHNlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2N1dChldmVudCkge1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLl9nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBldmVudC5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHNlbGVjdGlvbik7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclRleHRSYW5nZSgpO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3Bhc3RlKGV2ZW50KSB7XG4gICAgICAgIGxldCBwYXN0ZUNvbnRlbnQgPSAoZXZlbnQuY2xpcGJvYXJkRGF0YSB8fCB3aW5kb3cuY2xpcGJvYXJkRGF0YSkuZ2V0RGF0YShcInRleHRcIik7XG4gICAgICAgIGxldCBmbGFnID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgncGFzdGUnLCB7XG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICBjb250ZW50OiBwYXN0ZUNvbnRlbnQsXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNvbHZlUGFzdGVDb250ZW50KGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcGFzdGVDb250ZW50ID0gY2FsbGJhY2socGFzdGVDb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBpZihmbGFnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xlYXJUZXh0UmFuZ2UoKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fY3Vyc29yT2Zmc2V0O1xuICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5jb250ZW50O1xuICAgICAgICBjb25zdCBwcmVDb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcoMCwgb2Zmc2V0KTtcbiAgICAgICAgY29uc3QgYWZ0ZXJDb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcob2Zmc2V0KTtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gcHJlQ29udGVudCArIHBhc3RlQ29udGVudCArIGFmdGVyQ29udGVudDtcbiAgICAgICAgdGhpcy5fY3Vyc29yT2Zmc2V0ID0gKHByZUNvbnRlbnQgKyBwYXN0ZUNvbnRlbnQpLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgfVxuICAgIF9kZWZhdWx0Q2FsbGJhY2sob3AsIGUpIHtcbiAgICAgICAgc3dpdGNoKG9wKXtcbiAgICAgICAgICAgIGNhc2UgJ0tleURvd24nOiBcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2tleWRvd24nLCB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBlLmtleSxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogZS5jb2RlLFxuICAgICAgICAgICAgICAgICAgICByYXdFdmVudDogZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdLZXlVcCc6IFxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgna2V5dXAnLCB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBlLmtleSxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogZS5jb2RlLFxuICAgICAgICAgICAgICAgICAgICByYXdFdmVudDogZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYodGhpcy5famZsb3cuX2ZvY3VzLmluc3RhbmNlID09PSB0aGlzKSB7XG4gICAgICAgICAgICB0aGlzLl9qZmxvdy5ibHVyKCk7XG4gICAgICAgIH1cbiAgICB9XG59ICAgICAgIFxuXG5leHBvcnQgZGVmYXVsdCBUZXh0O1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0RWxlbWVudChjb250cm9sQ2FsbGJhY2ssIGRlZmF1bHRDYWxsYmFjaykge1xuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJyxgXG4gICAgICAgIHdpZHRoOiAxMDBweDtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGJvcmRlcjpub25lO1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICB6LWluZGV4OiAtMTtcbiAgICAgICAgY29udGFpbjogc3RyaWN0O2ApO1xuICAgIGlucHV0LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAtMSk7XG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKCdzcGVsbGNoZWNrJywgZmFsc2UpO1xuICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnYXV0b2NvcnJlY3QnLCAnb2ZmJyk7XG5cblxuICAgIC8vIGxldCBjb250ZW50ID0gY29uZmlncy5jb250ZW50O1xuICAgIC8vIGxldCBzdGFydGlkeCA9IDA7XG5cbiAgICAvLyBmdW5jdGlvbiByZW5kZXJDb250ZW50KCkge1xuICAgIC8vICAgICBjb25maWdzLmNhbGxiYWNrKGNvbnRlbnQpXG4gICAgLy8gfVxuICAgIGxldCBzdG9wSW5wdXQgPSBmYWxzZTtcbiAgICBsZXQgc3RhdHVzID0ge1xuICAgICAgICBjdHJsT246IGZhbHNlLFxuICAgIH1cblxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZWlucHV0JywgZSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYoZS5kYXRhKSB7XG4gICAgICAgICAgICAvLyBjb250ZW50ICs9IGUuZGF0YTtcbiAgICAgICAgICAgIC8vIHJlbmRlckNvbnRlbnQoKTtcbiAgICAgICAgICAgIGlmKCFzdG9wSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soJ0lucHV0JywgZS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0JywgKGUpID0+IHtcbiAgICAgICAgLy8gY2FjaGUgY29tcG9zaXRpb24gc3RhcnQgb2Zmc2V0XG4gICAgICAgIC8vIHN0YXJ0aWR4ID0gY29udGVudC5sZW5ndGg7XG4gICAgICAgIGNvbnRyb2xDYWxsYmFjaygnY29tcG9zaXRpb25zdGFydCcpO1xuICAgICAgICBzdG9wSW5wdXQgPSB0cnVlO1xuICAgIH0pO1xuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9udXBkYXRlJywgKGUpID0+IHtcbiAgICAgICAgLy8gdXBkYXRlIGNvbnRlbnRcbiAgICAgICAgLy8gY29udGVudCA9IGNvbnRlbnQuc3Vic3RyaW5nKDAsIHN0YXJ0aWR4KTtcbiAgICAgICAgLy8gY29udGVudCArPSBlLmRhdGE7XG4gICAgICAgIC8vIHJlbmRlckNvbnRlbnQoKTtcbiAgICAgICAgY29udHJvbENhbGxiYWNrKCdjb21wb3NpdGlvbnVwZGF0ZScsIGUuZGF0YSk7XG4gICAgfSk7XG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCAoZSkgPT4ge1xuICAgICAgICAvLyByZXBsYWNlIHRleHQgYXQgc3RhcnQgb2Zmc2V0XG4gICAgICAgIC8vIGNvbnRlbnQgPSBjb250ZW50LnN1YnN0cmluZygwLCBzdGFydGlkeCk7XG4gICAgICAgIC8vIHN0YXJ0aWR4ID0gMDtcbiAgICAgICAgLy8gY29udGVudCArPSBlLmRhdGE7XG4gICAgICAgIC8vIHJlbmRlckNvbnRlbnQoKTtcbiAgICAgICAgY29udHJvbENhbGxiYWNrKCdjb21wb3NpdGlvbmVuZCcsIGUuZGF0YSk7XG4gICAgICAgIGlucHV0LnZhbHVlID0gJyc7XG4gICAgICAgIHN0b3BJbnB1dCA9IGZhbHNlXG4gICAgfSk7XG5cbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIChldmVudCkgPT4ge1xuICAgICAgICBzd2l0Y2goZXZlbnQua2V5KSB7XG4gICAgICAgICAgICBjYXNlIFwiU2hpZnRcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soXCJTaGlmdFwiLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiTWV0YVwiOlxuICAgICAgICAgICAgY2FzZSBcIkNvbnRyb2xcIjpcbiAgICAgICAgICAgICAgICBzdGF0dXMuY3RybE9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChldmVudCkgPT4ge1xuICAgICAgICBzd2l0Y2goZXZlbnQuY29kZSkge1xuICAgICAgICAgICAgY2FzZSBcIkVudGVyXCI6XG4gICAgICAgICAgICAgICAgLy8gY29udGVudCA9IGNvbnRlbnQgKyAnXFxuJztcbiAgICAgICAgICAgICAgICAvLyByZW5kZXJDb250ZW50KCk7XG4gICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKCdFbnRlcicpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkJhY2tzcGFjZVwiOlxuICAgICAgICAgICAgICAgIC8vIGNvbnRlbnQgPSBjb250ZW50LnN1YnN0cmluZygwLCBjb250ZW50Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIC8vIHJlbmRlckNvbnRlbnQoKTtcbiAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soJ0JhY2tzcGFjZScpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkFycm93TGVmdFwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjayhcIkFycm93TGVmdFwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6XG4gICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKFwiQXJyb3dSaWdodFwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjpcbiAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soXCJBcnJvd0Rvd25cIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQXJyb3dVcFwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjayhcIkFycm93VXBcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKGV2ZW50LmtleSkge1xuICAgICAgICAgICAgY2FzZSBcIlNoaWZ0XCI6XG4gICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKFwiU2hpZnRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiTWV0YVwiOlxuICAgICAgICAgICAgY2FzZSBcIkNvbnRyb2xcIjpcbiAgICAgICAgICAgICAgICBzdGF0dXMuY3RybE9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgIGlmKHN0YXR1cy5jdHJsT24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKCdDdHJsQScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIChldmVudCkgPT4ge1xuICAgICAgICBkZWZhdWx0Q2FsbGJhY2soJ0tleVVwJywgZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChldmVudCkgPT4ge1xuICAgICAgICBkZWZhdWx0Q2FsbGJhY2soJ0tleURvd24nLCBldmVudCk7XG4gICAgfSk7XG5cbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjb3B5JywgZXZlbnQgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgY29udHJvbENhbGxiYWNrKCdDT1BZJywgbnVsbCwgZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY3V0JywgZXZlbnQgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgY29udHJvbENhbGxiYWNrKCdDVVQnLCBudWxsLCBldmVudCk7XG4gICAgfSk7XG5cbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsIGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnRyb2xDYWxsYmFjaygnUEFTVEUnLCBudWxsLCBldmVudCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGlucHV0O1xufVxuIiwiaW1wb3J0IFJlY3RhbmdsZSBmcm9tICcuL3NoYXBlcy9yZWN0YW5nbGUnO1xuaW1wb3J0IFN0YWNrTWl4aW4gZnJvbSAnLi9zdGFja01peGluJztcbmltcG9ydCBMYXlvdXRNaXhpbiBmcm9tICcuL2xheW91dE1peGluJztcbmltcG9ydCB7IGJvdW5kaW5nX2JveCB9IGZyb20gJy4uL3V0aWxzL2Z1bmN0aW9ucyc7XG5pbXBvcnQgeyBESVJFQ1RJT04gfSBmcm9tICcuLi91dGlscy9jb25zdGFuY2UnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEljb25+SW1hZ2VCb3VuZGluZ1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoICAgLSDlm77niYflrr3luqZcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgICAtIOWbvueJh+mrmOW6piBcbiAqL1xuLyoqXG4gKiDlm77niYfljZXlhYMg6YWN572uXG4gKiBAdHlwZWRlZiB7UmVjdGFuZ2xlflJlY3RhbmdsZUNvbmZpZ3N9IEljb25+SWNvbkNvbmZpZ3NcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbWFnZSAgIC0g5Zu+54mH5Zyw5Z2AXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW1hZ2VXaWR0aCAgIC0g5Zu+54mH5a695bqmXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW1hZ2VIZWlnaHQgICAtIOWbvueJh+mrmOW6plxuICovXG5cbi8qKlxuICog5Zu+54mH5Y2V5YWDXG4gKiBAZGVzY3JpcHRpb24g5Zu+54mH5Y2V5YWD5Y+v5Lul57uY5Yi25Zu+54mH77yM5Zu+54mH5Yqg6L295ZCO5Lya6Ieq5Yqo6YeN5paw57uY5Yi2XG4gKiBAY29uc3RydWN0b3IgSWNvblxuICogQGV4dGVuZHMgUmVjdGFuZ2xlXG4gKiBAcGFyYW0ge0ljb25+SWNvbkNvbmZpZ3N9IGNvbmZpZ3MgLSDphY3nva5cbiAqL1xuY2xhc3MgSWNvbiBleHRlbmRzIFJlY3RhbmdsZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlncykge1xuICAgICAgICBzdXBlcihjb25maWdzKVxuICAgICAgICAvKiogQG1lbWJlciB7Q2FudmFzSW1hZ2VTb3VyY2V9ICAgICAgLSDlm77niYcgKi9cbiAgICAgICAgdGhpcy5pbWFnZSA9IGNvbmZpZ3MuaW1hZ2U7XG4gICAgICAgIHRoaXMuaW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5famZsb3cuX3JlbmRlcigpO1xuICAgICAgICAgICAgLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIH0pXG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBtZW1iZXIge0ljb25+SW1hZ2VCb3VuZGluZ30gICAgICAtIOWbvueJh+e7tOW6piAqL1xuICAgICAgICB0aGlzLmltYWdlQm91bmRpbmcgPSB7XG4gICAgICAgICAgICB3aWR0aDogY29uZmlncy5pbWFnZVdpZHRoIHx8IGNvbmZpZ3Mud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGNvbmZpZ3MuaW1hZ2VIZWlnaHQgfHwgIGNvbmZpZ3MuaGVpZ2h0LFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0Q29uZmlnKGNvbmZpZ3MpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoY29uZmlncykuZm9yRWFjaChrID0+IHtcbiAgICAgICAgICAgIGlmKGNvbmZpZ3Nba10gIT09IHVuZGVmaW5lZCAmJiBjb25maWdzW2tdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trXSA9IGNvbmZpZ3Nba107XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF3Q29uZmlnc1trXSA9IGNvbmZpZ3Nba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZihjb25maWdzLmltYWdlICYmICFjb25maWdzLmltYWdlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9qZmxvdy5fcmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5famZsb3cuX3JlbmRlcigpO1xuICAgICAgICAgICAgICAgIC8vIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbWFnZUJvdW5kaW5nID0ge1xuICAgICAgICAgICAgd2lkdGg6IGNvbmZpZ3MuaW1hZ2VXaWR0aCB8fCBjb25maWdzLndpZHRoIHx8IHRoaXMuaW1hZ2VCb3VuZGluZy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogY29uZmlncy5pbWFnZUhlaWdodCB8fCAgY29uZmlncy5oZWlnaHQgfHwgdGhpcy5pbWFnZUJvdW5kaW5nLmhlaWdodCxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcihjdHgpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgaWYodGhpcy5faXNNb3Zpbmcpe1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC42XG4gICAgICAgIH1cbiAgICAgICAgUmVjdGFuZ2xlLnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzLCBjdHgpO1xuICAgICAgICBjb25zdCB4ID0gdGhpcy5hbmNob3JbMF0gLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMuYW5jaG9yWzFdIC0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgICBpZih0aGlzLm9wYWNpdHkgPCAxKSB7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLm9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5pbWFnZS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLmltYWdlLCB4LCB5LCB0aGlzLmltYWdlQm91bmRpbmcud2lkdGgsIHRoaXMuaW1hZ2VCb3VuZGluZy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgSWNvbjsiLCJpbXBvcnQgUmVjdGFuZ2xlIGZyb20gJy4vc2hhcGVzL3JlY3RhbmdsZSc7XG4vKipcbiAqIEBmdW50aW9uIGRvbUZhY3RvcnlcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyIC0gRE9N5a655ZmoXG4gKi9cbi8qKlxuICogRE9N5YWD57Sg5a655ZmoIOmFjee9rlxuICogQHR5cGVkZWYge1JlY3RhbmdsZX5Db25maWdzfSBTaGFkb3dEb21+UmVjdGFuZ2xlQ29uZmlnc1xuICogQHByb3BlcnR5IHtkb21GYWN0b3J5fSBjcmVhdGVEb2N1bWVudCAtIOWuvVxuICovXG4vKipcbiAqIERPTeWFg+e0oOWuueWZqCDlhoXlrrnlj6/otLQgRE9NIOWFg+e0oO+8jOaUr+aMgee8qeaUvuW5s+enu1xuICogQGNvbnN0cnVjdG9yIFNoYWRvd0RvbVxuICogQGV4dGVuZHMgUmVjdGFuZ2xlXG4gKiBAcGFyYW0ge1NoYWRvd0RvbX5SZWN0YW5nbGVDb25maWdzfSBjb25maWdzXG4gKi9cbmNsYXNzIFNoYWRvd0RvbSBleHRlbmRzIFJlY3RhbmdsZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlncykge1xuICAgICAgICBzdXBlcihjb25maWdzKTtcbiAgICAgICAgdGhpcy5kb21GYWN0b3J5ID0gY29uZmlncy5jcmVhdGVEb2N1bWVudDtcbiAgICAgICAgdGhpcy5fZG9tID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXRSZWFsV29ybGRQb3NpdGlvbigpIHtcbiAgICAgICAgY29uc3QgYiA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZVRvUmVhbFdvcmxkKGIuc2xpY2UoMCwgMikpO1xuICAgIH1cblxuICAgIHJlbmRlcihjdHgpIHtcbiAgICAgICAgaWYoIXRoaXMuX2RvbSAmJiB0aGlzLmRvbUZhY3RvcnkpIHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuX2RvbSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zID0gdGhpcy5nZXRSZWFsV29ybGRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2pmbG93LnNjYWxlO1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsIGBcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAke3RoaXMud2lkdGh9cHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICR7dGhpcy5oZWlnaHR9cHg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgke3Bvc1swXX1weCwgJHtwb3NbMV19cHgpIHNjYWxlKCR7c2NhbGV9KTtgKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9tID0gY29udGFpbmVyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9qZmxvdy5ET013cmFwcGVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tRmFjdG9yeShjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gdGhpcy5nZXRSZWFsV29ybGRQb3NpdGlvbigpO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9qZmxvdy5zY2FsZTtcbiAgICAgICAgICAgIHRoaXMuX2RvbS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7cG9zWzBdfXB4LCAke3Bvc1sxXX1weCkgc2NhbGUoJHtzY2FsZX0pYFxuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnJlbmRlcihjdHgpXG4gICAgfSAgICBcblxuICAgIG9uRW50ZXJWaWV3Ym94KCkge1xuICAgICAgICBpZih0aGlzLl9kb20pIHtcbiAgICAgICAgICAgIHRoaXMuX2RvbS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uTGVhdmVWaWV3Ym94KCl7XG4gICAgICAgIGlmKHRoaXMuX2RvbSkge1xuICAgICAgICAgICAgdGhpcy5fZG9tLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBcbiAgICAgICAgaWYodGhpcy5fZG9tKSB7XG4gICAgICAgICAgICB0aGlzLl9qZmxvdy5ET013cmFwcGVyLnJlbW92ZUNoaWxkKHRoaXMuX2RvbSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IFNoYWRvd0RvbTtcbiIsImltcG9ydCBCYXNlTGluayBmcm9tICcuL2Jhc2UtbGluayc7XG5pbXBvcnQgeyBkaXN0VG9TZWdtZW50U3F1YXJlZCxcbiAgICBpc1BvbHlMaW5lSW50ZXJzZWN0aW9uUmVjdGFuZ2UsXG4gICAgY29tcGFyZUJvdW5kaW5nYm94LFxuICAgIGNvcHlCb3VuZGluZ2JveFxufSBmcm9tICcuLi91dGlscy9mdW5jdGlvbnMnO1xuaW1wb3J0IHsgQVBQUk9YSU1BVEUgfSBmcm9tICcuLi91dGlscy9jb25zdGFuY2UnO1xuLyoqXG4gKiBAdHlwZWRlZiB7QmFzZUxpbmt+Q29uZmlnc30gTGlua35Db25maWdzXG4gKiBAcHJvcGVydHkge051bWJlcn0gYXBwcm94aW1hdGUgICAtIOeCueWHu+WTjeW6lOiMg+WbtFxuICogQHByb3BlcnR5IHtOdW1iZXJbXX0gbGluZURhc2ggICAgLSDomZrnur/mlbDnu4RcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZG91YmxlTGluayAgIC0g5Y+M5ZCR566t5aS0XG4gKiBAcHJvcGVydHkge1N0cmluZ30gZm9udEZhbWlseSAgICAtIOi/nue6v+S4iueahOaWh+Wtl+Wtl+S9k1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IGZvbnRTaXplICAgICAgLSDov57nur/kuIrnmoTmloflrZflpKflsI9cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBjb250ZW50ICAgICAgIC0g6L+e57q/5LiK55qE5paH5a2XXG4gKi9cbi8qKlxuICog55u057q/XG4gKiBAY29uc3RydWN0b3IgTGlua1xuICogQGV4dGVuZHMgQmFzZUxpbmtcbiAqIEBwYXJhbSB7TGlua35Db25maWdzfSBjb25maWdzIC0g6YWN572uXG4gKi9cbmNsYXNzIExpbmsgZXh0ZW5kcyBCYXNlTGluayB7XG4gICAgY29uc3RydWN0b3IoY29uZmlncykge1xuICAgICAgICBzdXBlcihjb25maWdzKTtcbiAgICAgICAgdGhpcy5mb250RmFtaWx5ICAgID0gY29uZmlncy5mb250RmFtaWx5ID0gJy1hcHBsZS1zeXN0ZW0sQmxpbmtNYWNTeXN0ZW1Gb250LFNlZ29lIFVJLFJvYm90byxIZWx2ZXRpY2EgTmV1ZSxIZWx2ZXRpY2EsVGFob21hLEFyaWFsLE5vdG8gU2FucyxQaW5nRmFuZyBTQyxNaWNyb3NvZnQgWWFIZWksSGlyYWdpbm8gU2FucyBHQixzYW5zLXNlcmlmLEFwcGxlIENvbG9yIEVtb2ppLFNlZ29lIFVJIEVtb2ppLFNlZ29lIFVJIFN5bWJvbCxOb3RvIENvbG9yIEVtb2ppJ1xuICAgICAgICB0aGlzLmZvbnRTaXplICAgICAgPSBjb25maWdzLmZvbnRTaXplIHx8ICcxMnB4JztcbiAgICAgICAgdGhpcy5jb250ZW50ICAgICAgID0gY29uZmlncy5jb250ZW50IHx8ICcnO1xuICAgICAgICB0aGlzLmxpbmVEYXNoICAgICAgPSBjb25maWdzLmxpbmVEYXNoO1xuICAgICAgICB0aGlzLmFwcHJveGltYXRlICA9IGNvbmZpZ3MuYXBwcm94aW1hdGUgfHwgQVBQUk9YSU1BVEU7XG5cbiAgICAgICAgdGhpcy5fY2FjaGVBbmdsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fY2FjaGVQb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy5fY2FjaGVCb3VuZGluZ2JveCA9IHtcbiAgICAgICAgICAgIGZyb206IFtdLFxuICAgICAgICAgICAgdG86IFtdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgX2NhbGN1bGF0ZUFuY2hvclBvaW50cygpIHtcbiAgICAgICAgY29uc3QgcDAgPSB0aGlzLmZyb20uY2FsY3VsYXRlSW50ZXJzZWN0aW9uKHRoaXMudG8uZ2V0Q2VudGVyKCkpO1xuICAgICAgICBjb25zdCBwMSA9IHRoaXMudG8uY2FsY3VsYXRlSW50ZXJzZWN0aW9uKHRoaXMuZnJvbS5nZXRDZW50ZXIoKSk7XG4gICAgICAgIHRoaXMuX2NhY2hlUG9pbnRzWzBdID0gcDA7XG4gICAgICAgIHRoaXMuX2NhY2hlUG9pbnRzWzFdID0gcDE7XG4gICAgICAgIGNvbnN0IGR4ID0gcDFbMF0gLSBwMFswXTtcbiAgICAgICAgY29uc3QgZHkgPSBwMVsxXSAtIHAwWzFdO1xuICAgICAgICBjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIoZHksIGR4KTtcbiAgICAgICAgdGhpcy5fY2FjaGVBbmdsZSA9IGFuZ2xlO1xuICAgIH1cbiAgICBcbiAgICBpc0luVmlld0JveChicikge1xuICAgICAgICBjb25zdCBmcm9tYm94ID0gdGhpcy5mcm9tLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICBjb25zdCB0b2JveCA9IHRoaXMudG8uZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgIGNvbnN0IF9ib3ggPSB0aGlzLl9jYWNoZUJvdW5kaW5nYm94O1xuICAgICAgICBpZighY29tcGFyZUJvdW5kaW5nYm94KF9ib3guZnJvbSwgZnJvbWJveCkgfHwgY29tcGFyZUJvdW5kaW5nYm94KF9ib3gudG8sIHRvYm94KSkge1xuICAgICAgICAgICAgY29weUJvdW5kaW5nYm94KF9ib3guZnJvbSwgZnJvbWJveCk7XG4gICAgICAgICAgICBjb3B5Qm91bmRpbmdib3goX2JveC50bywgdG9ib3gpO1xuICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlQW5jaG9yUG9pbnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmVuZGVyKGN0eCkge1xuICAgICAgICBjb25zdCBbIHAwLCBwMSBdID0gdGhpcy5fY2FjaGVQb2ludHM7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gdGhpcy5fY2FjaGVBbmdsZTtcbiAgICAgICAgY29uc3QgZHggPSBwMVswXSAtIHAwWzBdO1xuICAgICAgICBjb25zdCBkeSA9IHAxWzFdIC0gcDBbMV07XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBpZih0aGlzLmNvbnRlbnQpeyBcblxuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBgJHt0aGlzLmZvbnRTaXplfSAke3RoaXMuZm9udEZhbWlseX1gO1xuICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGFjdHVhbEJvdW5kaW5nQm94TGVmdCxcbiAgICAgICAgICAgICAgICBhY3R1YWxCb3VuZGluZ0JveFJpZ2h0LFxuICAgICAgICAgICAgICAgIGZvbnRCb3VuZGluZ0JveEFzY2VudCxcbiAgICAgICAgICAgICAgICBmb250Qm91bmRpbmdCb3hEZXNjZW50XG4gICAgICAgICAgICB9ID0gY3R4Lm1lYXN1cmVUZXh0KHRoaXMuY29udGVudCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gZHggLzIgKyBwMFswXTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBkeSAvMiArIHAwWzFdO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMuY29udGVudCwgeCwgeSk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IE1hdGguYWJzKGFjdHVhbEJvdW5kaW5nQm94TGVmdCkgKyBNYXRoLmFicyhhY3R1YWxCb3VuZGluZ0JveFJpZ2h0KSArIDIwO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gKE1hdGguYWJzKGZvbnRCb3VuZGluZ0JveEFzY2VudCkgKyBNYXRoLmFicyhmb250Qm91bmRpbmdCb3hEZXNjZW50KSkgKiAxLjU7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBsZXQgcmVnaW9uID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICAgICAgcmVnaW9uLnJlY3QoeCAtIHdpZHRoLzIgLCB5IC0gaGVpZ2h0LzIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgY29uc3QgcnggPSBNYXRoLm1pbihwMVswXSwgcDBbMF0pIC0gMTA7XG4gICAgICAgICAgICBjb25zdCByeSA9IE1hdGgubWluKHAxWzFdLCBwMFsxXSkgLSAxMDtcbiAgICAgICAgICAgIGNvbnN0IHJ3ID0gTWF0aC5hYnMoZHgpICsgMjA7XG4gICAgICAgICAgICBjb25zdCByaCA9IE1hdGguYWJzKGR5KSArIDIwO1xuICAgICAgICAgICAgcmVnaW9uLnJlY3QocnggLCByeSwgcncsIHJoKTtcbiAgICAgICAgICAgIGN0eC5jbGlwKHJlZ2lvbiwgXCJldmVub2RkXCIpO1xuICAgICAgICB9XG5cblxuICAgICAgICBjdHgubW92ZVRvKHAwWzBdLCBwMFsxXSk7XG4gICAgICAgIGN0eC5saW5lVG8ocDFbMF0sIHAxWzFdKTtcbiAgICAgICAgaWYodGhpcy5saW5lRGFzaCkge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaCh0aGlzLmxpbmVEYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGlmKHRoaXMubGluZURhc2gpIHtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgudHJhbnNsYXRlKHAxWzBdLCBwMVsxXSk7XG4gICAgICAgIGN0eC5yb3RhdGUoYW5nbGUpO1xuICAgICAgICBjdHgubW92ZVRvKDAsIDApO1xuICAgICAgICBjdHgubGluZVRvKC01LCAtNCk7XG4gICAgICAgIGN0eC5saW5lVG8oLTUsIDQpO1xuICAgICAgICBjdHgubGluZVRvKDAsIDApO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHgucm90YXRlKC1hbmdsZSk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoLXAxWzBdLCAtcDFbMV0pO1xuICAgIH1cblxuICAgIGlzSGl0KHBvaW50KSB7XG4gICAgICAgIGlmKCF0aGlzLl9jYWNoZVBvaW50cykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBbIHN0YXJ0LCBlbmQgXSA9IHRoaXMuX2NhY2hlUG9pbnRzO1xuICAgICAgICBjb25zdCBkaXN0ID0gZGlzdFRvU2VnbWVudFNxdWFyZWQocG9pbnQsIHN0YXJ0LCBlbmQpXG4gICAgICAgIHJldHVybiBkaXN0IDwgdGhpcy5hcHByb3hpbWF0ZTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExpbms7IiwiaW1wb3J0IEJhc2VMaW5rIGZyb20gJy4vYmFzZS1saW5rJztcbmltcG9ydCB7IFxuICAgIHBvbHlsaW5lUG9pbnRzLCBcbiAgICBkaXN0VG9TZWdtZW50U3F1YXJlZCwgXG4gICAgbWFrZVJhZGl1c0Zyb21WZWN0b3IsIFxuICAgIG1pbkludGVyc2VjdGlvbkJldHdlZW5Ob2RlcyxcbiAgICBpc1BvbHlMaW5lSW50ZXJzZWN0aW9uUmVjdGFuZ2UsXG59IGZyb20gJy4uL3V0aWxzL2Z1bmN0aW9ucyc7XG5pbXBvcnQgeyBBUFBST1hJTUFURSwgRElSRUNUSU9OIH0gZnJvbSAnLi4vdXRpbHMvY29uc3RhbmNlJztcbi8vIGltcG9ydCB7IGRpc3QyLCBiZXppZXJQb2ludCB9IGZyb20gJy4uL3V0aWxzL2Z1bmN0aW9ucyc7XG5jb25zdCBQSUlOUkFUSU8gPSBNYXRoLlBJIC8gMTgwXG4vKipcbiAqIEB0eXBlZGVmIHtCYXNlTGlua35Db25maWdzfSBQb2x5TGlua35Db25maWdzXG4gKiBAcHJvcGVydHkge051bWJlcn0gYXBwcm94aW1hdGUgICAtIOeCueWHu+WTjeW6lOiMg+WbtFxuICogQHByb3BlcnR5IHtOdW1iZXJ9IHJhZGl1cyAgICAgICAgLSDmi5Dop5LlvKfluqZcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtaW5TcGFuWCAgICAgIC0g6LW354K557uI54K55ZyoIHgg5pa55ZCR5pyA5bCP55qE6Leo5bqmXG4gKiBAcHJvcGVydHkge051bWJlcn0gbWluU3BhblkgICAgICAtIOi1t+eCuee7iOeCueWcqCB5IOaWueWQkeacgOWwj+eahOi3qOW6plxuICogQHByb3BlcnR5IHtudW1iZXJbXX0gbGluZURhc2ggICAgLSDomZrnur/mlbDnu4RcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZG91YmxlTGluayAgIC0g5Y+M5ZCR566t5aS0XG4gKiBAcHJvcGVydHkge1N0cmluZ30gZm9udEZhbWlseSAgICAtIOi/nue6v+S4iueahOaWh+Wtl+Wtl+S9k1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IGZvbnRTaXplICAgICAgLSDov57nur/kuIrnmoTmloflrZflpKflsI9cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBjb250ZW50ICAgICAgIC0g6L+e57q/5LiK55qE5paH5a2XXG4gKiBAcHJvcGVydHkge1N0cmluZ30gaXNTZWxmICAgICAgICAtIOaYr+WQpuS4uuiHqui/nuaOpVxuICovXG4vKipcbiAqIOaWueW9ouaKmOe6v1xuICogQGNvbnN0cnVjdG9yIFBvbHlMaW5rXG4gKiBAZXh0ZW5kcyBCYXNlTGlua1xuICogQHBhcmFtIHtQb2x5TGlua35Db25maWdzfSBjb25maWdzIC0g6YWN572uXG4gKi9cbmNsYXNzIFBvbHlMaW5rIGV4dGVuZHMgQmFzZUxpbmsge1xuICAgICAvKipcbiAgICAgKiDliJvlu7rmlrnlvaLmipjnur9cbiAgICAgKiBAcGFyYW0ge1BvbHlMaW5rfkNvbmZpZ3N9IGNvbmZpZ3MgLSDphY3nva5cbiAgICAgKiovXG4gICAgY29uc3RydWN0b3IoY29uZmlncykge1xuICAgICAgICBzdXBlcihjb25maWdzKTtcbiAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAtIOeCueWHu+WTjeW6lOiMg+WbtCAqL1xuICAgICAgICB0aGlzLmFwcHJveGltYXRlICAgPSBjb25maWdzLmFwcHJveGltYXRlIHx8IEFQUFJPWElNQVRFO1xuICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgIC0g5ouQ6KeS5byn5bqmICovXG4gICAgICAgIHRoaXMucmFkaXVzICAgICAgICA9IGNvbmZpZ3MucmFkaXVzIHx8IDA7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgLSDotbfngrnnu4jngrnlnKggeCDmlrnlkJHmnIDlsI/nmoTot6jluqYgKi9cbiAgICAgICAgdGhpcy5taW5TcGFuWCAgICAgID0gY29uZmlncy5taW5TcGFuWCB8fCAxMDtcbiAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAtIOi1t+eCuee7iOeCueWcqCB5IOaWueWQkeacgOWwj+eahOi3qOW6piAqL1xuICAgICAgICB0aGlzLm1pblNwYW5ZICAgICAgPSBjb25maWdzLm1pblNwYW5ZIHx8IDEwO1xuICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAtIOiZmue6v+aVsOe7hCAqL1xuICAgICAgICB0aGlzLmxpbmVEYXNoICAgICAgPSBjb25maWdzLmxpbmVEYXNoO1xuICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyfSAgICAtIOWPjOWQkeeureWktCAqL1xuICAgICAgICB0aGlzLmRvdWJsZUxpbmsgICAgPSBjb25maWdzLmRvdWJsZUxpbms7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgIC0g6L+e57q/5LiK55qE5paH5a2X5a2X5L2TICovXG4gICAgICAgIHRoaXMuZm9udEZhbWlseSAgICA9IGNvbmZpZ3MuZm9udEZhbWlseSA9ICctYXBwbGUtc3lzdGVtLEJsaW5rTWFjU3lzdGVtRm9udCxTZWdvZSBVSSxSb2JvdG8sSGVsdmV0aWNhIE5ldWUsSGVsdmV0aWNhLFRhaG9tYSxBcmlhbCxOb3RvIFNhbnMsUGluZ0ZhbmcgU0MsTWljcm9zb2Z0IFlhSGVpLEhpcmFnaW5vIFNhbnMgR0Isc2Fucy1zZXJpZixBcHBsZSBDb2xvciBFbW9qaSxTZWdvZSBVSSBFbW9qaSxTZWdvZSBVSSBTeW1ib2wsTm90byBDb2xvciBFbW9qaSdcbiAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgLSDov57nur/kuIrnmoTmloflrZflpKflsI8gKi9cbiAgICAgICAgdGhpcy5mb250U2l6ZSAgICAgID0gY29uZmlncy5mb250U2l6ZSB8fCAnMTJweCc7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgIC0g6L+e57q/5LiK55qE5paH5a2XICovXG4gICAgICAgIHRoaXMuY29udGVudCAgICAgICA9IGNvbmZpZ3MuY29udGVudCB8fCAnJztcbiAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgLSDmmK/lkKbkuLroh6rov57mjqUgKi9cbiAgICAgICAgdGhpcy5pc1NlbGYgICAgICAgID0gISFjb25maWdzLmlzU2VsZlxuXG4gICAgICAgIHRoaXMubm9BcnJvdyAgICAgICA9ICEhY29uZmlncy5ub0Fycm93IFxuICAgICAgICB0aGlzLl9jYWNoZUFuZ2xlID0gW107XG4gICAgICAgIHRoaXMuX2NhY2hlUG9pbnRzID0gW107XG4gICAgICAgIHRoaXMuX2NhY2hlQm91bmRpbmdib3ggPSB7XG4gICAgICAgICAgICBmcm9tOiBbXSxcbiAgICAgICAgICAgIHRvOiBbXVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIF9jYWxjdWxhdGVBbmNob3JQb2ludHMoKSB7XG4gICAgICAgIGNvbnN0IGRtc2Zyb20gPSB0aGlzLmZyb20uZ2V0SW50ZXJzZWN0aW9uc0luRm91ckRpbWVuc2lvbigpO1xuICAgICAgICBjb25zdCBkbXN0byA9IHRoaXMudG8uZ2V0SW50ZXJzZWN0aW9uc0luRm91ckRpbWVuc2lvbigpO1xuICAgICAgICBjb25zdCBfY2FjaGVBbmdsZSA9IHRoaXMuX2NhY2hlQW5nbGU7XG4gICAgICAgIGlmKHRoaXMuaXNTZWxmKXtcbiAgICAgICAgICAgIHBvbHlsaW5lUG9pbnRzKFxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlUG9pbnRzLFxuICAgICAgICAgICAgICAgIGRtc2Zyb21bdGhpcy5mcm9tRGlyXSxcbiAgICAgICAgICAgICAgICBkbXN0b1tESVJFQ1RJT04uU0VMRl0sXG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tRGlyLFxuICAgICAgICAgICAgICAgIHRoaXMudG9EaXIsIFxuICAgICAgICAgICAgICAgIHRoaXMubWluU3BhblgsIFxuICAgICAgICAgICAgICAgIHRoaXMubWluU3BhblksXG4gICAgICAgICAgICAgICAgdHJ1ZSk7XG4gICAgICAgICAgICBfY2FjaGVBbmdsZVswXSA9IHRoaXMuZnJvbURpcjtcbiAgICAgICAgICAgIF9jYWNoZUFuZ2xlWzFdID0gdGhpcy50b0RpcjtcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMuZnJvbURpciAhPT0gdW5kZWZpbmVkICYmIHRoaXMudG9EaXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcG9seWxpbmVQb2ludHMoXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVQb2ludHMsXG4gICAgICAgICAgICAgICAgZG1zZnJvbVt0aGlzLmZyb21EaXJdLFxuICAgICAgICAgICAgICAgIGRtc3RvW3RoaXMudG9EaXJdLFxuICAgICAgICAgICAgICAgIHRoaXMuZnJvbURpcixcbiAgICAgICAgICAgICAgICB0aGlzLnRvRGlyLCB0aGlzLm1pblNwYW5YICwgdGhpcy5taW5TcGFuWSk7XG4gICAgICAgICAgICBfY2FjaGVBbmdsZVswXSA9IHRoaXMuZnJvbURpcjtcbiAgICAgICAgICAgIF9jYWNoZUFuZ2xlWzFdID0gdGhpcy50b0RpcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBtaW5JbnRlcnNlY3Rpb25CZXR3ZWVuTm9kZXMoZG1zZnJvbSwgZG1zdG8pO1xuICAgICAgICAgICAgcG9seWxpbmVQb2ludHMoXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVQb2ludHMsXG4gICAgICAgICAgICAgICAgbWV0YS5mcm9tUCxcbiAgICAgICAgICAgICAgICBtZXRhLnRvUCxcbiAgICAgICAgICAgICAgICBtZXRhLmZyb21EaXIsXG4gICAgICAgICAgICAgICAgbWV0YS50b0RpcixcbiAgICAgICAgICAgICAgICB0aGlzLm1pblNwYW5YICwgdGhpcy5taW5TcGFuWSk7XG4gICAgICAgICAgICBfY2FjaGVBbmdsZVswXSA9IG1ldGEuZnJvbURpcjtcbiAgICAgICAgICAgIF9jYWNoZUFuZ2xlWzFdID0gbWV0YS50b0RpcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpc0luVmlld0JveChicikge1xuICAgICAgICBpZih0aGlzLl9zdGF0aWMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZUFuY2hvclBvaW50cygpOyAgICAgXG4gICAgICAgIHJldHVybiBpc1BvbHlMaW5lSW50ZXJzZWN0aW9uUmVjdGFuZ2UodGhpcy5fY2FjaGVQb2ludHMsIGJyKTtcbiAgICB9XG5cbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIC8vIHRoaXMuX2NhbGN1bGF0ZUFuY2hvclBvaW50cygpO1xuICAgICAgICBjb25zdCByYWRpdXMgPSB0aGlzLnJhZGl1cztcbiAgICAgICAgY29uc3QgcG9pbnRzID0gdGhpcy5fY2FjaGVQb2ludHM7XG4gICAgICAgIGNvbnN0IHAgPSBwb2ludHNbMF07XG4gICAgICAgIGNvbnN0IHBFbmQgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCBhbmdsZUVuZCA9ICgodGhpcy5fY2FjaGVBbmdsZVsxXSArIDIpICUgNCkgKiA5MCAqIFBJSU5SQVRJTztcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBpZih0aGlzLmRvdWJsZUxpbmspIHtcbiAgICAgICAgICAgIGNvbnN0IGJlZ2luQW5nbGUgPSAoKHRoaXMuX2NhY2hlQW5nbGVbMF0gKyAyKSAlIDQpICogOTAgKiBQSUlOUkFUSU87XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHBbMF0sIHBbMV0pO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShiZWdpbkFuZ2xlKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oNSwgMCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKDAsIC00KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oMCwgNCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKDUsIDApO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoLWJlZ2luQW5nbGUpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtcFswXSwgLXBbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhwWzBdLCBwWzFdKTtcbiAgICAgICAgcG9pbnRzLnNsaWNlKDEsIHBvaW50cy5sZW5ndGggLSAxKS5mb3JFYWNoKChwLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGlmKHRoaXMucmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcExhc3QgPSBwb2ludHNbaWR4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBwTmV4dCA9IHBvaW50c1tpZHgrMl07XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwMSwgcDIgfSA9IG1ha2VSYWRpdXNGcm9tVmVjdG9yKHBMYXN0LCBwLCBwTmV4dCwgcmFkaXVzKTtcbiAgICAgICAgICAgICAgICBpZihwMSAmJiBwMil7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocDFbMF0sIHAxWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8ocFswXSwgcFsxXSwgcDJbMF0sIHAyWzFdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHBbMF0sIHBbMV0pO1xuICAgICAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHBbMF0sIHBbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmxpbmVUbyhwRW5kWzBdLCBwRW5kWzFdKTtcblxuICAgICAgICBpZih0aGlzLmxpbmVEYXNoKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKHRoaXMubGluZURhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgaWYodGhpcy5saW5lRGFzaCkge1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCF0aGlzLm5vQXJyb3cpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUocEVuZFswXSwgcEVuZFsxXSk7XG4gICAgICAgICAgICBjdHgucm90YXRlKGFuZ2xlRW5kKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKC01LCAtNCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKC01LCA0KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oMCwgMCk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZSgtYW5nbGVFbmQpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtcEVuZFswXSwgLXBFbmRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuY29udGVudCkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBgJHt0aGlzLmZvbnRTaXplfSAke3RoaXMuZm9udEZhbWlseX1gO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmZyb21EaXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIERJUkVDVElPTi5CT1RUT006XG4gICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLmNvbnRlbnQsIHBbMF0gKyAyLCBwWzFdICsgMTApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIERJUkVDVElPTi5SSUdIVDpcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMuY29udGVudCwgcFswXSArIDEwLCBwWzFdIC0gMik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBpc0hpdChwb2ludCkge1xuICAgICAgICBpZih0aGlzLl9zdGF0aWMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZighdGhpcy5fY2FjaGVQb2ludHMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9jYWNoZVBvaW50cztcbiAgICAgICAgbGV0IGxhc3RQID0gcG9pbnRzWzBdO1xuICAgICAgICBjb25zdCByZW1haW5Qb2ludHMgPSBwb2ludHMuc2xpY2UoMSlcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFAgPSByZW1haW5Qb2ludHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmKGN1cnJlbnRQKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdCA9IGRpc3RUb1NlZ21lbnRTcXVhcmVkKHBvaW50LCBsYXN0UCwgY3VycmVudFApO1xuICAgICAgICAgICAgICAgIGlmKGRpc3QgPCB0aGlzLmFwcHJveGltYXRlKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdFAgPSBjdXJyZW50UDtcbiAgICAgICAgfSB3aGlsZShsYXN0UClcblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjbG9uZVN0YXRpYygpIHtcbiAgICAgICAgY29uc3QgdCA9IG5ldyBQb2x5TGluayh7fSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odCwge1xuICAgICAgICAgICAgcmFkaXVzOiB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAgIF9jYWNoZVBvaW50czogdGhpcy5fY2FjaGVQb2ludHMsXG4gICAgICAgICAgICBfY2FjaGVBbmdsZTogdGhpcy5fY2FjaGVBbmdsZSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBkb3VibGVMaW5rOiB0aGlzLmRvdWJsZUxpbmssXG4gICAgICAgICAgICByYWRpdXM6IHRoaXMucmFkaXVzLFxuICAgICAgICAgICAgbGluZURhc2g6IHRoaXMubGluZURhc2gsXG4gICAgICAgICAgICBub0Fycm93OiB0aGlzLm5vQXJyb3csXG4gICAgICAgICAgICBjb250ZW50OiB0aGlzLmNvbnRlbnQsXG4gICAgICAgICAgICBmb250U2l6ZTogdGhpcy5mb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHRoaXMuZm9udEZhbWlseSxcbiAgICAgICAgICAgIGZyb21EaXI6IHRoaXMuZnJvbURpcixcbiAgICAgICAgICAgIF9zdGF0aWM6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBvbHlMaW5rOyIsImltcG9ydCBCYXNlTGluayBmcm9tICcuL2Jhc2UtbGluayc7XG5pbXBvcnQgeyBiZXppZXJQb2ludHMsIGRpc3RUb0JlemllclNlZ21lbnRTcXVhcmVkLCBnZXRCZXppZXJBbmdsZSwgbWluSW50ZXJzZWN0aW9uQmV0d2Vlbk5vZGVzIH0gZnJvbSAnLi4vdXRpbHMvZnVuY3Rpb25zJztcbmltcG9ydCB7IEFQUFJPWElNQVRFLCBESVJFQ1RJT04gfSBmcm9tICcuLi91dGlscy9jb25zdGFuY2UnO1xuaW1wb3J0IHsgZGlzdDIsIGJlemllclBvaW50IH0gZnJvbSAnLi4vdXRpbHMvZnVuY3Rpb25zJztcbmNvbnN0IFBJSU5SQVRJTyA9IE1hdGguUEkgLyAxODBcbi8qKlxuICogQHR5cGVkZWYge0Jhc2VMaW5rfkNvbmZpZ3N9IEJlemllckxpbmt+Q29uZmlnc1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IGFwcHJveGltYXRlICAgLSDngrnlh7vlk43lupTojIPlm7RcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtaW5TcGFuWCAgICAgIC0g6LW354K557uI54K55ZyoIHgg5pa55ZCR5pyA5bCP55qE6Leo5bqmXG4gKiBAcHJvcGVydHkge051bWJlcn0gbWluU3BhblkgICAgICAtIOi1t+eCuee7iOeCueWcqCB5IOaWueWQkeacgOWwj+eahOi3qOW6plxuICogQHByb3BlcnR5IHtOdW1iZXJbXX0gbGluZURhc2ggICAgLSDomZrnur/mlbDnu4RcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZG91YmxlTGluayAgIC0g5Y+M5ZCR566t5aS0XG4gKiBAcHJvcGVydHkge1N0cmluZ30gZm9udEZhbWlseSAgICAtIOi/nue6v+S4iueahOaWh+Wtl+Wtl+S9k1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IGZvbnRTaXplICAgICAgLSDov57nur/kuIrnmoTmloflrZflpKflsI9cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBjb250ZW50ICAgICAgIC0g6L+e57q/5LiK55qE5paH5a2XXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGlzU2VsZiAgICAgICAgLSDmmK/lkKbkuLroh6rov57mjqVcbiAqL1xuLyoqXG4gKiDotJ3loZ7lsJTmm7Lnur9cbiAqIEBjb25zdHJ1Y3RvciBCZXppZXJMaW5rXG4gKiBAZXh0ZW5kcyBCYXNlTGlua1xuICogQHBhcmFtIHtCZXppZXJMaW5rfkNvbmZpZ3N9IGNvbmZpZ3MgLSDphY3nva5cbiAqL1xuY2xhc3MgQmV6aWVyTGluayBleHRlbmRzIEJhc2VMaW5rIHtcbiAgICAgLyoqXG4gICAgICog5Yib5bu66LSd5aGe5bCU5puy57q/LlxuICAgICAqIEBwYXJhbSB7QmV6aWVyTGlua35Db25maWdzfSBjb25maWdzIC0g6YWN572uXG4gICAgICoqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3MpIHtcbiAgICAgICAgc3VwZXIoY29uZmlncyk7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgICAgLSDngrnlh7vlk43lupTojIPlm7QgKi9cbiAgICAgICAgdGhpcy5hcHByb3hpbWF0ZSAgID0gY29uZmlncy5hcHByb3hpbWF0ZSB8fCBBUFBST1hJTUFURTtcbiAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgICAtIOi1t+eCuee7iOeCueWcqCB4IOaWueWQkeacgOWwj+eahOi3qOW6piAqL1xuICAgICAgICB0aGlzLm1pblNwYW5YICAgICAgPSBjb25maWdzLm1pblNwYW5YIHx8IDA7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtOdW1iZXJ9ICAgICAgLSDotbfngrnnu4jngrnlnKggeSDmlrnlkJHmnIDlsI/nmoTot6jluqYgKi9cbiAgICAgICAgdGhpcy5taW5TcGFuWSAgICAgID0gY29uZmlncy5taW5TcGFuWSB8fCAwO1xuICAgICAgICAvKiogQG1lbWJlciB7TnVtYmVyW119ICAgICAgLSDomZrnur/mlbDnu4QgKi9cbiAgICAgICAgdGhpcy5saW5lRGFzaCAgICAgID0gY29uZmlncy5saW5lRGFzaDtcbiAgICAgICAgdGhpcy5saW5lV2lkdGggICAgID0gY29uZmlncy5saW5lV2lkdGggfHwgMTtcbiAgICAgICAgLyoqIEBtZW1iZXIge0Jvb2xlYW59ICAgICAgLSDlj4zlkJHnrq3lpLQgKi9cbiAgICAgICAgdGhpcy5kb3VibGVMaW5rICAgID0gY29uZmlncy5kb3VibGVMaW5rO1xuICAgICAgICAvKiogQG1lbWJlciB7U3RyaW5nfSAgICAgIC0g6L+e57q/5LiK55qE5paH5a2X5a2X5L2TICovXG4gICAgICAgIHRoaXMuZm9udEZhbWlseSAgICA9IGNvbmZpZ3MuZm9udEZhbWlseSA9ICctYXBwbGUtc3lzdGVtLEJsaW5rTWFjU3lzdGVtRm9udCxTZWdvZSBVSSxSb2JvdG8sSGVsdmV0aWNhIE5ldWUsSGVsdmV0aWNhLFRhaG9tYSxBcmlhbCxOb3RvIFNhbnMsUGluZ0ZhbmcgU0MsTWljcm9zb2Z0IFlhSGVpLEhpcmFnaW5vIFNhbnMgR0Isc2Fucy1zZXJpZixBcHBsZSBDb2xvciBFbW9qaSxTZWdvZSBVSSBFbW9qaSxTZWdvZSBVSSBTeW1ib2wsTm90byBDb2xvciBFbW9qaSdcbiAgICAgICAgLyoqIEBtZW1iZXIge051bWJlcn0gICAgICAtIOi/nue6v+S4iueahOaWh+Wtl+Wkp+WwjyAqL1xuICAgICAgICB0aGlzLmZvbnRTaXplICAgICAgPSBjb25maWdzLmZvbnRTaXplIHx8ICcxMnB4JztcbiAgICAgICAgLyoqIEBtZW1iZXIge1N0cmluZ30gICAgICAtIOi/nue6v+S4iueahOaWh+WtlyAqL1xuICAgICAgICB0aGlzLmNvbnRlbnQgICAgICAgPSBjb25maWdzLmNvbnRlbnQgfHwgJyc7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtCb29sZWFufSAgICAgIC0g5piv5ZCm5Li66Ieq6L+e5o6lICovXG4gICAgICAgIHRoaXMuaXNTZWxmICAgICAgICA9ICEhY29uZmlncy5pc1NlbGZcbiAgICB9XG4gICAgXG4gICAgLy8gZ2V0Q29sb3IoKSB7XG4gICAgLy8gICAgIGlmKHRoaXMuX2lzVGFyZ2V0aW5nKSB7XG4gICAgLy8gICAgICAgICByZXR1cm4gdGhpcy5ob3ZlclN0eWxlO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIHJldHVybiB0aGlzLmRlZmF1bHRTdHlsZTtcbiAgICAvLyB9XG4gICAgXG4gICAgLy8gX2NhbGN1bGF0ZUFuY2hvclBvaW50cygpIHtcbiAgICAvLyAgICAgbGV0IHN0YXJ0O1xuICAgIC8vICAgICBsZXQgZW5kO1xuICAgIC8vICAgICBpZih0aGlzLmZyb21EaXIgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vICAgICAgICAgc3RhcnQgPSB7XG4gICAgLy8gICAgICAgICAgICAgZGlyOiB0aGlzLmZyb21EaXIsXG4gICAgLy8gICAgICAgICAgICAgcDogdGhpcy5mcm9tLmdldEludGVyc2VjdGlvbnNJbkZvdXJEaW1lbnNpb24oKVt0aGlzLmZyb21EaXJdLFxuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICB9IGVsc2Uge1xuICAgIC8vICAgICAgICAgc3RhcnQgPSB0aGlzLmZyb20uY2FsY3VsYXRlSW50ZXJzZWN0aW9uSW5Gb3VyRGltZW5zaW9uKHRoaXMudG8uZ2V0Q2VudGVyKCksICdmcm9tJyk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgaWYodGhpcy50b0RpciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gICAgICAgICBlbmQgPSB7XG4gICAgLy8gICAgICAgICAgICAgZGlyOiB0aGlzLnRvRGlyLFxuICAgIC8vICAgICAgICAgICAgIHA6IHRoaXMudG8uZ2V0SW50ZXJzZWN0aW9uc0luRm91ckRpbWVuc2lvbigpW3RoaXMudG9EaXJdLFxuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICB9IGVsc2Uge1xuICAgIC8vICAgICAgICAgZW5kID0gdGhpcy50by5jYWxjdWxhdGVJbnRlcnNlY3Rpb25JbkZvdXJEaW1lbnNpb24odGhpcy5mcm9tLmdldENlbnRlcigpLCAndG8nKTtcbiAgICAvLyAgICAgfVxuICAgICAgICBcbiAgICAgICAgXG4gICAgLy8gICAgIC8vIGNvbnN0IHN0YXJ0ID0gdGhpcy5mcm9tLmNhbGN1bGF0ZUludGVyc2VjdGlvbkluRm91ckRpbWVuc2lvbih0aGlzLnRvLmdldENlbnRlcigpLCAnZnJvbScpO1xuICAgIC8vICAgICAvLyBjb25zdCBlbmQgPSB0aGlzLnRvLmNhbGN1bGF0ZUludGVyc2VjdGlvbkluRm91ckRpbWVuc2lvbih0aGlzLmZyb20uZ2V0Q2VudGVyKCksICd0bycpO1xuICAgIC8vICAgICBjb25zdCBwMSA9IHN0YXJ0LnA7XG4gICAgLy8gICAgIGNvbnN0IHAyID0gZW5kLnA7XG4gICAgLy8gICAgIGNvbnN0IHBvaW50cyA9IGJlemllclBvaW50cyhwMSwgcDIsIHN0YXJ0LmRpciwgZW5kLmRpciwgdGhpcy5hbnRpY2xvY2spO1xuXG4gICAgLy8gICAgIHRoaXMuX2NhY2hlUG9pbnRzID0gWy4uLnAxLCAuLi5wb2ludHNdXG4gICAgLy8gfVxuXG4gICAgX2NhbGN1bGF0ZUFuY2hvclBvaW50cygpIHtcbiAgICAgICAgY29uc3QgZG1zZnJvbSA9IHRoaXMuZnJvbS5nZXRJbnRlcnNlY3Rpb25zSW5Gb3VyRGltZW5zaW9uKCk7XG4gICAgICAgIGNvbnN0IGRtc3RvID0gdGhpcy50by5nZXRJbnRlcnNlY3Rpb25zSW5Gb3VyRGltZW5zaW9uKCk7XG4gICAgICAgIGlmKHRoaXMuaXNTZWxmKSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBiZXppZXJQb2ludHMoXG4gICAgICAgICAgICAgICAgZG1zZnJvbVt0aGlzLmZyb21EaXJdLFxuICAgICAgICAgICAgICAgIGRtc3RvW0RJUkVDVElPTi5TRUxGXSxcbiAgICAgICAgICAgICAgICB0aGlzLmZyb21EaXIsXG4gICAgICAgICAgICAgICAgRElSRUNUSU9OLkJPVFRPTSwgXG4gICAgICAgICAgICAgICAgdGhpcy5taW5TcGFuWCwgXG4gICAgICAgICAgICAgICAgdGhpcy5taW5TcGFuWSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2NhY2hlUG9pbnRzID0gWy4uLmRtc2Zyb21bdGhpcy5mcm9tRGlyXSwgLi4ucG9pbnRzXSBcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlQW5nbGUgPSBbdGhpcy5mcm9tRGlyLCBESVJFQ1RJT04uQk9UVE9NXVxuICAgICAgICB9IGVsc2UgaWYodGhpcy5mcm9tRGlyICE9PSB1bmRlZmluZWQgJiYgdGhpcy50b0RpciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBiZXppZXJQb2ludHMoXG4gICAgICAgICAgICAgICAgZG1zZnJvbVt0aGlzLmZyb21EaXJdLFxuICAgICAgICAgICAgICAgIGRtc3RvW3RoaXMudG9EaXJdLFxuICAgICAgICAgICAgICAgIHRoaXMuZnJvbURpcixcbiAgICAgICAgICAgICAgICB0aGlzLnRvRGlyLCB0aGlzLm1pblNwYW5YICwgdGhpcy5taW5TcGFuWSk7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZVBvaW50cyA9IFsuLi5kbXNmcm9tW3RoaXMuZnJvbURpcl0sIC4uLnBvaW50c10gXG4gICAgICAgICAgICB0aGlzLl9jYWNoZUFuZ2xlID0gW3RoaXMuZnJvbURpciwgdGhpcy50b0Rpcl1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBtaW5JbnRlcnNlY3Rpb25CZXR3ZWVuTm9kZXMoZG1zZnJvbSwgZG1zdG8pO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gYmV6aWVyUG9pbnRzKFxuICAgICAgICAgICAgICAgIG1ldGEuZnJvbVAsXG4gICAgICAgICAgICAgICAgbWV0YS50b1AsXG4gICAgICAgICAgICAgICAgbWV0YS5mcm9tRGlyLFxuICAgICAgICAgICAgICAgIG1ldGEudG9EaXIpO1xuXG4gICAgICAgICAgICB0aGlzLl9jYWNoZVBvaW50cyA9IFsuLi5tZXRhLmZyb21QLCAuLi5wb2ludHNdO1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVBbmdsZSA9IFttZXRhLmZyb21EaXIsIG1ldGEudG9EaXJdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKGN0eCkge1xuICAgICAgICB0aGlzLl9jYWxjdWxhdGVBbmNob3JQb2ludHMoKTtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gdGhpcy5fY2FjaGVQb2ludHM7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gZ2V0QmV6aWVyQW5nbGUuYXBwbHkobnVsbCwgWzEsIC4uLnBvaW50c10pXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMubGluZVdpZHRoO1xuICAgICAgICBpZih0aGlzLmRvdWJsZUxpbmspIHtcbiAgICAgICAgICAgIGNvbnN0IGJlZ2luQW5nbGUgPSAoKHRoaXMuX2NhY2hlQW5nbGVbMF0gKyAyKSAlIDQpICogOTAgKiBQSUlOUkFUSU87XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoYmVnaW5BbmdsZSk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKDUsIDApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbygwLCAtNCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKDAsIDQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyg1LCAwKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICBjdHgucm90YXRlKC1iZWdpbkFuZ2xlKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLXBvaW50c1swXSwgLXBvaW50c1sxXSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdKVxuICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyguLi5wb2ludHMuc2xpY2UoMikpO1xuICAgICAgICBpZih0aGlzLmxpbmVEYXNoKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKHRoaXMubGluZURhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgaWYodGhpcy5saW5lRGFzaCkge1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUocG9pbnRzWzZdLCBwb2ludHNbN10pO1xuICAgICAgICBjdHgucm90YXRlKGFuZ2xlKTtcbiAgICAgICAgY3R4Lm1vdmVUbyg1LCAwKTtcbiAgICAgICAgY3R4LmxpbmVUbygwLCAtNCk7XG4gICAgICAgIGN0eC5saW5lVG8oMCwgNCk7XG4gICAgICAgIGN0eC5saW5lVG8oNSwgMCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5yb3RhdGUoLWFuZ2xlKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgtcG9pbnRzWzZdLCAtcG9pbnRzWzddKTtcbiAgICAgICAgaWYodGhpcy5jb250ZW50KSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb25zdCBoYXNGbGlwID0gcG9pbnRzWzBdID4gcG9pbnRzWzZdO1xuICAgICAgICAgICAgbGV0IFt4LCB5LCBhbmdsZV0gPSBiZXppZXJQb2ludCgwLjUsIHBvaW50cyk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShhbmdsZSk7XG4gICAgICAgICAgICBpZihoYXNGbGlwKXtcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKE1hdGguUEkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmZvbnQgPSBgJHt0aGlzLmZvbnRTaXplfSAke3RoaXMuZm9udEZhbWlseX1gO1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMuY29udGVudCwgMCwgLShwYXJzZUludCh0aGlzLmZvbnRTaXplKSB8fCAxMikvNCk7XG4gICAgICAgICAgICBpZihoYXNGbGlwKXtcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKE1hdGguUEkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnJvdGF0ZSgtYW5nbGUpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgteCwgLXkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNIaXQocG9pbnQpIHtcbiAgICAgICAgaWYoIXRoaXMuX2NhY2hlUG9pbnRzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX2NhY2hlUG9pbnRzO1xuICAgICAgICBjb25zdCBkaXN0ID0gZGlzdFRvQmV6aWVyU2VnbWVudFNxdWFyZWQocG9pbnQsIHBvaW50cylcbiAgICAgICAgcmV0dXJuIGRpc3QgPCB0aGlzLmFwcHJveGltYXRlO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmV6aWVyTGluazsiLCIvKipcbiAqIOe6v+aAp+W4g+WxgOmFjee9rlxuICogQHR5cGVkZWYge09iamVjdH0gTGluZWFyTGF5b3V0fkNvbmZpZ3NcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkaXJlY3Rpb24gICAgIC0g5o6S5YiX5pa55ZCRIOm7mOiupCB2ZXJ0aWNhbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGdhcCAgICAgICAgICAgLSDovrnot50sIOm7mOiupOaYryA1XG4gKiBAcHJvcGVydHkge3N0cmluZ30gYWxpZ25tZW50ICAgICAtIOWeguebtOaOkuWIl+aWueWQkeWvuem9kOaWueW8jyDpu5jorqQgY2VudGVyXG4gKiBAcHJvcGVydHkge3N0cmluZ30ganVzdGlmeSAgICAgICAtIOaOkuWIl+aWueWQkeWvuem9kOaWueW8jyDpu5jorqQgY2VudGVyXG4gKi9cbi8qKlxuICAgIOe6v+aAp+W4g+WxgFxuXG4gICAg5o6S5YiX5pa55ZCRXG4gICAgZGlyZWN0aW9uOlxuICAgICAgICArIHZlcnRpY2FsIOS7juS4iuiHs+S4i+aOkuW4g1xuICAgICAgICArIGhvcml6b250YWwg5LuO5bem6Iez5Y+z5o6S5biDXG4gICAgXG4gICAg5LiN6YeN5Y+g77yM5Lit57q/5a+56b2QXG4gICAg5Y+q6ZKI5a+55b2T5YmN55qEIGdyb3VwXG5cbiAgICDlr7npvZDmlrnlvI9cbiAgICBhbGlnbm1lbnQ6IFxuICAgICAgICArIHN0YXJ0IOS4u+i9tOW3puS+p+Wvuem9kFxuICAgICAgICArIGNlbnRlciDkuLvovbTlr7npvZBcbiAgICAgICAgKyBlbmQgICDkuLvovbTlj7Pkvqflr7npvZBcbiAgICBqdXN0aWZ5OiBcbiAgICAgICAgKyBzdGFydCDlvIDlp4vml7blr7npvZBcbiAgICAgICAgKyBjZW50ZXIg5bGF5Lit5a+56b2QXG4gICAgICAgICsgZW5kICAg5pyr5bC+5a+56b2QXG4gICAgICAgICsgc3BhY2UtYmV0d2VlbiDlubPlnYfliIbphY3nqbrpl7Tlr7npvZBcblxuICogQGNvbnN0cnVjdG9yIExpbmVhckxheW91dFxuICogQGltcGxlbWVudHMge0xheW91dH1cbiAqIEBwYXJhbSB7TGluZWFyTGF5b3V0fkNvbmZpZ3N9IGNvbmZpZ3MgLSDphY3nva5cbiAqL1xuXG5jbGFzcyBMaW5lYXJMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3MgPSB7fSkge1xuICAgICAgICAvKiogQG1lbWJlciB7c3RyaW5nfSAgLSDmjpLliJfmlrnlkJEg6buY6K6kIHZlcnRpY2FsICovXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gICAgIGNvbmZpZ3MuZGlyZWN0aW9uIHx8ICd2ZXJ0aWNhbCc7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtudW1iZXJ9ICAtIOi+uei3nSwg6buY6K6k5pivIDUgKi9cbiAgICAgICAgdGhpcy5nYXAgPSAgICAgICAgICAgY29uZmlncy5nYXAgPz8gNTtcbiAgICAgICAgLyoqIEBtZW1iZXIge3N0cmluZ30gIC0g5Z6C55u05o6S5YiX5pa55ZCR5a+56b2Q5pa55byPIOm7mOiupCBjZW50ZXIgKi9cbiAgICAgICAgdGhpcy5hbGlnbm1lbnQgPSAgICAgY29uZmlncy5hbGlnbm1lbnQgfHwgJ2NlbnRlcic7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtzdHJpbmd9ICAtIOaOkuWIl+aWueWQkeWvuem9kOaWueW8jyDpu5jorqQgY2VudGVyICovXG4gICAgICAgIHRoaXMuanVzdGlmeSA9ICAgICAgIGNvbmZpZ3MuanVzdGlmeSB8fCAnY2VudGVyJztcbiAgICAgICAgLy8gdGhpcy53aWR0aFNldEJ5UGFyZW50ID0gIGNvbmZpZ3Mud2lkdGggPT09ICcxMDAlJ1xuICAgICAgICB0aGlzLl9yYXdDb25maWdzID0gY29uZmlncztcbiAgICB9XG5cblxuICAgIHJlZmxvdyhncm91cCkge1xuICAgICAgICBjb25zdCBzdGFjayA9IGdyb3VwLl9zdGFjay5maWx0ZXIoaW5zdGFuY2UgPT4gaW5zdGFuY2UudmlzaWJsZSAmJiAhaW5zdGFuY2UuYWJzb2x1dGVQb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IGFic29sdXRlU3RhY2sgPSBncm91cC5fc3RhY2suZmlsdGVyKGluc3RhbmNlID0+IGluc3RhbmNlLnZpc2libGUgJiYgaW5zdGFuY2UuYWJzb2x1dGVQb3NpdGlvbilcbiAgICAgICAgY29uc3QgZ3JvdXBXaWR0aCA9IGdyb3VwLndpZHRoIC0gZ3JvdXAucGFkZGluZy5sZWZ0IC0gZ3JvdXAucGFkZGluZy5yaWdodDtcbiAgICAgICAgaWYodGhpcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIGxldCByZWR1Y2VIZWlnaHQgPSAwO1xuICAgICAgICAgICAgbGV0IGxhc3RJbnN0YW5jZUhlaWdodCA9IDA7XG4gICAgICAgICAgICBsZXQgbWF4V2lkdGggPSAwO1xuICAgICAgICAgICAgbGV0IGFsbEhlaWdodCA9IDA7XG4gICAgICAgICAgICBjb25zdCBjaGlsZEFsbCA9IHN0YWNrLmNvbmNhdChhYnNvbHV0ZVN0YWNrKTtcbiAgICAgICAgICAgIGNoaWxkQWxsLmZvckVhY2goKGluc3RhbmNlLCBpZHgpID0+ICB7XG4gICAgICAgICAgICAgICAgaWYoaW5zdGFuY2UuZGlzcGxheSA9PT0gJ2Jsb2NrJykge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS53aWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluc3RhbmNlLmRlZmluZWRXaWR0aCA9IG1heFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5yZXNldENoaWxkcmVuUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UucmVmbG93KCk7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLl9nZXRCb3VuZGluZ0dyb3VwUmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzdGFjay5mb3JFYWNoKChpbnN0YW5jZSwgaWR4KSA9PiAge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gaW5zdGFuY2UuZ2V0Qm91bmRpbmdEaW1lbnNpb24oKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhoZWlnaHQsIGluc3RhbmNlLnR5cGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdhcCA9IChpZHggPiAwID8gdGhpcy5nYXAgOiAwKTtcbiAgICAgICAgICAgICAgICBpZihpbnN0YW5jZS5kaXNwbGF5ICE9PSAnb3V0c3RyZXRjaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1heCh3aWR0aCwgbWF4V2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbGxIZWlnaHQgKz0gKGhlaWdodCArIGdhcCk7XG4gICAgICAgICAgICAgICAgcmVkdWNlSGVpZ2h0ICs9IChoZWlnaHQvMiArIGdhcCArIGxhc3RJbnN0YW5jZUhlaWdodClcbiAgICAgICAgICAgICAgICBsYXN0SW5zdGFuY2VIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmFuY2hvciA9IFswLCByZWR1Y2VIZWlnaHRdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjaGlsZEFsbC5mb3JFYWNoKChpbnN0YW5jZSwgaWR4KSA9PiAge1xuICAgICAgICAgICAgICAgIGlmKGluc3RhbmNlLmRpc3BsYXkgPT09ICdibG9jaycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5zdGFuY2UuZGVmaW5lZFdpZHRoID0gbWF4V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnJlc2V0Q2hpbGRyZW5Qb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS53aWR0aCA9IG1heFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5yZWZsb3coKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5zdGFuY2UuX2dldEJvdW5kaW5nR3JvdXBSZWN0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKGluc3RhbmNlLmRpc3BsYXkgPT09ICdvdXRzdHJldGNoJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3ID0gZ3JvdXAuX2JlbG9uZ3Mud2lkdGggLSBncm91cC5fYmVsb25ncy5wYWRkaW5nLmxlZnQgLSBncm91cC5fYmVsb25ncy5wYWRkaW5nLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5yZXNldENoaWxkcmVuUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uud2lkdGggPSBNYXRoLm1heCh3LCBtYXhXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnJlZmxvdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KGdyb3VwV2lkdGgsIG1heFdpZHRoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYWxsSGVpZ2h0ID0gYWxsSGVpZ2h0LzI7XG4gICAgICAgICAgICBpZih0aGlzLmFsaWdubWVudCA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgICAgIHN0YWNrLmZvckVhY2goKGluc3RhbmNlLCBpZHgpID0+ICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGggfSA9IGluc3RhbmNlLmdldEJvdW5kaW5nRGltZW5zaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmFuY2hvclswXSA9IC0obWF4V2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5hbmNob3JbMV0gLT0gYWxsSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhtYXhXaWR0aCwgd2lkdGgsIGluc3RhbmNlLmFuY2hvclswXSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5hbGlnbm1lbnQgPT09ICdlbmQnKSB7XG4gICAgICAgICAgICAgICAgc3RhY2suZm9yRWFjaCgoaW5zdGFuY2UsIGlkeCkgPT4gIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB3aWR0aCB9ID0gaW5zdGFuY2UuZ2V0Qm91bmRpbmdEaW1lbnNpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuYW5jaG9yWzBdID0gKG1heFdpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuYW5jaG9yWzFdIC09IGFsbEhlaWdodDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5hbGlnbm1lbnQgPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgc3RhY2suZm9yRWFjaCgoaW5zdGFuY2UsIGlkeCkgPT4gIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB3aWR0aCB9ID0gaW5zdGFuY2UuZ2V0Qm91bmRpbmdEaW1lbnNpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuYW5jaG9yWzFdIC09IGFsbEhlaWdodDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9IFxuICAgICAgICBpZih0aGlzLmRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICBsZXQgcmVkdWNlV2lkdGggPSAwO1xuICAgICAgICAgICAgbGV0IGxhc3RJbnN0YW5jZVdpZHRoID0gMDtcbiAgICAgICAgICAgIGxldCBtYXhIZWlnaHQgPSAwO1xuICAgICAgICAgICAgbGV0IGFsbFdpZHRoID0gMDtcbiAgICAgICAgICAgIGxldCBhbGxQdXJlV2lkdGggPSAwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzdGFjay5mb3JFYWNoKChpbnN0YW5jZSwgaWR4KSA9PiAge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gaW5zdGFuY2UuZ2V0Qm91bmRpbmdEaW1lbnNpb24oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBnYXAgPSAoaWR4ID4gMCA/IHRoaXMuZ2FwIDogMCk7XG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCBtYXhIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGFsbFdpZHRoICs9ICh3aWR0aCtnYXApO1xuICAgICAgICAgICAgICAgIGFsbFB1cmVXaWR0aCArPSB3aWR0aDtcbiAgICAgICAgICAgICAgICByZWR1Y2VXaWR0aCArPSAod2lkdGgvMiArIGdhcCArIGxhc3RJbnN0YW5jZVdpZHRoKVxuICAgICAgICAgICAgICAgIGxhc3RJbnN0YW5jZVdpZHRoID0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmFuY2hvciA9IFtyZWR1Y2VXaWR0aCwgMF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYodGhpcy5qdXN0aWZ5ID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2l0aGRyYXcgPSBncm91cFdpZHRoLzI7XG4gICAgICAgICAgICAgICAgc3RhY2suZm9yRWFjaCgoaW5zdGFuY2UsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5hbmNob3JbMF0gLT0gd2l0aGRyYXc7XG4gICAgICAgICAgICAgICAgfSk7ICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMuanVzdGlmeSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3aXRoZHJhdyA9IGdyb3VwV2lkdGgvMiAtIGFsbFdpZHRoO1xuICAgICAgICAgICAgICAgIHN0YWNrLmZvckVhY2goKGluc3RhbmNlLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuYW5jaG9yWzBdICs9IHdpdGhkcmF3O1xuICAgICAgICAgICAgICAgIH0pOyAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLmp1c3RpZnkgPT09ICdjZW50ZXInKSB7IFxuICAgICAgICAgICAgICAgIGNvbnN0IHdpdGhkcmF3ID0gYWxsV2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHN0YWNrLmZvckVhY2goKGluc3RhbmNlLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuYW5jaG9yWzBdIC09IHdpdGhkcmF3O1xuICAgICAgICAgICAgICAgIH0pICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5qdXN0aWZ5ID09PSAnc3BhY2UtYmV0d2VlbicgJiYgc3RhY2subGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5tYXgoZ3JvdXBXaWR0aCwgYWxsV2lkdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdhcEF2ZXJhZ2UgPSAod2lkdGggLSBhbGxXaWR0aCkgLyAoc3RhY2subGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2l0aGRyYXcgPSB3aWR0aC8yO1xuICAgICAgICAgICAgICAgIHN0YWNrLmZvckVhY2goKGluc3RhbmNlLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuYW5jaG9yWzBdICs9ICgoZ2FwQXZlcmFnZSAqIGlkeCkgLSB3aXRoZHJhdyk7XG4gICAgICAgICAgICAgICAgfSk7ICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMuYWxpZ25tZW50ID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgc3RhY2suZm9yRWFjaCgoaW5zdGFuY2UsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGhlaWdodCB9ID0gaW5zdGFuY2UuZ2V0Qm91bmRpbmdEaW1lbnNpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuYW5jaG9yWzFdID0gLShtYXhIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5hbGlnbm1lbnQgPT09ICdlbmQnKSB7XG4gICAgICAgICAgICAgICAgc3RhY2suZm9yRWFjaCgoaW5zdGFuY2UsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGhlaWdodCB9ID0gaW5zdGFuY2UuZ2V0Qm91bmRpbmdEaW1lbnNpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuYW5jaG9yWzFdID0gKG1heEhlaWdodCAtIGhlaWdodCkgLyAyO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihhYnNvbHV0ZVN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYoZ3JvdXAuZGlzcGxheSA9PT0gJ2Jsb2NrJykge1xuICAgICAgICAgICAgICAgIGdyb3VwLmdldEJvdW5kaW5nRGltZW5zaW9uKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdyb3VwLl9nZXRCb3VuZGluZ0dyb3VwUmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgV0lEVEggPSBncm91cC53aWR0aCAvMjtcbiAgICAgICAgICAgIGNvbnN0IEhFSUdIVCA9IGdyb3VwLmhlaWdodCAvMjtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0eSA9IChncm91cC5wYWRkaW5nLnRvcCAtIGdyb3VwLnBhZGRpbmcuYm90dG9tKS8yO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnR4ID0gKGdyb3VwLnBhZGRpbmcubGVmdCAtIGdyb3VwLnBhZGRpbmcucmlnaHQpLzI7XG4gICAgICAgICAgICBhYnNvbHV0ZVN0YWNrLmZvckVhY2goaW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmFuY2hvciA9IHRoaXMuX3Jlc29sdmVBYnNvbHV0ZUFuY2hvcihpbnN0YW5jZS5hYnNvbHV0ZVBvc2l0aW9uLCBpbnN0YW5jZSwgV0lEVEgsIEhFSUdIVCwgc2hpZnR4LCBzaGlmdHkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9yZXNvbHZlQWJzb2x1dGVBbmNob3IoY29uZmlnLCBpbnN0YW5jZSwgdywgaCwgc2hpZnR4LCBzaGlmdHkpe1xuICAgICAgICBjb25zdCB7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgY2VudGVyWCwgY2VudGVyWSB9ID0gY29uZmlnO1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGluc3RhbmNlLmdldEJvdW5kaW5nRGltZW5zaW9uKCk7XG4gICAgICAgIGNvbnN0IGh3ID0gd2lkdGggLyAyO1xuICAgICAgICBjb25zdCBoaCA9IGhlaWdodCAvIDI7XG4gICAgICAgIGxldCB5ID0gMDtcbiAgICAgICAgbGV0IHggPSAwO1xuICAgICAgICBpZih0eXBlb2YgdG9wID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgeSA9IHRvcCArIGhoIC0gaCAtIHNoaWZ0eTtcbiAgICAgICAgfVxuICAgICAgICBpZih0eXBlb2YgcmlnaHQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB4ID0gdyAtIHJpZ2h0IC0gaHcgLSBzaGlmdHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYodHlwZW9mIGJvdHRvbSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHkgPSBoIC0gYm90dG9tIC0gaGggLSBzaGlmdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodHlwZW9mIGxlZnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB4ID0gbGVmdCArIGh3IC0gdyAtIHNoaWZ0eDtcbiAgICAgICAgfVxuICAgICAgICBpZih0eXBlb2YgY2VudGVyWCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHggPSBjZW50ZXJYO1xuICAgICAgICB9XG4gICAgICAgIGlmKHR5cGVvZiBjZW50ZXJZID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgeSA9IGNlbnRlclk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4LCB5XVxuICAgIH1cblxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IExpbmVhckxheW91dCh0aGlzLl9yYXdDb25maWdzKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExpbmVhckxheW91dDsiLCJcbmV4cG9ydCBjb25zdCBFRElUT1JfRVZFTlRTID0ge1xuICAgIElOUFVUOiAnaW5wdXQnLFxuICAgIENPTlRST0xfQ01EOiAnY29udHJvbCdcbn1cblxuZXhwb3J0IGNvbnN0IEtFWUJPQVJEX0lOUFVUID0ge1xuICAgIElOUFVUOiAnaW5wdXQnLFxuICAgIENPTVBPU0lUSU9OX1NUQVJUOiAnY29tcG9zaXRpb25zdGFydCcsXG4gICAgQ09NUE9TSVRJT05fVVBEQVRFOiAnY29tcG9zaXRpb251cGRhdGUnLFxuICAgIENPTVBPU0lUSU9OX0VORDogJ2NvbXBvc2l0aW9uZW5kJyxcbiAgICBFTlRFUjogJ2VudGVyJyxcbiAgICBERUxFVEU6ICdkZWxldGUnLFxuICAgIEJBQ0tTUEFDRTogJ2JhY2tzcGFjZScsXG59XG5cbmV4cG9ydCBjb25zdCBLRVlCT0FSRF9DT01NQU5EUyA9IHtcbiAgICBBUlJPV19MRUZUOiAnYXJyb3dMZWZ0JyxcbiAgICBBUlJPV19SSUdIVDogJ2Fycm93UmlnaHQnLFxuICAgIEFSUk9XX1VQOiAnYXJyb3dVcCcsXG4gICAgQVJST1dfRE9XTjogJ2Fycm93RG93bicsXG4gICAgVU5ETzogJ3VuZG8nLFxuICAgIFJFRE86ICdyZWRvJyxcbiAgICBTSElGVF9ET1dOOiAnc2hpZnRfZG93bicsXG4gICAgU0hJRlRfVVA6ICdzaGlmdF91cCcsXG4gICAgQ1RSTEE6ICdjdHJsYScsXG4gICAgQ09QWTogJ2NvcHknLFxuICAgIENVVDogJ2N1dCcsXG4gICAgUEFTVEU6ICdwYXN0ZScsXG59XG5cbmV4cG9ydCBjb25zdCBNT1VTRV9DT01NQU5EUyA9IHtcbiAgICBTVEFSVF9FRElUOiAnc3RhcnRlZGl0JyxcbiAgICBFRElUX0NMSUNLOiAnZWRpdGNsaWNrJyxcbiAgICBTSElGVF9PTl9DTElDSzogJ3NoaWZ0b25jbGljaycsXG4gICAgRE9VQkxFX0NMSUNLOiAnZG91YmxlY2xpY2snXG59XG5cblxuZXhwb3J0IGNvbnN0IE9QRVJSQVRJT04gPSB7XG4gICAgUExBSU5JTlBVVDogJ3BsYWluaW5wdXQnLFxuICAgIFNQQUNFSU5QVVQ6ICdzcGFjZWlucHV0JyxcbiAgICBSRVRVUk5JTlBVVDogJ3JldHVybmlucHV0JyxcbiAgICBDQVJFVE1PVkVNRU5UOiAnY2FyZXRtb3ZlbWVudCcsXG4gICAgREVMRVRFX0lOX0xJTkU6ICdkZWxldGVpbmxpbmUnLFxuICAgIERFTEVURV9JTl9FRElUQVJFQTogJ2RlbGV0ZWluZWRpdGFyZWEnLFxuICAgIEVOU1VSRV9ERUxFVEU6ICdlbnN1cmVkZWxldGUnLFxuICAgIFNFTEVDVElPTl9ERUxFVEU6ICdzZWxlY3Rpb25kZWxldGUnLFxuICAgIFNFTEVDVElPTl9JTlBVVDogJ3NlbGVjdGlvbmlucHV0JyxcbiAgICBDT01QT1NJVEVfSU5TRVJUOiAnY29tcG9zaXRlaW5zZXJ0J1xufVxuIiwiaW1wb3J0IHsgS0VZQk9BUkRfQ09NTUFORFMsIEtFWUJPQVJEX0lOUFVULCBFRElUT1JfRVZFTlRTIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5jbGFzcyBTaGFkb3dJbnB1dCBleHRlbmRzIEV2ZW50VGFyZ2V0e1xuICAgIF9pbnB1dEVsZW1lbnQgPSBudWxsO1xuXG4gICAgY29uc3RydWN0b3Iod3JhcHBlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9pbnB1dEVsZW1lbnQgPSBjcmVhdGVJbnB1dEVsZW1lbnQodGhpcy5jb250cm9sQ2FsbGJhY2suYmluZCh0aGlzKSk7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kKHRoaXMuX2lucHV0RWxlbWVudCk7XG4gICAgICAgIHRoaXMuX2lucHV0RWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgICBjb250cm9sQ2FsbGJhY2soa2luZCwgZGF0YSkge1xuICAgICAgICBzd2l0Y2goa2luZCkge1xuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9JTlBVVC5JTlBVVDpcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfSU5QVVQuQ09NUE9TSVRJT05fU1RBUlQ6XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0lOUFVULkNPTVBPU0lUSU9OX1VQREFURTpcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfSU5QVVQuQ09NUE9TSVRJT05fRU5EOlxuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9JTlBVVC5FTlRFUjpcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfSU5QVVQuQkFDS1NQQUNFOlxuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9JTlBVVC5ERUxFVEU6XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChFRElUT1JfRVZFTlRTLklOUFVULCB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0NPTU1BTkRTLkFSUk9XX0xFRlQ6XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0NPTU1BTkRTLkFSUk9XX1JJR0hUOlxuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9DT01NQU5EUy5BUlJPV19VUDpcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfQ09NTUFORFMuQVJST1dfRE9XTjpcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfQ09NTUFORFMuQ1RSTEE6XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0NPTU1BTkRTLlNISUZUX0RPV046XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0NPTU1BTkRTLlNISUZUX1VQOlxuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9DT01NQU5EUy5VTkRPOlxuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9DT01NQU5EUy5SRURPOlxuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9DT01NQU5EUy5DT1BZOlxuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9DT01NQU5EUy5DVVQ6XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0NPTU1BTkRTLlBBU1RFOlxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoRURJVE9SX0VWRU5UUy5DT05UUk9MX0NNRCwge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb2N1cygpIHtcbiAgICAgICAgdGhpcy5faW5wdXRFbGVtZW50LmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTsgIFxuICAgIH1cblxuICAgIHN5bmNQb3NpdGlvbih4LCB5KSB7XG4gICAgICAgIHRoaXMuX2lucHV0RWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7eH1weCwgJHt5fXB4KWBcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZih0aGlzLnJlbW92ZUxpc2VudGVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxpc2VudGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5wdXRFbGVtZW50LnJlbW92ZSgpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2hhZG93SW5wdXQ7XG5cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0RWxlbWVudChjb250cm9sQ2FsbGJhY2spIHtcbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKCdzdHlsZScsYFxuICAgICAgICB3aWR0aDogMTAwcHg7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBib3JkZXI6bm9uZTtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgICAgei1pbmRleDogLTE7XG4gICAgICAgIGNvbnRhaW46IHN0cmljdDtgKTtcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgLTEpO1xuICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnc3BlbGxjaGVjaycsIGZhbHNlKTtcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2F1dG9jb3JyZWN0JywgJ29mZicpO1xuXG4gICAgbGV0IHN0b3BJbnB1dCA9IGZhbHNlO1xuICAgIGxldCBzdGF0dXMgPSB7XG4gICAgICAgIGN0cmxPbjogZmFsc2UsXG4gICAgICAgIHNoaWZ0T246IGZhbHNlLFxuICAgIH1cblxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZWlucHV0JywgZSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYoZS5kYXRhKSB7XG4gICAgICAgICAgICAvLyBjb250ZW50ICs9IGUuZGF0YTtcbiAgICAgICAgICAgIC8vIHJlbmRlckNvbnRlbnQoKTtcbiAgICAgICAgICAgIGlmKCFzdG9wSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soS0VZQk9BUkRfSU5QVVQuSU5QVVQsIGUuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigncGFzdGUnLCBlID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBjb25zdCBwYXN0ZUNvbnRlbnQgPSAoZS5jbGlwYm9hcmREYXRhIHx8IHdpbmRvdy5jbGlwYm9hcmREYXRhKS5nZXREYXRhKFwidGV4dFwiKTtcbiAgICAgICAgY29udHJvbENhbGxiYWNrKEtFWUJPQVJEX0NPTU1BTkRTLlBBU1RFLCBwYXN0ZUNvbnRlbnQpO1xuICAgIH0pO1xuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NvcHknLCBlID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBjb250cm9sQ2FsbGJhY2soS0VZQk9BUkRfQ09NTUFORFMuQ09QWSwgZSk7XG4gICAgfSk7XG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY3V0JywgZSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgY29udHJvbENhbGxiYWNrKEtFWUJPQVJEX0NPTU1BTkRTLkNVVCwgZSk7XG4gICAgfSk7XG5cbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0JywgKGUpID0+IHtcbiAgICAgICAgY29udHJvbENhbGxiYWNrKEtFWUJPQVJEX0lOUFVULkNPTVBPU0lUSU9OX1NUQVJUKTtcbiAgICAgICAgc3RvcElucHV0ID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnVwZGF0ZScsIChlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xDYWxsYmFjayhLRVlCT0FSRF9JTlBVVC5DT01QT1NJVElPTl9VUERBVEUsIGUuZGF0YSk7XG4gICAgfSk7XG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCAoZSkgPT4ge1xuICAgICAgICBjb250cm9sQ2FsbGJhY2soS0VZQk9BUkRfSU5QVVQuQ09NUE9TSVRJT05fRU5ELCBlLmRhdGEpO1xuICAgICAgICBpbnB1dC52YWx1ZSA9ICcnO1xuICAgICAgICBzdG9wSW5wdXQgPSBmYWxzZVxuICAgIH0pO1xuXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYoc3RvcElucHV0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKGV2ZW50LmtleSkge1xuICAgICAgICAgICAgY2FzZSBcIlNoaWZ0XCI6XG4gICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKEtFWUJPQVJEX0NPTU1BTkRTLlNISUZUX1VQKTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuc2hpZnRPbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIk1ldGFcIjpcbiAgICAgICAgICAgIGNhc2UgXCJDb250cm9sXCI6XG4gICAgICAgICAgICAgICAgc3RhdHVzLmN0cmxPbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChldmVudCkgPT4ge1xuICAgICAgICBpZihzdG9wSW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2goZXZlbnQuY29kZSkge1xuICAgICAgICAgICAgY2FzZSBcIkVudGVyXCI6XG4gICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKEtFWUJPQVJEX0lOUFVULkVOVEVSKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJCYWNrc3BhY2VcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soS0VZQk9BUkRfSU5QVVQuQkFDS1NQQUNFKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJEZWxldGVcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soS0VZQk9BUkRfSU5QVVQuREVMRVRFKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soS0VZQk9BUkRfQ09NTUFORFMuQVJST1dfTEVGVCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjayhLRVlCT0FSRF9DT01NQU5EUy5BUlJPV19SSUdIVCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XG4gICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKEtFWUJPQVJEX0NPTU1BTkRTLkFSUk9XX0RPV04pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soS0VZQk9BUkRfQ09NTUFORFMuQVJST1dfVVApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaChldmVudC5rZXkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJTaGlmdFwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjayhLRVlCT0FSRF9DT01NQU5EUy5TSElGVF9ET1dOKTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuc2hpZnRPbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiTWV0YVwiOlxuICAgICAgICAgICAgY2FzZSBcIkNvbnRyb2xcIjpcbiAgICAgICAgICAgICAgICBzdGF0dXMuY3RybE9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgIGlmKHN0YXR1cy5jdHJsT24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbENhbGxiYWNrKEtFWUJPQVJEX0NPTU1BTkRTLkNUUkxBKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBjYXNlICdjJzpcbiAgICAgICAgICAgIC8vICAgICBpZihzdGF0dXMuY3RybE9uKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgIGNvbnRyb2xDYWxsYmFjayhLRVlCT0FSRF9DT01NQU5EUy5DVFJMQyk7XG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gICAgIGJyZWFrOyBcbiAgICAgICAgICAgIC8vIGNhc2UgJ3YnOlxuICAgICAgICAgICAgLy8gICAgIGlmKHN0YXR1cy5jdHJsT24pIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgY29udHJvbENhbGxiYWNrKEtFWUJPQVJEX0NPTU1BTkRTLkNUUkxWKTtcbiAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAvLyAgICAgYnJlYWs7ICAgXG4gICAgICAgICAgICAvLyBjYXNlICd4JzpcbiAgICAgICAgICAgIC8vICAgICBpZihzdGF0dXMuY3RybE9uKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgIGNvbnRyb2xDYWxsYmFjayhLRVlCT0FSRF9DT01NQU5EUy5DVFJMWCk7XG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgICAgICAgaWYoc3RhdHVzLmN0cmxPbikge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soS0VZQk9BUkRfQ09NTUFORFMuUkVETyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgICAgICAgaWYoKHN0YXR1cy5jdHJsT24gJiYgc3RhdHVzLnNoaWZ0T24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xDYWxsYmFjayhLRVlCT0FSRF9DT01NQU5EUy5SRURPKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoc3RhdHVzLmN0cmxPbikge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sQ2FsbGJhY2soS0VZQk9BUkRfQ09NTUFORFMuVU5ETyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9ICAgXG4gICAgfSlcbiAgICByZXR1cm4gaW5wdXQ7XG59IiwiY2xhc3MgQ2FyZXQgeyBcbiAgICBfcm93ID0gMDtcbiAgICBfY29sdW1uID0gWzAsMF07XG5cbiAgICBfc3RhdHVzID0ge1xuICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICBhbmltZTogbnVsbCxcbiAgICAgICAgbGFzdEVsYXBzZWQ6IDAsXG4gICAgICAgIHJlZnJlc2hFbGFwc2VkOiBmYWxzZSxcbiAgICB9XG5cbiAgICBzZXRSb3cocm93KSB7XG4gICAgICAgIHRoaXMuX3JvdyA9IHJvdztcbiAgICB9XG4gICAgc2V0Q29sdW1uKGNvbHVtbm9yaWR4LCBjb2x1bW4pIHtcbiAgICAgICAgaWYoY29sdW1uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbHVtbltjb2x1bW5vcmlkeF0gPSBjb2x1bW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jb2x1bW4gPSBjb2x1bW5vcmlkeDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFJvdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JvdztcbiAgICB9XG5cbiAgICBnZXRDb2x1bW4oaWR4KSB7XG4gICAgICAgIGlmKGlkeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sdW1uW2lkeF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtbjtcbiAgICB9XG5cbiAgICBhbmltYXRlKGpmbG93KSB7XG4gICAgICAgIHRoaXMuX3N0YXR1cy5hbmltZSA9IGpmbG93LnJlcXVlc3RKRmxvd0FuaW1lKChlbGFwc2VkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsYXN0RWxhcHNlZCA9IHRoaXMuX3N0YXR1cy5sYXN0RWxhcHNlZDtcbiAgICAgICAgICAgIGlmKHRoaXMuX3N0YXR1cy5yZWZyZXNoRWxhcHNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5sYXN0RWxhcHNlZCA9IGVsYXBzZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzLnJlZnJlc2hFbGFwc2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihlbGFwc2VkIC0gbGFzdEVsYXBzZWQgPiA1MDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMuc2hvdyA9ICF0aGlzLl9zdGF0dXMuc2hvdztcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMubGFzdEVsYXBzZWQgPSBlbGFwc2VkO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2FuY2VsQW5pbWF0ZSgpIHtcbiAgICAgICAgdGhpcy5fc3RhdHVzLmFuaW1lLmNhbmNlbCgpXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fc3RhdHVzLCB7XG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgYW5pbWU6IG51bGwsXG4gICAgICAgICAgICBsYXN0RWxhcHNlZDogMCxcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBpc1Nob3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0dXMuc2hvdztcbiAgICB9XG5cbiAgICByZWZyZXNoKCkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3N0YXR1cywge1xuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIHJlZnJlc2hFbGFwc2VkOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0b1JhbmdlKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuX3JvdywgLi4udGhpcy5fY29sdW1uXTtcbiAgICB9XG5cbiAgICBmcm9tUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgdGhpcy5fcm93ID0gcmFuZ2VbMF07XG4gICAgICAgIHRoaXMuX2NvbHVtbiA9IHJhbmdlLnNsaWNlKDEpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FyZXQ7IiwiaW1wb3J0IHsgcmVxdWVzdENhY2hlQ2FudmFzIH0gZnJvbSAnLi4vLi4vdXRpbHMvY2FudmFzJztcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVPZmZzZXRCeVdpZHRoKFxuICAgIG9mZngsIFxuICAgIHRleHRtZXRhLFxuICAgIGZvbnRTaXplLCBmb250RmFtaWx5LFxuICAgIHNwYWNlSG9sZGVyXG4pIHtcbiAgICBjb25zdCBjb250ZW50ID0gdGV4dG1ldGEuZ2V0UmVuZGVyU291cmNlKHNwYWNlSG9sZGVyKTtcbiAgICBjb25zdCBtYXhMID0gY29udGVudC5sZW5ndGggLSAxO1xuICAgIGlmKHRleHRtZXRhLndpZHRoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBhbGx3aWR0aCA9IHRleHRtZXRhLndpZHRoO1xuICAgIGxldCBpZHggPSBNYXRoLmZsb29yKG9mZnggLyBhbGx3aWR0aCAqIG1heEwpIDtcbiAgICByZXF1ZXN0Q2FjaGVDYW52YXMoKGN0eCkgPT4ge1xuICAgICAgICBjdHguZm9udCA9IGAke2ZvbnRTaXplfSAke2ZvbnRGYW1pbHl9YDtcbiAgICAgICAgbGV0IGcxLCBnMjtcbiAgICAgICAgbGV0IGxhc3RpZHg7XG5cbiAgICAgICAgbGV0IGMgPSBjb250ZW50LnN1YnN0cmluZygwLCBpZHgpO1xuICAgICAgICBsZXQgYzEgPSBjb250ZW50LnN1YnN0cmluZyhpZHgtMSwgaWR4KTtcbiAgICAgICAgbGV0IGMyID0gY29udGVudC5zdWJzdHJpbmcoaWR4LCBpZHgrMSk7XG4gICAgICAgIGxldCB3ID0gY3R4Lm1lYXN1cmVUZXh0KGMpLndpZHRoO1xuICAgICAgICBsZXQgdzEgPSBjdHgubWVhc3VyZVRleHQoYzEpLndpZHRoO1xuICAgICAgICBsZXQgdzIgPSBjdHgubWVhc3VyZVRleHQoYzIpLndpZHRoO1xuICAgICAgICBnMSA9IHcgLSB3MS8yO1xuICAgICAgICBnMiA9IHcgKyB3Mi8yO1xuICAgICAgICBcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYoZzEgPD0gb2ZmeCAmJiBnMiA+PSBvZmZ4KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9ICBcbiAgICAgICAgICAgIGlmKGcxID4gb2ZmeCkge1xuICAgICAgICAgICAgICAgIC8vIOW3puS+p+WwkeS6hlxuICAgICAgICAgICAgICAgIGNvbnN0IHNwYW53ID0gZzIgLSBvZmZ4O1xuICAgICAgICAgICAgICAgIGxhc3RpZHggPSBpZHg7XG4gICAgICAgICAgICAgICAgaWYoc3BhbncgPCAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWR4IC09IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWR4IC09IE1hdGguZmxvb3Ioc3BhbncgLyBnMiAqIGxhc3RpZHgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGMgPSBjb250ZW50LnN1YnN0cmluZyhpZHgsIGxhc3RpZHgpO1xuICAgICAgICAgICAgICAgIHcgLT0gY3R4Lm1lYXN1cmVUZXh0KGMpLndpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGcyIDwgb2ZmeCkge1xuICAgICAgICAgICAgICAgIC8vIOWPs+S+p+WwkeS6hlxuICAgICAgICAgICAgICAgIGNvbnN0IHNwYW53ID0gb2ZmeCAtIGcxO1xuICAgICAgICAgICAgICAgIGxhc3RpZHggPSBpZHg7XG4gICAgICAgICAgICAgICAgaWYoc3BhbncgPCAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWR4ICs9IE1hdGguZmxvb3Ioc3BhbncgLyAoYWxsd2lkdGggLSBnMSkgKiAobWF4TCAtIGxhc3RpZHgpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjID0gY29udGVudC5zdWJzdHJpbmcobGFzdGlkeCwgaWR4KTtcbiAgICAgICAgICAgICAgICB3ICs9IGN0eC5tZWFzdXJlVGV4dChjKS53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYzEgPSBjb250ZW50LnN1YnN0cmluZyhpZHgtMSwgaWR4KTtcbiAgICAgICAgICAgIGMyID0gY29udGVudC5zdWJzdHJpbmcoaWR4LCBpZHgrMSk7XG4gICAgICAgICAgICB3MSA9IGN0eC5tZWFzdXJlVGV4dChjMSkud2lkdGg7XG4gICAgICAgICAgICB3MiA9IGN0eC5tZWFzdXJlVGV4dChjMikud2lkdGg7XG4gICAgICAgICAgICBnMSA9IHcgLSB3MS8yO1xuICAgICAgICAgICAgZzIgPSB3ICsgdzIvMjtcbiAgICAgICAgfSB3aGlsZShpZHggPj0gMCAmJiBpZHggPD0gbWF4TClcbiAgICAgICAgXG4gICAgfSk7XG4gICAgcmV0dXJuIGlkeDtcbn0iLCJpbXBvcnQgeyBjYWxjdWxhdGVPZmZzZXRCeVdpZHRoIH0gZnJvbSAnLi4vdXRpbHMnXG5leHBvcnQgY2xhc3MgQXJlYSB7XG4gICAgX2xpbmVzID0gW107IFxuXG4gICAgZ2V0KGlkeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGluZXNbaWR4XTtcbiAgICB9XG5cbiAgICBnZXRMaW5lQWJvdmUob2Zmc2V0WSkge1xuICAgICAgICBsZXQgcm93ID0gMDtcbiAgICAgICAgY29uc3QgbGluZXMgPSB0aGlzLl9saW5lcztcbiAgICAgICAgd2hpbGUocm93IDwgbGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZihsaW5lc1tyb3ddLnJlZHVjZUhlaWdodCA+IG9mZnNldFkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvdyArKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5taW4ocm93LCBsaW5lcy5sZW5ndGggLSAxKTtcbiAgICB9XG5cbiAgICB0cnVuY2F0ZShjb25maWdzKSB7XG4gICAgICAgIGNvbnN0IGwgPSBMaW5lLmNyZWF0ZShjb25maWdzKTtcbiAgICAgICAgdGhpcy5fbGluZXMgPSBbbF07XG4gICAgICAgIHJldHVybiBsO1xuICAgIH1cblxuICAgIHB1c2gobGluZSkge1xuICAgICAgICB0aGlzLl9saW5lcy5wdXNoKGxpbmUpO1xuICAgIH1cblxuICAgIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fbGluZXMuZm9yRWFjaChjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGluZXMubGVuZ3RoO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIExpbmUge1xuICAgIHdpZHRoID0gMDtcbiAgICBhbmNob3JZID0gMDtcbiAgICBoZWlnaHQgPSAwO1xuICAgIHJlZHVjZUhlaWdodCA9IDA7XG4gICAgX2VsZW1lbnRzID0gW11cblxuICAgIHN0YXRpYyBjcmVhdGUoY29uZmlncykge1xuICAgICAgICBjb25zdCBsID0gbmV3IExpbmUoY29uZmlncyk7XG4gICAgICAgIHJldHVybiBsO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3MgPSB7fSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNvbmZpZ3MpO1xuICAgIH1cblxuICAgIF9lbGVtZW50cyA9IFtdO1xuXG4gICAgZ2V0KGlkeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudHNbaWR4XTtcbiAgICB9XG4gICAgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudHMubGVuZ3RoO1xuICAgIH1cblxuICAgIGluc2VydChpZHgsIGVsZW0pIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudHMuc3BsaWNlKGlkeCwgMCwgZWxlbSlcbiAgICB9XG4gICAgcHVzaChlbGVtKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzLnB1c2goZWxlbSk7XG4gICAgfVxuICAgIHRhaWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50c1t0aGlzLl9lbGVtZW50cy5sZW5ndGgtMV07XG4gICAgfVxuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50cy5zbGljZSgpO1xuICAgIH1cblxuICAgIGdldENvbHVtbk5lYXJlc3Qob2Zmc2V0WCwgZWxlbWVudFNwYWNlLCBmb250U2l6ZSwgZm9udEZhbWlseSwgZWRpdG9yKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5fZWxlbWVudHM7XG4gICAgICAgIGlmKG9mZnNldFggPj0gdGhpcy53aWR0aCkge1xuICAgICAgICAgICAgY29uc3QgYyA9IGVsZW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBjb25zdCBlbGVtID0gZWxlbWVudHNbY107XG4gICAgICAgICAgICBsZXQgcSA9IDA7XG4gICAgICAgICAgICBpZihlbGVtLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIHEgPSBlbGVtLnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgcmV0dXJuIFtjLCBxXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGVsZW1faWR4ID0gMDtcbiAgICAgICAgICAgIGxldCBsYXN0X2MgPSAwO1xuICAgICAgICAgICAgbGV0IF9jID0gMDsgXG4gICAgICAgICAgICBsZXQgbGFzdGVsID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlKGVsZW1faWR4IDwgZWxlbWVudHMubGVuZ3RoIC0xKSB7XG4gICAgICAgICAgICAgICAgbGFzdF9jID0gX2M7XG4gICAgICAgICAgICAgICAgY29uc3QgZWwgPSBlbGVtZW50c1tlbGVtX2lkeF07XG4gICAgICAgICAgICAgICAgaWYoZWwudHlwZSAhPT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvdWJsZU1hcmdpbiA9IChsYXN0ZWwgJiYgbGFzdGVsLnR5cGUgPT09ICd0ZXh0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcmdpbiA9IGRvdWJsZU1hcmdpbiA/IGVsZW1lbnRTcGFjZSoyIDogZWxlbWVudFNwYWNlO1xuICAgICAgICAgICAgICAgICAgICBfYyArPSAoZWwud2lkdGggKyBtYXJnaW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9jICs9IGVsLndpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihfYyA+IG9mZnNldFgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdGVsID0gZWxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RlbCA9IGVsXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZWxlbV9pZHgrKztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKF9jIDw9IG9mZnNldFgpIHtcbiAgICAgICAgICAgICAgICBsYXN0X2MgPSBfYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRleHRtZXRhID0gZWxlbWVudHNbZWxlbV9pZHhdO1xuICAgICAgICAgICAgaWYodGV4dG1ldGEudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2ZmeCA9IG9mZnNldFggLSBsYXN0X2M7XG4gICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gY2FsY3VsYXRlT2Zmc2V0QnlXaWR0aChvZmZ4LCB0ZXh0bWV0YSwgZm9udFNpemUsIGZvbnRGYW1pbHksIGVkaXRvci5zcGFjZUhvbGRlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gW2VsZW1faWR4LCBpZHhdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZ4ID0gb2Zmc2V0WCAtIGxhc3RfYztcbiAgICAgICAgICAgICAgICBpZihvZmZ4ID4gbGFzdGVsLndpZHRoLzIpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2VsZW1faWR4KzEsIDBdXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtlbGVtX2lkeCwgMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzLmZvckVhY2goY2FsbGJhY2spO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZsYXR0ZW5UZXh0RWxlbWVudHMge1xuICAgIHN0YXRpYyBjcmVhdGUoZWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgX2UgPSBuZXcgRmxhdHRlblRleHRFbGVtZW50cygpO1xuICAgICAgICBfZS5mcm9tKGVsZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIF9lO1xuICAgIH1cbiAgICBfdGV4dEVsZW1lbnRzID0gW107XG4gICAgX3JlY29yZHMgPSBbXTtcbiAgICBfY2FyZXRSZWNvcmQgPSBudWxsO1xuXG4gICAgaW5zZXJ0QmVmb3JlKGFuY2hvciwgZWxlbSkge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmZpbmRJbmRleChhbmNob3IpO1xuICAgICAgICB0aGlzLmluZXJzZXRBdChpZHgsIGVsZW0pO1xuICAgIH1cbiAgICBpbnNlcnRBZnRlcihhbmNob3IsIGVsZW0sIG5lZWRXcmFwKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuZmluZEluZGV4KGFuY2hvcik7XG4gICAgICAgIC8vIGNvbnN0IG5leHQgPSB0aGlzLmdldChpZHgrMSk7XG4gICAgICAgIGlmKG5lZWRXcmFwKSB7XG4gICAgICAgICAgICBlbGVtLnNldE5lZWRXcmFwKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5lcnNldEF0KGlkeCsxLCBlbGVtKTtcbiAgICB9XG4gICAgZmluZEluZGV4KGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRFbGVtZW50cy5maW5kSW5kZXgoZWwgPT4gZWwgPT09IGVsZW0pO1xuICAgIH1cbiAgICBnZXQoaWR4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0RWxlbWVudHNbaWR4XTtcbiAgICB9XG4gICAgZnJvbShlbGVtZW50cykge1xuICAgICAgICB0aGlzLl90ZXh0RWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB9XG4gICAgaW5lcnNldEF0KGlkeCwgZWxlbSkge1xuICAgICAgICB0aGlzLnNwbGljZShpZHgsIDAsIGVsZW0pXG4gICAgfVxuICAgIHB1c2goZWxlbSkge1xuICAgICAgICB0aGlzLnNwbGljZSh0aGlzLmxlbmd0aCgpLCAwLCBlbGVtKTtcbiAgICB9XG4gICAgcmVtb3ZlKGlkeCkge1xuICAgICAgICB0aGlzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbiAgICBzcGxpY2UoKSB7XG4gICAgICAgIGNvbnN0IHJlbW92ZWQgPSB0aGlzLl90ZXh0RWxlbWVudHMuc3BsaWNlKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3JlY29yZHMucHVzaCh7XG4gICAgICAgICAgICBvcDogJ3NwbGljZScsXG4gICAgICAgICAgICBhcmdzOiBhcmd1bWVudHMsXG4gICAgICAgICAgICByZW1vdmVkLFxuICAgICAgICB9KVxuICAgIH1cbiAgICBzbGljZSguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0RWxlbWVudHMuc2xpY2UoLi4uYXJncylcbiAgICB9XG4gICAgY29weSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRFbGVtZW50cy5zbGljZSgpO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dEVsZW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLl90ZXh0RWxlbWVudHNbMF0uc291cmNlID09PSAnJztcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl90ZXh0RWxlbWVudHMuZm9yRWFjaChjYWxsYmFjayk7XG4gICAgfVxuICAgIHRhaWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0RWxlbWVudHNbdGhpcy5fdGV4dEVsZW1lbnRzLmxlbmd0aC0xXTtcbiAgICB9XG4gICAgZmlsdGVyKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0RWxlbWVudHMuZmlsdGVyKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dEVsZW1lbnRzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBzdGFydFJlY29yZCgpIHtcbiAgICAgICAgdGhpcy5fY2FyZXRSZWNvcmQgPSB7XG4gICAgICAgICAgICBiZWZvcmU6IG51bGwsXG4gICAgICAgICAgICBhZnRlcjogbnVsbCxcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWNvcmRzID0gW107XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWNvcmRzO1xuICAgIH1cblxuICAgIGdldFJlY29yZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29yZHM7XG4gICAgfVxuXG4gICAgcmVjb3JkQmVmb3JlQ2FyZXQoY2FyZXQpIHtcbiAgICAgICAgdGhpcy5fY2FyZXRSZWNvcmQuYmVmb3JlID0gY2FyZXQudG9SYW5nZSgpO1xuICAgIH1cblxuICAgIHJlY29yZEFmdGVyQ2FyZXQoY2FyZXQpIHtcbiAgICAgICAgdGhpcy5fY2FyZXRSZWNvcmQuYWZ0ZXIgPSBjYXJldC50b1JhbmdlKCk7XG4gICAgfVxuXG4gICAgZ2V0Q2FyZXRSZWNvcmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYXJldFJlY29yZDtcbiAgICB9XG5cbiAgICBjb2xsZWN0UmVjb3JkcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29yZHM7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgVGV4dEVsZW1lbnQge1xuICAgIG5lZWRXcmFwID0gZmFsc2U7XG4gICAgd2lkdGggPSAwO1xuICAgIHJlZHVjZVdpZHRoID0gMDtcbiAgICBoZWlnaHQgPSAwO1xuICAgIGFuY2hvclggPSAwO1xuICAgIGFuY2hvclkgPSAwO1xuICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICBpc1RhaWwgPSBmYWxzZTtcblxuICAgIF9zcGFjZVJlY29yZHMgPSBbXTtcbiAgICBfc3BhY2VkQ29udGVudFNlZ21uZW50ID0gW107XG4gICAgX3JldHVyblN5bWJvbCA9IHtcbiAgICAgICAgc3ltYm9sOiAn4oayJyxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG5cbiAgICBnZXRSZW5kZXJTb3VyY2Uoc3BhY2VIb2xkZXIpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuc291cmNlO1xuICAgICAgICBpZihzcGFjZUhvbGRlci5lbmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50LnJlcGxhY2UoL1xccy9nLCBzcGFjZUhvbGRlci5zcGFjZVBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cblxuICAgIHNldFNvdXJjZVdpdGhSZWNvcmQoc291cmNlLCBzcGFjZUhvbGRlciwgcmVjb3Jkcykge1xuICAgICAgICBjb25zdCBsYXN0U291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICAgIHRoaXMuc2V0U291cmNlKHNvdXJjZSwgc3BhY2VIb2xkZXIpO1xuICAgICAgICBpZihyZWNvcmRzKSB7XG4gICAgICAgICAgICByZWNvcmRzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9wOiAnc2V0U291cmNlJyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbdGhpcywgc291cmNlLCBsYXN0U291cmNlXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0U291cmNlKHNvdXJjZSwgc3BhY2VIb2xkZXIpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICBpZihzcGFjZUhvbGRlci5lbmFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLl9zcGFjZVJlY29yZHM7XG4gICAgICAgICAgICBjb25zdCBwID0gc3BhY2VIb2xkZXIuc3BhY2VQbGFjZWhvbGRlclxuICAgICAgICAgICAgci5sZW5ndGggPSAwO1xuICAgICAgICAgICAgbGV0IGxhc3RPZmZzZXQ7XG4gICAgICAgICAgICBzb3VyY2UucmVwbGFjZSgvXFxzL2csIChfLCBvZmZzZXQpID0+IHtcbiAgICAgICAgICAgICAgICBpZihsYXN0T2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgci5wdXNoKG9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKG9mZnNldCAtIGxhc3RPZmZzZXQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHIucHVzaChsYXN0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgci5wdXNoKG9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBpZihsYXN0T2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByLnB1c2gobGFzdE9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXROZWVkV3JhcChuZWVkV3JhcCwgcmVjb3Jkcykge1xuICAgICAgICBjb25zdCBsYXN0V3JhcCA9IHRoaXMubmVlZFdyYXA7XG4gICAgICAgIHRoaXMubmVlZFdyYXAgPSBuZWVkV3JhcDtcbiAgICAgICAgaWYobGFzdFdyYXAhPT0gbmVlZFdyYXAgJiYgcmVjb3Jkcykge1xuICAgICAgICAgICAgcmVjb3Jkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBvcDogJ3NldE5lZWRXcmFwJyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbdGhpcywgbmVlZFdyYXAsIGxhc3RXcmFwXSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzaGlmdChvZmZzZXQsIHN0ZXApIHtcbiAgICAgICAgaWYodGhpcy50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBjb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IG5leHRPZmZzZXQgPSBvZmZzZXQgKyBzdGVwO1xuICAgICAgICAgICAgaWYobmV4dE9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3ByZXYnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYobmV4dE9mZnNldCA+IGwgKXsvLy0gKChpc1RhaWwgfHwgdGhpcy5uZWVkV3JhcCkgPyAwIDogMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25leHQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdzZWxmJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKHN0ZXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICduZXh0JztcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBpZihzdGVwIDwgMCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdwcmV2JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRhaWxPZmZzZXQoKSB7XG4gICAgICAgIGlmKHRoaXMudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBpZih0aGlzLm5lZWRXcmFwIHx8IHRoaXMuaXNUYWlsKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgdGhpcy5zb3VyY2UubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhlYWRPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHByZUNhbGN1bGF0ZVRleHQoY3R4LCBzcGFjZUhvbGRlcikge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5nZXRSZW5kZXJTb3VyY2Uoc3BhY2VIb2xkZXIpO1xuICAgICAgICB0aGlzLndpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGNvbnRlbnQpLndpZHRoO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIGlmKHNwYWNlSG9sZGVyLmVuYWJsZSkge1xuICAgICAgICAgICAgY29uc3Qgc193aWR0aCA9IGN0eC5tZWFzdXJlVGV4dChzcGFjZUhvbGRlci5zcGFjZVBsYWNlaG9sZGVyKS53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuX3JldHVyblN5bWJvbC53aWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh0aGlzLl9yZXR1cm5TeW1ib2wuc3ltYm9sKS53aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IHIyID0gdGhpcy5fc3BhY2VkQ29udGVudFNlZ21uZW50O1xuICAgICAgICAgICAgbGV0IGxhc3RPZmZzZXQgPSAwO1xuICAgICAgICAgICAgcjIubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGlmKHRoaXMuX3NwYWNlUmVjb3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gdGhpcy5fc3BhY2VSZWNvcmRzOyAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IGwgPSByLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUoaSA8IGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZiA9IHJbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IHJbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcSA9IGNvbnRlbnQuc3Vic3RyaW5nKGxhc3RPZmZzZXQsIGYpO1xuICAgICAgICAgICAgICAgICAgICByMi5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubWVhc3VyZVRleHQocSkud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIHIyLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudC5zdWJzdHJpbmcoZiwgdCsxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0IC0gZiArIDEpICogc193aWR0aCwgIFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BsYWNlaG9sZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgbGFzdE9mZnNldCA9IHQrMVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGxhc3RPZmZzZXQgPCBjb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHEgPSBjb250ZW50LnN1YnN0cmluZyhsYXN0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByMi5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgcSxcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1lYXN1cmVUZXh0KHEpLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAndGV4dCcsXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodGhpcy5uZWVkV3JhcCkge1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggKz0gdGhpcy5fcmV0dXJuU3ltYm9sLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cblxuICAgIHJlbmRlcihjdHgsIHNwYWNlSG9sZGVyLCB0ZXh0Q29sb3IpIHtcbiAgICAgICAgaWYoc3BhY2VIb2xkZXIuZW5hYmxlKSB7XG4gICAgICAgICAgICBjb25zdCBodyA9IHRoaXMud2lkdGgvMjtcbiAgICAgICAgICAgIGxldCBfdyA9ICAtaHcgKyB0aGlzLmFuY2hvclg7XG4gICAgICAgICAgICBjb25zdCBzcGFjZVBsYWNlaG9sZGVyQ29sb3IgPSBzcGFjZUhvbGRlci5zcGFjZVBsYWNlaG9sZGVyQ29sb3I7XG4gICAgICAgICAgICB0aGlzLl9zcGFjZWRDb250ZW50U2VnbW5lbnQuZm9yRWFjaChzZWcgPT4ge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBzZWdbMl0gPT09ICd0ZXh0JyA/IHRleHRDb2xvciA6IHNwYWNlUGxhY2Vob2xkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gc2VnWzFdLzI7XG4gICAgICAgICAgICAgICAgX3cgKz0gdDtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoc2VnWzBdLCBfdywgdGhpcy5hbmNob3JZKTtcbiAgICAgICAgICAgICAgICBfdyArPSB0O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGlmKHRoaXMubmVlZFdyYXApIHtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5mb250ID0gc3BhY2VIb2xkZXIucmV0dXJuRm9udDtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gc3BhY2VQbGFjZWhvbGRlckNvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLl9yZXR1cm5TeW1ib2wuc3ltYm9sLCBcbiAgICAgICAgICAgICAgICAgICAgX3cgKyB0aGlzLl9yZXR1cm5TeW1ib2wud2lkdGgvMiwgdGhpcy5hbmNob3JZKTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuOyAgIFxuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLnNvdXJjZSwgdGhpcy5hbmNob3JYLCB0aGlzLmFuY2hvclkpXG4gICAgfVxufSIsImltcG9ydCB7IFRleHRFbGVtZW50IH0gZnJvbSBcIi4uL3N0b3JhZ2VcIjtcbmNsYXNzIFJhbmdlIHtcbiAgICBfZW5hYmxlID0gZmFsc2U7XG4gICAgX3JhbmdlRnJvbSA9IG51bGw7IC8vIFtyb3csIGVsZW1faWR4LCBvZmZzZXRdXG4gICAgX3JhbmdlVG8gPSBudWxsOyAgIC8vIFtyb3csIGVsZW1faWR4LCBvZmZzZXRdXG4gICAgX2luaXRpYWxSYW5nZSA9IG51bGw7IFxuXG4gICAgc2V0SW5pdGlhbFJhbmdlKGluaXRpYWxSYW5nZSkge1xuICAgICAgICB0aGlzLl9pbml0aWFsUmFuZ2UgPSBpbml0aWFsUmFuZ2U7XG4gICAgfVxuXG4gICAgZ2V0UmFuZ2VGcm9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmFuZ2VGcm9tO1xuICAgIH1cblxuICAgIGdldFJhbmdlVG8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYW5nZVRvO1xuICAgIH1cblxuICAgIGlzRW5hYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5hYmxlO1xuICAgIH1cblxuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgdGhpcy5fZW5hYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgZGlzYWJsZSgpIHtcbiAgICAgICAgdGhpcy5fZW5hYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaGFuZGxlQ2FyZXQoY2FyZXQpIHtcbiAgICAgICAgY29uc3QgW2EsIGIsIGNdID0gdGhpcy5fcmFuZ2VUbztcbiAgICAgICAgY2FyZXQuc2V0Um93KGEpO1xuICAgICAgICBjYXJldC5zZXRDb2x1bW4oW2IsIGNdKTtcbiAgICB9XG5cbiAgICBzZXRSYW5nZShhbm90aGVyKSB7XG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLl9pbml0aWFsUmFuZ2U7XG4gICAgICAgIGlmKHRoaXMuX2NvbXBhcmVSYW5nZShhLCBhbm90aGVyKSkge1xuICAgICAgICAgICAgdGhpcy5fcmFuZ2VGcm9tID0gYTtcbiAgICAgICAgICAgIHRoaXMuX3JhbmdlVG8gPSBhbm90aGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmFuZ2VGcm9tID0gYW5vdGhlcjtcbiAgICAgICAgICAgIHRoaXMuX3JhbmdlVG8gPSBhO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBfY29tcGFyZVJhbmdlKHIxLCByMikge1xuICAgICAgICBpZihyMVswXSA+IHIyWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYocjFbMF0gPT09IHIyWzBdICYmIHIxWzFdID4gcjJbMV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZihyMVswXSA9PT0gcjJbMF0gJiYgcjFbMV0gPT09IHIyWzFdICYmIHIxWzJdID4gcjJbMl0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIFxuICAgIGdldFJhbmdlQ29weShlZGl0b3IpIHtcbiAgICAgICAgaWYodGhpcy5fZW5hYmxlKSB7XG4gICAgICAgICAgICBjb25zdCBhcmVhID0gZWRpdG9yLl9hcmVhO1xuICAgICAgICAgICAgY29uc3QgY2FyZXQgPSBlZGl0b3IuX2NhcmV0O1xuICAgICAgICAgICAgY29uc3QgcmFuZ2VGcm9tID0gdGhpcy5fcmFuZ2VGcm9tO1xuICAgICAgICAgICAgY29uc3QgcmFuZ2VUbyA9IHRoaXMuX3JhbmdlVG87XG4gICAgICAgICAgICBjb25zdCBlbGVtRnJvbSA9IGFyZWEuZ2V0KHJhbmdlRnJvbVswXSkuZ2V0KHJhbmdlRnJvbVsxXSk7XG4gICAgICAgICAgICBjb25zdCBlbGVtVG8gPSBhcmVhLmdldChyYW5nZVRvWzBdKS5nZXQocmFuZ2VUb1sxXSk7XG4gICAgICAgICAgICBpZihlbGVtRnJvbSA9PT0gZWxlbVRvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IGVsZW1Gcm9tLnNvdXJjZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYy5zdWJzdHJpbmcocmFuZ2VGcm9tWzJdLCByYW5nZVRvWzJdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZmxhdHRlblR4dEVsZW0gPSBlZGl0b3IuX2ZsYXR0ZW5UeHRFbGVtXG4gICAgICAgICAgICBsZXQgcHJlQ29udGVudCA9ICcnO1xuICAgICAgICAgICAgbGV0IGFmdGVyQ29udGVudCA9ICcnO1xuICAgICAgICAgICAgY29uc3QgZnJvbUlkeCA9IGZsYXR0ZW5UeHRFbGVtLmZpbmRJbmRleChlbGVtRnJvbSk7XG4gICAgICAgICAgICBjb25zdCB0b0lkeCA9IGZsYXR0ZW5UeHRFbGVtLmZpbmRJbmRleChlbGVtVG8pO1xuICAgICAgICAgICAgY29uc3QgZWxlbXMgPSBmbGF0dGVuVHh0RWxlbS5zbGljZShmcm9tSWR4LCB0b0lkeCsxKTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gZWxlbXMuc2xpY2UoMSwgZWxlbXMubGVuZ3RoLTEpLmZpbHRlcigoZWwpID0+IGVsLnR5cGUgPT09ICd0ZXh0Jyk7XG4gICAgICAgICAgICBwcmVDb250ZW50ID0gZWxlbUZyb20uc291cmNlLnN1YnN0cmluZyhyYW5nZUZyb21bMl0pO1xuICAgICAgICAgICAgYWZ0ZXJDb250ZW50ID0gZWxlbVRvLnNvdXJjZS5zdWJzdHJpbmcoMCwgcmFuZ2VUb1syXSk7XG4gICAgICAgICAgICBsZXQgY29udGVudCA9IHByZUNvbnRlbnQ7XG4gICAgICAgICAgICBpZihlbGVtRnJvbS5uZWVkV3JhcCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gJ1xcbidcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gZWwuc291cmNlXG4gICAgICAgICAgICAgICAgaWYoZWwubmVlZFdyYXApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCArPSAnXFxuJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQgKyBhZnRlckNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWxldGUoZWRpdG9yLCByZWNvcmRzKSB7XG4gICAgICAgIGlmKHRoaXMuX2VuYWJsZSkge1xuICAgICAgICAgICAgY29uc3QgYXJlYSA9IGVkaXRvci5fYXJlYTtcbiAgICAgICAgICAgIGNvbnN0IGNhcmV0ID0gZWRpdG9yLl9jYXJldDtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlRnJvbSA9IHRoaXMuX3JhbmdlRnJvbTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlVG8gPSB0aGlzLl9yYW5nZVRvO1xuICAgICAgICAgICAgY29uc3QgZWxlbUZyb20gPSBhcmVhLmdldChyYW5nZUZyb21bMF0pLmdldChyYW5nZUZyb21bMV0pO1xuICAgICAgICAgICAgY29uc3QgZWxlbVRvID0gYXJlYS5nZXQocmFuZ2VUb1swXSkuZ2V0KHJhbmdlVG9bMV0pO1xuICAgICAgICAgICAgbGV0IFtyb3csIGVsZW1faWR4LCBvZmZzZXRdID0gcmFuZ2VGcm9tO1xuICAgICAgICAgICAgcmVjb3Jkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBvcDogJ3JhbmdlJyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbcmFuZ2VGcm9tLnNsaWNlKCksIHJhbmdlVG8uc2xpY2UoKV0sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgaWYoZWxlbUZyb20gPT09IGVsZW1Ubykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBlbGVtRnJvbS5zb3VyY2U7XG4gICAgICAgICAgICAgICAgZWxlbUZyb20uc2V0U291cmNlV2l0aFJlY29yZChcbiAgICAgICAgICAgICAgICAgICAgYy5zdWJzdHJpbmcoMCwgcmFuZ2VGcm9tWzJdKSArIGMuc3Vic3RyaW5nKHJhbmdlVG9bMl0pLCBcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNwYWNlSG9sZGVyLFxuICAgICAgICAgICAgICAgICAgICByZWNvcmRzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmxhdHRlblR4dEVsZW0gPSBlZGl0b3IuX2ZsYXR0ZW5UeHRFbGVtXG4gICAgICAgICAgICAgICAgbGV0IHByZUNvbnRlbnQgPSAnJztcbiAgICAgICAgICAgICAgICBsZXQgYWZ0ZXJDb250ZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgbGV0IHByZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgbGV0IGFmdGVyRWxlbWVudDsgIFxuICAgICAgICAgICAgICAgIGNvbnN0IGZyb21JZHggPSBmbGF0dGVuVHh0RWxlbS5maW5kSW5kZXgoZWxlbUZyb20pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvSWR4ID0gZmxhdHRlblR4dEVsZW0uZmluZEluZGV4KGVsZW1Ubyk7XG4gICAgICAgICAgICAgICAgbGV0IGVuZFRleHROZWVkV3JhcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmKGVsZW1Gcm9tLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBwcmVDb250ZW50ID0gZWxlbUZyb20uc291cmNlLnN1YnN0cmluZygwLCByYW5nZUZyb21bMl0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZUVsZW1lbnQgPSBmbGF0dGVuVHh0RWxlbS5nZXQoZnJvbUlkeC0xKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihlbGVtVG8udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyQ29udGVudCA9IGVsZW1Uby5zb3VyY2Uuc3Vic3RyaW5nKHJhbmdlVG9bMl0pO1xuICAgICAgICAgICAgICAgICAgICBlbmRUZXh0TmVlZFdyYXAgPSBlbGVtVG8ubmVlZFdyYXA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJFbGVtZW50ID0gZmxhdHRlblR4dEVsZW0uZ2V0KHRvSWR4LTEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKHByZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhdHRlblR4dEVsZW0uc3BsaWNlKGZyb21JZHgsIHRvSWR4LWZyb21JZHgrMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHByZUVsZW1lbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwcmVFbGVtZW50Lm5lZWRXcmFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93IC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1faWR4IC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBwcmVFbGVtZW50LnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVFbGVtZW50LnNldFNvdXJjZVdpdGhSZWNvcmQocHJlRWxlbWVudC5zb3VyY2UgKyBhZnRlckNvbnRlbnQsIGVkaXRvci5zcGFjZUhvbGRlciwgcmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVFbGVtZW50LnNldE5lZWRXcmFwKGVuZFRleHROZWVkV3JhcCwgcmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gbmV3IFRleHRFbGVtZW50KCd0ZXh0JywgcHJlQ29udGVudCArIGFmdGVyQ29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LnNldE5lZWRXcmFwKGVuZFRleHROZWVkV3JhcCwgcmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGF0dGVuVHh0RWxlbS5zcGxpY2UoZnJvbUlkeCwgMCwgdClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5UeHRFbGVtLnNwbGljZShmcm9tSWR4LCB0b0lkeC1mcm9tSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYoYWZ0ZXJFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gbmV3IFRleHRFbGVtZW50KCd0ZXh0JywgcHJlQ29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGF0dGVuVHh0RWxlbS5zcGxpY2UoZnJvbUlkeCwgMCwgdCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtVG8uc2V0U291cmNlV2l0aFJlY29yZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVDb250ZW50ICsgYWZ0ZXJDb250ZW50LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc3BhY2VIb2xkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoZmxhdHRlblR4dEVsZW0ubGVuZ3RoKCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxlbV9pZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICBmbGF0dGVuVHh0RWxlbS5wdXNoKG5ldyBUZXh0RWxlbWVudCgndGV4dCcsICcnKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2FyZXQuc2V0Um93KHJvdyk7XG4gICAgICAgICAgICBjYXJldC5zZXRDb2x1bW4oW2VsZW1faWR4LCBvZmZzZXRdKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IFJhbmdlOyIsIlxuZnVuY3Rpb24gaXNTZXRTb3VyY2VCYXRjaCh4KSB7XG4gICAgcmV0dXJuIHgubGVuZ3RoID09PSAxICYmIHhbMF0ub3AgPT09ICdzZXRTb3VyY2UnO1xufVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVW5kb1JlZG8ge1xuICAgIHN0YXRpYyBfbGVuZ3RoID0gNTA7XG4gICAgX3VuZG8gPSBbXTtcbiAgICBfcmVkbyA9IFtdO1xuICAgIF9lZGl0b3IgPSBudWxsO1xuXG4gICAgd3JpdGUoeCwgY2FyZXRSZWNvcmQpIHtcbiAgICAgICAgaWYoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZihpc1NldFNvdXJjZUJhdGNoKHgpKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0geFswXTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RVbmRvID0gdGhpcy5nZXRMYXN0VW5kbygpO1xuICAgICAgICAgICAgaWYobGFzdFVuZG8gJiYgaXNTZXRTb3VyY2VCYXRjaChsYXN0VW5kby5fYmF0Y2gpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcSA9IGxhc3RVbmRvLl9iYXRjaFswXTtcbiAgICAgICAgICAgICAgICBpZihxLmFyZ3NbMF0gPT09IHQuYXJnc1swXSkge1xuICAgICAgICAgICAgICAgICAgICBxLmFyZ3NbMV0gPSB0LmFyZ3NbMV07XG4gICAgICAgICAgICAgICAgICAgIGxhc3RVbmRvLl9jYXJldE1ldGFUbyA9IGNhcmV0UmVjb3JkLmFmdGVyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHIgPSBuZXcgQmF0Y2hBY3Rpb24oeCk7XG4gICAgICAgIHIuX2NhcmV0TWV0YUZyb20gPSBjYXJldFJlY29yZC5iZWZvcmU7XG4gICAgICAgIHIuX2NhcmV0TWV0YVRvID0gY2FyZXRSZWNvcmQuYWZ0ZXI7XG4gICAgICAgIHRoaXMuX3VuZG8ucHVzaChyKTtcbiAgICAgICAgXG4gICAgICAgIGlmKHRoaXMuX3VuZG8ubGVuZ3RoID4gVW5kb1JlZG8uX2xlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fdW5kby5zcGxpY2UoMCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5fcmVkby5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlZG8gPSBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldExhc3RVbmRvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdW5kb1t0aGlzLl91bmRvLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIHVuZG8oKSB7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLl91bmRvLnBvcCgpO1xuICAgICAgICBpZih4KSB7XG4gICAgICAgICAgICB4LnVuZG8odGhpcy5fZWRpdG9yKVxuICAgICAgICAgICAgdGhpcy5fcmVkby5wdXNoKHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIHJlZG8oKSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy5fcmVkby5wb3AoKTtcbiAgICAgICAgd2hpbGUoeCAmJiB4LlNLSVBfUkVETykge1xuICAgICAgICAgICAgeCA9IHRoaXMuX3JlZG8ucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCkge1xuICAgICAgICAgICAgeC5yZWRvKHRoaXMuX2VkaXRvcilcbiAgICAgICAgICAgIHRoaXMuX3VuZG8ucHVzaCh4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG59XG5cbmNsYXNzIEJhdGNoQWN0aW9uIHtcbiAgICBfYmF0Y2ggPSBbXTtcbiAgICBfY2FyZXRNZXRhRnJvbSA9IG51bGw7XG4gICAgX2NhcmV0TWV0YVRvID0gbnVsbDtcbiAgICBjb25zdHJ1Y3RvcihiYXRjaCkge1xuICAgICAgICB0aGlzLl9iYXRjaCA9IGJhdGNoO1xuICAgIH1cblxuICAgIHVwZGF0ZUNhcmV0TWV0YVRvKG1ldGEpIHtcbiAgICAgICAgdGhpcy5fY2FyZXRNZXRhVG8gPSBtZXRhO1xuICAgIH1cblxuICAgIHVuZG8oZWRpdG9yKSB7XG4gICAgICAgIHRoaXMuX2JhdGNoLnNsaWNlKCkucmV2ZXJzZSgpLmZvckVhY2goYWN0aW9uID0+IHtcbiAgICAgICAgICAgIHN3aXRjaChhY3Rpb24ub3ApIHtcbiAgICAgICAgICAgICAgICBjYXNlICdyYW5nZSc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtyYW5nZUZyb20sIHJhbmdlVG9dID0gYWN0aW9uLmFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZWRpdG9yLl9yYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0SW5pdGlhbFJhbmdlKHJhbmdlRnJvbSk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldFJhbmdlKHJhbmdlVG8pO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5lbmFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2V0U291cmNlJzpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2VsZW0sIHMsIGxzXSA9IGFjdGlvbi5hcmdzO1xuICAgICAgICAgICAgICAgICAgICBlbGVtLnNldFNvdXJjZShscywgZWRpdG9yLnNwYWNlSG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2V0TmVlZFdyYXAnOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbbywgcCwgcV0gPSBhY3Rpb24uYXJncztcbiAgICAgICAgICAgICAgICAgICAgby5uZWVkV3JhcCA9IHE7XG4gICAgICAgICAgICAgICAgICAgIG8uZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbGF0dGVuVHh0RWxlbSA9IGVkaXRvci5fZmxhdHRlblR4dEVsZW07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFthLCBiLCAuLi5jXSA9IGFjdGlvbi5hcmdzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1vdmVkID0gYWN0aW9uLnJlbW92ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gMFxuICAgICAgICAgICAgICAgICAgICBpZihjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gYy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmbGF0dGVuVHh0RWxlbS5zcGxpY2UoYSwgaSwgLi4ucmVtb3ZlZCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBlZGl0b3IuX2NhcmV0LmZyb21SYW5nZSh0aGlzLl9jYXJldE1ldGFGcm9tKTtcbiAgICB9XG5cbiAgICByZWRvKGVkaXRvcikge1xuICAgICAgICB0aGlzLl9iYXRjaC5mb3JFYWNoKGFjdGlvbiA9PiB7XG4gICAgICAgICAgICBzd2l0Y2goYWN0aW9uLm9wKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2V0U291cmNlJzpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2VsZW0sIHMsIGxzXSA9IGFjdGlvbi5hcmdzO1xuICAgICAgICAgICAgICAgICAgICBlbGVtLnNldFNvdXJjZShzLCBlZGl0b3Iuc3BhY2VIb2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzZXROZWVkV3JhcCc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtvLCBwLCBxXSA9IGFjdGlvbi5hcmdzO1xuICAgICAgICAgICAgICAgICAgICBvLm5lZWRXcmFwID0gcDtcbiAgICAgICAgICAgICAgICAgICAgby5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZsYXR0ZW5UeHRFbGVtID0gZWRpdG9yLl9mbGF0dGVuVHh0RWxlbTtcbiAgICAgICAgICAgICAgICAgICAgZmxhdHRlblR4dEVsZW0uc3BsaWNlKC4uLmFjdGlvbi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIGVkaXRvci5fY2FyZXQuZnJvbVJhbmdlKHRoaXMuX2NhcmV0TWV0YVRvKTtcbiAgICB9XG59IiwiY2xhc3MgQ29tbWFuZCB7XG4gICAgc3RhdGljIGNyZWF0ZShlZGl0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKGVkaXRvcilcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihlZGl0b3IpIHtcbiAgICAgICAgdGhpcy5fZWRpdG9yID0gZWRpdG9yO1xuICAgIH1cblxuICAgIGV4ZWMoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb21tYW5kOyIsImltcG9ydCBDb21tYW5kIGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgeyBLRVlCT0FSRF9DT01NQU5EUyB9IGZyb20gJy4uL2Jhc2UvY29uc3RhbnRzJztcblxuZXhwb3J0IGNsYXNzIEFycm93TGVmdENvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgICBzdGF0aWMgX25hbWUgPSBLRVlCT0FSRF9DT01NQU5EUy5BUlJPV19MRUZUO1xuXG4gICAgZXhlYygpIHtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5fZWRpdG9yO1xuICAgICAgICBlZGl0b3IuX3JhbmdlLmRpc2FibGUoKTtcbiAgICAgICAgY29uc3QgZmxhdHRlblR4dEVsZW0gPSBlZGl0b3IuX2ZsYXR0ZW5UeHRFbGVtXG4gICAgICAgIGNvbnN0IGNhcmV0ID0gZWRpdG9yLl9jYXJldDtcbiAgICAgICAgY29uc3Qgcm93ID0gY2FyZXQuZ2V0Um93KCk7XG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IGNhcmV0LmdldENvbHVtbigpO1xuICAgICAgICBjb25zdCBbZWxlbWlkeCwgb2Zmc2V0XSA9IGNvbHVtbjtcbiAgICAgICAgY29uc3QgbGluZSA9IGVkaXRvci5fYXJlYS5nZXQocm93KTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGxpbmUuZ2V0KGVsZW1pZHgpO1xuICAgICAgICBjb25zdCBpZHggPSBmbGF0dGVuVHh0RWxlbS5maW5kSW5kZXgoZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGVsZW1lbnQuc2hpZnQob2Zmc2V0LCAtMSk7XG4gICAgICAgIHN3aXRjaChyZXN1bHQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3ByZXYnOlxuICAgICAgICAgICAgICAgIGlmKGVsZW1pZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gbGluZS5nZXQoZWxlbWlkeCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBjYXJldC5zZXRDb2x1bW4oW2VsZW1pZHggLSAxLCBlbC50YWlsT2Zmc2V0KCldKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihpZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZVJvdyA9IHJvdyAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZUVsZW1pZHggPSBlZGl0b3IuX2FyZWEuZ2V0KHByZVJvdykubGVuZ3RoKCkgLSAxXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGZsYXR0ZW5UeHRFbGVtLmdldChpZHgtMSkudGFpbE9mZnNldCgpO1xuICAgICAgICAgICAgICAgICAgICBjYXJldC5zZXRSb3cocHJlUm93KTtcbiAgICAgICAgICAgICAgICAgICAgY2FyZXQuc2V0Q29sdW1uKFtwcmVFbGVtaWR4LCBvZmZzZXRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWxmJzpcbiAgICAgICAgICAgICAgICBjYXJldC5zZXRDb2x1bW4oMSwgb2Zmc2V0IC0gMSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXJldC5yZWZyZXNoKCk7XG4gICAgICAgIGVkaXRvci5zeW5jU2hhZG93SW5wdXRQb3NpdGlvbigpO1xuICAgICAgICBlZGl0b3IuX2pmbG93Ll9yZW5kZXIoKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQXJyb3dSaWdodENvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgICBzdGF0aWMgX25hbWUgPSBLRVlCT0FSRF9DT01NQU5EUy5BUlJPV19SSUdIVDtcblxuICAgIGV4ZWMoKSB7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuX2VkaXRvcjtcbiAgICAgICAgZWRpdG9yLl9yYW5nZS5kaXNhYmxlKCk7XG4gICAgICAgIGNvbnN0IGZsYXR0ZW5UeHRFbGVtID0gZWRpdG9yLl9mbGF0dGVuVHh0RWxlbVxuICAgICAgICBjb25zdCBjYXJldCA9IGVkaXRvci5fY2FyZXQ7XG4gICAgICAgIGNvbnN0IHJvdyA9IGNhcmV0LmdldFJvdygpO1xuICAgICAgICBjb25zdCBjb2x1bW4gPSBjYXJldC5nZXRDb2x1bW4oKTtcbiAgICAgICAgY29uc3QgW2VsZW1pZHgsIG9mZnNldF0gPSBjb2x1bW47XG4gICAgICAgIGNvbnN0IGxpbmUgPSBlZGl0b3IuX2FyZWEuZ2V0KHJvdyk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBsaW5lLmdldChlbGVtaWR4KTtcbiAgICAgICAgY29uc3QgaWR4ID0gZmxhdHRlblR4dEVsZW0uZmluZEluZGV4KGVsZW1lbnQpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBlbGVtZW50LnNoaWZ0KG9mZnNldCwgMSwgaWR4ID09PSBmbGF0dGVuVHh0RWxlbS5sZW5ndGgoKS0xKTtcbiAgICAgICAgc3dpdGNoKHJlc3VsdCkge1xuICAgICAgICAgICAgY2FzZSAnbmV4dCc6XG4gICAgICAgICAgICAgICAgaWYoZWxlbWlkeCA8IGxpbmUubGVuZ3RoKCktMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGxpbmUuZ2V0KGVsZW1pZHggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoZWxlbWVudC50eXBlID09PSAndGV4dCcgJiYgZWwudHlwZSAhPT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldC5zZXRDb2x1bW4oW2VsZW1pZHggKyAyLCBlbC5oZWFkT2Zmc2V0KCldKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXQuc2V0Q29sdW1uKFtlbGVtaWR4ICsgMSwgZWwuaGVhZE9mZnNldCgpXSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihpZHggPCBmbGF0dGVuVHh0RWxlbS5sZW5ndGgoKS0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyUm93ID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZmxhdHRlblR4dEVsZW0uZ2V0KGlkeCArIDEpLmhlYWRPZmZzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FyZXQuc2V0Um93KGFmdGVyUm93KTtcbiAgICAgICAgICAgICAgICAgICAgY2FyZXQuc2V0Q29sdW1uKFswLCBvZmZzZXRdKTtcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWxmJzpcbiAgICAgICAgICAgICAgICBjYXJldC5zZXRDb2x1bW4oMSwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjYXJldC5yZWZyZXNoKCk7XG4gICAgICAgIGVkaXRvci5zeW5jU2hhZG93SW5wdXRQb3NpdGlvbigpO1xuICAgICAgICBlZGl0b3IuX2pmbG93Ll9yZW5kZXIoKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQXJyb3dVcENvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgICBzdGF0aWMgX25hbWUgPSBLRVlCT0FSRF9DT01NQU5EUy5BUlJPV19VUDtcblxuICAgIGV4ZWMoKSB7XG4gICAgICAgIHRoaXMuX2VkaXRvci5fcmFuZ2UuZGlzYWJsZSgpO1xuICAgICAgICBjb25zdCBuZXh0Um93ID0gdGhpcy5fZWRpdG9yLl9jYXJldC5nZXRSb3coKSAtIDE7XG4gICAgICAgIGlmKG5leHRSb3cgPiAtMSl7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyKG5leHRSb3cpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFycm93RG93bkNvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgICBzdGF0aWMgX25hbWUgPSBLRVlCT0FSRF9DT01NQU5EUy5BUlJPV19ET1dOO1xuXG4gICAgZXhlYygpIHtcbiAgICAgICAgdGhpcy5fZWRpdG9yLl9yYW5nZS5kaXNhYmxlKCk7XG4gICAgICAgIGNvbnN0IG5leHRSb3cgPSB0aGlzLl9lZGl0b3IuX2NhcmV0LmdldFJvdygpICsgMTtcbiAgICAgICAgaWYobmV4dFJvdyA8IHRoaXMuX2VkaXRvci5fYXJlYS5sZW5ndGgoKSl7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyKG5leHRSb3cpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgX21peGluID0ge1xuICAgIF9oYW5kbGVyKG5leHRSb3cpIHtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5fZWRpdG9yO1xuICAgICAgICBjb25zdCBjYXJldCA9IGVkaXRvci5fY2FyZXQ7XG4gICAgICAgIGNvbnN0IHJvdyA9IGNhcmV0LmdldFJvdygpO1xuICAgICAgICBjb25zdCBjb2x1bW4gPSBjYXJldC5nZXRDb2x1bW4oKTtcbiAgICAgICAgY29uc3QgW2VsZW1pZHgsIG9mZnNldF0gPSBjb2x1bW47XG4gICAgICAgIGNvbnN0IGFyZWEgPSBlZGl0b3IuX2FyZWE7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBhcmVhLmdldChyb3cpO1xuICAgICAgICBsZXQgY3VyckVsZW0gPSBsaW5lLmdldChlbGVtaWR4KTtcbiAgICAgICAgbGV0IGN1cnJFbGVtUmVkdWNlV2lkdGggPSBjdXJyRWxlbS5yZWR1Y2VXaWR0aDtcbiAgICAgICAgaWYob2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgY3VyckVsZW1SZWR1Y2VXaWR0aCArPSBlZGl0b3IubWVhc3VyZVRleHRXaWR0aChjdXJyRWxlbS5nZXRSZW5kZXJTb3VyY2UoZWRpdG9yLnNwYWNlSG9sZGVyKS5zdWJzdHJpbmcoMCwgb2Zmc2V0KSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgbmV4dExpbmUgPSBhcmVhLmdldChuZXh0Um93KTtcbiAgICAgICAgY29uc3QgbmV4dENvbHVtbiA9IG5leHRMaW5lLmdldENvbHVtbk5lYXJlc3QoY3VyckVsZW1SZWR1Y2VXaWR0aCwgZWRpdG9yLmVsZW1lbnRTcGFjZSwgZWRpdG9yLmZvbnRTaXplLCBlZGl0b3IuZm9udEZhbWlseSwgZWRpdG9yKVxuICAgICAgICBjYXJldC5zZXRSb3cobmV4dFJvdyk7XG4gICAgICAgIGNhcmV0LnNldENvbHVtbihuZXh0Q29sdW1uKTtcbiAgICAgICAgXG4gICAgICAgIGNhcmV0LnJlZnJlc2goKTtcbiAgICAgICAgZWRpdG9yLnN5bmNTaGFkb3dJbnB1dFBvc2l0aW9uKCk7XG4gICAgICAgIGVkaXRvci5famZsb3cuX3JlbmRlcigpO1xuICAgIH1cbn1cblxuT2JqZWN0LmFzc2lnbihBcnJvd1VwQ29tbWFuZC5wcm90b3R5cGUsIF9taXhpbik7XG5PYmplY3QuYXNzaWduKEFycm93RG93bkNvbW1hbmQucHJvdG90eXBlLCBfbWl4aW4pOyIsImltcG9ydCBDb21tYW5kIGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgeyBUZXh0RWxlbWVudCB9IGZyb20gJy4uL3N0b3JhZ2UnO1xuaW1wb3J0IHsgRURJVE9SX0VWRU5UUywgS0VZQk9BUkRfSU5QVVQgfSBmcm9tICcuLi9iYXNlL2NvbnN0YW50cyc7XG5mdW5jdGlvbiBfYmxhbmRBZGphY2VudEVsZW1lbnQoZWRpdG9yLCBlbGVtMSwgZWxlbTIsIGRlZmF1bHRPZmZzZXQsIHJlY29yZHMpIHtcbiAgICBpZighZWxlbTEpIHtcbiAgICAgICAgcmV0dXJuIFtkZWZhdWx0T2Zmc2V0LCBmYWxzZV07XG4gICAgfVxuICAgIGlmKGVsZW0xLnR5cGUgPT09ICd0ZXh0JyAmJiBlbGVtMi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZWxlbTEuc291cmNlLmxlbmd0aDtcbiAgICAgICAgZWxlbTEuc2V0U291cmNlV2l0aFJlY29yZChlbGVtMS5zb3VyY2UgKyBlbGVtMi5zb3VyY2UsIGVkaXRvci5zcGFjZUhvbGRlciwgcmVjb3Jkcyk7XG4gICAgICAgIGVsZW0xLnNldE5lZWRXcmFwKGVsZW0yLm5lZWRXcmFwLCByZWNvcmRzKVxuICAgICAgICByZXR1cm4gW29mZnNldCwgdHJ1ZV07XG4gICAgfVxuICAgIHJldHVybiBbZGVmYXVsdE9mZnNldCwgZmFsc2VdO1xufVxuXG5leHBvcnQgY2xhc3MgSW5wdXQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgICBzdGF0aWMgX25hbWUgPSBFRElUT1JfRVZFTlRTLklOUFVUO1xuXG4gICAgY2FjaGVJZHggPSBudWxsO1xuXG4gICAgZXhlYyhraW5kLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuX2VkaXRvcjtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBlZGl0b3IuX3JhbmdlO1xuICAgICAgICBjb25zdCBjYXJldCA9IGVkaXRvci5fY2FyZXQ7XG4gICAgICAgIGNvbnN0IGZsYXR0ZW5UeHRFbGVtID0gZWRpdG9yLl9mbGF0dGVuVHh0RWxlbTtcbiAgICAgICAgY29uc3QgdW5kb3JlZG8gPSBlZGl0b3IuX3VuZG9yZWRvO1xuICAgICAgICBjb25zdCByZWNvcmRzID0gZmxhdHRlblR4dEVsZW0uc3RhcnRSZWNvcmQoKTtcbiAgICAgICAgZmxhdHRlblR4dEVsZW0ucmVjb3JkQmVmb3JlQ2FyZXQoY2FyZXQpO1xuICAgICAgICAvLyBsZXQgX2FmdGVyUmFuZ2VEZWxldGUgPSBmYWxzZTtcbiAgICAgICAgaWYocmFuZ2UuaXNFbmFibGUoKSkge1xuICAgICAgICAgICAgcmFuZ2UuZGVsZXRlKGVkaXRvciwgcmVjb3Jkcyk7XG4gICAgICAgICAgICBpZihraW5kID09PSBLRVlCT0FSRF9JTlBVVC5CQUNLU1BBQ0UgfHwga2luZCA9PT0gS0VZQk9BUkRfSU5QVVQuREVMRVRFKSB7XG4gICAgICAgICAgICAgICAgZmxhdHRlblR4dEVsZW0uY29sbGVjdFJlY29yZHMoKTtcbiAgICAgICAgICAgICAgICBmbGF0dGVuVHh0RWxlbS5yZWNvcmRBZnRlckNhcmV0KGNhcmV0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lZGl0b3IucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIHVuZG9yZWRvLndyaXRlKHJlY29yZHMsIGZsYXR0ZW5UeHRFbGVtLmdldENhcmV0UmVjb3JkKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZWRpdG9yLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICAvLyBfYWZ0ZXJSYW5nZURlbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJvdyA9IGNhcmV0LmdldFJvdygpO1xuICAgICAgICBsZXQgW2VsZW1faWR4LCBvZmZzZXRdID0gY2FyZXQuZ2V0Q29sdW1uKCk7XG4gICAgICAgIGNvbnN0IGFyZWEgPSBlZGl0b3IuX2FyZWE7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBhcmVhLmdldChyb3cpO1xuICAgICAgICBsZXQgZWxlbWVudCA9IGxpbmUuZ2V0KGVsZW1faWR4KTtcbiAgICAgICAgbGV0IHByZUVsZW0gPSBsaW5lLmdldChlbGVtX2lkeC0xKTtcbiAgICAgICAgXG4gICAgICAgIGxldCBjb250ZW50ID0gJyc7XG4gICAgICAgIGlmKGVsZW1lbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gZWxlbWVudC5zb3VyY2U7XG4gICAgICAgIH0gZWxzZSBpZihwcmVFbGVtPy50eXBlID09PSd0ZXh0Jyl7XG4gICAgICAgICAgICBjb250ZW50ID0gcHJlRWxlbS5zb3VyY2U7XG4gICAgICAgICAgICBlbGVtZW50ID0gcHJlRWxlbTtcbiAgICAgICAgICAgIG9mZnNldCA9IGNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgZWxlbV9pZHggLT0gMTtcbiAgICAgICAgICAgIGNhcmV0LnNldENvbHVtbihbZWxlbV9pZHgsIGNvbnRlbnQubGVuZ3RoXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuZXdFbGVtZW50ID0gbmV3IFRleHRFbGVtZW50KCd0ZXh0JywgJycpO1xuICAgICAgICAgICAgZmxhdHRlblR4dEVsZW0uaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIG5ld0VsZW1lbnQpO1xuICAgICAgICAgICAgZWxlbWVudCA9IG5ld0VsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcHJlQ29udGVudCA9IGNvbnRlbnQuc3Vic3RyaW5nKDAsIG9mZnNldCk7XG4gICAgICAgIGxldCBhZnRlckNvbnRlbnQgXG4gICAgICAgIGlmKHRoaXMuY2FjaGVJZHgpIHtcbiAgICAgICAgICAgIGFmdGVyQ29udGVudCA9IGNvbnRlbnQuc3Vic3RyaW5nKHRoaXMuY2FjaGVJZHhbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWZ0ZXJDb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcob2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaChraW5kKXtcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfSU5QVVQuSU5QVVQ6XG4gICAgICAgICAgICAgICAgLy8gaWYoX2FmdGVyUmFuZ2VEZWxldGUpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgZWxlbWVudCA9IGZsYXR0ZW5UeHRFbGVtLmdldCgwKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgYWZ0ZXJDb250ZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgLy8gICAgIHByZUNvbnRlbnQgPSAnJztcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYoL1xccj9bXFxuXFx0XS8udGVzdChkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcm93cyA9IGRhdGEuc3BsaXQoL1xccj9bXFxuXFx0XS8pIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAvLyBzb3VyY2UgPSBzb3VyY2UucmVwbGFjZSgvXFx0LywgJycpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZHggPSBmbGF0dGVuVHh0RWxlbS5maW5kSW5kZXgoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3ROZWVkV3JhcCA9IGVsZW1lbnQubmVlZFdyYXA7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0U291cmNlV2l0aFJlY29yZChwcmVDb250ZW50ICsgcm93cy5zaGlmdCgpLCBlZGl0b3Iuc3BhY2VIb2xkZXIsIHJlY29yZHMpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNldE5lZWRXcmFwKHRydWUsIHJlY29yZHMpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZW1wID0gW107XG4gICAgICAgICAgICAgICAgICAgIGxldCB0bjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IF9yb3cgPSByb3c7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2w7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKHJvd3MubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRuID0gbmV3IFRleHRFbGVtZW50KCd0ZXh0Jywgcm93cy5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRuLm5lZWRXcmFwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAucHVzaCh0bik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcm93Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29sID0gdG4uc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdG4uc291cmNlICs9IGFmdGVyQ29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgdG4ubmVlZFdyYXAgPSBsYXN0TmVlZFdyYXA7XG4gICAgICAgICAgICAgICAgICAgIHRlbXAuZm9yRWFjaCgodCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhdHRlblR4dEVsZW0uaW5lcnNldEF0KGlkeCArIDEgKyBpLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNhcmV0LnNldFJvdyhfcm93KTtcbiAgICAgICAgICAgICAgICAgICAgY2FyZXQuc2V0Q29sdW1uKFswLCBjb2xdKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZUNvbnRlbnQgKz0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgY2FyZXQuc2V0Q29sdW1uKDEsIGNhcmV0LmdldENvbHVtbigxKSArIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZXRTb3VyY2VXaXRoUmVjb3JkKHByZUNvbnRlbnQgKyBhZnRlckNvbnRlbnQsIGVkaXRvci5zcGFjZUhvbGRlciwgcmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9JTlBVVC5DT01QT1NJVElPTl9TVEFSVDpcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlSWR4ID0gW3ByZUNvbnRlbnQubGVuZ3RoLCBwcmVDb250ZW50Lmxlbmd0aF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0lOUFVULkNPTVBPU0lUSU9OX1VQREFURTpcbiAgICAgICAgICAgICAgICBwcmVDb250ZW50ID0gcHJlQ29udGVudC5zdWJzdHJpbmcoMCwgdGhpcy5jYWNoZUlkeFswXSk7XG4gICAgICAgICAgICAgICAgcHJlQ29udGVudCArPSBkYXRhO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0U291cmNlV2l0aFJlY29yZChwcmVDb250ZW50ICsgYWZ0ZXJDb250ZW50LCBlZGl0b3Iuc3BhY2VIb2xkZXIsIHJlY29yZHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IF90ID0gdGhpcy5jYWNoZUlkeFswXSArIGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNhcmV0LnNldENvbHVtbigxLCBfdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZUlkeFsxXSA9IF90O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLRVlCT0FSRF9JTlBVVC5DT01QT1NJVElPTl9FTkQ6XG4gICAgICAgICAgICAgICAgcHJlQ29udGVudCA9IHByZUNvbnRlbnQuc3Vic3RyaW5nKDAsIHRoaXMuY2FjaGVJZHhbMF0pO1xuICAgICAgICAgICAgICAgIGNhcmV0LnNldENvbHVtbigxLCB0aGlzLmNhY2hlSWR4WzBdICsgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVJZHggPSBudWxsO1xuICAgICAgICAgICAgICAgIHByZUNvbnRlbnQgKz0gZGF0YTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNldFNvdXJjZVdpdGhSZWNvcmQocHJlQ29udGVudCArIGFmdGVyQ29udGVudCwgZWRpdG9yLnNwYWNlSG9sZGVyLCByZWNvcmRzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS0VZQk9BUkRfSU5QVVQuRU5URVI6XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdE5lZWRXcmFwID0gZWxlbWVudC5uZWVkV3JhcDtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNldFNvdXJjZVdpdGhSZWNvcmQocHJlQ29udGVudCwgZWRpdG9yLnNwYWNlSG9sZGVyLCByZWNvcmRzKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNldE5lZWRXcmFwKHRydWUsIHJlY29yZHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBuZXcgVGV4dEVsZW1lbnQoJ3RleHQnLCBhZnRlckNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGZsYXR0ZW5UeHRFbGVtLmluc2VydEFmdGVyKGVsZW1lbnQsIHQsIGxhc3ROZWVkV3JhcCk7XG4gICAgICAgICAgICAgICAgY2FyZXQuc2V0Um93KHJvdysxKTtcbiAgICAgICAgICAgICAgICBjYXJldC5zZXRDb2x1bW4oWzAsIDBdKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0lOUFVULkJBQ0tTUEFDRTpcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBlbGVtZW50LnNoaWZ0KG9mZnNldCwgLTEpO1xuICAgICAgICAgICAgICAgIHN3aXRjaChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncHJldic6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaWR4ID0gZmxhdHRlblR4dEVsZW0uZmluZEluZGV4KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZWxlbV9pZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g6KGM5YaFXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhdHRlblR4dEVsZW0uc3BsaWNlKGlkeC0xLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHggLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50LnNldFNvdXJjZShhZnRlckNvbnRlbnQsIHJlY29yZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtvZmZzZXQsIGRlbGV0ZW9wXSA9IF9ibGFuZEFkamFjZW50RWxlbWVudChlZGl0b3IsIGZsYXR0ZW5UeHRFbGVtLmdldChpZHgtMSksIGVsZW1lbnQsIDAsIHJlY29yZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRlbGV0ZW9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5UeHRFbGVtLnJlbW92ZShpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldC5zZXRDb2x1bW4oW2VsZW1faWR4IC0gKChvZmZzZXQgPiAwIHx8IGRlbGV0ZW9wKT8yOjEpLCBvZmZzZXRdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKGlkeCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDmjaLooYzkuoZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVSb3cgPSByb3cgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZUVsZW1pZHggPSBhcmVhLmdldChwcmVSb3cpLmxlbmd0aCgpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbb2Zmc2V0LCBkZWxldGVvcF0gPSBfYmxhbmRBZGphY2VudEVsZW1lbnQoZWRpdG9yLCBmbGF0dGVuVHh0RWxlbS5nZXQoaWR4LTEpLCBlbGVtZW50LCAwLCByZWNvcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihkZWxldGVvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGF0dGVuVHh0RWxlbS5yZW1vdmUoaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXQuc2V0Um93KHByZVJvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXQuc2V0Q29sdW1uKFtwcmVFbGVtaWR4LCBvZmZzZXRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZWxmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZUNvbnRlbnQgPSBwcmVDb250ZW50LnN1YnN0cmluZygwLCBwcmVDb250ZW50Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXQuc2V0Q29sdW1uKDEsIGNhcmV0LmdldENvbHVtbigxKS0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZXRTb3VyY2VXaXRoUmVjb3JkKHByZUNvbnRlbnQgKyBhZnRlckNvbnRlbnQsIGVkaXRvci5zcGFjZUhvbGRlciwgcmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtFWUJPQVJEX0lOUFVULkRFTEVURTpcbiAgICAgICAgICAgICAgICBjb25zdCBzaGlmdHJlc3VsdCA9IGVsZW1lbnQuc2hpZnQob2Zmc2V0LCAxKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2goc2hpZnRyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbmV4dCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaWR4ID0gZmxhdHRlblR4dEVsZW0uZmluZEluZGV4KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZWxlbV9pZHggPCBsaW5lLmxlbmd0aCgpLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDooYzlhoVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGF0dGVuVHh0RWxlbS5zcGxpY2UoaWR4KzEsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRFbGVtID0gZmxhdHRlblR4dEVsZW0uZ2V0KGlkeCsxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbb2Zmc2V0LCBkZWxldGVvcF0gPSBfYmxhbmRBZGphY2VudEVsZW1lbnQoZWxlbWVudCwgbmV4dEVsZW0sIGVsZW1lbnQuc291cmNlLmxlbmd0aCwgcmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGVsZXRlb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhdHRlblR4dEVsZW0ucmVtb3ZlKGlkeCsxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXQuc2V0Q29sdW1uKFtlbGVtX2lkeCwgb2Zmc2V0XSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihpZHggPCBmbGF0dGVuVHh0RWxlbS5sZW5ndGgoKS0xKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDmjaLooYzkuoZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0RWxlbSA9IGZsYXR0ZW5UeHRFbGVtLmdldChpZHgrMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW29mZnNldCwgZGVsZXRlb3BdID0gX2JsYW5kQWRqYWNlbnRFbGVtZW50KGVsZW1lbnQsIG5leHRFbGVtLCBlbGVtZW50LnNvdXJjZS5sZW5ndGgsIHJlY29yZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRlbGV0ZW9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5UeHRFbGVtLnJlbW92ZShpZHgrMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0LnNldENvbHVtbihbZWxlbV9pZHgsIG9mZnNldF0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2VsZic6XG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlckNvbnRlbnQgPSBhZnRlckNvbnRlbnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZXRTb3VyY2VXaXRoUmVjb3JkKHByZUNvbnRlbnQgKyBhZnRlckNvbnRlbnQsIGVkaXRvci5zcGFjZUhvbGRlciwgcmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBmbGF0dGVuVHh0RWxlbS5jb2xsZWN0UmVjb3JkcygpO1xuICAgICAgICBmbGF0dGVuVHh0RWxlbS5yZWNvcmRBZnRlckNhcmV0KGNhcmV0KTtcbiAgICAgICAgdW5kb3JlZG8ud3JpdGUocmVjb3JkcywgZmxhdHRlblR4dEVsZW0uZ2V0Q2FyZXRSZWNvcmQoKSk7XG4gICAgICAgIHRoaXMuX2VkaXRvci5yZWZyZXNoKCk7XG4gICAgfVxuXG4gICAgXG59IiwiaW1wb3J0IENvbW1hbmQgZnJvbSAnLi9iYXNlJztcblxuaW1wb3J0IHsgTU9VU0VfQ09NTUFORFMgfSBmcm9tICcuLi9iYXNlL2NvbnN0YW50cyc7XG5pbXBvcnQgSkZsb3dFdmVudCBmcm9tICcuLi8uLi8uLi9ldmVudHMvaW5kZXgnO1xuXG5leHBvcnQgY2xhc3MgU3RhcnRFZGl0Q29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICAgIHN0YXRpYyBfbmFtZSA9IE1PVVNFX0NPTU1BTkRTLlNUQVJUX0VESVQ7XG5cbiAgICBleGVjKCkge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLl9lZGl0b3I7XG4gICAgICAgIGlmKCF0aGlzLl9zdGFydEVkaXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGpmbG93ID0gZWRpdG9yLl9qZmxvdztcbiAgICAgICAgZWRpdG9yLm1vdmVDYXJldEJ5SGl0UG9pbnQoKTtcbiAgICAgICAgZWRpdG9yLmNyZWF0ZVNoYWRvd0lucHV0KCk7XG4gICAgICAgIGVkaXRvci5fY2FyZXQuYW5pbWF0ZShqZmxvdyk7XG4gICAgICAgIGVkaXRvci5zeW5jU2hhZG93SW5wdXRQb3NpdGlvbigpO1xuICAgIH1cblxuICAgIF9zdGFydEVkaXQoKSB7XG4gICAgICAgIGxldCBmbGFnID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5fZWRpdG9yO1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnZWRpdCcsIHtcbiAgICAgICAgICAgIHRhcmdldDogZWRpdG9yLFxuICAgICAgICAgICAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSkgXG4gICAgICAgIHJldHVybiBmbGFnOyBcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRWRpdENsaWNrQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICAgIHN0YXRpYyBfbmFtZSA9IE1PVVNFX0NPTU1BTkRTLkVESVRfQ0xJQ0s7XG5cbiAgICBleGVjKCkge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLl9lZGl0b3I7XG4gICAgICAgIGVkaXRvci5tb3ZlQ2FyZXRCeUhpdFBvaW50KCk7XG4gICAgICAgIGVkaXRvci5fY2FyZXQucmVmcmVzaCgpO1xuICAgICAgICBlZGl0b3Iuc3luY1NoYWRvd0lucHV0UG9zaXRpb24oKTtcbiAgICAgICAgZWRpdG9yLl9yYW5nZS5kaXNhYmxlKCk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgRG91YmxlQ2xpY2tDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gICAgc3RhdGljIF9uYW1lID0gTU9VU0VfQ09NTUFORFMuRE9VQkxFX0NMSUNLO1xuXG4gICAgZXhlYygpIHtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5fZWRpdG9yO1xuICAgICAgICBlZGl0b3IubW92ZUNhcmV0QnlIaXRQb2ludCgpO1xuICAgICAgICBjb25zdCBjYXJldCA9IGVkaXRvci5fY2FyZXQ7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gZWRpdG9yLl9yYW5nZTtcbiAgICAgICAgY29uc3QgYXJlYSA9IGVkaXRvci5fYXJlYTtcbiAgICAgICAgY29uc3Qgcm93ID0gY2FyZXQuZ2V0Um93KCk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBhcmVhLmdldChyb3cpO1xuICAgICAgICBjb25zdCBlbGVtX2lkeCA9IGxpbmUubGVuZ3RoKCkgLSAxO1xuICAgICAgICByYW5nZS5zZXRJbml0aWFsUmFuZ2UoW3JvdywgMCwgMF0pO1xuICAgICAgICByYW5nZS5zZXRSYW5nZShbXG4gICAgICAgICAgICByb3csIGVsZW1faWR4LCBsaW5lLnRhaWwoKS50YWlsT2Zmc2V0KClcbiAgICAgICAgXSk7XG4gICAgICAgIHJhbmdlLmhhbmRsZUNhcmV0KGNhcmV0KTtcbiAgICAgICAgcmFuZ2UuZW5hYmxlKCk7XG4gICAgICAgIGVkaXRvci5zeW5jU2hhZG93SW5wdXRQb3NpdGlvbigpO1xuICAgIH1cbn1cbiIsImltcG9ydCBDb21tYW5kIGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgeyBLRVlCT0FSRF9DT01NQU5EUywgTU9VU0VfQ09NTUFORFMgfSBmcm9tICcuLi9iYXNlL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBjbGFzcyBTaGlmdFVwQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICAgIHN0YXRpYyBfbmFtZSA9IEtFWUJPQVJEX0NPTU1BTkRTLlNISUZUX1VQO1xuICAgIGV4ZWMoKSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5fZWRpdG9yLl9yYW5nZTtcbiAgICAgICAgcmFuZ2Uuc2V0SW5pdGlhbFJhbmdlKG51bGwpO1xuICAgICAgICB0aGlzLl9lZGl0b3IudG9nZ2xlU2hpZnQoZmFsc2UpXG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2hpZnREb3duQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICAgIHN0YXRpYyBfbmFtZSA9IEtFWUJPQVJEX0NPTU1BTkRTLlNISUZUX0RPV047XG4gICAgXG4gICAgZXhlYygpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGlzLl9lZGl0b3IuX3JhbmdlO1xuICAgICAgICBjb25zdCBjYXJldCA9IHRoaXMuX2VkaXRvci5fY2FyZXQ7XG4gICAgICAgIHJhbmdlLnNldEluaXRpYWxSYW5nZShjYXJldC50b1JhbmdlKCkpO1xuICAgICAgICB0aGlzLl9lZGl0b3IudG9nZ2xlU2hpZnQodHJ1ZSlcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTaGlmdE9uQ2xpY2tDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gICAgc3RhdGljIF9uYW1lID0gTU9VU0VfQ09NTUFORFMuU0hJRlRfT05fQ0xJQ0s7XG5cbiAgICBleGVjKCkge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLl9lZGl0b3I7XG4gICAgICAgIGVkaXRvci5tb3ZlQ2FyZXRCeUhpdFBvaW50KCk7XG4gICAgICAgIGNvbnN0IGNhcmV0ID0gdGhpcy5fZWRpdG9yLl9jYXJldDtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGlzLl9lZGl0b3IuX3JhbmdlO1xuICAgICAgICByYW5nZS5zZXRSYW5nZShjYXJldC50b1JhbmdlKCkpO1xuICAgICAgICByYW5nZS5lbmFibGUoKTtcbiAgICAgICAgcmFuZ2UuaGFuZGxlQ2FyZXQoY2FyZXQpO1xuICAgICAgICBjYXJldC5yZWZyZXNoKCk7XG4gICAgICAgIGVkaXRvci5zeW5jU2hhZG93SW5wdXRQb3NpdGlvbigpO1xuICAgIH1cbn0iLCJpbXBvcnQgQ29tbWFuZCBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHsgS0VZQk9BUkRfQ09NTUFORFMgfSBmcm9tICcuLi9iYXNlL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBjbGFzcyBDdHJsQUNvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgICBzdGF0aWMgX25hbWUgPSBLRVlCT0FSRF9DT01NQU5EUy5DVFJMQTtcbiAgICBleGVjKCkge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLl9lZGl0b3I7XG4gICAgICAgIGNvbnN0IGNhcmV0ID0gZWRpdG9yLl9jYXJldDtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBlZGl0b3IuX3JhbmdlO1xuICAgICAgICBjb25zdCBhcmVhID0gZWRpdG9yLl9hcmVhO1xuICAgICAgICBjb25zdCByb3cgPSBhcmVhLmxlbmd0aCgpIC0gMTtcbiAgICAgICAgY29uc3QgbGluZSA9IGFyZWEuZ2V0KHJvdyk7XG4gICAgICAgIGNvbnN0IGVsZW1faWR4ID0gbGluZS5sZW5ndGgoKSAtIDE7XG4gICAgICAgIHJhbmdlLnNldEluaXRpYWxSYW5nZShbMCwgMCwgMF0pO1xuICAgICAgICByYW5nZS5zZXRSYW5nZShbXG4gICAgICAgICAgICByb3csIGVsZW1faWR4LCBsaW5lLnRhaWwoKS50YWlsT2Zmc2V0KClcbiAgICAgICAgXSk7XG4gICAgICAgIHJhbmdlLmhhbmRsZUNhcmV0KGNhcmV0KTtcbiAgICAgICAgcmFuZ2UuZW5hYmxlKCk7XG4gICAgICAgIGVkaXRvci5zeW5jU2hhZG93SW5wdXRQb3NpdGlvbigpO1xuICAgIH1cbn1cbiIsImltcG9ydCBDb21tYW5kIGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgeyBLRVlCT0FSRF9DT01NQU5EUyB9IGZyb20gJy4uL2Jhc2UvY29uc3RhbnRzJztcblxuZXhwb3J0IGNsYXNzIFVuZG9Db21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gICAgc3RhdGljIF9uYW1lID0gS0VZQk9BUkRfQ09NTUFORFMuVU5ETztcbiAgICBleGVjKCkge1xuICAgICAgICB0aGlzLl9lZGl0b3IuX3JhbmdlLmRpc2FibGUoKVxuICAgICAgICB0aGlzLl9lZGl0b3IuX3VuZG9yZWRvLnVuZG8oKTtcbiAgICAgICAgdGhpcy5fZWRpdG9yLnJlZnJlc2goKTtcblxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlZG9Db21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gICAgc3RhdGljIF9uYW1lID0gS0VZQk9BUkRfQ09NTUFORFMuUkVETztcbiAgICBleGVjKCkge1xuICAgICAgICB0aGlzLl9lZGl0b3IuX3JhbmdlLmRpc2FibGUoKVxuICAgICAgICB0aGlzLl9lZGl0b3IuX3VuZG9yZWRvLnJlZG8oKTtcbiAgICAgICAgdGhpcy5fZWRpdG9yLnJlZnJlc2goKTtcbiAgICB9XG59IiwiaW1wb3J0IENvbW1hbmQgZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7IEtFWUJPQVJEX0NPTU1BTkRTLCBFRElUT1JfRVZFTlRTLCBLRVlCT0FSRF9JTlBVVCB9IGZyb20gJy4uL2Jhc2UvY29uc3RhbnRzJztcbmltcG9ydCBKRmxvd0V2ZW50IGZyb20gJy4uLy4uLy4uL2V2ZW50cyc7XG5leHBvcnQgY2xhc3MgQ29weUNvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgICBzdGF0aWMgX25hbWUgPSBLRVlCT0FSRF9DT01NQU5EUy5DT1BZO1xuICAgIGV4ZWMoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5fZWRpdG9yO1xuICAgICAgICBjb25zdCByYW5nZSA9IGVkaXRvci5fcmFuZ2U7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSByYW5nZS5nZXRSYW5nZUNvcHkoZWRpdG9yKTtcbiAgICAgICAgaWYoY29udGVudCkge1xuICAgICAgICAgICAgZXZlbnQuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEN1dENvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgICBzdGF0aWMgX25hbWUgPSBLRVlCT0FSRF9DT01NQU5EUy5DVVQ7XG4gICAgZXhlYyhldmVudCkgeyAgIFxuICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLl9lZGl0b3I7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gZWRpdG9yLl9yYW5nZTtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHJhbmdlLmdldFJhbmdlQ29weShlZGl0b3IpO1xuICAgICAgICBpZihjb250ZW50KSB7XG4gICAgICAgICAgICBldmVudC5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHJhbmdlLmlzRW5hYmxlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNtZCA9IGVkaXRvci5jb21tYW5kcy5nZXQoRURJVE9SX0VWRU5UUy5JTlBVVCk7XG4gICAgICAgICAgICBjbWQuZXhlYyhLRVlCT0FSRF9JTlBVVC5CQUNLU1BBQ0UpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUGFzdGVDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gICAgc3RhdGljIF9uYW1lID0gS0VZQk9BUkRfQ09NTUFORFMuUEFTVEU7XG4gICAgZXhlYyhwYXN0ZUNvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5fZWRpdG9yO1xuICAgICAgICBpZihwYXN0ZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIGxldCBfcHJldmVudERlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGVkaXRvci5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdwYXN0ZScsIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBwYXN0ZUNvbnRlbnQsXG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgX3ByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZighX3ByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY21kID0gZWRpdG9yLmNvbW1hbmRzLmdldChFRElUT1JfRVZFTlRTLklOUFVUKTtcbiAgICAgICAgICAgICAgICBjbWQuZXhlYyhLRVlCT0FSRF9JTlBVVC5JTlBVVCwgcGFzdGVDb250ZW50KTsgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5cbiIsImV4cG9ydCB7XG4gICAgQXJyb3dMZWZ0Q29tbWFuZCwgXG4gICAgQXJyb3dSaWdodENvbW1hbmQsXG4gICAgQXJyb3dVcENvbW1hbmQsXG4gICAgQXJyb3dEb3duQ29tbWFuZFxufSBmcm9tICcuL21vdmVtZW50JztcbmV4cG9ydCB7IElucHV0IH0gZnJvbSAnLi9pbnB1dCc7XG5leHBvcnQgeyBcbiAgICBTdGFydEVkaXRDb21tYW5kLFxuICAgIEVkaXRDbGlja0NvbW1hbmQsXG4gICAgRG91YmxlQ2xpY2tDb21tYW5kLFxufSBmcm9tICcuL21vdXNlJ1xuZXhwb3J0IHtcbiAgICBTaGlmdERvd25Db21tYW5kLFxuICAgIFNoaWZ0VXBDb21tYW5kLFxuICAgIFNoaWZ0T25DbGlja0NvbW1hbmRcbn0gZnJvbSAnLi9zaGlmdCc7XG5cbmV4cG9ydCB7XG4gICAgQ3RybEFDb21tYW5kXG59IGZyb20gJy4vY3RybCc7XG5cbmV4cG9ydCAge1xuICAgIFVuZG9Db21tYW5kLFxuICAgIFJlZG9Db21tYW5kXG59IGZyb20gJy4vdW5kb3JlZG8nO1xuXG5cbmV4cG9ydCB7XG4gICAgQ29weUNvbW1hbmQsXG4gICAgUGFzdGVDb21tYW5kLFxuICAgIEN1dENvbW1hbmQsXG59IGZyb20gJy4vY2xpcGJvYXJkJyIsImltcG9ydCBOb2RlIGZyb20gJy4uL25vZGUnO1xuaW1wb3J0IFN0YWNrTWl4aW4gZnJvbSAnLi4vc3RhY2tNaXhpbic7XG5pbXBvcnQgTGF5b3V0TWl4aW4gZnJvbSAnLi4vbGF5b3V0TWl4aW4nO1xuaW1wb3J0IEpGbG93RXZlbnQgZnJvbSAnLi4vLi4vZXZlbnRzL2luZGV4JztcbmltcG9ydCB7IHJlcXVlc3RDYWNoZUNhbnZhcyB9IGZyb20gJy4uLy4uL3V0aWxzL2NhbnZhcyc7XG5pbXBvcnQgU2hhZG93Q2FjaGUgZnJvbSAnLi4vc2hhcGVzL3NoYWRvdy1jYWNoZSc7XG5pbXBvcnQgU2hhZG93SW5wdXQgZnJvbSAnLi9iYXNlL3NoYWRvdy1pbnB1dCc7XG5cbmltcG9ydCBDYXJldCBmcm9tICcuL2Jhc2UvY2FyZXQnO1xuaW1wb3J0IFJhbmdlIGZyb20gJy4vYmFzZS9yYW5nZSc7XG5pbXBvcnQgVW5kb1JlZG8gZnJvbSAnLi91bmRvcmVkbyc7XG5pbXBvcnQge1xuICAgIEFyZWEsXG4gICAgRmxhdHRlblRleHRFbGVtZW50cyxcbiAgICBMaW5lLFxuICAgIFRleHRFbGVtZW50XG59IGZyb20gJy4vc3RvcmFnZSc7XG5cbmltcG9ydCB7IFxuICAgIElucHV0LFxuICAgIEFycm93TGVmdENvbW1hbmQsXG4gICAgQXJyb3dSaWdodENvbW1hbmQsXG4gICAgQXJyb3dVcENvbW1hbmQsXG4gICAgQXJyb3dEb3duQ29tbWFuZCxcbiAgICBTdGFydEVkaXRDb21tYW5kLFxuICAgIFNoaWZ0RG93bkNvbW1hbmQsXG4gICAgU2hpZnRVcENvbW1hbmQsXG4gICAgU2hpZnRPbkNsaWNrQ29tbWFuZCxcbiAgICBFZGl0Q2xpY2tDb21tYW5kLFxuICAgIEN0cmxBQ29tbWFuZCxcbiAgICBEb3VibGVDbGlja0NvbW1hbmQsXG4gICAgLy8gUmV0dXJuQ29tbWFuZCxcbiAgICAvLyBEZWxldGVDb21tYW5kLFxuICAgIFVuZG9Db21tYW5kLFxuICAgIFJlZG9Db21tYW5kLFxuICAgIENvcHlDb21tYW5kLFxuICAgIFBhc3RlQ29tbWFuZCxcbiAgICBDdXRDb21tYW5kLFxufSBmcm9tICcuL2NvbW1hbmQnXG5pbXBvcnQgeyBFRElUT1JfRVZFTlRTLCBLRVlCT0FSRF9DT01NQU5EUywgTU9VU0VfQ09NTUFORFMgfSBmcm9tICcuL2Jhc2UvY29uc3RhbnRzJztcblxuY2xhc3MgVGV4dEdyb3VwIGV4dGVuZHMgTm9kZSB7XG5cbiAgICBnZXQgY3VycmVudExpbmVIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVIZWlnaHQgfHwgcGFyc2VJbnQodGhpcy5mb250U2l6ZSk7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoY29uZmlncykge1xuICAgICAgICBzdXBlcihjb25maWdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ1RleHRHcm91cCc7XG4gICAgICAgIHRoaXMuaW5pdFN0YWNrKGNvbmZpZ3MpO1xuICAgICAgICB0aGlzLmluaXRMYXlvdXQoY29uZmlncyk7XG5cbiAgICAgICAgdGhpcy5fdW5kb3JlZG8gPSBuZXcgVW5kb1JlZG8oKTtcbiAgICAgICAgdGhpcy5fdW5kb3JlZG8uX2VkaXRvciA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2NhcmV0ID0gbmV3IENhcmV0KCk7XG4gICAgICAgIHRoaXMuX3JhbmdlID0gbmV3IFJhbmdlKCk7XG4gICAgICAgIHRoaXMuX3NoYWRvd0lucHV0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRoaXMudGV4dENvbG9yID0gY29uZmlncy50ZXh0Q29sb3IgfHwgJ3RyYW5zcGFyZW50JztcbiAgICAgICAgdGhpcy5mb250RmFtaWx5ID0gY29uZmlncy5mb250RmFtaWx5IHx8ICctYXBwbGUtc3lzdGVtLEJsaW5rTWFjU3lzdGVtRm9udCxTZWdvZSBVSSxSb2JvdG8sSGVsdmV0aWNhIE5ldWUsSGVsdmV0aWNhLFRhaG9tYSxBcmlhbCxOb3RvIFNhbnMsUGluZ0ZhbmcgU0MsTWljcm9zb2Z0IFlhSGVpLEhpcmFnaW5vIFNhbnMgR0Isc2Fucy1zZXJpZixBcHBsZSBDb2xvciBFbW9qaSxTZWdvZSBVSSBFbW9qaSxTZWdvZSBVSSBTeW1ib2wsTm90byBDb2xvciBFbW9qaSdcbiAgICAgICAgdGhpcy5mb250U2l6ZSA9IGNvbmZpZ3MuZm9udFNpemUgfHwgJzI4cHgnO1xuICAgICAgICB0aGlzLmZvbnRXZWlnaHQgPSBjb25maWdzLmZvbnRXZWlnaHQgfHwgJyc7XG4gICAgICAgIHRoaXMuZWxlbWVudFNwYWNlID0gY29uZmlncy5lbGVtZW50U3BhY2UgfHwgNTtcbiAgICAgICAgdGhpcy5saW5lU3BhY2UgPSBjb25maWdzLmxpbmVTcGFjZSB8fCA1O1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gY29uZmlncy5wbGFjZWhvbGRlciB8fCAn6K+36L6T5YWlJztcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlckNvbG9yID0gY29uZmlncy5wbGFjZWhvbGRlckNvbG9yIHx8ICcjZWVlJztcbiAgICAgICAgdGhpcy5jdXJzb3JDb2xvciA9IGNvbmZpZ3MuY3Vyc29yQ29sb3IgfHwgJyM2MENGQzQnO1xuICAgICAgICB0aGlzLnRleHRSYW5nZUNvbG9yID0gY29uZmlncy50ZXh0UmFuZ2VDb2xvciB8fCAnIzRFNzVFQzFBJztcbiAgICAgICAgdGhpcy5taW5XaWR0aCA9IGNvbmZpZ3MubWluV2lkdGggfHwgMDtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuc3BhY2VIb2xkZXIgPSB7XG4gICAgICAgICAgICBlbmFibGU6IGZhbHNlLFxuICAgICAgICB9XG4gICAgICAgIGlmKGNvbmZpZ3Muc3BhY2VQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnNwYWNlSG9sZGVyLCB7XG4gICAgICAgICAgICAgICAgZW5hYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNwYWNlUGxhY2Vob2xkZXI6IGNvbmZpZ3Muc3BhY2VQbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICBzcGFjZVBsYWNlaG9sZGVyQ29sb3I6IGNvbmZpZ3Muc3BhY2VQbGFjZWhvbGRlckNvbG9yLFxuICAgICAgICAgICAgICAgIHJldHVybkZvbnQ6IGNvbmZpZ3MucmV0dXJuRm9udCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgXG5cblxuICAgICAgICB0aGlzLnJlc29sdmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBjb25maWdzLnJlc29sdmVyKCk7XG4gICAgICAgICAgICBpZihlbGVtZW50cy5sZW5ndGggPT09IDAgfHwgZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoLTFdLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobmV3IFRleHRFbGVtZW50KCd0ZXh0JywgJycpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICAgICAgaWYoZWwudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnNldFNvdXJjZShlbC5zb3VyY2UsIHRoaXMuc3BhY2VIb2xkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGlzLl9saW5lcyA9IFtdO1xuICAgICAgICB0aGlzLl9hcmVhID0gbmV3IEFyZWEoKTtcbiAgICAgICAgdGhpcy5fZmxhdHRlblR4dEVsZW0gPSBGbGF0dGVuVGV4dEVsZW1lbnRzLmNyZWF0ZSh0aGlzLnJlc29sdmVyKCkpOyBcbiAgICAgICAgdGhpcy5fc3RhdHVzID0ge1xuICAgICAgICAgICAgZWRpdGluZzogZmFsc2UsXG4gICAgICAgICAgICBkcmFnb3ZlcjogZmFsc2UsXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29tbWFuZHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucmVnaXN0Q29tbWFuZChTdGFydEVkaXRDb21tYW5kKTtcbiAgICAgICAgdGhpcy5yZWdpc3RDb21tYW5kKEVkaXRDbGlja0NvbW1hbmQpO1xuICAgICAgICB0aGlzLnJlZ2lzdENvbW1hbmQoU2hpZnRVcENvbW1hbmQpO1xuICAgICAgICB0aGlzLnJlZ2lzdENvbW1hbmQoU2hpZnREb3duQ29tbWFuZCk7XG4gICAgICAgIHRoaXMucmVnaXN0Q29tbWFuZChTaGlmdE9uQ2xpY2tDb21tYW5kKTtcbiAgICAgICAgdGhpcy5yZWdpc3RDb21tYW5kKElucHV0KTtcbiAgICAgICAgdGhpcy5yZWdpc3RDb21tYW5kKEFycm93TGVmdENvbW1hbmQpO1xuICAgICAgICB0aGlzLnJlZ2lzdENvbW1hbmQoQXJyb3dSaWdodENvbW1hbmQpO1xuICAgICAgICB0aGlzLnJlZ2lzdENvbW1hbmQoQXJyb3dVcENvbW1hbmQpO1xuICAgICAgICB0aGlzLnJlZ2lzdENvbW1hbmQoQXJyb3dEb3duQ29tbWFuZCk7XG4gICAgICAgIHRoaXMucmVnaXN0Q29tbWFuZChDdHJsQUNvbW1hbmQpO1xuICAgICAgICB0aGlzLnJlZ2lzdENvbW1hbmQoRG91YmxlQ2xpY2tDb21tYW5kKTtcbiAgICAgICAgLy8gdGhpcy5yZWdpc3RDb21tYW5kKFJldHVybkNvbW1hbmQpO1xuICAgICAgICAvLyB0aGlzLnJlZ2lzdENvbW1hbmQoRGVsZXRlQ29tbWFuZCk7XG4gICAgICAgIHRoaXMucmVnaXN0Q29tbWFuZChVbmRvQ29tbWFuZCk7XG4gICAgICAgIHRoaXMucmVnaXN0Q29tbWFuZChSZWRvQ29tbWFuZCk7XG4gICAgICAgIHRoaXMucmVnaXN0Q29tbWFuZChDb3B5Q29tbWFuZCk7XG4gICAgICAgIHRoaXMucmVnaXN0Q29tbWFuZChDdXRDb21tYW5kKTtcbiAgICAgICAgdGhpcy5yZWdpc3RDb21tYW5kKFBhc3RlQ29tbWFuZCk7XG4gICAgICAgIHRoaXMuX21ha2VGdW5jdGlvbmFsKCk7XG5cbiAgICAgICAgdGhpcy5fY2FjaGVWaWV3Qm94ID0gW107XG4gICAgfVxuXG4gICAgcmVnaXN0Q29tbWFuZChjbWQpIHtcbiAgICAgICAgaWYoIXRoaXMuY29tbWFuZHMuaGFzKGNtZC5fbmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZHMuc2V0KGNtZC5fbmFtZSwgY21kLmNyZWF0ZSh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfbWFrZUZ1bmN0aW9uYWwoKSB7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmKGV2ZW50LmN1cnJlbnRUYXJnZXQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LmRldGFpbC5idWJibGVzID0gZmFsc2U7XG4gICAgICAgICAgICBpZih0aGlzLl9zdGF0dXMuZWRpdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuZXhlY0NvbW1hbmQoTU9VU0VfQ09NTUFORFMuRE9VQkxFX0NMSUNLKVxuICAgICAgICAgICAgfSBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmKGV2ZW50LmN1cnJlbnRUYXJnZXQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LmRldGFpbC5idWJibGVzID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgY29tbW5kO1xuICAgICAgICAgICAgaWYodGhpcy5fc3RhdHVzLmVkaXRpbmcpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9zdGF0dXMuc2hpZnRPbikge1xuICAgICAgICAgICAgICAgICAgICBjb21tbmQgPSBNT1VTRV9DT01NQU5EUy5TSElGVF9PTl9DTElDS1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1uZCA9IE1PVVNFX0NPTU1BTkRTLkVESVRfQ0xJQ0tcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbW1uZCA9IE1PVVNFX0NPTU1BTkRTLlNUQVJUX0VESVRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXhlY0NvbW1hbmQoY29tbW5kKVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cy5lZGl0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZih0aGlzLl9zaGFkb3dJbnB1dCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuX3NoYWRvd0lucHV0LnJlbGVhc2VFdmVudExpc3RlbnIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFkb3dJbnB1dC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hhZG93SW5wdXQgPSB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMuX2JlbG9uZ3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9qZmxvdy5fcmVuZGVyKCk7XG4gICAgICAgICAgICB9IFxuXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2NoYW5nZScsIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgdGV4dEVsZW1lbnRzOiB0aGlzLl9mbGF0dGVuVHh0RWxlbS5jb3B5KCksXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3JhbmdlLmRpc2FibGUoKTtcbiAgICAgICAgICAgIHRoaXMuX2NhcmV0LmNhbmNlbEFuaW1hdGUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdpbnN0YW5jZVByZXNzU3RhcnQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmKHRoaXMuX3N0YXR1cy5lZGl0aW5nICYmICF0aGlzLl9zdGF0dXMuc2hpZnRPbikge1xuICAgICAgICAgICAgICAgIGV2ZW50LmRldGFpbC5idWJibGVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZXZlbnQuZGV0YWlsLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgLy8gZXZlbnQuZGV0YWlsLmpmbG93LnNldE1vdmluZ1RhcmdldHMobnVsbCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLl9jdXJyZW50cDtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gdGhpcy5fcG9zaXRpb25Ub0N1cnNvck9mZnNldChwb2ludCk7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5fY3Vyc29yID0gYztcbiAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMuX3JhbmdlO1xuICAgICAgICAgICAgICAgIHJhbmdlLnNldEluaXRpYWxSYW5nZShbYy5yb3csIC4uLmMuY29sdW1uXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgamZsb3cgPSBldmVudC5kZXRhaWwuamZsb3c7XG4gICAgICAgICAgICAgICAgbGV0IG1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IChlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzLmVkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBqZmxvdy5fY2FsY3VsYXRlUG9pbnRCYWNrKFtvZmZzZXRYLCBvZmZzZXRZXSk7XG4gICAgICAgICAgICAgICAgICAgIGpmbG93Ll9zdGFjay5jaGVja0hpdChwKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMuX2N1cnJlbnRwO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjID0gdGhpcy5fcG9zaXRpb25Ub0N1cnNvck9mZnNldChwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMuX2N1cnNvciA9IGM7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldFJhbmdlKFtjLnJvdywgLi4uYy5jb2x1bW5dKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuZW5hYmxlKCk7XG4gICAgICAgICAgICAgICAgfSkuYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgdClcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHQpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRJbml0aWFsUmFuZ2UobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKCFtb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLmhhbmRsZUNhcmV0KHRoaXMuX2NhcmV0KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMuZWRpdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NoYWRvd0lucHV0LmZvY3VzKCk7ICAgXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VudGVyJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ2FyZXRCeUhpdFBvaW50KCk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMuZHJhZ292ZXIgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubW92ZUNhcmV0QnlIaXRQb2ludCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMuZHJhZ292ZXIgPSBmYWxzZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgb25Ecm9wID0gKChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYoIXRoaXMuX3N0YXR1cy5kcmFnb3Zlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LmRldGFpbC5idWJibGVzID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMuZHJhZ292ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGNhcmV0ID0gdGhpcy5fY2FyZXQ7XG4gICAgICAgICAgICBjb25zdCByb3cgPSBjYXJldC5nZXRSb3coKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IGNhcmV0LmdldENvbHVtbigpO1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IHRoaXMuX2FyZWEuZ2V0KHJvdyk7XG4gICAgICAgICAgICBsZXQgW2VsZW1pZHgsIG9mZnNldF0gPSBjb2x1bW47XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gbGluZS5nZXQoZWxlbWlkeCk7XG4gICAgICAgICAgICBjb25zdCBwcmVFbGVtID0gbGluZS5nZXQoZWxlbWlkeC0xKTtcbiAgICAgICAgICAgIGxldCBmbGF0dGVuVHh0RWxlbSA9IHRoaXMuX2ZsYXR0ZW5UeHRFbGVtO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgaWR4ID0gZmxhdHRlblR4dEVsZW0uZmluZEluZGV4KGVsZW1lbnQpXG4gICAgICAgICAgICBpZihlbGVtZW50LnR5cGUgIT09ICd0ZXh0JyAmJiBwcmVFbGVtPy50eXBlID09PSd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHByZUVsZW0uc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZHggPSBmbGF0dGVuVHh0RWxlbS5maW5kSW5kZXgocHJlRWxlbSkgICBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbGFzdExlbmd0aCA9IGZsYXR0ZW5UeHRFbGVtLmxlbmd0aCgpXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2luc2VydCcsIHtcbiAgICAgICAgICAgICAgICAuLi5ldmVudC5kZXRhaWwsXG4gICAgICAgICAgICAgICAgdHlwZTogZXZlbnQudHlwZSxcbiAgICAgICAgICAgICAgICB0ZXh0RWxlbWVudHM6IGZsYXR0ZW5UeHRFbGVtLmNvcHkoKSxcbiAgICAgICAgICAgICAgICBpZHgsIG9mZnNldCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIC8vIGFmdGVyIGluc2VydFxuICAgICAgICAgICAgZmxhdHRlblR4dEVsZW0gPSB0aGlzLl9mbGF0dGVuVHh0RWxlbTtcbiAgICAgICAgICAgIGlmKHRoaXMuX3N0YXR1cy5lZGl0aW5nKSB7XG4gICAgICAgICAgICAgICAgaWYoZmxhdHRlblR4dEVsZW0ubGVuZ3RoKCkgPiBsYXN0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhcmV0LnNldENvbHVtbihbXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtaWR4ICsgZmxhdHRlblR4dEVsZW0ubGVuZ3RoKCkgLSBsYXN0TGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFkb3dJbnB1dC5mb2N1cygpOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMuX3N0YXR1cy5lZGl0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FyZXQucmVmcmVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zeW5jU2hhZG93SW5wdXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5fcmFuZ2UuZGlzYWJsZSgpO1xuICAgICAgICB9KS5iaW5kKHRoaXMpXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigncHJlc3NFbmQnLCBvbkRyb3ApXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIG9uRHJvcCk7XG4gICAgfVxuXG4gICAgdG9nZ2xlU2hpZnQodmFsKSB7XG4gICAgICAgIHRoaXMuX3N0YXR1cy5zaGlmdE9uID0gdmFsO1xuICAgIH1cblxuICAgIGV4ZWNDb21tYW5kKGtpbmQsIGRhdGEpIHtcbiAgICAgICAgY29uc3QgY21kID0gdGhpcy5jb21tYW5kcy5nZXQoa2luZCk7XG4gICAgICAgIGNtZC5leGVjKGRhdGEpO1xuICAgIH1cblxuICAgIGNyZWF0ZVNoYWRvd0lucHV0KCkge1xuICAgICAgICBjb25zdCBqZmxvdyA9IHRoaXMuX2pmbG93O1xuICAgICAgICBsZXQgc2hhZG93SW5wdXQgPSBuZXcgU2hhZG93SW5wdXQoamZsb3cuRE9Nd3JhcHBlcik7XG4gICAgICAgIGNvbnN0IF9hID0gZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBraW5kID0gZS5kZXRhaWwua2luZDtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBlLmRldGFpbC5kYXRhO1xuICAgICAgICAgICAgdGhpcy5leGVjQ29tbWFuZChraW5kLCBkYXRhKVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBfYiA9IGUgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2luZCA9IGUuZGV0YWlsLmtpbmQ7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gZS5kZXRhaWwuZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IGNtZCA9IHRoaXMuY29tbWFuZHMuZ2V0KEVESVRPUl9FVkVOVFMuSU5QVVQpO1xuICAgICAgICAgICAgY21kLmV4ZWMoa2luZCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgc2hhZG93SW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihFRElUT1JfRVZFTlRTLkNPTlRST0xfQ01ELCBfYSk7XG4gICAgICAgIHNoYWRvd0lucHV0LmFkZEV2ZW50TGlzdGVuZXIoRURJVE9SX0VWRU5UUy5JTlBVVCwgX2IpO1xuXG4gICAgICAgIHNoYWRvd0lucHV0LnJlbW92ZUxpc2VudGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzaGFkb3dJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKEVESVRPUl9FVkVOVFMuQ09OVFJPTF9DTUQsIF9hKTtcbiAgICAgICAgICAgIHNoYWRvd0lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoRURJVE9SX0VWRU5UUy5JTlBVVCwgX2IpO1xuICAgICAgICAgICAgc2hhZG93SW5wdXQucmVtb3ZlTGlzZW50ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NoYWRvd0lucHV0ID0gc2hhZG93SW5wdXQ7XG4gICAgICAgIHRoaXMuX3N0YXR1cy5lZGl0aW5nID0gdHJ1ZTtcbiAgICAgICAgamZsb3cuc2V0Rm9jdXNJbnN0YW5jZSh0aGlzKTtcbiAgICB9XG5cbiAgICBtb3ZlQ2FyZXRCeUhpdFBvaW50KCkge1xuICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMuX2N1cnJlbnRwO1xuICAgICAgICBjb25zdCBjYXJldCA9IHRoaXMuX2NhcmV0O1xuICAgICAgICBjb25zdCB7IHJvdywgY29sdW1uIH0gPSB0aGlzLl9wb3NpdGlvblRvQ3Vyc29yT2Zmc2V0KHBvaW50KTtcbiAgICAgICAgY2FyZXQuc2V0Um93KHJvdyk7XG4gICAgICAgIGNhcmV0LnNldENvbHVtbihjb2x1bW4pO1xuICAgIH1cblxuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIHRoaXMucmVjYWxjdWxhdGVVcCgpO1xuICAgICAgICB0aGlzLnN5bmNTaGFkb3dJbnB1dFBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuX2pmbG93Ll9yZW5kZXIoKTtcbiAgICB9XG5cbiAgICByZWZyZXNoVGV4dEVsZW1lbnRzKCkge1xuICAgICAgICB0aGlzLl9mbGF0dGVuVHh0RWxlbSA9IEZsYXR0ZW5UZXh0RWxlbWVudHMuY3JlYXRlKHRoaXMucmVzb2x2ZXIoKSk7IFxuICAgIH1cblxuICAgIF9wb3NpdGlvblRvQ3Vyc29yT2Zmc2V0KHBvaW50KSB7XG4gICAgICAgIGNvbnN0IFt4LCB5XSA9IHBvaW50O1xuICAgICAgICAvLyBjb25zdCBbeDAsIHkwXSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCBhcmVhID0gdGhpcy5fYXJlYTtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGgvMjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSB4ICsgdztcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IHkgKyBoO1xuICAgICAgICBjb25zdCByb3cgPSBhcmVhLmdldExpbmVBYm92ZShvZmZzZXRZKVxuICAgICAgICBjb25zdCBjdXJyTGluZSA9IGFyZWEuZ2V0KHJvdyk7XG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IGN1cnJMaW5lLmdldENvbHVtbk5lYXJlc3Qob2Zmc2V0WCwgdGhpcy5lbGVtZW50U3BhY2UsIHRoaXMuZm9udFNpemUsIHRoaXMuZm9udEZhbWlseSwgdGhpcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb3csIFxuICAgICAgICAgICAgY29sdW1uLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NhcmV0VG9Qb3NpdGlvbigpIHtcbiAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5fY2FyZXQuZ2V0Um93KCk7XG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IHRoaXMuX2NhcmV0LmdldENvbHVtbigpO1xuICAgICAgICBjb25zdCBsaW5lID0gdGhpcy5fYXJlYS5nZXQocm93KTtcbiAgICAgICAgY29uc3QgW2VsZW1pZHgsIG9mZnNldF0gPSBjb2x1bW47XG4gICAgICAgIGNvbnN0IG1ldGEgPSBsaW5lLmdldChlbGVtaWR4KTtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5fZmxhdHRlblR4dEVsZW0uZmluZEluZGV4KG1ldGEpO1xuICAgICAgICBjb25zdCBwcmVFbGVtID0gdGhpcy5fZmxhdHRlblR4dEVsZW0uZ2V0KGlkeC0xKTtcbiAgICAgICAgbGV0IGN3O1xuICAgICAgICBsZXQgY19sZW4gPSB0aGlzLmN1cnJlbnRMaW5lSGVpZ2h0LzI7XG4gICAgICAgIGlmKG1ldGEudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gbWV0YS5nZXRSZW5kZXJTb3VyY2UodGhpcy5zcGFjZUhvbGRlcikuc3Vic3RyaW5nKDAsIG9mZnNldCk7XG4gICAgICAgICAgICByZXF1ZXN0Q2FjaGVDYW52YXMoKGN0eCkgPT4ge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9IGAke3RoaXMuZm9udFNpemV9ICR7dGhpcy5mb250RmFtaWx5fWA7XG4gICAgICAgICAgICAgICAgY3cgPSBtZXRhLmFuY2hvclggLSBtZXRhLndpZHRoLzIgKyBjdHgubWVhc3VyZVRleHQoYykud2lkdGhcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdyA9IG1ldGEuYW5jaG9yWCAtIG1ldGEud2lkdGgvMlxuICAgICAgICAgICAgY19sZW4gPSBNYXRoLm1heChjX2xlbiwgbWV0YS5oZWlnaHQvMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYob2Zmc2V0ID09PSAwICYmIHByZUVsZW0gJiYgcHJlRWxlbS50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgICAgIGNfbGVuID0gTWF0aC5tYXgoY19sZW4sIHByZUVsZW0uaGVpZ2h0LzIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbY3csIGNfbGVuLCBsaW5lLmFuY2hvclksIHByZUVsZW0sIG1ldGFdXG4gICAgfVxuXG4gICAgc3luY1NoYWRvd0lucHV0UG9zaXRpb24oKSB7XG4gICAgICAgIGlmKHRoaXMuX3N0YXR1cy5lZGl0aW5nKSB7XG4gICAgICAgICAgICBjb25zdCBbY3csIGNfbGVuLCBhbmNob3JZXSA9IHRoaXMuX2NhcmV0VG9Qb3NpdGlvbigpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLmNhbGN1bGF0ZVRvUmVhbFdvcmxkKFtjdywgYW5jaG9yWSArIGNfbGVuXSk7XG4gICAgICAgICAgICBjb25zdCBjYW52YXNNZXRhID0gdGhpcy5famZsb3cuY2FudmFzTWV0YTtcbiAgICAgICAgICAgIGNvbnN0IHB4ID0gTWF0aC5taW4oY2FudmFzTWV0YS5hY3R1YWxfd2lkdGggLSAxMjAsIHBvaW50WzBdKTtcbiAgICAgICAgICAgIC8vIHJldHVybiBbcHgsIHBvaW50WzFdXTtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd0lucHV0LnN5bmNQb3NpdGlvbihweCwgcG9pbnRbMV0pO1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93SW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgcmVuZGVyKGN0eCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBpZih0aGlzLl9pc01vdmluZyl7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjZcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMub3BhY2l0eSAhPT0gMSkge1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5vcGFjaXR5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtjeCwgY3ldID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IGpmbG93ID0gdGhpcy5famZsb3c7XG4gICAgICAgIGNvbnN0IGFyZWEgPSB0aGlzLl9hcmVhO1xuICAgICAgICBjdHgudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgIC8vIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgLy8gY3R4LnJlY3QoLXdpZHRoLzIsIC1oZWlnaHQvMiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIC8vIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY29uc3QgZmxhdHRlblR4dEVsZW0gPSB0aGlzLl9mbGF0dGVuVHh0RWxlbTtcbiAgICAgICAgaWYoZmxhdHRlblR4dEVsZW0uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguZm9udCA9IGAke3RoaXMuZm9udFdlaWdodH0gJHt0aGlzLmZvbnRTaXplfSAke3RoaXMuZm9udEZhbWlseX1gO1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMucGxhY2Vob2xkZXJDb2xvcjtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLnBsYWNlaG9sZGVyLCAwLCAwKTtcblxuICAgICAgICAgICAgdGhpcy5fcmFuZGVyQ3Vyc29yKGN0eCk7XG5cbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLWN4LCAtY3kpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmZvbnQgPSBgJHt0aGlzLmZvbnRXZWlnaHR9ICR7dGhpcy5mb250U2l6ZX0gJHt0aGlzLmZvbnRGYW1pbHl9YDtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnRleHRDb2xvcjtcbiAgICAgICAgYXJlYS5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICAgICAgbGluZS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAgICBpZihlbC50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwucmVuZGVyKGN0eCwgdGhpcy5zcGFjZUhvbGRlciwgdGhpcy50ZXh0Q29sb3IpO1xuICAgICAgICAgICAgICAgICAgICAvLyBjdHguZmlsbFRleHQoZWwuc291cmNlLCBlbC5hbmNob3JYLCBlbC5hbmNob3JZKVxuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgICBmbGF0dGVuVHh0RWxlbS5mb3JFYWNoKGVsZW0gPT4ge1xuICAgICAgICAgICAgaWYoZWxlbS50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGpmbG93LmdldFJlbmRlck5vZGVCeVNvdXJjZShlbGVtLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaWYoaW5zdGFuY2UgJiYgaW5zdGFuY2UudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5yZW5kZXIoY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5fcmFuZGVyQ3Vyc29yKGN0eCk7XG4gICAgICAgIHRoaXMuX3JlbmRlclJhbmdlKGN0eCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoLWN4LCAtY3kpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIF9yYW5kZXJDdXJzb3IoY3R4KSB7XG4gICAgICAgIGlmKHRoaXMuX2NhcmV0LmlzU2hvdygpICYmICh0aGlzLl9zdGF0dXMuZWRpdGluZyB8fCB0aGlzLl9zdGF0dXMuZHJhZ292ZXIpKSB7XG4gICAgICAgICAgICBjb25zdCBbY3csIGNfbGVuLCBhbmNob3JZXSA9IHRoaXMuX2NhcmV0VG9Qb3NpdGlvbigpO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhjdywgYW5jaG9yWSAtIGNfbGVuKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oY3csIGFuY2hvclkgKyBjX2xlbik7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY3Vyc29yQ29sb3I7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVuZGVyUmFuZ2UoY3R4KSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5fcmFuZ2U7XG4gICAgICAgIGlmKHJhbmdlLmlzRW5hYmxlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyZWEgPSB0aGlzLl9hcmVhO1xuICAgICAgICAgICAgY29uc3QgdGV4dFJhbmdlQ29sb3IgPSB0aGlzLnRleHRSYW5nZUNvbG9yO1xuICAgICAgICAgICAgY29uc3QgYmxvY2toZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IGJsb2Nrd2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICAgICAgY29uc3QgbGluZVNwYWNlID0gdGhpcy5saW5lU3BhY2U7XG4gICAgICAgICAgICBjb25zdCBbcl9mLCBpZHhfZiwgb2Zmc2V0X2ZdID0gcmFuZ2UuZ2V0UmFuZ2VGcm9tKCk7XG4gICAgICAgICAgICBjb25zdCBbcl90LCBpZHhfdCwgb2Zmc2V0X3RdID0gcmFuZ2UuZ2V0UmFuZ2VUbygpO1xuICAgICAgICAgICAgaWYocl9mID09PSByX3QpIHtcbiAgICAgICAgICAgICAgICBpZihpZHhfZiA9PT0gaWR4X3QgJiYgb2Zmc2V0X2YgPT0gb2Zmc2V0X3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lID0gYXJlYS5nZXQocl9mKTtcbiAgICAgICAgICAgICAgICBsZXQgc3BhY2UgPSAocl9mID09PSBhcmVhLmxlbmd0aCgpLTEgPyAwIDogbGluZVNwYWNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsdHkgPSBsaW5lLnJlZHVjZUhlaWdodCAtIHNwYWNlIC0gbGluZS5oZWlnaHQgLSBibG9ja2hlaWdodC8yO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGxpbmUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHgxID0gdGhpcy5fbWVhc3VyZUVsZW1lbnRPZmZzZXRYKGxpbmUuZ2V0KGlkeF9mKSwgb2Zmc2V0X2YsIGN0eCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeDIgPSB0aGlzLl9tZWFzdXJlRWxlbWVudE9mZnNldFgobGluZS5nZXQoaWR4X3QpLCBvZmZzZXRfdCwgY3R4KTtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LnJlY3QoeDEsIGx0eSAsIHgyIC0geDEsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRSYW5nZUNvbG9yXG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IF9yID0gcl9mO1xuICAgICAgICAgICAgICAgIGxldCBiZWdpbm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdoaWxlKF9yIDw9IHJfdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lID0gYXJlYS5nZXQoX3IpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2UgPSAoX3IgPT09IGFyZWEubGVuZ3RoKCktMSA/IDAgOiBsaW5lU3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsdHkgPSBsaW5lLnJlZHVjZUhlaWdodCAtIHNwYWNlIC0gbGluZS5oZWlnaHQgLSBibG9ja2hlaWdodC8yO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBsaW5lLmhlaWdodDtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYoYmVnaW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtID0gbGluZS5nZXQoaWR4X2YpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMuX21lYXN1cmVFbGVtZW50T2Zmc2V0WChlbGVtLCBvZmZzZXRfZiwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RFbGVtID0gbGluZS50YWlsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gbGFzdEVsZW0uYW5jaG9yWCArIGxhc3RFbGVtLndpZHRoLzI7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVjdCh4LCBsdHksIHQgLSB4LCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRSYW5nZUNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoX3IgPT09IHJfdCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtID0gbGluZS5nZXQoaWR4X3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMuX21lYXN1cmVFbGVtZW50T2Zmc2V0WChlbGVtLCBvZmZzZXRfdCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KC1ibG9ja3dpZHRoLzIsIGx0eSAsIGVsZW0ucmVkdWNlV2lkdGggKyAoeCAtIGVsZW0uYW5jaG9yWCArIGVsZW0ud2lkdGgvMiksIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGV4dFJhbmdlQ29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVjdCgtYmxvY2t3aWR0aC8yLCBsdHksIGxpbmUud2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGV4dFJhbmdlQ29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGJlZ2lubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfcisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9tZWFzdXJlRWxlbWVudE9mZnNldFgoZWxlbWVudCwgb2Zmc2V0LCBjdHgpIHtcbiAgICAgICAgaWYoZWxlbWVudC50eXBlICE9PSAndGV4dCcgfHwgb2Zmc2V0ID09PSAwKXtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmFuY2hvclggLSBlbGVtZW50LndpZHRoLzI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuYW5jaG9yWCAtIGVsZW1lbnQud2lkdGgvMiArIGN0eC5tZWFzdXJlVGV4dChlbGVtZW50LmdldFJlbmRlclNvdXJjZSh0aGlzLnNwYWNlSG9sZGVyKS5zdWJzdHJpbmcoMCwgb2Zmc2V0KSkud2lkdGg7XG4gICAgfVxuXG4gICAgbWVhc3VyZVRleHRXaWR0aChjb250ZW50KSB7XG4gICAgICAgIGxldCB0O1xuICAgICAgICByZXF1ZXN0Q2FjaGVDYW52YXMoKGN0eCkgPT4ge1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBgJHt0aGlzLmZvbnRTaXplfSAke3RoaXMuZm9udEZhbWlseX1gO1xuICAgICAgICAgICAgdCA9IGN0eC5tZWFzdXJlVGV4dChjb250ZW50KS53aWR0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cblxuICAgIGdldEJvdW5kaW5nRGltZW5zaW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICB9IFxuICAgIH1cblxuICAgIGdldEJvdW5kaW5nUmVjdCgpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoIC8yO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQvMjtcbiAgICAgICAgY29uc3QgbHR4ID0gYW5jaG9yWzBdIC0gdztcbiAgICAgICAgY29uc3QgbHR5ID0gYW5jaG9yWzFdIC0gaDtcbiAgICAgICAgY29uc3QgcmJ4ID0gYW5jaG9yWzBdICsgdztcbiAgICAgICAgY29uc3QgcmJ5ID0gYW5jaG9yWzFdICsgaDtcbiAgICAgICAgY29uc3QgYnIgPSB0aGlzLl9ib3VuZGluZ3JlY3Q7XG4gICAgICAgIGJyWzBdID0gbHR4O1xuICAgICAgICBiclsxXSA9IGx0eTtcbiAgICAgICAgYnJbMl0gPSByYng7XG4gICAgICAgIGJyWzNdID0gcmJ5O1xuICAgICAgICByZXR1cm4gYnJcbiAgICB9XG5cbiAgICBfZ2V0Vmlld0JveCgpIHtcbiAgICAgICAgY29uc3QgYmVsb25nc192Ym94ID0gdGhpcy5fYmVsb25ncy5nZXRDYWNoZVZpZXdCb3goKTtcbiAgICAgICAgY29uc3QgY2FjaGVWaWV3Qm94ID0gdGhpcy5fY2FjaGVWaWV3Qm94O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlUG9pbnRCYWNrV2l0aFBvaW50KGJlbG9uZ3NfdmJveFswXSwgYmVsb25nc192Ym94WzFdLCBjYWNoZVZpZXdCb3gsIDAsIDEpO1xuICAgICAgICB0aGlzLl9jYWxjdWxhdGVQb2ludEJhY2tXaXRoUG9pbnQoYmVsb25nc192Ym94WzJdLCBiZWxvbmdzX3Zib3hbM10sIGNhY2hlVmlld0JveCwgMiwgMyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZVZpZXdCb3g7XG4gICAgfVxuICAgIFxuICAgIGdldENhY2hlVmlld0JveCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlVmlld0JveDtcbiAgICB9XG5cbiAgICBjYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbihwb2ludCkge1xuICAgICAgICBjb25zdCBbZ3gsIGd5XSA9IHBvaW50O1xuICAgICAgICBjb25zdCBbY3gsIGN5XSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICAvLyBjb25zdCBwID0gW2N4ICsgYW5jaG9yWzBdIC0gc3BhbkgsIGN5ICsgYW5jaG9yWzFdIC0gc3BhblZdO1xuICAgICAgICBjb25zdCBwID0gW2d4ICsgY3gsIGd5ICsgY3ldXG4gICAgICAgIGlmKHRoaXMuX2JlbG9uZ3MgJiYgdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9Db29yZGluYXRpb24ocCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhbGN1bGF0ZVRvUmVhbFdvcmxkKHBvaW50KSB7XG4gICAgICAgIGNvbnN0IFtneCwgZ3ldID0gcG9pbnQ7XG4gICAgICAgIGNvbnN0IFtjeCwgY3ldID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IHAgPSBbZ3ggKyBjeCwgZ3kgKyBjeV1cbiAgICAgICAgaWYodGhpcy5fYmVsb25ncyAmJiB0aGlzLl9iZWxvbmdzLmNhbGN1bGF0ZVRvUmVhbFdvcmxkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmVsb25ncy5jYWxjdWxhdGVUb1JlYWxXb3JsZChwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhbGN1bGF0ZVRvUmVhbFdvcmxkV2l0aFBvaW50ZXIob3V0cG9pbnQsIGlucG9pbnQpIHtcbiAgICAgICAgb3V0cG9pbnRbMF0gPSBpbnBvaW50WzBdICsgdGhpcy5hbmNob3JbMF07XG4gICAgICAgIG91dHBvaW50WzFdID0gaW5wb2ludFsxXSArIHRoaXMuYW5jaG9yWzFdO1xuICAgICAgICBpZih0aGlzLl9iZWxvbmdzICYmIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9SZWFsV29ybGRXaXRoUG9pbnRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JlbG9uZ3MuY2FsY3VsYXRlVG9SZWFsV29ybGRXaXRoUG9pbnRlcihvdXRwb2ludCwgb3V0cG9pbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NhbGN1bGF0ZVBvaW50QmFjayhwb2ludCkge1xuICAgICAgICBjb25zdCBbZ3gsIGd5XSA9IHBvaW50O1xuICAgICAgICBjb25zdCBbY3gsIGN5XSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCBwID0gW2d4IC0gY3gsIGd5IC0gY3ldXG4gICAgICAgIHJldHVybiBwXG4gICAgfVxuXG4gICAgX2NhbGN1bGF0ZVBvaW50QmFja1dpdGhQb2ludChhLCBiLCBhcnIsIGlkeDEsIGlkeDIpIHtcbiAgICAgICAgYXJyW2lkeDFdID0gYSAtIHRoaXMuYW5jaG9yWzBdO1xuICAgICAgICBhcnJbaWR4Ml0gPSBiIC0gdGhpcy5hbmNob3JbMV07XG4gICAgfVxuXG4gICAgaXNIaXQocG9pbnQsIGNvbmRpdGlvbikge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5fY2FsY3VsYXRlUG9pbnRCYWNrKHBvaW50KTtcbiAgICAgICAgY29uc3QgamZsb3cgPSB0aGlzLl9qZmxvdztcbiAgICAgICAgdGhpcy5fY3VycmVudHAgPSBwOyAvLyDmmoLlrZjvvIzkuLrkuoblkI7nu63orqHnrpfliKvnmoTkvY3nva5cbiAgICAgICAgbGV0IHZhbGlkSW5zdGFuY2UgPSBbXTtcbiAgICAgICAgY29uc3QgZmxhdHRlblR4dEVsZW0gPSB0aGlzLl9mbGF0dGVuVHh0RWxlbTtcbiAgICAgICAgZmxhdHRlblR4dEVsZW0uZm9yRWFjaChlbGVtID0+IHtcbiAgICAgICAgICAgIGlmKGVsZW0udHlwZSAhPT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBqZmxvdy5nZXRSZW5kZXJOb2RlQnlTb3VyY2UoZWxlbS5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIGlmKGluc3RhbmNlLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRJbnN0YW5jZS5wdXNoKGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX3N0YWNrLmNoZWNrSGl0KHAsIGNvbmRpdGlvbiwgKGkpID0+IHZhbGlkSW5zdGFuY2UuaW5jbHVkZXMoaSkpO1xuICAgICAgICBcbiAgICAgICAgaWYodGFyZ2V0KSByZXR1cm4gdGFyZ2V0O1xuXG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aCAvMjtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIHJldHVybiBwb2ludFswXSA+IGFuY2hvclswXSAtIHdcbiAgICAgICAgICAgICYmIHBvaW50WzBdIDwgYW5jaG9yWzBdICsgd1xuICAgICAgICAgICAgJiYgcG9pbnRbMV0gPiBhbmNob3JbMV0gLSBoXG4gICAgICAgICAgICAmJiBwb2ludFsxXSA8IGFuY2hvclsxXSArIGg7XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IHQgPSBuZXcgU2hhZG93Q2FjaGUoe1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgY2FjaGU6IChjdHgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbY3gsIGN5XSA9IHRoaXMuYW5jaG9yO1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLWN4ICsgdGhpcy53aWR0aC8yLCAtY3kgKyB0aGlzLmhlaWdodC8yKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcihjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmKHRoaXMuX2pmbG93Ll9mb2N1cy5pbnN0YW5jZSA9PT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy5famZsb3cuYmx1cigpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5PYmplY3QuYXNzaWduKFRleHRHcm91cC5wcm90b3R5cGUsIFN0YWNrTWl4aW4pO1xuT2JqZWN0LmFzc2lnbihUZXh0R3JvdXAucHJvdG90eXBlLCBMYXlvdXRNaXhpbik7XG5PYmplY3QuYXNzaWduKFRleHRHcm91cC5wcm90b3R5cGUsIHtcbiAgICAgICAgLy8g5bGP6JS96L+Z5Lik5Liq5pa55rOV77yM5Y+q5qC55o2ucmVmbG936YeN566XXG4gICAgX2dldEJvdW5kaW5nR3JvdXBSZWN0KCkge30sXG4gICAgcmVzZXRDaGlsZHJlblBvc2l0aW9uKCkge30sXG4gICAgcmVmbG93KCkge1xuICAgICAgICBsZXQgbGluZUhlaWdodCA9IHRoaXMuY3VycmVudExpbmVIZWlnaHQ7XG4gICAgICAgIGNvbnN0IGZsYXR0ZW5UeHRFbGVtID0gdGhpcy5fZmxhdHRlblR4dEVsZW07XG4gICAgICAgIGNvbnN0IGFyZWEgPSB0aGlzLl9hcmVhO1xuICAgICAgICBpZihmbGF0dGVuVHh0RWxlbS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IDA7XG4gICAgICAgICAgICBjb25zdCB0ID0gZmxhdHRlblR4dEVsZW0uZ2V0KDApO1xuICAgICAgICAgICAgcmVxdWVzdENhY2hlQ2FudmFzKChjdHgpID0+IHtcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9IGAke3RoaXMuZm9udFNpemV9ICR7dGhpcy5mb250RmFtaWx5fWA7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGhpcy5wbGFjZWhvbGRlcikud2lkdGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBhcmVhLnRydW5jYXRlKHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGxpbmVIZWlnaHQsXG4gICAgICAgICAgICAgICAgcmVkdWNlSGVpZ2h0OiBsaW5lSGVpZ2h0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsaW5lLmluc2VydCgwLCB0KTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odCwge1xuICAgICAgICAgICAgICAgIGFuY2hvclg6IC13aWR0aC8yLFxuICAgICAgICAgICAgICAgIGhlaWdodDogbGluZUhlaWdodCxcbiAgICAgICAgICAgICAgICBpc1RhaWw6IHRydWUsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGpmbG93ID0gdGhpcy5famZsb3c7XG4gICAgICAgIGNvbnN0IHNwYWNlSG9sZGVyID0gdGhpcy5zcGFjZUhvbGRlcjtcbiAgICAgICAgcmVxdWVzdENhY2hlQ2FudmFzKChjdHgpID0+IHtcbiAgICAgICAgICAgIGN0eC5mb250ID0gYCR7dGhpcy5mb250U2l6ZX0gJHt0aGlzLmZvbnRGYW1pbHl9YDtcbiAgICAgICAgICAgIGZsYXR0ZW5UeHRFbGVtLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYoZWxlbWVudC50eXBlID09PSAndGV4dCcgJiYgZWxlbWVudC5kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnByZUNhbGN1bGF0ZVRleHQoY3R4LCBzcGFjZUhvbGRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBuZXh0QXJlYSA9IG5ldyBBcmVhKCk7XG4gICAgICAgIG5leHRBcmVhLnRydW5jYXRlKHtcbiAgICAgICAgICAgIGhlaWdodDogbGluZUhlaWdodCxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBsaW5lID0gbmV4dEFyZWEuZ2V0KDApO1xuICAgICAgICBsZXQgYWxsSGVpZ2h0ID0gMDtcbiAgICAgICAgbGV0IGFsbFdpZHRoID0gMDtcbiAgICAgICAgbGV0IGxhc3RFbGVtID0gbnVsbDtcbiAgICAgICAgY29uc3QgbGluZVNwYWNlID0gdGhpcy5saW5lU3BhY2U7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRTcGFjZSA9IHRoaXMuZWxlbWVudFNwYWNlO1xuICAgICAgICBmbGF0dGVuVHh0RWxlbS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgbGluZS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgZWxlbWVudC5yZWR1Y2VXaWR0aCA9IGxpbmUud2lkdGg7XG4gICAgICAgICAgICBpZihlbGVtZW50LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuaGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICBsaW5lLndpZHRoICs9IGVsZW1lbnQud2lkdGg7XG4gICAgICAgICAgICAgICAgaWYoZWxlbWVudC5uZWVkV3JhcCl7XG4gICAgICAgICAgICAgICAgICAgIGFsbEhlaWdodCArPSAobGluZS5oZWlnaHQgKyBsaW5lU3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICBsaW5lLnJlZHVjZUhlaWdodCA9IGFsbEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgYWxsV2lkdGggPSBNYXRoLm1heChsaW5lLndpZHRoLCBhbGxXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSBMaW5lLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGxpbmVIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBuZXh0QXJlYS5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGpmbG93LmdldFJlbmRlck5vZGVCeVNvdXJjZShlbGVtZW50LnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5oZWlnaHQgPSBub2RlLmhlaWdodDtcbiAgICAgICAgICAgICAgICBsaW5lLmhlaWdodCA9IE1hdGgubWF4KGxpbmUuaGVpZ2h0LCBub2RlLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFyZ2luID0gKCFsYXN0RWxlbSB8fCBsYXN0RWxlbS50eXBlID09PSAndGV4dCcpID8gZWxlbWVudFNwYWNlKjIgOiBlbGVtZW50U3BhY2U7XG4gICAgICAgICAgICAgICAgbGluZS53aWR0aCArPSBub2RlLndpZHRoK21hcmdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RFbGVtID0gZWxlbWVudDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZmxhdHRlblR4dEVsZW0udGFpbCgpLmlzVGFpbCA9IHRydWU7XG4gICAgICAgIGFsbEhlaWdodCArPSBsaW5lLmhlaWdodFxuICAgICAgICBsaW5lLnJlZHVjZUhlaWdodCA9IGFsbEhlaWdodDtcbiAgICAgICAgYWxsV2lkdGggPSBNYXRoLm1heCh0aGlzLm1pbldpZHRoLCBNYXRoLm1heChsaW5lLndpZHRoLCBhbGxXaWR0aCkpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgaGggPSBhbGxIZWlnaHQvMjtcbiAgICAgICAgY29uc3QgaHcgPSBhbGxXaWR0aC8yO1xuICAgICAgICBsZXQgdHkgPSAtaGg7XG4gICAgICAgIGxldCBsYXN0UmVkdWNlWSA9IDA7XG5cbiAgICAgICAgbmV4dEFyZWEuZm9yRWFjaChsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaGVpZ2h0LCByZWR1Y2VIZWlnaHQgfSA9IGw7XG4gICAgICAgICAgICBjb25zdCBhbmNob3JZID0gdHkgKyBsYXN0UmVkdWNlWSArIGhlaWdodCAvIDI7XG4gICAgICAgICAgICBsLmFuY2hvclkgPSBhbmNob3JZO1xuICAgICAgICAgICAgbGV0IHJlZHVjZVggPSAtaHc7XG4gICAgICAgICAgICBsZXQgbGFzdGVsID0gbnVsbDtcbiAgICAgICAgICAgIGwuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICAgICAgaWYoZWwudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmFuY2hvclkgPSBhbmNob3JZO1xuICAgICAgICAgICAgICAgICAgICBlbC5hbmNob3JYID0gcmVkdWNlWCArIGVsLndpZHRoLzI7XG4gICAgICAgICAgICAgICAgICAgIHJlZHVjZVggKz0gZWwud2lkdGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyTm9kZSA9IGpmbG93LmdldFJlbmRlck5vZGVCeVNvdXJjZShlbC5zb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb3VibGVNYXJnaW4gPSAoIWxhc3RlbCB8fCBsYXN0ZWwudHlwZSA9PT0gJ3RleHQnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFyZ2luID0gZG91YmxlTWFyZ2luID8gZWxlbWVudFNwYWNlKjIgOiBlbGVtZW50U3BhY2U7XG4gICAgICAgICAgICAgICAgICAgIGVsLndpZHRoID0gcmVuZGVyTm9kZS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgZWwuYW5jaG9yWSA9IGFuY2hvclk7XG4gICAgICAgICAgICAgICAgICAgIGVsLmFuY2hvclggPSByZWR1Y2VYICsgZWwud2lkdGgvMiArIChkb3VibGVNYXJnaW4gPyBtYXJnaW4vMiA6IDApO1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJOb2RlLmFuY2hvciA9IFtlbC5hbmNob3JYLCBlbC5hbmNob3JZXTtcbiAgICAgICAgICAgICAgICAgICAgcmVkdWNlWCArPSAoZWwud2lkdGggKyBtYXJnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0ZWwgPSBlbDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBsYXN0UmVkdWNlWSA9IHJlZHVjZUhlaWdodDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2FyZWEgPSBuZXh0QXJlYTtcbiAgICAgICAgdGhpcy53aWR0aCA9IGFsbFdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGFsbEhlaWdodDtcbiAgICB9LFxuICAgIGRvUmVjYWxjdWxhdGUoKSB7XG4gICAgICAgIGlmKHRoaXMuX19tb3VudGVkX18pIHtcbiAgICAgICAgICAgIHRoaXMucmVjYWxjdWxhdGVVcCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9fbW91bnRlZF9fID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxufSlcbmV4cG9ydCBkZWZhdWx0IFRleHRHcm91cDtcbiIsImltcG9ydCBOb2RlIGZyb20gJy4vbm9kZSc7XG5cbi8vIGV4cG9ydCBjb25zdCBQTEFDRUhPTERFUl9TWU1CT0wgPSBTeW1ib2woJ1BMQUNFSE9MREVSX1NZTUJPTCcpO1xuXG5leHBvcnQgY2xhc3MgTm9kZVBsYWNlaG9sZGVyIGV4dGVuZHMgTm9kZSB7XG4gICAgdHlwZSA9ICdOT0RFX1BMQUNFSE9MREVSJ1xufSIsImltcG9ydCB7IGNyZWF0ZUNhbnZhcywgcmVzaXplQ2FudmFzLCBsaXN0ZW5PbkRldmljZVBpeGVsUmF0aW8gfSBmcm9tICcuLi91dGlscy9jYW52YXMnO1xuaW1wb3J0IHsgYm91bmRpbmdfYm94LCBkb092ZXJsYXAsIGRlYm91bmNlIH0gZnJvbSAnLi4vdXRpbHMvZnVuY3Rpb25zJztcbmltcG9ydCB7IEpGTE9XX01PREUgfSBmcm9tICcuLi91dGlscy9jb25zdGFuY2UnO1xuaW1wb3J0IEdob3N0Tm9kZSBmcm9tICcuLi9pbnN0YW5jZS9naG9zdE5vZGUnO1xuaW1wb3J0IHsgTm9kZVdlYWtNYXBNaXhpbiB9IGZyb20gJy4uL2luc3RhbmNlL25vZGVXZWFrTWFwJztcbmltcG9ydCBTdGFja01peGluIGZyb20gJy4uL2luc3RhbmNlL3N0YWNrTWl4aW4nO1xuaW1wb3J0IExheW91dE1peGluIGZyb20gJy4uL2luc3RhbmNlL2xheW91dE1peGluJztcbmltcG9ydCBNZXNzYWdlTWl4aW4gZnJvbSAnLi4vaW5zdGFuY2UvbWVzc2FnZU1peGluJztcbmltcG9ydCBBbmltZU1peGluIGZyb20gJy4uL2FuaW1lL2FuaW1lTWl4aW4nO1xuaW1wb3J0IE1pbmlNYXBNaXhpbiBmcm9tICcuLi9taW5pTWFwL21pbmltYXAtbWl4aW4nO1xuaW1wb3J0IFNjcm9sbEJhck1peGluIGZyb20gJy4uL3Njcm9sbGJhci9zY3JvbGxiYXJNaXhpbic7XG5pbXBvcnQgU2NoZWR1bGVNaXhpbiBmcm9tICcuL3NjaGVkdWxlJztcbi8vIGltcG9ydCB7IHNldFVuaXF1ZUlkLCBnZXRVbmlxdWVJZCB9IGZyb20gJy4uL3V0aWxzL2Z1bmN0aW9ucyc7XG5pbXBvcnQgSkZsb3dFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuXG5pbXBvcnQgRXZlbnRBZGFwdGVyIGZyb20gJy4uL2V2ZW50cy9hZGFwdGVyJztcblxuaW1wb3J0IEdyb3VwRmFjdG9yeSBmcm9tICcuLi9pbnN0YW5jZS9ncm91cEZhY3RvcnknO1xuaW1wb3J0IFBvaW50IGZyb20gJy4uL2luc3RhbmNlL3NoYXBlcy9wb2ludCc7XG5pbXBvcnQgUmVjdGFuZ2xlIGZyb20gJy4uL2luc3RhbmNlL3NoYXBlcy9yZWN0YW5nbGUnO1xuaW1wb3J0IENhcHN1bGUgZnJvbSAnLi4vaW5zdGFuY2Uvc2hhcGVzL2NhcHN1bGUnO1xuaW1wb3J0IENhcHN1bGVWZXJ0aWNhbCBmcm9tICcuLi9pbnN0YW5jZS9zaGFwZXMvY2Fwc3VsZS12ZXJ0aWNhbCc7XG5pbXBvcnQgUmhvbWJ1cyBmcm9tICcuLi9pbnN0YW5jZS9zaGFwZXMvcmhvbWJ1cyc7XG5pbXBvcnQgRGlhbW9uZCBmcm9tICcuLi9pbnN0YW5jZS9zaGFwZXMvZGlhbW9uZCc7XG5pbXBvcnQgRGlhbW9uZFZlcnRpY2FsIGZyb20gJy4uL2luc3RhbmNlL3NoYXBlcy9kaWFtb25kLXZlcnRpY2FsJztcbi8vIGltcG9ydCB7IGNyZWF0ZUlucHV0VGV4dFN0eWxlIH0gZnJvbSAnLi4vaW5zdGFuY2UvdGV4dCc7XG4vLyBjcmVhdGVJbnB1dFRleHRTdHlsZSgpO1xuLyoqXG4gKiBAZnVudGlvbiBzZXRJbml0aWFsUG9zaXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBSZWFsYm94WCAtIOWGheWuueaYoOWwhOWIsGNhbnZhc+S4iueahCBYXG4gKiBAcGFyYW0ge051bWJlcn0gUmVhbGJveFkgLSDlhoXlrrnmmKDlsITliLBjYW52YXPkuIrnmoQgWSBcbiAqIEBwYXJhbSB7TnVtYmVyfSBSZWFsYm94VyAtIOWGheWuueaYoOWwhOWIsGNhbnZhc+S4iueahOWuveW6plxuICogQHBhcmFtIHtOdW1iZXJ9IFJlYWxib3hIIC0g5YaF5a655pig5bCE5YiwY2FudmFz5LiK55qE6auY5bqmIFxuICogQHBhcmFtIHtOdW1iZXJ9IENhbnZhc1dpZHRoICAtIOinhueql+WuveW6plxuICogQHBhcmFtIHtOdW1iZXJ9IENhbnZhc0hlaWdodCAgLSDop4bnqpfpq5jluqZcbiAqIEByZXR1cm4ge09iamVjdH0gLSDliJ3lp4vkvY3nva4geyB4LCB5IH1cbiAqL1xuXG4vKipcbiAqIEBmdW50aW9uIGxpbmtHZW5cbiAqIEBwYXJhbSB7Tm9kZX0gZnJvbSAtIOWHuuWPkee7mOWbvuiKgueCuVxuICogQHBhcmFtIHtOb2RlfSB0byAtIOS4tOaXtuiKgueCue+8jOW9k+WJjem8oOagh+aMh+eahOWcsOaWuVxuICogQHJldHVybiB7QmFzZWVMaW5rfSAtIOi/nue6v+WvueixoVxuICovXG5cblxuLyoqIFxuICogQGNsYXNzIEdyb3VwXG4gKiBAY2xhc3NkZXNjIOefqeW9oue7hOWNleWFgyDnlLEge0BsaW5rIEdyb3VwRmFjdG9yeX0g6YCa6L+HIHtAbGluayBSZWN0YW5nbGV9IOeUn+aIkFxuICogQGdyb3VwZnJvbSBSZWN0YW5nbGVcbiAqIEBhdWdtZW50cyBHcm91cFRlbXBsYXRlXG4gKiBAYXVnbWVudHMgUmVjdGFuZ2xlXG4gKiBAcGFyYW0geyhSZWN0YW5nbGV+UmVjdGFuZ2xlQ29uZmlnc3xHcm91cFRlbXBsYXRlfkdyb3VwQ29uZmlncyl9IGNvbmZpZ3MgLSDphY3nva5cbiAqL1xuZXhwb3J0IGNvbnN0IEdyb3VwID0gR3JvdXBGYWN0b3J5KFJlY3RhbmdsZSk7XG4vKiogXG4gKiBAY2xhc3MgQ2Fwc3VsZUdyb3VwXG4gKiBAY2xhc3NkZXNjIOiDtuWbiue7hOWNleWFgyDnlLEge0BsaW5rIEdyb3VwRmFjdG9yeX0g6YCa6L+HIHtAbGluayBDYXBzdWxlfSDnlJ/miJBcbiAqIEBncm91cGZyb20gQ2Fwc3VsZVxuICogQGF1Z21lbnRzIEdyb3VwVGVtcGxhdGVcbiAqIEBhdWdtZW50cyBDYXBzdWxlXG4gKiBAcGFyYW0geyhDYXBzdWxlfkNhcHN1bGVDb25maWdzfEdyb3VwVGVtcGxhdGV+R3JvdXBDb25maWdzKX0gY29uZmlncyAtIOmFjee9rlxuICovXG5leHBvcnQgY29uc3QgQ2Fwc3VsZUdyb3VwID0gR3JvdXBGYWN0b3J5KENhcHN1bGUpO1xuLyoqIFxuICogQGNsYXNzIFJob21idXNHcm91cFxuICogQGNsYXNzZGVzYyDoj7HlvaLnu4TljZXlhYMg55SxIHtAbGluayBHcm91cEZhY3Rvcnl9IOmAmui/hyB7QGxpbmsgUmhvbWJ1c30g55Sf5oiQXG4gKiBAYXVnbWVudHMgR3JvdXBUZW1wbGF0ZVxuICogQGF1Z21lbnRzIFJob21idXNcbiAqIEBncm91cGZyb20gUmhvbWJ1c1xuICogQHBhcmFtIHsoUmhvbWJ1c35SaG9tYnVzQ29uZmlnc3xHcm91cFRlbXBsYXRlfkdyb3VwQ29uZmlncyl9IGNvbmZpZ3MgLSDphY3nva5cbiAqL1xuZXhwb3J0IGNvbnN0IFJob21idXNHcm91cCA9IEdyb3VwRmFjdG9yeShSaG9tYnVzKTtcbi8qKiBcbiAqIEBjbGFzcyBEaWFtb25kR3JvdXBcbiAqIEBjbGFzc2Rlc2Mg6ZK755+z5b2i57uE5Y2V5YWDIOeUsSB7QGxpbmsgR3JvdXBGYWN0b3J5fSDpgJrov4cge0BsaW5rIERpYW1vbmR9IOeUn+aIkFxuICogQGdyb3VwZnJvbSBEaWFtb25kXG4gKiBAYXVnbWVudHMgR3JvdXBUZW1wbGF0ZVxuICogQGF1Z21lbnRzIERpYW1vbmRcbiAqIEBwYXJhbSB7KERpYW1vbmR+RGlhbW9uZENvbmZpZ3N8R3JvdXBUZW1wbGF0ZX5Hcm91cENvbmZpZ3MpfSBjb25maWdzIC0g6YWN572uXG4gKi9cbmV4cG9ydCBjb25zdCBEaWFtb25kR3JvdXAgPSBHcm91cEZhY3RvcnkoRGlhbW9uZCwge1xuICAgIHNoYXBlU2hpZnQod2lkdGgsIGhlaWdodCkge1xuICAgICAgICByZXR1cm4gW3dpZHRoICsgaGVpZ2h0ICogMC4yODg2NSwgaGVpZ2h0XVxuICAgIH1cbn0pO1xuLyoqIFxuICogQGNsYXNzIERpYW1vbmRWZXJ0aWNhbEdyb3VwXG4gKiBAY2xhc3NkZXNjIOWeguebtOmSu+efs+W9oue7hOWNleWFgyDnlLEge0BsaW5rIEdyb3VwRmFjdG9yeX0g6YCa6L+HIHtAbGluayBEaWFtb25kVmVydGljYWx9IOeUn+aIkFxuICogQGdyb3VwZnJvbSBEaWFtb25kVmVydGljYWxcbiAqIEBhdWdtZW50cyBHcm91cFRlbXBsYXRlXG4gKiBAYXVnbWVudHMgRGlhbW9uZFZlcnRpY2FsXG4gKiBAcGFyYW0geyhEaWFtb25kfkRpYW1vbmRDb25maWdzfEdyb3VwVGVtcGxhdGV+R3JvdXBDb25maWdzKX0gY29uZmlncyAtIOmFjee9rlxuICovXG5leHBvcnQgY29uc3QgRGlhbW9uZFZlcnRpY2FsR3JvdXAgPSBHcm91cEZhY3RvcnkoRGlhbW9uZFZlcnRpY2FsLCB7XG4gICAgc2hhcGVTaGlmdCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBbd2lkdGgsIGhlaWdodCArIHdpZHRoICogMC41NzczXVxuICAgIH1cbn0pO1xuLyoqIFxuICogQGNsYXNzIENhcHN1bGVWZXJ0aWNhbEdyb3VwXG4gKiBAY2xhc3NkZXNjIOWeguebtOmSu+efs+W9oue7hOWNleWFgyDnlLEge0BsaW5rIEdyb3VwRmFjdG9yeX0g6YCa6L+HIHtAbGluayBDYXBzdWxlVmVydGljYWx9IOeUn+aIkFxuICogQGdyb3VwZnJvbSBDYXBzdWxlVmVydGljYWxcbiAqIEBhdWdtZW50cyBHcm91cFRlbXBsYXRlXG4gKiBAYXVnbWVudHMgQ2Fwc3VsZVZlcnRpY2FsXG4gKiBAcGFyYW0geyhDYXBzdWxlfkNhcHN1bGVDb25maWdzfEdyb3VwVGVtcGxhdGV+R3JvdXBDb25maWdzKX0gY29uZmlncyAtIOmFjee9rlxuICovXG5leHBvcnQgY29uc3QgQ2Fwc3VsZVZlcnRpY2FsR3JvdXAgPSBHcm91cEZhY3RvcnkoQ2Fwc3VsZVZlcnRpY2FsKTtcblxuZXhwb3J0IGNvbnN0IFBvaW50R3JvdXAgPSBHcm91cEZhY3RvcnkoUG9pbnQsIHtcbiAgICBzaGFwZVNoaWZ0KHdpZHRoLCBoZWlnaHQsIHApIHtcbiAgICAgICAgY29uc3QgciA9IE1hdGguY2VpbChNYXRoLnNxcnQod2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCkgLyAyKTtcbiAgICAgICAgcC5yYWRpdXMgPSByO1xuICAgICAgICBjb25zdCB3ID0gciAqIDI7XG4gICAgICAgIHJldHVybiBbdywgd107XG4gICAgfVxufSk7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2Nyb2xsR3JvdXAgfSBmcm9tICcuLi9pbnN0YW5jZS9ncm91cHMvc2Nyb2xsLWdyb3VwJzsgXG4vKipcbiAqIEB0eXBlZGVmIEpGbG93fkpGbG93Q29uZmlnc1xuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gYWxsb3dEcm9wICAgICAgLSDmmK/lkKblhYHorrggZHJhZ2Ryb3BcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtYXhab29tICAgICAgICAgLSDmnIDlpKfnvKnmlL5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtaW5ab29tICAgICAgICAgLSDmnIDlsI/nvKnmlL5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbml0aWFsWm9vbSAgICAgLSDliJ3lp4vnvKnmlL7mr5RcbiAqIEBwcm9wZXJ0eSB7RXZlbnRBZGFwdGVyfnBsdWdpbkRlZn0gZXZlbnRBZGFwdGVyXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7SkZsb3d+SkZsb3dDb25maWdzIHwgTGF5b3V0TWl4aW5+TGF5b3V0Q29uZmlnc30gSkZsb3d+SkZsb3dMYXlvdXRDb25maWdzXG4gKi9cbi8qKiBcbiAqIEpGbG93IOWvueixoVxuICogSkZsb3cg5pivIGNhbnZhcyDkuIrpnaLlsIHoo4XnmoTkuIDkuKrpobblsYLlr7nosaHvvIzlhbfmnInlpITnkIbkuovku7blkoznu5jliLbnmoTlip/og71cbiAqIEBjb25zdHJ1Y3RvciBKRmxvd1xuICogQHBhcmFtIHtKRmxvd35KRmxvd0xheW91dENvbmZpZ3N9IGNvbmZpZ3MgLSDphY3nva7poblcbiAqIEBtaXhlcyBMYXlvdXRNaXhpblxuICogQG1peGVzIFN0YWNrTWl4aW5cbiAqIEBtaXhlcyBNZXNzYWdlTWl4aW5cbiAqL1xuY2xhc3MgSkZsb3cgZXh0ZW5kcyBFdmVudFRhcmdldHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudW5pcXVlTmFtZSA9ICdqZmxvdyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtFdmVudEFkYXB0ZXJ9IGV2ZW50QWRhcHRlciAgICAtIGV2ZW50QWRhcHRlciDlr7nosaFcbiAgICAgICAgICoqL1xuICAgICAgICB0aGlzLmV2ZW50QWRhcHRlciA9IG5ldyBFdmVudEFkYXB0ZXIoY29uZmlncy5ldmVudEFkYXB0ZXIpO1xuICAgICAgICB0aGlzLmluaXROb2RlV2Vha01hcCgpO1xuICAgICAgICB0aGlzLmluaXRBbmltZSgpO1xuICAgICAgICB0aGlzLmluaXRTdGFjayhjb25maWdzKTtcbiAgICAgICAgdGhpcy5pbml0TGF5b3V0KGNvbmZpZ3MpO1xuICAgICAgICAvKiogQG1lbWJlciB7Q29udGV4dDJkfSAgICAgLSBDb250ZXh0MmQg5a+56LGhICovXG4gICAgICAgIHRoaXMuY3R4ID0gbnVsbDtcbiAgICAgICAgLyoqIEBtZW1iZXIge0VsZW1lbnR9ICAgICAgIC0gY2FudmFzIOWFg+e0oCAqL1xuICAgICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtudW1iZXJ9ICAgICAgIC0g6K6+5aSHRFBSICovXG4gICAgICAgIHRoaXMuZHByID0gMTtcbiAgICAgICAgLyoqIEBtZW1iZXIge251bWJlcn0gICAgICAgLSDlhoXovrnot50gKi9cbiAgICAgICAgdGhpcy5wYWRkaW5nID0gMjA7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBudWxsO1xuICAgICAgICAvKiogQG1lbWJlciB7bnVtYmVyfSAgICAgLSDnvKnmlL4gKi9cblx0XHR0aGlzLnNjYWxlID0gbnVsbDtcbiAgICAgICAgLyoqIEBtZW1iZXIge251bWJlcn0gICAgIC0g5Yid5aeL57yp5pS+ICovXG4gICAgICAgIHRoaXMuaW5pdGlhbFpvb20gPSBjb25maWdzLmluaXRpYWxab29tO1xuICAgICAgICAvKiogQG1lbWJlciB7c2V0SW5pdGlhbFBvc2l0aW9ufSAtIOWIneWni+S9jee9ruiuoeeulyAqL1xuICAgICAgICB0aGlzLmluaXRpYWxQb3NpdGlvbiA9IGNvbmZpZ3Muc2V0SW5pdGlhbFBvc2l0aW9uO1xuICAgICAgICAvKiogQG1lbWJlciB7bnVtYmVyfSAgICAgLSDmnIDlpKfnvKnmlL4gKi9cbiAgICAgICAgdGhpcy5tYXhab29tID0gY29uZmlncy5tYXhab29tIHx8IDM7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtudW1iZXJ9ICAgICAtIOacgOWwj+e8qeaUviAqL1xuICAgICAgICB0aGlzLm1pblpvb20gPSBjb25maWdzLm1pblpvb20gfHwgLjU7XG4gICAgICAgIFxuICAgICAgICB0aGlzLk5vZGVSZW5kZXJUb3AgPSAhIWNvbmZpZ3MuTm9kZVJlbmRlclRvcFxuXG4gICAgICAgIHRoaXMud29ybGRNYXJnaW4gPSBjb25maWdzLndvcmxkTWFyZ2luO1xuXG4gICAgICAgIHRoaXMuZHJhZ2dpbmdiZWhhdmlvciA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgcGFuSW5Cb3JkZXI6IHtcbiAgICAgICAgICAgICAgICBlbmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMjAsXG4gICAgICAgICAgICAgICAgZGVsdGFtb3ZlbWVudDogOCxcbiAgICAgICAgICAgICAgICBhbGxvd01vdmluZ1RhcmdldEluUGFuOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgY29uZmlncy5kcmFnZ2luZ2JlaGF2aW9yIHx8IHt9KTtcbiAgICAgICAgdGhpcy5zY3JvbGxCYXJCZWhhdmlvciA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgZW5hYmxlOiB0cnVlLFxuICAgICAgICB9LCBjb25maWdzLnNjcm9sbEJhckJlaGF2aW9yIHx8IHt9KVxuXHRcdC8vIHRoaXMuaW5pdFNjYWxlID0gMTtcblx0XHQvLyB0aGlzLmluaXRQb3NpdGlvbiA9IG51bGxcblx0XHR0aGlzLm9mZmVzZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXN0U3RhdGUgPSB7XG4gICAgICAgICAgICB4OiBudWxsLFxuICAgICAgICAgICAgeTogbnVsbCxcbiAgICAgICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIHByb2Nlc3Npbmc6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2xhc3REcmFnU3RhdGUgPSB7XG4gICAgICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgICAgICB0YXJnZXRMaW5rOiBudWxsLFxuICAgICAgICAgICAgcHJvY2Vzc2luZzogZmFsc2UsXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90YXJnZXQgPSB7XG4gICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgIGxpbms6IG51bGwsXG4gICAgICAgICAgICBtb3Zpbmc6IG51bGwsXG4gICAgICAgICAgICBpc0luc3RhbmNlRGlydHk6IGZhbHNlLCBcbiAgICAgICAgICAgIGlzTGlua0RpcnR5OiBmYWxzZSwgXG4gICAgICAgICAgICAvLyBpc01vdmluZ0RpcnR5OiBmYWxzZSwgXG4gICAgICAgICAgICBjYWNoZToge1xuICAgICAgICAgICAgICAgIHN0YWNrOiBudWxsLFxuICAgICAgICAgICAgICAgIGJlbG9uZ3M6IG51bGwsXG4gICAgICAgICAgICAgICAgcG9pbnQ6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgIHg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgaW5pdGlhbFg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBpbml0aWFsWTogdW5kZWZpbmVkLCBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICBkcmFnb3ZlcmluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHByb2Nlc3Npbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1vdmluZ1N0YXRlOiBmYWxzZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZvY3VzID0ge1xuICAgICAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kcmFnT3ZlclRhcmdldCA9IG51bGw7XG4gICAgICAgIC8vIHRoaXMubG9jayA9IGNvbmZpZ3MubG9jaztcblxuICAgICAgICB0aGlzLmFsbG93RHJvcCA9IGNvbmZpZ3MuYWxsb3dEcm9wO1xuICAgICAgICAvLyDkuLTml7bnu5jliLbnmoTlr7nosaFcbiAgICAgICAgdGhpcy5fdGVtcE5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLl90ZW1wTGluayA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5tb2RlID0gSkZMT1dfTU9ERS5ERUZBVUxUO1xuXG4gICAgICAgIHRoaXMuX2FsbG93TW92aW5nVGFyZ2V0ID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmNhbnZhc01ldGEgPSB7fVxuXG4gICAgICAgIHRoaXMuX2NhY2hlVmlld0JveCA9IFtdXG5cbiAgICAgICAgdGhpcy5fX21vdW50ZWRfXyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIHRoaXMuX2FsbG93Wm9vbSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gYWxsb3dab29tKCkge1xuICAgIC8vICAgICB0aGlzLl9hbGxvd1pvb20gPSB0cnVlO1xuICAgIC8vIH1cblxuICAgIC8vIGFiYW5kb25ab29tKCkge1xuICAgIC8vICAgICB0aGlzLl9hbGxvd1pvb20gPSBmYWxzZTtcbiAgICAvLyB9XG4gICAgLyoqXG4gICAgICog6K6+572u5b2T5YmN5ouW5Yqo55qEIEpGbG93IOWvueixoVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHRhcmdldHMgLSDlhbfmnIkgYW5jaG9yIOWxnuaAp+eahOWvueixoVxuICAgICAqL1xuICAgIHNldE1vdmluZ1RhcmdldHModGFyZ2V0cykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3RhcmdldCwge1xuICAgICAgICAgICAgbW92aW5nOiB0YXJnZXRzLCAgICAgICBcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorr7nva7lvZPliY3mi5bliqjnmoQgSkZsb3cg5a+56LGhXG4gICAgICogQHBhcmFtIHtJbnN0YW5jZX0gaW5zdGFuY2UgLSBKRmxvdyDlr7nosaFcbiAgICAgKi9cbiAgICBzZXRUZW1wRHJhZ2dpbmdJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgICAgICBpbnN0YW5jZS5fYmVsb25ncyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3RlbXBOb2RlID0gaW5zdGFuY2U7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fdGFyZ2V0LCB7XG4gICAgICAgICAgICBtb3Zpbmc6IFt0aGlzLl90ZW1wTm9kZV0sXG4gICAgICAgICAgICBkcmFnZ2luZzogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlj5bmtojlvZPliY3mi5bliqjnmoQgSkZsb3cg5a+56LGhXG4gICAgICogQHJldHVybiB7bnVtYmVyW119IHBvaW50IC0gSkZsb3cg5Z2Q5qCHXG4gICAgICovXG4gICAgcmVtb3ZlVGVtcERyYWdnaW5nSW5zdGFuY2UoKSB7XG4gICAgICAgIGlmKHRoaXMuX3RlbXBOb2RlKSB7XG4gICAgICAgICAgICAvLyB0aGlzLnJlbW92ZUZyb21TdGFjayh0aGlzLl90ZW1wTm9kZSk7XG4gICAgICAgICAgICBjb25zdCBhbmNob3IgPSB0aGlzLl90ZW1wTm9kZS5hbmNob3I7XG4gICAgICAgICAgICB0aGlzLl90ZW1wTm9kZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gYW5jaG9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOWFs+mXrem7mOiupOWvueixoeaLluWKqOaViOaenFxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0RHJhZ2dpbmcoKSB7XG4gICAgICAgIHRoaXMuX2FsbG93TW92aW5nVGFyZ2V0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOW8gOWQr+m7mOiupOWvueixoeaLluWKqOaViOaenFxuICAgICAqL1xuICAgIGFsbG93RGVmYXVsdERyYWdnaW5nKCkge1xuICAgICAgICB0aGlzLl9hbGxvd01vdmluZ1RhcmdldCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOWcqCBEb2N1bWVudCDlhYPntKDkuIrliJ3lp4vljJblrp7kvotcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGRvbSBcbiAgICAgKi9cbiAgICAkbW91bnQoZG9tKSB7XG4gICAgICAgIGNvbnN0IHsgXG4gICAgICAgICAgICBjYW52YXMsIFxuICAgICAgICAgICAgY3R4LCBcbiAgICAgICAgICAgIHNjYWxlOiBkcHIsIFxuICAgICAgICAgICAgd2lkdGg6IGNfd2lkdGgsIFxuICAgICAgICAgICAgaGVpZ2h0OiBjX2hlaWdodCwgXG4gICAgICAgICAgICByYXdfd2lkdGgsXG4gICAgICAgICAgICByYXdfaGVpZ2h0LFxuICAgICAgICAgICAgbGVmdCwgdG9wIFxuICAgICAgICB9ID0gY3JlYXRlQ2FudmFzKGRvbSk7XG4gICAgICAgIHRoaXMucmVmbG93KCk7XG4gICAgICAgIHRoaXMuY3R4ID0gY3R4IC8vbmV3IENhbnZhc0NvbnRleHQyZChjdHgsIGRwcik7XG4gICAgICAgIHRoaXMuRE9Nd3JhcHBlciA9IGRvbTtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICAgIHRoaXMuY2FudmFzLnNldEF0dHJpYnV0ZSgnZGF0YS1qZmxvdycsIHRydWUpO1xuICAgICAgICB0aGlzLmNhbnZhcy4kamZsb3cgPSB0aGlzO1xuICAgICAgICB0aGlzLmNhbnZhc01ldGEgPSB7XG4gICAgICAgICAgICB3aWR0aDogcmF3X3dpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiByYXdfaGVpZ2h0LFxuICAgICAgICAgICAgYWN0dWFsX3dpZHRoOiBjX3dpZHRoLFxuICAgICAgICAgICAgYWN0dWFsX2hlaWdodDogY19oZWlnaHRcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRwciA9IGRwcjtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2dldEJvdW5kaW5nR3JvdXBSZWN0KCk7XG5cbiAgICAgICAgY29uc3QgcGFkZGluZyA9IHRoaXMucGFkZGluZztcbiAgICAgICAgY29uc3QgeyB3aWR0aDogcF93aWR0aCwgaGVpZ2h0OiBwX2hlaWdodCwgeDogcF94LCB5OiBwX3kgfSA9IHRoaXMuYm91bmRpbmdfYm94O1xuICAgICAgICBjb25zdCBjb250ZW50Qm94ID0ge1xuICAgICAgICAgICAgeDogcGFkZGluZyxcbiAgICAgICAgICAgIHk6IHBhZGRpbmcsXG4gICAgICAgICAgICB3aWR0aDogY193aWR0aCAtIHBhZGRpbmcgKiAyLFxuICAgICAgICAgICAgaGVpZ2h0OiBjX2hlaWdodCAtIHBhZGRpbmcgKiAyLFxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0geyB4OiAwLCB5OiAwLCBvZmZzZXRYOiAwLCBvZmZzZXRZOiAwIH07XG4gICAgICAgIGNvbnN0IHdfcmF0aW8gPSBjb250ZW50Qm94LndpZHRoIC8gcF93aWR0aDtcbiAgICAgICAgY29uc3QgaF9yYXRpbyA9IGNvbnRlbnRCb3guaGVpZ2h0IC8gcF9oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGFsaWduID0gd19yYXRpbyA8PSBoX3JhdGlvID8gJ3gnIDogJ3knO1xuICAgICAgICBsZXQgc2NhbGVSYXRpbztcbiAgICAgICAgaWYodGhpcy5pbml0aWFsWm9vbSkge1xuICAgICAgICAgICAgc2NhbGVSYXRpbyA9IHRoaXMuaW5pdGlhbFpvb207XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2FsZVJhdGlvID0gTWF0aC5taW4od19yYXRpbywgaF9yYXRpbyk7XG4gICAgICAgIH1cbiAgICAgICBcbiAgICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlUmF0aW87XG4gICAgICAgIGlmKHNjYWxlUmF0aW8gPiB0aGlzLm1heFpvb20pIHtcbiAgICAgICAgICAgIHRoaXMubWF4Wm9vbSA9IHNjYWxlUmF0aW87XG4gICAgICAgIH1cbiAgICAgICAgaWYoc2NhbGVSYXRpbyA8IHRoaXMubWluWm9vbSkge1xuICAgICAgICAgICAgdGhpcy5taW5ab29tID0gc2NhbGVSYXRpbztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWFsYm94WCA9IHBfeCAqIHNjYWxlUmF0aW87XG4gICAgICAgIGNvbnN0IHJlYWxib3hZID0gcF95ICogc2NhbGVSYXRpbztcbiAgICAgICAgY29uc3QgcmVhbGJveFcgPSBjb250ZW50Qm94LndpZHRoO1xuICAgICAgICBjb25zdCByZWFsYm94SCA9IGNvbnRlbnRCb3guaGVpZ2h0O1xuICAgICAgICBpZih0aGlzLmluaXRpYWxQb3NpdGlvbikge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLmluaXRpYWxQb3NpdGlvbihyZWFsYm94WCwgcmVhbGJveFksIHJlYWxib3hXLCByZWFsYm94SCwgY29udGVudEJveC54LCBjb250ZW50Qm94LnksIGNfd2lkdGgsIGNfaGVpZ2h0LCBwX3gsIHBfeSwgcF93aWR0aCwgcF9oZWlnaHQpO1xuICAgICAgICAgICAgcG9zaXRpb24ueCA9IHg7XG4gICAgICAgICAgICBwb3NpdGlvbi55ID0geTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLnggPSBhbGlnbiA9PT0gJ3gnID8gY29udGVudEJveC54IDogKHJlYWxib3hXIC0gcF93aWR0aCAqIHNjYWxlUmF0aW8pIC8gMiArIHBhZGRpbmdcbiAgICAgICAgICAgIHBvc2l0aW9uLnkgPSBhbGlnbiA9PT0gJ3knID8gY29udGVudEJveC55IDogKHJlYWxib3hIIC0gcF9oZWlnaHQgKiBzY2FsZVJhdGlvKSAvIDIgKyBwYWRkaW5nXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHBvc2l0aW9uLm9mZnNldFggPSBwb3NpdGlvbi54IC0gcmVhbGJveFg7XG4gICAgICAgIHBvc2l0aW9uLm9mZnNldFkgPSBwb3NpdGlvbi55IC0gcmVhbGJveFk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgdGhpcy5fcmVhZHlUb1JlbmRlciA9IHRydWU7XG4gICAgICAgIGlmKHRoaXMuc2Nyb2xsQmFyQmVoYXZpb3IuZW5hYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRTY3JvbGxCYXIodGhpcy5zY3JvbGxCYXJCZWhhdmlvcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcy5pbml0U2NoZWR1bGUoKTtcbiAgICAgICAgLy8gdGhpcy5zY2hlZHVsZVJlbmRlcigoKSA9PiB7XG4gICAgICAgIC8vICAgICB0aGlzLl9jcmVhdGVFdmVudEhhbmRsZXIoKTtcbiAgICAgICAgLy8gfSk7XG4gICAgICAgIHRoaXMuX19yZW5kZXIoKTtcbiAgICAgICAgdGhpcy5fY3JlYXRlRXZlbnRIYW5kbGVyKCk7XG4gICAgICAgIFxuICAgICAgICBsaXN0ZW5PbkRldmljZVBpeGVsUmF0aW8oKGRwcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5kcHIgPSBkcHI7XG4gICAgICAgICAgICAvLyB0aGlzLmN0eC5zZXREUFIoZHByKVxuICAgICAgICAgICAgdGhpcy5yZXNpemVDYW52YXMoKTtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgfSwgKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveURwckxpc3RlbmVyID0gaGFuZGxlcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX19tb3VudGVkX18gPSB0cnVlO1xuICAgICAgICBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorr7nva5KZmxvd+i/m+WFpei/nue6v+aooeW8j1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgLSDlvZPliY3ov57nur/nmoTlh7rlj5Hljp/lp4vmlbDmja5cbiAgICAgKiBAcGFyYW0ge2xpbmtHZW59IGxpbmtHZW4gLSDnlJ/miJDov57nur/ljZXlhYPnmoTmlrnms5VcbiAgICAgKi9cbiAgICBzZXRMaW5raW5nTW9kZShzb3VyY2UsIGxpbmtHZW4sIGlzVGFpbCkge1xuICAgICAgICBjb25zdCByZW5kZXJOb2RlID0gdGhpcy5nZXRSZW5kZXJOb2RlQnlTb3VyY2Uoc291cmNlKVxuICAgICAgICB0aGlzLl90ZW1wTm9kZSA9IG5ldyBHaG9zdE5vZGUoKTtcbiAgICAgICAgaWYoaXNUYWlsKSB7XG4gICAgICAgICAgICB0aGlzLl90ZW1wTGluayA9IGxpbmtHZW4oe1xuICAgICAgICAgICAgICAgIGZyb206IHRoaXMuX3RlbXBOb2RlLFxuICAgICAgICAgICAgICAgIHRvOiByZW5kZXJOb2RlLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBMaW5rID0gbGlua0dlbih7XG4gICAgICAgICAgICAgICAgZnJvbTogcmVuZGVyTm9kZSxcbiAgICAgICAgICAgICAgICB0bzogdGhpcy5fdGVtcE5vZGUsXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIGluc3RhbmNlOiBzb3VyY2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZSA9IEpGTE9XX01PREUuTElOS0lORztcbiAgICB9XG5cbiAgICBpc0luTGlua2luZ01vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGUgPT09IEpGTE9XX01PREUuTElOS0lORztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDov57nur/mqKHlvI/kuIvvvIzorr7nva7lvZPliY3kuLTml7bov57nur/nmoTlsZ7mgKdcbiAgICAgKiBAcGFyYW0ge0Jhc2VMaW5rfkNvbmZpZ3N9IGNvbmZpZ3MgLSDlvZPliY3ov57nur/nmoTlh7rlj5Hljp/lp4vmlbDmja5cbiAgICAgKi9cbiAgICBzZXRMaW5raW5nTGluayhjb25maWdzKSB7XG4gICAgICAgIGlmKHRoaXMubW9kZSA9PT0gSkZMT1dfTU9ERS5MSU5LSU5HKSB7XG4gICAgICAgICAgICB0aGlzLl90ZW1wTGluay5zZXRDb25maWcoY29uZmlncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICog6L+e57q/5qih5byP5LiL77yM6YeN6L+e5Zue5Li05pe26byg5qCH6IqC54K5XG4gICAgICovXG4gICAgcmVzZXRMaW5raW5nTGluaygpIHtcbiAgICAgICAgaWYodGhpcy5tb2RlID09PSBKRkxPV19NT0RFLkxJTktJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBMaW5rLnNldENvbmZpZyh7XG4gICAgICAgICAgICAgICAgdG86IHRoaXMuX3RlbXBOb2RlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xlYXJUZW1wKCkge1xuICAgICAgICBpZih0aGlzLl90ZW1wTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fdGVtcE5vZGUuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5fdGVtcE5vZGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuX3RlbXBMaW5rKSB7XG4gICAgICAgICAgICB0aGlzLl90ZW1wTGluay5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLl90ZW1wTGluayA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgfVxuXG4gICAgcHJldmVudENsZWFyVGVtcCgpIHtcbiAgICAgICAgdGhpcy5fcHJldmVudENsZWFyVGVtcCA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5aSW5bGC5a655Zmo5aSn5bCP5Y+Y5YyW5ZCO77yM6LCD55So5q2k5pa55rOV5Y+v5Lul5pS55Y+Y5b2T5YmNY2FudmFz55qE54q25oCBXG4gICAgICovXG4gICAgcmVzaXplQ2FudmFzKCkge1xuICAgICAgICBpZih0aGlzLmNhbnZhcyAmJiB0aGlzLkRPTXdyYXBwZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogY193aWR0aCwgXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBjX2hlaWdodCwgXG4gICAgICAgICAgICAgICAgcmF3X3dpZHRoLFxuICAgICAgICAgICAgICAgIHJhd19oZWlnaHQsXG4gICAgICAgICAgICB9ID0gcmVzaXplQ2FudmFzKHRoaXMuY2FudmFzLCB0aGlzLkRPTXdyYXBwZXIpO1xuICAgICAgICAgICAgdGhpcy5jYW52YXNNZXRhID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiByYXdfd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiByYXdfaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGFjdHVhbF93aWR0aDogY193aWR0aCxcbiAgICAgICAgICAgICAgICBhY3R1YWxfaGVpZ2h0OiBjX2hlaWdodFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0Rm9jdXNJbnN0YW5jZShub2RlKSB7XG4gICAgICAgIHRoaXMuX2ZvY3VzLmluc3RhbmNlID0gbm9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDnp7vliqjnlLvluIPliLDku6Xnm67moIfnu5jlm77oioLngrnkuLrkuK3lv4PnmoTkvY3nva7kuIpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSDnu5jlm77oioLngrlcbiAgICAgKi9cbiAgICBmb2N1c09uKG5vZGUpIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gdGhpcy5fY2FsY3VsYXRlUG9pbnRCYWNrKFtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzTWV0YS5hY3R1YWxfd2lkdGgvMixcbiAgICAgICAgICAgIHRoaXMuY2FudmFzTWV0YS5hY3R1YWxfaGVpZ2h0LzJcbiAgICAgICAgXSk7XG4gICAgICAgIGxldCBvZmZzZXQgPSBub2RlLmFuY2hvcjtcbiAgICAgICAgaWYobm9kZS5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbikge1xuICAgICAgICAgICAgb2Zmc2V0ID0gbm9kZS5fYmVsb25ncy5jYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbihvZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGVsdGFYID0gKGNlbnRlclswXSAtIG9mZnNldFswXSkgKiB0aGlzLnNjYWxlO1xuICAgICAgICBjb25zdCBkZWx0YVkgPSAoY2VudGVyWzFdIC0gb2Zmc2V0WzFdKSAqIHRoaXMuc2NhbGU7XG4gICAgICAgIFxuXG4gICAgICAgIHRoaXMuX3JlY2FsY3VsYXRlUG9zaXRpb24oZGVsdGFYLCBkZWx0YVkpXG4gICAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgIH1cbiAgICBcbiAgICBfZ2V0Qm91bmRpbmdHcm91cFJlY3QoKSB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX3N0YWNrLmdldEJvdW5kaW5nUmVjdFBvaW50cygpO1xuICAgICAgICBpZih0aGlzLmJvdW5kaW5nX2JveCkge1xuICAgICAgICAgICAgdGhpcy5ib3VuZGluZ19ib3ggPSBib3VuZGluZ19ib3gocG9pbnRzKTtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICB4OiBub3d4LFxuICAgICAgICAgICAgICAgIHk6IG5vd3ksXG4gICAgICAgICAgICB9ID0gdGhpcy5ib3VuZGluZ19ib3g7XG4gICAgICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnggPSB0aGlzLnBvc2l0aW9uLm9mZnNldFggKyBub3d4ICogc2NhbGU7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnkgPSB0aGlzLnBvc2l0aW9uLm9mZnNldFkgKyBub3d5ICogc2NhbGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nX2JveCA9IGJvdW5kaW5nX2JveChwb2ludHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NyZWF0ZUV2ZW50SGFuZGxlcigpIHsgXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgICBsZXQgZGVzdHJveUxpc3RlbmVyO1xuICAgICAgICB0aGlzLmV2ZW50QWRhcHRlci5hcHBseSh0aGlzKTtcbiAgICAgICAgY29uc3QgZGVzdHJveVBsYWluRXZlbnRMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRBZGFwdGVyLnVubG9hZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveURwckxpc3RlbmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdHJveUxpc3RlbmVyID0gZGVzdHJveVBsYWluRXZlbnRMaXN0ZW5lcjtcblxuICAgICAgICBpZih0aGlzLmFsbG93RHJvcCkge1xuICAgICAgICAgICAgY29uc3QgZHJhZ292ZXJIYW5kbGVyID0gdGhpcy5fb25EcmFnb3Zlci5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgZHJvcEhhbmRsZXIgPSB0aGlzLl9vbkRyb3AuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGRyYWdsZWF2ZUhhbmxkZXIgPSB0aGlzLl9vbkRyYWdMZWF2ZS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgZHJhZ292ZXJIYW5kbGVyKTtcbiAgICAgICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdkcm9wJywgZHJvcEhhbmRsZXIpO1xuICAgICAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdsZWF2ZScsIGRyYWdsZWF2ZUhhbmxkZXIpO1xuICAgICAgICAgICAgZGVzdHJveUxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlc3Ryb3lQbGFpbkV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCBkcmFnb3ZlckhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcm9wJywgZHJvcEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLCBkcmFnbGVhdmVIYW5sZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBcbiAgICAgICAgdGhpcy5kZXN0cm95ID0gZGVzdHJveUxpc3RlbmVyO1xuICAgIH1cblxuICAgIF90YXJnZXRMb2NrT24ob2Zmc2V0UG9pbnQsIGV2ZW50KSB7XG4gICAgICAgIGxldCBwb2ludCA9IHRoaXMuX2NhbGN1bGF0ZVBvaW50QmFjayhvZmZzZXRQb2ludCk7XG4gICAgICAgIGNvbnN0IHRvcExheWVyUG9pbnQgPSBwb2ludDtcbiAgICAgICAgdGhpcy5fY3VycmVudHAgPSBwb2ludDtcbiAgICAgICAgbGV0IHN0YWNrID0gdGhpcy5fc3RhY2s7XG4gICAgICAgIGNvbnN0IGJyID0gdGhpcy5fZ2V0Vmlld0JveCgpO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBzdGFjay5jaGVja0hpdChcbiAgICAgICAgICAgIHBvaW50LCBcbiAgICAgICAgICAgIC8vIOW6lOeUqOS6juaJgOaciVxuICAgICAgICAgICAgKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl90YXJnZXQuc3RhdHVzLmRyYWdnaW5nIFxuICAgICAgICAgICAgICAgICAgICAmJiAoaW5zdGFuY2UgPT09IHRoaXMuX2dldE1vdmluZ1RhcmdldCgpKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyDku4Xlr7nkuo7mnKzlsYLov4fmu6RcbiAgICAgICAgICAgIChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb092ZXJsYXAoYnIsIGluc3RhbmNlLmdldEJvdW5kaW5nUmVjdCgpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGxldCBsaW5rU3RhY2sgPSB0aGlzLl9saW5rU3RhY2s7XG4gICAgICAgIGxldCBiZWxvbmdzID0gdGhpcztcbiAgICAgICAgLypcbiAgICAgICAgaWYodGFyZ2V0KSB7XG4gICAgICAgICAgICBsaW5rU3RhY2sgPSB0YXJnZXQuX2JlbG9uZ3MuX2xpbmtTdGFjaztcbiAgICAgICAgICAgIHBvaW50ID0gdGFyZ2V0Ll9iZWxvbmdzLl9jdXJyZW50cDtcbiAgICAgICAgICAgIHN0YWNrID0gdGFyZ2V0Ll9iZWxvbmdzLl9zdGFjaztcbiAgICAgICAgICAgIGJlbG9uZ3MgPSB0YXJnZXQuX2JlbG9uZ3NcbiAgICAgICAgfSovXG4gICAgICAgIC8vIOaaguaXtuiuvuWumuWPquaciemhtuWxguaciei/nue6v1xuICAgICAgICBsZXQgdGFyZ2V0TGluaztcbiAgICAgICAgaWYoIXRhcmdldCB8fCB0YXJnZXQuX2JlbG9uZ3MgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHRhcmdldExpbmsgPSBsaW5rU3RhY2suY2hlY2tIaXQocG9pbnQsIChsaW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuX3RhcmdldC5zdGF0dXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBtb3Zpbmd0YXJnZXQgPSB0aGlzLl9nZXRNb3ZpbmdUYXJnZXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGluay5mcm9tID09PSBtb3Zpbmd0YXJnZXQgfHwgbGluay50byA9PT0gbW92aW5ndGFyZ2V0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIXRhcmdldExpbmspIHtcbiAgICAgICAgICAgIHRhcmdldExpbmsgPSBsaW5rU3RhY2suY2hlY2tIaXQocG9pbnQsIChsaW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFsaW5rLk9OX1RPUDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3RhcmdldCwge1xuICAgICAgICAgICAgaW5zdGFuY2U6IHRhcmdldCxcbiAgICAgICAgICAgIGxpbms6IHRhcmdldExpbmssIFxuICAgICAgICAgICAgaXNJbnN0YW5jZURpcnR5OiB0YXJnZXQgPT09IHRoaXMuX3RhcmdldC5pbnN0YW5jZSxcbiAgICAgICAgICAgIGlzTGlua0RpcnR5OiB0YXJnZXRMaW5rID09PSB0aGlzLl90YXJnZXQubGluayxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fdGFyZ2V0LmNhY2hlLCB7XG4gICAgICAgICAgICBzdGFjayxcbiAgICAgICAgICAgIGJlbG9uZ3MsXG4gICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgIHRvcExheWVyUG9pbnQsXG4gICAgICAgIH0pXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fdGFyZ2V0Lm1ldGEsIHtcbiAgICAgICAgICAgIHg6IG9mZnNldFBvaW50WzBdLFxuICAgICAgICAgICAgeTogb2Zmc2V0UG9pbnRbMV0sXG4gICAgICAgIH0pO1xuICAgICBcbiAgICAgICAgaWYoZXZlbnQgPT09ICdwcmVzc1N0YXJ0JyAmJiAhdGhpcy5fdGFyZ2V0LnN0YXR1cy5kcmFnZ2luZyAmJiAhdGhpcy5fdGFyZ2V0LnN0YXR1cy5kcmFnb3ZlcmluZykge1xuICAgICAgICAgICAgbGV0IG1vdmluZ3RhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICAgIHdoaWxlIChtb3Zpbmd0YXJnZXQgJiYgbW92aW5ndGFyZ2V0Ll9iZWxvbmdzLmxvY2sgJiYgbW92aW5ndGFyZ2V0ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgbW92aW5ndGFyZ2V0ID0gbW92aW5ndGFyZ2V0Ll9iZWxvbmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRNb3ZpbmdUYXJnZXRzKG1vdmluZ3RhcmdldCAmJiBbIG1vdmluZ3RhcmdldCBdKVxuICAgICAgICAgICAgaWYobW92aW5ndGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgICAgICog5byA5aeL5ouW5ou95pe277yM5ouW5ou95a+56LGh6K6+572u5LmL5YmNXG4gICAgICAgICAgICAgICAgICogQGV2ZW50IE5vZGUjYWZ0ZXJSZXNvbHZlTW92aW5nVGFyZ2V0XG4gICAgICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0V2ZW50fSBldmVudCAgICAgICAgICAgLSDljp/lp4vkuovku7YgXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtKRmxvd30gamZsb3cgICAgICAgICAgIC0g5b2T5YmNSkZsb3flr7nosaEgXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtOb2RlfSB0YXJnZXQgICAgICAgICAgIC0g55uu5qCH6IqC54K5XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmJ1YmJsZUV2ZW50KG5ldyBKRmxvd0V2ZW50KCdhZnRlclJlc29sdmVNb3ZpbmdUYXJnZXQnLCB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IG1vdmluZ3RhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKFsncHJlc3NTdGFydCcsICdjbGljaycsICdkYmxjbGljaycsICdjb250ZXh0Y2xpY2snXS5pbmNsdWRlcyhldmVudCkpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuX2ZvY3VzLmluc3RhbmNlICYmIHRoaXMuX2ZvY3VzLmluc3RhbmNlICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb2N1cy5pbnN0YW5jZS5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdibHVyJywge1xuICAgICAgICAgICAgICAgICAgICByZWxhdGVkVGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZvY3VzLmluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgIH0gICBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0O1xuICAgIH1cblxuICAgIGJsdXIoKSB7XG4gICAgICAgIGlmKHRoaXMuX2ZvY3VzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9mb2N1cy5pbnN0YW5jZS5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdibHVyJywge1xuICAgICAgICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IG51bGwsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB0aGlzLl9mb2N1cy5pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIH0gIFxuICAgIH1cblxuICAgIF9nZXRNb3ZpbmdUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXQubW92aW5nICYmIHRoaXMuX3RhcmdldC5tb3ZpbmdbMF07XG4gICAgfVxuXG4gICAgX3Byb2Nlc3NEcmFnT3ZlcihpbnN0YW5jZSwgZXZlbnQpIHtcbiAgICAgICAgaWYodGhpcy5fZHJhZ092ZXJUYXJnZXQgIT09IGluc3RhbmNlKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnJlYWRNZXNzYWdlKCk/Lmluc3RhbmNlO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ0N1cnJlbnREYXRhID0gdGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgeyBwb2ludCB9ID0gdGhpcy5fdGFyZ2V0LmNhY2hlO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ19wcm9jZXNzRHJhZ092ZXInLCB0aGlzLl9kcmFnT3ZlclRhcmdldClcbiAgICAgICAgICAgIGlmKHRoaXMuX2RyYWdPdmVyVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkSW5zID0gdGhpcy5fZHJhZ092ZXJUYXJnZXQ7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgKiBkcmFnbGVhdmUg6YCA5Ye65LqL5Lu2XG4gICAgICAgICAgICAgICAgKiBAZXZlbnQgSW5zdGFuY2UjZHJhZ2xlYXZlXG4gICAgICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtFdmVudH0gZXZlbnQgICAgICAgICAgIC0g5Y6f5aeL5LqL5Lu2IFxuICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IGluc3RhbmNlICAgICAgIC0gZHJhZ2xlYXZl55qE5a+56LGhIFxuICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHt0YXJnZXR9IHRhcmdldCAgICAgICAgIC0gZHJhZyDmkLrluKbnmoTlr7nosaHvvIjnibnmjIfku47lpJbpnaLmi5bov5tjYW52YXPnmoTlr7nosaHvvIkgXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBvbGRJbnMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnZHJhZ2xlYXZlJywge1xuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IG9sZElucyxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAqIGRyYWdlbnRlciDov5vlhaXkuovku7ZcbiAgICAgICAgICAgICAgICAqIEBldmVudCBJbnN0YW5jZSNkcmFnZW50ZXJcbiAgICAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0V2ZW50fSBldmVudCAgICAgICAgICAgLSDljp/lp4vkuovku7YgXG4gICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gaW5zdGFuY2UgICAgICAgLSBkcmFnZW50ZXLnmoTlr7nosaEgXG4gICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge3RhcmdldH0gdGFyZ2V0ICAgICAgICAgLSBkcmFnIOaQuuW4pueahOWvueixoe+8iOeJueaMh+S7juWklumdouaLlui/m2NhbnZhc+eahOWvueixoe+8iSBcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2RyYWdlbnRlcicsIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBwb2ludFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RyYWdPdmVyVGFyZ2V0ID0gaW5zdGFuY2U7XG4gICAgICAgIH0gZWxzZSBpZih0aGlzLl9kcmFnT3ZlclRhcmdldCl7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICogZHJhZ292ZXIg6L+b5YWl5LqL5Lu2XG4gICAgICAgICAgICAqIEBldmVudCBJbnN0YW5jZSNkcmFnb3ZlclxuICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgKiBAcHJvcGVydHkge0V2ZW50fSBldmVudCAgICAgICAgICAgLSDljp/lp4vkuovku7YgXG4gICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBpbnN0YW5jZSAgICAgICAtIGRyYWdvdmVy55qE5a+56LGhIFxuICAgICAgICAgICAgKiBAcHJvcGVydHkge3RhcmdldH0gdGFyZ2V0ICAgICAgICAgLSBkcmFnIOaQuuW4pueahOWvueixoe+8iOeJueaMh+S7juWklumdouaLlui/m2NhbnZhc+eahOWvueixoe+8iSBcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9kcmFnT3ZlclRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdkcmFnb3ZlcicsIHtcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMuX2RyYWdDdXJyZW50RGF0YSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NQYW5JbkJvcmRlcigpO1xuICAgIH1cblxuICAgIF9wcm9jZXNzUGFuSW5Cb3JkZXIoKSB7XG4gICAgICAgIGlmKHRoaXMuZHJhZ2dpbmdiZWhhdmlvcj8ucGFuSW5Cb3JkZXI/LmVuYWJsZSkge1xuICAgICAgICAgICAgaWYoIXRoaXMuZHJhZ2dpbmdiZWhhdmlvci5wYW5JbkJvcmRlci50aW1lcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdiZWhhdmlvci5wYW5JbkJvcmRlci50aW1lciA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihEYXRlLm5vdygpIC0gdGhpcy5kcmFnZ2luZ2JlaGF2aW9yLnBhbkluQm9yZGVyLnRpbWVyID4gNTAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3gsIHksIHcsIGhdID0gdGhpcy5fY2FjaGVWaWV3Qm94O1xuICAgICAgICAgICAgICAgIGNvbnN0IFtweCwgcHldID0gdGhpcy5fY3VycmVudHA7XG4gICAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YW1vdmVtZW50XG4gICAgICAgICAgICAgICAgfSA9IHRoaXMuZHJhZ2dpbmdiZWhhdmlvci5wYW5JbkJvcmRlcjtcbiAgICAgICAgICAgICAgICBsZXQgZGVsdGFYID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgZGVsdGFZID0gMDtcbiAgICAgICAgICAgICAgICBpZihweCA8IHggKyBwYWRkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhWCA9IGRlbHRhbW92ZW1lbnQ7XG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICBpZihweCA+IHcgLSBwYWRkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhWCA9IC1kZWx0YW1vdmVtZW50O1xuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgaWYocHkgPCB5ICsgcGFkZGluZykge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YVkgPSBkZWx0YW1vdmVtZW50O1xuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgaWYocHkgPiBoIC0gcGFkZGluZykge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YVkgPSAtZGVsdGFtb3ZlbWVudDtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX19wcm9jZXNzT3ZlckFuaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19wcm9jZXNzT3ZlckFuaW1lLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihkZWx0YVggfHwgZGVsdGFZKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19wcm9jZXNzT3ZlckFuaW1lID0gdGhpcy5yZXF1ZXN0SkZsb3dBbmltZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhbkhhbmRsZXIoZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICAgICAgICAgICAgICB9KSBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nYmVoYXZpb3IucGFuSW5Cb3JkZXIudGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9vbkRyYWdvdmVyKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZih0aGlzLl9sYXN0RHJhZ1N0YXRlLnByb2Nlc3NpbmcpIHJldHVybjtcbiAgICAgICAgdGhpcy5fbGFzdERyYWdTdGF0ZS5wcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudFxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3RhcmdldC5zdGF0dXMsIHtcbiAgICAgICAgICAgIGRyYWdvdmVyaW5nOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgICB0aGlzLl90YXJnZXRMb2NrT24oW29mZnNldFgsIG9mZnNldFldKVxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuX3RhcmdldC5pbnN0YW5jZSB8fCB0aGlzLl90YXJnZXQubGluaztcbiAgICAgICAgdGhpcy5fcHJvY2Vzc0RyYWdPdmVyKGluc3RhbmNlLCBldmVudCk7XG4gICAgICAgIGlmKHRoaXMuX3RhcmdldC5pc0xpbmtEaXJ0eSB8fCB0aGlzLl90YXJnZXQuaXNJbnN0YW5jZURpcnR5KSB7XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9yZW5kZXIoKTsgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LmlzTGlua0RpcnR5ID0gZmFsc2U7IFxuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldC5pc0luc3RhbmNlRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0RHJhZ1N0YXRlLnByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0RHJhZ1N0YXRlLnByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgfSBcbiAgICB9XG5cbiAgICBfY2FuY2VsUGFuSW5Cb3JkZXIoKSB7XG4gICAgICAgIGlmKHRoaXMuX19wcm9jZXNzT3ZlckFuaW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9fcHJvY2Vzc092ZXJBbmltZS5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLmRyYWdnaW5nYmVoYXZpb3I/LnBhbkluQm9yZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nYmVoYXZpb3IucGFuSW5Cb3JkZXIudGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX29uRHJhZ0xlYXZlKCkge1xuICAgICAgICB0aGlzLl9jYW5jZWxQYW5JbkJvcmRlcigpO1xuICAgIH1cblxuICAgIF9vbkRyb3AoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsUGFuSW5Cb3JkZXIoKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMuY29uc3VtZU1lc3NhZ2UoKTtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBwYXlsb2FkPy5pbnN0YW5jZTtcbiAgICAgICAgaWYodGhpcy5fZHJhZ092ZXJUYXJnZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZElucyA9IHRoaXMuX2RyYWdPdmVyVGFyZ2V0O1xuICAgICAgICAgICAgb2xkSW5zLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2RyYWdvdmVyZW5kJywge1xuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiBvbGRJbnMsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB0aGlzLl9kcmFnT3ZlclRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgbGluayxcbiAgICAgICAgICAgIGluc3RhbmNlOiB0YXJnZXQsXG4gICAgICAgIH0gPSB0aGlzLl90YXJnZXQ7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHBvaW50LCBiZWxvbmdzXG4gICAgICAgIH0gPSB0aGlzLl90YXJnZXQuY2FjaGU7XG4gICAgICAgIGlmKGxpbmspIHsgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5Lii5Zyo57q/5LiK5LqL5Lu2XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV2ZW50IEJhc2VMaW5rI2Ryb3BcbiAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0V2ZW50fSBldmVudCAgICAgICAgICAgLSDljp/lp4vkuovku7YgXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gaW5zdGFuY2UgICAgICAgLSDmi5bliqjnmoTlr7nosaEgXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0Jhc2VMaW5rfSBsaW5rICAgICAgICAgLSDnm67moIfov57nur8gXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0pGbG93fSBqZmxvdyAgICAgICAgICAgLSDlvZPliY1KRmxvd+WvueixoSBcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7R3JvdXB8SkZsb3d9IGJlbG9uZ3MgICAtIOi/nue6v+aJgOWcqOeahOe7mOWbvuagiOeahOWvueixoVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJbXX0gcG9pbnQgICAgICAgIC0g5bey57uP6K6h566X5Yiw57uY5Zu+5qCI5a+55bqU5Z2Q5qCH57O75LiL55qE5Z2Q5qCHXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIGluc3RhbmNlLmFuY2hvciA9IHBvaW50O1xuICAgICAgICAgICAgbGluay5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdkcm9wJywge1xuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgIGxpbmssXG4gICAgICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICAgICAgYmVsb25ncyxcbiAgICAgICAgICAgICAgICBwb2ludFxuICAgICAgICAgICAgfSkpXG4gICAgICAgIH0gZWxzZSBpZih0YXJnZXQpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5Lii5Zyo6IqC54K55LiK5LqL5Lu2XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV2ZW50IE5vZGUjZHJvcFxuICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IGV2ZW50ICAgICAgICAgICAtIOWOn+Wni+S6i+S7tiBcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBpbnN0YW5jZSAgICAgICAtIOaLluWKqOeahOWvueixoSBcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SkZsb3d9IGpmbG93ICAgICAgICAgICAtIOW9k+WJjUpGbG935a+56LGhIFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtOb2RlfSB0YXJnZXQgICAgICAgICAgIC0g55uu5qCH6IqC54K5XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcltdfSBwb2ludCAgICAgICAgLSDlt7Lnu4/orqHnrpfliLDnu5jlm77moIjlr7nlupTlnZDmoIfns7vkuIvnmoTlnZDmoIdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGFyZ2V0LmJ1YmJsZUV2ZW50KG5ldyBKRmxvd0V2ZW50KCdkcm9wJywge1xuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAqIOS4ouWcqOS4u+WbvuS4iuS6i+S7tlxuICAgICAgICAgICAgKlxuICAgICAgICAgICAgKiBAZXZlbnQgSkZsb3cjZHJvcFxuICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgKiBAcHJvcGVydHkge0V2ZW50fSBldmVudCAgICAgICAgICAgLSDljp/lp4vkuovku7YgXG4gICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBpbnN0YW5jZSAgICAgICAtIOaLluWKqOeahOWvueixoSBcbiAgICAgICAgICAgICogQHByb3BlcnR5IHtKRmxvd30gamZsb3cgICAgICAgICAgIC0g5b2T5YmNSkZsb3flr7nosaEgXG4gICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IHBvaW50ICAgICAgICAtIOW3sue7j+iuoeeul+WIsOe7mOWbvuagiOWvueW6lOWdkOagh+ezu+S4i+eahOWdkOagh1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnZHJvcCcsIHtcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgcG9pbnQsXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxEcm9wKCk7XG4gICAgICAgIH0pXG4gICAgfVxuICAgIGNhbmNlbERyb3AoKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldC5pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RhcmdldC5saW5rID0gbnVsbDtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl90YXJnZXQuc3RhdHVzLCB7XG4gICAgICAgICAgICBkcmFnb3ZlcmluZzogZmFsc2UsXG4gICAgICAgIH0pXG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIOe8qeaUvuaTjeS9nOWkhOeQhuWHveaVsFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRYIC0g5LqL5Lu25a+56LGh5LiOY2FudmFz55qE5YaF5aGr5YWF6L6577yIcGFkZGluZyBlZGdl77yJ5ZyoIFgg6L205pa55ZCR5LiK55qE5YGP56e76YeP44CCXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFkgLSDkuovku7blr7nosaHkuI5jYW52YXPnmoTlhoXloavlhYXovrnvvIhwYWRkaW5nIGVkZ2XvvInlnKggWSDovbTmlrnlkJHkuIrnmoTlgY/np7vph4/jgIIgXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWCAgLSDmsLTlubPmu5rliqjph49cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFZICAtIOWeguebtOa7muWKqOmHj1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudCAtIOWOn+eUn+S6i+S7tlxuICAgICAqL1xuICAgIHpvb21IYW5kbGVyKG9mZnNldFgsIG9mZnNldFksIGRlbHRhWCwgZGVsdGFZLCBldmVudCkge1xuICAgICAgICAvLyBpZighdGhpcy5fYWxsb3dab29tKSByZXR1cm47XG4gICAgICAgIGlmKHRoaXMuX3pvb21pbmcpIHJldHVybjtcbiAgICAgICAgdGhpcy5fem9vbWluZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgd2lkdGg6IHBfd2lkdGgsIGhlaWdodDogcF9oZWlnaHQsIHgsIHkgfSA9IHRoaXMuYm91bmRpbmdfYm94O1xuICAgICAgICBjb25zdCB7IGFjdHVhbF93aWR0aDogY3csIGFjdHVhbF9oZWlnaHQ6IGNoIH0gPSB0aGlzLmNhbnZhc01ldGE7XG4gICAgICAgIGxldCBtaW5ab29tID0gdGhpcy5taW5ab29tO1xuICAgICAgICBpZih0aGlzLndvcmxkTWFyZ2luKSB7XG4gICAgICAgICAgICBjb25zdCBtID0gdGhpcy53b3JsZE1hcmdpbjtcbiAgICAgICAgICAgIGNvbnN0IG1heFdpZHRoID0gcF93aWR0aCArIG0gKiAyO1xuICAgICAgICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gcF9oZWlnaHQgKyBtICogMjtcbiAgICAgICAgICAgIG1pblpvb20gPSBNYXRoLm1heChtaW5ab29tLCBNYXRoLm1heChjdyAvIG1heFdpZHRoLCBjaCAvIG1heEhlaWdodCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdTY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICAgIGNvbnN0IGFtb3VudCA9IGRlbHRhWSA+IDAgPyAxLjA1IDogMSAvIDEuMDU7XG4gICAgICAgIG5ld1NjYWxlICo9IGFtb3VudDtcbiAgICAgICAgbmV3U2NhbGUgPSBNYXRoLm1pbih0aGlzLm1heFpvb20sIE1hdGgubWF4KG1pblpvb20sIG5ld1NjYWxlKSlcbiAgICAgICAgLy8gY29uc29sZS5sb2cobmV3U2NhbGUpO1xuICAgICAgICAvLyBpZiAodGhpcy5tYXhab29tICYmIG5ld1NjYWxlID4gdGhpcy5tYXhab29tKXtcbiAgICAgICAgLy8gICAgIC8vIGNvdWxkIGp1c3QgcmV0dXJuIGJ1dCB0aGVuIHdvbid0IHN0b3AgZXhhY3RseSBhdCBtYXhab29tXG4gICAgICAgIC8vICAgICBuZXdTY2FsZSA9IHRoaXMubWF4Wm9vbTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGlmKHRoaXMubWluWm9vbSAmJiBuZXdTY2FsZSA8IHRoaXMubWluWm9vbSkge1xuICAgICAgICAvLyAgICAgbmV3U2NhbGUgPSB0aGlzLm1pblpvb207XG4gICAgICAgIC8vIH1cblxuICAgICAgICB2YXIgZGVsdGFTY2FsZSAgICA9IG5ld1NjYWxlIC0gdGhpcy5zY2FsZTtcbiAgICAgICAgdmFyIGN1cnJlbnRXaWR0aCAgPSBwX3dpZHRoICogdGhpcy5zY2FsZTtcbiAgICAgICAgdmFyIGN1cnJlbnRIZWlnaHQgPSBwX2hlaWdodCAqIHRoaXMuc2NhbGU7XG4gICAgICAgIHZhciBkZWx0YVdpZHRoICAgID0gcF93aWR0aCAqIGRlbHRhU2NhbGU7XG4gICAgICAgIHZhciBkZWx0YUhlaWdodCAgID0gcF9oZWlnaHQgKiBkZWx0YVNjYWxlO1xuXG4gICAgICAgIHZhciB0WCA9IG9mZnNldFggLSB0aGlzLnBvc2l0aW9uLng7XG4gICAgICAgIHZhciB0WSA9IG9mZnNldFkgLSB0aGlzLnBvc2l0aW9uLnk7XG4gICAgICAgIHZhciBwWCA9IC10WCAvIGN1cnJlbnRXaWR0aDtcbiAgICAgICAgdmFyIHBZID0gLXRZIC8gY3VycmVudEhlaWdodDtcblxuICAgICAgICB0aGlzLnNjYWxlID0gbmV3U2NhbGU7XG4gICAgICAgIHRoaXMuX3JlY2FsY3VsYXRlUG9zaXRpb24ocFggKiBkZWx0YVdpZHRoLCBwWSAqIGRlbHRhSGVpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIC8vIHRoaXMucG9zaXRpb24ueCArPSBwWCAqIGRlbHRhV2lkdGg7XG4gICAgICAgIC8vIHRoaXMucG9zaXRpb24ueSArPSBwWSAqIGRlbHRhSGVpZ2h0O1xuICAgICAgICAvLyB0aGlzLnBvc2l0aW9uLm9mZnNldFggPSB0aGlzLnBvc2l0aW9uLnggLSB4ICogbmV3U2NhbGU7XG4gICAgICAgIC8vIHRoaXMucG9zaXRpb24ub2Zmc2V0WSA9IHRoaXMucG9zaXRpb24ueSAtIHkgKiBuZXdTY2FsZTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCd6b29tcGFuJywge1xuICAgICAgICAgICAgIGRlbHRhWDogMCwgZGVsdGFZOiAwXG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gdGhpcy5zZXRBbmltZUNsb2NrKClcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl96b29taW5nID0gZmFsc2U7XG4gICAgICAgIH0pXG4gICAgICAgIC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSgodGltZXN0YW1wKSA9PiB7XG4gICAgICAgIC8vICAgICB0aGlzLnNldEFuaW1lQ2xvY2sodGltZXN0YW1wKTtcbiAgICAgICAgLy8gICAgIHRoaXMuX3JlbmRlcigpO1xuICAgICAgICAvLyAgICAgdGhpcy5fem9vbWluZyA9IGZhbHNlO1xuICAgICAgICAvLyB9KVxuICAgIH1cbiAgICAvKipcbiAgICAgKiDlubPnp7vnlLvluIPmk43kvZzlpITnkIblh73mlbBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFYICAtIOawtOW5s+a7muWKqOmHj1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVkgIC0g5Z6C55u05rua5Yqo6YePXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50IC0g5Y6f55Sf5LqL5Lu2XG4gICAgICovXG4gICAgcGFuSGFuZGxlcihkZWx0YVgsIGRlbHRhWSwgZXZlbnQpIHtcbiAgICAgICAgaWYodGhpcy5fcGFubmluZykgcmV0dXJuO1xuICAgICAgICB0aGlzLl9wYW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZHJhZ2dpbmcsXG4gICAgICAgIH0gPSB0aGlzLl90YXJnZXQuc3RhdHVzO1xuICAgICAgICBpZihkcmFnZ2luZykge1xuICAgICAgICAgICAgY29uc3QgbW92aW5ndGFyZ2V0ID0gdGhpcy5fdGFyZ2V0Lm1vdmluZztcbiAgICAgICAgICAgIGlmKG1vdmluZ3RhcmdldCkge1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuZHJhZ2dpbmdiZWhhdmlvci5wYW5JbkJvcmRlci5hbGxvd01vdmluZ1RhcmdldEluUGFuKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmluZ3RhcmdldC5mb3JFYWNoKHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdC5hbmNob3JbMF0gKz0gLWRlbHRhWCAvIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LmFuY2hvclsxXSArPSAtZGVsdGFZIC8gdGhpcy5zY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZWNhbGN1bGF0ZVBvc2l0aW9uKGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOe8qeaUvuW5s+enu+S6i+S7tlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgSkZsb3cjem9vbXBhblxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ3pvb21wYW4nLCB7XG4gICAgICAgICAgICBkZWx0YVgsXG4gICAgICAgICAgICBkZWx0YVlcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Bhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfSlcbiAgICAgICAgLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCh0aW1lc3RhbXApID0+IHtcbiAgICAgICAgLy8gICAgIHRoaXMuc2V0QW5pbWVDbG9jayh0aW1lc3RhbXApO1xuICAgICAgICAvLyAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgICAgIC8vICAgICB0aGlzLl9wYW5uaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIH0pXG4gICAgfVxuICAgIC8qKlxuICAgICAqIOW8gOWni+aMieWOi+WkhOeQhuWHveaVsFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRYIC0g5LqL5Lu25a+56LGh5LiOY2FudmFz55qE5YaF5aGr5YWF6L6577yIcGFkZGluZyBlZGdl77yJ5ZyoIFgg6L205pa55ZCR5LiK55qE5YGP56e76YeP44CCXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFkgLSDkuovku7blr7nosaHkuI5jYW52YXPnmoTlhoXloavlhYXovrnvvIhwYWRkaW5nIGVkZ2XvvInlnKggWSDovbTmlrnlkJHkuIrnmoTlgY/np7vph4/jgIIgXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50IC0g5Y6f55Sf5LqL5Lu2XG4gICAgICovXG4gICAgcHJlc3NTdGFydEhhbmRsZXIob2Zmc2V0WCwgb2Zmc2V0WSwgZXZlbnQpIHtcbiAgICAgICAgaWYodGhpcy5jaGVja1Njcm9sbERyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3RhcmdldC5tZXRhLCB7XG4gICAgICAgICAgICBpbml0aWFsWDogb2Zmc2V0WCxcbiAgICAgICAgICAgIGluaXRpYWxZOiBvZmZzZXRZLFxuICAgICAgICB9KVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBsaW5rLFxuICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgfSA9IHRoaXMuX3RhcmdldExvY2tPbihbb2Zmc2V0WCwgb2Zmc2V0WV0sICdwcmVzc1N0YXJ0Jyk7XG4gICAgICAgIC8vIOWQjue7reWPquaUr+aMgSBjbGljayDliqjkvZxcbiAgICAgICAgaWYodGhpcy5tb2RlID09PSBKRkxPV19NT0RFLkxJTktJTkcpIHJldHVybjtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl90YXJnZXQuc3RhdHVzLCB7XG4gICAgICAgICAgICBkcmFnZ2luZzogdHJ1ZSxcbiAgICAgICAgICAgIHByb2Nlc3Npbmc6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYodGhpcy5fdGFyZ2V0Lm1vdmluZykge1xuICAgICAgICAgICAgY29uc3QgbW92aW5nID0gdGhpcy5fZ2V0TW92aW5nVGFyZ2V0KCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOW8gOWni+aLluWKqOe7hOeahOS6i+S7tu+8iOeJueaMh2xvY2vnmoTpobblsYLnu4TvvIlcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXZlbnQgTm9kZSNwcmVzc1N0YXJ0XG4gICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtFdmVudH0gZXZlbnQgICAgICAgICAgIC0g5Y6f5aeL5LqL5Lu2IFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtOb2RlfSBpbnN0YW5jZSAgICAgICAtIOaLluWKqOeahOWvueixoSBcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SkZsb3d9IGpmbG93ICAgICAgICAgICAtIOW9k+WJjUpGbG935a+56LGhIFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtb3ZpbmcuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgncHJlc3NTdGFydCcsIHtcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogbW92aW5nLFxuICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgfSkpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdCA9IHRoaXMuX3Jlc29sdmVMb2NrT25UYXJnZXQobGluaywgaW5zdGFuY2UpXG4gICAgICAgIGlmKHQpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5byA5aeL5ouW5Yqo5a+56LGh5LqL5Lu277yI5bCx5piv55uu5qCH5a+56LGh55qE5ouW5Yqo5LqL5Lu277yM5LqL5Lu25pSv5oyB5YaS5rOh77yJXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV2ZW50IE5vZGUjaW5zdGFuY2VQcmVzc1N0YXJ0XG4gICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtFdmVudH0gZXZlbnQgICAgICAgICAgIC0g5Y6f5aeL5LqL5Lu2IFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtOb2RlfSBpbnN0YW5jZSAgICAgLSDmi5bliqjnmoTlr7nosaEgXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0pGbG93fSBqZmxvdyAgICAgICAgICAgLSDlvZPliY1KRmxvd+WvueixoSBcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gYnViYmxlcyAgICAgICAtIOWGkuazoVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBjb25zdCB0ID0gdGhpcy5fdGFyZ2V0Lmluc3RhbmNlO1xuICAgICAgICAgICAgdC5idWJibGVFdmVudChuZXcgSkZsb3dFdmVudCgnaW5zdGFuY2VQcmVzc1N0YXJ0Jywge1xuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIHRhcmdldDogdCxcbiAgICAgICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZlbnRQcmVzc1NlcXVlZW5jZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFyVGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZlbnRQcmVzc1NlcXVlZW5jZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgIH1cbiAgICAgICAgaWYoIXRoaXMuX3ByZXZlbnRQcmVzc1NlcXVlZW5jZSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdqZmxvd1ByZXNzU3RhcnQnLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICog5oyJ5Y6L5Lit5aSE55CG5Ye95pWwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFggLSDkuovku7blr7nosaHkuI5jYW52YXPnmoTlhoXloavlhYXovrnvvIhwYWRkaW5nIGVkZ2XvvInlnKggWCDovbTmlrnlkJHkuIrnmoTlgY/np7vph4/jgIJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0WSAtIOS6i+S7tuWvueixoeS4jmNhbnZhc+eahOWGheWhq+WFhei+ue+8iHBhZGRpbmcgZWRnZe+8ieWcqCBZIOi9tOaWueWQkeS4iueahOWBj+enu+mHj+OAgiBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQgLSDljp/nlJ/kuovku7ZcbiAgICAgKi9cbiAgICBwcmVzc01vdmVIYW5kbGVyKG9mZnNldFgsIG9mZnNldFksIGV2ZW50KSB7XG4gICAgICAgIGlmKHRoaXMuX3ByZXZlbnRQcmVzc1NlcXVlZW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuY2hlY2tTY3JvbGxEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZHJhZ2dpbmcsIHByb2Nlc3NpbmdcbiAgICAgICAgfSA9IHRoaXMuX3RhcmdldC5zdGF0dXM7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy5fdGFyZ2V0Lm1ldGE7XG4gICAgICAgIC8vIHRoaXMuY2FudmFzLnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcbiAgICAgICAgaWYoIWRyYWdnaW5nKSB7XG4gICAgICAgICAgICBpZih0aGlzLmNoZWNrU2Nyb2xsQmFySG92ZXIob2Zmc2V0WCwgb2Zmc2V0WSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRTY3JvbGxCYXJIb3ZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICBpZighZHJhZ2dpbmcgJiYgIXByb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBsaW5rLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgICB9ID0gdGhpcy5fdGFyZ2V0TG9ja09uKFtvZmZzZXRYLCBvZmZzZXRZXSk7XG4gICAgICAgICAgICBjb25zdCB0ID0gdGhpcy5fcmVzb2x2ZUxvY2tPblRhcmdldChsaW5rLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICBpZih0KSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgKiBpbnN0YW5jZSBtb3VzZW1vdmUg5Y6f55Sf5LqL5Lu277yM5LuF5Zyo5peg5ouW5ou95pe26Kem5Y+RXG4gICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICogQGV2ZW50IE5vZGUjaW5zdGFuY2Vtb3VzZW1vdmVcbiAgICAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0V2ZW50fSBldmVudCAgICAgICAgICAgLSDljp/lp4vkuovku7ZcbiAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Tm9kZX0gaW5zdGFuY2UgICAgICAgICAgIC0g5Y6f5aeL5LqL5Lu2XG4gICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0pGbG93fSBqZmxvdyAgICAgICAgICAgLSDlvZPliY1KRmxvd+WvueixoSBcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIC8vIGluc3RhbmNlLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2luc3RhbmNlbW91c2Vtb3ZlJywge1xuICAgICAgICAgICAgICAgIC8vICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAvLyAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgLy8gICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgICAgIC8vIH0pKVxuICAgICAgICAgICAgICAgIHQuYnViYmxlRXZlbnQobmV3IEpGbG93RXZlbnQoJ2luc3RhbmNlbW91c2Vtb3ZlJywge1xuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IHQsXG4gICAgICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2luc3RhbmNlbW91c2Vtb3ZlJywge1xuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBpZih0aGlzLm1vZGUgPT09IEpGTE9XX01PREUuTElOS0lORykge1xuICAgICAgICAgICAgICAgIC8vIGlmKGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGluc3RhbmNlLmJ1YmJsZUV2ZW50KG5ldyBKRmxvd0V2ZW50KCdsaW5raW5nJywge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICB0YXJnZXQ6IGluc3RhbmNlLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgY2FsbGJhY2s6IChwKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgdGhpcy5fY3VycmVudHAgPSBwO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgICB9KSlcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wTm9kZS5hbmNob3IgPSB0aGlzLl9jdXJyZW50cDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LmlzTGlua0RpcnR5ID0gZmFsc2U7IFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXQuaXNJbnN0YW5jZURpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldC5zdGF0dXMucHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc1BhbkluQm9yZGVyKCk7XG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCh0aW1lc3RhbXApID0+IHtcbiAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5zZXRBbmltZUNsb2NrKHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgLy8gICAgIHRoaXMuX3JlbmRlcigpO1xuICAgICAgICAgICAgICAgIC8vICAgICB0aGlzLl90YXJnZXQuaXNMaW5rRGlydHkgPSBmYWxzZTsgXG4gICAgICAgICAgICAgICAgLy8gICAgIHRoaXMuX3RhcmdldC5pc0luc3RhbmNlRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5fdGFyZ2V0LnN0YXR1cy5wcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gfSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNhbnZhcyBtb3VzZW1vdmUg5Y6f55Sf5LqL5Lu2XG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBKRmxvdyNjYW52YXNtb3VzZW1vdmVcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHByb3BlcnR5IHtFdmVudH0gZXZlbnQgICAgICAgICAgIC0g5Y6f5aeL5LqL5Lu2XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7SkZsb3d9IGpmbG93ICAgICAgICAgICAtIOW9k+WJjUpGbG935a+56LGhIFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdjYW52YXNtb3VzZW1vdmUnLCB7XG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICB9KSlcblxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGlmKCFkcmFnZ2luZykgcmV0dXJuO1xuICAgICAgICAvLyB0aGlzLmNhbnZhcy5zdHlsZS5jdXJzb3IgPSAnZ3JhYmJpbmcnO1xuICAgICAgICBpZihwcm9jZXNzaW5nKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBjb25zdCBtb3Zpbmd0YXJnZXQgPSB0aGlzLl90YXJnZXQubW92aW5nOy8vIHRoaXMuX3RlbXBOb2RlID8gW3RoaXMuX3RlbXBOb2RlXSA6IHRoaXMuX3RhcmdldC5tb3Zpbmc7XG4gICAgICAgIHRoaXMuX3RhcmdldC5zdGF0dXMubW92aW5nU3RhdGUgPSB0cnVlXG4gICAgICAgIHRoaXMuX3RhcmdldC5zdGF0dXMucHJvY2Vzc2luZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IGRlbHRhWCA9IG9mZnNldFggLSB4O1xuICAgICAgICBjb25zdCBkZWx0YVkgPSBvZmZzZXRZIC0geTtcbiAgICAgICAgaWYobW92aW5ndGFyZ2V0KSB7XG4gICAgICAgICAgICBpZih0aGlzLl9hbGxvd01vdmluZ1RhcmdldCkge1xuICAgICAgICAgICAgICAgIG1vdmluZ3RhcmdldC5mb3JFYWNoKHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0LmFuY2hvclswXSArPSBkZWx0YVggLyB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgICAgICAgICB0LmFuY2hvclsxXSArPSBkZWx0YVkgLyB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZWNhbGN1bGF0ZVBvc2l0aW9uKGRlbHRhWCwgZGVsdGFZKTsgICAgXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ3pvb21wYW4nLCB7XG4gICAgICAgICAgICAgICAgZGVsdGFYLCBkZWx0YVlcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGluc3RhbmNlLCBsaW5rIH0gPSB0aGlzLl90YXJnZXRMb2NrT24oW29mZnNldFgsIG9mZnNldFldKTtcblxuICAgICAgICB0aGlzLl9wcm9jZXNzRHJhZ092ZXIoaW5zdGFuY2UgfHwgbGluaywgZXZlbnQpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXQuaXNMaW5rRGlydHkgPSBmYWxzZTsgXG4gICAgICAgICAgICB0aGlzLl90YXJnZXQuaXNJbnN0YW5jZURpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXQuc3RhdHVzLnByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgfSlcbiAgICAgICAgLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCh0aW1lc3RhbXApID0+IHtcbiAgICAgICAgLy8gICAgIHRoaXMuX3JlbmRlcigpO1xuICAgICAgICAvLyAgICAgdGhpcy5fdGFyZ2V0LmlzTGlua0RpcnR5ID0gZmFsc2U7IFxuICAgICAgICAvLyAgICAgdGhpcy5fdGFyZ2V0LmlzSW5zdGFuY2VEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAvLyAgICAgdGhpcy5fdGFyZ2V0LnN0YXR1cy5wcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIH0pXG4gICAgfVxuICAgIC8qKlxuICAgICAqIOaMieWOi+e7k+adn+WkhOeQhuWHveaVsFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEb2N1bWVudCAtIOaYr+WQpuS4uiBkb2N1bWVudCDop6blj5FcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQgLSDljp/nlJ/kuovku7ZcbiAgICAgKi9cbiAgICBwcmVzc1VwSGFubGRlcihpc0RvY3VtZW50LCBldmVudCkge1xuICAgICAgICBpZih0aGlzLl9wcmV2ZW50UHJlc3NTZXF1ZWVuY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYodGhpcy5fX3Byb2Nlc3NPdmVyQW5pbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX19wcm9jZXNzT3ZlckFuaW1lLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RyYWdPdmVyVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2FuY2VsUGFuSW5Cb3JkZXIoKTtcbiAgICAgICAgLy8gdGhpcy5yZXNldFNjb2xsQmFyU3RhdHVzKCk7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl90YXJnZXQubWV0YTtcbiAgICAgICAgaWYodGhpcy5tb2RlID09PSBKRkxPV19NT0RFLkxJTktJTkcpIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLl90YXJnZXQuaW5zdGFuY2U7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5jb25zdW1lTWVzc2FnZSgpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2cocGF5bG9hZClcbiAgICAgICAgICAgIGxldCBfcHJldmVudERlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZlbnREZWZhdWx0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIF9wcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgaWYodCkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIGNhbnZhcyBtb3VzZW1vdmUg5Y6f55Sf5LqL5Lu2XG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAZXZlbnQgTm9kZSNsaW5rXG4gICAgICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0V2ZW50fSBldmVudCAgICAgICAgICAgLSDljp/lp4vkuovku7ZcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge05vZGV9IHRhcmdldCAgICAgICAgICAgLSDljp/lp4vkuovku7ZcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge29iamVjdH0gcGF5bG9hZCAgICAgICAgLSDkvKDlhaXnmoTmtojmga9cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0pGbG93fSBqZmxvdyAgICAgICAgICAgLSDlvZPliY1KRmxvd+WvueixoSAgICAgICAtIOW9k+WJjUpGbG935a+56LGhIFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHQuYnViYmxlRXZlbnQobmV3IEpGbG93RXZlbnQoJ2xpbmsnLCB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHQsXG4gICAgICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBsaW5rOiB0aGlzLl90ZW1wTGluayxcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQsXG4gICAgICAgICAgICAgICAgfSkpICAgICAgICBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudFxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnbGluaycsIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICBhbmNob3I6IHRoaXMuX2NhbGN1bGF0ZVBvaW50QmFjayhbb2Zmc2V0WCwgb2Zmc2V0WV0pLFxuICAgICAgICAgICAgICAgICAgICBsaW5rOiB0aGlzLl90ZW1wTGluayxcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHRcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihfcHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jbGVhclRhcmdldCgpO1xuICAgICAgICAgICAgaWYoIXRoaXMuX3ByZXZlbnRDbGVhclRlbXApIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLl90ZW1wTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wTm9kZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBOb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYodGhpcy5fdGVtcExpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcExpbmsuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wTGluayA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJldmVudENsZWFyVGVtcCA9IGZhbHNlXG4gICAgICAgICAgICB0aGlzLm1vZGUgPSBKRkxPV19NT0RFLkRFRkFVTFQ7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYodGhpcy5fdGFyZ2V0Lm1vdmluZykge1xuICAgICAgICAgICAgbGV0IGNoZWNrcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZih0aGlzLl9sYXlvdXQuc3RhdGljKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tyZXN1bHQgPSB0aGlzLnN0YXRpY0NoZWNrKHRoaXMuX2dldE1vdmluZ1RhcmdldCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIWNoZWNrcmVzdWx0ICYmIHRoaXMuX3RhcmdldC5saW5rKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgICAgICBwb2ludCwgYmVsb25nc1xuICAgICAgICAgICAgICAgIH0gPSB0aGlzLl90YXJnZXQuY2FjaGU7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluayA9IHRoaXMuX3RhcmdldC5saW5rO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5fZ2V0TW92aW5nVGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICog5ouW5Yqo5Yiw57q/5LiK5LqL5Lu2XG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAZXZlbnQgQmFzZUxpbmsjZHJvcFxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtFdmVudH0gZXZlbnQgICAgICAgICAgIC0g5Y6f5aeL5LqL5Lu2IFxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBpbnN0YW5jZSAgICAgLSDmi5bliqjnmoTlr7nosaEgXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtCYXNlTGlua30gbGluayAgICAgICAgIC0g55uu5qCH6L+e57q/IFxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SkZsb3d9IGpmbG93ICAgICAgICAgICAtIOW9k+WJjUpGbG935a+56LGhIFxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7R3JvdXB8SkZsb3d9IGJlbG9uZ3MgICAtIOi/nue6v+aJgOWcqOeahOe7mOWbvuagiOeahOWvueixoVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGxpbmsuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnZHJvcCcsIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICBsaW5rLFxuICAgICAgICAgICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgYmVsb25ncyxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LmxpbmsgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldC5pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYodGhpcy5fdGFyZ2V0Lm1vdmluZykge1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuX3RhcmdldC5pbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICog5ouW5Yqo5ZCO5pS+572u5YiwIEluc3RhbmNlIOS4iueahOS6i+S7tu+8jOeUseiiq+aLluWKqOWIsOeahOWvueixoeinpuWPkVxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBAZXZlbnQgTm9kZSNwcmVzc0VuZFxuICAgICAgICAgICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0V2ZW50fSBldmVudCAgICAgICAgICAgLSDljp/lp4vkuovku7YgXG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Tm9kZX0gaW5zdGFuY2UgICAgICAgICAtIOaLluWKqOeahOWvueixoSBcbiAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtKRmxvd30gamZsb3cgICAgICAgICAgIC0g5b2T5YmNSkZsb3flr7nosaEgXG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SW5zdGFuY2V9IHRhcmdldCAgICAgICAtIOaLluWKqOWIsOeahOWvueixoVxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGJ1YmJsZXMgICAgICAgLSDlhpLms6FcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIC8vICBjb25zb2xlLmxvZygncHJlc3NFbmQnLCB0aGlzLl90YXJnZXQuaW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldC5pbnN0YW5jZS5idWJibGVFdmVudChuZXcgSkZsb3dFdmVudCgncHJlc3NFbmQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLl9nZXRNb3ZpbmdUYXJnZXQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLl90YXJnZXQuaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICog5ouW5Yqo5ZCO5pS+572u5Yiw5Li75Zu+5LiK55qE5LqL5Lu2XG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqIEBldmVudCBKRmxvdyNwcmVzc0VuZFxuICAgICAgICAgICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0V2ZW50fSBldmVudCAgICAgICAgICAgLSDljp/lp4vkuovku7YgXG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SW5zdGFuY2V9IGluc3RhbmNlICAgICAgIC0g5ouW5Yqo55qE5a+56LGhIFxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0pGbG93fSBqZmxvdyAgICAgICAgICAgLSDlvZPliY1KRmxvd+WvueixoSBcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgncHJlc3NFbmQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLl9nZXRNb3ZpbmdUYXJnZXQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90YXJnZXQubW92aW5nID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlVGVtcERyYWdnaW5nSW5zdGFuY2UoKVxuICAgICAgICAgICAgLy8gdGhpcy5fdGFyZ2V0LmlzTW92aW5nRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NsZWFyVGFyZ2V0KCk7XG4gICAgfVxuICAgICAvKipcbiAgICAgKiDoj5zljZXlvLnlh7rlpITnkIblh73mlbBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0WCAtIOS6i+S7tuWvueixoeS4jmNhbnZhc+eahOWGheWhq+WFhei+ue+8iHBhZGRpbmcgZWRnZe+8ieWcqCBYIOi9tOaWueWQkeS4iueahOWBj+enu+mHj+OAglxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRZIC0g5LqL5Lu25a+56LGh5LiOY2FudmFz55qE5YaF5aGr5YWF6L6577yIcGFkZGluZyBlZGdl77yJ5ZyoIFkg6L205pa55ZCR5LiK55qE5YGP56e76YeP44CCIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudCAtIOWOn+eUn+S6i+S7tlxuICAgICAqL1xuICAgIGNsaWNrSGFubGRlcihvZmZzZXRYLCBvZmZzZXRZLCBldmVudCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBsaW5rLFxuICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICBtZXRhXG4gICAgICAgIH0gPSB0aGlzLl90YXJnZXRMb2NrT24oW29mZnNldFgsIG9mZnNldFldLCAnY2xpY2snKTtcbiAgICAgICAgaWYoTWF0aC5hYnMobWV0YS5pbml0aWFsWCAtIG1ldGEueCkgPCAxXG4gICAgICAgICAgICAmJiBNYXRoLmFicyhtZXRhLmluaXRpYWxZIC0gbWV0YS55KSA8IDEpIHsgXG4gICAgICAgICAgICAgICAgaWYoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmNhbnZhcyl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFyVGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fdGFyZ2V0Lm1ldGEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxYOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsWTogdW5kZWZpbmVkLCBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0b3BMYXllclBvaW50IH0gPSB0aGlzLl90YXJnZXQuY2FjaGVcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gdGhpcy5fcmVzb2x2ZUxvY2tPblRhcmdldChsaW5rLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgaWYodCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0O1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICog54K55Ye75LqL5Lu277yI5YaS5rOh77yJXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqIEBldmVudCBJbnN0YW5jZSNjb250ZXh0Y2xpY2tcbiAgICAgICAgICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtFdmVudH0gZXZlbnQgICAgICAgICAgIC0g5Y6f5aeL5LqL5Lu2IFxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0luc3RhbmNlfSB0YXJnZXQgICAgICAgLSDlj7PplK7lr7nosaEgXG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SkZsb3d9IGpmbG93ICAgICAgICAgICAtIOW9k+WJjUpGbG935a+56LGhXG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IHRvcExheWVyUG9pbnQgIC0gamZsb3flnZDmoIfns7vkuIrnmoTkvY3nva5cbiAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBidWJibGVzICAgICAgIC0g5YaS5rOhXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuYnViYmxlRXZlbnQobmV3IEpGbG93RXZlbnQoJ2NsaWNrJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcExheWVyUG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICog54K55Ye75LqL5Lu2XG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqIEBldmVudCBKRmxvdyNjb250ZXh0Y2xpY2tcbiAgICAgICAgICAgICAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtFdmVudH0gZXZlbnQgICAgICAgICAgIC0g5Y6f5aeL5LqL5Lu2IFxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0pGbG93fSBqZmxvdyAgICAgICAgICAgLSDlvZPliY1KRmxvd+WvueixoVxuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcltdfSB0b3BMYXllclBvaW50ICAtIGpmbG935Z2Q5qCH57O75LiK55qE5L2N572uXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2NsaWNrJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcExheWVyUG9pbnQsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJUYXJnZXQoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3RhcmdldC5tZXRhLCB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxYOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxZOiB1bmRlZmluZWQsIFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiDoj5zljZXlvLnlh7rlpITnkIblh73mlbBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0WCAtIOS6i+S7tuWvueixoeS4jmNhbnZhc+eahOWGheWhq+WFhei+ue+8iHBhZGRpbmcgZWRnZe+8ieWcqCBYIOi9tOaWueWQkeS4iueahOWBj+enu+mHj+OAglxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRZIC0g5LqL5Lu25a+56LGh5LiOY2FudmFz55qE5YaF5aGr5YWF6L6577yIcGFkZGluZyBlZGdl77yJ5ZyoIFkg6L205pa55ZCR5LiK55qE5YGP56e76YeP44CCIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudCAtIOWOn+eUn+S6i+S7tlxuICAgICAqL1xuICAgIGNvbnRleHRNZW51SGFubGRlcihvZmZzZXRYLCBvZmZzZXRZLCBldmVudCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBsaW5rLFxuICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgfSA9IHRoaXMuX3RhcmdldExvY2tPbihbb2Zmc2V0WCwgb2Zmc2V0WV0sICdjb250ZXh0Y2xpY2snKTtcbiAgICAgICAgY29uc3QgeyB0b3BMYXllclBvaW50IH0gPSB0aGlzLl90YXJnZXQuY2FjaGVcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuX3Jlc29sdmVMb2NrT25UYXJnZXQobGluaywgaW5zdGFuY2UpO1xuICAgICAgICBpZih0KSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDlj7PplK7kuovku7bvvIjlhpLms6HvvIlcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXZlbnQgSW5zdGFuY2UjY29udGV4dGNsaWNrXG4gICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtFdmVudH0gZXZlbnQgICAgICAgICAgIC0g5Y6f5aeL5LqL5Lu2IFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtJbnN0YW5jZX0gdGFyZ2V0ICAgICAgIC0g5Y+z6ZSu5a+56LGhIFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtKRmxvd30gamZsb3cgICAgICAgICAgIC0g5b2T5YmNSkZsb3flr7nosaFcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IHRvcExheWVyUG9pbnQgIC0gamZsb3flnZDmoIfns7vkuIrnmoTkvY3nva5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gYnViYmxlcyAgICAgICAtIOWGkuazoVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0YXJnZXQuYnViYmxlRXZlbnQobmV3IEpGbG93RXZlbnQoJ2NvbnRleHRjbGljaycsIHtcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgdG9wTGF5ZXJQb2ludCxcbiAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOWPs+mUruS6i+S7tlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBldmVudCBKRmxvdyNjb250ZXh0Y2xpY2tcbiAgICAgICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0V2ZW50fSBldmVudCAgICAgICAgICAgLSDljp/lp4vkuovku7YgXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0pGbG93fSBqZmxvdyAgICAgICAgICAgLSDlvZPliY1KRmxvd+WvueixoVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJbXX0gdG9wTGF5ZXJQb2ludCAgLSBqZmxvd+WdkOagh+ezu+S4iueahOS9jee9rlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEpGbG93RXZlbnQoJ2NvbnRleHRjbGljaycsIHtcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICBqZmxvdzogdGhpcyxcbiAgICAgICAgICAgICAgICB0b3BMYXllclBvaW50LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGJsY2xpY2tIYW5kbGVyKG9mZnNldFgsIG9mZnNldFksIGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGxpbmssXG4gICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICB9ID0gdGhpcy5fdGFyZ2V0TG9ja09uKFtvZmZzZXRYLCBvZmZzZXRZXSwgJ2RibGNsaWNrJyk7XG4gICAgICAgIGNvbnN0IHsgdG9wTGF5ZXJQb2ludCB9ID0gdGhpcy5fdGFyZ2V0LmNhY2hlXG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLl9yZXNvbHZlTG9ja09uVGFyZ2V0KGxpbmssIGluc3RhbmNlKTtcbiAgICAgICAgaWYodCkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5Y+z6ZSu5LqL5Lu2XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV2ZW50IEluc3RhbmNlI2RibGNsaWNrXG4gICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtFdmVudH0gZXZlbnQgICAgICAgICAgIC0g5Y6f5aeL5LqL5Lu2IFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtJbnN0YW5jZX0gdGFyZ2V0ICAgICAgIC0g5Y+z6ZSu5a+56LGhIFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtKRmxvd30gamZsb3cgICAgICAgICAgIC0g5b2T5YmNSkZsb3flr7nosaFcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IHRvcExheWVyUG9pbnQgIC0gamZsb3flnZDmoIfns7vkuIrnmoTkvY3nva5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gYnViYmxlcyAgICAgICAtIOWGkuazoVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0YXJnZXQuYnViYmxlRXZlbnQobmV3IEpGbG93RXZlbnQoJ2RibGNsaWNrJywge1xuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIGpmbG93OiB0aGlzLFxuICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICB0b3BMYXllclBvaW50LFxuICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgSkZsb3dFdmVudCgnZGJsY2xpY2snLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgamZsb3c6IHRoaXMsXG4gICAgICAgICAgICAgICAgdG9wTGF5ZXJQb2ludCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qX29uWm9vbShldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBsZXQgeyBvZmZzZXRYLCBvZmZzZXRZLCBkZWx0YVgsIGRlbHRhWSB9ID0gZXZlbnRcbiAgICAgICAgaWYoZXZlbnQuY3RybEtleSkgeyBcbiAgICAgICAgICAgIGRlbHRhWSA9IC1kZWx0YVk7XG4gICAgICAgICAgICB0aGlzLnpvb21IYW5kbGVyKG9mZnNldFgsIG9mZnNldFksIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFuSGFuZGxlcigtZGVsdGFYLCAtZGVsdGFZKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9vblByZXNzU3RhcnQoZXZlbnQpIHsgXG4gICAgICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSwgZGVsdGFZLCBidXR0b24gfSA9IGV2ZW50XG4gICAgICAgIGlmKGJ1dHRvbiAhPT0gMCkgcmV0dXJuO1xuICAgICAgICB0aGlzLnByZXNzU3RhcnRIYW5kbGVyKG9mZnNldFgsIG9mZnNldFkpO1xuICAgIH1cblxuICAgIF9vblByZXNzTW92ZShldmVudCkge1xuICAgICAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGV2ZW50XG4gICAgICAgIHRoaXMucHJlc3NNb3ZlSGFuZGxlcihvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICB9XG5cbiAgICBfb25QcmVzc1VwKGV2ZW50LCBpc0RvY3VtZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBjb25zdCB7IGJ1dHRvbiB9ID0gZXZlbnRcbiAgICAgICAgaWYoYnV0dG9uICE9PSAwKSByZXR1cm47XG4gICAgICAgIHRoaXMucHJlc3NVcEhhbmxkZXIoaXNEb2N1bWVudClcbiAgICB9XG5cbiAgICBfb25QcmVzc1VwRG9jdW1lbnQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fb25QcmVzc1VwKGV2ZW50LCB0cnVlKTtcbiAgICB9XG5cbiAgICBfb25Db250ZXh0TWVudShldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcbiAgICAgICAgdGhpcy5jb250ZXh0TWVudUhhbmxkZXIob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgfSovXG4gICAgX3Jlc29sdmVMb2NrT25UYXJnZXQobGluaywgaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGxpbms/Lk9OX1RPUCA/IGxpbmsgOiAoaW5zdGFuY2UgfHwgbGluayk7XG4gICAgfVxuXG4gICAgX2NsZWFyVGFyZ2V0KCl7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fdGFyZ2V0Lm1ldGEsIHtcbiAgICAgICAgICAgIHg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIGluaXRpYWxYOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBpbml0aWFsWTogdW5kZWZpbmVkLCBcbiAgICAgICAgfSlcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl90YXJnZXQuc3RhdHVzLCB7XG4gICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICBwcm9jZXNzaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIG1vdmluZ1N0YXRlOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fdGFyZ2V0LCB7XG4gICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgIGxpbms6IG51bGwsXG4gICAgICAgICAgICBtb3Zpbmc6IG51bGwsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9yZWNhbGN1bGF0ZVBvc2l0aW9uKGRlbHRhWCwgZGVsdGFZLCBzY2FsZSkge1xuICAgICAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuYm91bmRpbmdfYm94O1xuICAgICAgICBjb25zdCB7IGFjdHVhbF93aWR0aDogY3csIGFjdHVhbF9oZWlnaHQ6IGNoIH0gPSB0aGlzLmNhbnZhc01ldGE7XG4gICAgICAgIGlmKHNjYWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBcblxuICAgICAgICBpZih0aGlzLndvcmxkTWFyZ2luKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhzY2FsZSlcbiAgICAgICAgICAgIGNvbnN0IG0gPSB0aGlzLndvcmxkTWFyZ2luO1xuICAgICAgICAgICAgY29uc3QgYngxID0gKHggKyB3aWR0aCArIG0pKnNjYWxlIC0gY3c7XG4gICAgICAgICAgICBjb25zdCBieDIgPSAoeCAtIG0pKnNjYWxlO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYngxLCBieDIpXG4gICAgICAgICAgICBjb25zdCBzeCA9IHggKiBzY2FsZTtcbiAgICAgICAgICAgIGNvbnN0IHB4ID0gdGhpcy5wb3NpdGlvbi54ICsgZGVsdGFYO1xuICAgICAgICAgICAgY29uc3QgY3ggPSBweCAtIHN4O1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi5vZmZzZXRYID0gTWF0aC5taW4oTWF0aC5tYXgoLWJ4MSwgY3gpLCAtYngyKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMucG9zaXRpb24ub2Zmc2V0WClcbiAgICAgICAgICAgIC8vIHRoaXMucG9zaXRpb24ub2Zmc2V0WCA9IE1hdGgubWF4KE1hdGgubWluKC1ieDIsIGN4KSwgLWJ4MSk7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnggPSB0aGlzLnBvc2l0aW9uLm9mZnNldFggKyBzeDtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMucG9zaXRpb24ueCwgZGVsdGFYKVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5wb3NpdGlvbi5vZmZzZXRYKVxuXG4gICAgICAgICAgICBjb25zdCBieTEgPSAoeSArIGhlaWdodCArIG0pKnNjYWxlIC0gY2g7XG4gICAgICAgICAgICBjb25zdCBieTIgPSAoeSAtIG0pKnNjYWxlO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYnkxLCBieTIpXG4gICAgICAgICAgICBjb25zdCBzeSA9IHkgKiBzY2FsZTtcbiAgICAgICAgICAgIGNvbnN0IHB5ID0gdGhpcy5wb3NpdGlvbi55ICsgZGVsdGFZO1xuICAgICAgICAgICAgY29uc3QgY3kgPSBweSAtIHN5O1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi5vZmZzZXRZID0gTWF0aC5taW4oTWF0aC5tYXgoLWJ5MSwgY3kpLCAtYnkyKTtcbiAgICAgICAgICAgIC8vIHRoaXMucG9zaXRpb24ub2Zmc2V0WSA9IE1hdGgubWF4KE1hdGgubWluKC1ieTIsIGN5KSwgLWJ5MSk7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnkgPSB0aGlzLnBvc2l0aW9uLm9mZnNldFkgKyBzeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ueCArPSBkZWx0YVg7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnkgKz0gZGVsdGFZOyBcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ub2Zmc2V0WCA9IHRoaXMucG9zaXRpb24ueCAtIHggKiBzY2FsZTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ub2Zmc2V0WSA9IHRoaXMucG9zaXRpb24ueSAtIHkgKiBzY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG5cbiAgICBjYWxjdWxhdGVUb1JlYWxXb3JsZChwKSB7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICByZXR1cm4gW3BbMF0gKiBzY2FsZSArIHBvc2l0aW9uLm9mZnNldFgsIHBbMV0gKiBzY2FsZSArIHBvc2l0aW9uLm9mZnNldFldXG4gICAgfVxuXG4gICAgX2NhbGN1bGF0ZVBvaW50QmFjayhwKSB7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICByZXR1cm4gWyhwWzBdIC0gcG9zaXRpb24ub2Zmc2V0WCkvc2NhbGUsIChwWzFdIC0gcG9zaXRpb24ub2Zmc2V0WSkgLyBzY2FsZV07XG4gICAgfVxuXG4gICAgX2NhbGN1bGF0ZVBvaW50QmFja1dpdGhQb2ludChhLCBiLCBhcnIsIGlkeDEsIGlkeDIpIHtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIGFycltpZHgxXSA9IChhIC0gcG9zaXRpb24ub2Zmc2V0WCkgLyBzY2FsZTtcbiAgICAgICAgYXJyW2lkeDJdID0gKGIgLSBwb3NpdGlvbi5vZmZzZXRZKSAvIHNjYWxlXG4gICAgfVxuXG4gICAgX2NhbGN1bGF0ZURpc3RhbmNlKGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUgKiBsO1xuICAgIH1cblxuICAgIF9yZXNldFRyYW5zZm9ybSgpIHtcbiAgICAgICAgY29uc3QgeyB3aWR0aDogY193aWR0aCwgaGVpZ2h0OiBjX2hlaWdodCB9ID0gdGhpcy5jYW52YXNNZXRhO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjX3dpZHRoLCBjX2hlaWdodCk7XG4gICAgICAgIGN0eC5zY2FsZSh0aGlzLmRwciwgdGhpcy5kcHIpO1xuICAgICAgICBjdHgudHJhbnNmb3JtKHNjYWxlLCAwLCAwLCBzY2FsZSwgcG9zaXRpb24ub2Zmc2V0WCwgcG9zaXRpb24ub2Zmc2V0WSk7XG4gICAgICAgIC8vIGN0eC5fY3R4LnNldFRyYW5zZm9ybSgpO1xuICAgICAgICAvLyBjdHguX2N0eC5jbGVhclJlY3QoMCwgMCwgY193aWR0aCwgY19oZWlnaHQpO1xuICAgICAgICAvLyBjdHguX2N0eC5zY2FsZSh0aGlzLmRwciwgdGhpcy5kcHIpO1xuICAgICAgICAvLyBjdHgudHJhbnNmb3JtKHNjYWxlLCBwb3NpdGlvbi5vZmZzZXRYLCBwb3NpdGlvbi5vZmZzZXRZKTtcbiAgICB9XG5cbiAgICByZXNldFRyYW5zZm9ybShjdHgpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgY3R4LnNjYWxlKHRoaXMuZHByLCB0aGlzLmRwcik7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0oc2NhbGUsIDAsIDAsIHNjYWxlLCBwb3NpdGlvbi5vZmZzZXRYLCBwb3NpdGlvbi5vZmZzZXRZKTtcbiAgICB9XG5cbiAgICBfZ2V0Vmlld0JveCgpIHtcbiAgICAgICAgLy8gY29uc3QgY2FjaGVWaWV3Qm94ID0gW1xuICAgICAgICAvLyAgICAgLi4udGhpcy5fY2FsY3VsYXRlUG9pbnRCYWNrKFswLDBdKSxcbiAgICAgICAgLy8gICAgIC4uLnRoaXMuX2NhbGN1bGF0ZVBvaW50QmFjayhbdGhpcy5jYW52YXNNZXRhLmFjdHVhbF93aWR0aCx0aGlzLmNhbnZhc01ldGEuYWN0dWFsX2hlaWdodF0pLFxuICAgICAgICAvLyBdO1xuICAgICAgICBjb25zdCBjYWNoZVZpZXdCb3ggPSB0aGlzLl9jYWNoZVZpZXdCb3g7XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVBvaW50QmFja1dpdGhQb2ludCgwLDAsIGNhY2hlVmlld0JveCwgMCwgMSk7XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVBvaW50QmFja1dpdGhQb2ludChcbiAgICAgICAgICAgIHRoaXMuY2FudmFzTWV0YS5hY3R1YWxfd2lkdGgsXG4gICAgICAgICAgICB0aGlzLmNhbnZhc01ldGEuYWN0dWFsX2hlaWdodCwgXG4gICAgICAgICAgICBjYWNoZVZpZXdCb3gsIDIsIDMpO1xuICAgICAgICByZXR1cm4gY2FjaGVWaWV3Qm94O1xuICAgIH1cblxuICAgIHNldE5vZGVUb1RvcExheWVyKG5vZGUpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9zdGFjay5maW5kSW5kZXgobiA9PiBuID09PSBub2RlKTtcbiAgICAgICAgaWYoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBbcmVuZGVyTm9kZV0gPSB0aGlzLl9zdGFjay5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5fc3RhY2sucHVzaChyZW5kZXJOb2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldENhY2hlVmlld0JveCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlVmlld0JveDtcbiAgICB9XG5cbiAgICBcbiAgICBfcmVuZGVyKCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgfVxuXG4gICAgIC8qKlxuICAgICAqIOe7mOWItueUu+W4g1xuICAgICAqL1xuICAgIF9fcmVuZGVyKCkge1xuICAgICAgICBpZighdGhpcy5fcmVhZHlUb1JlbmRlcikgcmV0dXJuO1xuICAgICAgICAvLyBpZih0aGlzLmhhc0FuaW1lQW5kRnJhbWVSZW5kZXJlZCgpKSByZXR1cm47XG4gICAgICAgIHRoaXMucnVuQW5pbWVGcmFtZSgpO1xuICAgICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybSgpO1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdiZWZvcmVKZmxvd1JlbmRlcicsIHtcbiAgICAgICAgICAgIGN0eFxuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IGJyID0gdGhpcy5fZ2V0Vmlld0JveCgpO1xuXG4gICAgICAgIGlmKHRoaXMuTm9kZVJlbmRlclRvcCkge1xuICAgICAgICAgICAgdGhpcy5fbGlua1N0YWNrLnJlbmRlcihjdHgsIChsaW5rKSA9PiAhbGluay5PTl9UT1AgJiYgbGluay5pc0luVmlld0JveChicikpO1xuICAgICAgICAgICAgdGhpcy5fc3RhY2sucmVuZGVyKGN0eCwgKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZG9PdmVybGFwKGJyLCBpbnN0YW5jZS5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuX2lzSW5WaWV3Qm94ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2xpbmtTdGFjay5yZW5kZXIoY3R4LCAobGluaykgPT4gbGluay5PTl9UT1AgJiYgbGluay5pc0luVmlld0JveChicikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3RhY2sucmVuZGVyKGN0eCwgKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZG9PdmVybGFwKGJyLCBpbnN0YW5jZS5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coaW5zdGFuY2UuX2xheW91dE5vZGUudHlwZSwgcmVzdWx0KVxuICAgICAgICAgICAgICAgIGluc3RhbmNlLl9pc0luVmlld0JveCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9saW5rU3RhY2sucmVuZGVyKGN0eCwgKGxpbmspID0+IGxpbmsuaXNJblZpZXdCb3goYnIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjdHguc2F2ZSgpO1xuICAgICAgICAvLyBmb3IobGV0IGkgPTA7aTwyMDAwO2krKykge1xuICAgICAgICAvLyAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAvLyAgICAgY3R4LmZpbGxTdHlsZSA9IGByZ2IoJHtwYXJzZUludChNYXRoLnJhbmRvbSgpKjI1NSl9LCR7cGFyc2VJbnQoTWF0aC5yYW5kb20oKSoyNTUpfSwke3BhcnNlSW50KE1hdGgucmFuZG9tKCkqMjU1KX0pYFxuICAgICAgICAvLyAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAvLyAgICAgICAgIE1hdGgucmFuZG9tKCkqMjUwLCBcbiAgICAgICAgLy8gICAgICAgICBNYXRoLnJhbmRvbSgpKjI0MCwgXG4gICAgICAgIC8vICAgICAgICAgTWF0aC5yYW5kb20oKSoyMDAsIFxuICAgICAgICAvLyAgICAgICAgIE1hdGgucmFuZG9tKCkqMzAwKVxuICAgICAgICAvLyB9XG4gICAgICAgIFxuICAgICAgICAvLyBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAgIGlmKHRoaXMuX3RlbXBOb2RlKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgdGhpcy5fdGVtcE5vZGUucmVuZGVyKGN0eClcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5fdGVtcExpbmspIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICB0aGlzLl90ZW1wTGluay5pc0luVmlld0JveChicilcbiAgICAgICAgICAgIHRoaXMuX3RlbXBMaW5rLnJlbmRlcihjdHgpXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBKRmxvd0V2ZW50KCdhZnRlckpmbG93UmVuZGVyJywge1xuICAgICAgICAgICAgY3R4XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5yZW5kZXJTY3JvbGxCYXIoY3R4KTtcbiAgICAgICAgLy8gdGhpcy5zZXRGcmFtZVJlbmRlcmVkKCk7XG4gICAgfVxufVxuT2JqZWN0LmFzc2lnbihKRmxvdy5wcm90b3R5cGUsIE1lc3NhZ2VNaXhpbik7XG5PYmplY3QuYXNzaWduKEpGbG93LnByb3RvdHlwZSwgU3RhY2tNaXhpbik7XG5PYmplY3QuYXNzaWduKEpGbG93LnByb3RvdHlwZSwgTGF5b3V0TWl4aW4pO1xuT2JqZWN0LmFzc2lnbihKRmxvdy5wcm90b3R5cGUsIHtcbiAgICByZWNhbGN1bGF0ZVVwKCkge1xuICAgICAgICBpZih0aGlzLl9fbW91bnRlZF9fKSB7XG4gICAgICAgICAgICB0aGlzLnJlZmxvdygpO1xuICAgICAgICB9XG4gICAgfVxufSlcblxuT2JqZWN0LmFzc2lnbihKRmxvdy5wcm90b3R5cGUsIE5vZGVXZWFrTWFwTWl4aW4pO1xuT2JqZWN0LmFzc2lnbihKRmxvdy5wcm90b3R5cGUsIEFuaW1lTWl4aW4pO1xuT2JqZWN0LmFzc2lnbihKRmxvdy5wcm90b3R5cGUsIE1pbmlNYXBNaXhpbik7XG5PYmplY3QuYXNzaWduKEpGbG93LnByb3RvdHlwZSwgU2NoZWR1bGVNaXhpbik7XG5PYmplY3QuYXNzaWduKEpGbG93LnByb3RvdHlwZSwgU2Nyb2xsQmFyTWl4aW4pO1xuXG5leHBvcnQgZGVmYXVsdCBKRmxvdztcbmV4cG9ydCB7IEpGTE9XX01PREUgfSBmcm9tICcuLi91dGlscy9jb25zdGFuY2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBKRmxvd0V2ZW50IH0gZnJvbSAnLi4vZXZlbnRzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY29tbW9uRXZlbnRBZGFwdGVyIH0gZnJvbSAnLi4vZXZlbnRzL2NvbW1vbkFkYXB0ZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBJbnN0YW5jZSB9IGZyb20gJy4uL2luc3RhbmNlL2luc3RhbmNlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTm9kZSB9IGZyb20gJy4uL2luc3RhbmNlL25vZGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCYXNlTGluayB9IGZyb20gJy4uL2luc3RhbmNlL2Jhc2UtbGluayc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBvaW50IH0gZnJvbSAnLi4vaW5zdGFuY2Uvc2hhcGVzL3BvaW50JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUmVjdGFuZ2xlIH0gZnJvbSAnLi4vaW5zdGFuY2Uvc2hhcGVzL3JlY3RhbmdsZSc7XG4vLyBleHBvcnQgeyBkZWZhdWx0IGFzIEdyb3VwIH0gZnJvbSAnLi4vaW5zdGFuY2Uvc2hhcGVzL3JlY3RhbmdsZS1ncm91cCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENhcHN1bGUgfSBmcm9tICcuLi9pbnN0YW5jZS9zaGFwZXMvY2Fwc3VsZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENhcHN1bGVWZXJ0aWNhbCB9IGZyb20gJy4uL2luc3RhbmNlL3NoYXBlcy9jYXBzdWxlLXZlcnRpY2FsJztcbi8vIGV4cG9ydCB7IGRlZmF1bHQgYXMgQ2Fwc3VsZUdyb3VwIH0gZnJvbSAnLi4vaW5zdGFuY2Uvc2hhcGVzL2NhcHN1bGUtZ3JvdXAnO1xuLy8gZXhwb3J0IHsgZGVmYXVsdCBhcyBDYXBzdWxlVmVydGljYWxHcm91cCB9IGZyb20gJy4uL2luc3RhbmNlL3NoYXBlcy9jYXBzdWxlLXZlcnRpY2FsLWdyb3VwJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGlhbW9uZCB9IGZyb20gJy4uL2luc3RhbmNlL3NoYXBlcy9kaWFtb25kJztcbi8vIGV4cG9ydCB7IGRlZmF1bHQgYXMgRGlhbW9uZEdyb3VwIH0gZnJvbSAnLi4vaW5zdGFuY2Uvc2hhcGVzL2RpYW1vbmQtZ3JvdXAnO1xuLy8gZXhwb3J0IHsgZGVmYXVsdCBhcyBEaWFtb25kVmVydGljYWxHcm91cCB9IGZyb20gJy4uL2luc3RhbmNlL3NoYXBlcy9kaWFtb25kLXZlcnRpY2FsLWdyb3VwJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUmhvbWJ1cyB9IGZyb20gJy4uL2luc3RhbmNlL3NoYXBlcy9yaG9tYnVzJztcbi8vIGV4cG9ydCB7IGRlZmF1bHQgYXMgUmhvbWJ1c0dyb3VwIH0gZnJvbSAnLi4vaW5zdGFuY2Uvc2hhcGVzL3Job21idXMtZ3JvdXAnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUZXh0IH0gZnJvbSAnLi4vaW5zdGFuY2UvZWxlbWVudHMvdGV4dCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEljb24gfSBmcm9tICcuLi9pbnN0YW5jZS9pbWFnZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNoYWRvd0RvbSB9IGZyb20gJy4uL2luc3RhbmNlL3NoYWRvd0RvbSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEdyb3VwRmFjdG9yeSB9IGZyb20gJy4uL2luc3RhbmNlL2dyb3VwRmFjdG9yeSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIExpbmsgfSBmcm9tICcuLi9pbnN0YW5jZS9saW5rJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUG9seUxpbmsgfSBmcm9tICcuLi9pbnN0YW5jZS9wb2x5LWxpbmsnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCZXppZXJMaW5rIH0gZnJvbSAnLi4vaW5zdGFuY2UvYmV6aWVyLWxpbmsnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaW5lYXJMYXlvdXR9IGZyb20gJy4uL2xheW91dC9saW5lYXItbGF5b3V0Jztcbi8vIGV4cG9ydCB7IGRlZmF1bHQgYXMgVHJlZUxheW91dCB9IGZyb20gJy4uL2xlci1sYXlvdXRhO3lvdXQvdHJlZS1sYXlvdXQnO1xuLy8gZXhwb3J0IHsgZGVmYXVsdCBhcyBMb3djb2RlbGF5b3V0IH0gZnJvbSAnLi4vbGF5b3V0L2xvdy1jb2RlLWxheW91dCc7XG4vLyBleHBvcnQgeyBkZWZhdWx0IGFzIEVSTGF5b3V0IH0gZnJvbSAnLi4vbGF5b3V0L2VyLWxheW91dC9lci1sYXlvdXQnO1xuLy8gZXhwb3J0IHsgZGVmYXVsdCBhcyBPcmFuZ2UgfSBmcm9tICcuLi9pbnN0YW5jZS9ub2RlV3JhcHBlci9vcmFuZ2Uvb3JhbmdlJ1xuLy8gZXhwb3J0IHsgZGVmYXVsdCBhcyBUZXh0RWRpdG9yIH0gZnJvbSAnLi4vaW5zdGFuY2UvdGV4dC1lZGl0b3InO1xuLy8gZXhwb3J0IHsgZGVmYXVsdCBhcyBUZXh0R3JvdXB9IGZyb20gJy4uL2luc3RhbmNlL3RleHQtZ3JvdXAnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUZXh0R3JvdXB9IGZyb20gJy4uL2luc3RhbmNlL3RleHQtZ3JvdXAvdGV4dC1ncm91cCc7XG5leHBvcnQgeyBUZXh0RWxlbWVudCB9IGZyb20gJy4uL2luc3RhbmNlL3RleHQtZ3JvdXAvc3RvcmFnZSc7XG4vLyBleHBvcnQgeyBKRmxvd1BhdGgyRCB9IGZyb20gJy4uL3V0aWxzL3BhdGgtMmQnO1xuXG5leHBvcnQgeyBOb2RlUGxhY2Vob2xkZXIgfSBmcm9tICcuLi9pbnN0YW5jZS9ub2RlLXBsYWNlaG9sZGVyJztcbmV4cG9ydCB7IGFkZFJlZmxvd1dvcmsgfSBmcm9tICcuLi9kaXJ0eS13b3JrL2RpcnR5LXdvcmsnO1xuIiwiaW1wb3J0IHBhY2thZ2VKc29uIGZyb20gJy4uL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBkZWZhdWx0IGFzIEpGbG93IH0gZnJvbSAnLi9jb3JlL2Zsb3cnOyBcbmV4cG9ydCBkZWZhdWx0IEpGbG93O1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL2Zsb3cnO1xuLy8gZXhwb3J0IHsgZGVmYXVsdCBhcyBKRmxvd1Z1ZVBsdWdpbiwgSkZsb3dMaW5rR3JvdXAgfSBmcm9tICcuL3Z1ZS1wbHVnaW4vSkZsb3dQbHVnaW4uanMnO1xuSkZsb3cuJGpmbG93X3ZlcnNpb24gPSBwYWNrYWdlSnNvbi52ZXJzaW9uO1xuLy8gY29uc29sZS5sb2coYGpmbG93IHZlcnNpb25AJHtwYWNrYWdlSnNvbi52ZXJzaW9ufWApIl0sIm5hbWVzIjpbImNyZWF0ZUNhbnZhcyIsIndyYXBwZXIiLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjdHgiLCJnZXRDb250ZXh0IiwiX3dyYXBwZXIkZ2V0Qm91bmRpbmdDIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJsZWZ0IiwidG9wIiwic3R5bGUiLCJ1c2VyU2VsZWN0Iiwic2NhbGUiLCJ3aW5kb3ciLCJkZXZpY2VQaXhlbFJhdGlvIiwiTWF0aCIsImZsb29yIiwicG9zaXRpb24iLCJvdmVyZmxvdyIsImFwcGVuZCIsInJhd193aWR0aCIsInJhd19oZWlnaHQiLCJyZXNpemVDYW52YXMiLCJfd3JhcHBlciRnZXRCb3VuZGluZ0MyIiwiY2FoZUNhbnZhcyIsImNhaGVDYW52YXNjdHgiLCJyZXF1ZXN0Q2FjaGVDYW52YXMiLCJyZW5kZXIiLCJjbGVhclJlY3QiLCJzYXZlIiwicmVzdG9yZSIsImxpc3Rlbk9uRGV2aWNlUGl4ZWxSYXRpbyIsImNhbGxiYWNrIiwiZGVzdHJveUhhbmRsZXIiLCJ0YXJnZXQiLCJtYXRjaE1lZGlhIiwiY29uY2F0Iiwib25DaGFuZ2UiLCJjb25zb2xlIiwibG9nIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9uY2UiLCJhZGRFdmVudExpc3RlbmVyIiwiRElSRUNUSU9OIiwiUklHSFQiLCJCT1RUT00iLCJMRUZUIiwiVE9QIiwiU0VMRiIsIm5leHREaXJlY3Rpb24iLCJkaXJlY3Rpb24iLCJjbG9ja3dpc2UiLCJuZXh0RGlyIiwib3Bwb3NpdGVEaXJlY3Rpb24iLCJBUFBST1hJTUFURSIsIkpGTE9XX01PREUiLCJERUZBVUxUIiwiTElOS0lORyIsIkxJTkVfRElSIiwiRlJPTSIsIlRPIiwiQmV6aWVyIiwiYm91bmRpbmdfYm94IiwicG9pbnRzIiwibGVuZ3RoIiwieCIsInkiLCJtaW5feCIsIkluZmluaXR5IiwibWluX3kiLCJtYXhfeCIsIm1heF95IiwiaWR4IiwiaXRlbSIsIm1heCIsInNxciIsImRpc3QyIiwidiIsInciLCJkaXN0VG9TZWdtZW50U3F1YXJlZCIsInAiLCJsMiIsInQiLCJtaW4iLCJtaW5JbnRlcnNlY3Rpb25CZXR3ZWVuTm9kZXMiLCJkbXNmcm9tIiwiZG1zdG8iLCJtZXRhIiwiZnJvbURpciIsImZyb21QIiwidG9EaXIiLCJ0b1AiLCJkaXN0TWluIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJkZiIsInBmIiwiZHQiLCJwdCIsImRpc3QiLCJhc3NpZ24iLCJfcmVzb2x2ZUNvbnRyb2xQb2ludCIsImRpciIsInNwYW54Iiwic3BhbnkiLCJiZXppZXJQb2ludHMiLCJwMSIsInAyIiwic3RhcnRfZGlyIiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwiZW5kX2RpciIsIm1pblNwYW5YIiwibWluU3BhblkiLCJhYnMiLCJjcDEiLCJjcDIiLCJhcnJvd3NwYW4iLCJpbmNsdWRlcyIsImlzVmVydGljYWxFbmQiLCJlbmRYIiwiZW5kWSIsIl90b0NvbnN1bWFibGVBcnJheSIsImJlemllclBvaW50IiwiUCIsInEiLCJ1IiwiYW5nbGUiLCJhdGFuMiIsImRpc3RUb0JlemllclNlZ21lbnRTcXVhcmVkIiwiYiIsIl9jb25zdHJ1Y3QiLCJwb2ludCIsInByb2plY3QiLCJkIiwiZ2V0QmV6aWVyQW5nbGUiLCJzeCIsInN5IiwiY3AxeCIsImNwMXkiLCJjcDJ4IiwiY3AyeSIsImV4IiwiZXkiLCJkeCIsInBvdyIsImR5IiwiUEkiLCJnZXRJbnN0YW5jZUhlaWdodCIsImluc3RhbmNlIiwicmVjdCIsImdldEJvdW5kaW5nUmVjdCIsInBvbHlsaW5lUG9pbnRzIiwiaXNTZWxmIiwiZGlyU3BhbiIsImlzVmVydGljYWxTdGFydCIsInlwIiwicHVzaCIsInhwIiwicG1pZGRsZSIsInVuc2hpZnQiLCJtaW51c1ZlYyIsImFic1ZlYyIsInZlYyIsInNxcnQiLCJzY2FsZVZlYyIsIm1ha2VSYWRpdXNGcm9tVmVjdG9yIiwicGJlZm9yZSIsInBuZXh0IiwicmFkaXVzIiwidmVjMSIsInZlYzIiLCJhYnNWZWMxIiwiYWJzVmVjMiIsInIxIiwicjIiLCJkb092ZXJsYXAiLCJyZWMxIiwicmVjMiIsImlzUG9seUxpbmVJbnRlcnNlY3Rpb25SZWN0YW5nZSIsInBvbHlsaW5lIiwibCIsImkiLCJfcmVjdCIsIl9zbGljZWRUb0FycmF5IiwibDAiLCJsMSIsInIwIiwiY3AiLCJkZWJvdW5jZSIsImZ1bmMiLCJfdGhpcyIsInRpbWVvdXQiLCJ0aW1lciIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJjYWxsIiwiY29tcGFyZUJvdW5kaW5nYm94IiwiYSIsImNvcHlCb3VuZGluZ2JveCIsImlzaGl0S2V5IiwiU3ltYm9sIiwiaXNJblZpZXdCb3giLCJJbnN0YW5jZSIsIl9FdmVudFRhcmdldCIsIl9pbmhlcml0cyIsIl9zdXBlciIsIl9jcmVhdGVTdXBlciIsImNvbmZpZ3MiLCJfY2xhc3NDYWxsQ2hlY2siLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwidmlzaWJsZSIsIl9iZWxvbmdzIiwiYm9yZGVyV2lkdGgiLCJib3JkZXJDb2xvciIsImJhY2tncm91bmRDb2xvciIsInNoYWRvd0NvbG9yIiwic2hhZG93Qmx1ciIsInNoYWRvd09mZnNldFgiLCJzaGFkb3dPZmZzZXRZIiwib3BhY2l0eSIsIl9ib3VuZGluZ3JlY3QiLCJfY3JlYXRlQ2xhc3MiLCJrZXkiLCJnZXQiLCJfamZsb3ciLCJfdGFyZ2V0IiwibGluayIsIl9nZXRNb3ZpbmdUYXJnZXQiLCJzdGF0dXMiLCJtb3ZpbmdTdGF0ZSIsInNldCIsImlzaGl0IiwiZGlzcGF0Y2hFdmVudCIsIkN1c3RvbUV2ZW50IiwiZGV0YWlsIiwiamZsb3ciLCJfamZsb3dSb290IiwidW5pcXVlTmFtZSIsInZhbCIsIm9sZHZhbCIsIm9uRW50ZXJWaWV3Ym94Iiwib25MZWF2ZVZpZXdib3giLCJ2YWx1ZSIsInNldENvbmZpZyIsIl90aGlzMiIsImsiLCJpc0hpdCIsImNhbGN1bGF0ZUludGVyc2VjdGlvbiIsImdldEludGVyc2VjdGlvbnNJbkZvdXJEaW1lbnNpb24iLCJnZXRDZW50ZXIiLCJhbmNob3IiLCJnZXRCb3VuZGluZ0RpbWVuc2lvbiIsImJ1YmJsZUV2ZW50IiwiY3VzdG9tRXZlbnQiLCJjdXJyZW50VGFyZ2V0IiwiYnViYmxlcyIsImNhbGN1bGF0ZVRvUmVhbFdvcmxkIiwiY2FsY3VsYXRlVG9SZWFsV29ybGRXaXRoUG9pbnRlciIsIm91dHBvaW50IiwiaW5wb2ludCIsImNhbGN1bGF0ZVRvUmVhbFdvcmxkV2l0aFNjYWxhciIsInJlY2FsY3VsYXRlVXAiLCJkZXN0cm95IiwiX3dyYXBOYXRpdmVTdXBlciIsIkV2ZW50VGFyZ2V0IiwicXVldWUiLCJjbGVhclF1ZXVlIiwicXVldWVTZXQiLCJXZWFrU2V0IiwiY2hlY2tXb3JrIiwiaGFzIiwiZ2V0U3RhY2tQYXRoIiwibm9kZSIsImV4cCIsIl9zdGFjayIsImZpbmRJbmRleCIsIm4iLCJzb3J0QnlQYXRoIiwibWFwIiwiV2Vha01hcCIsInNvcnQiLCJhcGF0aCIsImJwYXRoIiwiX2EiLCJzcGxpdCIsIl9iIiwiX3AiLCJfcSIsImFkZENsZWFyU291cmNlV29yayIsInNvdXJjZSIsImFkZFJlZmxvd1dvcmsiLCJwYXJlbnQiLCJkb1JlY2FsY3VsYXRlIiwiYWRkIiwiZmx1c2giLCJpbkZsdXNoIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicm9vdHMiLCJTZXQiLCJzaGlmdCIsIl9jbGVhclF1ZXVlJHNoaWZ0IiwiX2NsZWFyUXVldWUkc2hpZnQyIiwiZ2V0UmVuZGVyTm9kZUJ5U291cmNlIiwiY2xlYXJTb3VyY2UiLCJBcnJheSIsImZyb20iLCJfcmVuZGVyIiwiTm9kZSIsIl9JbnN0YW5jZSIsIl9kZWZpbmVQcm9wZXJ0eSIsIl9yYXdDb25maWdzIiwiYWJzb2x1dGVQb3NpdGlvbiIsInN0YWNrIiwicyIsIl90aGlzMyIsInNldEFuY2hvclgiLCJzZXRBbmNob3JZIiwic2V0QW5jaG9yIiwiYmVmb3JlUmVuZGVyIiwiX2dldFZpZXdCb3giLCJjbG9uZSIsIkMiLCJjb25zdHJ1Y3RvciIsIkdob3N0Tm9kZSIsIl9Ob2RlIiwiX3RoaXMkYW5jaG9yIiwieDIiLCJ5MiIsIl9yZWYiLCJfdGhpcyRhbmNob3IyIiwiZ2V0TWFwT2JqZWN0IiwibGF5b3V0Tm9kZSIsImpmbG93Tm9kZSIsImpmbG93bGlua3MiLCJqZmxvd0Zyb21MaW5rcyIsImpmbG93VG9MaW5rcyIsIk5vZGVXZWFrTWFwIiwiX21hcCIsIk1hcCIsIm9iaiIsIl9kZWxldGUiLCJjbGVhciIsIk5vZGVXZWFrTWFwTWl4aW4iLCJpbml0Tm9kZVdlYWtNYXAiLCJzb3VyY2VfTGF5b3V0X1JlbmRlcl9Ob2RlTWFwIiwibWFwcGluZyIsInJlbW92ZVJlbmRlck5vZGVCeVNvdXJjZSIsInNpemUiLCJnZXRMYXlvdXROb2RlQnlTb3VyY2UiLCJnZXRTb3VyY2VSZW5kZXJNZXRhIiwiX21ldGEiLCJfb2JqZWN0U3ByZWFkIiwiX2dldE1hcCIsInNldExheW91dE5vZGVCeVNvdXJjZSIsInNldFJlbmRlck5vZGVCeVNvdXJjZSIsInRvIiwiYWRkTGlua05vZGVCeVNvdXJjZSIsInNvdXJjZUZyb20iLCJzb3VyY2VUbyIsInJlbW92ZUxpbmtOb2RlQnlTb3VyY2UiLCJjaGFuZ2VMaW5rTm9kZUJ5U291cmNlIiwicHJldlNvdXJjZSIsIm5leHRTb3VyY2UiLCJjaGFuZ2VOb2RlQnlTb3VyY2UiLCJvbGRvYmoiLCJuZXdvYmoiLCJJbnN0YW5jZVN0YWNrIiwiX0FycmF5IiwiX2N1cnJlbnRIaXQiLCJjYiIsIl9nZXQiLCJfZ2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJ0eXBlIiwiZmlsdGVyIiwic2xpY2UiLCJzdXBlcmZpbHRlciIsImNvbmRpdGlvbiIsIm1vdmluZ1RhcmdldCIsIl9pc01vdmluZyIsInJlc2V0SGl0U3RhdHVzIiwiX2lzSGl0IiwiY2hlY2tIaXQiLCJjdXJyZW50Q29uc3RyYWludCIsImlnbm9yZUhpdCIsImdldEJvdW5kaW5nUmVjdFBvaW50cyIsImdldEFuY2hvclJlY3RQb2ludHMiLCJTdGFja01peGluIiwiaW5zdGFuY2VzIiwibGlua3MiLCJfbGlua1N0YWNrIiwiaW5pdFN0YWNrIiwiZGF0YSIsImFkZFRvU3RhY2siLCJpbnNlcnRUb1N0YWNrQmVmb3JlIiwiYW5jaG9yTm9kZSIsInJlbW92ZUZyb21TdGFjayIsInNwbGljZSIsInJlcGxhY2VGcm9tU3RhY2siLCJpbmRleCIsImFkZFRvTGlua1N0YWNrIiwiZmluZCIsInJlbW92ZUZyb21MaW5rU3RhY2siLCJlbXB0eUxpbmsiLCJyZXNldENoaWxkcmVuUG9zaXRpb24iLCJhZGRJbnN0YW5jZVRvTGluayIsInRhcmdldExpbmsiLCJfY29uc3R1Y3RvciIsIl9fcHJvdG9fXyIsImludGVyYXRlTm9kZVN0YWNrIiwiTGF5b3V0TWl4aW4iLCJfbGF5b3V0IiwiaW5pdExheW91dCIsImxheW91dCIsIl90aGlzJF9iZWxvbmdzIiwiZGlydHkiLCJfdGhpcyRnZXRCb3VuZGluZ0RpbWUiLCJ3b2xkIiwiaG9sZCIsIl9nZXRCb3VuZGluZ0dyb3VwUmVjdCIsInJlZmxvdyIsIl90aGlzJGdldEJvdW5kaW5nRGltZTIiLCJ3bm93IiwiaG5vdyIsInJlY2FsY3VsYXRlRG93biIsInJlZmxvd0FmdGVyIiwicmVjYWxjdWxhdGUiLCJzdGF0aWNDaGVjayIsIk1lc3NhZ2VNaXhpbiIsIl9tZXNzYWdlIiwic2VuZE1lc3NhZ2UiLCJtc2ciLCJjb25zdW1lTWVzc2FnZSIsInJlYWRNZXNzYWdlIiwiaW5pdEFuaW1lIiwiYW5pbWVfcXVldWUiLCJfX2FuaW1lQ2xvY2tfXyIsInJlcXVlc3RKRmxvd0FuaW1lIiwiZnJhbWVDYWxsQmFjayIsImVucXVldWVBbmltZSIsIl9ydW5BbmltZSIsImFuaW1lTWV0YSIsInN0YXJ0IiwiY2FuY2VsIiwiX2NhbmNlbEFuaW1lIiwibSIsInJ1bkFuaW1lIiwic2NoZWR1bGVSZW5kZXIiLCJydW5BbmltZUZyYW1lIiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsImVsYXBzZWQiLCJjYXB0dXJlTWFwIiwiX3JlZiRwYWRkaW5nIiwicGFkZGluZyIsIl9yZWYkcGxhY2VtZW50IiwicGxhY2VtZW50IiwiX3RoaXMkYm91bmRpbmdfYm94IiwicF93aWR0aCIsInBfaGVpZ2h0IiwicF94IiwicF95IiwibWluaU1hcCIsIl90aGlzJG1pbmlNYXAiLCJfcmVuZGVyTWFwIiwicHJlc3NEb3duIiwiZXZlbnQiLCJvZmZzZXRYIiwib2Zmc2V0WSIsImRlbHRhWCIsImRlbHRhWSIsIl9vbk1vdmVNYXAiLCJjYWNoZU1pbmltYXBDdHgiLCJfdGhpcyRtaW5pTWFwMiIsInBhZDIiLCJwYWQiLCJyIiwibV94IiwibV95IiwiY2FjaGVjdHgiLCJzZXRUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm0iLCJiciIsIk5vZGVSZW5kZXJUb3AiLCJfY2FjaGVNYXBJbWFnZURhdGEiLCJnZXRJbWFnZURhdGEiLCJwdXRJbWFnZURhdGEiLCJfdGhpcyRfZ2V0Vmlld0JveCIsIl90aGlzJF9nZXRWaWV3Qm94MiIsImJlZ2luUGF0aCIsImNsaXAiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsIl90aGlzJF9nZXRWaWV3Qm94MyIsIl90aGlzJF9nZXRWaWV3Qm94NCIsIl9yZWNhbGN1bGF0ZVBvc2l0aW9uIiwiSkZsb3dFdmVudCIsIl9DdXN0b21FdmVudCIsIm9yaWdpbkV2ZW50IiwiU2Nyb2xsQmFyIiwiYmFyV2lkdGgiLCJiYXJNYXJnaW5YIiwiYmFyTWFyZ2luWSIsInBsYWluQ29sb3IiLCJmb2N1c0NvbG9yIiwiaXNGb2N1cyIsImN5IiwiYnkiLCJyYyIsImxjIiwibW92ZVRvIiwiYXJjIiwibGluZVRvIiwiY2xvc2VQYXRoIiwidGMiLCJiYyIsImN4IiwicngiLCJmaWxsIiwiaCIsImluaXRTY3JvbGxCYXIiLCJiYXJDb2xvciIsImJhckZvY3VzQ29sb3IiLCJfc2Nyb2xsYmFyRW5hYmxlIiwiX3Njcm9sbGJhclgiLCJfc2Nyb2xsYmFyWSIsIl9zY3JvbGxCYXJTdGF0dXMiLCJkcmFnZ2luZyIsInhzY2FsZSIsInlzY2FsZSIsImJhckluaXRYIiwiYmFySW5pdFkiLCJzdG9wWm9vbXBhbldhdGNoIiwic2Nyb2xsQmFyT25QYW5BbmRab29tIiwiZSIsImNsaWVudFgiLCJjbGllbnRZIiwib25TY3JvbGxiYXJQcmVzc1N0YXJ0IiwiY2hlY2tTY3JvbGxEcmFnZ2luZyIsInhoaXQiLCJiYXJTdGFydFgiLCJ5aGl0IiwiYmFyU3RhcnRZIiwiZiIsIm9uRHJhZ2dpbmdTY3JvbGxiYXIiLCJiaW5kIiwiX3RoaXMkX3Njcm9sbEJhclN0YXR1Iiwic2NvbGxiYXJIZWlnaHQiLCJzY29sbGJhcldpZHRoIiwicmVhbFIiLCJyZWFsTCIsInJlYWxUIiwicmVhbEIiLCJfdGhpcyRjYW52YXNNZXRhIiwiY2FudmFzTWV0YSIsImFjdHVhbF93aWR0aCIsImFjdHVhbF9oZWlnaHQiLCJ4bmV3IiwicmF0aW9JblgiLCJyYXRpb1giLCJ5bmV3IiwicmF0aW9JblkiLCJyYXRpb1kiLCJjaGVja1Njcm9sbEJhckhvdmVyIiwiY3Vyc29yIiwicmVzZXRTY3JvbGxCYXJIb3ZlciIsIl9nZXRTY3JvbGxWaWV3Qm91bmRpbmdib3giLCJfdGhpcyRib3VuZGluZ19ib3gyIiwiX3RoaXMkX2dldFNjcm9sbFZpZXdCIiwidnciLCJ2aCIsIl90aGlzJGNhbnZhc01ldGEyIiwiYW5jaG9yWCIsImFuY2hvclkiLCJyZXNldFNjb2xsQmFyU3RhdHVzIiwicmVuZGVyU2Nyb2xsQmFyIiwiZHByIiwiX3RoaXMkX3Njcm9sbEJhclN0YXR1MiIsInRvZ2dsZVJlbmRlciIsIl9fcmVuZGVyc3RvcF9fIiwiaW5pdFNjaGVkdWxlIiwiX19jbG9ja19fIiwiaXNGaXJzdFRpbWUiLCJfX3JlbmRlciIsImdldERlZmF1bHRQbHVnaW4iLCJfbW91c2VTdGF0dXMiLCJwb2ludGVyRG93biIsIndoZWVsIiwicHJldmVudERlZmF1bHQiLCJjdHJsS2V5Iiwiem9vbUhhbmRsZXIiLCJwYW5IYW5kbGVyIiwicG9pbnRlcmRvd24iLCJidXR0b24iLCJwcmVzc1N0YXJ0SGFuZGxlciIsInBvaW50ZXJtb3ZlIiwicHJlc3NNb3ZlSGFuZGxlciIsInBvaW50ZXJ1cCIsInByZXNzVXBIYW5sZGVyIiwiY29udGV4dG1lbnUiLCJzdG9wUHJvcGFnYXRpb24iLCJjb250ZXh0TWVudUhhbmxkZXIiLCJkYmxjbGljayIsImRibGNsaWNrSGFuZGxlciIsImNsaWNrIiwiY2xpY2tIYW5sZGVyIiwiRXZlbnRBZGFwdGVyIiwicGx1Z2luIiwidXNlIiwiY2FudmFzSGFuZGxlcnMiLCJkb2N1bWVudEhhbmRsZXJzIiwiY2EiLCJkb2NPYmoiLCJldmVudE5hbWUiLCJoYXNPd25Qcm9wZXJ0eSIsImFwcGx5IiwiX3RoaXMkcGx1Z2luIiwiX2xvb3AiLCJoYW5kbGVyIiwiaGFuZGxlcldyYXBwZXJkIiwiX2xvb3AyIiwib3B0aW9ucyIsInVubG9hZCIsIl9yZWYyIiwiR3JvdXBNaXhpbiIsIl9zZXRQYWRkaW5nIiwicGFkZGluZ1RvcCIsInJpZ2h0IiwicGFkZGluZ1JpZ2h0IiwiYm90dG9tIiwicGFkZGluZ0JvdHRvbSIsInBhZGRpbmdMZWZ0IiwiX3NldE1hcmdpbiIsIm1hcmdpbiIsIm1hcmdpblRvcCIsIm1hcmdpblJpZ2h0IiwibWFyZ2luQm90dG9tIiwibWFyZ2luTGVmdCIsIl9nZXRDZW50ZXIiLCJteCIsIm15IiwiY2VudGVyWCIsImNlbnRlclkiLCJfc2hhcGUiLCJfY2VudGVyIiwiX2NhbGN1bGF0ZVBvaW50QmFjayIsIl9wb2ludCIsImd4IiwiZ3kiLCJfdGhpcyRfZ2V0Q2VudGVyIiwiX3RoaXMkX2dldENlbnRlcjIiLCJfY2FsY3VsYXRlUG9pbnRCYWNrV2l0aFBvaW50IiwiYXJyIiwiaWR4MSIsImlkeDIiLCJjYWxjdWxhdGVUb0Nvb3JkaW5hdGlvbiIsIl9wb2ludDIiLCJfdGhpcyRfZ2V0Q2VudGVyMyIsIl90aGlzJF9nZXRDZW50ZXI0IiwiX3BvaW50MyIsIl90aGlzJF9nZXRDZW50ZXI1IiwiX3RoaXMkX2dldENlbnRlcjYiLCJsdHgiLCJsdHkiLCJyYngiLCJyYnkiLCJfcDIiLCJfcG9pbnQ0IiwieDEiLCJ5MSIsInZlY3giLCJ2ZWN5IiwidGhldGExIiwidGhldGEyIiwiZGlyeCIsImRpcnkiLCJfX21vdW50ZWRfXyIsImRlZmF1bHRTaGlmdCIsIkdyb3VwRmFjdG9yeSIsImpmbG93Tm9kZUNvbnN0cnVjdG9yIiwic2hhcGVTaGlmdCIsIl9jb25maWdzJGxvY2siLCJfY29uZmlncyR0cmFuc3BhcmVudCIsImRlZmluZWRXaWR0aCIsIm1pbldpZHRoIiwiZGVmaW5lZEhlaWdodCIsImxvY2siLCJkaXNwbGF5IiwidHJhbnNwYXJlbnQiLCJfY2FjaGVWaWV3Qm94IiwiX3NoYXBlU2hpZnQiLCJfc2hhcGVTaGlmdDIiLCJzaGFwZVdpZHRoIiwic2hhcGVIZWlnaHQiLCJiYm94IiwicGFkZGluZ1dpZHRoIiwicGFkZGluZ0hlaWdodCIsIl9wYWRkaW5nV2lkdGgiLCJfcGFkZGluZ0hlaWdodCIsIl9zaGFwZVNoaWZ0MyIsIl9zaGFwZVNoaWZ0NCIsImJlbG9uZ3NfdmJveCIsImdldENhY2hlVmlld0JveCIsImNhY2hlVmlld0JveCIsImdsb2JhbEFscGhhIiwiX3RoaXMkX2dldENlbnRlcjciLCJfdGhpcyRfZ2V0Q2VudGVyOCIsInRyYW5zbGF0ZSIsIl9jdXJyZW50cCIsIlBvaW50IiwiX2RvQ2FjaGUiLCJsaW5lV2lkdGgiLCJzdHJva2VTdHlsZSIsInN0cm9rZSIsInJhdGlvIiwiY2FsY3VsYXRlSW50ZXJzZWN0aW9uSW5Gb3VyRGltZW5zaW9uIiwiZW5kIiwiX2FsbEludGVyc2VjdGlvbnMiLCJfdGhpcyRhbmNob3IzIiwiYWxsSW50ZXJzZWN0aW9ucyIsImludGVyRGlyIiwiUmVjdGFuZ2xlIiwiYm9yZGVyUmFkaXVzIiwiX3NldEJvcmRlciIsIl9jb25maWdzJGJvcmRlciIsIl9jb25maWdzJGJvcmRlcjIiLCJfY29uZmlncyRib3JkZXIzIiwiX2NvbmZpZ3MkYm9yZGVyNCIsIl9jb25maWdzJGJvcmRlcjUiLCJfY29uZmlncyRib3JkZXI2IiwiX2NvbmZpZ3MkYm9yZGVyNyIsIl9jb25maWdzJGJvcmRlcjgiLCJfY29uZmlncyRib3JkZXI5IiwiX2NvbmZpZ3MkYm9yZGVyMTAiLCJfY29uZmlncyRib3JkZXIxMSIsIl9jb25maWdzJGJvcmRlcjEyIiwiYm9yZGVyIiwiY29sb3IiLCJlbmFibGUiLCJ4dCIsInl0IiwicXVhZHJhdGljQ3VydmVUbyIsInN3aXRjaFBhdGgiLCJQYXRoMkQiLCJ0eSIsInRvcFBhdGgiLCJfcDMiLCJfcDQiLCJDYXBzdWxlIiwiaHciLCJoaCIsImxlZnRDZW50ZXIiLCJyaWdodENlbnRlciIsInd3IiwicnIiLCJDYXBzdWxlVmVydGljYWwiLCJfQ2Fwc3VsZSIsInRvcENlbnRlciIsImJvdHRvbUNlbnRlciIsInl5IiwiUmhvbWJ1cyIsImRpYWdvbmFsc1YiLCJkaWFnb25hbHNIIiwiY2VudGVyIiwiRGlhbW9uZCIsInNpZGUiLCJzaW5TSURFIiwic2luIiwiY29zU0lERSIsImNvcyIsInh4IiwiX2NhY2hlUG9pbnRzIiwicG9seWdvbiIsIm9kZCIsImoiLCJiYWNrc3FydDMiLCJEaWFtb25kVmVydGljYWwiLCJfRGlhbW9uZCIsInRvcG1pZGRsZSIsImJvdHRvbW1pZGRsZSIsInhsZWZ0IiwieHJpZ2h0IiwiSW5uZXJTY3JvbGxCYXIiLCJfU2Nyb2xsQmFyIiwic2V0SGl0Iiwib25IaXQiLCJTY3JvbGxHcm91cCIsIl9zdXBlcjIiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsIl9vZmZzZXQiLCJfcmVzZXRPZmZzZXQiLCJfZiIsImhpdFNjcm9sbFgiLCJoaXRTY3JvbGxZIiwiX3RoaXM0IiwiamZsb3dJbnN0YW5jZSIsIkpGTE9XIiwiX3Njcm9sbFdpZHRoIiwiX291dGVyV2lkdGgiLCJfaW5uZXJXaWR0aCIsIl9zY3JvbGxIZWlnaHQiLCJfb3V0ZXJIZWlnaHQiLCJfaW5uZXJIZWlnaHQiLCJvdXRlcldpZHRoIiwib3V0ZXJIZWlnaHQiLCJfdGhpcyRfb2Zmc2V0IiwidHgiLCJvZmZzZXQiLCJfdGhpcyRfb2Zmc2V0MiIsIl90aGlzJF9vZmZzZXQzIiwiX3RoaXMkYW5jaG9yNCIsIncyIiwiaDIiLCJfdGhpcyRfb2Zmc2V0NCIsIl90aGlzJGFuY2hvcjUiLCJzcCIsImlzSW5Cb3VuZCIsIl90aGlzJF9vZmZzZXQ1IiwiQmFzZUxpbmsiLCJ2aWV3Ym94IiwiYnJpbmdUb1RvcCIsImxpbmtTdGFjayIsIlNoYWRvd0NhY2hlIiwiaW1hZ2VCdWZmZXIiLCJjYWNoZSIsImRyYXdJbWFnZSIsIlRFWFRfQUxJR04iLCJDRU5URVIiLCJTUEFDRV9SRUciLCJUZXh0IiwiX1JlY3RhbmdsZSIsImNvbnRlbnQiLCJmb250RmFtaWx5IiwiZm9udFNpemUiLCJmb250V2VpZ2h0IiwidGV4dENvbG9yIiwicGxhY2Vob2xkZXJDb2xvciIsInRleHRBbGlnbiIsInRleHRCYXNlbGluZSIsImxpbmVIZWlnaHQiLCJpbmRlbnQiLCJlZGl0YWJsZSIsImVsbGlwc2lzIiwicGxhY2Vob2xkZXIiLCJlbXB0eVdoZW5JbnB1dCIsImVkaXR0aW5nIiwiZGlzYWJsZWQiLCJjdXJzb3JDb2xvciIsInRleHRSYW5nZUNvbG9yIiwic3BhY2VQbGFjZWhvbGRlciIsInNwYWNlUGxhY2Vob2xkZXJDb2xvciIsInNwYWNlUmVjb3JkcyIsIl9zcGFjZWRDb250ZW50U2VnbW5lbnQiLCJfc3RhdHVzIiwiZWRpdGluZyIsImN1cnNvcnNob3ciLCJjdXJzb3JhbmltZSIsImxhc3RFbGFwc2VkIiwicmVmcmVzaEVsYXBzZWQiLCJjdXJzb3JEcmFnZ2luZyIsInNoaWZ0T24iLCJvbGRWYWwiLCJpbnB1dEVsZW1lbnQiLCJfY3Vyc29yT2Zmc2V0IiwiX3RleHRSYW5nZSIsInJhbmdlZnJvbSIsInJhbmdlVG8iLCJpbml0aWFsUmFuZ2UiLCJfbWFrZUZ1bmN0aW9uYWwiLCJwcmVDYWxjdWxhdGVUZXh0Iiwic2hhZG93Q2FjaGUiLCJyZXBsYWNlU3BhY2VIb2xkZXIiLCJ1c2VDYWNoZSIsInJlcGxhY2UiLCJsYXN0T2Zmc2V0IiwiYyIsIl8iLCJmb250IiwidF9oIiwicGFyc2VJbnQiLCJjdXJyZW50Q29udGVudCIsIl9jdHgkbWVhc3VyZVRleHQiLCJtZWFzdXJlVGV4dCIsImZvbnRCb3VuZGluZ0JveEFzY2VudCIsImZvbnRCb3VuZGluZ0JveERlc2NlbnQiLCJfdGV4dFdpZHRoIiwiX2NhbGN1bGF0ZU9mZnNldCIsImVsbGlwc2lzQ29udGVudCIsInN1YnN0cmluZyIsIl9jdHgkbWVhc3VyZVRleHQyIiwic193aWR0aCIsInBjb2xvciIsIl90ZXh0SGVpZ2h0IiwiX3NoYWRvd0NhY2hlIiwiaXNFbXB0eSIsIl93Iiwic2VnIiwiZmlsbFRleHQiLCJfdGhpczUiLCJmbGFnIiwiX3Bvc2l0aW9uVG9DdXJzb3JPZmZzZXQiLCJjcmVhdGVJbnB1dEVsZW1lbnQiLCJfY29udHJvbENhbGxiYWNrIiwiX2RlZmF1bHRDYWxsYmFjayIsIkRPTXdyYXBwZXIiLCJmb2N1cyIsInByZXZlbnRTY3JvbGwiLCJzZXRGb2N1c0luc3RhbmNlIiwic3luY1NoYWRvd0lucHV0UG9zaXRpb24iLCJfdGhpczYiLCJibHVySGFuZGxlciIsInJlbW92ZSIsIl9zZWxlY3RGdWxsUmFuZ2UiLCJfcmVmcmVzaEN1cnNvciIsIl90aGlzNiRfc3RhdHVzJGN1cnNvciIsIm1vdmVkIiwib3giLCJjdXJzb3JPZmZzZXQiLCJvZmZ4IiwiX3RoaXM3IiwibWF4TCIsImNvbnRlbnRXaWR0aCIsImFsbHdpZHRoIiwiZzEiLCJnMiIsImxhc3RpZHgiLCJjMSIsImMyIiwidzEiLCJzcGFudyIsImRpc2FibGVDYWNoZSIsInRleHRoZWlnaHQiLCJseCIsImx5IiwiY3ciLCJjX2xlbiIsIl90aGlzJF90ZXh0UmFuZ2UiLCJyYW5nZSIsIl9pbnB1dENvbnRyb2wiLCJvcCIsIl9jbGVhclRleHRSYW5nZSIsInJlZnJlc2giLCJwcmVDb250ZW50IiwiYWZ0ZXJDb250ZW50IiwiY2FjaGVJZHgiLCJzdG9wSW5wdXRFdmVudCIsImRlZmF1bHRBY3QiLCJzdG9wSW5wdXQiLCJibHVyIiwiX3RoaXM4IiwicHgiLCJfb25BcnJvd0xlZnQiLCJfb25BcnJvd1JpZ2h0IiwiX29uU2hpZnRUb2dnbGUiLCJfY29weSIsIl9jdXQiLCJfcGFzdGUiLCJfdGhpcyRfdGV4dFJhbmdlMiIsIl9nZXRTZWxlY3Rpb24iLCJfdGhpcyRfdGV4dFJhbmdlMyIsInNlbGVjdGlvbiIsImNsaXBib2FyZERhdGEiLCJzZXREYXRhIiwicGFzdGVDb250ZW50IiwiZ2V0RGF0YSIsInJlc29sdmVQYXN0ZUNvbnRlbnQiLCJjb2RlIiwicmF3RXZlbnQiLCJfZm9jdXMiLCJjb250cm9sQ2FsbGJhY2siLCJkZWZhdWx0Q2FsbGJhY2siLCJpbnB1dCIsInNldEF0dHJpYnV0ZSIsImN0cmxPbiIsIkljb24iLCJpbWFnZSIsIm9ubG9hZCIsImltYWdlQm91bmRpbmciLCJpbWFnZVdpZHRoIiwiaW1hZ2VIZWlnaHQiLCJjb21wbGV0ZSIsIlNoYWRvd0RvbSIsImRvbUZhY3RvcnkiLCJjcmVhdGVEb2N1bWVudCIsIl9kb20iLCJnZXRSZWFsV29ybGRQb3NpdGlvbiIsImNvbnRhaW5lciIsInBvcyIsImFwcGVuZENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJMaW5rIiwiX0Jhc2VMaW5rIiwibGluZURhc2giLCJhcHByb3hpbWF0ZSIsIl9jYWNoZUFuZ2xlIiwiX2NhY2hlQm91bmRpbmdib3giLCJfY2FsY3VsYXRlQW5jaG9yUG9pbnRzIiwicDAiLCJmcm9tYm94IiwidG9ib3giLCJfYm94IiwiX3RoaXMkX2NhY2hlUG9pbnRzIiwiYWN0dWFsQm91bmRpbmdCb3hMZWZ0IiwiYWN0dWFsQm91bmRpbmdCb3hSaWdodCIsInJlZ2lvbiIsInJ5IiwicnciLCJyaCIsInNldExpbmVEYXNoIiwicm90YXRlIiwiX3RoaXMkX2NhY2hlUG9pbnRzMiIsIlBJSU5SQVRJTyIsIlBvbHlMaW5rIiwiZG91YmxlTGluayIsIm5vQXJyb3ciLCJfc3RhdGljIiwicEVuZCIsImFuZ2xlRW5kIiwiYmVnaW5BbmdsZSIsInBMYXN0IiwicE5leHQiLCJfbWFrZVJhZGl1c0Zyb21WZWN0b3IiLCJsYXN0UCIsInJlbWFpblBvaW50cyIsImN1cnJlbnRQIiwiY2xvbmVTdGF0aWMiLCJfT2JqZWN0JGFzc2lnbiIsIkJlemllckxpbmsiLCJiZXppZXJDdXJ2ZVRvIiwiaGFzRmxpcCIsIl9iZXppZXJQb2ludCIsIl9iZXppZXJQb2ludDIiLCJMaW5lYXJMYXlvdXQiLCJfY29uZmlncyRnYXAiLCJnYXAiLCJhbGlnbm1lbnQiLCJqdXN0aWZ5IiwiZ3JvdXAiLCJhYnNvbHV0ZVN0YWNrIiwiZ3JvdXBXaWR0aCIsInJlZHVjZUhlaWdodCIsImxhc3RJbnN0YW5jZUhlaWdodCIsImFsbEhlaWdodCIsImNoaWxkQWxsIiwiX2luc3RhbmNlJGdldEJvdW5kaW5nIiwiX2luc3RhbmNlJGdldEJvdW5kaW5nMiIsIl9pbnN0YW5jZSRnZXRCb3VuZGluZzMiLCJfaW5zdGFuY2UkZ2V0Qm91bmRpbmc0IiwicmVkdWNlV2lkdGgiLCJsYXN0SW5zdGFuY2VXaWR0aCIsImFsbFdpZHRoIiwiYWxsUHVyZVdpZHRoIiwiX2luc3RhbmNlJGdldEJvdW5kaW5nNSIsIndpdGhkcmF3IiwiZ2FwQXZlcmFnZSIsIl9pbnN0YW5jZSRnZXRCb3VuZGluZzYiLCJfaW5zdGFuY2UkZ2V0Qm91bmRpbmc3IiwiV0lEVEgiLCJIRUlHSFQiLCJzaGlmdHkiLCJzaGlmdHgiLCJfcmVzb2x2ZUFic29sdXRlQW5jaG9yIiwiY29uZmlnIiwiX2luc3RhbmNlJGdldEJvdW5kaW5nOCIsIkVESVRPUl9FVkVOVFMiLCJJTlBVVCIsIkNPTlRST0xfQ01EIiwiS0VZQk9BUkRfSU5QVVQiLCJDT01QT1NJVElPTl9TVEFSVCIsIkNPTVBPU0lUSU9OX1VQREFURSIsIkNPTVBPU0lUSU9OX0VORCIsIkVOVEVSIiwiREVMRVRFIiwiQkFDS1NQQUNFIiwiS0VZQk9BUkRfQ09NTUFORFMiLCJBUlJPV19MRUZUIiwiQVJST1dfUklHSFQiLCJBUlJPV19VUCIsIkFSUk9XX0RPV04iLCJVTkRPIiwiUkVETyIsIlNISUZUX0RPV04iLCJTSElGVF9VUCIsIkNUUkxBIiwiQ09QWSIsIkNVVCIsIlBBU1RFIiwiTU9VU0VfQ09NTUFORFMiLCJTVEFSVF9FRElUIiwiRURJVF9DTElDSyIsIlNISUZUX09OX0NMSUNLIiwiRE9VQkxFX0NMSUNLIiwiT1BFUlJBVElPTiIsIlBMQUlOSU5QVVQiLCJTUEFDRUlOUFVUIiwiUkVUVVJOSU5QVVQiLCJDQVJFVE1PVkVNRU5UIiwiREVMRVRFX0lOX0xJTkUiLCJERUxFVEVfSU5fRURJVEFSRUEiLCJFTlNVUkVfREVMRVRFIiwiU0VMRUNUSU9OX0RFTEVURSIsIlNFTEVDVElPTl9JTlBVVCIsIkNPTVBPU0lURV9JTlNFUlQiLCJTaGFkb3dJbnB1dCIsIl9pbnB1dEVsZW1lbnQiLCJraW5kIiwic3luY1Bvc2l0aW9uIiwicmVtb3ZlTGlzZW50ZXIiLCJDYXJldCIsInNob3ciLCJhbmltZSIsInNldFJvdyIsInJvdyIsIl9yb3ciLCJzZXRDb2x1bW4iLCJjb2x1bW5vcmlkeCIsImNvbHVtbiIsIl9jb2x1bW4iLCJnZXRSb3ciLCJnZXRDb2x1bW4iLCJhbmltYXRlIiwiY2FuY2VsQW5pbWF0ZSIsImlzU2hvdyIsInRvUmFuZ2UiLCJmcm9tUmFuZ2UiLCJjYWxjdWxhdGVPZmZzZXRCeVdpZHRoIiwidGV4dG1ldGEiLCJzcGFjZUhvbGRlciIsImdldFJlbmRlclNvdXJjZSIsIkFyZWEiLCJfbGluZXMiLCJnZXRMaW5lQWJvdmUiLCJsaW5lcyIsInRydW5jYXRlIiwiTGluZSIsImNyZWF0ZSIsImxpbmUiLCJfZWxlbWVudHMiLCJpbnNlcnQiLCJlbGVtIiwidGFpbCIsImNvcHkiLCJnZXRDb2x1bW5OZWFyZXN0IiwiZWxlbWVudFNwYWNlIiwiZWRpdG9yIiwiZWxlbWVudHMiLCJlbGVtX2lkeCIsImxhc3RfYyIsIl9jIiwibGFzdGVsIiwiZWwiLCJkb3VibGVNYXJnaW4iLCJGbGF0dGVuVGV4dEVsZW1lbnRzIiwiaW5zZXJ0QmVmb3JlIiwiaW5lcnNldEF0IiwiaW5zZXJ0QWZ0ZXIiLCJuZWVkV3JhcCIsInNldE5lZWRXcmFwIiwiX3RleHRFbGVtZW50cyIsIl90aGlzJF90ZXh0RWxlbWVudHMiLCJyZW1vdmVkIiwiX3JlY29yZHMiLCJhcmdzIiwiX3RoaXMkX3RleHRFbGVtZW50czIiLCJzdGFydFJlY29yZCIsIl9jYXJldFJlY29yZCIsImJlZm9yZSIsImFmdGVyIiwiZ2V0UmVjb3JkIiwicmVjb3JkQmVmb3JlQ2FyZXQiLCJjYXJldCIsInJlY29yZEFmdGVyQ2FyZXQiLCJnZXRDYXJldFJlY29yZCIsImNvbGxlY3RSZWNvcmRzIiwiX2UiLCJUZXh0RWxlbWVudCIsInN5bWJvbCIsInNldFNvdXJjZVdpdGhSZWNvcmQiLCJyZWNvcmRzIiwibGFzdFNvdXJjZSIsInNldFNvdXJjZSIsIl9zcGFjZVJlY29yZHMiLCJsYXN0V3JhcCIsInN0ZXAiLCJuZXh0T2Zmc2V0IiwidGFpbE9mZnNldCIsImlzVGFpbCIsImhlYWRPZmZzZXQiLCJfcmV0dXJuU3ltYm9sIiwicmV0dXJuRm9udCIsIlJhbmdlIiwic2V0SW5pdGlhbFJhbmdlIiwiX2luaXRpYWxSYW5nZSIsImdldFJhbmdlRnJvbSIsIl9yYW5nZUZyb20iLCJnZXRSYW5nZVRvIiwiX3JhbmdlVG8iLCJpc0VuYWJsZSIsIl9lbmFibGUiLCJkaXNhYmxlIiwiaGFuZGxlQ2FyZXQiLCJfdGhpcyRfcmFuZ2VUbyIsInNldFJhbmdlIiwiYW5vdGhlciIsIl9jb21wYXJlUmFuZ2UiLCJnZXRSYW5nZUNvcHkiLCJhcmVhIiwiX2FyZWEiLCJfY2FyZXQiLCJyYW5nZUZyb20iLCJlbGVtRnJvbSIsImVsZW1UbyIsImZsYXR0ZW5UeHRFbGVtIiwiX2ZsYXR0ZW5UeHRFbGVtIiwiZnJvbUlkeCIsInRvSWR4IiwiZWxlbXMiLCJwcmVFbGVtZW50IiwiYWZ0ZXJFbGVtZW50IiwiZW5kVGV4dE5lZWRXcmFwIiwiaXNTZXRTb3VyY2VCYXRjaCIsIlVuZG9SZWRvIiwid3JpdGUiLCJjYXJldFJlY29yZCIsImxhc3RVbmRvIiwiZ2V0TGFzdFVuZG8iLCJfYmF0Y2giLCJfY2FyZXRNZXRhVG8iLCJCYXRjaEFjdGlvbiIsIl9jYXJldE1ldGFGcm9tIiwiX3VuZG8iLCJfbGVuZ3RoIiwiX3JlZG8iLCJ1bmRvIiwicG9wIiwiX2VkaXRvciIsInJlZG8iLCJTS0lQX1JFRE8iLCJkZWZhdWx0IiwiYmF0Y2giLCJ1cGRhdGVDYXJldE1ldGFUbyIsInJldmVyc2UiLCJhY3Rpb24iLCJfYWN0aW9uJGFyZ3MiLCJfcmFuZ2UiLCJfYWN0aW9uJGFyZ3MyIiwibHMiLCJfYWN0aW9uJGFyZ3MzIiwibyIsIl9hY3Rpb24kYXJnczQiLCJfdG9BcnJheSIsIl9hY3Rpb24kYXJnczUiLCJfYWN0aW9uJGFyZ3M2IiwiQ29tbWFuZCIsImV4ZWMiLCJBcnJvd0xlZnRDb21tYW5kIiwiX0NvbW1hbmQiLCJlbGVtaWR4IiwiZWxlbWVudCIsInJlc3VsdCIsInByZVJvdyIsInByZUVsZW1pZHgiLCJBcnJvd1JpZ2h0Q29tbWFuZCIsIl9Db21tYW5kMiIsIl9jb2x1bW4yIiwiYWZ0ZXJSb3ciLCJBcnJvd1VwQ29tbWFuZCIsIl9Db21tYW5kMyIsIl9zdXBlcjMiLCJuZXh0Um93IiwiX2hhbmRsZXIiLCJBcnJvd0Rvd25Db21tYW5kIiwiX0NvbW1hbmQ0IiwiX3N1cGVyNCIsIl9taXhpbiIsIl9jb2x1bW4zIiwiY3VyckVsZW0iLCJjdXJyRWxlbVJlZHVjZVdpZHRoIiwibWVhc3VyZVRleHRXaWR0aCIsIm5leHRMaW5lIiwibmV4dENvbHVtbiIsIl9ibGFuZEFkamFjZW50RWxlbWVudCIsImVsZW0xIiwiZWxlbTIiLCJkZWZhdWx0T2Zmc2V0IiwiSW5wdXQiLCJfbGVuIiwiX2tleSIsInVuZG9yZWRvIiwiX3VuZG9yZWRvIiwiX2NhcmV0JGdldENvbHVtbiIsIl9jYXJldCRnZXRDb2x1bW4yIiwicHJlRWxlbSIsIm5ld0VsZW1lbnQiLCJ0ZXN0Iiwicm93cyIsImxhc3ROZWVkV3JhcCIsInRlbXAiLCJ0biIsImNvbCIsIl90IiwiX2JsYW5kQWRqYWNlbnRFbGVtZW50MiIsIl9ibGFuZEFkamFjZW50RWxlbWVudDMiLCJkZWxldGVvcCIsIl9ibGFuZEFkamFjZW50RWxlbWVudDQiLCJfYmxhbmRBZGphY2VudEVsZW1lbnQ1Iiwic2hpZnRyZXN1bHQiLCJuZXh0RWxlbSIsIl9ibGFuZEFkamFjZW50RWxlbWVudDYiLCJfYmxhbmRBZGphY2VudEVsZW1lbnQ3IiwiX2JsYW5kQWRqYWNlbnRFbGVtZW50OCIsIl9ibGFuZEFkamFjZW50RWxlbWVudDkiLCJTdGFydEVkaXRDb21tYW5kIiwiX3N0YXJ0RWRpdCIsIm1vdmVDYXJldEJ5SGl0UG9pbnQiLCJjcmVhdGVTaGFkb3dJbnB1dCIsIkVkaXRDbGlja0NvbW1hbmQiLCJEb3VibGVDbGlja0NvbW1hbmQiLCJTaGlmdFVwQ29tbWFuZCIsInRvZ2dsZVNoaWZ0IiwiU2hpZnREb3duQ29tbWFuZCIsIlNoaWZ0T25DbGlja0NvbW1hbmQiLCJDdHJsQUNvbW1hbmQiLCJVbmRvQ29tbWFuZCIsIlJlZG9Db21tYW5kIiwiQ29weUNvbW1hbmQiLCJDdXRDb21tYW5kIiwiY21kIiwiY29tbWFuZHMiLCJQYXN0ZUNvbW1hbmQiLCJfcHJldmVudERlZmF1bHQiLCJUZXh0R3JvdXAiLCJfc2hhZG93SW5wdXQiLCJsaW5lU3BhY2UiLCJyZXNvbHZlciIsImRyYWdvdmVyIiwicmVnaXN0Q29tbWFuZCIsIl9uYW1lIiwiZXhlY0NvbW1hbmQiLCJjb21tbmQiLCJ0ZXh0RWxlbWVudHMiLCJvbkRyb3AiLCJsYXN0TGVuZ3RoIiwic2hhZG93SW5wdXQiLCJfdGhpcyRfcG9zaXRpb25Ub0N1cnMiLCJyZWZyZXNoVGV4dEVsZW1lbnRzIiwiY3VyckxpbmUiLCJfY2FyZXRUb1Bvc2l0aW9uIiwiY3VycmVudExpbmVIZWlnaHQiLCJfdGhpcyRfY2FyZXRUb1Bvc2l0aW8iLCJfdGhpcyRfY2FyZXRUb1Bvc2l0aW8yIiwiX3JhbmRlckN1cnNvciIsIl9yZW5kZXJSYW5nZSIsIl90aGlzJF9jYXJldFRvUG9zaXRpbzMiLCJfdGhpcyRfY2FyZXRUb1Bvc2l0aW80IiwiYmxvY2toZWlnaHQiLCJibG9ja3dpZHRoIiwiX3JhbmdlJGdldFJhbmdlRnJvbSIsIl9yYW5nZSRnZXRSYW5nZUZyb20yIiwicl9mIiwiaWR4X2YiLCJvZmZzZXRfZiIsIl9yYW5nZSRnZXRSYW5nZVRvIiwiX3JhbmdlJGdldFJhbmdlVG8yIiwicl90IiwiaWR4X3QiLCJvZmZzZXRfdCIsInNwYWNlIiwiX21lYXN1cmVFbGVtZW50T2Zmc2V0WCIsIl9yIiwiYmVnaW5uaW5nIiwibGFzdEVsZW0iLCJ2YWxpZEluc3RhbmNlIiwiX3RoaXM3JGFuY2hvciIsIm5leHRBcmVhIiwibGFzdFJlZHVjZVkiLCJyZWR1Y2VYIiwicmVuZGVyTm9kZSIsIk5vZGVQbGFjZWhvbGRlciIsIkFuaW1lTWl4aW4iLCJNaW5pTWFwTWl4aW4iLCJTY3JvbGxCYXJNaXhpbiIsIlNjaGVkdWxlTWl4aW4iLCJHcm91cCIsIkNhcHN1bGVHcm91cCIsIlJob21idXNHcm91cCIsIkRpYW1vbmRHcm91cCIsIkRpYW1vbmRWZXJ0aWNhbEdyb3VwIiwiQ2Fwc3VsZVZlcnRpY2FsR3JvdXAiLCJQb2ludEdyb3VwIiwiY2VpbCIsIkpGbG93IiwiZXZlbnRBZGFwdGVyIiwiaW5pdGlhbFpvb20iLCJpbml0aWFsUG9zaXRpb24iLCJzZXRJbml0aWFsUG9zaXRpb24iLCJtYXhab29tIiwibWluWm9vbSIsIndvcmxkTWFyZ2luIiwiZHJhZ2dpbmdiZWhhdmlvciIsInBhbkluQm9yZGVyIiwiZGVsdGFtb3ZlbWVudCIsImFsbG93TW92aW5nVGFyZ2V0SW5QYW4iLCJzY3JvbGxCYXJCZWhhdmlvciIsIm9mZmVzZXQiLCJfbGFzdFN0YXRlIiwicHJvY2Vzc2luZyIsIl9sYXN0RHJhZ1N0YXRlIiwibW92aW5nIiwiaXNJbnN0YW5jZURpcnR5IiwiaXNMaW5rRGlydHkiLCJiZWxvbmdzIiwiaW5pdGlhbFgiLCJpbml0aWFsWSIsImRyYWdvdmVyaW5nIiwiX2RyYWdPdmVyVGFyZ2V0IiwiYWxsb3dEcm9wIiwiX3RlbXBOb2RlIiwiX3RlbXBMaW5rIiwibW9kZSIsIl9hbGxvd01vdmluZ1RhcmdldCIsInNldE1vdmluZ1RhcmdldHMiLCJ0YXJnZXRzIiwic2V0VGVtcERyYWdnaW5nSW5zdGFuY2UiLCJyZW1vdmVUZW1wRHJhZ2dpbmdJbnN0YW5jZSIsInByZXZlbnREZWZhdWx0RHJhZ2dpbmciLCJhbGxvd0RlZmF1bHREcmFnZ2luZyIsIiRtb3VudCIsImRvbSIsIl9jcmVhdGVDYW52YXMiLCJjX3dpZHRoIiwiY19oZWlnaHQiLCIkamZsb3ciLCJjb250ZW50Qm94Iiwid19yYXRpbyIsImhfcmF0aW8iLCJhbGlnbiIsInNjYWxlUmF0aW8iLCJyZWFsYm94WCIsInJlYWxib3hZIiwicmVhbGJveFciLCJyZWFsYm94SCIsIl90aGlzJGluaXRpYWxQb3NpdGlvbiIsIl9yZWFkeVRvUmVuZGVyIiwiX2NyZWF0ZUV2ZW50SGFuZGxlciIsImRlc3Ryb3lEcHJMaXN0ZW5lciIsInNldExpbmtpbmdNb2RlIiwibGlua0dlbiIsImlzSW5MaW5raW5nTW9kZSIsInNldExpbmtpbmdMaW5rIiwicmVzZXRMaW5raW5nTGluayIsImNsZWFyVGVtcCIsInByZXZlbnRDbGVhclRlbXAiLCJfcHJldmVudENsZWFyVGVtcCIsIl9yZXNpemVDYW52YXMyIiwiZm9jdXNPbiIsIm5vd3giLCJub3d5IiwiZGVzdHJveUxpc3RlbmVyIiwiZGVzdHJveVBsYWluRXZlbnRMaXN0ZW5lciIsImRyYWdvdmVySGFuZGxlciIsIl9vbkRyYWdvdmVyIiwiZHJvcEhhbmRsZXIiLCJfb25Ecm9wIiwiZHJhZ2xlYXZlSGFubGRlciIsIl9vbkRyYWdMZWF2ZSIsIl90YXJnZXRMb2NrT24iLCJvZmZzZXRQb2ludCIsInRvcExheWVyUG9pbnQiLCJtb3Zpbmd0YXJnZXQiLCJPTl9UT1AiLCJyZWxhdGVkVGFyZ2V0IiwiX3Byb2Nlc3NEcmFnT3ZlciIsIl90aGlzJHJlYWRNZXNzYWdlIiwiX2RyYWdDdXJyZW50RGF0YSIsIm9sZElucyIsIl9wcm9jZXNzUGFuSW5Cb3JkZXIiLCJfdGhpcyRkcmFnZ2luZ2JlaGF2aW8iLCJfdGhpcyRfY2FjaGVWaWV3Qm94IiwiX3RoaXMkX2N1cnJlbnRwIiwicHkiLCJfdGhpcyRkcmFnZ2luZ2JlaGF2aW8yIiwiX19wcm9jZXNzT3ZlckFuaW1lIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiX2NhbmNlbFBhbkluQm9yZGVyIiwiX3RoaXMkZHJhZ2dpbmdiZWhhdmlvMyIsInBheWxvYWQiLCJfdGhpcyRfdGFyZ2V0IiwiX3RoaXMkX3RhcmdldCRjYWNoZSIsImNhbmNlbERyb3AiLCJfem9vbWluZyIsIl90aGlzJGJvdW5kaW5nX2JveDMiLCJjaCIsIm5ld1NjYWxlIiwiYW1vdW50IiwiZGVsdGFTY2FsZSIsImN1cnJlbnRXaWR0aCIsImN1cnJlbnRIZWlnaHQiLCJkZWx0YVdpZHRoIiwiZGVsdGFIZWlnaHQiLCJ0WCIsInRZIiwicFgiLCJwWSIsIl90aGlzOSIsIl9wYW5uaW5nIiwiX3RoaXMxMCIsIl90aGlzJF90YXJnZXRMb2NrT24iLCJfcmVzb2x2ZUxvY2tPblRhcmdldCIsIl9wcmV2ZW50UHJlc3NTZXF1ZWVuY2UiLCJfY2xlYXJUYXJnZXQiLCJfdGhpczExIiwiX3RoaXMkX3RhcmdldCRzdGF0dXMiLCJfdGhpcyRfdGFyZ2V0JG1ldGEiLCJfdGhpcyRfdGFyZ2V0TG9ja09uMiIsIl90aGlzJF90YXJnZXRMb2NrT24zIiwiaXNEb2N1bWVudCIsImNoZWNrcmVzdWx0IiwiX3RoaXMkX3RhcmdldCRjYWNoZTIiLCJfdGhpcyRfdGFyZ2V0TG9ja09uNCIsIl90aGlzJF90YXJnZXRMb2NrT241IiwiX3RoaXMkX3RhcmdldExvY2tPbjYiLCJfdGhpcyRib3VuZGluZ19ib3g0IiwiYngxIiwiYngyIiwiYnkxIiwiYnkyIiwiX2NhbGN1bGF0ZURpc3RhbmNlIiwiX3Jlc2V0VHJhbnNmb3JtIiwiX3RoaXMkY2FudmFzTWV0YTMiLCJyZXNldFRyYW5zZm9ybSIsInNldE5vZGVUb1RvcExheWVyIiwiX3RoaXMkX3N0YWNrJHNwbGljZSIsIl90aGlzJF9zdGFjayRzcGxpY2UyIiwiX2lzSW5WaWV3Qm94IiwiY29tbW9uRXZlbnRBZGFwdGVyIiwicGFja2FnZUpzb24iLCIkamZsb3dfdmVyc2lvbiIsInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///406\n')}},__webpack_require__={d:(Q,U)=>{for(var B in U)__webpack_require__.o(U,B)&&!__webpack_require__.o(Q,B)&&Object.defineProperty(Q,B,{enumerable:!0,get:U[B]})},o:(Q,U)=>Object.prototype.hasOwnProperty.call(Q,U),r:Q=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})}},__webpack_exports__={};return __webpack_modules__[406](0,__webpack_exports__,__webpack_require__),__webpack_exports__})()}));
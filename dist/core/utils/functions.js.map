{"version":3,"sources":["core/utils/functions.js"],"names":["bounding_box","points","min_x","Infinity","min_y","max_x","max_y","idx","item","width","Math","max","height","x","y","sqr","dist2","v","w","distToSegmentSquared","p","l2","t","min","minIntersectionBetweenNodes","dmsfrom","dmsto","meta","fromDir","fromP","toDir","toP","distMin","Object","keys","forEach","df","DIRECTION","SELF","pf","dt","pt","dist","assign","_resolveControlPoint","dir","spanx","spany","TOP","BOTTOM","LEFT","RIGHT","bezierPoints","p1","p2","start_dir","end_dir","minSpanX","minSpanY","abs","cp1","cp2","arrowspan","includes","isVerticalEnd","endX","endY","bezierPoint","P","q","u","angle","atan2","distToBezierSegmentSquared","b","Bezier","point","project","d","getBezierAngle","sx","sy","cp1x","cp1y","cp2x","cp2y","ex","ey","dx","pow","dy","PI","getInstanceHeight","instance","rect","getBoundingRect","polylinePoints","isSelf","dirSpan","isVerticalStart","yp","push","xp","pmiddle","unshift","minusVec","absVec","vec","sqrt","scaleVec","scale","makeRadiusFromVector","pbefore","pnext","radius","vec1","vec2","absVec1","absVec2","r1","r2"],"mappings":"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","sourcesContent":["import {\n    Bezier,\n} from 'bezier-js';\nimport { DIRECTION } from './constance';\n\n/**\n * 根据点计算最小外接矩形\n * @param {number[][]} points - 点集合\n * @return {Object} demension 宽高，坐标\n */\nexport function bounding_box(points) {\n    let min_x = Infinity; \n    let min_y = Infinity; \n    let max_x = -Infinity; \n    let max_y = -Infinity; \n    for(let idx in points) {\n        const item = points[idx];\n        if(item[0] < min_x){\n            min_x = item[0]\n        }\n\n        if (item[0] > max_x) {\n            max_x = item[0]\n        } \n\n        if (item[1] < min_y) {\n            min_y = item[1]\n        }\n\n        if (item[1] > max_y) {\n            max_y = item[1]\n        }\n    }\n    return {\n        // points: [(min_x,min_y),(max_x,min_y),(max_x,max_y),(min_x,max_y)],\n        width: Math.max(max_x - min_x, 10),\n        height: Math.max(max_y - min_y, 10),\n        x: min_x,\n        y: min_y,\n    }\n}\n\nfunction sqr(x) {\n    return x * x;\n}\nexport function dist2(v, w) {\n    return sqr(v[0] - w[0]) + sqr(v[1] - w[1]);\n}\n\n// p - point\n// v - start point of segment\n// w - end point of segment\nexport function distToSegmentSquared(p, v, w) {\n    const l2 = dist2(v, w);\n    if (l2 === 0) return dist2(p, v);\n    let t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\n    t = Math.max(0, Math.min(1, t));\n    return dist2(p, [ v[0] + t * (w[0] - v[0]), v[1] + t * (w[1] - v[1]) ]);\n}\n\nexport function minIntersectionBetweenNodes(dmsfrom, dmsto) {\n    const meta = {\n        fromDir: null,\n        fromP: null,\n        toDir: null,\n        toP: null,\n        distMin: Infinity\n    }\n    Object.keys(dmsfrom).forEach(df => {\n        if((+df) === DIRECTION.SELF) {\n            return;\n        }\n        let pf = dmsfrom[df];\n        Object.keys(dmsto).forEach(dt => {\n            if((+dt) === DIRECTION.SELF) {\n                return;\n            }\n            let pt = dmsto[dt];\n            const dist = dist2(pf, pt);\n            if(dist < meta.distMin) {\n                Object.assign(meta, {\n                    distMin: dist,\n                    fromDir: +df,\n                    fromP: pf,\n                    toDir: +dt,\n                    toP: pt,\n                })\n            }\n        })\n    });\n    return meta;\n}\n\n// export function bezierPoints(p1, p2, start_dir = DIRECTION.TOP, end_dir = DIRECTION.TOP, anticlock = false) {\n//     const isSameDirection = start_dir === end_dir;\n//     const isVerticalStart = [DIRECTION.TOP, DIRECTION.BOTTOM].includes(start_dir);   \n//     const isVerticalEnd = [DIRECTION.TOP, DIRECTION.BOTTOM].includes(end_dir);\n//     const arrowspan = [DIRECTION.TOP, DIRECTION.LEFT].includes(end_dir) ? -5 : 5;\n//     const endX = isVerticalEnd ? p2[0] : p2[0] + arrowspan;\n//     const endY = isVerticalEnd ? p2[1] + arrowspan : p2[1];\n//     if(isSameDirection) {\n//         let span = Math.abs(isVerticalStart ? (endY - p1[1]) : (endX - p1[0]))\n//         span = Math.min(span, 50);\n//         const symb = [DIRECTION.RIGHT, DIRECTION.BOTTOM].includes(end_dir)\n//         span = symb ? span : - span;\n//         const cp1 = isVerticalStart ? [p1[0], p1[1] + span] : [p1[0] + span, p1[1]];\n//         const cp2 = isVerticalEnd ? [endX, endY + span] : [endX + span, endY];\n//         return [ \n//             ...cp1,\n//             ...cp2,\n//             endX, endY ];\n//     }\n//     let spanStart = (anticlock ? -5 : 1) * (isVerticalStart ? (endY - p1[1]) / 2 : (endX - p1[0]) / 2)\n//     let spanEnd = (anticlock ? -4 : 1) * (isVerticalEnd ? (p1[1] - endY) / 2 : (p1[0] - endX) / 2)\n//     let u1 = spanStart / Math.abs(spanStart);\n//     spanStart = u1 * Math.min(Math.abs(spanStart), 50);\n//     let u2 = spanEnd / Math.abs(spanEnd);\n//     spanEnd = u2 * Math.min(Math.abs(spanEnd), 50);\n//     const cp1 = isVerticalStart ? [p1[0], p1[1] + spanStart] : [p1[0] + spanStart, p1[1]];\n//     const cp2 = isVerticalEnd ? [endX, endY + spanEnd] : [endX + spanEnd, endY];\n//     return [ \n//         ...cp1,\n//         ...cp2,\n//         endX, endY ];\n// }\nfunction _resolveControlPoint(p, dir, spanx, spany){\n    if(dir === DIRECTION.TOP){\n        return [p[0], p[1]-spany]\n    }\n    if(dir === DIRECTION.BOTTOM){\n        return [p[0], p[1]+spany]\n    }\n    if(dir === DIRECTION.LEFT){\n        return [p[0]-spanx, p[1]]\n    }\n    if(dir === DIRECTION.RIGHT){\n        return [p[0]+spanx, p[1]]\n    }\n}\n\nexport function bezierPoints(p1, p2, start_dir = DIRECTION.TOP, end_dir = DIRECTION.TOP, minSpanX = 0, minSpanY = 0) {\n    const spanx = Math.max(Math.abs((p1[0] - p2[0])/2), minSpanX);\n    const spany = Math.max(Math.abs((p1[1] - p2[1])/2), minSpanY);\n    const cp1 = _resolveControlPoint(p1, start_dir, spanx, spany);\n    const cp2 = _resolveControlPoint(p2, end_dir, spanx, spany);\n    const arrowspan = [DIRECTION.TOP, DIRECTION.LEFT].includes(end_dir) ? -5 : 5;\n    const isVerticalEnd = [DIRECTION.TOP, DIRECTION.BOTTOM].includes(end_dir);\n    const endX = isVerticalEnd ? p2[0] : p2[0] + arrowspan;\n    const endY = isVerticalEnd ? p2[1] + arrowspan : p2[1];\n    return [ \n        ...cp1,\n        ...cp2,\n        endX, endY];\n}\n\nexport function bezierPoint(t, P) {\n    const q = 1-t;\n    const x = q*q*q*P[0] + 3*q*q*t*P[2] + 3*q*t*t*P[4] + t*t*t*P[6];\n    const y = q*q*q*P[1] + 3*q*q*t*P[3] + 3*q*t*t*P[5] + t*t*t*P[7];\n    const u = q*q*(P[2]-P[0]) + 2*t*q*(P[4]-P[2]) + t*t*(P[6]-P[4]);\n    const v = q*q*(P[3]-P[1]) + 2*t*q*(P[5]-P[3]) + t*t*(P[7]-P[5]);\n    let angle = Math.atan2(v, u);\n    // console.log(angle * 180)\n    // if(angle < 0) {\n    //     angle = Math.PI + angle;\n    // }\n    return [x, y, angle];\n}\n\n// export function bezierPoints(p1, p2, start_vec, end_vec) {\n\n// }\n\nexport function distToBezierSegmentSquared(p, points) {\n    const b = new Bezier(...points);\n\n    const point = b.project({ x: p[0], y: p[1] });\n    const d = dist2(p, [ point.x, point.y ]);\n    return d;\n}\n\nexport function getBezierAngle(t, sx, sy, cp1x, cp1y, cp2x, cp2y, ex, ey) {\n  var dx = Math.pow(1-t, 2)*(cp1x-sx) + 2*t*(1-t)*(cp2x-cp1x) + t * t * (ex - cp2x);\n  var dy = Math.pow(1-t, 2)*(cp1y-sy) + 2*t*(1-t)*(cp2y-cp1y) + t * t * (ey - cp2y);\n  return -Math.atan2(dx, dy) + 0.5*Math.PI;\n}\n\n\nexport function getInstanceHeight(instance) {\n    const rect = instance.getBoundingRect();\n    let min_y = Infinity;\n    let max_y = -Infinity;\n    let min_x = Infinity;\n    let max_x = -Infinity;\n    rect.forEach(point => {\n        max_y = Math.max(max_y, point[1]);\n        min_y = Math.min(min_y, point[1]);\n        max_x = Math.max(max_x, point[0]);\n        min_x = Math.min(min_x, point[0]);\n    });\n    return {\n        height: max_y - min_y,\n        width: max_x - min_x,\n    }\n}\n\nexport function polylinePoints(p1, p2, start_dir = DIRECTION.TOP, end_dir = DIRECTION.TOP, minSpanX = 10, minSpanY = 10, isSelf) {\n    const dirSpan = Math.abs(start_dir - end_dir);\n    // const spanx = Math.max(Math.abs((p1[0] - p2[0])/2), minSpanX);\n    // const spany = Math.max(Math.abs((p1[1] - p2[1])/2), minSpanY);\n    const isVerticalStart = (start_dir === DIRECTION.TOP || start_dir === DIRECTION.BOTTOM);\n    let points = [];\n    switch (dirSpan) {\n        case 0:\n            // 都按向右好了\n            if(start_dir === DIRECTION.TOP) {\n                const y = Math.min(p1[1], p2[1]);\n                const yp = y - minSpanY;\n                points.push([p1[0], yp]);\n                points.push([p2[0], yp]);\n            }\n            if(start_dir === DIRECTION.BOTTOM) {\n                const y = Math.max(p1[1], p2[1]);\n                const yp = y + minSpanY;\n                points.push([p1[0], yp]);\n                points.push([p2[0], yp]);\n            }\n            if(start_dir === DIRECTION.LEFT) {\n                const x = Math.min(p1[0], p2[0]);\n                const xp = x - minSpanX;\n                points.push([xp, p1[1]]);\n                points.push([xp, p2[1]]);\n            }\n            if(start_dir === DIRECTION.RIGHT) {\n                const x = Math.max(p1[0], p2[0]);\n                const xp = x + minSpanX;\n                points.push([xp, p1[1]]);\n                points.push([xp, p2[1]]);\n            }\n            break;\n        case 1:\n        case 3:  \n            if(isSelf) {\n                if(!isVerticalStart) {\n                    points.push([p1[0] + minSpanX, p1[1]]);\n                    points.push([p1[0] + minSpanX, p2[1] + minSpanY]);\n                    points.push([p2[0], p2[1] + minSpanY]);\n                } else {\n                    points.push([p1[0], p1[1] + minSpanY]);\n                    points.push([p2[0] + minSpanX, p1[1] + minSpanY]);\n                    points.push([p2[0] + minSpanX, p2[1]]);\n                }\n            } else {\n                const point = isVerticalStart ? [p1[0], p2[1]]: [p2[0], p1[1]]\n                points.push(point);\n            }\n            break;\n        case 2:\n            const pmiddle = [\n                (p1[0] - p2[0])/2 + p2[0],\n                (p1[1] - p2[1])/2 + p2[1]\n            ]; \n            if(isVerticalStart) {\n                points.push([p1[0], pmiddle[1]])\n                points.push([p2[0], pmiddle[1]])\n            } else {\n                points.push([pmiddle[0], p1[1]])\n                points.push([pmiddle[0], p2[1]])\n            }\n            break;\n        default:\n            break;\n    }\n    points.unshift(p1);\n    points.push(p2);\n    return points;\n}\n\nfunction minusVec(p1, p2) {\n    return [p1[0] - p2[0], p1[1] - p2[1]]\n}\n\nfunction absVec(vec) {\n    return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);\n}\n\nfunction scaleVec(vec, scale) {\n    return [vec[0] * scale, vec[1] * scale];\n}\n\nexport function makeRadiusFromVector(pbefore, p, pnext, radius) {\n    const vec1 = minusVec(p, pbefore);\n    const vec2 = minusVec(p, pnext);\n    const absVec1 = absVec(vec1);\n    const absVec2 = absVec(vec2);\n    if(!absVec1 || !absVec2) {\n        return {\n            p1: null,\n            p2: null,\n        }\n    }\n    const r1 = scaleVec(vec1, radius/absVec1);\n    const r2 = scaleVec(vec2, radius/absVec2);\n    return {\n        p1: minusVec(p, r1),\n        p2: minusVec(p, r2),\n    }\n}"],"file":"functions.js"}
{"version":3,"sources":["core/layout/er-layout/er-layout.js"],"names":["ERLayout","configs","flowStack","flowLinkStack","erNodes","reOrder","entityRelationship","er","root","nodes","idMap","forEach","node","traverse","n","push","type","source","layoutMeta","makeLink","property","from","toProperty","to","meta","isObjectRef","id1","id2","fromMeta","includes","isParentRef","instance","jflow","links","x","lineMapping","size","computeNodeAnchor","recorded","relativeAnchor","parentRef","diagramWeight","getJflowInstance","nx","ny","anchor","length"],"mappings":"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","sourcesContent":["\nimport { makeER } from './er-node';\n/**\n    ER layout\n\n    Entity Relationship Structure\n    tree = [\n        {\n            type: 'node',\n            id: 'uniqueID',\n            properties: [\n                {\n                    name: 'xxxx',\n                    ref: someUniqueId,\n                    description: 'xxxxxx',\n                },\n                ...\n            ]\n        },\n        ...\n    ]\n    \n    * @implements {Layout}\n */\n\nclass ERLayout {\n    constructor(configs) {\n        this.static = false;\n        this.flowStack = [];\n        this.flowLinkStack = [];\n        this.erNodes = [];\n        this.reOrder(configs.entityRelationship);\n    }\n    /**\n     * 从 tree 计算布局\n     * @param {AstNode} tree - ER 树\n     */\n    reOrder(er, root) {\n        this.er = er;\n        this.flowStack = [];\n        this.flowLinkStack = [];\n        const nodes = makeER(this.er);\n        const idMap = [];\n        nodes.forEach(node => {\n            node.traverse((n) => {\n                this.flowStack.push({\n                    type: n.type,\n                    configs: n.source,\n                    layoutMeta: n,\n                })\n            });\n            node.makeLink(configs => {\n                const {\n                    from: property,\n                    to: toProperty,\n                    meta,\n                } = configs;\n                if(meta.isObjectRef) {\n                    const id1 = `${property}-${toProperty}`;\n                    const id2 = `${toProperty}-${property}`;\n                    \n                    const fromMeta = meta.from;\n                    if(idMap.includes(id1) || idMap.includes(id2)) {\n                        return;\n                    }\n                    if(!fromMeta.source.isParentRef) {  \n                        idMap.push(id1);\n                        idMap.push(id2);\n                        this.flowLinkStack.push(configs)\n                    }\n                } else {\n                    this.flowLinkStack.push(configs)\n                }\n               \n            })\n        });\n        this.erNodes = nodes;\n    }\n\n    staticCheck(instance, jflow) {\n        return false;\n    }\n\n    reflow(jflow){\n        const links = this.flowLinkStack;\n        const nodes = this.erNodes;\n        let x = 0;\n        const lineMapping = {};\n        const size = 1000;\n        function computeNodeAnchor(node, recorded = []) {\n            let relativeAnchor = [0, 0];\n            \n            \n            if (node.parentRef) {\n                if(recorded.includes(node.parentRef)) {\n                    // debugger;\n                    return [\n                        relativeAnchor[0] - (size/2) + node.source.diagramWeight * size,\n                        relativeAnchor[1]\n                    ];\n                }\n                recorded.push(node.parentRef);\n                \n                relativeAnchor = computeNodeAnchor(node.parentRef, recorded);\n                return [\n                    relativeAnchor[0] - (size/2) + node.source.diagramWeight * size,\n                    relativeAnchor[1] + 600,\n                ];\n            } else {\n                return relativeAnchor;\n            }\n        }\n        this.erNodes.forEach(node => {\n            const instance = node.getJflowInstance();\n            const [nx, ny] = computeNodeAnchor(node);\n            if(!lineMapping[ny]) {\n                lineMapping[ny] = [];\n            }\n            lineMapping[ny].push(node);\n            instance.anchor = [nx + lineMapping[ny].length * 500, ny];\n            x+=300\n        });\n        // debugger\n        // // Kahn’s Algorithm\n        // // Calcuate the incoming degree of each vertex\n        // const vertices = nodes.slice();\n        // debugger\n        // const inDegree = {};\n        // vertices.forEach(v => {\n        //     v.adjacencyList.forEach(p => {\n        //         const name = p.name;\n        //         inDegree[name] = inDegree[name] + 1 || 1;\n        //     })\n            \n        // })\n        // console.log(inDegree)\n        // debugger\n\n        // // Create a queue which stores the vertex without dependencies\n        // const queue = vertices.filter((v) => !inDegree[v.name]);\n        // console.log(queue)\n        // debugger\n        // const topNums = {};\n        // let index = 0;\n        // while (queue.length) {\n        //     const v = queue.shift();\n        //     topNums[v.name] = index++;\n        //     v.adjacencyList.forEach(neighbor => {\n        //         const name = neighbor.name;\n        //         inDegree[name]--;\n        //         if (inDegree[name] === 0) {\n        //             queue.push(neighbor);\n        //         }\n        //     });\n        // }\n        // if (index !== vertices.length) {\n        //     console.log(\"Detect a cycle\");\n        // }\n        // console.log(topNums);\n    }\n}\n\nexport default ERLayout;"],"file":"er-layout.js"}
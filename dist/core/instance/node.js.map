{"version":3,"sources":["core/instance/node.js"],"names":["Node","configs","_rawConfigs","anchor","absolutePosition","Object","keys","forEach","k","undefined","C","constructor","t","Instance"],"mappings":";;;;;;;;;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;IACMA,I;;;;;AACF,kBAA0B;AAAA;;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AAAA;;AACtB,8BAAMA,OAAN;AACA,UAAKC,WAAL,GAAmBD,OAAnB,CAFsB,CAGtB;AACA;;AACA,UAAKE,MAAL,GAAwBF,OAAO,CAACE,MAAR,IAAkB,CAAC,CAAD,EAAI,CAAJ,CAA1C;AACA,UAAKC,gBAAL,GAAwBH,OAAO,CAACG,gBAAhC,CANsB,CAOtB;;AAPsB;AAQzB;;;;WAED,mBAAUH,OAAV,EAAmB;AAAA;;AACfI,MAAAA,MAAM,CAACC,IAAP,CAAYL,OAAZ,EAAqBM,OAArB,CAA6B,UAAAC,CAAC,EAAI;AAC9B,YAAGP,OAAO,CAACO,CAAD,CAAP,KAAeC,SAAf,IAA4BR,OAAO,CAACO,CAAD,CAAP,KAAe,IAA9C,EAAoD;AAChD,UAAA,MAAI,CAACA,CAAD,CAAJ,GAAUP,OAAO,CAACO,CAAD,CAAjB;AACA,UAAA,MAAI,CAACN,WAAL,CAAiBM,CAAjB,IAAsBP,OAAO,CAACO,CAAD,CAA7B;AACH;AACJ,OALD;AAMH,K,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAKI;AACJ;AACA;AACA;;;;WACI,iBAAQ;AACJ,UAAME,CAAC,GAAG,KAAKC,WAAf;AACA,UAAMC,CAAC,GAAG,IAAIF,CAAJ,CAAM,KAAKR,WAAX,CAAV;AACA,aAAOU,CAAP;AACH;;;;EA3EcC,oB;;eA8EJb,I","sourcesContent":["import Instance from './instance';\nimport { nextDirection } from '../utils/constance';\n\n/**\n * 绝对定位 配置， 绝对定位不受布局影响，相对于当前组来定位\n * @typedef {object} Node~AbsolutePosition \n * @property {number} top       - 上距离\n * @property {number} bottom    - 下距离\n * @property {number} right     - 右距离\n * @property {number} left      - 左距离\n */\n/**\n * Node 配置\n * @typedef {Instance~Configs} Node~Configs \n * @property {number[]} anchor - 坐标\n * @property {Node~AbsolutePosition} absolutePosition - 绝对定位位置\n */\n/**\n * 节点基类\n * @constructor Node\n * @extends Instance\n * @param {Node~Configs} configs - 节点配置\n */\nclass Node extends Instance {\n    constructor(configs = {}) {\n        super(configs);\n        this._rawConfigs = configs;\n        // for layout\n        // this._intersections = [];\n        this.anchor =           configs.anchor || [0, 0];\n        this.absolutePosition = configs.absolutePosition;\n        // this.margin =   configs.margin || 5;\n    }\n\n    setConfig(configs) {\n        Object.keys(configs).forEach(k => {\n            if(configs[k] !== undefined && configs[k] !== null) {\n                this[k] = configs[k]\n                this._rawConfigs[k] = configs[k];\n            }\n        });\n    }\n\n    // end: from | to\n    // from 逆时针, to 顺时针\n    // checkLinked(interDir, end) {\n    //     if(this._intersections.find(i => i === interDir)) {\n    //         interDir = nextDirection(interDir, end === 'to');\n    //     } else {\n    //         this._intersections.push(interDir)\n    //     }\n    //     return interDir;\n    // }\n\n    /* renderFocus(ctx) {\n        const points = this.getBoundingRect();\n        if(points.length !== 4) return;\n        const margin = this.margin;\n        const [p0, p1, p2, p3] = points;\n        const width = p1[0] - p0[0];\n        const height = p3[1] - p0[1];\n        const w = width * 0.2;\n        const h = height * 0.2;\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(p0[0] - margin, p0[1] - margin + h);\n        ctx.lineTo(p0[0] - margin, p0[1] - margin);\n        ctx.lineTo(p0[0] - margin + w, p0[1] - margin);\n        ctx.stroke();\n\n        ctx.beginPath();\n        ctx.moveTo(p1[0] + margin - w, p1[1] - margin);\n        ctx.lineTo(p1[0] + margin, p1[1] - margin);\n        ctx.lineTo(p1[0] + margin, p1[1] - margin + h);\n        ctx.stroke();\n\n        ctx.beginPath();\n        ctx.moveTo(p2[0] + margin, p2[1] + margin - h);\n        ctx.lineTo(p2[0] + margin, p2[1] + margin);\n        ctx.lineTo(p2[0] + margin - w, p2[1] + margin);\n        ctx.stroke();\n\n        ctx.beginPath();\n        ctx.moveTo(p3[0] - margin + w, p3[1] + margin);\n        ctx.lineTo(p3[0] - margin, p3[1] + margin);\n        ctx.lineTo(p3[0] - margin, p3[1] + margin - h);\n        ctx.stroke();\n        ctx.restore();\n    } */\n\n    /**\n     * 克隆当前节点.\n     * @return {Node} 当前节点的副本\n     */\n    clone() {\n        const C = this.constructor;\n        const t = new C(this._rawConfigs);\n        return t;\n    }\n}\n\nexport default Node;"],"file":"node.js"}